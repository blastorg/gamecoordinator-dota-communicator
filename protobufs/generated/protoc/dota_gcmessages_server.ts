// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.176.1
//   protoc               v5.26.1
// source: dota_gcmessages_server.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";
import {
  CMatchAdditionalUnitInventory,
  CMatchHeroSelectEvent,
  CMatchPlayerAbilityUpgrade,
  CMatchPlayerPermanentBuff,
  CMatchPlayerTimedStats,
  CMatchTeamTimedStats,
  CMsgClientToGCRerollPlayerChallenge,
  CMsgDOTAFantasyPlayerStats,
  CMsgDOTAMatch,
  CMsgDOTARealtimeGameStatsTerse,
  CMsgMapStatsSnapshot,
  CMsgStickerHeroes,
  CMsgTrackedStat,
  CProtoItemHeroStatue,
  DOTATournamentEvents,
  dOTATournamentEventsFromJSON,
  dOTATournamentEventsToJSON,
  ENewBloomGiftingResponse,
  eNewBloomGiftingResponseFromJSON,
  eNewBloomGiftingResponseToJSON,
} from "./dota_gcmessages_common";
import { CMsgCraftworksComponents } from "./dota_gcmessages_common_craftworks";
import { CMsgLeaverState, CMvpData } from "./dota_gcmessages_common_match_management";
import { CMsgOverworldMatchRewards } from "./dota_gcmessages_common_overworld";
import {
  CMsgDOTACombatLogEntry,
  DOTABotDifficulty,
  dOTABotDifficultyFromJSON,
  dOTABotDifficultyToJSON,
  DOTAGameState,
  dOTAGameStateFromJSON,
  dOTAGameStateToJSON,
  dotaGcTeam,
  dotaGcTeamFromJSON,
  dotaGcTeamToJSON,
  DOTALeaverStatusT,
  dOTALeaverStatusTFromJSON,
  dOTALeaverStatusTToJSON,
  EEvent,
  eEventFromJSON,
  eEventToJSON,
  EPlayerChallengeHistoryType,
  ePlayerChallengeHistoryTypeFromJSON,
  ePlayerChallengeHistoryTypeToJSON,
} from "./dota_shared_enums";
import { CMsgEconPlayerStrangeCountAdjustment } from "./econ_gcmessages";
import { CExtraMsgBlock } from "./gcsdk_gcmessages";
import {
  ENetworkDisconnectionReason,
  eNetworkDisconnectionReasonFromJSON,
  eNetworkDisconnectionReasonToJSON,
} from "./network_connection";

export enum EPoorNetworkConditionsType {
  k_EPoorNetworkConditions_None = 0,
  k_EPoorNetworkConditions_Unknown = 1,
  k_EPoorNetworkConditions_MassDisconnect = 2,
  k_EPoorNetworkConditions_ExcessBadQosIntervals = 3,
}

export function ePoorNetworkConditionsTypeFromJSON(object: any): EPoorNetworkConditionsType {
  switch (object) {
    case 0:
    case "k_EPoorNetworkConditions_None":
      return EPoorNetworkConditionsType.k_EPoorNetworkConditions_None;
    case 1:
    case "k_EPoorNetworkConditions_Unknown":
      return EPoorNetworkConditionsType.k_EPoorNetworkConditions_Unknown;
    case 2:
    case "k_EPoorNetworkConditions_MassDisconnect":
      return EPoorNetworkConditionsType.k_EPoorNetworkConditions_MassDisconnect;
    case 3:
    case "k_EPoorNetworkConditions_ExcessBadQosIntervals":
      return EPoorNetworkConditionsType.k_EPoorNetworkConditions_ExcessBadQosIntervals;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum EPoorNetworkConditionsType");
  }
}

export function ePoorNetworkConditionsTypeToJSON(object: EPoorNetworkConditionsType): string {
  switch (object) {
    case EPoorNetworkConditionsType.k_EPoorNetworkConditions_None:
      return "k_EPoorNetworkConditions_None";
    case EPoorNetworkConditionsType.k_EPoorNetworkConditions_Unknown:
      return "k_EPoorNetworkConditions_Unknown";
    case EPoorNetworkConditionsType.k_EPoorNetworkConditions_MassDisconnect:
      return "k_EPoorNetworkConditions_MassDisconnect";
    case EPoorNetworkConditionsType.k_EPoorNetworkConditions_ExcessBadQosIntervals:
      return "k_EPoorNetworkConditions_ExcessBadQosIntervals";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum EPoorNetworkConditionsType");
  }
}

export interface CMsgPoorNetworkConditions {
  detectionType?: EPoorNetworkConditionsType | undefined;
  players: CMsgPoorNetworkConditions_Player[];
}

export interface CMsgPoorNetworkConditions_Player {
  accountId?: number | undefined;
  disconnectReason?: ENetworkDisconnectionReason | undefined;
  numBadIntervals?: number | undefined;
  peakLossPct?: number | undefined;
}

export interface CMsgGameserverCrash {
  matchId?: string | undefined;
  lobbyId?: string | undefined;
  gameState?: DOTAGameState | undefined;
  sentinelSaveTime?: number | undefined;
  customGameId?: string | undefined;
  tournamentId?: number | undefined;
  serverSteamId?: string | undefined;
  serverPublicIpAddr?: number | undefined;
  serverPort?: number | undefined;
  serverCluster?: number | undefined;
  pid?: number | undefined;
  engine?: number | undefined;
}

export interface CMsgConnectedPlayers {
  connectedPlayers: CMsgConnectedPlayers_Player[];
  disconnectedPlayers: CMsgConnectedPlayers_Player[];
  gameState?: DOTAGameState | undefined;
  firstBloodHappened?: boolean | undefined;
  poorNetworkConditions?: CMsgPoorNetworkConditions | undefined;
  sendReason?: CMsgConnectedPlayers_SendReason | undefined;
  radiantKills?: number | undefined;
  direKills?: number | undefined;
  radiantLead?: number | undefined;
  buildingState?: number | undefined;
  playerDraft: CMsgConnectedPlayers_PlayerDraft[];
}

export enum CMsgConnectedPlayers_SendReason {
  INVALID = 0,
  HEARTBEAT = 1,
  GAME_STATE = 2,
  FIRST_BLOOD = 3,
  PLAYER_CONNECTED = 4,
  PLAYER_HERO = 5,
  PLAYER_DISCONNECTED_CONSEQUENCES = 6,
  PLAYER_DISCONNECTED_NOCONSEQUENCES = 7,
  GAMESTATE_TIMEOUT = 10,
  MASS_DISCONNECT = 11,
  KILLS = 13,
  BUILDING_STATE = 14,
}

export function cMsgConnectedPlayers_SendReasonFromJSON(object: any): CMsgConnectedPlayers_SendReason {
  switch (object) {
    case 0:
    case "INVALID":
      return CMsgConnectedPlayers_SendReason.INVALID;
    case 1:
    case "HEARTBEAT":
      return CMsgConnectedPlayers_SendReason.HEARTBEAT;
    case 2:
    case "GAME_STATE":
      return CMsgConnectedPlayers_SendReason.GAME_STATE;
    case 3:
    case "FIRST_BLOOD":
      return CMsgConnectedPlayers_SendReason.FIRST_BLOOD;
    case 4:
    case "PLAYER_CONNECTED":
      return CMsgConnectedPlayers_SendReason.PLAYER_CONNECTED;
    case 5:
    case "PLAYER_HERO":
      return CMsgConnectedPlayers_SendReason.PLAYER_HERO;
    case 6:
    case "PLAYER_DISCONNECTED_CONSEQUENCES":
      return CMsgConnectedPlayers_SendReason.PLAYER_DISCONNECTED_CONSEQUENCES;
    case 7:
    case "PLAYER_DISCONNECTED_NOCONSEQUENCES":
      return CMsgConnectedPlayers_SendReason.PLAYER_DISCONNECTED_NOCONSEQUENCES;
    case 10:
    case "GAMESTATE_TIMEOUT":
      return CMsgConnectedPlayers_SendReason.GAMESTATE_TIMEOUT;
    case 11:
    case "MASS_DISCONNECT":
      return CMsgConnectedPlayers_SendReason.MASS_DISCONNECT;
    case 13:
    case "KILLS":
      return CMsgConnectedPlayers_SendReason.KILLS;
    case 14:
    case "BUILDING_STATE":
      return CMsgConnectedPlayers_SendReason.BUILDING_STATE;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum CMsgConnectedPlayers_SendReason");
  }
}

export function cMsgConnectedPlayers_SendReasonToJSON(object: CMsgConnectedPlayers_SendReason): string {
  switch (object) {
    case CMsgConnectedPlayers_SendReason.INVALID:
      return "INVALID";
    case CMsgConnectedPlayers_SendReason.HEARTBEAT:
      return "HEARTBEAT";
    case CMsgConnectedPlayers_SendReason.GAME_STATE:
      return "GAME_STATE";
    case CMsgConnectedPlayers_SendReason.FIRST_BLOOD:
      return "FIRST_BLOOD";
    case CMsgConnectedPlayers_SendReason.PLAYER_CONNECTED:
      return "PLAYER_CONNECTED";
    case CMsgConnectedPlayers_SendReason.PLAYER_HERO:
      return "PLAYER_HERO";
    case CMsgConnectedPlayers_SendReason.PLAYER_DISCONNECTED_CONSEQUENCES:
      return "PLAYER_DISCONNECTED_CONSEQUENCES";
    case CMsgConnectedPlayers_SendReason.PLAYER_DISCONNECTED_NOCONSEQUENCES:
      return "PLAYER_DISCONNECTED_NOCONSEQUENCES";
    case CMsgConnectedPlayers_SendReason.GAMESTATE_TIMEOUT:
      return "GAMESTATE_TIMEOUT";
    case CMsgConnectedPlayers_SendReason.MASS_DISCONNECT:
      return "MASS_DISCONNECT";
    case CMsgConnectedPlayers_SendReason.KILLS:
      return "KILLS";
    case CMsgConnectedPlayers_SendReason.BUILDING_STATE:
      return "BUILDING_STATE";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum CMsgConnectedPlayers_SendReason");
  }
}

export interface CMsgConnectedPlayers_Player {
  steamId?: string | undefined;
  heroId?: number | undefined;
  leaverState?: CMsgLeaverState | undefined;
  disconnectReason?: ENetworkDisconnectionReason | undefined;
}

export interface CMsgConnectedPlayers_PlayerDraft {
  steamId?: string | undefined;
  team?: dotaGcTeam | undefined;
  teamSlot?: number | undefined;
}

export interface CMsgGameServerInfo {
  serverPublicIpAddr?: number | undefined;
  serverPrivateIpAddr?: number | undefined;
  serverPort?: number | undefined;
  serverTvPort?: number | undefined;
  assignedServerTvPort?: number | undefined;
  legacyServerSteamdatagramAddress?: Buffer | undefined;
  serverKey?: string | undefined;
  serverHibernation?: boolean | undefined;
  serverType?: CMsgGameServerInfo_ServerType | undefined;
  serverRegion?: number | undefined;
  serverLoadavg?: number | undefined;
  serverTvBroadcastTime?: number | undefined;
  serverGameTime?: number | undefined;
  serverRelayConnectedSteamId?: string | undefined;
  relaySlotsMax?: number | undefined;
  relaysConnected?: number | undefined;
  relayClientsConnected?: number | undefined;
  relayedGameServerSteamId?: string | undefined;
  parentRelayCount?: number | undefined;
  tvSecretCode?: string | undefined;
  serverVersion?: number | undefined;
  serverCluster?: number | undefined;
  allowCustomGames?: CMsgGameServerInfo_CustomGames | undefined;
  buildVersion?: number | undefined;
  srcdsInstance?: number | undefined;
  devForceServerType?: boolean | undefined;
  isRecordingMatchTrainingData?: boolean | undefined;
}

export enum CMsgGameServerInfo_ServerType {
  UNSPECIFIED = 0,
  GAME = 1,
  PROXY = 2,
  DOTA_ONLY = 4,
  CUSTOM_GAME_ONLY = 5,
  EVENT_GAME_ONLY = 6,
}

export function cMsgGameServerInfo_ServerTypeFromJSON(object: any): CMsgGameServerInfo_ServerType {
  switch (object) {
    case 0:
    case "UNSPECIFIED":
      return CMsgGameServerInfo_ServerType.UNSPECIFIED;
    case 1:
    case "GAME":
      return CMsgGameServerInfo_ServerType.GAME;
    case 2:
    case "PROXY":
      return CMsgGameServerInfo_ServerType.PROXY;
    case 4:
    case "DOTA_ONLY":
      return CMsgGameServerInfo_ServerType.DOTA_ONLY;
    case 5:
    case "CUSTOM_GAME_ONLY":
      return CMsgGameServerInfo_ServerType.CUSTOM_GAME_ONLY;
    case 6:
    case "EVENT_GAME_ONLY":
      return CMsgGameServerInfo_ServerType.EVENT_GAME_ONLY;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum CMsgGameServerInfo_ServerType");
  }
}

export function cMsgGameServerInfo_ServerTypeToJSON(object: CMsgGameServerInfo_ServerType): string {
  switch (object) {
    case CMsgGameServerInfo_ServerType.UNSPECIFIED:
      return "UNSPECIFIED";
    case CMsgGameServerInfo_ServerType.GAME:
      return "GAME";
    case CMsgGameServerInfo_ServerType.PROXY:
      return "PROXY";
    case CMsgGameServerInfo_ServerType.DOTA_ONLY:
      return "DOTA_ONLY";
    case CMsgGameServerInfo_ServerType.CUSTOM_GAME_ONLY:
      return "CUSTOM_GAME_ONLY";
    case CMsgGameServerInfo_ServerType.EVENT_GAME_ONLY:
      return "EVENT_GAME_ONLY";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum CMsgGameServerInfo_ServerType");
  }
}

export enum CMsgGameServerInfo_CustomGames {
  BOTH = 0,
  NONE = 1,
  ONLY = 2,
  EVENT = 3,
}

export function cMsgGameServerInfo_CustomGamesFromJSON(object: any): CMsgGameServerInfo_CustomGames {
  switch (object) {
    case 0:
    case "BOTH":
      return CMsgGameServerInfo_CustomGames.BOTH;
    case 1:
    case "NONE":
      return CMsgGameServerInfo_CustomGames.NONE;
    case 2:
    case "ONLY":
      return CMsgGameServerInfo_CustomGames.ONLY;
    case 3:
    case "EVENT":
      return CMsgGameServerInfo_CustomGames.EVENT;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum CMsgGameServerInfo_CustomGames");
  }
}

export function cMsgGameServerInfo_CustomGamesToJSON(object: CMsgGameServerInfo_CustomGames): string {
  switch (object) {
    case CMsgGameServerInfo_CustomGames.BOTH:
      return "BOTH";
    case CMsgGameServerInfo_CustomGames.NONE:
      return "NONE";
    case CMsgGameServerInfo_CustomGames.ONLY:
      return "ONLY";
    case CMsgGameServerInfo_CustomGames.EVENT:
      return "EVENT";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum CMsgGameServerInfo_CustomGames");
  }
}

export interface CMsgLeaverDetected {
  steamId?: string | undefined;
  leaverStatus?: DOTALeaverStatusT | undefined;
  leaverState?: CMsgLeaverState | undefined;
  serverCluster?: number | undefined;
  disconnectReason?: ENetworkDisconnectionReason | undefined;
  poorNetworkConditions?: CMsgPoorNetworkConditions | undefined;
}

export interface CMsgLeaverDetectedResponse {
  result?: number | undefined;
}

export interface CMsgDOTAFantasyFinalPlayerStats {
  stats: CMsgDOTAFantasyPlayerStats[];
}

export interface CMsgDOTAFantasyLivePlayerStats {
  stats: CMsgDOTAFantasyPlayerStats[];
}

export interface CMsgServerToGCRealtimeStats {
  delayed?: CMsgDOTARealtimeGameStatsTerse | undefined;
}

export interface CMsgGCToServerRealtimeStatsStartStop {
  delayed?: boolean | undefined;
}

export interface CMsgGCToServerUpdateSteamBroadcasting {
  active?: boolean | undefined;
}

export interface CMsgSignOutGameplayStats {
  teams: CMsgSignOutGameplayStats_CTeam[];
}

export interface CMsgSignOutGameplayStats_CPlayer {
  steamId?: string | undefined;
  playerSlot?: number | undefined;
  heroId?: number | undefined;
  timedPlayerStats: CMatchPlayerTimedStats[];
}

export interface CMsgSignOutGameplayStats_CTeam {
  isWinningTeam?: boolean | undefined;
  isRadiantTeam?: boolean | undefined;
  timedTeamStats: CMatchTeamTimedStats[];
  players: CMsgSignOutGameplayStats_CPlayer[];
}

export interface CMsgGameMatchSignOut {
  matchId?: string | undefined;
  duration?: number | undefined;
  goodGuysWin?: boolean | undefined;
  date?: number | undefined;
  teams: CMsgGameMatchSignOut_CTeam[];
  towerStatus: number[];
  barracksStatus: number[];
  cluster?: number | undefined;
  serverAddr?: string | undefined;
  firstBloodTime?: number | undefined;
  eventScore?: number | undefined;
  fantasyStats: CMsgDOTAFantasyPlayerStats[];
  playerStrangeCountAdjustments: CMsgEconPlayerStrangeCountAdjustment[];
  automaticSurrender?: boolean | undefined;
  serverVersion?: number | undefined;
  poorNetworkConditions?: CMsgPoorNetworkConditions | undefined;
  additionalMsgs: CMsgGameMatchSignOut_CAdditionalSignoutMsg[];
  socialFeedEvents: CMsgGameMatchSignOut_CSocialFeedMatchEvent[];
  averageNetworthDelta?: number | undefined;
  customGameData?: CMsgGameMatchSignOut_CCustomGameData | undefined;
  matchFlags?: number | undefined;
  teamScores: number[];
  preGameDuration?: number | undefined;
  eventGameLeaderboardEntries: CMsgGameMatchSignOut_EventGameLeaderboardEntry[];
  wardPlacements: CMsgGameMatchSignOut_WardPlacement[];
  gameplayStats?: CMsgSignOutGameplayStats | undefined;
  extraMessages: CExtraMsgBlock[];
  trainingDataRecorded?: boolean | undefined;
  winningTeam?: dotaGcTeam | undefined;
  normalizedWinProbabilityDiff?: number | undefined;
  matchTrackedStats: CMsgTrackedStat[];
}

export interface CMsgGameMatchSignOut_CTeam {
  players: CMsgGameMatchSignOut_CTeam_CPlayer[];
  teamTrackedStats: CMsgTrackedStat[];
}

export interface CMsgGameMatchSignOut_CTeam_CPlayer {
  steamId?: string | undefined;
  heroId?: number | undefined;
  items: number[];
  itemPurchaseTimes: number[];
  gold?: number | undefined;
  kills?: number | undefined;
  deaths?: number | undefined;
  assists?: number | undefined;
  leaverStatus?: number | undefined;
  lastHits?: number | undefined;
  denies?: number | undefined;
  goldPerMin?: number | undefined;
  xpPerMinute?: number | undefined;
  goldSpent?: number | undefined;
  level?: number | undefined;
  scaledHeroDamage?: number | undefined;
  scaledTowerDamage?: number | undefined;
  scaledHeroHealing?: number | undefined;
  timeLastSeen?: number | undefined;
  supportAbilityValue?: number | undefined;
  partyId?: string | undefined;
  claimedFarmGold?: number | undefined;
  supportGold?: number | undefined;
  claimedDenies?: number | undefined;
  claimedMisses?: number | undefined;
  misses?: number | undefined;
  netWorth?: number | undefined;
  heroDamage?: number | undefined;
  towerDamage?: number | undefined;
  heroHealing?: number | undefined;
  abilityUpgrades: CMatchPlayerAbilityUpgrade[];
  additionalUnitsInventory: CMatchAdditionalUnitInventory[];
  permanentBuffs: CMatchPlayerPermanentBuff[];
  customGameData?: CMsgGameMatchSignOut_CTeam_CPlayer_CCustomGameData | undefined;
  matchPlayerFlags?: number | undefined;
  talentAbilityIds: number[];
  heroPickOrder?: number | undefined;
  heroWasRandomed?: boolean | undefined;
  heroWasDotaPlusSuggestion?: boolean | undefined;
  lane?: number | undefined;
  isUsingPlusGuide?: boolean | undefined;
  heroDamageReceived: CMsgGameMatchSignOut_CTeam_CPlayer_HeroDamageReceived[];
  heroDamageDealt: CMsgGameMatchSignOut_CTeam_CPlayer_HeroDamageReceived[];
  secondsDead?: number | undefined;
  goldLostToDeath?: number | undefined;
  commandCount?: number | undefined;
  mouseClickCastCommandCount?: number | undefined;
  teleportsUsed?: number | undefined;
  cavernCrawlPreferredMapVariant?: number | undefined;
  bountyRunes?: number | undefined;
  outpostsCaptured?: number | undefined;
  dewards?: number | undefined;
  wardsPlaced?: number | undefined;
  campsStacked?: number | undefined;
  playerSlot?: number | undefined;
  predictedPosition?: number | undefined;
  laneOutcomes?: number | undefined;
  friendlyT1DestroyedTime?: number | undefined;
  enemyT1DestroyedTime?: number | undefined;
  friendlyRoshanKills?: number | undefined;
  enemyRoshanKills?: number | undefined;
  powerRunes?: number | undefined;
  waterRunes?: number | undefined;
  stunDuration?: number | undefined;
  teamNumber?: dotaGcTeam | undefined;
  teamSlot?: number | undefined;
  timePurchasedShard?: number | undefined;
  timePurchasedAghs?: number | undefined;
  abilityDraftAbilities: number[];
  playerTrackedStats: CMsgTrackedStat[];
  predictedRank?: number | undefined;
  selectedFacet?: number | undefined;
  enhancementLevel?: number | undefined;
}

export enum CMsgGameMatchSignOut_CTeam_CPlayer_HeroDamageType {
  HERO_DAMAGE_PHYSICAL = 0,
  HERO_DAMAGE_MAGICAL = 1,
  HERO_DAMAGE_PURE = 2,
}

export function cMsgGameMatchSignOut_CTeam_CPlayer_HeroDamageTypeFromJSON(
  object: any,
): CMsgGameMatchSignOut_CTeam_CPlayer_HeroDamageType {
  switch (object) {
    case 0:
    case "HERO_DAMAGE_PHYSICAL":
      return CMsgGameMatchSignOut_CTeam_CPlayer_HeroDamageType.HERO_DAMAGE_PHYSICAL;
    case 1:
    case "HERO_DAMAGE_MAGICAL":
      return CMsgGameMatchSignOut_CTeam_CPlayer_HeroDamageType.HERO_DAMAGE_MAGICAL;
    case 2:
    case "HERO_DAMAGE_PURE":
      return CMsgGameMatchSignOut_CTeam_CPlayer_HeroDamageType.HERO_DAMAGE_PURE;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgGameMatchSignOut_CTeam_CPlayer_HeroDamageType",
      );
  }
}

export function cMsgGameMatchSignOut_CTeam_CPlayer_HeroDamageTypeToJSON(
  object: CMsgGameMatchSignOut_CTeam_CPlayer_HeroDamageType,
): string {
  switch (object) {
    case CMsgGameMatchSignOut_CTeam_CPlayer_HeroDamageType.HERO_DAMAGE_PHYSICAL:
      return "HERO_DAMAGE_PHYSICAL";
    case CMsgGameMatchSignOut_CTeam_CPlayer_HeroDamageType.HERO_DAMAGE_MAGICAL:
      return "HERO_DAMAGE_MAGICAL";
    case CMsgGameMatchSignOut_CTeam_CPlayer_HeroDamageType.HERO_DAMAGE_PURE:
      return "HERO_DAMAGE_PURE";
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgGameMatchSignOut_CTeam_CPlayer_HeroDamageType",
      );
  }
}

export interface CMsgGameMatchSignOut_CTeam_CPlayer_CCustomGameData {
  dotaTeam?: number | undefined;
  winner?: boolean | undefined;
}

export interface CMsgGameMatchSignOut_CTeam_CPlayer_HeroDamageReceived {
  preReduction?: number | undefined;
  postReduction?: number | undefined;
  damageType?: CMsgGameMatchSignOut_CTeam_CPlayer_HeroDamageType | undefined;
}

export interface CMsgGameMatchSignOut_CAdditionalSignoutMsg {
  id?: number | undefined;
  contents?: Buffer | undefined;
}

export interface CMsgGameMatchSignOut_CSocialFeedMatchEvent {
  accountId?: number | undefined;
  timestamp?: number | undefined;
  eventType?: number | undefined;
  gameTime?: number | undefined;
  replayTime?: number | undefined;
}

export interface CMsgGameMatchSignOut_CCustomGameData {
  publishTimestamp?: number | undefined;
}

export interface CMsgGameMatchSignOut_EventGameLeaderboardEntry {
  nameSuffix?: string | undefined;
  score?: number | undefined;
  extraData1?: number | undefined;
  extraData2?: number | undefined;
  extraData3?: number | undefined;
  extraData4?: number | undefined;
  extraData5?: number | undefined;
}

export interface CMsgGameMatchSignOut_WardPlacement {
  playerId?: number | undefined;
  teamId?: number | undefined;
  placedTime?: number | undefined;
  buildingState?: number | undefined;
  creepState?: number | undefined;
  roshanAlive?: boolean | undefined;
  positionX?: number | undefined;
  positionY?: number | undefined;
}

export interface CMsgSignOutDraftInfo {
  radiantCaptainAccountId?: number | undefined;
  direCaptainAccountId?: number | undefined;
  picksBans: CMatchHeroSelectEvent[];
}

export interface CMsgSignOutBotInfo {
  allowCheats?: boolean | undefined;
  botDifficultyRadiant?: DOTABotDifficulty | undefined;
  createdLobby?: boolean | undefined;
  botDifficultyDire?: DOTABotDifficulty | undefined;
}

export interface CMsgSignOutTextMuteInfo {
  textMuteMessages: CMsgSignOutTextMuteInfo_TextMuteMessage[];
}

export interface CMsgSignOutTextMuteInfo_TextMuteMessage {
  region?: number | undefined;
  causedTextMute?: boolean | undefined;
  chatMessage?: string | undefined;
}

export interface CMsgSignOutPlayerStats {
  accountId?: number | undefined;
  matchId?: string | undefined;
  rank?: number | undefined;
  heroId?: number | undefined;
  rampages?: number | undefined;
  tripleKills?: number | undefined;
  firstBloodClaimed?: number | undefined;
  firstBloodGiven?: number | undefined;
  couriersKilled?: number | undefined;
  aegisesSnatched?: number | undefined;
  cheesesEaten?: number | undefined;
  creepsStacked?: number | undefined;
  fightScore?: number | undefined;
  farmScore?: number | undefined;
  supportScore?: number | undefined;
  pushScore?: number | undefined;
  kills?: number | undefined;
  deaths?: number | undefined;
  assists?: number | undefined;
  lastHits?: number | undefined;
  denies?: number | undefined;
  gpm?: number | undefined;
  xppm?: number | undefined;
  netWorth?: number | undefined;
  damage?: number | undefined;
  heals?: number | undefined;
  rapiersPurchased?: number | undefined;
  observerWardsPlaced?: number | undefined;
  wardsDestroyed?: number | undefined;
  lobbyType?: number | undefined;
}

export interface CMsgSignOutCommunicationSummary {
  players: CMsgSignOutCommunicationSummary_PlayerCommunication[];
}

export interface CMsgSignOutCommunicationSummary_PlayerCommunication {
  accountId?: number | undefined;
  pings?: number | undefined;
  maxPingsPerInterval?: number | undefined;
  teammatePings?: number | undefined;
  maxTeammatePingsPerInterval?: number | undefined;
  teamChatMessages?: number | undefined;
  allChatMessages?: number | undefined;
  chatWheelMessages?: number | undefined;
  pauses?: number | undefined;
  unpauses?: number | undefined;
  linesDrawn?: number | undefined;
  voiceChatSeconds?: number | undefined;
  chatMutes?: number | undefined;
  voiceMutes?: number | undefined;
  pingDetails: CMsgSignOutCommunicationSummary_PlayerCommunication_PingDetail[];
  commsBlocksSolo?: number | undefined;
  commsBlocksMass?: number | undefined;
  chatLog: string[];
}

export interface CMsgSignOutCommunicationSummary_PlayerCommunication_PingDetail {
  type?: number | undefined;
  count?: number | undefined;
}

export interface CMsgGameMatchSignoutResponse {
  matchId?: string | undefined;
  replaySalt?: number | undefined;
  leagueid?: number | undefined;
  metadataPrivateKey?: number | undefined;
  matchDetails?: CMsgDOTAMatch | undefined;
  playersMetadata: CMsgGameMatchSignoutResponse_PlayerMetadata[];
  mvpData?: CMvpData | undefined;
  owPrivateKey?: string | undefined;
  owSalt?: number | undefined;
  owReplayId?: string | undefined;
  overworldRewards?: CMsgOverworldMatchRewards | undefined;
}

export interface CMsgGameMatchSignoutResponse_PlayerMetadata {
  heroId?: number | undefined;
  avgKillsX16?: number | undefined;
  avgDeathsX16?: number | undefined;
  avgAssistsX16?: number | undefined;
  avgGpmX16?: number | undefined;
  avgXpmX16?: number | undefined;
  bestKillsX16?: number | undefined;
  bestAssistsX16?: number | undefined;
  bestGpmX16?: number | undefined;
  bestXpmX16?: number | undefined;
  winStreak?: number | undefined;
  bestWinStreak?: number | undefined;
  gamesPlayed?: number | undefined;
}

export interface CMsgGameMatchSignOutPermissionRequest {
  serverVersion?: number | undefined;
  localAttempt?: number | undefined;
  totalAttempt?: number | undefined;
  secondsWaited?: number | undefined;
}

export interface CMsgGameMatchSignOutPermissionResponse {
  permissionGranted?: boolean | undefined;
  abandonSignout?: boolean | undefined;
  retryDelaySeconds?: number | undefined;
}

export interface CMsgGameMatchSignOutEventGameData {
  eventId?: EEvent | undefined;
  gameName?: string | undefined;
  mapName?: string | undefined;
  eventGameData?: Buffer | undefined;
  startTime?: number | undefined;
}

export interface CMsgGameMatchSignOutPerfData {
  averageFrameTime: number[];
  maxFrameTime: number[];
  serverAverageFrameTime?: number | undefined;
  serverMaxFrameTime?: number | undefined;
  averageComputeTime: number[];
  maxComputeTime: number[];
  averageClientTickTime: number[];
  maxClientTickTime: number[];
  averageClientSimulateTime: number[];
  maxClientSimulateTime: number[];
  averageOutputTime: number[];
  maxOutputTime: number[];
  averageWaitForRenderingToCompleteTime: number[];
  maxWaitForRenderingToCompleteTime: number[];
  averageSwapTime: number[];
  maxSwapTime: number[];
  averageFrameUpdateTime: number[];
  maxFrameUpdateTime: number[];
  averageIdleTime: number[];
  maxIdleTime: number[];
  averageInputProcessingTime: number[];
  maxInputProcessingTime: number[];
}

export interface CMsgGameMatchSignOutBanData {
  heroBans: number[];
  heroBanVotes: number[];
}

export interface CMsgDOTALiveScoreboardUpdate {
  tournamentId?: number | undefined;
  tournamentGameId?: number | undefined;
  duration?: number | undefined;
  hltvDelay?: number | undefined;
  teamGood?: CMsgDOTALiveScoreboardUpdate_Team | undefined;
  teamBad?: CMsgDOTALiveScoreboardUpdate_Team | undefined;
  roshanRespawnTimer?: number | undefined;
  leagueId?: number | undefined;
  matchId?: string | undefined;
}

export interface CMsgDOTALiveScoreboardUpdate_Team {
  players: CMsgDOTALiveScoreboardUpdate_Team_Player[];
  score?: number | undefined;
  towerState?: number | undefined;
  barracksState?: number | undefined;
  heroPicks: number[];
  heroBans: number[];
}

export interface CMsgDOTALiveScoreboardUpdate_Team_Player {
  playerSlot?: number | undefined;
  playerName?: string | undefined;
  heroName?: string | undefined;
  heroId?: number | undefined;
  kills?: number | undefined;
  deaths?: number | undefined;
  assists?: number | undefined;
  lastHits?: number | undefined;
  denies?: number | undefined;
  gold?: number | undefined;
  level?: number | undefined;
  goldPerMin?: number | undefined;
  xpPerMin?: number | undefined;
  ultimateState?: CMsgDOTALiveScoreboardUpdate_Team_Player_DOTAUltimateState | undefined;
  ultimateCooldown?: number | undefined;
  item0?: number | undefined;
  item1?: number | undefined;
  item2?: number | undefined;
  item3?: number | undefined;
  item4?: number | undefined;
  item5?: number | undefined;
  respawnTimer?: number | undefined;
  accountId?: number | undefined;
  positionX?: number | undefined;
  positionY?: number | undefined;
  netWorth?: number | undefined;
  abilities: CMsgDOTALiveScoreboardUpdate_Team_Player_HeroAbility[];
}

export enum CMsgDOTALiveScoreboardUpdate_Team_Player_DOTAUltimateState {
  k_EDOTAUltimateStateNotLearned = 0,
  k_EDOTAUltimateStateCooldown = 1,
  k_EDOTAUltimateStateNeedsMana = 2,
  k_EDOTAUltimateStateReady = 3,
}

export function cMsgDOTALiveScoreboardUpdate_Team_Player_DOTAUltimateStateFromJSON(
  object: any,
): CMsgDOTALiveScoreboardUpdate_Team_Player_DOTAUltimateState {
  switch (object) {
    case 0:
    case "k_EDOTAUltimateStateNotLearned":
      return CMsgDOTALiveScoreboardUpdate_Team_Player_DOTAUltimateState.k_EDOTAUltimateStateNotLearned;
    case 1:
    case "k_EDOTAUltimateStateCooldown":
      return CMsgDOTALiveScoreboardUpdate_Team_Player_DOTAUltimateState.k_EDOTAUltimateStateCooldown;
    case 2:
    case "k_EDOTAUltimateStateNeedsMana":
      return CMsgDOTALiveScoreboardUpdate_Team_Player_DOTAUltimateState.k_EDOTAUltimateStateNeedsMana;
    case 3:
    case "k_EDOTAUltimateStateReady":
      return CMsgDOTALiveScoreboardUpdate_Team_Player_DOTAUltimateState.k_EDOTAUltimateStateReady;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgDOTALiveScoreboardUpdate_Team_Player_DOTAUltimateState",
      );
  }
}

export function cMsgDOTALiveScoreboardUpdate_Team_Player_DOTAUltimateStateToJSON(
  object: CMsgDOTALiveScoreboardUpdate_Team_Player_DOTAUltimateState,
): string {
  switch (object) {
    case CMsgDOTALiveScoreboardUpdate_Team_Player_DOTAUltimateState.k_EDOTAUltimateStateNotLearned:
      return "k_EDOTAUltimateStateNotLearned";
    case CMsgDOTALiveScoreboardUpdate_Team_Player_DOTAUltimateState.k_EDOTAUltimateStateCooldown:
      return "k_EDOTAUltimateStateCooldown";
    case CMsgDOTALiveScoreboardUpdate_Team_Player_DOTAUltimateState.k_EDOTAUltimateStateNeedsMana:
      return "k_EDOTAUltimateStateNeedsMana";
    case CMsgDOTALiveScoreboardUpdate_Team_Player_DOTAUltimateState.k_EDOTAUltimateStateReady:
      return "k_EDOTAUltimateStateReady";
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgDOTALiveScoreboardUpdate_Team_Player_DOTAUltimateState",
      );
  }
}

export interface CMsgDOTALiveScoreboardUpdate_Team_Player_HeroAbility {
  abilityId?: number | undefined;
  abilityLevel?: number | undefined;
}

export interface CMsgServerToGCRequestBatchPlayerResources {
  accountIds: number[];
  rankTypes: number[];
  lobbyType?: number | undefined;
}

export interface CMsgServerToGCRequestBatchPlayerResourcesResponse {
  results: CMsgServerToGCRequestBatchPlayerResourcesResponse_Result[];
}

export interface CMsgServerToGCRequestBatchPlayerResourcesResponse_Result {
  accountId?: number | undefined;
  rank?: number | undefined;
  rankCalibrated?: boolean | undefined;
  lowPriority?: boolean | undefined;
  isNewPlayer?: boolean | undefined;
  isGuidePlayer?: boolean | undefined;
  commLevel?: number | undefined;
  behaviorLevel?: number | undefined;
  wins?: number | undefined;
  losses?: number | undefined;
  smurfCategory?: number | undefined;
  commScore?: number | undefined;
  behaviorScore?: number | undefined;
  rankUncertainty?: number | undefined;
}

export interface CMsgDOTAPlayerFailedToConnect {
  failedLoaders: string[];
  abandonedLoaders: string[];
}

export interface CMsgGCToRelayConnect {
  sourceTvPublicAddr?: number | undefined;
  sourceTvPrivateAddr?: number | undefined;
  sourceTvPort?: number | undefined;
  gameServerSteamId?: string | undefined;
  parentCount?: number | undefined;
  tvUniqueSecretCode?: string | undefined;
  sourceTvSteamid?: string | undefined;
}

export interface CMsgGCGCToLANServerRelayConnect {
  relaySteamid?: string | undefined;
}

export interface CMsgGCBanStatusRequest {
  accountId?: number | undefined;
}

export interface CMsgGCBanStatusResponse {
  result?: number | undefined;
  lowPriority?: boolean | undefined;
  textChatBanned?: boolean | undefined;
  voiceChatBanned?: boolean | undefined;
}

export interface CMsgTournamentItemEvent {
  killerAccountId?: number | undefined;
  victimAccountId?: number | undefined;
  eventType?: DOTATournamentEvents | undefined;
  tvDelay?: number | undefined;
  dotaTime?: number | undefined;
  replayTime?: number | undefined;
  lootList?: string | undefined;
  eventTeam?: number | undefined;
  multiKillCount?: number | undefined;
  winnerScore?: number | undefined;
  loserScore?: number | undefined;
  heroStatues: CProtoItemHeroStatue[];
}

export interface CMsgTournamentItemEventResponse {
  eventType?: DOTATournamentEvents | undefined;
  viewersGranted?: number | undefined;
}

export interface CMsgTeamFanfare {
  matchId?: string | undefined;
}

export interface CMsgResponseTeamFanfare {
  fanfareGoodguys?: number | undefined;
  fanfareBadguys?: number | undefined;
}

export interface CMsgDOTAAwardEventPoints {
  awardPoints: CMsgDOTAAwardEventPoints_AwardPoints[];
  matchId?: string | undefined;
  eventId?: EEvent | undefined;
  timestamp?: number | undefined;
  auditAction?: number | undefined;
}

export interface CMsgDOTAAwardEventPoints_AwardPoints {
  accountId?: number | undefined;
  points?: number | undefined;
  premiumPoints?: number | undefined;
  tradeBanTime?: number | undefined;
  eligibleForPeriodicAdjustment?: boolean | undefined;
  pointCapPeriodicResourceId?: number | undefined;
}

export interface CMsgGCToServerPingRequest {
  requestId?: string | undefined;
  requestTime?: string | undefined;
}

export interface CMsgGCToServerPingResponse {
  requestId?: string | undefined;
  requestTime?: string | undefined;
  cluster?: number | undefined;
}

export interface CMsgServerToGCMatchConnectionStats {
  matchId?: string | undefined;
  regionId?: number | undefined;
  leagueId?: number | undefined;
  players: CMsgServerToGCMatchConnectionStats_Player[];
  clusterId?: number | undefined;
}

export interface CMsgServerToGCMatchConnectionStats_Player {
  accountId?: number | undefined;
  ip?: number | undefined;
  avgPingMs?: number | undefined;
  packetLoss?: number | undefined;
  pingDeviation?: number | undefined;
  fullResends?: number | undefined;
}

export interface CMsgServerGCUpdateSpectatorCount {
  spectatorCount?: number | undefined;
}

export interface CSerializedCombatLog {
  version?: number | undefined;
  dictionary?: CSerializedCombatLog_Dictionary | undefined;
  entries: CMsgDOTACombatLogEntry[];
}

export interface CSerializedCombatLog_Dictionary {
  strings: CSerializedCombatLog_Dictionary_DictString[];
}

export interface CSerializedCombatLog_Dictionary_DictString {
  id: number;
  value: string;
}

export interface CMsgServerToGCVictoryPredictions {
  records: CMsgServerToGCVictoryPredictions_Record[];
}

export interface CMsgServerToGCVictoryPredictions_PredictionItem {
  itemId?: string | undefined;
  itemDef?: number | undefined;
}

export interface CMsgServerToGCVictoryPredictions_Record {
  accountId?: number | undefined;
  itemIds: string[];
  predictionItems: CMsgServerToGCVictoryPredictions_PredictionItem[];
}

export interface CMsgServerToGCRequestStatus {
}

export interface CMsgServerToGCRequestStatusResponse {
  response?: number | undefined;
}

export interface CMsgGCToServerEvaluateToxicChat {
  targetAccountId?: number | undefined;
  reporterAccountId?: number | undefined;
}

export interface CMsgServerToGCEvaluateToxicChat {
  targetAccountId?: number | undefined;
  reporterAccountId?: number | undefined;
  matchId?: string | undefined;
  timestamp: number[];
  line: string[];
}

export interface CMsgServerToGCEvaluateToxicChatResponse {
  targetAccountId?: number | undefined;
  reporterAccountId?: number | undefined;
  banReason?: number | undefined;
  banDuration?: number | undefined;
  toxicityScore?: number | undefined;
}

export interface CMsgSignOutAssassinMiniGameInfo {
  winningPlayers: string[];
  losingPlayers: string[];
  arcanaOwners: string[];
  assassinWon?: boolean | undefined;
  targetHeroId?: number | undefined;
  contractCompleted?: boolean | undefined;
  contractCompleteTime?: number | undefined;
  paIsRadiant?: boolean | undefined;
}

export interface CMsgServerToGCKillSummaries {
  ingameeventId?: number | undefined;
  summaries: CMsgServerToGCKillSummaries_KillSummary[];
}

export interface CMsgServerToGCKillSummaries_KillSummary {
  killerHeroId?: number | undefined;
  victimHeroId?: number | undefined;
  killCount?: number | undefined;
}

export interface CMsgServerToGCLockCharmTrading {
  accountId?: number | undefined;
  itemId?: string | undefined;
}

export interface CMsgSignOutUpdatePlayerChallenge {
  accountId?: number | undefined;
  completed: CMsgSignOutUpdatePlayerChallenge_Challenge[];
  rerolled: CMsgSignOutUpdatePlayerChallenge_Challenge[];
  matchId?: string | undefined;
  heroId?: number | undefined;
}

export interface CMsgSignOutUpdatePlayerChallenge_Challenge {
  eventId?: EEvent | undefined;
  slotId?: number | undefined;
  sequenceId?: number | undefined;
  progress?: number | undefined;
  challengeRank?: number | undefined;
}

export interface CMsgServerToGCRerollPlayerChallenge {
  accountId?: number | undefined;
  rerollMsg?: CMsgClientToGCRerollPlayerChallenge | undefined;
}

export interface CMsgSpendWager {
  players: CMsgSpendWager_Player[];
  eventId?: EEvent | undefined;
  timestamp?: number | undefined;
  matchId?: string | undefined;
  serverSteamId?: string | undefined;
}

export interface CMsgSpendWager_Player {
  accountId?: number | undefined;
  wager?: number | undefined;
  wagerTokenItemId?: string | undefined;
}

export interface CMsgSignOutXPCoins {
  players: CMsgSignOutXPCoins_Player[];
  eventId?: EEvent | undefined;
  matchId?: string | undefined;
  timestamp?: number | undefined;
}

export interface CMsgSignOutXPCoins_Player {
  accountId?: number | undefined;
  xpGained?: number | undefined;
  coinsSpent?: number | undefined;
  wagerTokenItemId?: string | undefined;
  rankWager?: number | undefined;
  wagerStreak?: number | undefined;
}

export interface CMsgSignOutBounties {
  bounties: CMsgSignOutBounties_Bounty[];
  eventId?: EEvent | undefined;
  matchId?: string | undefined;
  timestamp?: number | undefined;
}

export interface CMsgSignOutBounties_Bounty {
  issuerAccountId?: number | undefined;
  completerAccountId?: number | undefined;
  targetAccountId?: number | undefined;
}

export interface CMsgSignOutCommunityGoalProgress {
  eventId?: EEvent | undefined;
  eventIncrements: CMsgSignOutCommunityGoalProgress_EventGoalIncrement[];
}

export interface CMsgSignOutCommunityGoalProgress_EventGoalIncrement {
  eventGoalId?: number | undefined;
  incrementAmount?: number | undefined;
}

export interface CMsgServerToGCCloseCompendiumInGamePredictionVoting {
  matchId?: string | undefined;
  hltvDelay?: number | undefined;
  leagueId?: number | undefined;
}

export interface CMsgServerToGCCloseCompendiumInGamePredictionVotingResponse {
  result?: boolean | undefined;
}

export interface CMsgServerToGCCompendiumInGamePredictionResults {
  matchId?: string | undefined;
  results: CMsgServerToGCCompendiumInGamePredictionResults_PredictionResult[];
  leagueId?: number | undefined;
  leagueNodeId?: number | undefined;
}

export interface CMsgServerToGCCompendiumInGamePredictionResults_PredictionResult {
  predictionId?: number | undefined;
  predictionValue?: number | undefined;
  predictionValueIsMask?: boolean | undefined;
}

export interface CMsgServerToGCCompendiumChosenInGamePredictions {
  matchId?: string | undefined;
  predictionsChosen: CMsgServerToGCCompendiumChosenInGamePredictions_Prediction[];
  leagueId?: number | undefined;
}

export interface CMsgServerToGCCompendiumChosenInGamePredictions_Prediction {
  predictionId?: number | undefined;
}

export interface CMsgGCToGCCompendiumInGamePredictionResults {
  results?: CMsgServerToGCCompendiumInGamePredictionResults | undefined;
}

export interface CMsgServerToGCMatchPlayerItemPurchaseHistory {
  matchId?: string | undefined;
  mmr?: number | undefined;
  players: CMsgServerToGCMatchPlayerItemPurchaseHistory_Player[];
}

export interface CMsgServerToGCMatchPlayerItemPurchaseHistory_ItemPurchase {
  item?: number | undefined;
  gold?: number | undefined;
  netWorth?: number | undefined;
  gameTime?: number | undefined;
  inventoryItems: number[];
  talentsSkilled: boolean[];
}

export interface CMsgServerToGCMatchPlayerItemPurchaseHistory_Player {
  playerSlot?: number | undefined;
  accountId?: number | undefined;
  heroId?: number | undefined;
  alliedHeroIds: number[];
  enemyHeroIds: number[];
  itemPurchases: CMsgServerToGCMatchPlayerItemPurchaseHistory_ItemPurchase[];
  lane?: number | undefined;
  isWinner?: boolean | undefined;
}

export interface CMsgServerToGCMatchPlayerNeutralItemEquipHistory {
  matchId?: string | undefined;
  players: CMsgServerToGCMatchPlayerNeutralItemEquipHistory_Player[];
}

export interface CMsgServerToGCMatchPlayerNeutralItemEquipHistory_ItemEquip {
  item?: number | undefined;
  gameTime?: number | undefined;
  inventoryItems: number[];
  talentsSkilled: boolean[];
  availableNeutralItems: number[];
}

export interface CMsgServerToGCMatchPlayerNeutralItemEquipHistory_Player {
  accountId?: number | undefined;
  alliedHeroIds: number[];
  enemyHeroIds: number[];
  itemEquips: CMsgServerToGCMatchPlayerNeutralItemEquipHistory_ItemEquip[];
  isWinner?: boolean | undefined;
}

export interface CMsgServerToGCMatchStateHistory {
  matchId?: string | undefined;
  radiantWon?: boolean | undefined;
  mmr?: number | undefined;
  matchStates: CMsgServerToGCMatchStateHistory_MatchState[];
}

export interface CMsgServerToGCMatchStateHistory_PlayerState {
  heroId?: number | undefined;
  netWorth?: number | undefined;
  level?: number | undefined;
  deaths?: number | undefined;
  respawnTime?: number | undefined;
  hasBuyback?: boolean | undefined;
  hasAegis?: boolean | undefined;
  hasRapier?: boolean | undefined;
  distance?: number | undefined;
}

export interface CMsgServerToGCMatchStateHistory_TeamState {
  team?: number | undefined;
  playerStates: CMsgServerToGCMatchStateHistory_PlayerState[];
  towerHealthPct: number[];
  barracksHealthPct: number[];
  ancientHealthPct?: number | undefined;
  glyphCooldown?: number | undefined;
  kills?: number | undefined;
  creepDistanceSafe?: number | undefined;
  creepDistanceMid?: number | undefined;
  creepDistanceOff?: number | undefined;
}

export interface CMsgServerToGCMatchStateHistory_MatchState {
  gameTime?: number | undefined;
  radiantState?: CMsgServerToGCMatchStateHistory_TeamState | undefined;
  direState?: CMsgServerToGCMatchStateHistory_TeamState | undefined;
}

export interface CMsgMatchStateSteamMLEntry {
  matchState?: CMsgServerToGCMatchStateHistory_MatchState | undefined;
  mmr?: number | undefined;
  radiantWon?: boolean | undefined;
}

export interface CMsgLaneSelectionSteamMLEntry {
  heroIds: number[];
  lanes: number[];
}

export interface CMsgAbilitySelectionSteamMLEntry {
  mmr?: number | undefined;
  heroId?: number | undefined;
  enemyHeroIds: number[];
  lane?: number | undefined;
  abilities: number[];
  selectedAbility?: number | undefined;
}

export interface CMsgItemPurchasePregameSteamMLEntry {
  mmr?: number | undefined;
  lane?: number | undefined;
  balance?: number | undefined;
  heroId?: number | undefined;
  alliedHeroIds: number[];
  enemyHeroIds: number[];
  items: number[];
}

export interface CMsgItemPurchaseSteamMLEntry {
  mmr?: number | undefined;
  lane?: number | undefined;
  heroId?: number | undefined;
  alliedHeroIds: number[];
  enemyHeroIds: number[];
  items: number[];
  itemsToBePurchased: number[];
}

export interface CMsgItemPurchaseSequenceSteamMLEntry {
  mmr?: number | undefined;
  lane?: number | undefined;
  heroId?: number | undefined;
  alliedHeroIds: number[];
  enemyHeroIds: number[];
  items: number[];
  itemToBePurchased?: number | undefined;
}

export interface CMsgServerToGCCavernCrawlIsHeroActive {
  eventId?: number | undefined;
  accountId?: number | undefined;
  preferredMapVariant?: number | undefined;
  heroId?: number | undefined;
  turboMode?: boolean | undefined;
}

export interface CMsgServerToGCPlayerChallengeHistory {
  matchId?: string | undefined;
  averageRank?: number | undefined;
  challengeRecords: CMsgServerToGCPlayerChallengeHistory_PlayerChallenge[];
}

export interface CMsgServerToGCPlayerChallengeHistory_PlayerChallenge {
  accountId?: number | undefined;
  challengeType?: EPlayerChallengeHistoryType | undefined;
  challengeId1?: number | undefined;
  challengeId2?: number | undefined;
  progressValueStart?: number | undefined;
  progressValueEnd?: number | undefined;
  teamWon?: boolean | undefined;
  auditData?: string | undefined;
  heroId?: number | undefined;
  rankCompleted?: number | undefined;
}

export interface CMsgServerToGCCavernCrawlIsHeroActiveResponse {
  result?: boolean | undefined;
  mapVariant?: number | undefined;
  potentialWinnings?: number | undefined;
  mapResults: CMsgServerToGCCavernCrawlIsHeroActiveResponse_MapResults[];
  potentialPlusShardWinnings?: number | undefined;
}

export interface CMsgServerToGCCavernCrawlIsHeroActiveResponse_MapResults {
  pathIdCompleted?: number | undefined;
  roomIdClaimed?: number | undefined;
}

export interface CMsgNeutralItemStats {
  neutralItems: CMsgNeutralItemStats_NeutralItem[];
}

export interface CMsgNeutralItemStats_NeutralItem {
  itemId?: number | undefined;
  timeDropped?: number | undefined;
  team?: number | undefined;
  timeLastEquipped?: number | undefined;
  timeLastUnequipped?: number | undefined;
  durationEquipped?: number | undefined;
}

export interface CMsgGCToServerLobbyHeroBanRates {
  banData: CMsgGCToServerLobbyHeroBanRates_HeroBanEntry[];
}

export interface CMsgGCToServerLobbyHeroBanRates_HeroBanEntry {
  heroId?: number | undefined;
  banCount?: number | undefined;
  pickCount?: number | undefined;
}

export interface CMsgSignOutGuildContractProgress {
  playerContracts: CMsgSignOutGuildContractProgress_PlayerContract[];
}

export interface CMsgSignOutGuildContractProgress_CompletedGuildEventContracts {
  guildId?: number | undefined;
  eventId?: number | undefined;
  contracts: string[];
}

export interface CMsgSignOutGuildContractProgress_PlayerContract {
  accountId?: number | undefined;
  completedContracts: CMsgSignOutGuildContractProgress_CompletedGuildEventContracts[];
}

export interface CMsgSignOutGuildChallengeProgress {
  guildChallengesProgresses: CMsgSignOutGuildChallengeProgress_ChallengeProgress[];
}

export interface CMsgSignOutGuildChallengeProgress_ChallengeProgress {
  guildId?: number | undefined;
  eventId?: number | undefined;
  challengeInstanceId?: number | undefined;
  challengeInstanceTimestamp?: number | undefined;
  challengePeriodSerial?: number | undefined;
  progress?: number | undefined;
  challengeParameter?: number | undefined;
}

export interface CMsgSignOutMVPStats {
  matchId?: string | undefined;
  gameMode?: number | undefined;
  winningTeam?: number | undefined;
  gameTime?: number | undefined;
  players: CMsgSignOutMVPStats_Player[];
}

export interface CMsgSignOutMVPStats_Player {
  teamId?: number | undefined;
  teamNetworthRank?: number | undefined;
  accountId?: number | undefined;
  playerSlot?: number | undefined;
  rank?: number | undefined;
  heroId?: number | undefined;
  role?: number | undefined;
  kills?: number | undefined;
  deaths?: number | undefined;
  assists?: number | undefined;
  xp?: number | undefined;
  netWorth?: number | undefined;
  supportGoldSpent?: number | undefined;
  wardsPlaced?: number | undefined;
  wardsSpottedForDewarding?: number | undefined;
  campsStacked?: number | undefined;
  lastHits?: number | undefined;
  denies?: number | undefined;
  buildingDamage?: number | undefined;
  otherDamage?: number | undefined;
  tripleKills?: number | undefined;
  rampages?: number | undefined;
  firstBlood?: number | undefined;
  killEaterEvents: CMsgSignOutMVPStats_Player_KillEaterEvent[];
  highestKillstreak?: number | undefined;
}

export interface CMsgSignOutMVPStats_Player_KillEaterEvent {
  eventType: number;
  amount: number;
}

export interface CMsgGCToServerRecordTrainingData {
  enable?: boolean | undefined;
}

export interface CMsgServerToGCGetGuildContracts {
  accountIds: number[];
}

export interface CMsgServerToGCGetGuildContractsResponse {
  playerContracts: CMsgServerToGCGetGuildContractsResponse_Player[];
}

export interface CMsgServerToGCGetGuildContractsResponse_ContractDetails {
  contractId?: string | undefined;
  challengeInstanceId?: number | undefined;
  challengeParameter?: number | undefined;
  contractStars?: number | undefined;
  contractSlot?: number | undefined;
}

export interface CMsgServerToGCGetGuildContractsResponse_Player {
  accountId?: number | undefined;
  guildId?: number | undefined;
  eventId?: EEvent | undefined;
  contracts: CMsgServerToGCGetGuildContractsResponse_ContractDetails[];
}

export interface CMsgMatchDiretideCandy {
  playerCandyData: CMsgMatchDiretideCandy_PlayerCandy[];
  eventId?: EEvent | undefined;
}

export interface CMsgMatchDiretideCandy_CandyDetails {
  amount?: number | undefined;
  audit?: number | undefined;
}

export interface CMsgMatchDiretideCandy_PlayerCandy {
  accountId?: number | undefined;
  candyAmount?: number | undefined;
  consumesPeriodicResource?: boolean | undefined;
  candyBreakdown: CMsgMatchDiretideCandy_CandyDetails[];
}

export interface CMsgGCToServerCheerData {
  cheerTypes: CMsgGCToServerCheerData_CheerTypeCount[];
}

export interface CMsgGCToServerCheerData_CheerTypeCount {
  cheerType?: number | undefined;
  cheerCount?: number | undefined;
}

export interface CMsgCheerConfig {
  cheersEnabled?: boolean | undefined;
  isValidLeagueId?: boolean | undefined;
  windowDuration?: number | undefined;
  windowBucketCount?: number | undefined;
  crowdLevelPushTime?: number | undefined;
  crowdLevelLow?: number | undefined;
  crowdLevelMedium?: number | undefined;
  crowdLevelHigh?: number | undefined;
  cheerScaleStart?: number | undefined;
  cheerScaleSpeed?: number | undefined;
  cheerScalePushMark?: number | undefined;
  cheerScalePullMark?: number | undefined;
  cheerScalePctOfMaxCpsClamp?: number | undefined;
  cheerScaleDampenerValue?: number | undefined;
  cheerScaleDampenerLerpTime?: number | undefined;
  cheerFactorBronze?: number | undefined;
  cheerFactorSilver?: number | undefined;
  cheerFactorGold?: number | undefined;
}

export interface CMsgGCToServerCheerConfig {
  cheerConfig?: CMsgCheerConfig | undefined;
}

export interface CMsgServerToGCGetCheerConfig {
  leagueId?: number | undefined;
}

export interface CMsgServerToGCGetCheerConfigResponse {
  cheerConfig?: CMsgCheerConfig | undefined;
}

export interface CMsgGCToServerCheerScalesOverride {
  scales: number[];
}

export interface CMsgGCToServerGetCheerState {
}

export interface CMsgCheerTypeState {
  cheerCounts: number[];
  maxPerSecond?: number | undefined;
  cheerScale?: number | undefined;
  overrideScale?: number | undefined;
}

export interface CMsgCheerState {
  cheerTypes: CMsgCheerTypeState[];
  radiantCrowdLevel?: number | undefined;
  direCrowdLevel?: number | undefined;
}

export interface CMsgServerToGCReportCheerState {
  cheerConfig?: CMsgCheerConfig | undefined;
  cheerState?: CMsgCheerState | undefined;
}

export interface CMsgServerToGCGetStickerHeroes {
  accountIds: number[];
}

export interface CMsgServerToGCGetStickerHeroesResponse {
  players: CMsgServerToGCGetStickerHeroesResponse_Player[];
}

export interface CMsgServerToGCGetStickerHeroesResponse_Player {
  accountId?: number | undefined;
  stickers?: CMsgStickerHeroes | undefined;
}

export interface CMsgSteamLearnMatchInfo {
  averageMmr?: number | undefined;
  radiantWon?: boolean | undefined;
  duration?: number | undefined;
  gameMode?: number | undefined;
  lobbyType?: number | undefined;
}

export interface CMsgSteamLearnMatchInfoPlayer {
  averageMmr?: number | undefined;
  teamWon?: boolean | undefined;
  duration?: number | undefined;
  gameMode?: number | undefined;
  lobbyType?: number | undefined;
  playerMmr?: number | undefined;
}

export interface CMsgSteamLearnMatchInfoTeam {
  radiantPlayers: CMsgSteamLearnMatchInfoTeam_Player[];
  direPlayers: CMsgSteamLearnMatchInfoTeam_Player[];
  radiantTeamWon?: boolean | undefined;
}

export interface CMsgSteamLearnMatchInfoTeam_Player {
  prematchMmr?: number | undefined;
  prematchRankUncertainty?: number | undefined;
  prematchBehaviorScore?: number | undefined;
  prematchCommScore?: number | undefined;
  numPlayersInParty?: number | undefined;
}

export interface CMsgSteamLearnMatchHeroesV3 {
  radiantHeroIds: number[];
  direHeroIds: number[];
  radiantLanes: number[];
  direLanes: number[];
  radiantHeroFacets: number[];
  direHeroFacets: number[];
  radiantPositions: number[];
  direPositions: number[];
}

export interface CMsgSteamLearnMatchHeroV3 {
  heroId?: number | undefined;
  lane?: number | undefined;
  position?: number | undefined;
  alliedHeroIds: number[];
  enemyHeroIds: number[];
  heroFacet?: number | undefined;
  alliedHeroFacets: number[];
  enemyHerofacets: number[];
}

export interface CMsgSteamLearnPlayerTimedStats {
  statBuckets: CMsgSteamLearnPlayerTimedStats_StatBucket[];
}

export interface CMsgSteamLearnPlayerTimedStats_StatBucket {
  gameTime?: number | undefined;
  kills?: number | undefined;
  deaths?: number | undefined;
  assists?: number | undefined;
  experience?: number | undefined;
  lastHits?: number | undefined;
  denies?: number | undefined;
  netWorth?: number | undefined;
  idleTime?: number | undefined;
  commandsIssued?: number | undefined;
  sentryWardsPlaced?: number | undefined;
  observerWardsPlaced?: number | undefined;
}

export interface CMsgSteamLearnMatchStateV5 {
  gameTime?: number | undefined;
  radiantState?: CMsgSteamLearnMatchStateV5_TeamState | undefined;
  direState?: CMsgSteamLearnMatchStateV5_TeamState | undefined;
}

export interface CMsgSteamLearnMatchStateV5_PlayerState {
  heroId?: number | undefined;
  netWorth?: number | undefined;
  level?: number | undefined;
  deaths?: number | undefined;
  respawnTime?: number | undefined;
  hasBuyback?: boolean | undefined;
  hasAegis?: boolean | undefined;
  hasRapier?: boolean | undefined;
  distance?: number | undefined;
  heroFacet?: number | undefined;
}

export interface CMsgSteamLearnMatchStateV5_TeamState {
  team?: number | undefined;
  playerStates: CMsgSteamLearnMatchStateV5_PlayerState[];
  towerHealthPct: number[];
  barracksHealthPct: number[];
  ancientHealthPct?: number | undefined;
  glyphCooldown?: number | undefined;
  kills?: number | undefined;
  creepDistanceSafe?: number | undefined;
  creepDistanceMid?: number | undefined;
  creepDistanceOff?: number | undefined;
}

export interface CMsgSteamLearnItemPurchase {
  itemId?: number | undefined;
  inventoryItems: number[];
  purchaseHistory: number[];
  gold?: number | undefined;
  netWorth?: number | undefined;
  isRadiantTeam?: number | undefined;
  gameTime?: number | undefined;
  isUsingDotaPlus?: boolean | undefined;
}

export interface CMsgSteamLearnPreGameItemPurchases {
  itemIds: number[];
  isRadiantTeam?: number | undefined;
  isUsingDotaPlus?: boolean | undefined;
}

export interface CMsgSteamLearnNeutralItemPurchase {
  itemId?: number | undefined;
  tier?: number | undefined;
  isRadiantTeam?: number | undefined;
  isUsingDotaPlus?: boolean | undefined;
}

export interface CMsgSteamLearnNeutralItemPurchaseV2 {
  tier?: number | undefined;
  trinketId?: number | undefined;
  enhancementId?: number | undefined;
  previousTrinketId?: number | undefined;
}

export interface CMsgSteamLearnAbilitySkill {
  abilityId?: number | undefined;
  skilledAbilities: number[];
  gameTime?: number | undefined;
  isUsingDotaPlus?: boolean | undefined;
}

export interface CMsgSteamLearnEarlyGameItemPurchasesV2 {
  itemIds: number[];
  otherItemIds: number[];
}

export interface CMsgSteamLearnLateGameItemPurchasesV2 {
  itemIds: number[];
  otherItemIds: number[];
}

export interface CMsgSteamLearnMainGameItemPurchases {
  itemIds: number[];
}

export interface CMsgSteamLearnWardPlacement {
  wardLoc?: CMsgSteamLearnWardPlacement_Location | undefined;
  existingWardLocs: CMsgSteamLearnWardPlacement_Location[];
  team?: number | undefined;
}

export interface CMsgSteamLearnWardPlacement_Location {
  x?: number | undefined;
  y?: number | undefined;
}

export interface CMsgSteamLearnPlayerMatchState {
  netWorth?: number | undefined;
  level?: number | undefined;
  deaths?: number | undefined;
  respawnTime?: number | undefined;
  hasBuyback?: boolean | undefined;
  hasAegis?: boolean | undefined;
  hasRapier?: boolean | undefined;
  teamNetWorth?: number | undefined;
  enemyTeamNetWorth?: number | undefined;
  teamKills?: number | undefined;
  enemyTeamKills?: number | undefined;
  gameTime?: number | undefined;
}

export interface CMsgSignOutMuertaMinigame {
  eventGameData?: Buffer | undefined;
}

export interface CMsgSignOutMapStats {
  players: CMsgSignOutMapStats_Player[];
  globalStats?: CMsgMapStatsSnapshot | undefined;
}

export interface CMsgSignOutMapStats_Player {
  accountId?: number | undefined;
  personalStats?: CMsgMapStatsSnapshot | undefined;
}

export interface CMsgServerToGCNewBloomGift {
  defindex?: number | undefined;
  gifterAccountId?: number | undefined;
  targetAccountIds: number[];
}

export interface CMsgServerToGCNewBloomGiftResponse {
  result?: ENewBloomGiftingResponse | undefined;
  receivedAccountIds: number[];
}

export interface CMsgSignOutOverworld {
  players: CMsgSignOutOverworld_Player[];
  eventId?: EEvent | undefined;
}

export interface CMsgSignOutOverworld_Player {
  accountId?: number | undefined;
  overworldId?: number | undefined;
  desiredTokenRewards: number[];
}

export interface CMsgSignOutCraftworks {
  players: CMsgSignOutCraftworks_Player[];
  eventId?: EEvent | undefined;
}

export interface CMsgSignOutCraftworks_Player {
  accountId?: number | undefined;
  components?: CMsgCraftworksComponents | undefined;
}

function createBaseCMsgPoorNetworkConditions(): CMsgPoorNetworkConditions {
  return { detectionType: 0, players: [] };
}

export const CMsgPoorNetworkConditions = {
  encode(message: CMsgPoorNetworkConditions, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.detectionType !== undefined && message.detectionType !== 0) {
      writer.uint32(8).int32(message.detectionType);
    }
    for (const v of message.players) {
      CMsgPoorNetworkConditions_Player.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgPoorNetworkConditions {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgPoorNetworkConditions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.detectionType = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.players.push(CMsgPoorNetworkConditions_Player.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgPoorNetworkConditions {
    return {
      detectionType: isSet(object.detectionType) ? ePoorNetworkConditionsTypeFromJSON(object.detectionType) : 0,
      players: globalThis.Array.isArray(object?.players)
        ? object.players.map((e: any) => CMsgPoorNetworkConditions_Player.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgPoorNetworkConditions): unknown {
    const obj: any = {};
    if (message.detectionType !== undefined && message.detectionType !== 0) {
      obj.detectionType = ePoorNetworkConditionsTypeToJSON(message.detectionType);
    }
    if (message.players?.length) {
      obj.players = message.players.map((e) => CMsgPoorNetworkConditions_Player.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgPoorNetworkConditions>): CMsgPoorNetworkConditions {
    return CMsgPoorNetworkConditions.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgPoorNetworkConditions>): CMsgPoorNetworkConditions {
    const message = createBaseCMsgPoorNetworkConditions();
    message.detectionType = object.detectionType ?? 0;
    message.players = object.players?.map((e) => CMsgPoorNetworkConditions_Player.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgPoorNetworkConditions_Player(): CMsgPoorNetworkConditions_Player {
  return { accountId: 0, disconnectReason: 0, numBadIntervals: 0, peakLossPct: 0 };
}

export const CMsgPoorNetworkConditions_Player = {
  encode(message: CMsgPoorNetworkConditions_Player, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.accountId !== undefined && message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    if (message.disconnectReason !== undefined && message.disconnectReason !== 0) {
      writer.uint32(16).int32(message.disconnectReason);
    }
    if (message.numBadIntervals !== undefined && message.numBadIntervals !== 0) {
      writer.uint32(24).uint32(message.numBadIntervals);
    }
    if (message.peakLossPct !== undefined && message.peakLossPct !== 0) {
      writer.uint32(32).uint32(message.peakLossPct);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgPoorNetworkConditions_Player {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgPoorNetworkConditions_Player();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.disconnectReason = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.numBadIntervals = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.peakLossPct = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgPoorNetworkConditions_Player {
    return {
      accountId: isSet(object.accountId) ? globalThis.Number(object.accountId) : 0,
      disconnectReason: isSet(object.disconnectReason)
        ? eNetworkDisconnectionReasonFromJSON(object.disconnectReason)
        : 0,
      numBadIntervals: isSet(object.numBadIntervals) ? globalThis.Number(object.numBadIntervals) : 0,
      peakLossPct: isSet(object.peakLossPct) ? globalThis.Number(object.peakLossPct) : 0,
    };
  },

  toJSON(message: CMsgPoorNetworkConditions_Player): unknown {
    const obj: any = {};
    if (message.accountId !== undefined && message.accountId !== 0) {
      obj.accountId = Math.round(message.accountId);
    }
    if (message.disconnectReason !== undefined && message.disconnectReason !== 0) {
      obj.disconnectReason = eNetworkDisconnectionReasonToJSON(message.disconnectReason);
    }
    if (message.numBadIntervals !== undefined && message.numBadIntervals !== 0) {
      obj.numBadIntervals = Math.round(message.numBadIntervals);
    }
    if (message.peakLossPct !== undefined && message.peakLossPct !== 0) {
      obj.peakLossPct = Math.round(message.peakLossPct);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgPoorNetworkConditions_Player>): CMsgPoorNetworkConditions_Player {
    return CMsgPoorNetworkConditions_Player.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgPoorNetworkConditions_Player>): CMsgPoorNetworkConditions_Player {
    const message = createBaseCMsgPoorNetworkConditions_Player();
    message.accountId = object.accountId ?? 0;
    message.disconnectReason = object.disconnectReason ?? 0;
    message.numBadIntervals = object.numBadIntervals ?? 0;
    message.peakLossPct = object.peakLossPct ?? 0;
    return message;
  },
};

function createBaseCMsgGameserverCrash(): CMsgGameserverCrash {
  return {
    matchId: "0",
    lobbyId: "0",
    gameState: 0,
    sentinelSaveTime: 0,
    customGameId: "0",
    tournamentId: 0,
    serverSteamId: "0",
    serverPublicIpAddr: 0,
    serverPort: 0,
    serverCluster: 0,
    pid: 0,
    engine: 0,
  };
}

export const CMsgGameserverCrash = {
  encode(message: CMsgGameserverCrash, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.matchId !== undefined && message.matchId !== "0") {
      writer.uint32(8).uint64(message.matchId);
    }
    if (message.lobbyId !== undefined && message.lobbyId !== "0") {
      writer.uint32(17).fixed64(message.lobbyId);
    }
    if (message.gameState !== undefined && message.gameState !== 0) {
      writer.uint32(24).int32(message.gameState);
    }
    if (message.sentinelSaveTime !== undefined && message.sentinelSaveTime !== 0) {
      writer.uint32(37).fixed32(message.sentinelSaveTime);
    }
    if (message.customGameId !== undefined && message.customGameId !== "0") {
      writer.uint32(89).fixed64(message.customGameId);
    }
    if (message.tournamentId !== undefined && message.tournamentId !== 0) {
      writer.uint32(96).uint32(message.tournamentId);
    }
    if (message.serverSteamId !== undefined && message.serverSteamId !== "0") {
      writer.uint32(41).fixed64(message.serverSteamId);
    }
    if (message.serverPublicIpAddr !== undefined && message.serverPublicIpAddr !== 0) {
      writer.uint32(53).fixed32(message.serverPublicIpAddr);
    }
    if (message.serverPort !== undefined && message.serverPort !== 0) {
      writer.uint32(56).uint32(message.serverPort);
    }
    if (message.serverCluster !== undefined && message.serverCluster !== 0) {
      writer.uint32(64).uint32(message.serverCluster);
    }
    if (message.pid !== undefined && message.pid !== 0) {
      writer.uint32(72).uint32(message.pid);
    }
    if (message.engine !== undefined && message.engine !== 0) {
      writer.uint32(80).uint32(message.engine);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGameserverCrash {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGameserverCrash();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.matchId = longToString(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.lobbyId = longToString(reader.fixed64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.gameState = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 37) {
            break;
          }

          message.sentinelSaveTime = reader.fixed32();
          continue;
        case 11:
          if (tag !== 89) {
            break;
          }

          message.customGameId = longToString(reader.fixed64() as Long);
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.tournamentId = reader.uint32();
          continue;
        case 5:
          if (tag !== 41) {
            break;
          }

          message.serverSteamId = longToString(reader.fixed64() as Long);
          continue;
        case 6:
          if (tag !== 53) {
            break;
          }

          message.serverPublicIpAddr = reader.fixed32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.serverPort = reader.uint32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.serverCluster = reader.uint32();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.pid = reader.uint32();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.engine = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGameserverCrash {
    return {
      matchId: isSet(object.matchId) ? globalThis.String(object.matchId) : "0",
      lobbyId: isSet(object.lobbyId) ? globalThis.String(object.lobbyId) : "0",
      gameState: isSet(object.gameState) ? dOTAGameStateFromJSON(object.gameState) : 0,
      sentinelSaveTime: isSet(object.sentinelSaveTime) ? globalThis.Number(object.sentinelSaveTime) : 0,
      customGameId: isSet(object.customGameId) ? globalThis.String(object.customGameId) : "0",
      tournamentId: isSet(object.tournamentId) ? globalThis.Number(object.tournamentId) : 0,
      serverSteamId: isSet(object.serverSteamId) ? globalThis.String(object.serverSteamId) : "0",
      serverPublicIpAddr: isSet(object.serverPublicIpAddr) ? globalThis.Number(object.serverPublicIpAddr) : 0,
      serverPort: isSet(object.serverPort) ? globalThis.Number(object.serverPort) : 0,
      serverCluster: isSet(object.serverCluster) ? globalThis.Number(object.serverCluster) : 0,
      pid: isSet(object.pid) ? globalThis.Number(object.pid) : 0,
      engine: isSet(object.engine) ? globalThis.Number(object.engine) : 0,
    };
  },

  toJSON(message: CMsgGameserverCrash): unknown {
    const obj: any = {};
    if (message.matchId !== undefined && message.matchId !== "0") {
      obj.matchId = message.matchId;
    }
    if (message.lobbyId !== undefined && message.lobbyId !== "0") {
      obj.lobbyId = message.lobbyId;
    }
    if (message.gameState !== undefined && message.gameState !== 0) {
      obj.gameState = dOTAGameStateToJSON(message.gameState);
    }
    if (message.sentinelSaveTime !== undefined && message.sentinelSaveTime !== 0) {
      obj.sentinelSaveTime = Math.round(message.sentinelSaveTime);
    }
    if (message.customGameId !== undefined && message.customGameId !== "0") {
      obj.customGameId = message.customGameId;
    }
    if (message.tournamentId !== undefined && message.tournamentId !== 0) {
      obj.tournamentId = Math.round(message.tournamentId);
    }
    if (message.serverSteamId !== undefined && message.serverSteamId !== "0") {
      obj.serverSteamId = message.serverSteamId;
    }
    if (message.serverPublicIpAddr !== undefined && message.serverPublicIpAddr !== 0) {
      obj.serverPublicIpAddr = Math.round(message.serverPublicIpAddr);
    }
    if (message.serverPort !== undefined && message.serverPort !== 0) {
      obj.serverPort = Math.round(message.serverPort);
    }
    if (message.serverCluster !== undefined && message.serverCluster !== 0) {
      obj.serverCluster = Math.round(message.serverCluster);
    }
    if (message.pid !== undefined && message.pid !== 0) {
      obj.pid = Math.round(message.pid);
    }
    if (message.engine !== undefined && message.engine !== 0) {
      obj.engine = Math.round(message.engine);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGameserverCrash>): CMsgGameserverCrash {
    return CMsgGameserverCrash.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGameserverCrash>): CMsgGameserverCrash {
    const message = createBaseCMsgGameserverCrash();
    message.matchId = object.matchId ?? "0";
    message.lobbyId = object.lobbyId ?? "0";
    message.gameState = object.gameState ?? 0;
    message.sentinelSaveTime = object.sentinelSaveTime ?? 0;
    message.customGameId = object.customGameId ?? "0";
    message.tournamentId = object.tournamentId ?? 0;
    message.serverSteamId = object.serverSteamId ?? "0";
    message.serverPublicIpAddr = object.serverPublicIpAddr ?? 0;
    message.serverPort = object.serverPort ?? 0;
    message.serverCluster = object.serverCluster ?? 0;
    message.pid = object.pid ?? 0;
    message.engine = object.engine ?? 0;
    return message;
  },
};

function createBaseCMsgConnectedPlayers(): CMsgConnectedPlayers {
  return {
    connectedPlayers: [],
    disconnectedPlayers: [],
    gameState: 0,
    firstBloodHappened: false,
    poorNetworkConditions: undefined,
    sendReason: 0,
    radiantKills: 0,
    direKills: 0,
    radiantLead: 0,
    buildingState: 0,
    playerDraft: [],
  };
}

export const CMsgConnectedPlayers = {
  encode(message: CMsgConnectedPlayers, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.connectedPlayers) {
      CMsgConnectedPlayers_Player.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.disconnectedPlayers) {
      CMsgConnectedPlayers_Player.encode(v!, writer.uint32(58).fork()).ldelim();
    }
    if (message.gameState !== undefined && message.gameState !== 0) {
      writer.uint32(16).int32(message.gameState);
    }
    if (message.firstBloodHappened !== undefined && message.firstBloodHappened !== false) {
      writer.uint32(48).bool(message.firstBloodHappened);
    }
    if (message.poorNetworkConditions !== undefined) {
      CMsgPoorNetworkConditions.encode(message.poorNetworkConditions, writer.uint32(82).fork()).ldelim();
    }
    if (message.sendReason !== undefined && message.sendReason !== 0) {
      writer.uint32(64).int32(message.sendReason);
    }
    if (message.radiantKills !== undefined && message.radiantKills !== 0) {
      writer.uint32(88).uint32(message.radiantKills);
    }
    if (message.direKills !== undefined && message.direKills !== 0) {
      writer.uint32(96).uint32(message.direKills);
    }
    if (message.radiantLead !== undefined && message.radiantLead !== 0) {
      writer.uint32(112).int32(message.radiantLead);
    }
    if (message.buildingState !== undefined && message.buildingState !== 0) {
      writer.uint32(120).uint32(message.buildingState);
    }
    for (const v of message.playerDraft) {
      CMsgConnectedPlayers_PlayerDraft.encode(v!, writer.uint32(130).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgConnectedPlayers {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgConnectedPlayers();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.connectedPlayers.push(CMsgConnectedPlayers_Player.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.disconnectedPlayers.push(CMsgConnectedPlayers_Player.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.gameState = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.firstBloodHappened = reader.bool();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.poorNetworkConditions = CMsgPoorNetworkConditions.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.sendReason = reader.int32() as any;
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.radiantKills = reader.uint32();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.direKills = reader.uint32();
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.radiantLead = reader.int32();
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.buildingState = reader.uint32();
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.playerDraft.push(CMsgConnectedPlayers_PlayerDraft.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgConnectedPlayers {
    return {
      connectedPlayers: globalThis.Array.isArray(object?.connectedPlayers)
        ? object.connectedPlayers.map((e: any) => CMsgConnectedPlayers_Player.fromJSON(e))
        : [],
      disconnectedPlayers: globalThis.Array.isArray(object?.disconnectedPlayers)
        ? object.disconnectedPlayers.map((e: any) => CMsgConnectedPlayers_Player.fromJSON(e))
        : [],
      gameState: isSet(object.gameState) ? dOTAGameStateFromJSON(object.gameState) : 0,
      firstBloodHappened: isSet(object.firstBloodHappened) ? globalThis.Boolean(object.firstBloodHappened) : false,
      poorNetworkConditions: isSet(object.poorNetworkConditions)
        ? CMsgPoorNetworkConditions.fromJSON(object.poorNetworkConditions)
        : undefined,
      sendReason: isSet(object.sendReason) ? cMsgConnectedPlayers_SendReasonFromJSON(object.sendReason) : 0,
      radiantKills: isSet(object.radiantKills) ? globalThis.Number(object.radiantKills) : 0,
      direKills: isSet(object.direKills) ? globalThis.Number(object.direKills) : 0,
      radiantLead: isSet(object.radiantLead) ? globalThis.Number(object.radiantLead) : 0,
      buildingState: isSet(object.buildingState) ? globalThis.Number(object.buildingState) : 0,
      playerDraft: globalThis.Array.isArray(object?.playerDraft)
        ? object.playerDraft.map((e: any) => CMsgConnectedPlayers_PlayerDraft.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgConnectedPlayers): unknown {
    const obj: any = {};
    if (message.connectedPlayers?.length) {
      obj.connectedPlayers = message.connectedPlayers.map((e) => CMsgConnectedPlayers_Player.toJSON(e));
    }
    if (message.disconnectedPlayers?.length) {
      obj.disconnectedPlayers = message.disconnectedPlayers.map((e) => CMsgConnectedPlayers_Player.toJSON(e));
    }
    if (message.gameState !== undefined && message.gameState !== 0) {
      obj.gameState = dOTAGameStateToJSON(message.gameState);
    }
    if (message.firstBloodHappened !== undefined && message.firstBloodHappened !== false) {
      obj.firstBloodHappened = message.firstBloodHappened;
    }
    if (message.poorNetworkConditions !== undefined) {
      obj.poorNetworkConditions = CMsgPoorNetworkConditions.toJSON(message.poorNetworkConditions);
    }
    if (message.sendReason !== undefined && message.sendReason !== 0) {
      obj.sendReason = cMsgConnectedPlayers_SendReasonToJSON(message.sendReason);
    }
    if (message.radiantKills !== undefined && message.radiantKills !== 0) {
      obj.radiantKills = Math.round(message.radiantKills);
    }
    if (message.direKills !== undefined && message.direKills !== 0) {
      obj.direKills = Math.round(message.direKills);
    }
    if (message.radiantLead !== undefined && message.radiantLead !== 0) {
      obj.radiantLead = Math.round(message.radiantLead);
    }
    if (message.buildingState !== undefined && message.buildingState !== 0) {
      obj.buildingState = Math.round(message.buildingState);
    }
    if (message.playerDraft?.length) {
      obj.playerDraft = message.playerDraft.map((e) => CMsgConnectedPlayers_PlayerDraft.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgConnectedPlayers>): CMsgConnectedPlayers {
    return CMsgConnectedPlayers.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgConnectedPlayers>): CMsgConnectedPlayers {
    const message = createBaseCMsgConnectedPlayers();
    message.connectedPlayers = object.connectedPlayers?.map((e) => CMsgConnectedPlayers_Player.fromPartial(e)) || [];
    message.disconnectedPlayers = object.disconnectedPlayers?.map((e) => CMsgConnectedPlayers_Player.fromPartial(e)) ||
      [];
    message.gameState = object.gameState ?? 0;
    message.firstBloodHappened = object.firstBloodHappened ?? false;
    message.poorNetworkConditions =
      (object.poorNetworkConditions !== undefined && object.poorNetworkConditions !== null)
        ? CMsgPoorNetworkConditions.fromPartial(object.poorNetworkConditions)
        : undefined;
    message.sendReason = object.sendReason ?? 0;
    message.radiantKills = object.radiantKills ?? 0;
    message.direKills = object.direKills ?? 0;
    message.radiantLead = object.radiantLead ?? 0;
    message.buildingState = object.buildingState ?? 0;
    message.playerDraft = object.playerDraft?.map((e) => CMsgConnectedPlayers_PlayerDraft.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgConnectedPlayers_Player(): CMsgConnectedPlayers_Player {
  return { steamId: "0", heroId: 0, leaverState: undefined, disconnectReason: 0 };
}

export const CMsgConnectedPlayers_Player = {
  encode(message: CMsgConnectedPlayers_Player, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.steamId !== undefined && message.steamId !== "0") {
      writer.uint32(9).fixed64(message.steamId);
    }
    if (message.heroId !== undefined && message.heroId !== 0) {
      writer.uint32(16).int32(message.heroId);
    }
    if (message.leaverState !== undefined) {
      CMsgLeaverState.encode(message.leaverState, writer.uint32(26).fork()).ldelim();
    }
    if (message.disconnectReason !== undefined && message.disconnectReason !== 0) {
      writer.uint32(32).int32(message.disconnectReason);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgConnectedPlayers_Player {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgConnectedPlayers_Player();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.steamId = longToString(reader.fixed64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.heroId = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.leaverState = CMsgLeaverState.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.disconnectReason = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgConnectedPlayers_Player {
    return {
      steamId: isSet(object.steamId) ? globalThis.String(object.steamId) : "0",
      heroId: isSet(object.heroId) ? globalThis.Number(object.heroId) : 0,
      leaverState: isSet(object.leaverState) ? CMsgLeaverState.fromJSON(object.leaverState) : undefined,
      disconnectReason: isSet(object.disconnectReason)
        ? eNetworkDisconnectionReasonFromJSON(object.disconnectReason)
        : 0,
    };
  },

  toJSON(message: CMsgConnectedPlayers_Player): unknown {
    const obj: any = {};
    if (message.steamId !== undefined && message.steamId !== "0") {
      obj.steamId = message.steamId;
    }
    if (message.heroId !== undefined && message.heroId !== 0) {
      obj.heroId = Math.round(message.heroId);
    }
    if (message.leaverState !== undefined) {
      obj.leaverState = CMsgLeaverState.toJSON(message.leaverState);
    }
    if (message.disconnectReason !== undefined && message.disconnectReason !== 0) {
      obj.disconnectReason = eNetworkDisconnectionReasonToJSON(message.disconnectReason);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgConnectedPlayers_Player>): CMsgConnectedPlayers_Player {
    return CMsgConnectedPlayers_Player.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgConnectedPlayers_Player>): CMsgConnectedPlayers_Player {
    const message = createBaseCMsgConnectedPlayers_Player();
    message.steamId = object.steamId ?? "0";
    message.heroId = object.heroId ?? 0;
    message.leaverState = (object.leaverState !== undefined && object.leaverState !== null)
      ? CMsgLeaverState.fromPartial(object.leaverState)
      : undefined;
    message.disconnectReason = object.disconnectReason ?? 0;
    return message;
  },
};

function createBaseCMsgConnectedPlayers_PlayerDraft(): CMsgConnectedPlayers_PlayerDraft {
  return { steamId: "0", team: 0, teamSlot: 0 };
}

export const CMsgConnectedPlayers_PlayerDraft = {
  encode(message: CMsgConnectedPlayers_PlayerDraft, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.steamId !== undefined && message.steamId !== "0") {
      writer.uint32(9).fixed64(message.steamId);
    }
    if (message.team !== undefined && message.team !== 0) {
      writer.uint32(16).int32(message.team);
    }
    if (message.teamSlot !== undefined && message.teamSlot !== 0) {
      writer.uint32(24).int32(message.teamSlot);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgConnectedPlayers_PlayerDraft {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgConnectedPlayers_PlayerDraft();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.steamId = longToString(reader.fixed64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.team = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.teamSlot = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgConnectedPlayers_PlayerDraft {
    return {
      steamId: isSet(object.steamId) ? globalThis.String(object.steamId) : "0",
      team: isSet(object.team) ? dotaGcTeamFromJSON(object.team) : 0,
      teamSlot: isSet(object.teamSlot) ? globalThis.Number(object.teamSlot) : 0,
    };
  },

  toJSON(message: CMsgConnectedPlayers_PlayerDraft): unknown {
    const obj: any = {};
    if (message.steamId !== undefined && message.steamId !== "0") {
      obj.steamId = message.steamId;
    }
    if (message.team !== undefined && message.team !== 0) {
      obj.team = dotaGcTeamToJSON(message.team);
    }
    if (message.teamSlot !== undefined && message.teamSlot !== 0) {
      obj.teamSlot = Math.round(message.teamSlot);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgConnectedPlayers_PlayerDraft>): CMsgConnectedPlayers_PlayerDraft {
    return CMsgConnectedPlayers_PlayerDraft.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgConnectedPlayers_PlayerDraft>): CMsgConnectedPlayers_PlayerDraft {
    const message = createBaseCMsgConnectedPlayers_PlayerDraft();
    message.steamId = object.steamId ?? "0";
    message.team = object.team ?? 0;
    message.teamSlot = object.teamSlot ?? 0;
    return message;
  },
};

function createBaseCMsgGameServerInfo(): CMsgGameServerInfo {
  return {
    serverPublicIpAddr: 0,
    serverPrivateIpAddr: 0,
    serverPort: 0,
    serverTvPort: 0,
    assignedServerTvPort: 0,
    legacyServerSteamdatagramAddress: Buffer.alloc(0),
    serverKey: "",
    serverHibernation: false,
    serverType: 0,
    serverRegion: 0,
    serverLoadavg: 0,
    serverTvBroadcastTime: 0,
    serverGameTime: 0,
    serverRelayConnectedSteamId: "0",
    relaySlotsMax: 0,
    relaysConnected: 0,
    relayClientsConnected: 0,
    relayedGameServerSteamId: "0",
    parentRelayCount: 0,
    tvSecretCode: "0",
    serverVersion: 0,
    serverCluster: 0,
    allowCustomGames: 0,
    buildVersion: 0,
    srcdsInstance: 0,
    devForceServerType: false,
    isRecordingMatchTrainingData: false,
  };
}

export const CMsgGameServerInfo = {
  encode(message: CMsgGameServerInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.serverPublicIpAddr !== undefined && message.serverPublicIpAddr !== 0) {
      writer.uint32(13).fixed32(message.serverPublicIpAddr);
    }
    if (message.serverPrivateIpAddr !== undefined && message.serverPrivateIpAddr !== 0) {
      writer.uint32(21).fixed32(message.serverPrivateIpAddr);
    }
    if (message.serverPort !== undefined && message.serverPort !== 0) {
      writer.uint32(24).uint32(message.serverPort);
    }
    if (message.serverTvPort !== undefined && message.serverTvPort !== 0) {
      writer.uint32(32).uint32(message.serverTvPort);
    }
    if (message.assignedServerTvPort !== undefined && message.assignedServerTvPort !== 0) {
      writer.uint32(176).uint32(message.assignedServerTvPort);
    }
    if (
      message.legacyServerSteamdatagramAddress !== undefined && message.legacyServerSteamdatagramAddress.length !== 0
    ) {
      writer.uint32(218).bytes(message.legacyServerSteamdatagramAddress);
    }
    if (message.serverKey !== undefined && message.serverKey !== "") {
      writer.uint32(42).string(message.serverKey);
    }
    if (message.serverHibernation !== undefined && message.serverHibernation !== false) {
      writer.uint32(48).bool(message.serverHibernation);
    }
    if (message.serverType !== undefined && message.serverType !== 0) {
      writer.uint32(56).int32(message.serverType);
    }
    if (message.serverRegion !== undefined && message.serverRegion !== 0) {
      writer.uint32(64).uint32(message.serverRegion);
    }
    if (message.serverLoadavg !== undefined && message.serverLoadavg !== 0) {
      writer.uint32(77).float(message.serverLoadavg);
    }
    if (message.serverTvBroadcastTime !== undefined && message.serverTvBroadcastTime !== 0) {
      writer.uint32(85).float(message.serverTvBroadcastTime);
    }
    if (message.serverGameTime !== undefined && message.serverGameTime !== 0) {
      writer.uint32(93).float(message.serverGameTime);
    }
    if (message.serverRelayConnectedSteamId !== undefined && message.serverRelayConnectedSteamId !== "0") {
      writer.uint32(97).fixed64(message.serverRelayConnectedSteamId);
    }
    if (message.relaySlotsMax !== undefined && message.relaySlotsMax !== 0) {
      writer.uint32(104).uint32(message.relaySlotsMax);
    }
    if (message.relaysConnected !== undefined && message.relaysConnected !== 0) {
      writer.uint32(112).int32(message.relaysConnected);
    }
    if (message.relayClientsConnected !== undefined && message.relayClientsConnected !== 0) {
      writer.uint32(120).int32(message.relayClientsConnected);
    }
    if (message.relayedGameServerSteamId !== undefined && message.relayedGameServerSteamId !== "0") {
      writer.uint32(129).fixed64(message.relayedGameServerSteamId);
    }
    if (message.parentRelayCount !== undefined && message.parentRelayCount !== 0) {
      writer.uint32(136).uint32(message.parentRelayCount);
    }
    if (message.tvSecretCode !== undefined && message.tvSecretCode !== "0") {
      writer.uint32(145).fixed64(message.tvSecretCode);
    }
    if (message.serverVersion !== undefined && message.serverVersion !== 0) {
      writer.uint32(152).uint32(message.serverVersion);
    }
    if (message.serverCluster !== undefined && message.serverCluster !== 0) {
      writer.uint32(160).uint32(message.serverCluster);
    }
    if (message.allowCustomGames !== undefined && message.allowCustomGames !== 0) {
      writer.uint32(184).int32(message.allowCustomGames);
    }
    if (message.buildVersion !== undefined && message.buildVersion !== 0) {
      writer.uint32(192).uint32(message.buildVersion);
    }
    if (message.srcdsInstance !== undefined && message.srcdsInstance !== 0) {
      writer.uint32(208).uint32(message.srcdsInstance);
    }
    if (message.devForceServerType !== undefined && message.devForceServerType !== false) {
      writer.uint32(224).bool(message.devForceServerType);
    }
    if (message.isRecordingMatchTrainingData !== undefined && message.isRecordingMatchTrainingData !== false) {
      writer.uint32(232).bool(message.isRecordingMatchTrainingData);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGameServerInfo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGameServerInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.serverPublicIpAddr = reader.fixed32();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.serverPrivateIpAddr = reader.fixed32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.serverPort = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.serverTvPort = reader.uint32();
          continue;
        case 22:
          if (tag !== 176) {
            break;
          }

          message.assignedServerTvPort = reader.uint32();
          continue;
        case 27:
          if (tag !== 218) {
            break;
          }

          message.legacyServerSteamdatagramAddress = reader.bytes() as Buffer;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.serverKey = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.serverHibernation = reader.bool();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.serverType = reader.int32() as any;
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.serverRegion = reader.uint32();
          continue;
        case 9:
          if (tag !== 77) {
            break;
          }

          message.serverLoadavg = reader.float();
          continue;
        case 10:
          if (tag !== 85) {
            break;
          }

          message.serverTvBroadcastTime = reader.float();
          continue;
        case 11:
          if (tag !== 93) {
            break;
          }

          message.serverGameTime = reader.float();
          continue;
        case 12:
          if (tag !== 97) {
            break;
          }

          message.serverRelayConnectedSteamId = longToString(reader.fixed64() as Long);
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.relaySlotsMax = reader.uint32();
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.relaysConnected = reader.int32();
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.relayClientsConnected = reader.int32();
          continue;
        case 16:
          if (tag !== 129) {
            break;
          }

          message.relayedGameServerSteamId = longToString(reader.fixed64() as Long);
          continue;
        case 17:
          if (tag !== 136) {
            break;
          }

          message.parentRelayCount = reader.uint32();
          continue;
        case 18:
          if (tag !== 145) {
            break;
          }

          message.tvSecretCode = longToString(reader.fixed64() as Long);
          continue;
        case 19:
          if (tag !== 152) {
            break;
          }

          message.serverVersion = reader.uint32();
          continue;
        case 20:
          if (tag !== 160) {
            break;
          }

          message.serverCluster = reader.uint32();
          continue;
        case 23:
          if (tag !== 184) {
            break;
          }

          message.allowCustomGames = reader.int32() as any;
          continue;
        case 24:
          if (tag !== 192) {
            break;
          }

          message.buildVersion = reader.uint32();
          continue;
        case 26:
          if (tag !== 208) {
            break;
          }

          message.srcdsInstance = reader.uint32();
          continue;
        case 28:
          if (tag !== 224) {
            break;
          }

          message.devForceServerType = reader.bool();
          continue;
        case 29:
          if (tag !== 232) {
            break;
          }

          message.isRecordingMatchTrainingData = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGameServerInfo {
    return {
      serverPublicIpAddr: isSet(object.serverPublicIpAddr) ? globalThis.Number(object.serverPublicIpAddr) : 0,
      serverPrivateIpAddr: isSet(object.serverPrivateIpAddr) ? globalThis.Number(object.serverPrivateIpAddr) : 0,
      serverPort: isSet(object.serverPort) ? globalThis.Number(object.serverPort) : 0,
      serverTvPort: isSet(object.serverTvPort) ? globalThis.Number(object.serverTvPort) : 0,
      assignedServerTvPort: isSet(object.assignedServerTvPort) ? globalThis.Number(object.assignedServerTvPort) : 0,
      legacyServerSteamdatagramAddress: isSet(object.legacyServerSteamdatagramAddress)
        ? Buffer.from(bytesFromBase64(object.legacyServerSteamdatagramAddress))
        : Buffer.alloc(0),
      serverKey: isSet(object.serverKey) ? globalThis.String(object.serverKey) : "",
      serverHibernation: isSet(object.serverHibernation) ? globalThis.Boolean(object.serverHibernation) : false,
      serverType: isSet(object.serverType) ? cMsgGameServerInfo_ServerTypeFromJSON(object.serverType) : 0,
      serverRegion: isSet(object.serverRegion) ? globalThis.Number(object.serverRegion) : 0,
      serverLoadavg: isSet(object.serverLoadavg) ? globalThis.Number(object.serverLoadavg) : 0,
      serverTvBroadcastTime: isSet(object.serverTvBroadcastTime) ? globalThis.Number(object.serverTvBroadcastTime) : 0,
      serverGameTime: isSet(object.serverGameTime) ? globalThis.Number(object.serverGameTime) : 0,
      serverRelayConnectedSteamId: isSet(object.serverRelayConnectedSteamId)
        ? globalThis.String(object.serverRelayConnectedSteamId)
        : "0",
      relaySlotsMax: isSet(object.relaySlotsMax) ? globalThis.Number(object.relaySlotsMax) : 0,
      relaysConnected: isSet(object.relaysConnected) ? globalThis.Number(object.relaysConnected) : 0,
      relayClientsConnected: isSet(object.relayClientsConnected) ? globalThis.Number(object.relayClientsConnected) : 0,
      relayedGameServerSteamId: isSet(object.relayedGameServerSteamId)
        ? globalThis.String(object.relayedGameServerSteamId)
        : "0",
      parentRelayCount: isSet(object.parentRelayCount) ? globalThis.Number(object.parentRelayCount) : 0,
      tvSecretCode: isSet(object.tvSecretCode) ? globalThis.String(object.tvSecretCode) : "0",
      serverVersion: isSet(object.serverVersion) ? globalThis.Number(object.serverVersion) : 0,
      serverCluster: isSet(object.serverCluster) ? globalThis.Number(object.serverCluster) : 0,
      allowCustomGames: isSet(object.allowCustomGames)
        ? cMsgGameServerInfo_CustomGamesFromJSON(object.allowCustomGames)
        : 0,
      buildVersion: isSet(object.buildVersion) ? globalThis.Number(object.buildVersion) : 0,
      srcdsInstance: isSet(object.srcdsInstance) ? globalThis.Number(object.srcdsInstance) : 0,
      devForceServerType: isSet(object.devForceServerType) ? globalThis.Boolean(object.devForceServerType) : false,
      isRecordingMatchTrainingData: isSet(object.isRecordingMatchTrainingData)
        ? globalThis.Boolean(object.isRecordingMatchTrainingData)
        : false,
    };
  },

  toJSON(message: CMsgGameServerInfo): unknown {
    const obj: any = {};
    if (message.serverPublicIpAddr !== undefined && message.serverPublicIpAddr !== 0) {
      obj.serverPublicIpAddr = Math.round(message.serverPublicIpAddr);
    }
    if (message.serverPrivateIpAddr !== undefined && message.serverPrivateIpAddr !== 0) {
      obj.serverPrivateIpAddr = Math.round(message.serverPrivateIpAddr);
    }
    if (message.serverPort !== undefined && message.serverPort !== 0) {
      obj.serverPort = Math.round(message.serverPort);
    }
    if (message.serverTvPort !== undefined && message.serverTvPort !== 0) {
      obj.serverTvPort = Math.round(message.serverTvPort);
    }
    if (message.assignedServerTvPort !== undefined && message.assignedServerTvPort !== 0) {
      obj.assignedServerTvPort = Math.round(message.assignedServerTvPort);
    }
    if (
      message.legacyServerSteamdatagramAddress !== undefined && message.legacyServerSteamdatagramAddress.length !== 0
    ) {
      obj.legacyServerSteamdatagramAddress = base64FromBytes(message.legacyServerSteamdatagramAddress);
    }
    if (message.serverKey !== undefined && message.serverKey !== "") {
      obj.serverKey = message.serverKey;
    }
    if (message.serverHibernation !== undefined && message.serverHibernation !== false) {
      obj.serverHibernation = message.serverHibernation;
    }
    if (message.serverType !== undefined && message.serverType !== 0) {
      obj.serverType = cMsgGameServerInfo_ServerTypeToJSON(message.serverType);
    }
    if (message.serverRegion !== undefined && message.serverRegion !== 0) {
      obj.serverRegion = Math.round(message.serverRegion);
    }
    if (message.serverLoadavg !== undefined && message.serverLoadavg !== 0) {
      obj.serverLoadavg = message.serverLoadavg;
    }
    if (message.serverTvBroadcastTime !== undefined && message.serverTvBroadcastTime !== 0) {
      obj.serverTvBroadcastTime = message.serverTvBroadcastTime;
    }
    if (message.serverGameTime !== undefined && message.serverGameTime !== 0) {
      obj.serverGameTime = message.serverGameTime;
    }
    if (message.serverRelayConnectedSteamId !== undefined && message.serverRelayConnectedSteamId !== "0") {
      obj.serverRelayConnectedSteamId = message.serverRelayConnectedSteamId;
    }
    if (message.relaySlotsMax !== undefined && message.relaySlotsMax !== 0) {
      obj.relaySlotsMax = Math.round(message.relaySlotsMax);
    }
    if (message.relaysConnected !== undefined && message.relaysConnected !== 0) {
      obj.relaysConnected = Math.round(message.relaysConnected);
    }
    if (message.relayClientsConnected !== undefined && message.relayClientsConnected !== 0) {
      obj.relayClientsConnected = Math.round(message.relayClientsConnected);
    }
    if (message.relayedGameServerSteamId !== undefined && message.relayedGameServerSteamId !== "0") {
      obj.relayedGameServerSteamId = message.relayedGameServerSteamId;
    }
    if (message.parentRelayCount !== undefined && message.parentRelayCount !== 0) {
      obj.parentRelayCount = Math.round(message.parentRelayCount);
    }
    if (message.tvSecretCode !== undefined && message.tvSecretCode !== "0") {
      obj.tvSecretCode = message.tvSecretCode;
    }
    if (message.serverVersion !== undefined && message.serverVersion !== 0) {
      obj.serverVersion = Math.round(message.serverVersion);
    }
    if (message.serverCluster !== undefined && message.serverCluster !== 0) {
      obj.serverCluster = Math.round(message.serverCluster);
    }
    if (message.allowCustomGames !== undefined && message.allowCustomGames !== 0) {
      obj.allowCustomGames = cMsgGameServerInfo_CustomGamesToJSON(message.allowCustomGames);
    }
    if (message.buildVersion !== undefined && message.buildVersion !== 0) {
      obj.buildVersion = Math.round(message.buildVersion);
    }
    if (message.srcdsInstance !== undefined && message.srcdsInstance !== 0) {
      obj.srcdsInstance = Math.round(message.srcdsInstance);
    }
    if (message.devForceServerType !== undefined && message.devForceServerType !== false) {
      obj.devForceServerType = message.devForceServerType;
    }
    if (message.isRecordingMatchTrainingData !== undefined && message.isRecordingMatchTrainingData !== false) {
      obj.isRecordingMatchTrainingData = message.isRecordingMatchTrainingData;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGameServerInfo>): CMsgGameServerInfo {
    return CMsgGameServerInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGameServerInfo>): CMsgGameServerInfo {
    const message = createBaseCMsgGameServerInfo();
    message.serverPublicIpAddr = object.serverPublicIpAddr ?? 0;
    message.serverPrivateIpAddr = object.serverPrivateIpAddr ?? 0;
    message.serverPort = object.serverPort ?? 0;
    message.serverTvPort = object.serverTvPort ?? 0;
    message.assignedServerTvPort = object.assignedServerTvPort ?? 0;
    message.legacyServerSteamdatagramAddress = object.legacyServerSteamdatagramAddress ?? Buffer.alloc(0);
    message.serverKey = object.serverKey ?? "";
    message.serverHibernation = object.serverHibernation ?? false;
    message.serverType = object.serverType ?? 0;
    message.serverRegion = object.serverRegion ?? 0;
    message.serverLoadavg = object.serverLoadavg ?? 0;
    message.serverTvBroadcastTime = object.serverTvBroadcastTime ?? 0;
    message.serverGameTime = object.serverGameTime ?? 0;
    message.serverRelayConnectedSteamId = object.serverRelayConnectedSteamId ?? "0";
    message.relaySlotsMax = object.relaySlotsMax ?? 0;
    message.relaysConnected = object.relaysConnected ?? 0;
    message.relayClientsConnected = object.relayClientsConnected ?? 0;
    message.relayedGameServerSteamId = object.relayedGameServerSteamId ?? "0";
    message.parentRelayCount = object.parentRelayCount ?? 0;
    message.tvSecretCode = object.tvSecretCode ?? "0";
    message.serverVersion = object.serverVersion ?? 0;
    message.serverCluster = object.serverCluster ?? 0;
    message.allowCustomGames = object.allowCustomGames ?? 0;
    message.buildVersion = object.buildVersion ?? 0;
    message.srcdsInstance = object.srcdsInstance ?? 0;
    message.devForceServerType = object.devForceServerType ?? false;
    message.isRecordingMatchTrainingData = object.isRecordingMatchTrainingData ?? false;
    return message;
  },
};

function createBaseCMsgLeaverDetected(): CMsgLeaverDetected {
  return {
    steamId: "0",
    leaverStatus: 0,
    leaverState: undefined,
    serverCluster: 0,
    disconnectReason: 0,
    poorNetworkConditions: undefined,
  };
}

export const CMsgLeaverDetected = {
  encode(message: CMsgLeaverDetected, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.steamId !== undefined && message.steamId !== "0") {
      writer.uint32(9).fixed64(message.steamId);
    }
    if (message.leaverStatus !== undefined && message.leaverStatus !== 0) {
      writer.uint32(16).int32(message.leaverStatus);
    }
    if (message.leaverState !== undefined) {
      CMsgLeaverState.encode(message.leaverState, writer.uint32(34).fork()).ldelim();
    }
    if (message.serverCluster !== undefined && message.serverCluster !== 0) {
      writer.uint32(40).uint32(message.serverCluster);
    }
    if (message.disconnectReason !== undefined && message.disconnectReason !== 0) {
      writer.uint32(48).int32(message.disconnectReason);
    }
    if (message.poorNetworkConditions !== undefined) {
      CMsgPoorNetworkConditions.encode(message.poorNetworkConditions, writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgLeaverDetected {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgLeaverDetected();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.steamId = longToString(reader.fixed64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.leaverStatus = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.leaverState = CMsgLeaverState.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.serverCluster = reader.uint32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.disconnectReason = reader.int32() as any;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.poorNetworkConditions = CMsgPoorNetworkConditions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgLeaverDetected {
    return {
      steamId: isSet(object.steamId) ? globalThis.String(object.steamId) : "0",
      leaverStatus: isSet(object.leaverStatus) ? dOTALeaverStatusTFromJSON(object.leaverStatus) : 0,
      leaverState: isSet(object.leaverState) ? CMsgLeaverState.fromJSON(object.leaverState) : undefined,
      serverCluster: isSet(object.serverCluster) ? globalThis.Number(object.serverCluster) : 0,
      disconnectReason: isSet(object.disconnectReason)
        ? eNetworkDisconnectionReasonFromJSON(object.disconnectReason)
        : 0,
      poorNetworkConditions: isSet(object.poorNetworkConditions)
        ? CMsgPoorNetworkConditions.fromJSON(object.poorNetworkConditions)
        : undefined,
    };
  },

  toJSON(message: CMsgLeaverDetected): unknown {
    const obj: any = {};
    if (message.steamId !== undefined && message.steamId !== "0") {
      obj.steamId = message.steamId;
    }
    if (message.leaverStatus !== undefined && message.leaverStatus !== 0) {
      obj.leaverStatus = dOTALeaverStatusTToJSON(message.leaverStatus);
    }
    if (message.leaverState !== undefined) {
      obj.leaverState = CMsgLeaverState.toJSON(message.leaverState);
    }
    if (message.serverCluster !== undefined && message.serverCluster !== 0) {
      obj.serverCluster = Math.round(message.serverCluster);
    }
    if (message.disconnectReason !== undefined && message.disconnectReason !== 0) {
      obj.disconnectReason = eNetworkDisconnectionReasonToJSON(message.disconnectReason);
    }
    if (message.poorNetworkConditions !== undefined) {
      obj.poorNetworkConditions = CMsgPoorNetworkConditions.toJSON(message.poorNetworkConditions);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgLeaverDetected>): CMsgLeaverDetected {
    return CMsgLeaverDetected.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgLeaverDetected>): CMsgLeaverDetected {
    const message = createBaseCMsgLeaverDetected();
    message.steamId = object.steamId ?? "0";
    message.leaverStatus = object.leaverStatus ?? 0;
    message.leaverState = (object.leaverState !== undefined && object.leaverState !== null)
      ? CMsgLeaverState.fromPartial(object.leaverState)
      : undefined;
    message.serverCluster = object.serverCluster ?? 0;
    message.disconnectReason = object.disconnectReason ?? 0;
    message.poorNetworkConditions =
      (object.poorNetworkConditions !== undefined && object.poorNetworkConditions !== null)
        ? CMsgPoorNetworkConditions.fromPartial(object.poorNetworkConditions)
        : undefined;
    return message;
  },
};

function createBaseCMsgLeaverDetectedResponse(): CMsgLeaverDetectedResponse {
  return { result: 0 };
}

export const CMsgLeaverDetectedResponse = {
  encode(message: CMsgLeaverDetectedResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result !== undefined && message.result !== 0) {
      writer.uint32(8).uint32(message.result);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgLeaverDetectedResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgLeaverDetectedResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.result = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgLeaverDetectedResponse {
    return { result: isSet(object.result) ? globalThis.Number(object.result) : 0 };
  },

  toJSON(message: CMsgLeaverDetectedResponse): unknown {
    const obj: any = {};
    if (message.result !== undefined && message.result !== 0) {
      obj.result = Math.round(message.result);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgLeaverDetectedResponse>): CMsgLeaverDetectedResponse {
    return CMsgLeaverDetectedResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgLeaverDetectedResponse>): CMsgLeaverDetectedResponse {
    const message = createBaseCMsgLeaverDetectedResponse();
    message.result = object.result ?? 0;
    return message;
  },
};

function createBaseCMsgDOTAFantasyFinalPlayerStats(): CMsgDOTAFantasyFinalPlayerStats {
  return { stats: [] };
}

export const CMsgDOTAFantasyFinalPlayerStats = {
  encode(message: CMsgDOTAFantasyFinalPlayerStats, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.stats) {
      CMsgDOTAFantasyPlayerStats.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTAFantasyFinalPlayerStats {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAFantasyFinalPlayerStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.stats.push(CMsgDOTAFantasyPlayerStats.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAFantasyFinalPlayerStats {
    return {
      stats: globalThis.Array.isArray(object?.stats)
        ? object.stats.map((e: any) => CMsgDOTAFantasyPlayerStats.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgDOTAFantasyFinalPlayerStats): unknown {
    const obj: any = {};
    if (message.stats?.length) {
      obj.stats = message.stats.map((e) => CMsgDOTAFantasyPlayerStats.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTAFantasyFinalPlayerStats>): CMsgDOTAFantasyFinalPlayerStats {
    return CMsgDOTAFantasyFinalPlayerStats.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTAFantasyFinalPlayerStats>): CMsgDOTAFantasyFinalPlayerStats {
    const message = createBaseCMsgDOTAFantasyFinalPlayerStats();
    message.stats = object.stats?.map((e) => CMsgDOTAFantasyPlayerStats.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgDOTAFantasyLivePlayerStats(): CMsgDOTAFantasyLivePlayerStats {
  return { stats: [] };
}

export const CMsgDOTAFantasyLivePlayerStats = {
  encode(message: CMsgDOTAFantasyLivePlayerStats, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.stats) {
      CMsgDOTAFantasyPlayerStats.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTAFantasyLivePlayerStats {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAFantasyLivePlayerStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.stats.push(CMsgDOTAFantasyPlayerStats.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAFantasyLivePlayerStats {
    return {
      stats: globalThis.Array.isArray(object?.stats)
        ? object.stats.map((e: any) => CMsgDOTAFantasyPlayerStats.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgDOTAFantasyLivePlayerStats): unknown {
    const obj: any = {};
    if (message.stats?.length) {
      obj.stats = message.stats.map((e) => CMsgDOTAFantasyPlayerStats.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTAFantasyLivePlayerStats>): CMsgDOTAFantasyLivePlayerStats {
    return CMsgDOTAFantasyLivePlayerStats.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTAFantasyLivePlayerStats>): CMsgDOTAFantasyLivePlayerStats {
    const message = createBaseCMsgDOTAFantasyLivePlayerStats();
    message.stats = object.stats?.map((e) => CMsgDOTAFantasyPlayerStats.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgServerToGCRealtimeStats(): CMsgServerToGCRealtimeStats {
  return { delayed: undefined };
}

export const CMsgServerToGCRealtimeStats = {
  encode(message: CMsgServerToGCRealtimeStats, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.delayed !== undefined) {
      CMsgDOTARealtimeGameStatsTerse.encode(message.delayed, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgServerToGCRealtimeStats {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgServerToGCRealtimeStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.delayed = CMsgDOTARealtimeGameStatsTerse.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgServerToGCRealtimeStats {
    return { delayed: isSet(object.delayed) ? CMsgDOTARealtimeGameStatsTerse.fromJSON(object.delayed) : undefined };
  },

  toJSON(message: CMsgServerToGCRealtimeStats): unknown {
    const obj: any = {};
    if (message.delayed !== undefined) {
      obj.delayed = CMsgDOTARealtimeGameStatsTerse.toJSON(message.delayed);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgServerToGCRealtimeStats>): CMsgServerToGCRealtimeStats {
    return CMsgServerToGCRealtimeStats.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgServerToGCRealtimeStats>): CMsgServerToGCRealtimeStats {
    const message = createBaseCMsgServerToGCRealtimeStats();
    message.delayed = (object.delayed !== undefined && object.delayed !== null)
      ? CMsgDOTARealtimeGameStatsTerse.fromPartial(object.delayed)
      : undefined;
    return message;
  },
};

function createBaseCMsgGCToServerRealtimeStatsStartStop(): CMsgGCToServerRealtimeStatsStartStop {
  return { delayed: false };
}

export const CMsgGCToServerRealtimeStatsStartStop = {
  encode(message: CMsgGCToServerRealtimeStatsStartStop, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.delayed !== undefined && message.delayed !== false) {
      writer.uint32(8).bool(message.delayed);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToServerRealtimeStatsStartStop {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToServerRealtimeStatsStartStop();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.delayed = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToServerRealtimeStatsStartStop {
    return { delayed: isSet(object.delayed) ? globalThis.Boolean(object.delayed) : false };
  },

  toJSON(message: CMsgGCToServerRealtimeStatsStartStop): unknown {
    const obj: any = {};
    if (message.delayed !== undefined && message.delayed !== false) {
      obj.delayed = message.delayed;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCToServerRealtimeStatsStartStop>): CMsgGCToServerRealtimeStatsStartStop {
    return CMsgGCToServerRealtimeStatsStartStop.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCToServerRealtimeStatsStartStop>): CMsgGCToServerRealtimeStatsStartStop {
    const message = createBaseCMsgGCToServerRealtimeStatsStartStop();
    message.delayed = object.delayed ?? false;
    return message;
  },
};

function createBaseCMsgGCToServerUpdateSteamBroadcasting(): CMsgGCToServerUpdateSteamBroadcasting {
  return { active: false };
}

export const CMsgGCToServerUpdateSteamBroadcasting = {
  encode(message: CMsgGCToServerUpdateSteamBroadcasting, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.active !== undefined && message.active !== false) {
      writer.uint32(8).bool(message.active);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToServerUpdateSteamBroadcasting {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToServerUpdateSteamBroadcasting();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.active = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToServerUpdateSteamBroadcasting {
    return { active: isSet(object.active) ? globalThis.Boolean(object.active) : false };
  },

  toJSON(message: CMsgGCToServerUpdateSteamBroadcasting): unknown {
    const obj: any = {};
    if (message.active !== undefined && message.active !== false) {
      obj.active = message.active;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCToServerUpdateSteamBroadcasting>): CMsgGCToServerUpdateSteamBroadcasting {
    return CMsgGCToServerUpdateSteamBroadcasting.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCToServerUpdateSteamBroadcasting>): CMsgGCToServerUpdateSteamBroadcasting {
    const message = createBaseCMsgGCToServerUpdateSteamBroadcasting();
    message.active = object.active ?? false;
    return message;
  },
};

function createBaseCMsgSignOutGameplayStats(): CMsgSignOutGameplayStats {
  return { teams: [] };
}

export const CMsgSignOutGameplayStats = {
  encode(message: CMsgSignOutGameplayStats, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.teams) {
      CMsgSignOutGameplayStats_CTeam.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSignOutGameplayStats {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSignOutGameplayStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.teams.push(CMsgSignOutGameplayStats_CTeam.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSignOutGameplayStats {
    return {
      teams: globalThis.Array.isArray(object?.teams)
        ? object.teams.map((e: any) => CMsgSignOutGameplayStats_CTeam.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgSignOutGameplayStats): unknown {
    const obj: any = {};
    if (message.teams?.length) {
      obj.teams = message.teams.map((e) => CMsgSignOutGameplayStats_CTeam.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSignOutGameplayStats>): CMsgSignOutGameplayStats {
    return CMsgSignOutGameplayStats.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSignOutGameplayStats>): CMsgSignOutGameplayStats {
    const message = createBaseCMsgSignOutGameplayStats();
    message.teams = object.teams?.map((e) => CMsgSignOutGameplayStats_CTeam.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgSignOutGameplayStats_CPlayer(): CMsgSignOutGameplayStats_CPlayer {
  return { steamId: "0", playerSlot: 0, heroId: 0, timedPlayerStats: [] };
}

export const CMsgSignOutGameplayStats_CPlayer = {
  encode(message: CMsgSignOutGameplayStats_CPlayer, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.steamId !== undefined && message.steamId !== "0") {
      writer.uint32(9).fixed64(message.steamId);
    }
    if (message.playerSlot !== undefined && message.playerSlot !== 0) {
      writer.uint32(16).uint32(message.playerSlot);
    }
    if (message.heroId !== undefined && message.heroId !== 0) {
      writer.uint32(24).int32(message.heroId);
    }
    for (const v of message.timedPlayerStats) {
      CMatchPlayerTimedStats.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSignOutGameplayStats_CPlayer {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSignOutGameplayStats_CPlayer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.steamId = longToString(reader.fixed64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.playerSlot = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.heroId = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.timedPlayerStats.push(CMatchPlayerTimedStats.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSignOutGameplayStats_CPlayer {
    return {
      steamId: isSet(object.steamId) ? globalThis.String(object.steamId) : "0",
      playerSlot: isSet(object.playerSlot) ? globalThis.Number(object.playerSlot) : 0,
      heroId: isSet(object.heroId) ? globalThis.Number(object.heroId) : 0,
      timedPlayerStats: globalThis.Array.isArray(object?.timedPlayerStats)
        ? object.timedPlayerStats.map((e: any) => CMatchPlayerTimedStats.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgSignOutGameplayStats_CPlayer): unknown {
    const obj: any = {};
    if (message.steamId !== undefined && message.steamId !== "0") {
      obj.steamId = message.steamId;
    }
    if (message.playerSlot !== undefined && message.playerSlot !== 0) {
      obj.playerSlot = Math.round(message.playerSlot);
    }
    if (message.heroId !== undefined && message.heroId !== 0) {
      obj.heroId = Math.round(message.heroId);
    }
    if (message.timedPlayerStats?.length) {
      obj.timedPlayerStats = message.timedPlayerStats.map((e) => CMatchPlayerTimedStats.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSignOutGameplayStats_CPlayer>): CMsgSignOutGameplayStats_CPlayer {
    return CMsgSignOutGameplayStats_CPlayer.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSignOutGameplayStats_CPlayer>): CMsgSignOutGameplayStats_CPlayer {
    const message = createBaseCMsgSignOutGameplayStats_CPlayer();
    message.steamId = object.steamId ?? "0";
    message.playerSlot = object.playerSlot ?? 0;
    message.heroId = object.heroId ?? 0;
    message.timedPlayerStats = object.timedPlayerStats?.map((e) => CMatchPlayerTimedStats.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgSignOutGameplayStats_CTeam(): CMsgSignOutGameplayStats_CTeam {
  return { isWinningTeam: false, isRadiantTeam: false, timedTeamStats: [], players: [] };
}

export const CMsgSignOutGameplayStats_CTeam = {
  encode(message: CMsgSignOutGameplayStats_CTeam, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.isWinningTeam !== undefined && message.isWinningTeam !== false) {
      writer.uint32(8).bool(message.isWinningTeam);
    }
    if (message.isRadiantTeam !== undefined && message.isRadiantTeam !== false) {
      writer.uint32(16).bool(message.isRadiantTeam);
    }
    for (const v of message.timedTeamStats) {
      CMatchTeamTimedStats.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    for (const v of message.players) {
      CMsgSignOutGameplayStats_CPlayer.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSignOutGameplayStats_CTeam {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSignOutGameplayStats_CTeam();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.isWinningTeam = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.isRadiantTeam = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.timedTeamStats.push(CMatchTeamTimedStats.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.players.push(CMsgSignOutGameplayStats_CPlayer.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSignOutGameplayStats_CTeam {
    return {
      isWinningTeam: isSet(object.isWinningTeam) ? globalThis.Boolean(object.isWinningTeam) : false,
      isRadiantTeam: isSet(object.isRadiantTeam) ? globalThis.Boolean(object.isRadiantTeam) : false,
      timedTeamStats: globalThis.Array.isArray(object?.timedTeamStats)
        ? object.timedTeamStats.map((e: any) => CMatchTeamTimedStats.fromJSON(e))
        : [],
      players: globalThis.Array.isArray(object?.players)
        ? object.players.map((e: any) => CMsgSignOutGameplayStats_CPlayer.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgSignOutGameplayStats_CTeam): unknown {
    const obj: any = {};
    if (message.isWinningTeam !== undefined && message.isWinningTeam !== false) {
      obj.isWinningTeam = message.isWinningTeam;
    }
    if (message.isRadiantTeam !== undefined && message.isRadiantTeam !== false) {
      obj.isRadiantTeam = message.isRadiantTeam;
    }
    if (message.timedTeamStats?.length) {
      obj.timedTeamStats = message.timedTeamStats.map((e) => CMatchTeamTimedStats.toJSON(e));
    }
    if (message.players?.length) {
      obj.players = message.players.map((e) => CMsgSignOutGameplayStats_CPlayer.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSignOutGameplayStats_CTeam>): CMsgSignOutGameplayStats_CTeam {
    return CMsgSignOutGameplayStats_CTeam.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSignOutGameplayStats_CTeam>): CMsgSignOutGameplayStats_CTeam {
    const message = createBaseCMsgSignOutGameplayStats_CTeam();
    message.isWinningTeam = object.isWinningTeam ?? false;
    message.isRadiantTeam = object.isRadiantTeam ?? false;
    message.timedTeamStats = object.timedTeamStats?.map((e) => CMatchTeamTimedStats.fromPartial(e)) || [];
    message.players = object.players?.map((e) => CMsgSignOutGameplayStats_CPlayer.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgGameMatchSignOut(): CMsgGameMatchSignOut {
  return {
    matchId: "0",
    duration: 0,
    goodGuysWin: false,
    date: 0,
    teams: [],
    towerStatus: [],
    barracksStatus: [],
    cluster: 0,
    serverAddr: "",
    firstBloodTime: 0,
    eventScore: 0,
    fantasyStats: [],
    playerStrangeCountAdjustments: [],
    automaticSurrender: false,
    serverVersion: 0,
    poorNetworkConditions: undefined,
    additionalMsgs: [],
    socialFeedEvents: [],
    averageNetworthDelta: 0,
    customGameData: undefined,
    matchFlags: 0,
    teamScores: [],
    preGameDuration: 0,
    eventGameLeaderboardEntries: [],
    wardPlacements: [],
    gameplayStats: undefined,
    extraMessages: [],
    trainingDataRecorded: false,
    winningTeam: 0,
    normalizedWinProbabilityDiff: 0,
    matchTrackedStats: [],
  };
}

export const CMsgGameMatchSignOut = {
  encode(message: CMsgGameMatchSignOut, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.matchId !== undefined && message.matchId !== "0") {
      writer.uint32(8).uint64(message.matchId);
    }
    if (message.duration !== undefined && message.duration !== 0) {
      writer.uint32(16).uint32(message.duration);
    }
    if (message.goodGuysWin !== undefined && message.goodGuysWin !== false) {
      writer.uint32(24).bool(message.goodGuysWin);
    }
    if (message.date !== undefined && message.date !== 0) {
      writer.uint32(37).fixed32(message.date);
    }
    for (const v of message.teams) {
      CMsgGameMatchSignOut_CTeam.encode(v!, writer.uint32(50).fork()).ldelim();
    }
    writer.uint32(66).fork();
    for (const v of message.towerStatus) {
      writer.uint32(v);
    }
    writer.ldelim();
    writer.uint32(74).fork();
    for (const v of message.barracksStatus) {
      writer.uint32(v);
    }
    writer.ldelim();
    if (message.cluster !== undefined && message.cluster !== 0) {
      writer.uint32(80).uint32(message.cluster);
    }
    if (message.serverAddr !== undefined && message.serverAddr !== "") {
      writer.uint32(90).string(message.serverAddr);
    }
    if (message.firstBloodTime !== undefined && message.firstBloodTime !== 0) {
      writer.uint32(96).uint32(message.firstBloodTime);
    }
    if (message.eventScore !== undefined && message.eventScore !== 0) {
      writer.uint32(112).uint32(message.eventScore);
    }
    for (const v of message.fantasyStats) {
      CMsgDOTAFantasyPlayerStats.encode(v!, writer.uint32(330).fork()).ldelim();
    }
    for (const v of message.playerStrangeCountAdjustments) {
      CMsgEconPlayerStrangeCountAdjustment.encode(v!, writer.uint32(138).fork()).ldelim();
    }
    if (message.automaticSurrender !== undefined && message.automaticSurrender !== false) {
      writer.uint32(144).bool(message.automaticSurrender);
    }
    if (message.serverVersion !== undefined && message.serverVersion !== 0) {
      writer.uint32(152).uint32(message.serverVersion);
    }
    if (message.poorNetworkConditions !== undefined) {
      CMsgPoorNetworkConditions.encode(message.poorNetworkConditions, writer.uint32(282).fork()).ldelim();
    }
    for (const v of message.additionalMsgs) {
      CMsgGameMatchSignOut_CAdditionalSignoutMsg.encode(v!, writer.uint32(162).fork()).ldelim();
    }
    for (const v of message.socialFeedEvents) {
      CMsgGameMatchSignOut_CSocialFeedMatchEvent.encode(v!, writer.uint32(290).fork()).ldelim();
    }
    if (message.averageNetworthDelta !== undefined && message.averageNetworthDelta !== 0) {
      writer.uint32(176).sint32(message.averageNetworthDelta);
    }
    if (message.customGameData !== undefined) {
      CMsgGameMatchSignOut_CCustomGameData.encode(message.customGameData, writer.uint32(298).fork()).ldelim();
    }
    if (message.matchFlags !== undefined && message.matchFlags !== 0) {
      writer.uint32(304).uint32(message.matchFlags);
    }
    writer.uint32(314).fork();
    for (const v of message.teamScores) {
      writer.uint32(v);
    }
    writer.ldelim();
    if (message.preGameDuration !== undefined && message.preGameDuration !== 0) {
      writer.uint32(320).uint32(message.preGameDuration);
    }
    for (const v of message.eventGameLeaderboardEntries) {
      CMsgGameMatchSignOut_EventGameLeaderboardEntry.encode(v!, writer.uint32(338).fork()).ldelim();
    }
    for (const v of message.wardPlacements) {
      CMsgGameMatchSignOut_WardPlacement.encode(v!, writer.uint32(346).fork()).ldelim();
    }
    if (message.gameplayStats !== undefined) {
      CMsgSignOutGameplayStats.encode(message.gameplayStats, writer.uint32(354).fork()).ldelim();
    }
    for (const v of message.extraMessages) {
      CExtraMsgBlock.encode(v!, writer.uint32(434).fork()).ldelim();
    }
    if (message.trainingDataRecorded !== undefined && message.trainingDataRecorded !== false) {
      writer.uint32(440).bool(message.trainingDataRecorded);
    }
    if (message.winningTeam !== undefined && message.winningTeam !== 0) {
      writer.uint32(448).int32(message.winningTeam);
    }
    if (message.normalizedWinProbabilityDiff !== undefined && message.normalizedWinProbabilityDiff !== 0) {
      writer.uint32(461).float(message.normalizedWinProbabilityDiff);
    }
    for (const v of message.matchTrackedStats) {
      CMsgTrackedStat.encode(v!, writer.uint32(466).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGameMatchSignOut {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGameMatchSignOut();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.matchId = longToString(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.duration = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.goodGuysWin = reader.bool();
          continue;
        case 4:
          if (tag !== 37) {
            break;
          }

          message.date = reader.fixed32();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.teams.push(CMsgGameMatchSignOut_CTeam.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag === 64) {
            message.towerStatus.push(reader.uint32());

            continue;
          }

          if (tag === 66) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.towerStatus.push(reader.uint32());
            }

            continue;
          }

          break;
        case 9:
          if (tag === 72) {
            message.barracksStatus.push(reader.uint32());

            continue;
          }

          if (tag === 74) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.barracksStatus.push(reader.uint32());
            }

            continue;
          }

          break;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.cluster = reader.uint32();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.serverAddr = reader.string();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.firstBloodTime = reader.uint32();
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.eventScore = reader.uint32();
          continue;
        case 41:
          if (tag !== 330) {
            break;
          }

          message.fantasyStats.push(CMsgDOTAFantasyPlayerStats.decode(reader, reader.uint32()));
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.playerStrangeCountAdjustments.push(
            CMsgEconPlayerStrangeCountAdjustment.decode(reader, reader.uint32()),
          );
          continue;
        case 18:
          if (tag !== 144) {
            break;
          }

          message.automaticSurrender = reader.bool();
          continue;
        case 19:
          if (tag !== 152) {
            break;
          }

          message.serverVersion = reader.uint32();
          continue;
        case 35:
          if (tag !== 282) {
            break;
          }

          message.poorNetworkConditions = CMsgPoorNetworkConditions.decode(reader, reader.uint32());
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.additionalMsgs.push(CMsgGameMatchSignOut_CAdditionalSignoutMsg.decode(reader, reader.uint32()));
          continue;
        case 36:
          if (tag !== 290) {
            break;
          }

          message.socialFeedEvents.push(CMsgGameMatchSignOut_CSocialFeedMatchEvent.decode(reader, reader.uint32()));
          continue;
        case 22:
          if (tag !== 176) {
            break;
          }

          message.averageNetworthDelta = reader.sint32();
          continue;
        case 37:
          if (tag !== 298) {
            break;
          }

          message.customGameData = CMsgGameMatchSignOut_CCustomGameData.decode(reader, reader.uint32());
          continue;
        case 38:
          if (tag !== 304) {
            break;
          }

          message.matchFlags = reader.uint32();
          continue;
        case 39:
          if (tag === 312) {
            message.teamScores.push(reader.uint32());

            continue;
          }

          if (tag === 314) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.teamScores.push(reader.uint32());
            }

            continue;
          }

          break;
        case 40:
          if (tag !== 320) {
            break;
          }

          message.preGameDuration = reader.uint32();
          continue;
        case 42:
          if (tag !== 338) {
            break;
          }

          message.eventGameLeaderboardEntries.push(
            CMsgGameMatchSignOut_EventGameLeaderboardEntry.decode(reader, reader.uint32()),
          );
          continue;
        case 43:
          if (tag !== 346) {
            break;
          }

          message.wardPlacements.push(CMsgGameMatchSignOut_WardPlacement.decode(reader, reader.uint32()));
          continue;
        case 44:
          if (tag !== 354) {
            break;
          }

          message.gameplayStats = CMsgSignOutGameplayStats.decode(reader, reader.uint32());
          continue;
        case 54:
          if (tag !== 434) {
            break;
          }

          message.extraMessages.push(CExtraMsgBlock.decode(reader, reader.uint32()));
          continue;
        case 55:
          if (tag !== 440) {
            break;
          }

          message.trainingDataRecorded = reader.bool();
          continue;
        case 56:
          if (tag !== 448) {
            break;
          }

          message.winningTeam = reader.int32() as any;
          continue;
        case 57:
          if (tag !== 461) {
            break;
          }

          message.normalizedWinProbabilityDiff = reader.float();
          continue;
        case 58:
          if (tag !== 466) {
            break;
          }

          message.matchTrackedStats.push(CMsgTrackedStat.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGameMatchSignOut {
    return {
      matchId: isSet(object.matchId) ? globalThis.String(object.matchId) : "0",
      duration: isSet(object.duration) ? globalThis.Number(object.duration) : 0,
      goodGuysWin: isSet(object.goodGuysWin) ? globalThis.Boolean(object.goodGuysWin) : false,
      date: isSet(object.date) ? globalThis.Number(object.date) : 0,
      teams: globalThis.Array.isArray(object?.teams)
        ? object.teams.map((e: any) => CMsgGameMatchSignOut_CTeam.fromJSON(e))
        : [],
      towerStatus: globalThis.Array.isArray(object?.towerStatus)
        ? object.towerStatus.map((e: any) => globalThis.Number(e))
        : [],
      barracksStatus: globalThis.Array.isArray(object?.barracksStatus)
        ? object.barracksStatus.map((e: any) => globalThis.Number(e))
        : [],
      cluster: isSet(object.cluster) ? globalThis.Number(object.cluster) : 0,
      serverAddr: isSet(object.serverAddr) ? globalThis.String(object.serverAddr) : "",
      firstBloodTime: isSet(object.firstBloodTime) ? globalThis.Number(object.firstBloodTime) : 0,
      eventScore: isSet(object.eventScore) ? globalThis.Number(object.eventScore) : 0,
      fantasyStats: globalThis.Array.isArray(object?.fantasyStats)
        ? object.fantasyStats.map((e: any) => CMsgDOTAFantasyPlayerStats.fromJSON(e))
        : [],
      playerStrangeCountAdjustments: globalThis.Array.isArray(object?.playerStrangeCountAdjustments)
        ? object.playerStrangeCountAdjustments.map((e: any) => CMsgEconPlayerStrangeCountAdjustment.fromJSON(e))
        : [],
      automaticSurrender: isSet(object.automaticSurrender) ? globalThis.Boolean(object.automaticSurrender) : false,
      serverVersion: isSet(object.serverVersion) ? globalThis.Number(object.serverVersion) : 0,
      poorNetworkConditions: isSet(object.poorNetworkConditions)
        ? CMsgPoorNetworkConditions.fromJSON(object.poorNetworkConditions)
        : undefined,
      additionalMsgs: globalThis.Array.isArray(object?.additionalMsgs)
        ? object.additionalMsgs.map((e: any) => CMsgGameMatchSignOut_CAdditionalSignoutMsg.fromJSON(e))
        : [],
      socialFeedEvents: globalThis.Array.isArray(object?.socialFeedEvents)
        ? object.socialFeedEvents.map((e: any) => CMsgGameMatchSignOut_CSocialFeedMatchEvent.fromJSON(e))
        : [],
      averageNetworthDelta: isSet(object.averageNetworthDelta) ? globalThis.Number(object.averageNetworthDelta) : 0,
      customGameData: isSet(object.customGameData)
        ? CMsgGameMatchSignOut_CCustomGameData.fromJSON(object.customGameData)
        : undefined,
      matchFlags: isSet(object.matchFlags) ? globalThis.Number(object.matchFlags) : 0,
      teamScores: globalThis.Array.isArray(object?.teamScores)
        ? object.teamScores.map((e: any) => globalThis.Number(e))
        : [],
      preGameDuration: isSet(object.preGameDuration) ? globalThis.Number(object.preGameDuration) : 0,
      eventGameLeaderboardEntries: globalThis.Array.isArray(object?.eventGameLeaderboardEntries)
        ? object.eventGameLeaderboardEntries.map((e: any) => CMsgGameMatchSignOut_EventGameLeaderboardEntry.fromJSON(e))
        : [],
      wardPlacements: globalThis.Array.isArray(object?.wardPlacements)
        ? object.wardPlacements.map((e: any) => CMsgGameMatchSignOut_WardPlacement.fromJSON(e))
        : [],
      gameplayStats: isSet(object.gameplayStats) ? CMsgSignOutGameplayStats.fromJSON(object.gameplayStats) : undefined,
      extraMessages: globalThis.Array.isArray(object?.extraMessages)
        ? object.extraMessages.map((e: any) => CExtraMsgBlock.fromJSON(e))
        : [],
      trainingDataRecorded: isSet(object.trainingDataRecorded)
        ? globalThis.Boolean(object.trainingDataRecorded)
        : false,
      winningTeam: isSet(object.winningTeam) ? dotaGcTeamFromJSON(object.winningTeam) : 0,
      normalizedWinProbabilityDiff: isSet(object.normalizedWinProbabilityDiff)
        ? globalThis.Number(object.normalizedWinProbabilityDiff)
        : 0,
      matchTrackedStats: globalThis.Array.isArray(object?.matchTrackedStats)
        ? object.matchTrackedStats.map((e: any) => CMsgTrackedStat.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgGameMatchSignOut): unknown {
    const obj: any = {};
    if (message.matchId !== undefined && message.matchId !== "0") {
      obj.matchId = message.matchId;
    }
    if (message.duration !== undefined && message.duration !== 0) {
      obj.duration = Math.round(message.duration);
    }
    if (message.goodGuysWin !== undefined && message.goodGuysWin !== false) {
      obj.goodGuysWin = message.goodGuysWin;
    }
    if (message.date !== undefined && message.date !== 0) {
      obj.date = Math.round(message.date);
    }
    if (message.teams?.length) {
      obj.teams = message.teams.map((e) => CMsgGameMatchSignOut_CTeam.toJSON(e));
    }
    if (message.towerStatus?.length) {
      obj.towerStatus = message.towerStatus.map((e) => Math.round(e));
    }
    if (message.barracksStatus?.length) {
      obj.barracksStatus = message.barracksStatus.map((e) => Math.round(e));
    }
    if (message.cluster !== undefined && message.cluster !== 0) {
      obj.cluster = Math.round(message.cluster);
    }
    if (message.serverAddr !== undefined && message.serverAddr !== "") {
      obj.serverAddr = message.serverAddr;
    }
    if (message.firstBloodTime !== undefined && message.firstBloodTime !== 0) {
      obj.firstBloodTime = Math.round(message.firstBloodTime);
    }
    if (message.eventScore !== undefined && message.eventScore !== 0) {
      obj.eventScore = Math.round(message.eventScore);
    }
    if (message.fantasyStats?.length) {
      obj.fantasyStats = message.fantasyStats.map((e) => CMsgDOTAFantasyPlayerStats.toJSON(e));
    }
    if (message.playerStrangeCountAdjustments?.length) {
      obj.playerStrangeCountAdjustments = message.playerStrangeCountAdjustments.map((e) =>
        CMsgEconPlayerStrangeCountAdjustment.toJSON(e)
      );
    }
    if (message.automaticSurrender !== undefined && message.automaticSurrender !== false) {
      obj.automaticSurrender = message.automaticSurrender;
    }
    if (message.serverVersion !== undefined && message.serverVersion !== 0) {
      obj.serverVersion = Math.round(message.serverVersion);
    }
    if (message.poorNetworkConditions !== undefined) {
      obj.poorNetworkConditions = CMsgPoorNetworkConditions.toJSON(message.poorNetworkConditions);
    }
    if (message.additionalMsgs?.length) {
      obj.additionalMsgs = message.additionalMsgs.map((e) => CMsgGameMatchSignOut_CAdditionalSignoutMsg.toJSON(e));
    }
    if (message.socialFeedEvents?.length) {
      obj.socialFeedEvents = message.socialFeedEvents.map((e) => CMsgGameMatchSignOut_CSocialFeedMatchEvent.toJSON(e));
    }
    if (message.averageNetworthDelta !== undefined && message.averageNetworthDelta !== 0) {
      obj.averageNetworthDelta = Math.round(message.averageNetworthDelta);
    }
    if (message.customGameData !== undefined) {
      obj.customGameData = CMsgGameMatchSignOut_CCustomGameData.toJSON(message.customGameData);
    }
    if (message.matchFlags !== undefined && message.matchFlags !== 0) {
      obj.matchFlags = Math.round(message.matchFlags);
    }
    if (message.teamScores?.length) {
      obj.teamScores = message.teamScores.map((e) => Math.round(e));
    }
    if (message.preGameDuration !== undefined && message.preGameDuration !== 0) {
      obj.preGameDuration = Math.round(message.preGameDuration);
    }
    if (message.eventGameLeaderboardEntries?.length) {
      obj.eventGameLeaderboardEntries = message.eventGameLeaderboardEntries.map((e) =>
        CMsgGameMatchSignOut_EventGameLeaderboardEntry.toJSON(e)
      );
    }
    if (message.wardPlacements?.length) {
      obj.wardPlacements = message.wardPlacements.map((e) => CMsgGameMatchSignOut_WardPlacement.toJSON(e));
    }
    if (message.gameplayStats !== undefined) {
      obj.gameplayStats = CMsgSignOutGameplayStats.toJSON(message.gameplayStats);
    }
    if (message.extraMessages?.length) {
      obj.extraMessages = message.extraMessages.map((e) => CExtraMsgBlock.toJSON(e));
    }
    if (message.trainingDataRecorded !== undefined && message.trainingDataRecorded !== false) {
      obj.trainingDataRecorded = message.trainingDataRecorded;
    }
    if (message.winningTeam !== undefined && message.winningTeam !== 0) {
      obj.winningTeam = dotaGcTeamToJSON(message.winningTeam);
    }
    if (message.normalizedWinProbabilityDiff !== undefined && message.normalizedWinProbabilityDiff !== 0) {
      obj.normalizedWinProbabilityDiff = message.normalizedWinProbabilityDiff;
    }
    if (message.matchTrackedStats?.length) {
      obj.matchTrackedStats = message.matchTrackedStats.map((e) => CMsgTrackedStat.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGameMatchSignOut>): CMsgGameMatchSignOut {
    return CMsgGameMatchSignOut.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGameMatchSignOut>): CMsgGameMatchSignOut {
    const message = createBaseCMsgGameMatchSignOut();
    message.matchId = object.matchId ?? "0";
    message.duration = object.duration ?? 0;
    message.goodGuysWin = object.goodGuysWin ?? false;
    message.date = object.date ?? 0;
    message.teams = object.teams?.map((e) => CMsgGameMatchSignOut_CTeam.fromPartial(e)) || [];
    message.towerStatus = object.towerStatus?.map((e) => e) || [];
    message.barracksStatus = object.barracksStatus?.map((e) => e) || [];
    message.cluster = object.cluster ?? 0;
    message.serverAddr = object.serverAddr ?? "";
    message.firstBloodTime = object.firstBloodTime ?? 0;
    message.eventScore = object.eventScore ?? 0;
    message.fantasyStats = object.fantasyStats?.map((e) => CMsgDOTAFantasyPlayerStats.fromPartial(e)) || [];
    message.playerStrangeCountAdjustments =
      object.playerStrangeCountAdjustments?.map((e) => CMsgEconPlayerStrangeCountAdjustment.fromPartial(e)) || [];
    message.automaticSurrender = object.automaticSurrender ?? false;
    message.serverVersion = object.serverVersion ?? 0;
    message.poorNetworkConditions =
      (object.poorNetworkConditions !== undefined && object.poorNetworkConditions !== null)
        ? CMsgPoorNetworkConditions.fromPartial(object.poorNetworkConditions)
        : undefined;
    message.additionalMsgs =
      object.additionalMsgs?.map((e) => CMsgGameMatchSignOut_CAdditionalSignoutMsg.fromPartial(e)) || [];
    message.socialFeedEvents =
      object.socialFeedEvents?.map((e) => CMsgGameMatchSignOut_CSocialFeedMatchEvent.fromPartial(e)) || [];
    message.averageNetworthDelta = object.averageNetworthDelta ?? 0;
    message.customGameData = (object.customGameData !== undefined && object.customGameData !== null)
      ? CMsgGameMatchSignOut_CCustomGameData.fromPartial(object.customGameData)
      : undefined;
    message.matchFlags = object.matchFlags ?? 0;
    message.teamScores = object.teamScores?.map((e) => e) || [];
    message.preGameDuration = object.preGameDuration ?? 0;
    message.eventGameLeaderboardEntries =
      object.eventGameLeaderboardEntries?.map((e) => CMsgGameMatchSignOut_EventGameLeaderboardEntry.fromPartial(e)) ||
      [];
    message.wardPlacements = object.wardPlacements?.map((e) => CMsgGameMatchSignOut_WardPlacement.fromPartial(e)) || [];
    message.gameplayStats = (object.gameplayStats !== undefined && object.gameplayStats !== null)
      ? CMsgSignOutGameplayStats.fromPartial(object.gameplayStats)
      : undefined;
    message.extraMessages = object.extraMessages?.map((e) => CExtraMsgBlock.fromPartial(e)) || [];
    message.trainingDataRecorded = object.trainingDataRecorded ?? false;
    message.winningTeam = object.winningTeam ?? 0;
    message.normalizedWinProbabilityDiff = object.normalizedWinProbabilityDiff ?? 0;
    message.matchTrackedStats = object.matchTrackedStats?.map((e) => CMsgTrackedStat.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgGameMatchSignOut_CTeam(): CMsgGameMatchSignOut_CTeam {
  return { players: [], teamTrackedStats: [] };
}

export const CMsgGameMatchSignOut_CTeam = {
  encode(message: CMsgGameMatchSignOut_CTeam, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.players) {
      CMsgGameMatchSignOut_CTeam_CPlayer.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.teamTrackedStats) {
      CMsgTrackedStat.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGameMatchSignOut_CTeam {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGameMatchSignOut_CTeam();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.players.push(CMsgGameMatchSignOut_CTeam_CPlayer.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.teamTrackedStats.push(CMsgTrackedStat.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGameMatchSignOut_CTeam {
    return {
      players: globalThis.Array.isArray(object?.players)
        ? object.players.map((e: any) => CMsgGameMatchSignOut_CTeam_CPlayer.fromJSON(e))
        : [],
      teamTrackedStats: globalThis.Array.isArray(object?.teamTrackedStats)
        ? object.teamTrackedStats.map((e: any) => CMsgTrackedStat.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgGameMatchSignOut_CTeam): unknown {
    const obj: any = {};
    if (message.players?.length) {
      obj.players = message.players.map((e) => CMsgGameMatchSignOut_CTeam_CPlayer.toJSON(e));
    }
    if (message.teamTrackedStats?.length) {
      obj.teamTrackedStats = message.teamTrackedStats.map((e) => CMsgTrackedStat.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGameMatchSignOut_CTeam>): CMsgGameMatchSignOut_CTeam {
    return CMsgGameMatchSignOut_CTeam.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGameMatchSignOut_CTeam>): CMsgGameMatchSignOut_CTeam {
    const message = createBaseCMsgGameMatchSignOut_CTeam();
    message.players = object.players?.map((e) => CMsgGameMatchSignOut_CTeam_CPlayer.fromPartial(e)) || [];
    message.teamTrackedStats = object.teamTrackedStats?.map((e) => CMsgTrackedStat.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgGameMatchSignOut_CTeam_CPlayer(): CMsgGameMatchSignOut_CTeam_CPlayer {
  return {
    steamId: "0",
    heroId: 0,
    items: [],
    itemPurchaseTimes: [],
    gold: 0,
    kills: 0,
    deaths: 0,
    assists: 0,
    leaverStatus: 0,
    lastHits: 0,
    denies: 0,
    goldPerMin: 0,
    xpPerMinute: 0,
    goldSpent: 0,
    level: 0,
    scaledHeroDamage: 0,
    scaledTowerDamage: 0,
    scaledHeroHealing: 0,
    timeLastSeen: 0,
    supportAbilityValue: 0,
    partyId: "0",
    claimedFarmGold: 0,
    supportGold: 0,
    claimedDenies: 0,
    claimedMisses: 0,
    misses: 0,
    netWorth: 0,
    heroDamage: 0,
    towerDamage: 0,
    heroHealing: 0,
    abilityUpgrades: [],
    additionalUnitsInventory: [],
    permanentBuffs: [],
    customGameData: undefined,
    matchPlayerFlags: 0,
    talentAbilityIds: [],
    heroPickOrder: 0,
    heroWasRandomed: false,
    heroWasDotaPlusSuggestion: false,
    lane: 0,
    isUsingPlusGuide: false,
    heroDamageReceived: [],
    heroDamageDealt: [],
    secondsDead: 0,
    goldLostToDeath: 0,
    commandCount: 0,
    mouseClickCastCommandCount: 0,
    teleportsUsed: 0,
    cavernCrawlPreferredMapVariant: 255,
    bountyRunes: 0,
    outpostsCaptured: 0,
    dewards: 0,
    wardsPlaced: 0,
    campsStacked: 0,
    playerSlot: 0,
    predictedPosition: 0,
    laneOutcomes: 255,
    friendlyT1DestroyedTime: 0,
    enemyT1DestroyedTime: 0,
    friendlyRoshanKills: 0,
    enemyRoshanKills: 0,
    powerRunes: 0,
    waterRunes: 0,
    stunDuration: 0,
    teamNumber: 0,
    teamSlot: 0,
    timePurchasedShard: 0,
    timePurchasedAghs: 0,
    abilityDraftAbilities: [],
    playerTrackedStats: [],
    predictedRank: 0,
    selectedFacet: 0,
    enhancementLevel: 0,
  };
}

export const CMsgGameMatchSignOut_CTeam_CPlayer = {
  encode(message: CMsgGameMatchSignOut_CTeam_CPlayer, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.steamId !== undefined && message.steamId !== "0") {
      writer.uint32(9).fixed64(message.steamId);
    }
    if (message.heroId !== undefined && message.heroId !== 0) {
      writer.uint32(24).int32(message.heroId);
    }
    writer.uint32(34).fork();
    for (const v of message.items) {
      writer.int32(v);
    }
    writer.ldelim();
    writer.uint32(506).fork();
    for (const v of message.itemPurchaseTimes) {
      writer.uint32(v);
    }
    writer.ldelim();
    if (message.gold !== undefined && message.gold !== 0) {
      writer.uint32(40).uint32(message.gold);
    }
    if (message.kills !== undefined && message.kills !== 0) {
      writer.uint32(48).uint32(message.kills);
    }
    if (message.deaths !== undefined && message.deaths !== 0) {
      writer.uint32(56).uint32(message.deaths);
    }
    if (message.assists !== undefined && message.assists !== 0) {
      writer.uint32(64).uint32(message.assists);
    }
    if (message.leaverStatus !== undefined && message.leaverStatus !== 0) {
      writer.uint32(72).uint32(message.leaverStatus);
    }
    if (message.lastHits !== undefined && message.lastHits !== 0) {
      writer.uint32(80).uint32(message.lastHits);
    }
    if (message.denies !== undefined && message.denies !== 0) {
      writer.uint32(88).uint32(message.denies);
    }
    if (message.goldPerMin !== undefined && message.goldPerMin !== 0) {
      writer.uint32(96).uint32(message.goldPerMin);
    }
    if (message.xpPerMinute !== undefined && message.xpPerMinute !== 0) {
      writer.uint32(104).uint32(message.xpPerMinute);
    }
    if (message.goldSpent !== undefined && message.goldSpent !== 0) {
      writer.uint32(112).uint32(message.goldSpent);
    }
    if (message.level !== undefined && message.level !== 0) {
      writer.uint32(120).uint32(message.level);
    }
    if (message.scaledHeroDamage !== undefined && message.scaledHeroDamage !== 0) {
      writer.uint32(128).uint32(message.scaledHeroDamage);
    }
    if (message.scaledTowerDamage !== undefined && message.scaledTowerDamage !== 0) {
      writer.uint32(136).uint32(message.scaledTowerDamage);
    }
    if (message.scaledHeroHealing !== undefined && message.scaledHeroHealing !== 0) {
      writer.uint32(144).uint32(message.scaledHeroHealing);
    }
    if (message.timeLastSeen !== undefined && message.timeLastSeen !== 0) {
      writer.uint32(152).uint32(message.timeLastSeen);
    }
    if (message.supportAbilityValue !== undefined && message.supportAbilityValue !== 0) {
      writer.uint32(160).uint32(message.supportAbilityValue);
    }
    if (message.partyId !== undefined && message.partyId !== "0") {
      writer.uint32(168).uint64(message.partyId);
    }
    if (message.claimedFarmGold !== undefined && message.claimedFarmGold !== 0) {
      writer.uint32(216).uint32(message.claimedFarmGold);
    }
    if (message.supportGold !== undefined && message.supportGold !== 0) {
      writer.uint32(224).uint32(message.supportGold);
    }
    if (message.claimedDenies !== undefined && message.claimedDenies !== 0) {
      writer.uint32(232).uint32(message.claimedDenies);
    }
    if (message.claimedMisses !== undefined && message.claimedMisses !== 0) {
      writer.uint32(240).uint32(message.claimedMisses);
    }
    if (message.misses !== undefined && message.misses !== 0) {
      writer.uint32(248).uint32(message.misses);
    }
    if (message.netWorth !== undefined && message.netWorth !== 0) {
      writer.uint32(272).uint32(message.netWorth);
    }
    if (message.heroDamage !== undefined && message.heroDamage !== 0) {
      writer.uint32(296).uint32(message.heroDamage);
    }
    if (message.towerDamage !== undefined && message.towerDamage !== 0) {
      writer.uint32(304).uint32(message.towerDamage);
    }
    if (message.heroHealing !== undefined && message.heroHealing !== 0) {
      writer.uint32(312).uint32(message.heroHealing);
    }
    for (const v of message.abilityUpgrades) {
      CMatchPlayerAbilityUpgrade.encode(v!, writer.uint32(258).fork()).ldelim();
    }
    for (const v of message.additionalUnitsInventory) {
      CMatchAdditionalUnitInventory.encode(v!, writer.uint32(266).fork()).ldelim();
    }
    for (const v of message.permanentBuffs) {
      CMatchPlayerPermanentBuff.encode(v!, writer.uint32(322).fork()).ldelim();
    }
    if (message.customGameData !== undefined) {
      CMsgGameMatchSignOut_CTeam_CPlayer_CCustomGameData.encode(message.customGameData, writer.uint32(282).fork())
        .ldelim();
    }
    if (message.matchPlayerFlags !== undefined && message.matchPlayerFlags !== 0) {
      writer.uint32(288).uint32(message.matchPlayerFlags);
    }
    writer.uint32(330).fork();
    for (const v of message.talentAbilityIds) {
      writer.int32(v);
    }
    writer.ldelim();
    if (message.heroPickOrder !== undefined && message.heroPickOrder !== 0) {
      writer.uint32(336).uint32(message.heroPickOrder);
    }
    if (message.heroWasRandomed !== undefined && message.heroWasRandomed !== false) {
      writer.uint32(344).bool(message.heroWasRandomed);
    }
    if (message.heroWasDotaPlusSuggestion !== undefined && message.heroWasDotaPlusSuggestion !== false) {
      writer.uint32(400).bool(message.heroWasDotaPlusSuggestion);
    }
    if (message.lane !== undefined && message.lane !== 0) {
      writer.uint32(360).uint32(message.lane);
    }
    if (message.isUsingPlusGuide !== undefined && message.isUsingPlusGuide !== false) {
      writer.uint32(376).bool(message.isUsingPlusGuide);
    }
    for (const v of message.heroDamageReceived) {
      CMsgGameMatchSignOut_CTeam_CPlayer_HeroDamageReceived.encode(v!, writer.uint32(386).fork()).ldelim();
    }
    for (const v of message.heroDamageDealt) {
      CMsgGameMatchSignOut_CTeam_CPlayer_HeroDamageReceived.encode(v!, writer.uint32(514).fork()).ldelim();
    }
    if (message.secondsDead !== undefined && message.secondsDead !== 0) {
      writer.uint32(408).uint32(message.secondsDead);
    }
    if (message.goldLostToDeath !== undefined && message.goldLostToDeath !== 0) {
      writer.uint32(416).uint32(message.goldLostToDeath);
    }
    if (message.commandCount !== undefined && message.commandCount !== 0) {
      writer.uint32(424).uint32(message.commandCount);
    }
    if (message.mouseClickCastCommandCount !== undefined && message.mouseClickCastCommandCount !== 0) {
      writer.uint32(432).uint32(message.mouseClickCastCommandCount);
    }
    if (message.teleportsUsed !== undefined && message.teleportsUsed !== 0) {
      writer.uint32(440).uint32(message.teleportsUsed);
    }
    if (message.cavernCrawlPreferredMapVariant !== undefined && message.cavernCrawlPreferredMapVariant !== 255) {
      writer.uint32(448).uint32(message.cavernCrawlPreferredMapVariant);
    }
    if (message.bountyRunes !== undefined && message.bountyRunes !== 0) {
      writer.uint32(456).uint32(message.bountyRunes);
    }
    if (message.outpostsCaptured !== undefined && message.outpostsCaptured !== 0) {
      writer.uint32(464).uint32(message.outpostsCaptured);
    }
    if (message.dewards !== undefined && message.dewards !== 0) {
      writer.uint32(472).uint32(message.dewards);
    }
    if (message.wardsPlaced !== undefined && message.wardsPlaced !== 0) {
      writer.uint32(480).uint32(message.wardsPlaced);
    }
    if (message.campsStacked !== undefined && message.campsStacked !== 0) {
      writer.uint32(488).uint32(message.campsStacked);
    }
    if (message.playerSlot !== undefined && message.playerSlot !== 0) {
      writer.uint32(496).uint32(message.playerSlot);
    }
    if (message.predictedPosition !== undefined && message.predictedPosition !== 0) {
      writer.uint32(528).uint32(message.predictedPosition);
    }
    if (message.laneOutcomes !== undefined && message.laneOutcomes !== 255) {
      writer.uint32(536).uint32(message.laneOutcomes);
    }
    if (message.friendlyT1DestroyedTime !== undefined && message.friendlyT1DestroyedTime !== 0) {
      writer.uint32(544).uint32(message.friendlyT1DestroyedTime);
    }
    if (message.enemyT1DestroyedTime !== undefined && message.enemyT1DestroyedTime !== 0) {
      writer.uint32(552).uint32(message.enemyT1DestroyedTime);
    }
    if (message.friendlyRoshanKills !== undefined && message.friendlyRoshanKills !== 0) {
      writer.uint32(560).uint32(message.friendlyRoshanKills);
    }
    if (message.enemyRoshanKills !== undefined && message.enemyRoshanKills !== 0) {
      writer.uint32(568).uint32(message.enemyRoshanKills);
    }
    if (message.powerRunes !== undefined && message.powerRunes !== 0) {
      writer.uint32(576).uint32(message.powerRunes);
    }
    if (message.waterRunes !== undefined && message.waterRunes !== 0) {
      writer.uint32(584).uint32(message.waterRunes);
    }
    if (message.stunDuration !== undefined && message.stunDuration !== 0) {
      writer.uint32(597).float(message.stunDuration);
    }
    if (message.teamNumber !== undefined && message.teamNumber !== 0) {
      writer.uint32(600).int32(message.teamNumber);
    }
    if (message.teamSlot !== undefined && message.teamSlot !== 0) {
      writer.uint32(608).uint32(message.teamSlot);
    }
    if (message.timePurchasedShard !== undefined && message.timePurchasedShard !== 0) {
      writer.uint32(616).uint32(message.timePurchasedShard);
    }
    if (message.timePurchasedAghs !== undefined && message.timePurchasedAghs !== 0) {
      writer.uint32(624).uint32(message.timePurchasedAghs);
    }
    writer.uint32(634).fork();
    for (const v of message.abilityDraftAbilities) {
      writer.int32(v);
    }
    writer.ldelim();
    for (const v of message.playerTrackedStats) {
      CMsgTrackedStat.encode(v!, writer.uint32(642).fork()).ldelim();
    }
    if (message.predictedRank !== undefined && message.predictedRank !== 0) {
      writer.uint32(648).uint32(message.predictedRank);
    }
    if (message.selectedFacet !== undefined && message.selectedFacet !== 0) {
      writer.uint32(656).uint32(message.selectedFacet);
    }
    if (message.enhancementLevel !== undefined && message.enhancementLevel !== 0) {
      writer.uint32(664).uint32(message.enhancementLevel);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGameMatchSignOut_CTeam_CPlayer {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGameMatchSignOut_CTeam_CPlayer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.steamId = longToString(reader.fixed64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.heroId = reader.int32();
          continue;
        case 4:
          if (tag === 32) {
            message.items.push(reader.int32());

            continue;
          }

          if (tag === 34) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.items.push(reader.int32());
            }

            continue;
          }

          break;
        case 63:
          if (tag === 504) {
            message.itemPurchaseTimes.push(reader.uint32());

            continue;
          }

          if (tag === 506) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.itemPurchaseTimes.push(reader.uint32());
            }

            continue;
          }

          break;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.gold = reader.uint32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.kills = reader.uint32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.deaths = reader.uint32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.assists = reader.uint32();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.leaverStatus = reader.uint32();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.lastHits = reader.uint32();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.denies = reader.uint32();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.goldPerMin = reader.uint32();
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.xpPerMinute = reader.uint32();
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.goldSpent = reader.uint32();
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.level = reader.uint32();
          continue;
        case 16:
          if (tag !== 128) {
            break;
          }

          message.scaledHeroDamage = reader.uint32();
          continue;
        case 17:
          if (tag !== 136) {
            break;
          }

          message.scaledTowerDamage = reader.uint32();
          continue;
        case 18:
          if (tag !== 144) {
            break;
          }

          message.scaledHeroHealing = reader.uint32();
          continue;
        case 19:
          if (tag !== 152) {
            break;
          }

          message.timeLastSeen = reader.uint32();
          continue;
        case 20:
          if (tag !== 160) {
            break;
          }

          message.supportAbilityValue = reader.uint32();
          continue;
        case 21:
          if (tag !== 168) {
            break;
          }

          message.partyId = longToString(reader.uint64() as Long);
          continue;
        case 27:
          if (tag !== 216) {
            break;
          }

          message.claimedFarmGold = reader.uint32();
          continue;
        case 28:
          if (tag !== 224) {
            break;
          }

          message.supportGold = reader.uint32();
          continue;
        case 29:
          if (tag !== 232) {
            break;
          }

          message.claimedDenies = reader.uint32();
          continue;
        case 30:
          if (tag !== 240) {
            break;
          }

          message.claimedMisses = reader.uint32();
          continue;
        case 31:
          if (tag !== 248) {
            break;
          }

          message.misses = reader.uint32();
          continue;
        case 34:
          if (tag !== 272) {
            break;
          }

          message.netWorth = reader.uint32();
          continue;
        case 37:
          if (tag !== 296) {
            break;
          }

          message.heroDamage = reader.uint32();
          continue;
        case 38:
          if (tag !== 304) {
            break;
          }

          message.towerDamage = reader.uint32();
          continue;
        case 39:
          if (tag !== 312) {
            break;
          }

          message.heroHealing = reader.uint32();
          continue;
        case 32:
          if (tag !== 258) {
            break;
          }

          message.abilityUpgrades.push(CMatchPlayerAbilityUpgrade.decode(reader, reader.uint32()));
          continue;
        case 33:
          if (tag !== 266) {
            break;
          }

          message.additionalUnitsInventory.push(CMatchAdditionalUnitInventory.decode(reader, reader.uint32()));
          continue;
        case 40:
          if (tag !== 322) {
            break;
          }

          message.permanentBuffs.push(CMatchPlayerPermanentBuff.decode(reader, reader.uint32()));
          continue;
        case 35:
          if (tag !== 282) {
            break;
          }

          message.customGameData = CMsgGameMatchSignOut_CTeam_CPlayer_CCustomGameData.decode(reader, reader.uint32());
          continue;
        case 36:
          if (tag !== 288) {
            break;
          }

          message.matchPlayerFlags = reader.uint32();
          continue;
        case 41:
          if (tag === 328) {
            message.talentAbilityIds.push(reader.int32());

            continue;
          }

          if (tag === 330) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.talentAbilityIds.push(reader.int32());
            }

            continue;
          }

          break;
        case 42:
          if (tag !== 336) {
            break;
          }

          message.heroPickOrder = reader.uint32();
          continue;
        case 43:
          if (tag !== 344) {
            break;
          }

          message.heroWasRandomed = reader.bool();
          continue;
        case 50:
          if (tag !== 400) {
            break;
          }

          message.heroWasDotaPlusSuggestion = reader.bool();
          continue;
        case 45:
          if (tag !== 360) {
            break;
          }

          message.lane = reader.uint32();
          continue;
        case 47:
          if (tag !== 376) {
            break;
          }

          message.isUsingPlusGuide = reader.bool();
          continue;
        case 48:
          if (tag !== 386) {
            break;
          }

          message.heroDamageReceived.push(
            CMsgGameMatchSignOut_CTeam_CPlayer_HeroDamageReceived.decode(reader, reader.uint32()),
          );
          continue;
        case 64:
          if (tag !== 514) {
            break;
          }

          message.heroDamageDealt.push(
            CMsgGameMatchSignOut_CTeam_CPlayer_HeroDamageReceived.decode(reader, reader.uint32()),
          );
          continue;
        case 51:
          if (tag !== 408) {
            break;
          }

          message.secondsDead = reader.uint32();
          continue;
        case 52:
          if (tag !== 416) {
            break;
          }

          message.goldLostToDeath = reader.uint32();
          continue;
        case 53:
          if (tag !== 424) {
            break;
          }

          message.commandCount = reader.uint32();
          continue;
        case 54:
          if (tag !== 432) {
            break;
          }

          message.mouseClickCastCommandCount = reader.uint32();
          continue;
        case 55:
          if (tag !== 440) {
            break;
          }

          message.teleportsUsed = reader.uint32();
          continue;
        case 56:
          if (tag !== 448) {
            break;
          }

          message.cavernCrawlPreferredMapVariant = reader.uint32();
          continue;
        case 57:
          if (tag !== 456) {
            break;
          }

          message.bountyRunes = reader.uint32();
          continue;
        case 58:
          if (tag !== 464) {
            break;
          }

          message.outpostsCaptured = reader.uint32();
          continue;
        case 59:
          if (tag !== 472) {
            break;
          }

          message.dewards = reader.uint32();
          continue;
        case 60:
          if (tag !== 480) {
            break;
          }

          message.wardsPlaced = reader.uint32();
          continue;
        case 61:
          if (tag !== 488) {
            break;
          }

          message.campsStacked = reader.uint32();
          continue;
        case 62:
          if (tag !== 496) {
            break;
          }

          message.playerSlot = reader.uint32();
          continue;
        case 66:
          if (tag !== 528) {
            break;
          }

          message.predictedPosition = reader.uint32();
          continue;
        case 67:
          if (tag !== 536) {
            break;
          }

          message.laneOutcomes = reader.uint32();
          continue;
        case 68:
          if (tag !== 544) {
            break;
          }

          message.friendlyT1DestroyedTime = reader.uint32();
          continue;
        case 69:
          if (tag !== 552) {
            break;
          }

          message.enemyT1DestroyedTime = reader.uint32();
          continue;
        case 70:
          if (tag !== 560) {
            break;
          }

          message.friendlyRoshanKills = reader.uint32();
          continue;
        case 71:
          if (tag !== 568) {
            break;
          }

          message.enemyRoshanKills = reader.uint32();
          continue;
        case 72:
          if (tag !== 576) {
            break;
          }

          message.powerRunes = reader.uint32();
          continue;
        case 73:
          if (tag !== 584) {
            break;
          }

          message.waterRunes = reader.uint32();
          continue;
        case 74:
          if (tag !== 597) {
            break;
          }

          message.stunDuration = reader.float();
          continue;
        case 75:
          if (tag !== 600) {
            break;
          }

          message.teamNumber = reader.int32() as any;
          continue;
        case 76:
          if (tag !== 608) {
            break;
          }

          message.teamSlot = reader.uint32();
          continue;
        case 77:
          if (tag !== 616) {
            break;
          }

          message.timePurchasedShard = reader.uint32();
          continue;
        case 78:
          if (tag !== 624) {
            break;
          }

          message.timePurchasedAghs = reader.uint32();
          continue;
        case 79:
          if (tag === 632) {
            message.abilityDraftAbilities.push(reader.int32());

            continue;
          }

          if (tag === 634) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.abilityDraftAbilities.push(reader.int32());
            }

            continue;
          }

          break;
        case 80:
          if (tag !== 642) {
            break;
          }

          message.playerTrackedStats.push(CMsgTrackedStat.decode(reader, reader.uint32()));
          continue;
        case 81:
          if (tag !== 648) {
            break;
          }

          message.predictedRank = reader.uint32();
          continue;
        case 82:
          if (tag !== 656) {
            break;
          }

          message.selectedFacet = reader.uint32();
          continue;
        case 83:
          if (tag !== 664) {
            break;
          }

          message.enhancementLevel = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGameMatchSignOut_CTeam_CPlayer {
    return {
      steamId: isSet(object.steamId) ? globalThis.String(object.steamId) : "0",
      heroId: isSet(object.heroId) ? globalThis.Number(object.heroId) : 0,
      items: globalThis.Array.isArray(object?.items) ? object.items.map((e: any) => globalThis.Number(e)) : [],
      itemPurchaseTimes: globalThis.Array.isArray(object?.itemPurchaseTimes)
        ? object.itemPurchaseTimes.map((e: any) => globalThis.Number(e))
        : [],
      gold: isSet(object.gold) ? globalThis.Number(object.gold) : 0,
      kills: isSet(object.kills) ? globalThis.Number(object.kills) : 0,
      deaths: isSet(object.deaths) ? globalThis.Number(object.deaths) : 0,
      assists: isSet(object.assists) ? globalThis.Number(object.assists) : 0,
      leaverStatus: isSet(object.leaverStatus) ? globalThis.Number(object.leaverStatus) : 0,
      lastHits: isSet(object.lastHits) ? globalThis.Number(object.lastHits) : 0,
      denies: isSet(object.denies) ? globalThis.Number(object.denies) : 0,
      goldPerMin: isSet(object.goldPerMin) ? globalThis.Number(object.goldPerMin) : 0,
      xpPerMinute: isSet(object.xpPerMinute) ? globalThis.Number(object.xpPerMinute) : 0,
      goldSpent: isSet(object.goldSpent) ? globalThis.Number(object.goldSpent) : 0,
      level: isSet(object.level) ? globalThis.Number(object.level) : 0,
      scaledHeroDamage: isSet(object.scaledHeroDamage) ? globalThis.Number(object.scaledHeroDamage) : 0,
      scaledTowerDamage: isSet(object.scaledTowerDamage) ? globalThis.Number(object.scaledTowerDamage) : 0,
      scaledHeroHealing: isSet(object.scaledHeroHealing) ? globalThis.Number(object.scaledHeroHealing) : 0,
      timeLastSeen: isSet(object.timeLastSeen) ? globalThis.Number(object.timeLastSeen) : 0,
      supportAbilityValue: isSet(object.supportAbilityValue) ? globalThis.Number(object.supportAbilityValue) : 0,
      partyId: isSet(object.partyId) ? globalThis.String(object.partyId) : "0",
      claimedFarmGold: isSet(object.claimedFarmGold) ? globalThis.Number(object.claimedFarmGold) : 0,
      supportGold: isSet(object.supportGold) ? globalThis.Number(object.supportGold) : 0,
      claimedDenies: isSet(object.claimedDenies) ? globalThis.Number(object.claimedDenies) : 0,
      claimedMisses: isSet(object.claimedMisses) ? globalThis.Number(object.claimedMisses) : 0,
      misses: isSet(object.misses) ? globalThis.Number(object.misses) : 0,
      netWorth: isSet(object.netWorth) ? globalThis.Number(object.netWorth) : 0,
      heroDamage: isSet(object.heroDamage) ? globalThis.Number(object.heroDamage) : 0,
      towerDamage: isSet(object.towerDamage) ? globalThis.Number(object.towerDamage) : 0,
      heroHealing: isSet(object.heroHealing) ? globalThis.Number(object.heroHealing) : 0,
      abilityUpgrades: globalThis.Array.isArray(object?.abilityUpgrades)
        ? object.abilityUpgrades.map((e: any) => CMatchPlayerAbilityUpgrade.fromJSON(e))
        : [],
      additionalUnitsInventory: globalThis.Array.isArray(object?.additionalUnitsInventory)
        ? object.additionalUnitsInventory.map((e: any) => CMatchAdditionalUnitInventory.fromJSON(e))
        : [],
      permanentBuffs: globalThis.Array.isArray(object?.permanentBuffs)
        ? object.permanentBuffs.map((e: any) => CMatchPlayerPermanentBuff.fromJSON(e))
        : [],
      customGameData: isSet(object.customGameData)
        ? CMsgGameMatchSignOut_CTeam_CPlayer_CCustomGameData.fromJSON(object.customGameData)
        : undefined,
      matchPlayerFlags: isSet(object.matchPlayerFlags) ? globalThis.Number(object.matchPlayerFlags) : 0,
      talentAbilityIds: globalThis.Array.isArray(object?.talentAbilityIds)
        ? object.talentAbilityIds.map((e: any) => globalThis.Number(e))
        : [],
      heroPickOrder: isSet(object.heroPickOrder) ? globalThis.Number(object.heroPickOrder) : 0,
      heroWasRandomed: isSet(object.heroWasRandomed) ? globalThis.Boolean(object.heroWasRandomed) : false,
      heroWasDotaPlusSuggestion: isSet(object.heroWasDotaPlusSuggestion)
        ? globalThis.Boolean(object.heroWasDotaPlusSuggestion)
        : false,
      lane: isSet(object.lane) ? globalThis.Number(object.lane) : 0,
      isUsingPlusGuide: isSet(object.isUsingPlusGuide) ? globalThis.Boolean(object.isUsingPlusGuide) : false,
      heroDamageReceived: globalThis.Array.isArray(object?.heroDamageReceived)
        ? object.heroDamageReceived.map((e: any) => CMsgGameMatchSignOut_CTeam_CPlayer_HeroDamageReceived.fromJSON(e))
        : [],
      heroDamageDealt: globalThis.Array.isArray(object?.heroDamageDealt)
        ? object.heroDamageDealt.map((e: any) => CMsgGameMatchSignOut_CTeam_CPlayer_HeroDamageReceived.fromJSON(e))
        : [],
      secondsDead: isSet(object.secondsDead) ? globalThis.Number(object.secondsDead) : 0,
      goldLostToDeath: isSet(object.goldLostToDeath) ? globalThis.Number(object.goldLostToDeath) : 0,
      commandCount: isSet(object.commandCount) ? globalThis.Number(object.commandCount) : 0,
      mouseClickCastCommandCount: isSet(object.mouseClickCastCommandCount)
        ? globalThis.Number(object.mouseClickCastCommandCount)
        : 0,
      teleportsUsed: isSet(object.teleportsUsed) ? globalThis.Number(object.teleportsUsed) : 0,
      cavernCrawlPreferredMapVariant: isSet(object.cavernCrawlPreferredMapVariant)
        ? globalThis.Number(object.cavernCrawlPreferredMapVariant)
        : 255,
      bountyRunes: isSet(object.bountyRunes) ? globalThis.Number(object.bountyRunes) : 0,
      outpostsCaptured: isSet(object.outpostsCaptured) ? globalThis.Number(object.outpostsCaptured) : 0,
      dewards: isSet(object.dewards) ? globalThis.Number(object.dewards) : 0,
      wardsPlaced: isSet(object.wardsPlaced) ? globalThis.Number(object.wardsPlaced) : 0,
      campsStacked: isSet(object.campsStacked) ? globalThis.Number(object.campsStacked) : 0,
      playerSlot: isSet(object.playerSlot) ? globalThis.Number(object.playerSlot) : 0,
      predictedPosition: isSet(object.predictedPosition) ? globalThis.Number(object.predictedPosition) : 0,
      laneOutcomes: isSet(object.laneOutcomes) ? globalThis.Number(object.laneOutcomes) : 255,
      friendlyT1DestroyedTime: isSet(object.friendlyT1DestroyedTime)
        ? globalThis.Number(object.friendlyT1DestroyedTime)
        : 0,
      enemyT1DestroyedTime: isSet(object.enemyT1DestroyedTime) ? globalThis.Number(object.enemyT1DestroyedTime) : 0,
      friendlyRoshanKills: isSet(object.friendlyRoshanKills) ? globalThis.Number(object.friendlyRoshanKills) : 0,
      enemyRoshanKills: isSet(object.enemyRoshanKills) ? globalThis.Number(object.enemyRoshanKills) : 0,
      powerRunes: isSet(object.powerRunes) ? globalThis.Number(object.powerRunes) : 0,
      waterRunes: isSet(object.waterRunes) ? globalThis.Number(object.waterRunes) : 0,
      stunDuration: isSet(object.stunDuration) ? globalThis.Number(object.stunDuration) : 0,
      teamNumber: isSet(object.teamNumber) ? dotaGcTeamFromJSON(object.teamNumber) : 0,
      teamSlot: isSet(object.teamSlot) ? globalThis.Number(object.teamSlot) : 0,
      timePurchasedShard: isSet(object.timePurchasedShard) ? globalThis.Number(object.timePurchasedShard) : 0,
      timePurchasedAghs: isSet(object.timePurchasedAghs) ? globalThis.Number(object.timePurchasedAghs) : 0,
      abilityDraftAbilities: globalThis.Array.isArray(object?.abilityDraftAbilities)
        ? object.abilityDraftAbilities.map((e: any) => globalThis.Number(e))
        : [],
      playerTrackedStats: globalThis.Array.isArray(object?.playerTrackedStats)
        ? object.playerTrackedStats.map((e: any) => CMsgTrackedStat.fromJSON(e))
        : [],
      predictedRank: isSet(object.predictedRank) ? globalThis.Number(object.predictedRank) : 0,
      selectedFacet: isSet(object.selectedFacet) ? globalThis.Number(object.selectedFacet) : 0,
      enhancementLevel: isSet(object.enhancementLevel) ? globalThis.Number(object.enhancementLevel) : 0,
    };
  },

  toJSON(message: CMsgGameMatchSignOut_CTeam_CPlayer): unknown {
    const obj: any = {};
    if (message.steamId !== undefined && message.steamId !== "0") {
      obj.steamId = message.steamId;
    }
    if (message.heroId !== undefined && message.heroId !== 0) {
      obj.heroId = Math.round(message.heroId);
    }
    if (message.items?.length) {
      obj.items = message.items.map((e) => Math.round(e));
    }
    if (message.itemPurchaseTimes?.length) {
      obj.itemPurchaseTimes = message.itemPurchaseTimes.map((e) => Math.round(e));
    }
    if (message.gold !== undefined && message.gold !== 0) {
      obj.gold = Math.round(message.gold);
    }
    if (message.kills !== undefined && message.kills !== 0) {
      obj.kills = Math.round(message.kills);
    }
    if (message.deaths !== undefined && message.deaths !== 0) {
      obj.deaths = Math.round(message.deaths);
    }
    if (message.assists !== undefined && message.assists !== 0) {
      obj.assists = Math.round(message.assists);
    }
    if (message.leaverStatus !== undefined && message.leaverStatus !== 0) {
      obj.leaverStatus = Math.round(message.leaverStatus);
    }
    if (message.lastHits !== undefined && message.lastHits !== 0) {
      obj.lastHits = Math.round(message.lastHits);
    }
    if (message.denies !== undefined && message.denies !== 0) {
      obj.denies = Math.round(message.denies);
    }
    if (message.goldPerMin !== undefined && message.goldPerMin !== 0) {
      obj.goldPerMin = Math.round(message.goldPerMin);
    }
    if (message.xpPerMinute !== undefined && message.xpPerMinute !== 0) {
      obj.xpPerMinute = Math.round(message.xpPerMinute);
    }
    if (message.goldSpent !== undefined && message.goldSpent !== 0) {
      obj.goldSpent = Math.round(message.goldSpent);
    }
    if (message.level !== undefined && message.level !== 0) {
      obj.level = Math.round(message.level);
    }
    if (message.scaledHeroDamage !== undefined && message.scaledHeroDamage !== 0) {
      obj.scaledHeroDamage = Math.round(message.scaledHeroDamage);
    }
    if (message.scaledTowerDamage !== undefined && message.scaledTowerDamage !== 0) {
      obj.scaledTowerDamage = Math.round(message.scaledTowerDamage);
    }
    if (message.scaledHeroHealing !== undefined && message.scaledHeroHealing !== 0) {
      obj.scaledHeroHealing = Math.round(message.scaledHeroHealing);
    }
    if (message.timeLastSeen !== undefined && message.timeLastSeen !== 0) {
      obj.timeLastSeen = Math.round(message.timeLastSeen);
    }
    if (message.supportAbilityValue !== undefined && message.supportAbilityValue !== 0) {
      obj.supportAbilityValue = Math.round(message.supportAbilityValue);
    }
    if (message.partyId !== undefined && message.partyId !== "0") {
      obj.partyId = message.partyId;
    }
    if (message.claimedFarmGold !== undefined && message.claimedFarmGold !== 0) {
      obj.claimedFarmGold = Math.round(message.claimedFarmGold);
    }
    if (message.supportGold !== undefined && message.supportGold !== 0) {
      obj.supportGold = Math.round(message.supportGold);
    }
    if (message.claimedDenies !== undefined && message.claimedDenies !== 0) {
      obj.claimedDenies = Math.round(message.claimedDenies);
    }
    if (message.claimedMisses !== undefined && message.claimedMisses !== 0) {
      obj.claimedMisses = Math.round(message.claimedMisses);
    }
    if (message.misses !== undefined && message.misses !== 0) {
      obj.misses = Math.round(message.misses);
    }
    if (message.netWorth !== undefined && message.netWorth !== 0) {
      obj.netWorth = Math.round(message.netWorth);
    }
    if (message.heroDamage !== undefined && message.heroDamage !== 0) {
      obj.heroDamage = Math.round(message.heroDamage);
    }
    if (message.towerDamage !== undefined && message.towerDamage !== 0) {
      obj.towerDamage = Math.round(message.towerDamage);
    }
    if (message.heroHealing !== undefined && message.heroHealing !== 0) {
      obj.heroHealing = Math.round(message.heroHealing);
    }
    if (message.abilityUpgrades?.length) {
      obj.abilityUpgrades = message.abilityUpgrades.map((e) => CMatchPlayerAbilityUpgrade.toJSON(e));
    }
    if (message.additionalUnitsInventory?.length) {
      obj.additionalUnitsInventory = message.additionalUnitsInventory.map((e) =>
        CMatchAdditionalUnitInventory.toJSON(e)
      );
    }
    if (message.permanentBuffs?.length) {
      obj.permanentBuffs = message.permanentBuffs.map((e) => CMatchPlayerPermanentBuff.toJSON(e));
    }
    if (message.customGameData !== undefined) {
      obj.customGameData = CMsgGameMatchSignOut_CTeam_CPlayer_CCustomGameData.toJSON(message.customGameData);
    }
    if (message.matchPlayerFlags !== undefined && message.matchPlayerFlags !== 0) {
      obj.matchPlayerFlags = Math.round(message.matchPlayerFlags);
    }
    if (message.talentAbilityIds?.length) {
      obj.talentAbilityIds = message.talentAbilityIds.map((e) => Math.round(e));
    }
    if (message.heroPickOrder !== undefined && message.heroPickOrder !== 0) {
      obj.heroPickOrder = Math.round(message.heroPickOrder);
    }
    if (message.heroWasRandomed !== undefined && message.heroWasRandomed !== false) {
      obj.heroWasRandomed = message.heroWasRandomed;
    }
    if (message.heroWasDotaPlusSuggestion !== undefined && message.heroWasDotaPlusSuggestion !== false) {
      obj.heroWasDotaPlusSuggestion = message.heroWasDotaPlusSuggestion;
    }
    if (message.lane !== undefined && message.lane !== 0) {
      obj.lane = Math.round(message.lane);
    }
    if (message.isUsingPlusGuide !== undefined && message.isUsingPlusGuide !== false) {
      obj.isUsingPlusGuide = message.isUsingPlusGuide;
    }
    if (message.heroDamageReceived?.length) {
      obj.heroDamageReceived = message.heroDamageReceived.map((e) =>
        CMsgGameMatchSignOut_CTeam_CPlayer_HeroDamageReceived.toJSON(e)
      );
    }
    if (message.heroDamageDealt?.length) {
      obj.heroDamageDealt = message.heroDamageDealt.map((e) =>
        CMsgGameMatchSignOut_CTeam_CPlayer_HeroDamageReceived.toJSON(e)
      );
    }
    if (message.secondsDead !== undefined && message.secondsDead !== 0) {
      obj.secondsDead = Math.round(message.secondsDead);
    }
    if (message.goldLostToDeath !== undefined && message.goldLostToDeath !== 0) {
      obj.goldLostToDeath = Math.round(message.goldLostToDeath);
    }
    if (message.commandCount !== undefined && message.commandCount !== 0) {
      obj.commandCount = Math.round(message.commandCount);
    }
    if (message.mouseClickCastCommandCount !== undefined && message.mouseClickCastCommandCount !== 0) {
      obj.mouseClickCastCommandCount = Math.round(message.mouseClickCastCommandCount);
    }
    if (message.teleportsUsed !== undefined && message.teleportsUsed !== 0) {
      obj.teleportsUsed = Math.round(message.teleportsUsed);
    }
    if (message.cavernCrawlPreferredMapVariant !== undefined && message.cavernCrawlPreferredMapVariant !== 255) {
      obj.cavernCrawlPreferredMapVariant = Math.round(message.cavernCrawlPreferredMapVariant);
    }
    if (message.bountyRunes !== undefined && message.bountyRunes !== 0) {
      obj.bountyRunes = Math.round(message.bountyRunes);
    }
    if (message.outpostsCaptured !== undefined && message.outpostsCaptured !== 0) {
      obj.outpostsCaptured = Math.round(message.outpostsCaptured);
    }
    if (message.dewards !== undefined && message.dewards !== 0) {
      obj.dewards = Math.round(message.dewards);
    }
    if (message.wardsPlaced !== undefined && message.wardsPlaced !== 0) {
      obj.wardsPlaced = Math.round(message.wardsPlaced);
    }
    if (message.campsStacked !== undefined && message.campsStacked !== 0) {
      obj.campsStacked = Math.round(message.campsStacked);
    }
    if (message.playerSlot !== undefined && message.playerSlot !== 0) {
      obj.playerSlot = Math.round(message.playerSlot);
    }
    if (message.predictedPosition !== undefined && message.predictedPosition !== 0) {
      obj.predictedPosition = Math.round(message.predictedPosition);
    }
    if (message.laneOutcomes !== undefined && message.laneOutcomes !== 255) {
      obj.laneOutcomes = Math.round(message.laneOutcomes);
    }
    if (message.friendlyT1DestroyedTime !== undefined && message.friendlyT1DestroyedTime !== 0) {
      obj.friendlyT1DestroyedTime = Math.round(message.friendlyT1DestroyedTime);
    }
    if (message.enemyT1DestroyedTime !== undefined && message.enemyT1DestroyedTime !== 0) {
      obj.enemyT1DestroyedTime = Math.round(message.enemyT1DestroyedTime);
    }
    if (message.friendlyRoshanKills !== undefined && message.friendlyRoshanKills !== 0) {
      obj.friendlyRoshanKills = Math.round(message.friendlyRoshanKills);
    }
    if (message.enemyRoshanKills !== undefined && message.enemyRoshanKills !== 0) {
      obj.enemyRoshanKills = Math.round(message.enemyRoshanKills);
    }
    if (message.powerRunes !== undefined && message.powerRunes !== 0) {
      obj.powerRunes = Math.round(message.powerRunes);
    }
    if (message.waterRunes !== undefined && message.waterRunes !== 0) {
      obj.waterRunes = Math.round(message.waterRunes);
    }
    if (message.stunDuration !== undefined && message.stunDuration !== 0) {
      obj.stunDuration = message.stunDuration;
    }
    if (message.teamNumber !== undefined && message.teamNumber !== 0) {
      obj.teamNumber = dotaGcTeamToJSON(message.teamNumber);
    }
    if (message.teamSlot !== undefined && message.teamSlot !== 0) {
      obj.teamSlot = Math.round(message.teamSlot);
    }
    if (message.timePurchasedShard !== undefined && message.timePurchasedShard !== 0) {
      obj.timePurchasedShard = Math.round(message.timePurchasedShard);
    }
    if (message.timePurchasedAghs !== undefined && message.timePurchasedAghs !== 0) {
      obj.timePurchasedAghs = Math.round(message.timePurchasedAghs);
    }
    if (message.abilityDraftAbilities?.length) {
      obj.abilityDraftAbilities = message.abilityDraftAbilities.map((e) => Math.round(e));
    }
    if (message.playerTrackedStats?.length) {
      obj.playerTrackedStats = message.playerTrackedStats.map((e) => CMsgTrackedStat.toJSON(e));
    }
    if (message.predictedRank !== undefined && message.predictedRank !== 0) {
      obj.predictedRank = Math.round(message.predictedRank);
    }
    if (message.selectedFacet !== undefined && message.selectedFacet !== 0) {
      obj.selectedFacet = Math.round(message.selectedFacet);
    }
    if (message.enhancementLevel !== undefined && message.enhancementLevel !== 0) {
      obj.enhancementLevel = Math.round(message.enhancementLevel);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGameMatchSignOut_CTeam_CPlayer>): CMsgGameMatchSignOut_CTeam_CPlayer {
    return CMsgGameMatchSignOut_CTeam_CPlayer.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGameMatchSignOut_CTeam_CPlayer>): CMsgGameMatchSignOut_CTeam_CPlayer {
    const message = createBaseCMsgGameMatchSignOut_CTeam_CPlayer();
    message.steamId = object.steamId ?? "0";
    message.heroId = object.heroId ?? 0;
    message.items = object.items?.map((e) => e) || [];
    message.itemPurchaseTimes = object.itemPurchaseTimes?.map((e) => e) || [];
    message.gold = object.gold ?? 0;
    message.kills = object.kills ?? 0;
    message.deaths = object.deaths ?? 0;
    message.assists = object.assists ?? 0;
    message.leaverStatus = object.leaverStatus ?? 0;
    message.lastHits = object.lastHits ?? 0;
    message.denies = object.denies ?? 0;
    message.goldPerMin = object.goldPerMin ?? 0;
    message.xpPerMinute = object.xpPerMinute ?? 0;
    message.goldSpent = object.goldSpent ?? 0;
    message.level = object.level ?? 0;
    message.scaledHeroDamage = object.scaledHeroDamage ?? 0;
    message.scaledTowerDamage = object.scaledTowerDamage ?? 0;
    message.scaledHeroHealing = object.scaledHeroHealing ?? 0;
    message.timeLastSeen = object.timeLastSeen ?? 0;
    message.supportAbilityValue = object.supportAbilityValue ?? 0;
    message.partyId = object.partyId ?? "0";
    message.claimedFarmGold = object.claimedFarmGold ?? 0;
    message.supportGold = object.supportGold ?? 0;
    message.claimedDenies = object.claimedDenies ?? 0;
    message.claimedMisses = object.claimedMisses ?? 0;
    message.misses = object.misses ?? 0;
    message.netWorth = object.netWorth ?? 0;
    message.heroDamage = object.heroDamage ?? 0;
    message.towerDamage = object.towerDamage ?? 0;
    message.heroHealing = object.heroHealing ?? 0;
    message.abilityUpgrades = object.abilityUpgrades?.map((e) => CMatchPlayerAbilityUpgrade.fromPartial(e)) || [];
    message.additionalUnitsInventory =
      object.additionalUnitsInventory?.map((e) => CMatchAdditionalUnitInventory.fromPartial(e)) || [];
    message.permanentBuffs = object.permanentBuffs?.map((e) => CMatchPlayerPermanentBuff.fromPartial(e)) || [];
    message.customGameData = (object.customGameData !== undefined && object.customGameData !== null)
      ? CMsgGameMatchSignOut_CTeam_CPlayer_CCustomGameData.fromPartial(object.customGameData)
      : undefined;
    message.matchPlayerFlags = object.matchPlayerFlags ?? 0;
    message.talentAbilityIds = object.talentAbilityIds?.map((e) => e) || [];
    message.heroPickOrder = object.heroPickOrder ?? 0;
    message.heroWasRandomed = object.heroWasRandomed ?? false;
    message.heroWasDotaPlusSuggestion = object.heroWasDotaPlusSuggestion ?? false;
    message.lane = object.lane ?? 0;
    message.isUsingPlusGuide = object.isUsingPlusGuide ?? false;
    message.heroDamageReceived =
      object.heroDamageReceived?.map((e) => CMsgGameMatchSignOut_CTeam_CPlayer_HeroDamageReceived.fromPartial(e)) || [];
    message.heroDamageDealt =
      object.heroDamageDealt?.map((e) => CMsgGameMatchSignOut_CTeam_CPlayer_HeroDamageReceived.fromPartial(e)) || [];
    message.secondsDead = object.secondsDead ?? 0;
    message.goldLostToDeath = object.goldLostToDeath ?? 0;
    message.commandCount = object.commandCount ?? 0;
    message.mouseClickCastCommandCount = object.mouseClickCastCommandCount ?? 0;
    message.teleportsUsed = object.teleportsUsed ?? 0;
    message.cavernCrawlPreferredMapVariant = object.cavernCrawlPreferredMapVariant ?? 255;
    message.bountyRunes = object.bountyRunes ?? 0;
    message.outpostsCaptured = object.outpostsCaptured ?? 0;
    message.dewards = object.dewards ?? 0;
    message.wardsPlaced = object.wardsPlaced ?? 0;
    message.campsStacked = object.campsStacked ?? 0;
    message.playerSlot = object.playerSlot ?? 0;
    message.predictedPosition = object.predictedPosition ?? 0;
    message.laneOutcomes = object.laneOutcomes ?? 255;
    message.friendlyT1DestroyedTime = object.friendlyT1DestroyedTime ?? 0;
    message.enemyT1DestroyedTime = object.enemyT1DestroyedTime ?? 0;
    message.friendlyRoshanKills = object.friendlyRoshanKills ?? 0;
    message.enemyRoshanKills = object.enemyRoshanKills ?? 0;
    message.powerRunes = object.powerRunes ?? 0;
    message.waterRunes = object.waterRunes ?? 0;
    message.stunDuration = object.stunDuration ?? 0;
    message.teamNumber = object.teamNumber ?? 0;
    message.teamSlot = object.teamSlot ?? 0;
    message.timePurchasedShard = object.timePurchasedShard ?? 0;
    message.timePurchasedAghs = object.timePurchasedAghs ?? 0;
    message.abilityDraftAbilities = object.abilityDraftAbilities?.map((e) => e) || [];
    message.playerTrackedStats = object.playerTrackedStats?.map((e) => CMsgTrackedStat.fromPartial(e)) || [];
    message.predictedRank = object.predictedRank ?? 0;
    message.selectedFacet = object.selectedFacet ?? 0;
    message.enhancementLevel = object.enhancementLevel ?? 0;
    return message;
  },
};

function createBaseCMsgGameMatchSignOut_CTeam_CPlayer_CCustomGameData(): CMsgGameMatchSignOut_CTeam_CPlayer_CCustomGameData {
  return { dotaTeam: 0, winner: false };
}

export const CMsgGameMatchSignOut_CTeam_CPlayer_CCustomGameData = {
  encode(
    message: CMsgGameMatchSignOut_CTeam_CPlayer_CCustomGameData,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.dotaTeam !== undefined && message.dotaTeam !== 0) {
      writer.uint32(8).uint32(message.dotaTeam);
    }
    if (message.winner !== undefined && message.winner !== false) {
      writer.uint32(16).bool(message.winner);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGameMatchSignOut_CTeam_CPlayer_CCustomGameData {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGameMatchSignOut_CTeam_CPlayer_CCustomGameData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.dotaTeam = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.winner = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGameMatchSignOut_CTeam_CPlayer_CCustomGameData {
    return {
      dotaTeam: isSet(object.dotaTeam) ? globalThis.Number(object.dotaTeam) : 0,
      winner: isSet(object.winner) ? globalThis.Boolean(object.winner) : false,
    };
  },

  toJSON(message: CMsgGameMatchSignOut_CTeam_CPlayer_CCustomGameData): unknown {
    const obj: any = {};
    if (message.dotaTeam !== undefined && message.dotaTeam !== 0) {
      obj.dotaTeam = Math.round(message.dotaTeam);
    }
    if (message.winner !== undefined && message.winner !== false) {
      obj.winner = message.winner;
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgGameMatchSignOut_CTeam_CPlayer_CCustomGameData>,
  ): CMsgGameMatchSignOut_CTeam_CPlayer_CCustomGameData {
    return CMsgGameMatchSignOut_CTeam_CPlayer_CCustomGameData.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgGameMatchSignOut_CTeam_CPlayer_CCustomGameData>,
  ): CMsgGameMatchSignOut_CTeam_CPlayer_CCustomGameData {
    const message = createBaseCMsgGameMatchSignOut_CTeam_CPlayer_CCustomGameData();
    message.dotaTeam = object.dotaTeam ?? 0;
    message.winner = object.winner ?? false;
    return message;
  },
};

function createBaseCMsgGameMatchSignOut_CTeam_CPlayer_HeroDamageReceived(): CMsgGameMatchSignOut_CTeam_CPlayer_HeroDamageReceived {
  return { preReduction: 0, postReduction: 0, damageType: 0 };
}

export const CMsgGameMatchSignOut_CTeam_CPlayer_HeroDamageReceived = {
  encode(
    message: CMsgGameMatchSignOut_CTeam_CPlayer_HeroDamageReceived,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.preReduction !== undefined && message.preReduction !== 0) {
      writer.uint32(8).uint32(message.preReduction);
    }
    if (message.postReduction !== undefined && message.postReduction !== 0) {
      writer.uint32(16).uint32(message.postReduction);
    }
    if (message.damageType !== undefined && message.damageType !== 0) {
      writer.uint32(24).int32(message.damageType);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGameMatchSignOut_CTeam_CPlayer_HeroDamageReceived {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGameMatchSignOut_CTeam_CPlayer_HeroDamageReceived();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.preReduction = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.postReduction = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.damageType = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGameMatchSignOut_CTeam_CPlayer_HeroDamageReceived {
    return {
      preReduction: isSet(object.preReduction) ? globalThis.Number(object.preReduction) : 0,
      postReduction: isSet(object.postReduction) ? globalThis.Number(object.postReduction) : 0,
      damageType: isSet(object.damageType)
        ? cMsgGameMatchSignOut_CTeam_CPlayer_HeroDamageTypeFromJSON(object.damageType)
        : 0,
    };
  },

  toJSON(message: CMsgGameMatchSignOut_CTeam_CPlayer_HeroDamageReceived): unknown {
    const obj: any = {};
    if (message.preReduction !== undefined && message.preReduction !== 0) {
      obj.preReduction = Math.round(message.preReduction);
    }
    if (message.postReduction !== undefined && message.postReduction !== 0) {
      obj.postReduction = Math.round(message.postReduction);
    }
    if (message.damageType !== undefined && message.damageType !== 0) {
      obj.damageType = cMsgGameMatchSignOut_CTeam_CPlayer_HeroDamageTypeToJSON(message.damageType);
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgGameMatchSignOut_CTeam_CPlayer_HeroDamageReceived>,
  ): CMsgGameMatchSignOut_CTeam_CPlayer_HeroDamageReceived {
    return CMsgGameMatchSignOut_CTeam_CPlayer_HeroDamageReceived.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgGameMatchSignOut_CTeam_CPlayer_HeroDamageReceived>,
  ): CMsgGameMatchSignOut_CTeam_CPlayer_HeroDamageReceived {
    const message = createBaseCMsgGameMatchSignOut_CTeam_CPlayer_HeroDamageReceived();
    message.preReduction = object.preReduction ?? 0;
    message.postReduction = object.postReduction ?? 0;
    message.damageType = object.damageType ?? 0;
    return message;
  },
};

function createBaseCMsgGameMatchSignOut_CAdditionalSignoutMsg(): CMsgGameMatchSignOut_CAdditionalSignoutMsg {
  return { id: 0, contents: Buffer.alloc(0) };
}

export const CMsgGameMatchSignOut_CAdditionalSignoutMsg = {
  encode(message: CMsgGameMatchSignOut_CAdditionalSignoutMsg, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== undefined && message.id !== 0) {
      writer.uint32(8).uint32(message.id);
    }
    if (message.contents !== undefined && message.contents.length !== 0) {
      writer.uint32(18).bytes(message.contents);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGameMatchSignOut_CAdditionalSignoutMsg {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGameMatchSignOut_CAdditionalSignoutMsg();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.contents = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGameMatchSignOut_CAdditionalSignoutMsg {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      contents: isSet(object.contents) ? Buffer.from(bytesFromBase64(object.contents)) : Buffer.alloc(0),
    };
  },

  toJSON(message: CMsgGameMatchSignOut_CAdditionalSignoutMsg): unknown {
    const obj: any = {};
    if (message.id !== undefined && message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.contents !== undefined && message.contents.length !== 0) {
      obj.contents = base64FromBytes(message.contents);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGameMatchSignOut_CAdditionalSignoutMsg>): CMsgGameMatchSignOut_CAdditionalSignoutMsg {
    return CMsgGameMatchSignOut_CAdditionalSignoutMsg.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgGameMatchSignOut_CAdditionalSignoutMsg>,
  ): CMsgGameMatchSignOut_CAdditionalSignoutMsg {
    const message = createBaseCMsgGameMatchSignOut_CAdditionalSignoutMsg();
    message.id = object.id ?? 0;
    message.contents = object.contents ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseCMsgGameMatchSignOut_CSocialFeedMatchEvent(): CMsgGameMatchSignOut_CSocialFeedMatchEvent {
  return { accountId: 0, timestamp: 0, eventType: 0, gameTime: 0, replayTime: 0 };
}

export const CMsgGameMatchSignOut_CSocialFeedMatchEvent = {
  encode(message: CMsgGameMatchSignOut_CSocialFeedMatchEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.accountId !== undefined && message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    if (message.timestamp !== undefined && message.timestamp !== 0) {
      writer.uint32(16).uint32(message.timestamp);
    }
    if (message.eventType !== undefined && message.eventType !== 0) {
      writer.uint32(24).uint32(message.eventType);
    }
    if (message.gameTime !== undefined && message.gameTime !== 0) {
      writer.uint32(32).int32(message.gameTime);
    }
    if (message.replayTime !== undefined && message.replayTime !== 0) {
      writer.uint32(40).uint32(message.replayTime);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGameMatchSignOut_CSocialFeedMatchEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGameMatchSignOut_CSocialFeedMatchEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.timestamp = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.eventType = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.gameTime = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.replayTime = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGameMatchSignOut_CSocialFeedMatchEvent {
    return {
      accountId: isSet(object.accountId) ? globalThis.Number(object.accountId) : 0,
      timestamp: isSet(object.timestamp) ? globalThis.Number(object.timestamp) : 0,
      eventType: isSet(object.eventType) ? globalThis.Number(object.eventType) : 0,
      gameTime: isSet(object.gameTime) ? globalThis.Number(object.gameTime) : 0,
      replayTime: isSet(object.replayTime) ? globalThis.Number(object.replayTime) : 0,
    };
  },

  toJSON(message: CMsgGameMatchSignOut_CSocialFeedMatchEvent): unknown {
    const obj: any = {};
    if (message.accountId !== undefined && message.accountId !== 0) {
      obj.accountId = Math.round(message.accountId);
    }
    if (message.timestamp !== undefined && message.timestamp !== 0) {
      obj.timestamp = Math.round(message.timestamp);
    }
    if (message.eventType !== undefined && message.eventType !== 0) {
      obj.eventType = Math.round(message.eventType);
    }
    if (message.gameTime !== undefined && message.gameTime !== 0) {
      obj.gameTime = Math.round(message.gameTime);
    }
    if (message.replayTime !== undefined && message.replayTime !== 0) {
      obj.replayTime = Math.round(message.replayTime);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGameMatchSignOut_CSocialFeedMatchEvent>): CMsgGameMatchSignOut_CSocialFeedMatchEvent {
    return CMsgGameMatchSignOut_CSocialFeedMatchEvent.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgGameMatchSignOut_CSocialFeedMatchEvent>,
  ): CMsgGameMatchSignOut_CSocialFeedMatchEvent {
    const message = createBaseCMsgGameMatchSignOut_CSocialFeedMatchEvent();
    message.accountId = object.accountId ?? 0;
    message.timestamp = object.timestamp ?? 0;
    message.eventType = object.eventType ?? 0;
    message.gameTime = object.gameTime ?? 0;
    message.replayTime = object.replayTime ?? 0;
    return message;
  },
};

function createBaseCMsgGameMatchSignOut_CCustomGameData(): CMsgGameMatchSignOut_CCustomGameData {
  return { publishTimestamp: 0 };
}

export const CMsgGameMatchSignOut_CCustomGameData = {
  encode(message: CMsgGameMatchSignOut_CCustomGameData, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.publishTimestamp !== undefined && message.publishTimestamp !== 0) {
      writer.uint32(8).uint32(message.publishTimestamp);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGameMatchSignOut_CCustomGameData {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGameMatchSignOut_CCustomGameData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.publishTimestamp = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGameMatchSignOut_CCustomGameData {
    return { publishTimestamp: isSet(object.publishTimestamp) ? globalThis.Number(object.publishTimestamp) : 0 };
  },

  toJSON(message: CMsgGameMatchSignOut_CCustomGameData): unknown {
    const obj: any = {};
    if (message.publishTimestamp !== undefined && message.publishTimestamp !== 0) {
      obj.publishTimestamp = Math.round(message.publishTimestamp);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGameMatchSignOut_CCustomGameData>): CMsgGameMatchSignOut_CCustomGameData {
    return CMsgGameMatchSignOut_CCustomGameData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGameMatchSignOut_CCustomGameData>): CMsgGameMatchSignOut_CCustomGameData {
    const message = createBaseCMsgGameMatchSignOut_CCustomGameData();
    message.publishTimestamp = object.publishTimestamp ?? 0;
    return message;
  },
};

function createBaseCMsgGameMatchSignOut_EventGameLeaderboardEntry(): CMsgGameMatchSignOut_EventGameLeaderboardEntry {
  return { nameSuffix: "", score: 0, extraData1: 0, extraData2: 0, extraData3: 0, extraData4: 0, extraData5: 0 };
}

export const CMsgGameMatchSignOut_EventGameLeaderboardEntry = {
  encode(
    message: CMsgGameMatchSignOut_EventGameLeaderboardEntry,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.nameSuffix !== undefined && message.nameSuffix !== "") {
      writer.uint32(10).string(message.nameSuffix);
    }
    if (message.score !== undefined && message.score !== 0) {
      writer.uint32(16).int32(message.score);
    }
    if (message.extraData1 !== undefined && message.extraData1 !== 0) {
      writer.uint32(24).uint32(message.extraData1);
    }
    if (message.extraData2 !== undefined && message.extraData2 !== 0) {
      writer.uint32(32).uint32(message.extraData2);
    }
    if (message.extraData3 !== undefined && message.extraData3 !== 0) {
      writer.uint32(40).uint32(message.extraData3);
    }
    if (message.extraData4 !== undefined && message.extraData4 !== 0) {
      writer.uint32(48).uint32(message.extraData4);
    }
    if (message.extraData5 !== undefined && message.extraData5 !== 0) {
      writer.uint32(56).uint32(message.extraData5);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGameMatchSignOut_EventGameLeaderboardEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGameMatchSignOut_EventGameLeaderboardEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.nameSuffix = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.score = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.extraData1 = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.extraData2 = reader.uint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.extraData3 = reader.uint32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.extraData4 = reader.uint32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.extraData5 = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGameMatchSignOut_EventGameLeaderboardEntry {
    return {
      nameSuffix: isSet(object.nameSuffix) ? globalThis.String(object.nameSuffix) : "",
      score: isSet(object.score) ? globalThis.Number(object.score) : 0,
      extraData1: isSet(object.extraData1) ? globalThis.Number(object.extraData1) : 0,
      extraData2: isSet(object.extraData2) ? globalThis.Number(object.extraData2) : 0,
      extraData3: isSet(object.extraData3) ? globalThis.Number(object.extraData3) : 0,
      extraData4: isSet(object.extraData4) ? globalThis.Number(object.extraData4) : 0,
      extraData5: isSet(object.extraData5) ? globalThis.Number(object.extraData5) : 0,
    };
  },

  toJSON(message: CMsgGameMatchSignOut_EventGameLeaderboardEntry): unknown {
    const obj: any = {};
    if (message.nameSuffix !== undefined && message.nameSuffix !== "") {
      obj.nameSuffix = message.nameSuffix;
    }
    if (message.score !== undefined && message.score !== 0) {
      obj.score = Math.round(message.score);
    }
    if (message.extraData1 !== undefined && message.extraData1 !== 0) {
      obj.extraData1 = Math.round(message.extraData1);
    }
    if (message.extraData2 !== undefined && message.extraData2 !== 0) {
      obj.extraData2 = Math.round(message.extraData2);
    }
    if (message.extraData3 !== undefined && message.extraData3 !== 0) {
      obj.extraData3 = Math.round(message.extraData3);
    }
    if (message.extraData4 !== undefined && message.extraData4 !== 0) {
      obj.extraData4 = Math.round(message.extraData4);
    }
    if (message.extraData5 !== undefined && message.extraData5 !== 0) {
      obj.extraData5 = Math.round(message.extraData5);
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgGameMatchSignOut_EventGameLeaderboardEntry>,
  ): CMsgGameMatchSignOut_EventGameLeaderboardEntry {
    return CMsgGameMatchSignOut_EventGameLeaderboardEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgGameMatchSignOut_EventGameLeaderboardEntry>,
  ): CMsgGameMatchSignOut_EventGameLeaderboardEntry {
    const message = createBaseCMsgGameMatchSignOut_EventGameLeaderboardEntry();
    message.nameSuffix = object.nameSuffix ?? "";
    message.score = object.score ?? 0;
    message.extraData1 = object.extraData1 ?? 0;
    message.extraData2 = object.extraData2 ?? 0;
    message.extraData3 = object.extraData3 ?? 0;
    message.extraData4 = object.extraData4 ?? 0;
    message.extraData5 = object.extraData5 ?? 0;
    return message;
  },
};

function createBaseCMsgGameMatchSignOut_WardPlacement(): CMsgGameMatchSignOut_WardPlacement {
  return {
    playerId: -1,
    teamId: 0,
    placedTime: 0,
    buildingState: 0,
    creepState: 0,
    roshanAlive: false,
    positionX: 0,
    positionY: 0,
  };
}

export const CMsgGameMatchSignOut_WardPlacement = {
  encode(message: CMsgGameMatchSignOut_WardPlacement, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.playerId !== undefined && message.playerId !== -1) {
      writer.uint32(8).int32(message.playerId);
    }
    if (message.teamId !== undefined && message.teamId !== 0) {
      writer.uint32(16).uint32(message.teamId);
    }
    if (message.placedTime !== undefined && message.placedTime !== 0) {
      writer.uint32(24).uint32(message.placedTime);
    }
    if (message.buildingState !== undefined && message.buildingState !== 0) {
      writer.uint32(32).uint32(message.buildingState);
    }
    if (message.creepState !== undefined && message.creepState !== 0) {
      writer.uint32(40).uint32(message.creepState);
    }
    if (message.roshanAlive !== undefined && message.roshanAlive !== false) {
      writer.uint32(48).bool(message.roshanAlive);
    }
    if (message.positionX !== undefined && message.positionX !== 0) {
      writer.uint32(56).uint32(message.positionX);
    }
    if (message.positionY !== undefined && message.positionY !== 0) {
      writer.uint32(64).uint32(message.positionY);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGameMatchSignOut_WardPlacement {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGameMatchSignOut_WardPlacement();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.playerId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.teamId = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.placedTime = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.buildingState = reader.uint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.creepState = reader.uint32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.roshanAlive = reader.bool();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.positionX = reader.uint32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.positionY = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGameMatchSignOut_WardPlacement {
    return {
      playerId: isSet(object.playerId) ? globalThis.Number(object.playerId) : -1,
      teamId: isSet(object.teamId) ? globalThis.Number(object.teamId) : 0,
      placedTime: isSet(object.placedTime) ? globalThis.Number(object.placedTime) : 0,
      buildingState: isSet(object.buildingState) ? globalThis.Number(object.buildingState) : 0,
      creepState: isSet(object.creepState) ? globalThis.Number(object.creepState) : 0,
      roshanAlive: isSet(object.roshanAlive) ? globalThis.Boolean(object.roshanAlive) : false,
      positionX: isSet(object.positionX) ? globalThis.Number(object.positionX) : 0,
      positionY: isSet(object.positionY) ? globalThis.Number(object.positionY) : 0,
    };
  },

  toJSON(message: CMsgGameMatchSignOut_WardPlacement): unknown {
    const obj: any = {};
    if (message.playerId !== undefined && message.playerId !== -1) {
      obj.playerId = Math.round(message.playerId);
    }
    if (message.teamId !== undefined && message.teamId !== 0) {
      obj.teamId = Math.round(message.teamId);
    }
    if (message.placedTime !== undefined && message.placedTime !== 0) {
      obj.placedTime = Math.round(message.placedTime);
    }
    if (message.buildingState !== undefined && message.buildingState !== 0) {
      obj.buildingState = Math.round(message.buildingState);
    }
    if (message.creepState !== undefined && message.creepState !== 0) {
      obj.creepState = Math.round(message.creepState);
    }
    if (message.roshanAlive !== undefined && message.roshanAlive !== false) {
      obj.roshanAlive = message.roshanAlive;
    }
    if (message.positionX !== undefined && message.positionX !== 0) {
      obj.positionX = Math.round(message.positionX);
    }
    if (message.positionY !== undefined && message.positionY !== 0) {
      obj.positionY = Math.round(message.positionY);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGameMatchSignOut_WardPlacement>): CMsgGameMatchSignOut_WardPlacement {
    return CMsgGameMatchSignOut_WardPlacement.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGameMatchSignOut_WardPlacement>): CMsgGameMatchSignOut_WardPlacement {
    const message = createBaseCMsgGameMatchSignOut_WardPlacement();
    message.playerId = object.playerId ?? -1;
    message.teamId = object.teamId ?? 0;
    message.placedTime = object.placedTime ?? 0;
    message.buildingState = object.buildingState ?? 0;
    message.creepState = object.creepState ?? 0;
    message.roshanAlive = object.roshanAlive ?? false;
    message.positionX = object.positionX ?? 0;
    message.positionY = object.positionY ?? 0;
    return message;
  },
};

function createBaseCMsgSignOutDraftInfo(): CMsgSignOutDraftInfo {
  return { radiantCaptainAccountId: 0, direCaptainAccountId: 0, picksBans: [] };
}

export const CMsgSignOutDraftInfo = {
  encode(message: CMsgSignOutDraftInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.radiantCaptainAccountId !== undefined && message.radiantCaptainAccountId !== 0) {
      writer.uint32(8).uint32(message.radiantCaptainAccountId);
    }
    if (message.direCaptainAccountId !== undefined && message.direCaptainAccountId !== 0) {
      writer.uint32(16).uint32(message.direCaptainAccountId);
    }
    for (const v of message.picksBans) {
      CMatchHeroSelectEvent.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSignOutDraftInfo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSignOutDraftInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.radiantCaptainAccountId = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.direCaptainAccountId = reader.uint32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.picksBans.push(CMatchHeroSelectEvent.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSignOutDraftInfo {
    return {
      radiantCaptainAccountId: isSet(object.radiantCaptainAccountId)
        ? globalThis.Number(object.radiantCaptainAccountId)
        : 0,
      direCaptainAccountId: isSet(object.direCaptainAccountId) ? globalThis.Number(object.direCaptainAccountId) : 0,
      picksBans: globalThis.Array.isArray(object?.picksBans)
        ? object.picksBans.map((e: any) => CMatchHeroSelectEvent.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgSignOutDraftInfo): unknown {
    const obj: any = {};
    if (message.radiantCaptainAccountId !== undefined && message.radiantCaptainAccountId !== 0) {
      obj.radiantCaptainAccountId = Math.round(message.radiantCaptainAccountId);
    }
    if (message.direCaptainAccountId !== undefined && message.direCaptainAccountId !== 0) {
      obj.direCaptainAccountId = Math.round(message.direCaptainAccountId);
    }
    if (message.picksBans?.length) {
      obj.picksBans = message.picksBans.map((e) => CMatchHeroSelectEvent.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSignOutDraftInfo>): CMsgSignOutDraftInfo {
    return CMsgSignOutDraftInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSignOutDraftInfo>): CMsgSignOutDraftInfo {
    const message = createBaseCMsgSignOutDraftInfo();
    message.radiantCaptainAccountId = object.radiantCaptainAccountId ?? 0;
    message.direCaptainAccountId = object.direCaptainAccountId ?? 0;
    message.picksBans = object.picksBans?.map((e) => CMatchHeroSelectEvent.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgSignOutBotInfo(): CMsgSignOutBotInfo {
  return { allowCheats: false, botDifficultyRadiant: 0, createdLobby: false, botDifficultyDire: 0 };
}

export const CMsgSignOutBotInfo = {
  encode(message: CMsgSignOutBotInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.allowCheats !== undefined && message.allowCheats !== false) {
      writer.uint32(8).bool(message.allowCheats);
    }
    if (message.botDifficultyRadiant !== undefined && message.botDifficultyRadiant !== 0) {
      writer.uint32(16).int32(message.botDifficultyRadiant);
    }
    if (message.createdLobby !== undefined && message.createdLobby !== false) {
      writer.uint32(24).bool(message.createdLobby);
    }
    if (message.botDifficultyDire !== undefined && message.botDifficultyDire !== 0) {
      writer.uint32(40).int32(message.botDifficultyDire);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSignOutBotInfo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSignOutBotInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.allowCheats = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.botDifficultyRadiant = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.createdLobby = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.botDifficultyDire = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSignOutBotInfo {
    return {
      allowCheats: isSet(object.allowCheats) ? globalThis.Boolean(object.allowCheats) : false,
      botDifficultyRadiant: isSet(object.botDifficultyRadiant)
        ? dOTABotDifficultyFromJSON(object.botDifficultyRadiant)
        : 0,
      createdLobby: isSet(object.createdLobby) ? globalThis.Boolean(object.createdLobby) : false,
      botDifficultyDire: isSet(object.botDifficultyDire) ? dOTABotDifficultyFromJSON(object.botDifficultyDire) : 0,
    };
  },

  toJSON(message: CMsgSignOutBotInfo): unknown {
    const obj: any = {};
    if (message.allowCheats !== undefined && message.allowCheats !== false) {
      obj.allowCheats = message.allowCheats;
    }
    if (message.botDifficultyRadiant !== undefined && message.botDifficultyRadiant !== 0) {
      obj.botDifficultyRadiant = dOTABotDifficultyToJSON(message.botDifficultyRadiant);
    }
    if (message.createdLobby !== undefined && message.createdLobby !== false) {
      obj.createdLobby = message.createdLobby;
    }
    if (message.botDifficultyDire !== undefined && message.botDifficultyDire !== 0) {
      obj.botDifficultyDire = dOTABotDifficultyToJSON(message.botDifficultyDire);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSignOutBotInfo>): CMsgSignOutBotInfo {
    return CMsgSignOutBotInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSignOutBotInfo>): CMsgSignOutBotInfo {
    const message = createBaseCMsgSignOutBotInfo();
    message.allowCheats = object.allowCheats ?? false;
    message.botDifficultyRadiant = object.botDifficultyRadiant ?? 0;
    message.createdLobby = object.createdLobby ?? false;
    message.botDifficultyDire = object.botDifficultyDire ?? 0;
    return message;
  },
};

function createBaseCMsgSignOutTextMuteInfo(): CMsgSignOutTextMuteInfo {
  return { textMuteMessages: [] };
}

export const CMsgSignOutTextMuteInfo = {
  encode(message: CMsgSignOutTextMuteInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.textMuteMessages) {
      CMsgSignOutTextMuteInfo_TextMuteMessage.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSignOutTextMuteInfo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSignOutTextMuteInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.textMuteMessages.push(CMsgSignOutTextMuteInfo_TextMuteMessage.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSignOutTextMuteInfo {
    return {
      textMuteMessages: globalThis.Array.isArray(object?.textMuteMessages)
        ? object.textMuteMessages.map((e: any) => CMsgSignOutTextMuteInfo_TextMuteMessage.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgSignOutTextMuteInfo): unknown {
    const obj: any = {};
    if (message.textMuteMessages?.length) {
      obj.textMuteMessages = message.textMuteMessages.map((e) => CMsgSignOutTextMuteInfo_TextMuteMessage.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSignOutTextMuteInfo>): CMsgSignOutTextMuteInfo {
    return CMsgSignOutTextMuteInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSignOutTextMuteInfo>): CMsgSignOutTextMuteInfo {
    const message = createBaseCMsgSignOutTextMuteInfo();
    message.textMuteMessages =
      object.textMuteMessages?.map((e) => CMsgSignOutTextMuteInfo_TextMuteMessage.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgSignOutTextMuteInfo_TextMuteMessage(): CMsgSignOutTextMuteInfo_TextMuteMessage {
  return { region: 0, causedTextMute: false, chatMessage: "" };
}

export const CMsgSignOutTextMuteInfo_TextMuteMessage = {
  encode(message: CMsgSignOutTextMuteInfo_TextMuteMessage, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.region !== undefined && message.region !== 0) {
      writer.uint32(8).uint32(message.region);
    }
    if (message.causedTextMute !== undefined && message.causedTextMute !== false) {
      writer.uint32(16).bool(message.causedTextMute);
    }
    if (message.chatMessage !== undefined && message.chatMessage !== "") {
      writer.uint32(26).string(message.chatMessage);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSignOutTextMuteInfo_TextMuteMessage {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSignOutTextMuteInfo_TextMuteMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.region = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.causedTextMute = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.chatMessage = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSignOutTextMuteInfo_TextMuteMessage {
    return {
      region: isSet(object.region) ? globalThis.Number(object.region) : 0,
      causedTextMute: isSet(object.causedTextMute) ? globalThis.Boolean(object.causedTextMute) : false,
      chatMessage: isSet(object.chatMessage) ? globalThis.String(object.chatMessage) : "",
    };
  },

  toJSON(message: CMsgSignOutTextMuteInfo_TextMuteMessage): unknown {
    const obj: any = {};
    if (message.region !== undefined && message.region !== 0) {
      obj.region = Math.round(message.region);
    }
    if (message.causedTextMute !== undefined && message.causedTextMute !== false) {
      obj.causedTextMute = message.causedTextMute;
    }
    if (message.chatMessage !== undefined && message.chatMessage !== "") {
      obj.chatMessage = message.chatMessage;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSignOutTextMuteInfo_TextMuteMessage>): CMsgSignOutTextMuteInfo_TextMuteMessage {
    return CMsgSignOutTextMuteInfo_TextMuteMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSignOutTextMuteInfo_TextMuteMessage>): CMsgSignOutTextMuteInfo_TextMuteMessage {
    const message = createBaseCMsgSignOutTextMuteInfo_TextMuteMessage();
    message.region = object.region ?? 0;
    message.causedTextMute = object.causedTextMute ?? false;
    message.chatMessage = object.chatMessage ?? "";
    return message;
  },
};

function createBaseCMsgSignOutPlayerStats(): CMsgSignOutPlayerStats {
  return {
    accountId: 0,
    matchId: "0",
    rank: 0,
    heroId: 0,
    rampages: 0,
    tripleKills: 0,
    firstBloodClaimed: 0,
    firstBloodGiven: 0,
    couriersKilled: 0,
    aegisesSnatched: 0,
    cheesesEaten: 0,
    creepsStacked: 0,
    fightScore: 0,
    farmScore: 0,
    supportScore: 0,
    pushScore: 0,
    kills: 0,
    deaths: 0,
    assists: 0,
    lastHits: 0,
    denies: 0,
    gpm: 0,
    xppm: 0,
    netWorth: 0,
    damage: 0,
    heals: 0,
    rapiersPurchased: 0,
    observerWardsPlaced: 0,
    wardsDestroyed: 0,
    lobbyType: 0,
  };
}

export const CMsgSignOutPlayerStats = {
  encode(message: CMsgSignOutPlayerStats, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.accountId !== undefined && message.accountId !== 0) {
      writer.uint32(8).int32(message.accountId);
    }
    if (message.matchId !== undefined && message.matchId !== "0") {
      writer.uint32(16).uint64(message.matchId);
    }
    if (message.rank !== undefined && message.rank !== 0) {
      writer.uint32(24).uint32(message.rank);
    }
    if (message.heroId !== undefined && message.heroId !== 0) {
      writer.uint32(32).int32(message.heroId);
    }
    if (message.rampages !== undefined && message.rampages !== 0) {
      writer.uint32(40).uint32(message.rampages);
    }
    if (message.tripleKills !== undefined && message.tripleKills !== 0) {
      writer.uint32(48).uint32(message.tripleKills);
    }
    if (message.firstBloodClaimed !== undefined && message.firstBloodClaimed !== 0) {
      writer.uint32(56).uint32(message.firstBloodClaimed);
    }
    if (message.firstBloodGiven !== undefined && message.firstBloodGiven !== 0) {
      writer.uint32(64).uint32(message.firstBloodGiven);
    }
    if (message.couriersKilled !== undefined && message.couriersKilled !== 0) {
      writer.uint32(72).uint32(message.couriersKilled);
    }
    if (message.aegisesSnatched !== undefined && message.aegisesSnatched !== 0) {
      writer.uint32(80).uint32(message.aegisesSnatched);
    }
    if (message.cheesesEaten !== undefined && message.cheesesEaten !== 0) {
      writer.uint32(88).uint32(message.cheesesEaten);
    }
    if (message.creepsStacked !== undefined && message.creepsStacked !== 0) {
      writer.uint32(96).uint32(message.creepsStacked);
    }
    if (message.fightScore !== undefined && message.fightScore !== 0) {
      writer.uint32(109).float(message.fightScore);
    }
    if (message.farmScore !== undefined && message.farmScore !== 0) {
      writer.uint32(117).float(message.farmScore);
    }
    if (message.supportScore !== undefined && message.supportScore !== 0) {
      writer.uint32(125).float(message.supportScore);
    }
    if (message.pushScore !== undefined && message.pushScore !== 0) {
      writer.uint32(133).float(message.pushScore);
    }
    if (message.kills !== undefined && message.kills !== 0) {
      writer.uint32(136).uint32(message.kills);
    }
    if (message.deaths !== undefined && message.deaths !== 0) {
      writer.uint32(144).uint32(message.deaths);
    }
    if (message.assists !== undefined && message.assists !== 0) {
      writer.uint32(152).uint32(message.assists);
    }
    if (message.lastHits !== undefined && message.lastHits !== 0) {
      writer.uint32(160).uint32(message.lastHits);
    }
    if (message.denies !== undefined && message.denies !== 0) {
      writer.uint32(168).uint32(message.denies);
    }
    if (message.gpm !== undefined && message.gpm !== 0) {
      writer.uint32(181).float(message.gpm);
    }
    if (message.xppm !== undefined && message.xppm !== 0) {
      writer.uint32(189).float(message.xppm);
    }
    if (message.netWorth !== undefined && message.netWorth !== 0) {
      writer.uint32(197).float(message.netWorth);
    }
    if (message.damage !== undefined && message.damage !== 0) {
      writer.uint32(205).float(message.damage);
    }
    if (message.heals !== undefined && message.heals !== 0) {
      writer.uint32(213).float(message.heals);
    }
    if (message.rapiersPurchased !== undefined && message.rapiersPurchased !== 0) {
      writer.uint32(216).uint32(message.rapiersPurchased);
    }
    if (message.observerWardsPlaced !== undefined && message.observerWardsPlaced !== 0) {
      writer.uint32(224).uint32(message.observerWardsPlaced);
    }
    if (message.wardsDestroyed !== undefined && message.wardsDestroyed !== 0) {
      writer.uint32(232).uint32(message.wardsDestroyed);
    }
    if (message.lobbyType !== undefined && message.lobbyType !== 0) {
      writer.uint32(240).uint32(message.lobbyType);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSignOutPlayerStats {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSignOutPlayerStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.accountId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.matchId = longToString(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.rank = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.heroId = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.rampages = reader.uint32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.tripleKills = reader.uint32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.firstBloodClaimed = reader.uint32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.firstBloodGiven = reader.uint32();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.couriersKilled = reader.uint32();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.aegisesSnatched = reader.uint32();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.cheesesEaten = reader.uint32();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.creepsStacked = reader.uint32();
          continue;
        case 13:
          if (tag !== 109) {
            break;
          }

          message.fightScore = reader.float();
          continue;
        case 14:
          if (tag !== 117) {
            break;
          }

          message.farmScore = reader.float();
          continue;
        case 15:
          if (tag !== 125) {
            break;
          }

          message.supportScore = reader.float();
          continue;
        case 16:
          if (tag !== 133) {
            break;
          }

          message.pushScore = reader.float();
          continue;
        case 17:
          if (tag !== 136) {
            break;
          }

          message.kills = reader.uint32();
          continue;
        case 18:
          if (tag !== 144) {
            break;
          }

          message.deaths = reader.uint32();
          continue;
        case 19:
          if (tag !== 152) {
            break;
          }

          message.assists = reader.uint32();
          continue;
        case 20:
          if (tag !== 160) {
            break;
          }

          message.lastHits = reader.uint32();
          continue;
        case 21:
          if (tag !== 168) {
            break;
          }

          message.denies = reader.uint32();
          continue;
        case 22:
          if (tag !== 181) {
            break;
          }

          message.gpm = reader.float();
          continue;
        case 23:
          if (tag !== 189) {
            break;
          }

          message.xppm = reader.float();
          continue;
        case 24:
          if (tag !== 197) {
            break;
          }

          message.netWorth = reader.float();
          continue;
        case 25:
          if (tag !== 205) {
            break;
          }

          message.damage = reader.float();
          continue;
        case 26:
          if (tag !== 213) {
            break;
          }

          message.heals = reader.float();
          continue;
        case 27:
          if (tag !== 216) {
            break;
          }

          message.rapiersPurchased = reader.uint32();
          continue;
        case 28:
          if (tag !== 224) {
            break;
          }

          message.observerWardsPlaced = reader.uint32();
          continue;
        case 29:
          if (tag !== 232) {
            break;
          }

          message.wardsDestroyed = reader.uint32();
          continue;
        case 30:
          if (tag !== 240) {
            break;
          }

          message.lobbyType = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSignOutPlayerStats {
    return {
      accountId: isSet(object.accountId) ? globalThis.Number(object.accountId) : 0,
      matchId: isSet(object.matchId) ? globalThis.String(object.matchId) : "0",
      rank: isSet(object.rank) ? globalThis.Number(object.rank) : 0,
      heroId: isSet(object.heroId) ? globalThis.Number(object.heroId) : 0,
      rampages: isSet(object.rampages) ? globalThis.Number(object.rampages) : 0,
      tripleKills: isSet(object.tripleKills) ? globalThis.Number(object.tripleKills) : 0,
      firstBloodClaimed: isSet(object.firstBloodClaimed) ? globalThis.Number(object.firstBloodClaimed) : 0,
      firstBloodGiven: isSet(object.firstBloodGiven) ? globalThis.Number(object.firstBloodGiven) : 0,
      couriersKilled: isSet(object.couriersKilled) ? globalThis.Number(object.couriersKilled) : 0,
      aegisesSnatched: isSet(object.aegisesSnatched) ? globalThis.Number(object.aegisesSnatched) : 0,
      cheesesEaten: isSet(object.cheesesEaten) ? globalThis.Number(object.cheesesEaten) : 0,
      creepsStacked: isSet(object.creepsStacked) ? globalThis.Number(object.creepsStacked) : 0,
      fightScore: isSet(object.fightScore) ? globalThis.Number(object.fightScore) : 0,
      farmScore: isSet(object.farmScore) ? globalThis.Number(object.farmScore) : 0,
      supportScore: isSet(object.supportScore) ? globalThis.Number(object.supportScore) : 0,
      pushScore: isSet(object.pushScore) ? globalThis.Number(object.pushScore) : 0,
      kills: isSet(object.kills) ? globalThis.Number(object.kills) : 0,
      deaths: isSet(object.deaths) ? globalThis.Number(object.deaths) : 0,
      assists: isSet(object.assists) ? globalThis.Number(object.assists) : 0,
      lastHits: isSet(object.lastHits) ? globalThis.Number(object.lastHits) : 0,
      denies: isSet(object.denies) ? globalThis.Number(object.denies) : 0,
      gpm: isSet(object.gpm) ? globalThis.Number(object.gpm) : 0,
      xppm: isSet(object.xppm) ? globalThis.Number(object.xppm) : 0,
      netWorth: isSet(object.netWorth) ? globalThis.Number(object.netWorth) : 0,
      damage: isSet(object.damage) ? globalThis.Number(object.damage) : 0,
      heals: isSet(object.heals) ? globalThis.Number(object.heals) : 0,
      rapiersPurchased: isSet(object.rapiersPurchased) ? globalThis.Number(object.rapiersPurchased) : 0,
      observerWardsPlaced: isSet(object.observerWardsPlaced) ? globalThis.Number(object.observerWardsPlaced) : 0,
      wardsDestroyed: isSet(object.wardsDestroyed) ? globalThis.Number(object.wardsDestroyed) : 0,
      lobbyType: isSet(object.lobbyType) ? globalThis.Number(object.lobbyType) : 0,
    };
  },

  toJSON(message: CMsgSignOutPlayerStats): unknown {
    const obj: any = {};
    if (message.accountId !== undefined && message.accountId !== 0) {
      obj.accountId = Math.round(message.accountId);
    }
    if (message.matchId !== undefined && message.matchId !== "0") {
      obj.matchId = message.matchId;
    }
    if (message.rank !== undefined && message.rank !== 0) {
      obj.rank = Math.round(message.rank);
    }
    if (message.heroId !== undefined && message.heroId !== 0) {
      obj.heroId = Math.round(message.heroId);
    }
    if (message.rampages !== undefined && message.rampages !== 0) {
      obj.rampages = Math.round(message.rampages);
    }
    if (message.tripleKills !== undefined && message.tripleKills !== 0) {
      obj.tripleKills = Math.round(message.tripleKills);
    }
    if (message.firstBloodClaimed !== undefined && message.firstBloodClaimed !== 0) {
      obj.firstBloodClaimed = Math.round(message.firstBloodClaimed);
    }
    if (message.firstBloodGiven !== undefined && message.firstBloodGiven !== 0) {
      obj.firstBloodGiven = Math.round(message.firstBloodGiven);
    }
    if (message.couriersKilled !== undefined && message.couriersKilled !== 0) {
      obj.couriersKilled = Math.round(message.couriersKilled);
    }
    if (message.aegisesSnatched !== undefined && message.aegisesSnatched !== 0) {
      obj.aegisesSnatched = Math.round(message.aegisesSnatched);
    }
    if (message.cheesesEaten !== undefined && message.cheesesEaten !== 0) {
      obj.cheesesEaten = Math.round(message.cheesesEaten);
    }
    if (message.creepsStacked !== undefined && message.creepsStacked !== 0) {
      obj.creepsStacked = Math.round(message.creepsStacked);
    }
    if (message.fightScore !== undefined && message.fightScore !== 0) {
      obj.fightScore = message.fightScore;
    }
    if (message.farmScore !== undefined && message.farmScore !== 0) {
      obj.farmScore = message.farmScore;
    }
    if (message.supportScore !== undefined && message.supportScore !== 0) {
      obj.supportScore = message.supportScore;
    }
    if (message.pushScore !== undefined && message.pushScore !== 0) {
      obj.pushScore = message.pushScore;
    }
    if (message.kills !== undefined && message.kills !== 0) {
      obj.kills = Math.round(message.kills);
    }
    if (message.deaths !== undefined && message.deaths !== 0) {
      obj.deaths = Math.round(message.deaths);
    }
    if (message.assists !== undefined && message.assists !== 0) {
      obj.assists = Math.round(message.assists);
    }
    if (message.lastHits !== undefined && message.lastHits !== 0) {
      obj.lastHits = Math.round(message.lastHits);
    }
    if (message.denies !== undefined && message.denies !== 0) {
      obj.denies = Math.round(message.denies);
    }
    if (message.gpm !== undefined && message.gpm !== 0) {
      obj.gpm = message.gpm;
    }
    if (message.xppm !== undefined && message.xppm !== 0) {
      obj.xppm = message.xppm;
    }
    if (message.netWorth !== undefined && message.netWorth !== 0) {
      obj.netWorth = message.netWorth;
    }
    if (message.damage !== undefined && message.damage !== 0) {
      obj.damage = message.damage;
    }
    if (message.heals !== undefined && message.heals !== 0) {
      obj.heals = message.heals;
    }
    if (message.rapiersPurchased !== undefined && message.rapiersPurchased !== 0) {
      obj.rapiersPurchased = Math.round(message.rapiersPurchased);
    }
    if (message.observerWardsPlaced !== undefined && message.observerWardsPlaced !== 0) {
      obj.observerWardsPlaced = Math.round(message.observerWardsPlaced);
    }
    if (message.wardsDestroyed !== undefined && message.wardsDestroyed !== 0) {
      obj.wardsDestroyed = Math.round(message.wardsDestroyed);
    }
    if (message.lobbyType !== undefined && message.lobbyType !== 0) {
      obj.lobbyType = Math.round(message.lobbyType);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSignOutPlayerStats>): CMsgSignOutPlayerStats {
    return CMsgSignOutPlayerStats.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSignOutPlayerStats>): CMsgSignOutPlayerStats {
    const message = createBaseCMsgSignOutPlayerStats();
    message.accountId = object.accountId ?? 0;
    message.matchId = object.matchId ?? "0";
    message.rank = object.rank ?? 0;
    message.heroId = object.heroId ?? 0;
    message.rampages = object.rampages ?? 0;
    message.tripleKills = object.tripleKills ?? 0;
    message.firstBloodClaimed = object.firstBloodClaimed ?? 0;
    message.firstBloodGiven = object.firstBloodGiven ?? 0;
    message.couriersKilled = object.couriersKilled ?? 0;
    message.aegisesSnatched = object.aegisesSnatched ?? 0;
    message.cheesesEaten = object.cheesesEaten ?? 0;
    message.creepsStacked = object.creepsStacked ?? 0;
    message.fightScore = object.fightScore ?? 0;
    message.farmScore = object.farmScore ?? 0;
    message.supportScore = object.supportScore ?? 0;
    message.pushScore = object.pushScore ?? 0;
    message.kills = object.kills ?? 0;
    message.deaths = object.deaths ?? 0;
    message.assists = object.assists ?? 0;
    message.lastHits = object.lastHits ?? 0;
    message.denies = object.denies ?? 0;
    message.gpm = object.gpm ?? 0;
    message.xppm = object.xppm ?? 0;
    message.netWorth = object.netWorth ?? 0;
    message.damage = object.damage ?? 0;
    message.heals = object.heals ?? 0;
    message.rapiersPurchased = object.rapiersPurchased ?? 0;
    message.observerWardsPlaced = object.observerWardsPlaced ?? 0;
    message.wardsDestroyed = object.wardsDestroyed ?? 0;
    message.lobbyType = object.lobbyType ?? 0;
    return message;
  },
};

function createBaseCMsgSignOutCommunicationSummary(): CMsgSignOutCommunicationSummary {
  return { players: [] };
}

export const CMsgSignOutCommunicationSummary = {
  encode(message: CMsgSignOutCommunicationSummary, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.players) {
      CMsgSignOutCommunicationSummary_PlayerCommunication.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSignOutCommunicationSummary {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSignOutCommunicationSummary();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.players.push(CMsgSignOutCommunicationSummary_PlayerCommunication.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSignOutCommunicationSummary {
    return {
      players: globalThis.Array.isArray(object?.players)
        ? object.players.map((e: any) => CMsgSignOutCommunicationSummary_PlayerCommunication.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgSignOutCommunicationSummary): unknown {
    const obj: any = {};
    if (message.players?.length) {
      obj.players = message.players.map((e) => CMsgSignOutCommunicationSummary_PlayerCommunication.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSignOutCommunicationSummary>): CMsgSignOutCommunicationSummary {
    return CMsgSignOutCommunicationSummary.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSignOutCommunicationSummary>): CMsgSignOutCommunicationSummary {
    const message = createBaseCMsgSignOutCommunicationSummary();
    message.players = object.players?.map((e) => CMsgSignOutCommunicationSummary_PlayerCommunication.fromPartial(e)) ||
      [];
    return message;
  },
};

function createBaseCMsgSignOutCommunicationSummary_PlayerCommunication(): CMsgSignOutCommunicationSummary_PlayerCommunication {
  return {
    accountId: 0,
    pings: 0,
    maxPingsPerInterval: 0,
    teammatePings: 0,
    maxTeammatePingsPerInterval: 0,
    teamChatMessages: 0,
    allChatMessages: 0,
    chatWheelMessages: 0,
    pauses: 0,
    unpauses: 0,
    linesDrawn: 0,
    voiceChatSeconds: 0,
    chatMutes: 0,
    voiceMutes: 0,
    pingDetails: [],
    commsBlocksSolo: 0,
    commsBlocksMass: 0,
    chatLog: [],
  };
}

export const CMsgSignOutCommunicationSummary_PlayerCommunication = {
  encode(
    message: CMsgSignOutCommunicationSummary_PlayerCommunication,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.accountId !== undefined && message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    if (message.pings !== undefined && message.pings !== 0) {
      writer.uint32(16).uint32(message.pings);
    }
    if (message.maxPingsPerInterval !== undefined && message.maxPingsPerInterval !== 0) {
      writer.uint32(24).uint32(message.maxPingsPerInterval);
    }
    if (message.teammatePings !== undefined && message.teammatePings !== 0) {
      writer.uint32(32).uint32(message.teammatePings);
    }
    if (message.maxTeammatePingsPerInterval !== undefined && message.maxTeammatePingsPerInterval !== 0) {
      writer.uint32(40).uint32(message.maxTeammatePingsPerInterval);
    }
    if (message.teamChatMessages !== undefined && message.teamChatMessages !== 0) {
      writer.uint32(48).uint32(message.teamChatMessages);
    }
    if (message.allChatMessages !== undefined && message.allChatMessages !== 0) {
      writer.uint32(56).uint32(message.allChatMessages);
    }
    if (message.chatWheelMessages !== undefined && message.chatWheelMessages !== 0) {
      writer.uint32(64).uint32(message.chatWheelMessages);
    }
    if (message.pauses !== undefined && message.pauses !== 0) {
      writer.uint32(72).uint32(message.pauses);
    }
    if (message.unpauses !== undefined && message.unpauses !== 0) {
      writer.uint32(80).uint32(message.unpauses);
    }
    if (message.linesDrawn !== undefined && message.linesDrawn !== 0) {
      writer.uint32(88).uint32(message.linesDrawn);
    }
    if (message.voiceChatSeconds !== undefined && message.voiceChatSeconds !== 0) {
      writer.uint32(96).uint32(message.voiceChatSeconds);
    }
    if (message.chatMutes !== undefined && message.chatMutes !== 0) {
      writer.uint32(104).uint32(message.chatMutes);
    }
    if (message.voiceMutes !== undefined && message.voiceMutes !== 0) {
      writer.uint32(112).uint32(message.voiceMutes);
    }
    for (const v of message.pingDetails) {
      CMsgSignOutCommunicationSummary_PlayerCommunication_PingDetail.encode(v!, writer.uint32(122).fork()).ldelim();
    }
    if (message.commsBlocksSolo !== undefined && message.commsBlocksSolo !== 0) {
      writer.uint32(128).uint32(message.commsBlocksSolo);
    }
    if (message.commsBlocksMass !== undefined && message.commsBlocksMass !== 0) {
      writer.uint32(136).uint32(message.commsBlocksMass);
    }
    for (const v of message.chatLog) {
      writer.uint32(146).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSignOutCommunicationSummary_PlayerCommunication {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSignOutCommunicationSummary_PlayerCommunication();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pings = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.maxPingsPerInterval = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.teammatePings = reader.uint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.maxTeammatePingsPerInterval = reader.uint32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.teamChatMessages = reader.uint32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.allChatMessages = reader.uint32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.chatWheelMessages = reader.uint32();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.pauses = reader.uint32();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.unpauses = reader.uint32();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.linesDrawn = reader.uint32();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.voiceChatSeconds = reader.uint32();
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.chatMutes = reader.uint32();
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.voiceMutes = reader.uint32();
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.pingDetails.push(
            CMsgSignOutCommunicationSummary_PlayerCommunication_PingDetail.decode(reader, reader.uint32()),
          );
          continue;
        case 16:
          if (tag !== 128) {
            break;
          }

          message.commsBlocksSolo = reader.uint32();
          continue;
        case 17:
          if (tag !== 136) {
            break;
          }

          message.commsBlocksMass = reader.uint32();
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.chatLog.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSignOutCommunicationSummary_PlayerCommunication {
    return {
      accountId: isSet(object.accountId) ? globalThis.Number(object.accountId) : 0,
      pings: isSet(object.pings) ? globalThis.Number(object.pings) : 0,
      maxPingsPerInterval: isSet(object.maxPingsPerInterval) ? globalThis.Number(object.maxPingsPerInterval) : 0,
      teammatePings: isSet(object.teammatePings) ? globalThis.Number(object.teammatePings) : 0,
      maxTeammatePingsPerInterval: isSet(object.maxTeammatePingsPerInterval)
        ? globalThis.Number(object.maxTeammatePingsPerInterval)
        : 0,
      teamChatMessages: isSet(object.teamChatMessages) ? globalThis.Number(object.teamChatMessages) : 0,
      allChatMessages: isSet(object.allChatMessages) ? globalThis.Number(object.allChatMessages) : 0,
      chatWheelMessages: isSet(object.chatWheelMessages) ? globalThis.Number(object.chatWheelMessages) : 0,
      pauses: isSet(object.pauses) ? globalThis.Number(object.pauses) : 0,
      unpauses: isSet(object.unpauses) ? globalThis.Number(object.unpauses) : 0,
      linesDrawn: isSet(object.linesDrawn) ? globalThis.Number(object.linesDrawn) : 0,
      voiceChatSeconds: isSet(object.voiceChatSeconds) ? globalThis.Number(object.voiceChatSeconds) : 0,
      chatMutes: isSet(object.chatMutes) ? globalThis.Number(object.chatMutes) : 0,
      voiceMutes: isSet(object.voiceMutes) ? globalThis.Number(object.voiceMutes) : 0,
      pingDetails: globalThis.Array.isArray(object?.pingDetails)
        ? object.pingDetails.map((e: any) => CMsgSignOutCommunicationSummary_PlayerCommunication_PingDetail.fromJSON(e))
        : [],
      commsBlocksSolo: isSet(object.commsBlocksSolo) ? globalThis.Number(object.commsBlocksSolo) : 0,
      commsBlocksMass: isSet(object.commsBlocksMass) ? globalThis.Number(object.commsBlocksMass) : 0,
      chatLog: globalThis.Array.isArray(object?.chatLog) ? object.chatLog.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: CMsgSignOutCommunicationSummary_PlayerCommunication): unknown {
    const obj: any = {};
    if (message.accountId !== undefined && message.accountId !== 0) {
      obj.accountId = Math.round(message.accountId);
    }
    if (message.pings !== undefined && message.pings !== 0) {
      obj.pings = Math.round(message.pings);
    }
    if (message.maxPingsPerInterval !== undefined && message.maxPingsPerInterval !== 0) {
      obj.maxPingsPerInterval = Math.round(message.maxPingsPerInterval);
    }
    if (message.teammatePings !== undefined && message.teammatePings !== 0) {
      obj.teammatePings = Math.round(message.teammatePings);
    }
    if (message.maxTeammatePingsPerInterval !== undefined && message.maxTeammatePingsPerInterval !== 0) {
      obj.maxTeammatePingsPerInterval = Math.round(message.maxTeammatePingsPerInterval);
    }
    if (message.teamChatMessages !== undefined && message.teamChatMessages !== 0) {
      obj.teamChatMessages = Math.round(message.teamChatMessages);
    }
    if (message.allChatMessages !== undefined && message.allChatMessages !== 0) {
      obj.allChatMessages = Math.round(message.allChatMessages);
    }
    if (message.chatWheelMessages !== undefined && message.chatWheelMessages !== 0) {
      obj.chatWheelMessages = Math.round(message.chatWheelMessages);
    }
    if (message.pauses !== undefined && message.pauses !== 0) {
      obj.pauses = Math.round(message.pauses);
    }
    if (message.unpauses !== undefined && message.unpauses !== 0) {
      obj.unpauses = Math.round(message.unpauses);
    }
    if (message.linesDrawn !== undefined && message.linesDrawn !== 0) {
      obj.linesDrawn = Math.round(message.linesDrawn);
    }
    if (message.voiceChatSeconds !== undefined && message.voiceChatSeconds !== 0) {
      obj.voiceChatSeconds = Math.round(message.voiceChatSeconds);
    }
    if (message.chatMutes !== undefined && message.chatMutes !== 0) {
      obj.chatMutes = Math.round(message.chatMutes);
    }
    if (message.voiceMutes !== undefined && message.voiceMutes !== 0) {
      obj.voiceMutes = Math.round(message.voiceMutes);
    }
    if (message.pingDetails?.length) {
      obj.pingDetails = message.pingDetails.map((e) =>
        CMsgSignOutCommunicationSummary_PlayerCommunication_PingDetail.toJSON(e)
      );
    }
    if (message.commsBlocksSolo !== undefined && message.commsBlocksSolo !== 0) {
      obj.commsBlocksSolo = Math.round(message.commsBlocksSolo);
    }
    if (message.commsBlocksMass !== undefined && message.commsBlocksMass !== 0) {
      obj.commsBlocksMass = Math.round(message.commsBlocksMass);
    }
    if (message.chatLog?.length) {
      obj.chatLog = message.chatLog;
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgSignOutCommunicationSummary_PlayerCommunication>,
  ): CMsgSignOutCommunicationSummary_PlayerCommunication {
    return CMsgSignOutCommunicationSummary_PlayerCommunication.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgSignOutCommunicationSummary_PlayerCommunication>,
  ): CMsgSignOutCommunicationSummary_PlayerCommunication {
    const message = createBaseCMsgSignOutCommunicationSummary_PlayerCommunication();
    message.accountId = object.accountId ?? 0;
    message.pings = object.pings ?? 0;
    message.maxPingsPerInterval = object.maxPingsPerInterval ?? 0;
    message.teammatePings = object.teammatePings ?? 0;
    message.maxTeammatePingsPerInterval = object.maxTeammatePingsPerInterval ?? 0;
    message.teamChatMessages = object.teamChatMessages ?? 0;
    message.allChatMessages = object.allChatMessages ?? 0;
    message.chatWheelMessages = object.chatWheelMessages ?? 0;
    message.pauses = object.pauses ?? 0;
    message.unpauses = object.unpauses ?? 0;
    message.linesDrawn = object.linesDrawn ?? 0;
    message.voiceChatSeconds = object.voiceChatSeconds ?? 0;
    message.chatMutes = object.chatMutes ?? 0;
    message.voiceMutes = object.voiceMutes ?? 0;
    message.pingDetails =
      object.pingDetails?.map((e) => CMsgSignOutCommunicationSummary_PlayerCommunication_PingDetail.fromPartial(e)) ||
      [];
    message.commsBlocksSolo = object.commsBlocksSolo ?? 0;
    message.commsBlocksMass = object.commsBlocksMass ?? 0;
    message.chatLog = object.chatLog?.map((e) => e) || [];
    return message;
  },
};

function createBaseCMsgSignOutCommunicationSummary_PlayerCommunication_PingDetail(): CMsgSignOutCommunicationSummary_PlayerCommunication_PingDetail {
  return { type: 4294967295, count: 0 };
}

export const CMsgSignOutCommunicationSummary_PlayerCommunication_PingDetail = {
  encode(
    message: CMsgSignOutCommunicationSummary_PlayerCommunication_PingDetail,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.type !== undefined && message.type !== 4294967295) {
      writer.uint32(8).uint32(message.type);
    }
    if (message.count !== undefined && message.count !== 0) {
      writer.uint32(16).uint32(message.count);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): CMsgSignOutCommunicationSummary_PlayerCommunication_PingDetail {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSignOutCommunicationSummary_PlayerCommunication_PingDetail();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.count = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSignOutCommunicationSummary_PlayerCommunication_PingDetail {
    return {
      type: isSet(object.type) ? globalThis.Number(object.type) : 4294967295,
      count: isSet(object.count) ? globalThis.Number(object.count) : 0,
    };
  },

  toJSON(message: CMsgSignOutCommunicationSummary_PlayerCommunication_PingDetail): unknown {
    const obj: any = {};
    if (message.type !== undefined && message.type !== 4294967295) {
      obj.type = Math.round(message.type);
    }
    if (message.count !== undefined && message.count !== 0) {
      obj.count = Math.round(message.count);
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgSignOutCommunicationSummary_PlayerCommunication_PingDetail>,
  ): CMsgSignOutCommunicationSummary_PlayerCommunication_PingDetail {
    return CMsgSignOutCommunicationSummary_PlayerCommunication_PingDetail.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgSignOutCommunicationSummary_PlayerCommunication_PingDetail>,
  ): CMsgSignOutCommunicationSummary_PlayerCommunication_PingDetail {
    const message = createBaseCMsgSignOutCommunicationSummary_PlayerCommunication_PingDetail();
    message.type = object.type ?? 4294967295;
    message.count = object.count ?? 0;
    return message;
  },
};

function createBaseCMsgGameMatchSignoutResponse(): CMsgGameMatchSignoutResponse {
  return {
    matchId: "0",
    replaySalt: 0,
    leagueid: 0,
    metadataPrivateKey: 0,
    matchDetails: undefined,
    playersMetadata: [],
    mvpData: undefined,
    owPrivateKey: "0",
    owSalt: 0,
    owReplayId: "0",
    overworldRewards: undefined,
  };
}

export const CMsgGameMatchSignoutResponse = {
  encode(message: CMsgGameMatchSignoutResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.matchId !== undefined && message.matchId !== "0") {
      writer.uint32(8).uint64(message.matchId);
    }
    if (message.replaySalt !== undefined && message.replaySalt !== 0) {
      writer.uint32(21).fixed32(message.replaySalt);
    }
    if (message.leagueid !== undefined && message.leagueid !== 0) {
      writer.uint32(40).uint32(message.leagueid);
    }
    if (message.metadataPrivateKey !== undefined && message.metadataPrivateKey !== 0) {
      writer.uint32(61).fixed32(message.metadataPrivateKey);
    }
    if (message.matchDetails !== undefined) {
      CMsgDOTAMatch.encode(message.matchDetails, writer.uint32(66).fork()).ldelim();
    }
    for (const v of message.playersMetadata) {
      CMsgGameMatchSignoutResponse_PlayerMetadata.encode(v!, writer.uint32(74).fork()).ldelim();
    }
    if (message.mvpData !== undefined) {
      CMvpData.encode(message.mvpData, writer.uint32(82).fork()).ldelim();
    }
    if (message.owPrivateKey !== undefined && message.owPrivateKey !== "0") {
      writer.uint32(89).fixed64(message.owPrivateKey);
    }
    if (message.owSalt !== undefined && message.owSalt !== 0) {
      writer.uint32(101).fixed32(message.owSalt);
    }
    if (message.owReplayId !== undefined && message.owReplayId !== "0") {
      writer.uint32(104).uint64(message.owReplayId);
    }
    if (message.overworldRewards !== undefined) {
      CMsgOverworldMatchRewards.encode(message.overworldRewards, writer.uint32(114).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGameMatchSignoutResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGameMatchSignoutResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.matchId = longToString(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.replaySalt = reader.fixed32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.leagueid = reader.uint32();
          continue;
        case 7:
          if (tag !== 61) {
            break;
          }

          message.metadataPrivateKey = reader.fixed32();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.matchDetails = CMsgDOTAMatch.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.playersMetadata.push(CMsgGameMatchSignoutResponse_PlayerMetadata.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.mvpData = CMvpData.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 89) {
            break;
          }

          message.owPrivateKey = longToString(reader.fixed64() as Long);
          continue;
        case 12:
          if (tag !== 101) {
            break;
          }

          message.owSalt = reader.fixed32();
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.owReplayId = longToString(reader.uint64() as Long);
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.overworldRewards = CMsgOverworldMatchRewards.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGameMatchSignoutResponse {
    return {
      matchId: isSet(object.matchId) ? globalThis.String(object.matchId) : "0",
      replaySalt: isSet(object.replaySalt) ? globalThis.Number(object.replaySalt) : 0,
      leagueid: isSet(object.leagueid) ? globalThis.Number(object.leagueid) : 0,
      metadataPrivateKey: isSet(object.metadataPrivateKey) ? globalThis.Number(object.metadataPrivateKey) : 0,
      matchDetails: isSet(object.matchDetails) ? CMsgDOTAMatch.fromJSON(object.matchDetails) : undefined,
      playersMetadata: globalThis.Array.isArray(object?.playersMetadata)
        ? object.playersMetadata.map((e: any) => CMsgGameMatchSignoutResponse_PlayerMetadata.fromJSON(e))
        : [],
      mvpData: isSet(object.mvpData) ? CMvpData.fromJSON(object.mvpData) : undefined,
      owPrivateKey: isSet(object.owPrivateKey) ? globalThis.String(object.owPrivateKey) : "0",
      owSalt: isSet(object.owSalt) ? globalThis.Number(object.owSalt) : 0,
      owReplayId: isSet(object.owReplayId) ? globalThis.String(object.owReplayId) : "0",
      overworldRewards: isSet(object.overworldRewards)
        ? CMsgOverworldMatchRewards.fromJSON(object.overworldRewards)
        : undefined,
    };
  },

  toJSON(message: CMsgGameMatchSignoutResponse): unknown {
    const obj: any = {};
    if (message.matchId !== undefined && message.matchId !== "0") {
      obj.matchId = message.matchId;
    }
    if (message.replaySalt !== undefined && message.replaySalt !== 0) {
      obj.replaySalt = Math.round(message.replaySalt);
    }
    if (message.leagueid !== undefined && message.leagueid !== 0) {
      obj.leagueid = Math.round(message.leagueid);
    }
    if (message.metadataPrivateKey !== undefined && message.metadataPrivateKey !== 0) {
      obj.metadataPrivateKey = Math.round(message.metadataPrivateKey);
    }
    if (message.matchDetails !== undefined) {
      obj.matchDetails = CMsgDOTAMatch.toJSON(message.matchDetails);
    }
    if (message.playersMetadata?.length) {
      obj.playersMetadata = message.playersMetadata.map((e) => CMsgGameMatchSignoutResponse_PlayerMetadata.toJSON(e));
    }
    if (message.mvpData !== undefined) {
      obj.mvpData = CMvpData.toJSON(message.mvpData);
    }
    if (message.owPrivateKey !== undefined && message.owPrivateKey !== "0") {
      obj.owPrivateKey = message.owPrivateKey;
    }
    if (message.owSalt !== undefined && message.owSalt !== 0) {
      obj.owSalt = Math.round(message.owSalt);
    }
    if (message.owReplayId !== undefined && message.owReplayId !== "0") {
      obj.owReplayId = message.owReplayId;
    }
    if (message.overworldRewards !== undefined) {
      obj.overworldRewards = CMsgOverworldMatchRewards.toJSON(message.overworldRewards);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGameMatchSignoutResponse>): CMsgGameMatchSignoutResponse {
    return CMsgGameMatchSignoutResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGameMatchSignoutResponse>): CMsgGameMatchSignoutResponse {
    const message = createBaseCMsgGameMatchSignoutResponse();
    message.matchId = object.matchId ?? "0";
    message.replaySalt = object.replaySalt ?? 0;
    message.leagueid = object.leagueid ?? 0;
    message.metadataPrivateKey = object.metadataPrivateKey ?? 0;
    message.matchDetails = (object.matchDetails !== undefined && object.matchDetails !== null)
      ? CMsgDOTAMatch.fromPartial(object.matchDetails)
      : undefined;
    message.playersMetadata =
      object.playersMetadata?.map((e) => CMsgGameMatchSignoutResponse_PlayerMetadata.fromPartial(e)) || [];
    message.mvpData = (object.mvpData !== undefined && object.mvpData !== null)
      ? CMvpData.fromPartial(object.mvpData)
      : undefined;
    message.owPrivateKey = object.owPrivateKey ?? "0";
    message.owSalt = object.owSalt ?? 0;
    message.owReplayId = object.owReplayId ?? "0";
    message.overworldRewards = (object.overworldRewards !== undefined && object.overworldRewards !== null)
      ? CMsgOverworldMatchRewards.fromPartial(object.overworldRewards)
      : undefined;
    return message;
  },
};

function createBaseCMsgGameMatchSignoutResponse_PlayerMetadata(): CMsgGameMatchSignoutResponse_PlayerMetadata {
  return {
    heroId: 0,
    avgKillsX16: 0,
    avgDeathsX16: 0,
    avgAssistsX16: 0,
    avgGpmX16: 0,
    avgXpmX16: 0,
    bestKillsX16: 0,
    bestAssistsX16: 0,
    bestGpmX16: 0,
    bestXpmX16: 0,
    winStreak: 0,
    bestWinStreak: 0,
    gamesPlayed: 0,
  };
}

export const CMsgGameMatchSignoutResponse_PlayerMetadata = {
  encode(message: CMsgGameMatchSignoutResponse_PlayerMetadata, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.heroId !== undefined && message.heroId !== 0) {
      writer.uint32(8).int32(message.heroId);
    }
    if (message.avgKillsX16 !== undefined && message.avgKillsX16 !== 0) {
      writer.uint32(16).uint32(message.avgKillsX16);
    }
    if (message.avgDeathsX16 !== undefined && message.avgDeathsX16 !== 0) {
      writer.uint32(24).uint32(message.avgDeathsX16);
    }
    if (message.avgAssistsX16 !== undefined && message.avgAssistsX16 !== 0) {
      writer.uint32(32).uint32(message.avgAssistsX16);
    }
    if (message.avgGpmX16 !== undefined && message.avgGpmX16 !== 0) {
      writer.uint32(40).uint32(message.avgGpmX16);
    }
    if (message.avgXpmX16 !== undefined && message.avgXpmX16 !== 0) {
      writer.uint32(48).uint32(message.avgXpmX16);
    }
    if (message.bestKillsX16 !== undefined && message.bestKillsX16 !== 0) {
      writer.uint32(56).uint32(message.bestKillsX16);
    }
    if (message.bestAssistsX16 !== undefined && message.bestAssistsX16 !== 0) {
      writer.uint32(64).uint32(message.bestAssistsX16);
    }
    if (message.bestGpmX16 !== undefined && message.bestGpmX16 !== 0) {
      writer.uint32(72).uint32(message.bestGpmX16);
    }
    if (message.bestXpmX16 !== undefined && message.bestXpmX16 !== 0) {
      writer.uint32(80).uint32(message.bestXpmX16);
    }
    if (message.winStreak !== undefined && message.winStreak !== 0) {
      writer.uint32(88).uint32(message.winStreak);
    }
    if (message.bestWinStreak !== undefined && message.bestWinStreak !== 0) {
      writer.uint32(96).uint32(message.bestWinStreak);
    }
    if (message.gamesPlayed !== undefined && message.gamesPlayed !== 0) {
      writer.uint32(104).uint32(message.gamesPlayed);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGameMatchSignoutResponse_PlayerMetadata {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGameMatchSignoutResponse_PlayerMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.heroId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.avgKillsX16 = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.avgDeathsX16 = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.avgAssistsX16 = reader.uint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.avgGpmX16 = reader.uint32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.avgXpmX16 = reader.uint32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.bestKillsX16 = reader.uint32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.bestAssistsX16 = reader.uint32();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.bestGpmX16 = reader.uint32();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.bestXpmX16 = reader.uint32();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.winStreak = reader.uint32();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.bestWinStreak = reader.uint32();
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.gamesPlayed = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGameMatchSignoutResponse_PlayerMetadata {
    return {
      heroId: isSet(object.heroId) ? globalThis.Number(object.heroId) : 0,
      avgKillsX16: isSet(object.avgKillsX16) ? globalThis.Number(object.avgKillsX16) : 0,
      avgDeathsX16: isSet(object.avgDeathsX16) ? globalThis.Number(object.avgDeathsX16) : 0,
      avgAssistsX16: isSet(object.avgAssistsX16) ? globalThis.Number(object.avgAssistsX16) : 0,
      avgGpmX16: isSet(object.avgGpmX16) ? globalThis.Number(object.avgGpmX16) : 0,
      avgXpmX16: isSet(object.avgXpmX16) ? globalThis.Number(object.avgXpmX16) : 0,
      bestKillsX16: isSet(object.bestKillsX16) ? globalThis.Number(object.bestKillsX16) : 0,
      bestAssistsX16: isSet(object.bestAssistsX16) ? globalThis.Number(object.bestAssistsX16) : 0,
      bestGpmX16: isSet(object.bestGpmX16) ? globalThis.Number(object.bestGpmX16) : 0,
      bestXpmX16: isSet(object.bestXpmX16) ? globalThis.Number(object.bestXpmX16) : 0,
      winStreak: isSet(object.winStreak) ? globalThis.Number(object.winStreak) : 0,
      bestWinStreak: isSet(object.bestWinStreak) ? globalThis.Number(object.bestWinStreak) : 0,
      gamesPlayed: isSet(object.gamesPlayed) ? globalThis.Number(object.gamesPlayed) : 0,
    };
  },

  toJSON(message: CMsgGameMatchSignoutResponse_PlayerMetadata): unknown {
    const obj: any = {};
    if (message.heroId !== undefined && message.heroId !== 0) {
      obj.heroId = Math.round(message.heroId);
    }
    if (message.avgKillsX16 !== undefined && message.avgKillsX16 !== 0) {
      obj.avgKillsX16 = Math.round(message.avgKillsX16);
    }
    if (message.avgDeathsX16 !== undefined && message.avgDeathsX16 !== 0) {
      obj.avgDeathsX16 = Math.round(message.avgDeathsX16);
    }
    if (message.avgAssistsX16 !== undefined && message.avgAssistsX16 !== 0) {
      obj.avgAssistsX16 = Math.round(message.avgAssistsX16);
    }
    if (message.avgGpmX16 !== undefined && message.avgGpmX16 !== 0) {
      obj.avgGpmX16 = Math.round(message.avgGpmX16);
    }
    if (message.avgXpmX16 !== undefined && message.avgXpmX16 !== 0) {
      obj.avgXpmX16 = Math.round(message.avgXpmX16);
    }
    if (message.bestKillsX16 !== undefined && message.bestKillsX16 !== 0) {
      obj.bestKillsX16 = Math.round(message.bestKillsX16);
    }
    if (message.bestAssistsX16 !== undefined && message.bestAssistsX16 !== 0) {
      obj.bestAssistsX16 = Math.round(message.bestAssistsX16);
    }
    if (message.bestGpmX16 !== undefined && message.bestGpmX16 !== 0) {
      obj.bestGpmX16 = Math.round(message.bestGpmX16);
    }
    if (message.bestXpmX16 !== undefined && message.bestXpmX16 !== 0) {
      obj.bestXpmX16 = Math.round(message.bestXpmX16);
    }
    if (message.winStreak !== undefined && message.winStreak !== 0) {
      obj.winStreak = Math.round(message.winStreak);
    }
    if (message.bestWinStreak !== undefined && message.bestWinStreak !== 0) {
      obj.bestWinStreak = Math.round(message.bestWinStreak);
    }
    if (message.gamesPlayed !== undefined && message.gamesPlayed !== 0) {
      obj.gamesPlayed = Math.round(message.gamesPlayed);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGameMatchSignoutResponse_PlayerMetadata>): CMsgGameMatchSignoutResponse_PlayerMetadata {
    return CMsgGameMatchSignoutResponse_PlayerMetadata.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgGameMatchSignoutResponse_PlayerMetadata>,
  ): CMsgGameMatchSignoutResponse_PlayerMetadata {
    const message = createBaseCMsgGameMatchSignoutResponse_PlayerMetadata();
    message.heroId = object.heroId ?? 0;
    message.avgKillsX16 = object.avgKillsX16 ?? 0;
    message.avgDeathsX16 = object.avgDeathsX16 ?? 0;
    message.avgAssistsX16 = object.avgAssistsX16 ?? 0;
    message.avgGpmX16 = object.avgGpmX16 ?? 0;
    message.avgXpmX16 = object.avgXpmX16 ?? 0;
    message.bestKillsX16 = object.bestKillsX16 ?? 0;
    message.bestAssistsX16 = object.bestAssistsX16 ?? 0;
    message.bestGpmX16 = object.bestGpmX16 ?? 0;
    message.bestXpmX16 = object.bestXpmX16 ?? 0;
    message.winStreak = object.winStreak ?? 0;
    message.bestWinStreak = object.bestWinStreak ?? 0;
    message.gamesPlayed = object.gamesPlayed ?? 0;
    return message;
  },
};

function createBaseCMsgGameMatchSignOutPermissionRequest(): CMsgGameMatchSignOutPermissionRequest {
  return { serverVersion: 0, localAttempt: 0, totalAttempt: 0, secondsWaited: 0 };
}

export const CMsgGameMatchSignOutPermissionRequest = {
  encode(message: CMsgGameMatchSignOutPermissionRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.serverVersion !== undefined && message.serverVersion !== 0) {
      writer.uint32(8).uint32(message.serverVersion);
    }
    if (message.localAttempt !== undefined && message.localAttempt !== 0) {
      writer.uint32(16).uint32(message.localAttempt);
    }
    if (message.totalAttempt !== undefined && message.totalAttempt !== 0) {
      writer.uint32(24).uint32(message.totalAttempt);
    }
    if (message.secondsWaited !== undefined && message.secondsWaited !== 0) {
      writer.uint32(32).uint32(message.secondsWaited);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGameMatchSignOutPermissionRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGameMatchSignOutPermissionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.serverVersion = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.localAttempt = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.totalAttempt = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.secondsWaited = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGameMatchSignOutPermissionRequest {
    return {
      serverVersion: isSet(object.serverVersion) ? globalThis.Number(object.serverVersion) : 0,
      localAttempt: isSet(object.localAttempt) ? globalThis.Number(object.localAttempt) : 0,
      totalAttempt: isSet(object.totalAttempt) ? globalThis.Number(object.totalAttempt) : 0,
      secondsWaited: isSet(object.secondsWaited) ? globalThis.Number(object.secondsWaited) : 0,
    };
  },

  toJSON(message: CMsgGameMatchSignOutPermissionRequest): unknown {
    const obj: any = {};
    if (message.serverVersion !== undefined && message.serverVersion !== 0) {
      obj.serverVersion = Math.round(message.serverVersion);
    }
    if (message.localAttempt !== undefined && message.localAttempt !== 0) {
      obj.localAttempt = Math.round(message.localAttempt);
    }
    if (message.totalAttempt !== undefined && message.totalAttempt !== 0) {
      obj.totalAttempt = Math.round(message.totalAttempt);
    }
    if (message.secondsWaited !== undefined && message.secondsWaited !== 0) {
      obj.secondsWaited = Math.round(message.secondsWaited);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGameMatchSignOutPermissionRequest>): CMsgGameMatchSignOutPermissionRequest {
    return CMsgGameMatchSignOutPermissionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGameMatchSignOutPermissionRequest>): CMsgGameMatchSignOutPermissionRequest {
    const message = createBaseCMsgGameMatchSignOutPermissionRequest();
    message.serverVersion = object.serverVersion ?? 0;
    message.localAttempt = object.localAttempt ?? 0;
    message.totalAttempt = object.totalAttempt ?? 0;
    message.secondsWaited = object.secondsWaited ?? 0;
    return message;
  },
};

function createBaseCMsgGameMatchSignOutPermissionResponse(): CMsgGameMatchSignOutPermissionResponse {
  return { permissionGranted: false, abandonSignout: false, retryDelaySeconds: 0 };
}

export const CMsgGameMatchSignOutPermissionResponse = {
  encode(message: CMsgGameMatchSignOutPermissionResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.permissionGranted !== undefined && message.permissionGranted !== false) {
      writer.uint32(8).bool(message.permissionGranted);
    }
    if (message.abandonSignout !== undefined && message.abandonSignout !== false) {
      writer.uint32(16).bool(message.abandonSignout);
    }
    if (message.retryDelaySeconds !== undefined && message.retryDelaySeconds !== 0) {
      writer.uint32(24).uint32(message.retryDelaySeconds);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGameMatchSignOutPermissionResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGameMatchSignOutPermissionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.permissionGranted = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.abandonSignout = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.retryDelaySeconds = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGameMatchSignOutPermissionResponse {
    return {
      permissionGranted: isSet(object.permissionGranted) ? globalThis.Boolean(object.permissionGranted) : false,
      abandonSignout: isSet(object.abandonSignout) ? globalThis.Boolean(object.abandonSignout) : false,
      retryDelaySeconds: isSet(object.retryDelaySeconds) ? globalThis.Number(object.retryDelaySeconds) : 0,
    };
  },

  toJSON(message: CMsgGameMatchSignOutPermissionResponse): unknown {
    const obj: any = {};
    if (message.permissionGranted !== undefined && message.permissionGranted !== false) {
      obj.permissionGranted = message.permissionGranted;
    }
    if (message.abandonSignout !== undefined && message.abandonSignout !== false) {
      obj.abandonSignout = message.abandonSignout;
    }
    if (message.retryDelaySeconds !== undefined && message.retryDelaySeconds !== 0) {
      obj.retryDelaySeconds = Math.round(message.retryDelaySeconds);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGameMatchSignOutPermissionResponse>): CMsgGameMatchSignOutPermissionResponse {
    return CMsgGameMatchSignOutPermissionResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGameMatchSignOutPermissionResponse>): CMsgGameMatchSignOutPermissionResponse {
    const message = createBaseCMsgGameMatchSignOutPermissionResponse();
    message.permissionGranted = object.permissionGranted ?? false;
    message.abandonSignout = object.abandonSignout ?? false;
    message.retryDelaySeconds = object.retryDelaySeconds ?? 0;
    return message;
  },
};

function createBaseCMsgGameMatchSignOutEventGameData(): CMsgGameMatchSignOutEventGameData {
  return { eventId: 0, gameName: "", mapName: "", eventGameData: Buffer.alloc(0), startTime: 0 };
}

export const CMsgGameMatchSignOutEventGameData = {
  encode(message: CMsgGameMatchSignOutEventGameData, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.eventId !== undefined && message.eventId !== 0) {
      writer.uint32(8).int32(message.eventId);
    }
    if (message.gameName !== undefined && message.gameName !== "") {
      writer.uint32(18).string(message.gameName);
    }
    if (message.mapName !== undefined && message.mapName !== "") {
      writer.uint32(26).string(message.mapName);
    }
    if (message.eventGameData !== undefined && message.eventGameData.length !== 0) {
      writer.uint32(34).bytes(message.eventGameData);
    }
    if (message.startTime !== undefined && message.startTime !== 0) {
      writer.uint32(40).uint32(message.startTime);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGameMatchSignOutEventGameData {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGameMatchSignOutEventGameData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.eventId = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.gameName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.mapName = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.eventGameData = reader.bytes() as Buffer;
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.startTime = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGameMatchSignOutEventGameData {
    return {
      eventId: isSet(object.eventId) ? eEventFromJSON(object.eventId) : 0,
      gameName: isSet(object.gameName) ? globalThis.String(object.gameName) : "",
      mapName: isSet(object.mapName) ? globalThis.String(object.mapName) : "",
      eventGameData: isSet(object.eventGameData) ? Buffer.from(bytesFromBase64(object.eventGameData)) : Buffer.alloc(0),
      startTime: isSet(object.startTime) ? globalThis.Number(object.startTime) : 0,
    };
  },

  toJSON(message: CMsgGameMatchSignOutEventGameData): unknown {
    const obj: any = {};
    if (message.eventId !== undefined && message.eventId !== 0) {
      obj.eventId = eEventToJSON(message.eventId);
    }
    if (message.gameName !== undefined && message.gameName !== "") {
      obj.gameName = message.gameName;
    }
    if (message.mapName !== undefined && message.mapName !== "") {
      obj.mapName = message.mapName;
    }
    if (message.eventGameData !== undefined && message.eventGameData.length !== 0) {
      obj.eventGameData = base64FromBytes(message.eventGameData);
    }
    if (message.startTime !== undefined && message.startTime !== 0) {
      obj.startTime = Math.round(message.startTime);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGameMatchSignOutEventGameData>): CMsgGameMatchSignOutEventGameData {
    return CMsgGameMatchSignOutEventGameData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGameMatchSignOutEventGameData>): CMsgGameMatchSignOutEventGameData {
    const message = createBaseCMsgGameMatchSignOutEventGameData();
    message.eventId = object.eventId ?? 0;
    message.gameName = object.gameName ?? "";
    message.mapName = object.mapName ?? "";
    message.eventGameData = object.eventGameData ?? Buffer.alloc(0);
    message.startTime = object.startTime ?? 0;
    return message;
  },
};

function createBaseCMsgGameMatchSignOutPerfData(): CMsgGameMatchSignOutPerfData {
  return {
    averageFrameTime: [],
    maxFrameTime: [],
    serverAverageFrameTime: 0,
    serverMaxFrameTime: 0,
    averageComputeTime: [],
    maxComputeTime: [],
    averageClientTickTime: [],
    maxClientTickTime: [],
    averageClientSimulateTime: [],
    maxClientSimulateTime: [],
    averageOutputTime: [],
    maxOutputTime: [],
    averageWaitForRenderingToCompleteTime: [],
    maxWaitForRenderingToCompleteTime: [],
    averageSwapTime: [],
    maxSwapTime: [],
    averageFrameUpdateTime: [],
    maxFrameUpdateTime: [],
    averageIdleTime: [],
    maxIdleTime: [],
    averageInputProcessingTime: [],
    maxInputProcessingTime: [],
  };
}

export const CMsgGameMatchSignOutPerfData = {
  encode(message: CMsgGameMatchSignOutPerfData, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.averageFrameTime) {
      writer.float(v);
    }
    writer.ldelim();
    writer.uint32(18).fork();
    for (const v of message.maxFrameTime) {
      writer.float(v);
    }
    writer.ldelim();
    if (message.serverAverageFrameTime !== undefined && message.serverAverageFrameTime !== 0) {
      writer.uint32(29).float(message.serverAverageFrameTime);
    }
    if (message.serverMaxFrameTime !== undefined && message.serverMaxFrameTime !== 0) {
      writer.uint32(37).float(message.serverMaxFrameTime);
    }
    writer.uint32(42).fork();
    for (const v of message.averageComputeTime) {
      writer.float(v);
    }
    writer.ldelim();
    writer.uint32(50).fork();
    for (const v of message.maxComputeTime) {
      writer.float(v);
    }
    writer.ldelim();
    writer.uint32(58).fork();
    for (const v of message.averageClientTickTime) {
      writer.float(v);
    }
    writer.ldelim();
    writer.uint32(66).fork();
    for (const v of message.maxClientTickTime) {
      writer.float(v);
    }
    writer.ldelim();
    writer.uint32(74).fork();
    for (const v of message.averageClientSimulateTime) {
      writer.float(v);
    }
    writer.ldelim();
    writer.uint32(82).fork();
    for (const v of message.maxClientSimulateTime) {
      writer.float(v);
    }
    writer.ldelim();
    writer.uint32(90).fork();
    for (const v of message.averageOutputTime) {
      writer.float(v);
    }
    writer.ldelim();
    writer.uint32(98).fork();
    for (const v of message.maxOutputTime) {
      writer.float(v);
    }
    writer.ldelim();
    writer.uint32(106).fork();
    for (const v of message.averageWaitForRenderingToCompleteTime) {
      writer.float(v);
    }
    writer.ldelim();
    writer.uint32(114).fork();
    for (const v of message.maxWaitForRenderingToCompleteTime) {
      writer.float(v);
    }
    writer.ldelim();
    writer.uint32(122).fork();
    for (const v of message.averageSwapTime) {
      writer.float(v);
    }
    writer.ldelim();
    writer.uint32(130).fork();
    for (const v of message.maxSwapTime) {
      writer.float(v);
    }
    writer.ldelim();
    writer.uint32(138).fork();
    for (const v of message.averageFrameUpdateTime) {
      writer.float(v);
    }
    writer.ldelim();
    writer.uint32(146).fork();
    for (const v of message.maxFrameUpdateTime) {
      writer.float(v);
    }
    writer.ldelim();
    writer.uint32(154).fork();
    for (const v of message.averageIdleTime) {
      writer.float(v);
    }
    writer.ldelim();
    writer.uint32(162).fork();
    for (const v of message.maxIdleTime) {
      writer.float(v);
    }
    writer.ldelim();
    writer.uint32(170).fork();
    for (const v of message.averageInputProcessingTime) {
      writer.float(v);
    }
    writer.ldelim();
    writer.uint32(178).fork();
    for (const v of message.maxInputProcessingTime) {
      writer.float(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGameMatchSignOutPerfData {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGameMatchSignOutPerfData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 13) {
            message.averageFrameTime.push(reader.float());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.averageFrameTime.push(reader.float());
            }

            continue;
          }

          break;
        case 2:
          if (tag === 21) {
            message.maxFrameTime.push(reader.float());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.maxFrameTime.push(reader.float());
            }

            continue;
          }

          break;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.serverAverageFrameTime = reader.float();
          continue;
        case 4:
          if (tag !== 37) {
            break;
          }

          message.serverMaxFrameTime = reader.float();
          continue;
        case 5:
          if (tag === 45) {
            message.averageComputeTime.push(reader.float());

            continue;
          }

          if (tag === 42) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.averageComputeTime.push(reader.float());
            }

            continue;
          }

          break;
        case 6:
          if (tag === 53) {
            message.maxComputeTime.push(reader.float());

            continue;
          }

          if (tag === 50) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.maxComputeTime.push(reader.float());
            }

            continue;
          }

          break;
        case 7:
          if (tag === 61) {
            message.averageClientTickTime.push(reader.float());

            continue;
          }

          if (tag === 58) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.averageClientTickTime.push(reader.float());
            }

            continue;
          }

          break;
        case 8:
          if (tag === 69) {
            message.maxClientTickTime.push(reader.float());

            continue;
          }

          if (tag === 66) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.maxClientTickTime.push(reader.float());
            }

            continue;
          }

          break;
        case 9:
          if (tag === 77) {
            message.averageClientSimulateTime.push(reader.float());

            continue;
          }

          if (tag === 74) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.averageClientSimulateTime.push(reader.float());
            }

            continue;
          }

          break;
        case 10:
          if (tag === 85) {
            message.maxClientSimulateTime.push(reader.float());

            continue;
          }

          if (tag === 82) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.maxClientSimulateTime.push(reader.float());
            }

            continue;
          }

          break;
        case 11:
          if (tag === 93) {
            message.averageOutputTime.push(reader.float());

            continue;
          }

          if (tag === 90) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.averageOutputTime.push(reader.float());
            }

            continue;
          }

          break;
        case 12:
          if (tag === 101) {
            message.maxOutputTime.push(reader.float());

            continue;
          }

          if (tag === 98) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.maxOutputTime.push(reader.float());
            }

            continue;
          }

          break;
        case 13:
          if (tag === 109) {
            message.averageWaitForRenderingToCompleteTime.push(reader.float());

            continue;
          }

          if (tag === 106) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.averageWaitForRenderingToCompleteTime.push(reader.float());
            }

            continue;
          }

          break;
        case 14:
          if (tag === 117) {
            message.maxWaitForRenderingToCompleteTime.push(reader.float());

            continue;
          }

          if (tag === 114) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.maxWaitForRenderingToCompleteTime.push(reader.float());
            }

            continue;
          }

          break;
        case 15:
          if (tag === 125) {
            message.averageSwapTime.push(reader.float());

            continue;
          }

          if (tag === 122) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.averageSwapTime.push(reader.float());
            }

            continue;
          }

          break;
        case 16:
          if (tag === 133) {
            message.maxSwapTime.push(reader.float());

            continue;
          }

          if (tag === 130) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.maxSwapTime.push(reader.float());
            }

            continue;
          }

          break;
        case 17:
          if (tag === 141) {
            message.averageFrameUpdateTime.push(reader.float());

            continue;
          }

          if (tag === 138) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.averageFrameUpdateTime.push(reader.float());
            }

            continue;
          }

          break;
        case 18:
          if (tag === 149) {
            message.maxFrameUpdateTime.push(reader.float());

            continue;
          }

          if (tag === 146) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.maxFrameUpdateTime.push(reader.float());
            }

            continue;
          }

          break;
        case 19:
          if (tag === 157) {
            message.averageIdleTime.push(reader.float());

            continue;
          }

          if (tag === 154) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.averageIdleTime.push(reader.float());
            }

            continue;
          }

          break;
        case 20:
          if (tag === 165) {
            message.maxIdleTime.push(reader.float());

            continue;
          }

          if (tag === 162) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.maxIdleTime.push(reader.float());
            }

            continue;
          }

          break;
        case 21:
          if (tag === 173) {
            message.averageInputProcessingTime.push(reader.float());

            continue;
          }

          if (tag === 170) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.averageInputProcessingTime.push(reader.float());
            }

            continue;
          }

          break;
        case 22:
          if (tag === 181) {
            message.maxInputProcessingTime.push(reader.float());

            continue;
          }

          if (tag === 178) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.maxInputProcessingTime.push(reader.float());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGameMatchSignOutPerfData {
    return {
      averageFrameTime: globalThis.Array.isArray(object?.averageFrameTime)
        ? object.averageFrameTime.map((e: any) => globalThis.Number(e))
        : [],
      maxFrameTime: globalThis.Array.isArray(object?.maxFrameTime)
        ? object.maxFrameTime.map((e: any) => globalThis.Number(e))
        : [],
      serverAverageFrameTime: isSet(object.serverAverageFrameTime)
        ? globalThis.Number(object.serverAverageFrameTime)
        : 0,
      serverMaxFrameTime: isSet(object.serverMaxFrameTime) ? globalThis.Number(object.serverMaxFrameTime) : 0,
      averageComputeTime: globalThis.Array.isArray(object?.averageComputeTime)
        ? object.averageComputeTime.map((e: any) => globalThis.Number(e))
        : [],
      maxComputeTime: globalThis.Array.isArray(object?.maxComputeTime)
        ? object.maxComputeTime.map((e: any) => globalThis.Number(e))
        : [],
      averageClientTickTime: globalThis.Array.isArray(object?.averageClientTickTime)
        ? object.averageClientTickTime.map((e: any) => globalThis.Number(e))
        : [],
      maxClientTickTime: globalThis.Array.isArray(object?.maxClientTickTime)
        ? object.maxClientTickTime.map((e: any) => globalThis.Number(e))
        : [],
      averageClientSimulateTime: globalThis.Array.isArray(object?.averageClientSimulateTime)
        ? object.averageClientSimulateTime.map((e: any) => globalThis.Number(e))
        : [],
      maxClientSimulateTime: globalThis.Array.isArray(object?.maxClientSimulateTime)
        ? object.maxClientSimulateTime.map((e: any) => globalThis.Number(e))
        : [],
      averageOutputTime: globalThis.Array.isArray(object?.averageOutputTime)
        ? object.averageOutputTime.map((e: any) => globalThis.Number(e))
        : [],
      maxOutputTime: globalThis.Array.isArray(object?.maxOutputTime)
        ? object.maxOutputTime.map((e: any) => globalThis.Number(e))
        : [],
      averageWaitForRenderingToCompleteTime: globalThis.Array.isArray(object?.averageWaitForRenderingToCompleteTime)
        ? object.averageWaitForRenderingToCompleteTime.map((e: any) => globalThis.Number(e))
        : [],
      maxWaitForRenderingToCompleteTime: globalThis.Array.isArray(object?.maxWaitForRenderingToCompleteTime)
        ? object.maxWaitForRenderingToCompleteTime.map((e: any) => globalThis.Number(e))
        : [],
      averageSwapTime: globalThis.Array.isArray(object?.averageSwapTime)
        ? object.averageSwapTime.map((e: any) => globalThis.Number(e))
        : [],
      maxSwapTime: globalThis.Array.isArray(object?.maxSwapTime)
        ? object.maxSwapTime.map((e: any) => globalThis.Number(e))
        : [],
      averageFrameUpdateTime: globalThis.Array.isArray(object?.averageFrameUpdateTime)
        ? object.averageFrameUpdateTime.map((e: any) => globalThis.Number(e))
        : [],
      maxFrameUpdateTime: globalThis.Array.isArray(object?.maxFrameUpdateTime)
        ? object.maxFrameUpdateTime.map((e: any) => globalThis.Number(e))
        : [],
      averageIdleTime: globalThis.Array.isArray(object?.averageIdleTime)
        ? object.averageIdleTime.map((e: any) => globalThis.Number(e))
        : [],
      maxIdleTime: globalThis.Array.isArray(object?.maxIdleTime)
        ? object.maxIdleTime.map((e: any) => globalThis.Number(e))
        : [],
      averageInputProcessingTime: globalThis.Array.isArray(object?.averageInputProcessingTime)
        ? object.averageInputProcessingTime.map((e: any) => globalThis.Number(e))
        : [],
      maxInputProcessingTime: globalThis.Array.isArray(object?.maxInputProcessingTime)
        ? object.maxInputProcessingTime.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: CMsgGameMatchSignOutPerfData): unknown {
    const obj: any = {};
    if (message.averageFrameTime?.length) {
      obj.averageFrameTime = message.averageFrameTime;
    }
    if (message.maxFrameTime?.length) {
      obj.maxFrameTime = message.maxFrameTime;
    }
    if (message.serverAverageFrameTime !== undefined && message.serverAverageFrameTime !== 0) {
      obj.serverAverageFrameTime = message.serverAverageFrameTime;
    }
    if (message.serverMaxFrameTime !== undefined && message.serverMaxFrameTime !== 0) {
      obj.serverMaxFrameTime = message.serverMaxFrameTime;
    }
    if (message.averageComputeTime?.length) {
      obj.averageComputeTime = message.averageComputeTime;
    }
    if (message.maxComputeTime?.length) {
      obj.maxComputeTime = message.maxComputeTime;
    }
    if (message.averageClientTickTime?.length) {
      obj.averageClientTickTime = message.averageClientTickTime;
    }
    if (message.maxClientTickTime?.length) {
      obj.maxClientTickTime = message.maxClientTickTime;
    }
    if (message.averageClientSimulateTime?.length) {
      obj.averageClientSimulateTime = message.averageClientSimulateTime;
    }
    if (message.maxClientSimulateTime?.length) {
      obj.maxClientSimulateTime = message.maxClientSimulateTime;
    }
    if (message.averageOutputTime?.length) {
      obj.averageOutputTime = message.averageOutputTime;
    }
    if (message.maxOutputTime?.length) {
      obj.maxOutputTime = message.maxOutputTime;
    }
    if (message.averageWaitForRenderingToCompleteTime?.length) {
      obj.averageWaitForRenderingToCompleteTime = message.averageWaitForRenderingToCompleteTime;
    }
    if (message.maxWaitForRenderingToCompleteTime?.length) {
      obj.maxWaitForRenderingToCompleteTime = message.maxWaitForRenderingToCompleteTime;
    }
    if (message.averageSwapTime?.length) {
      obj.averageSwapTime = message.averageSwapTime;
    }
    if (message.maxSwapTime?.length) {
      obj.maxSwapTime = message.maxSwapTime;
    }
    if (message.averageFrameUpdateTime?.length) {
      obj.averageFrameUpdateTime = message.averageFrameUpdateTime;
    }
    if (message.maxFrameUpdateTime?.length) {
      obj.maxFrameUpdateTime = message.maxFrameUpdateTime;
    }
    if (message.averageIdleTime?.length) {
      obj.averageIdleTime = message.averageIdleTime;
    }
    if (message.maxIdleTime?.length) {
      obj.maxIdleTime = message.maxIdleTime;
    }
    if (message.averageInputProcessingTime?.length) {
      obj.averageInputProcessingTime = message.averageInputProcessingTime;
    }
    if (message.maxInputProcessingTime?.length) {
      obj.maxInputProcessingTime = message.maxInputProcessingTime;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGameMatchSignOutPerfData>): CMsgGameMatchSignOutPerfData {
    return CMsgGameMatchSignOutPerfData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGameMatchSignOutPerfData>): CMsgGameMatchSignOutPerfData {
    const message = createBaseCMsgGameMatchSignOutPerfData();
    message.averageFrameTime = object.averageFrameTime?.map((e) => e) || [];
    message.maxFrameTime = object.maxFrameTime?.map((e) => e) || [];
    message.serverAverageFrameTime = object.serverAverageFrameTime ?? 0;
    message.serverMaxFrameTime = object.serverMaxFrameTime ?? 0;
    message.averageComputeTime = object.averageComputeTime?.map((e) => e) || [];
    message.maxComputeTime = object.maxComputeTime?.map((e) => e) || [];
    message.averageClientTickTime = object.averageClientTickTime?.map((e) => e) || [];
    message.maxClientTickTime = object.maxClientTickTime?.map((e) => e) || [];
    message.averageClientSimulateTime = object.averageClientSimulateTime?.map((e) => e) || [];
    message.maxClientSimulateTime = object.maxClientSimulateTime?.map((e) => e) || [];
    message.averageOutputTime = object.averageOutputTime?.map((e) => e) || [];
    message.maxOutputTime = object.maxOutputTime?.map((e) => e) || [];
    message.averageWaitForRenderingToCompleteTime = object.averageWaitForRenderingToCompleteTime?.map((e) => e) || [];
    message.maxWaitForRenderingToCompleteTime = object.maxWaitForRenderingToCompleteTime?.map((e) => e) || [];
    message.averageSwapTime = object.averageSwapTime?.map((e) => e) || [];
    message.maxSwapTime = object.maxSwapTime?.map((e) => e) || [];
    message.averageFrameUpdateTime = object.averageFrameUpdateTime?.map((e) => e) || [];
    message.maxFrameUpdateTime = object.maxFrameUpdateTime?.map((e) => e) || [];
    message.averageIdleTime = object.averageIdleTime?.map((e) => e) || [];
    message.maxIdleTime = object.maxIdleTime?.map((e) => e) || [];
    message.averageInputProcessingTime = object.averageInputProcessingTime?.map((e) => e) || [];
    message.maxInputProcessingTime = object.maxInputProcessingTime?.map((e) => e) || [];
    return message;
  },
};

function createBaseCMsgGameMatchSignOutBanData(): CMsgGameMatchSignOutBanData {
  return { heroBans: [], heroBanVotes: [] };
}

export const CMsgGameMatchSignOutBanData = {
  encode(message: CMsgGameMatchSignOutBanData, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.heroBans) {
      writer.int32(v);
    }
    writer.ldelim();
    writer.uint32(18).fork();
    for (const v of message.heroBanVotes) {
      writer.int32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGameMatchSignOutBanData {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGameMatchSignOutBanData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.heroBans.push(reader.int32());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.heroBans.push(reader.int32());
            }

            continue;
          }

          break;
        case 2:
          if (tag === 16) {
            message.heroBanVotes.push(reader.int32());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.heroBanVotes.push(reader.int32());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGameMatchSignOutBanData {
    return {
      heroBans: globalThis.Array.isArray(object?.heroBans) ? object.heroBans.map((e: any) => globalThis.Number(e)) : [],
      heroBanVotes: globalThis.Array.isArray(object?.heroBanVotes)
        ? object.heroBanVotes.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: CMsgGameMatchSignOutBanData): unknown {
    const obj: any = {};
    if (message.heroBans?.length) {
      obj.heroBans = message.heroBans.map((e) => Math.round(e));
    }
    if (message.heroBanVotes?.length) {
      obj.heroBanVotes = message.heroBanVotes.map((e) => Math.round(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGameMatchSignOutBanData>): CMsgGameMatchSignOutBanData {
    return CMsgGameMatchSignOutBanData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGameMatchSignOutBanData>): CMsgGameMatchSignOutBanData {
    const message = createBaseCMsgGameMatchSignOutBanData();
    message.heroBans = object.heroBans?.map((e) => e) || [];
    message.heroBanVotes = object.heroBanVotes?.map((e) => e) || [];
    return message;
  },
};

function createBaseCMsgDOTALiveScoreboardUpdate(): CMsgDOTALiveScoreboardUpdate {
  return {
    tournamentId: 0,
    tournamentGameId: 0,
    duration: 0,
    hltvDelay: 0,
    teamGood: undefined,
    teamBad: undefined,
    roshanRespawnTimer: 0,
    leagueId: 0,
    matchId: "0",
  };
}

export const CMsgDOTALiveScoreboardUpdate = {
  encode(message: CMsgDOTALiveScoreboardUpdate, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.tournamentId !== undefined && message.tournamentId !== 0) {
      writer.uint32(8).uint32(message.tournamentId);
    }
    if (message.tournamentGameId !== undefined && message.tournamentGameId !== 0) {
      writer.uint32(16).uint32(message.tournamentGameId);
    }
    if (message.duration !== undefined && message.duration !== 0) {
      writer.uint32(29).float(message.duration);
    }
    if (message.hltvDelay !== undefined && message.hltvDelay !== 0) {
      writer.uint32(32).int32(message.hltvDelay);
    }
    if (message.teamGood !== undefined) {
      CMsgDOTALiveScoreboardUpdate_Team.encode(message.teamGood, writer.uint32(42).fork()).ldelim();
    }
    if (message.teamBad !== undefined) {
      CMsgDOTALiveScoreboardUpdate_Team.encode(message.teamBad, writer.uint32(50).fork()).ldelim();
    }
    if (message.roshanRespawnTimer !== undefined && message.roshanRespawnTimer !== 0) {
      writer.uint32(56).uint32(message.roshanRespawnTimer);
    }
    if (message.leagueId !== undefined && message.leagueId !== 0) {
      writer.uint32(64).uint32(message.leagueId);
    }
    if (message.matchId !== undefined && message.matchId !== "0") {
      writer.uint32(72).uint64(message.matchId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTALiveScoreboardUpdate {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTALiveScoreboardUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.tournamentId = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.tournamentGameId = reader.uint32();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.duration = reader.float();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.hltvDelay = reader.int32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.teamGood = CMsgDOTALiveScoreboardUpdate_Team.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.teamBad = CMsgDOTALiveScoreboardUpdate_Team.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.roshanRespawnTimer = reader.uint32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.leagueId = reader.uint32();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.matchId = longToString(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTALiveScoreboardUpdate {
    return {
      tournamentId: isSet(object.tournamentId) ? globalThis.Number(object.tournamentId) : 0,
      tournamentGameId: isSet(object.tournamentGameId) ? globalThis.Number(object.tournamentGameId) : 0,
      duration: isSet(object.duration) ? globalThis.Number(object.duration) : 0,
      hltvDelay: isSet(object.hltvDelay) ? globalThis.Number(object.hltvDelay) : 0,
      teamGood: isSet(object.teamGood) ? CMsgDOTALiveScoreboardUpdate_Team.fromJSON(object.teamGood) : undefined,
      teamBad: isSet(object.teamBad) ? CMsgDOTALiveScoreboardUpdate_Team.fromJSON(object.teamBad) : undefined,
      roshanRespawnTimer: isSet(object.roshanRespawnTimer) ? globalThis.Number(object.roshanRespawnTimer) : 0,
      leagueId: isSet(object.leagueId) ? globalThis.Number(object.leagueId) : 0,
      matchId: isSet(object.matchId) ? globalThis.String(object.matchId) : "0",
    };
  },

  toJSON(message: CMsgDOTALiveScoreboardUpdate): unknown {
    const obj: any = {};
    if (message.tournamentId !== undefined && message.tournamentId !== 0) {
      obj.tournamentId = Math.round(message.tournamentId);
    }
    if (message.tournamentGameId !== undefined && message.tournamentGameId !== 0) {
      obj.tournamentGameId = Math.round(message.tournamentGameId);
    }
    if (message.duration !== undefined && message.duration !== 0) {
      obj.duration = message.duration;
    }
    if (message.hltvDelay !== undefined && message.hltvDelay !== 0) {
      obj.hltvDelay = Math.round(message.hltvDelay);
    }
    if (message.teamGood !== undefined) {
      obj.teamGood = CMsgDOTALiveScoreboardUpdate_Team.toJSON(message.teamGood);
    }
    if (message.teamBad !== undefined) {
      obj.teamBad = CMsgDOTALiveScoreboardUpdate_Team.toJSON(message.teamBad);
    }
    if (message.roshanRespawnTimer !== undefined && message.roshanRespawnTimer !== 0) {
      obj.roshanRespawnTimer = Math.round(message.roshanRespawnTimer);
    }
    if (message.leagueId !== undefined && message.leagueId !== 0) {
      obj.leagueId = Math.round(message.leagueId);
    }
    if (message.matchId !== undefined && message.matchId !== "0") {
      obj.matchId = message.matchId;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTALiveScoreboardUpdate>): CMsgDOTALiveScoreboardUpdate {
    return CMsgDOTALiveScoreboardUpdate.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTALiveScoreboardUpdate>): CMsgDOTALiveScoreboardUpdate {
    const message = createBaseCMsgDOTALiveScoreboardUpdate();
    message.tournamentId = object.tournamentId ?? 0;
    message.tournamentGameId = object.tournamentGameId ?? 0;
    message.duration = object.duration ?? 0;
    message.hltvDelay = object.hltvDelay ?? 0;
    message.teamGood = (object.teamGood !== undefined && object.teamGood !== null)
      ? CMsgDOTALiveScoreboardUpdate_Team.fromPartial(object.teamGood)
      : undefined;
    message.teamBad = (object.teamBad !== undefined && object.teamBad !== null)
      ? CMsgDOTALiveScoreboardUpdate_Team.fromPartial(object.teamBad)
      : undefined;
    message.roshanRespawnTimer = object.roshanRespawnTimer ?? 0;
    message.leagueId = object.leagueId ?? 0;
    message.matchId = object.matchId ?? "0";
    return message;
  },
};

function createBaseCMsgDOTALiveScoreboardUpdate_Team(): CMsgDOTALiveScoreboardUpdate_Team {
  return { players: [], score: 0, towerState: 0, barracksState: 0, heroPicks: [], heroBans: [] };
}

export const CMsgDOTALiveScoreboardUpdate_Team = {
  encode(message: CMsgDOTALiveScoreboardUpdate_Team, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.players) {
      CMsgDOTALiveScoreboardUpdate_Team_Player.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.score !== undefined && message.score !== 0) {
      writer.uint32(16).uint32(message.score);
    }
    if (message.towerState !== undefined && message.towerState !== 0) {
      writer.uint32(24).uint32(message.towerState);
    }
    if (message.barracksState !== undefined && message.barracksState !== 0) {
      writer.uint32(32).uint32(message.barracksState);
    }
    writer.uint32(42).fork();
    for (const v of message.heroPicks) {
      writer.int32(v);
    }
    writer.ldelim();
    writer.uint32(50).fork();
    for (const v of message.heroBans) {
      writer.int32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTALiveScoreboardUpdate_Team {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTALiveScoreboardUpdate_Team();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.players.push(CMsgDOTALiveScoreboardUpdate_Team_Player.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.score = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.towerState = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.barracksState = reader.uint32();
          continue;
        case 5:
          if (tag === 40) {
            message.heroPicks.push(reader.int32());

            continue;
          }

          if (tag === 42) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.heroPicks.push(reader.int32());
            }

            continue;
          }

          break;
        case 6:
          if (tag === 48) {
            message.heroBans.push(reader.int32());

            continue;
          }

          if (tag === 50) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.heroBans.push(reader.int32());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTALiveScoreboardUpdate_Team {
    return {
      players: globalThis.Array.isArray(object?.players)
        ? object.players.map((e: any) => CMsgDOTALiveScoreboardUpdate_Team_Player.fromJSON(e))
        : [],
      score: isSet(object.score) ? globalThis.Number(object.score) : 0,
      towerState: isSet(object.towerState) ? globalThis.Number(object.towerState) : 0,
      barracksState: isSet(object.barracksState) ? globalThis.Number(object.barracksState) : 0,
      heroPicks: globalThis.Array.isArray(object?.heroPicks)
        ? object.heroPicks.map((e: any) => globalThis.Number(e))
        : [],
      heroBans: globalThis.Array.isArray(object?.heroBans) ? object.heroBans.map((e: any) => globalThis.Number(e)) : [],
    };
  },

  toJSON(message: CMsgDOTALiveScoreboardUpdate_Team): unknown {
    const obj: any = {};
    if (message.players?.length) {
      obj.players = message.players.map((e) => CMsgDOTALiveScoreboardUpdate_Team_Player.toJSON(e));
    }
    if (message.score !== undefined && message.score !== 0) {
      obj.score = Math.round(message.score);
    }
    if (message.towerState !== undefined && message.towerState !== 0) {
      obj.towerState = Math.round(message.towerState);
    }
    if (message.barracksState !== undefined && message.barracksState !== 0) {
      obj.barracksState = Math.round(message.barracksState);
    }
    if (message.heroPicks?.length) {
      obj.heroPicks = message.heroPicks.map((e) => Math.round(e));
    }
    if (message.heroBans?.length) {
      obj.heroBans = message.heroBans.map((e) => Math.round(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTALiveScoreboardUpdate_Team>): CMsgDOTALiveScoreboardUpdate_Team {
    return CMsgDOTALiveScoreboardUpdate_Team.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTALiveScoreboardUpdate_Team>): CMsgDOTALiveScoreboardUpdate_Team {
    const message = createBaseCMsgDOTALiveScoreboardUpdate_Team();
    message.players = object.players?.map((e) => CMsgDOTALiveScoreboardUpdate_Team_Player.fromPartial(e)) || [];
    message.score = object.score ?? 0;
    message.towerState = object.towerState ?? 0;
    message.barracksState = object.barracksState ?? 0;
    message.heroPicks = object.heroPicks?.map((e) => e) || [];
    message.heroBans = object.heroBans?.map((e) => e) || [];
    return message;
  },
};

function createBaseCMsgDOTALiveScoreboardUpdate_Team_Player(): CMsgDOTALiveScoreboardUpdate_Team_Player {
  return {
    playerSlot: 0,
    playerName: "",
    heroName: "",
    heroId: 0,
    kills: 0,
    deaths: 0,
    assists: 0,
    lastHits: 0,
    denies: 0,
    gold: 0,
    level: 0,
    goldPerMin: 0,
    xpPerMin: 0,
    ultimateState: 0,
    ultimateCooldown: 0,
    item0: -1,
    item1: -1,
    item2: -1,
    item3: -1,
    item4: -1,
    item5: -1,
    respawnTimer: 0,
    accountId: 0,
    positionX: 0,
    positionY: 0,
    netWorth: 0,
    abilities: [],
  };
}

export const CMsgDOTALiveScoreboardUpdate_Team_Player = {
  encode(message: CMsgDOTALiveScoreboardUpdate_Team_Player, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.playerSlot !== undefined && message.playerSlot !== 0) {
      writer.uint32(8).uint32(message.playerSlot);
    }
    if (message.playerName !== undefined && message.playerName !== "") {
      writer.uint32(18).string(message.playerName);
    }
    if (message.heroName !== undefined && message.heroName !== "") {
      writer.uint32(26).string(message.heroName);
    }
    if (message.heroId !== undefined && message.heroId !== 0) {
      writer.uint32(32).int32(message.heroId);
    }
    if (message.kills !== undefined && message.kills !== 0) {
      writer.uint32(40).uint32(message.kills);
    }
    if (message.deaths !== undefined && message.deaths !== 0) {
      writer.uint32(48).uint32(message.deaths);
    }
    if (message.assists !== undefined && message.assists !== 0) {
      writer.uint32(56).uint32(message.assists);
    }
    if (message.lastHits !== undefined && message.lastHits !== 0) {
      writer.uint32(64).uint32(message.lastHits);
    }
    if (message.denies !== undefined && message.denies !== 0) {
      writer.uint32(72).uint32(message.denies);
    }
    if (message.gold !== undefined && message.gold !== 0) {
      writer.uint32(80).uint32(message.gold);
    }
    if (message.level !== undefined && message.level !== 0) {
      writer.uint32(88).uint32(message.level);
    }
    if (message.goldPerMin !== undefined && message.goldPerMin !== 0) {
      writer.uint32(101).float(message.goldPerMin);
    }
    if (message.xpPerMin !== undefined && message.xpPerMin !== 0) {
      writer.uint32(109).float(message.xpPerMin);
    }
    if (message.ultimateState !== undefined && message.ultimateState !== 0) {
      writer.uint32(112).int32(message.ultimateState);
    }
    if (message.ultimateCooldown !== undefined && message.ultimateCooldown !== 0) {
      writer.uint32(125).float(message.ultimateCooldown);
    }
    if (message.item0 !== undefined && message.item0 !== -1) {
      writer.uint32(128).int32(message.item0);
    }
    if (message.item1 !== undefined && message.item1 !== -1) {
      writer.uint32(136).int32(message.item1);
    }
    if (message.item2 !== undefined && message.item2 !== -1) {
      writer.uint32(144).int32(message.item2);
    }
    if (message.item3 !== undefined && message.item3 !== -1) {
      writer.uint32(152).int32(message.item3);
    }
    if (message.item4 !== undefined && message.item4 !== -1) {
      writer.uint32(160).int32(message.item4);
    }
    if (message.item5 !== undefined && message.item5 !== -1) {
      writer.uint32(168).int32(message.item5);
    }
    if (message.respawnTimer !== undefined && message.respawnTimer !== 0) {
      writer.uint32(176).uint32(message.respawnTimer);
    }
    if (message.accountId !== undefined && message.accountId !== 0) {
      writer.uint32(184).uint32(message.accountId);
    }
    if (message.positionX !== undefined && message.positionX !== 0) {
      writer.uint32(197).float(message.positionX);
    }
    if (message.positionY !== undefined && message.positionY !== 0) {
      writer.uint32(205).float(message.positionY);
    }
    if (message.netWorth !== undefined && message.netWorth !== 0) {
      writer.uint32(208).uint32(message.netWorth);
    }
    for (const v of message.abilities) {
      CMsgDOTALiveScoreboardUpdate_Team_Player_HeroAbility.encode(v!, writer.uint32(218).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTALiveScoreboardUpdate_Team_Player {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTALiveScoreboardUpdate_Team_Player();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.playerSlot = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.playerName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.heroName = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.heroId = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.kills = reader.uint32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.deaths = reader.uint32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.assists = reader.uint32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.lastHits = reader.uint32();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.denies = reader.uint32();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.gold = reader.uint32();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.level = reader.uint32();
          continue;
        case 12:
          if (tag !== 101) {
            break;
          }

          message.goldPerMin = reader.float();
          continue;
        case 13:
          if (tag !== 109) {
            break;
          }

          message.xpPerMin = reader.float();
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.ultimateState = reader.int32() as any;
          continue;
        case 15:
          if (tag !== 125) {
            break;
          }

          message.ultimateCooldown = reader.float();
          continue;
        case 16:
          if (tag !== 128) {
            break;
          }

          message.item0 = reader.int32();
          continue;
        case 17:
          if (tag !== 136) {
            break;
          }

          message.item1 = reader.int32();
          continue;
        case 18:
          if (tag !== 144) {
            break;
          }

          message.item2 = reader.int32();
          continue;
        case 19:
          if (tag !== 152) {
            break;
          }

          message.item3 = reader.int32();
          continue;
        case 20:
          if (tag !== 160) {
            break;
          }

          message.item4 = reader.int32();
          continue;
        case 21:
          if (tag !== 168) {
            break;
          }

          message.item5 = reader.int32();
          continue;
        case 22:
          if (tag !== 176) {
            break;
          }

          message.respawnTimer = reader.uint32();
          continue;
        case 23:
          if (tag !== 184) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        case 24:
          if (tag !== 197) {
            break;
          }

          message.positionX = reader.float();
          continue;
        case 25:
          if (tag !== 205) {
            break;
          }

          message.positionY = reader.float();
          continue;
        case 26:
          if (tag !== 208) {
            break;
          }

          message.netWorth = reader.uint32();
          continue;
        case 27:
          if (tag !== 218) {
            break;
          }

          message.abilities.push(CMsgDOTALiveScoreboardUpdate_Team_Player_HeroAbility.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTALiveScoreboardUpdate_Team_Player {
    return {
      playerSlot: isSet(object.playerSlot) ? globalThis.Number(object.playerSlot) : 0,
      playerName: isSet(object.playerName) ? globalThis.String(object.playerName) : "",
      heroName: isSet(object.heroName) ? globalThis.String(object.heroName) : "",
      heroId: isSet(object.heroId) ? globalThis.Number(object.heroId) : 0,
      kills: isSet(object.kills) ? globalThis.Number(object.kills) : 0,
      deaths: isSet(object.deaths) ? globalThis.Number(object.deaths) : 0,
      assists: isSet(object.assists) ? globalThis.Number(object.assists) : 0,
      lastHits: isSet(object.lastHits) ? globalThis.Number(object.lastHits) : 0,
      denies: isSet(object.denies) ? globalThis.Number(object.denies) : 0,
      gold: isSet(object.gold) ? globalThis.Number(object.gold) : 0,
      level: isSet(object.level) ? globalThis.Number(object.level) : 0,
      goldPerMin: isSet(object.goldPerMin) ? globalThis.Number(object.goldPerMin) : 0,
      xpPerMin: isSet(object.xpPerMin) ? globalThis.Number(object.xpPerMin) : 0,
      ultimateState: isSet(object.ultimateState)
        ? cMsgDOTALiveScoreboardUpdate_Team_Player_DOTAUltimateStateFromJSON(object.ultimateState)
        : 0,
      ultimateCooldown: isSet(object.ultimateCooldown) ? globalThis.Number(object.ultimateCooldown) : 0,
      item0: isSet(object.item0) ? globalThis.Number(object.item0) : -1,
      item1: isSet(object.item1) ? globalThis.Number(object.item1) : -1,
      item2: isSet(object.item2) ? globalThis.Number(object.item2) : -1,
      item3: isSet(object.item3) ? globalThis.Number(object.item3) : -1,
      item4: isSet(object.item4) ? globalThis.Number(object.item4) : -1,
      item5: isSet(object.item5) ? globalThis.Number(object.item5) : -1,
      respawnTimer: isSet(object.respawnTimer) ? globalThis.Number(object.respawnTimer) : 0,
      accountId: isSet(object.accountId) ? globalThis.Number(object.accountId) : 0,
      positionX: isSet(object.positionX) ? globalThis.Number(object.positionX) : 0,
      positionY: isSet(object.positionY) ? globalThis.Number(object.positionY) : 0,
      netWorth: isSet(object.netWorth) ? globalThis.Number(object.netWorth) : 0,
      abilities: globalThis.Array.isArray(object?.abilities)
        ? object.abilities.map((e: any) => CMsgDOTALiveScoreboardUpdate_Team_Player_HeroAbility.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgDOTALiveScoreboardUpdate_Team_Player): unknown {
    const obj: any = {};
    if (message.playerSlot !== undefined && message.playerSlot !== 0) {
      obj.playerSlot = Math.round(message.playerSlot);
    }
    if (message.playerName !== undefined && message.playerName !== "") {
      obj.playerName = message.playerName;
    }
    if (message.heroName !== undefined && message.heroName !== "") {
      obj.heroName = message.heroName;
    }
    if (message.heroId !== undefined && message.heroId !== 0) {
      obj.heroId = Math.round(message.heroId);
    }
    if (message.kills !== undefined && message.kills !== 0) {
      obj.kills = Math.round(message.kills);
    }
    if (message.deaths !== undefined && message.deaths !== 0) {
      obj.deaths = Math.round(message.deaths);
    }
    if (message.assists !== undefined && message.assists !== 0) {
      obj.assists = Math.round(message.assists);
    }
    if (message.lastHits !== undefined && message.lastHits !== 0) {
      obj.lastHits = Math.round(message.lastHits);
    }
    if (message.denies !== undefined && message.denies !== 0) {
      obj.denies = Math.round(message.denies);
    }
    if (message.gold !== undefined && message.gold !== 0) {
      obj.gold = Math.round(message.gold);
    }
    if (message.level !== undefined && message.level !== 0) {
      obj.level = Math.round(message.level);
    }
    if (message.goldPerMin !== undefined && message.goldPerMin !== 0) {
      obj.goldPerMin = message.goldPerMin;
    }
    if (message.xpPerMin !== undefined && message.xpPerMin !== 0) {
      obj.xpPerMin = message.xpPerMin;
    }
    if (message.ultimateState !== undefined && message.ultimateState !== 0) {
      obj.ultimateState = cMsgDOTALiveScoreboardUpdate_Team_Player_DOTAUltimateStateToJSON(message.ultimateState);
    }
    if (message.ultimateCooldown !== undefined && message.ultimateCooldown !== 0) {
      obj.ultimateCooldown = message.ultimateCooldown;
    }
    if (message.item0 !== undefined && message.item0 !== -1) {
      obj.item0 = Math.round(message.item0);
    }
    if (message.item1 !== undefined && message.item1 !== -1) {
      obj.item1 = Math.round(message.item1);
    }
    if (message.item2 !== undefined && message.item2 !== -1) {
      obj.item2 = Math.round(message.item2);
    }
    if (message.item3 !== undefined && message.item3 !== -1) {
      obj.item3 = Math.round(message.item3);
    }
    if (message.item4 !== undefined && message.item4 !== -1) {
      obj.item4 = Math.round(message.item4);
    }
    if (message.item5 !== undefined && message.item5 !== -1) {
      obj.item5 = Math.round(message.item5);
    }
    if (message.respawnTimer !== undefined && message.respawnTimer !== 0) {
      obj.respawnTimer = Math.round(message.respawnTimer);
    }
    if (message.accountId !== undefined && message.accountId !== 0) {
      obj.accountId = Math.round(message.accountId);
    }
    if (message.positionX !== undefined && message.positionX !== 0) {
      obj.positionX = message.positionX;
    }
    if (message.positionY !== undefined && message.positionY !== 0) {
      obj.positionY = message.positionY;
    }
    if (message.netWorth !== undefined && message.netWorth !== 0) {
      obj.netWorth = Math.round(message.netWorth);
    }
    if (message.abilities?.length) {
      obj.abilities = message.abilities.map((e) => CMsgDOTALiveScoreboardUpdate_Team_Player_HeroAbility.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTALiveScoreboardUpdate_Team_Player>): CMsgDOTALiveScoreboardUpdate_Team_Player {
    return CMsgDOTALiveScoreboardUpdate_Team_Player.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTALiveScoreboardUpdate_Team_Player>): CMsgDOTALiveScoreboardUpdate_Team_Player {
    const message = createBaseCMsgDOTALiveScoreboardUpdate_Team_Player();
    message.playerSlot = object.playerSlot ?? 0;
    message.playerName = object.playerName ?? "";
    message.heroName = object.heroName ?? "";
    message.heroId = object.heroId ?? 0;
    message.kills = object.kills ?? 0;
    message.deaths = object.deaths ?? 0;
    message.assists = object.assists ?? 0;
    message.lastHits = object.lastHits ?? 0;
    message.denies = object.denies ?? 0;
    message.gold = object.gold ?? 0;
    message.level = object.level ?? 0;
    message.goldPerMin = object.goldPerMin ?? 0;
    message.xpPerMin = object.xpPerMin ?? 0;
    message.ultimateState = object.ultimateState ?? 0;
    message.ultimateCooldown = object.ultimateCooldown ?? 0;
    message.item0 = object.item0 ?? -1;
    message.item1 = object.item1 ?? -1;
    message.item2 = object.item2 ?? -1;
    message.item3 = object.item3 ?? -1;
    message.item4 = object.item4 ?? -1;
    message.item5 = object.item5 ?? -1;
    message.respawnTimer = object.respawnTimer ?? 0;
    message.accountId = object.accountId ?? 0;
    message.positionX = object.positionX ?? 0;
    message.positionY = object.positionY ?? 0;
    message.netWorth = object.netWorth ?? 0;
    message.abilities =
      object.abilities?.map((e) => CMsgDOTALiveScoreboardUpdate_Team_Player_HeroAbility.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgDOTALiveScoreboardUpdate_Team_Player_HeroAbility(): CMsgDOTALiveScoreboardUpdate_Team_Player_HeroAbility {
  return { abilityId: -1, abilityLevel: 0 };
}

export const CMsgDOTALiveScoreboardUpdate_Team_Player_HeroAbility = {
  encode(
    message: CMsgDOTALiveScoreboardUpdate_Team_Player_HeroAbility,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.abilityId !== undefined && message.abilityId !== -1) {
      writer.uint32(8).int32(message.abilityId);
    }
    if (message.abilityLevel !== undefined && message.abilityLevel !== 0) {
      writer.uint32(16).uint32(message.abilityLevel);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTALiveScoreboardUpdate_Team_Player_HeroAbility {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTALiveScoreboardUpdate_Team_Player_HeroAbility();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.abilityId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.abilityLevel = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTALiveScoreboardUpdate_Team_Player_HeroAbility {
    return {
      abilityId: isSet(object.abilityId) ? globalThis.Number(object.abilityId) : -1,
      abilityLevel: isSet(object.abilityLevel) ? globalThis.Number(object.abilityLevel) : 0,
    };
  },

  toJSON(message: CMsgDOTALiveScoreboardUpdate_Team_Player_HeroAbility): unknown {
    const obj: any = {};
    if (message.abilityId !== undefined && message.abilityId !== -1) {
      obj.abilityId = Math.round(message.abilityId);
    }
    if (message.abilityLevel !== undefined && message.abilityLevel !== 0) {
      obj.abilityLevel = Math.round(message.abilityLevel);
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgDOTALiveScoreboardUpdate_Team_Player_HeroAbility>,
  ): CMsgDOTALiveScoreboardUpdate_Team_Player_HeroAbility {
    return CMsgDOTALiveScoreboardUpdate_Team_Player_HeroAbility.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgDOTALiveScoreboardUpdate_Team_Player_HeroAbility>,
  ): CMsgDOTALiveScoreboardUpdate_Team_Player_HeroAbility {
    const message = createBaseCMsgDOTALiveScoreboardUpdate_Team_Player_HeroAbility();
    message.abilityId = object.abilityId ?? -1;
    message.abilityLevel = object.abilityLevel ?? 0;
    return message;
  },
};

function createBaseCMsgServerToGCRequestBatchPlayerResources(): CMsgServerToGCRequestBatchPlayerResources {
  return { accountIds: [], rankTypes: [], lobbyType: 0 };
}

export const CMsgServerToGCRequestBatchPlayerResources = {
  encode(message: CMsgServerToGCRequestBatchPlayerResources, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.accountIds) {
      writer.uint32(v);
    }
    writer.ldelim();
    writer.uint32(34).fork();
    for (const v of message.rankTypes) {
      writer.uint32(v);
    }
    writer.ldelim();
    if (message.lobbyType !== undefined && message.lobbyType !== 0) {
      writer.uint32(40).int32(message.lobbyType);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgServerToGCRequestBatchPlayerResources {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgServerToGCRequestBatchPlayerResources();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.accountIds.push(reader.uint32());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.accountIds.push(reader.uint32());
            }

            continue;
          }

          break;
        case 4:
          if (tag === 32) {
            message.rankTypes.push(reader.uint32());

            continue;
          }

          if (tag === 34) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.rankTypes.push(reader.uint32());
            }

            continue;
          }

          break;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.lobbyType = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgServerToGCRequestBatchPlayerResources {
    return {
      accountIds: globalThis.Array.isArray(object?.accountIds)
        ? object.accountIds.map((e: any) => globalThis.Number(e))
        : [],
      rankTypes: globalThis.Array.isArray(object?.rankTypes)
        ? object.rankTypes.map((e: any) => globalThis.Number(e))
        : [],
      lobbyType: isSet(object.lobbyType) ? globalThis.Number(object.lobbyType) : 0,
    };
  },

  toJSON(message: CMsgServerToGCRequestBatchPlayerResources): unknown {
    const obj: any = {};
    if (message.accountIds?.length) {
      obj.accountIds = message.accountIds.map((e) => Math.round(e));
    }
    if (message.rankTypes?.length) {
      obj.rankTypes = message.rankTypes.map((e) => Math.round(e));
    }
    if (message.lobbyType !== undefined && message.lobbyType !== 0) {
      obj.lobbyType = Math.round(message.lobbyType);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgServerToGCRequestBatchPlayerResources>): CMsgServerToGCRequestBatchPlayerResources {
    return CMsgServerToGCRequestBatchPlayerResources.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgServerToGCRequestBatchPlayerResources>,
  ): CMsgServerToGCRequestBatchPlayerResources {
    const message = createBaseCMsgServerToGCRequestBatchPlayerResources();
    message.accountIds = object.accountIds?.map((e) => e) || [];
    message.rankTypes = object.rankTypes?.map((e) => e) || [];
    message.lobbyType = object.lobbyType ?? 0;
    return message;
  },
};

function createBaseCMsgServerToGCRequestBatchPlayerResourcesResponse(): CMsgServerToGCRequestBatchPlayerResourcesResponse {
  return { results: [] };
}

export const CMsgServerToGCRequestBatchPlayerResourcesResponse = {
  encode(
    message: CMsgServerToGCRequestBatchPlayerResourcesResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    for (const v of message.results) {
      CMsgServerToGCRequestBatchPlayerResourcesResponse_Result.encode(v!, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgServerToGCRequestBatchPlayerResourcesResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgServerToGCRequestBatchPlayerResourcesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 6:
          if (tag !== 50) {
            break;
          }

          message.results.push(
            CMsgServerToGCRequestBatchPlayerResourcesResponse_Result.decode(reader, reader.uint32()),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgServerToGCRequestBatchPlayerResourcesResponse {
    return {
      results: globalThis.Array.isArray(object?.results)
        ? object.results.map((e: any) => CMsgServerToGCRequestBatchPlayerResourcesResponse_Result.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgServerToGCRequestBatchPlayerResourcesResponse): unknown {
    const obj: any = {};
    if (message.results?.length) {
      obj.results = message.results.map((e) => CMsgServerToGCRequestBatchPlayerResourcesResponse_Result.toJSON(e));
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgServerToGCRequestBatchPlayerResourcesResponse>,
  ): CMsgServerToGCRequestBatchPlayerResourcesResponse {
    return CMsgServerToGCRequestBatchPlayerResourcesResponse.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgServerToGCRequestBatchPlayerResourcesResponse>,
  ): CMsgServerToGCRequestBatchPlayerResourcesResponse {
    const message = createBaseCMsgServerToGCRequestBatchPlayerResourcesResponse();
    message.results =
      object.results?.map((e) => CMsgServerToGCRequestBatchPlayerResourcesResponse_Result.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgServerToGCRequestBatchPlayerResourcesResponse_Result(): CMsgServerToGCRequestBatchPlayerResourcesResponse_Result {
  return {
    accountId: 0,
    rank: 0,
    rankCalibrated: false,
    lowPriority: false,
    isNewPlayer: false,
    isGuidePlayer: false,
    commLevel: 0,
    behaviorLevel: 0,
    wins: 0,
    losses: 0,
    smurfCategory: 0,
    commScore: 0,
    behaviorScore: 0,
    rankUncertainty: 0,
  };
}

export const CMsgServerToGCRequestBatchPlayerResourcesResponse_Result = {
  encode(
    message: CMsgServerToGCRequestBatchPlayerResourcesResponse_Result,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.accountId !== undefined && message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    if (message.rank !== undefined && message.rank !== 0) {
      writer.uint32(32).uint32(message.rank);
    }
    if (message.rankCalibrated !== undefined && message.rankCalibrated !== false) {
      writer.uint32(40).bool(message.rankCalibrated);
    }
    if (message.lowPriority !== undefined && message.lowPriority !== false) {
      writer.uint32(48).bool(message.lowPriority);
    }
    if (message.isNewPlayer !== undefined && message.isNewPlayer !== false) {
      writer.uint32(56).bool(message.isNewPlayer);
    }
    if (message.isGuidePlayer !== undefined && message.isGuidePlayer !== false) {
      writer.uint32(64).bool(message.isGuidePlayer);
    }
    if (message.commLevel !== undefined && message.commLevel !== 0) {
      writer.uint32(72).int32(message.commLevel);
    }
    if (message.behaviorLevel !== undefined && message.behaviorLevel !== 0) {
      writer.uint32(80).int32(message.behaviorLevel);
    }
    if (message.wins !== undefined && message.wins !== 0) {
      writer.uint32(88).int32(message.wins);
    }
    if (message.losses !== undefined && message.losses !== 0) {
      writer.uint32(96).int32(message.losses);
    }
    if (message.smurfCategory !== undefined && message.smurfCategory !== 0) {
      writer.uint32(104).int32(message.smurfCategory);
    }
    if (message.commScore !== undefined && message.commScore !== 0) {
      writer.uint32(112).int32(message.commScore);
    }
    if (message.behaviorScore !== undefined && message.behaviorScore !== 0) {
      writer.uint32(120).int32(message.behaviorScore);
    }
    if (message.rankUncertainty !== undefined && message.rankUncertainty !== 0) {
      writer.uint32(128).int32(message.rankUncertainty);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgServerToGCRequestBatchPlayerResourcesResponse_Result {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgServerToGCRequestBatchPlayerResourcesResponse_Result();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.rank = reader.uint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.rankCalibrated = reader.bool();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.lowPriority = reader.bool();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.isNewPlayer = reader.bool();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.isGuidePlayer = reader.bool();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.commLevel = reader.int32();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.behaviorLevel = reader.int32();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.wins = reader.int32();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.losses = reader.int32();
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.smurfCategory = reader.int32();
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.commScore = reader.int32();
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.behaviorScore = reader.int32();
          continue;
        case 16:
          if (tag !== 128) {
            break;
          }

          message.rankUncertainty = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgServerToGCRequestBatchPlayerResourcesResponse_Result {
    return {
      accountId: isSet(object.accountId) ? globalThis.Number(object.accountId) : 0,
      rank: isSet(object.rank) ? globalThis.Number(object.rank) : 0,
      rankCalibrated: isSet(object.rankCalibrated) ? globalThis.Boolean(object.rankCalibrated) : false,
      lowPriority: isSet(object.lowPriority) ? globalThis.Boolean(object.lowPriority) : false,
      isNewPlayer: isSet(object.isNewPlayer) ? globalThis.Boolean(object.isNewPlayer) : false,
      isGuidePlayer: isSet(object.isGuidePlayer) ? globalThis.Boolean(object.isGuidePlayer) : false,
      commLevel: isSet(object.commLevel) ? globalThis.Number(object.commLevel) : 0,
      behaviorLevel: isSet(object.behaviorLevel) ? globalThis.Number(object.behaviorLevel) : 0,
      wins: isSet(object.wins) ? globalThis.Number(object.wins) : 0,
      losses: isSet(object.losses) ? globalThis.Number(object.losses) : 0,
      smurfCategory: isSet(object.smurfCategory) ? globalThis.Number(object.smurfCategory) : 0,
      commScore: isSet(object.commScore) ? globalThis.Number(object.commScore) : 0,
      behaviorScore: isSet(object.behaviorScore) ? globalThis.Number(object.behaviorScore) : 0,
      rankUncertainty: isSet(object.rankUncertainty) ? globalThis.Number(object.rankUncertainty) : 0,
    };
  },

  toJSON(message: CMsgServerToGCRequestBatchPlayerResourcesResponse_Result): unknown {
    const obj: any = {};
    if (message.accountId !== undefined && message.accountId !== 0) {
      obj.accountId = Math.round(message.accountId);
    }
    if (message.rank !== undefined && message.rank !== 0) {
      obj.rank = Math.round(message.rank);
    }
    if (message.rankCalibrated !== undefined && message.rankCalibrated !== false) {
      obj.rankCalibrated = message.rankCalibrated;
    }
    if (message.lowPriority !== undefined && message.lowPriority !== false) {
      obj.lowPriority = message.lowPriority;
    }
    if (message.isNewPlayer !== undefined && message.isNewPlayer !== false) {
      obj.isNewPlayer = message.isNewPlayer;
    }
    if (message.isGuidePlayer !== undefined && message.isGuidePlayer !== false) {
      obj.isGuidePlayer = message.isGuidePlayer;
    }
    if (message.commLevel !== undefined && message.commLevel !== 0) {
      obj.commLevel = Math.round(message.commLevel);
    }
    if (message.behaviorLevel !== undefined && message.behaviorLevel !== 0) {
      obj.behaviorLevel = Math.round(message.behaviorLevel);
    }
    if (message.wins !== undefined && message.wins !== 0) {
      obj.wins = Math.round(message.wins);
    }
    if (message.losses !== undefined && message.losses !== 0) {
      obj.losses = Math.round(message.losses);
    }
    if (message.smurfCategory !== undefined && message.smurfCategory !== 0) {
      obj.smurfCategory = Math.round(message.smurfCategory);
    }
    if (message.commScore !== undefined && message.commScore !== 0) {
      obj.commScore = Math.round(message.commScore);
    }
    if (message.behaviorScore !== undefined && message.behaviorScore !== 0) {
      obj.behaviorScore = Math.round(message.behaviorScore);
    }
    if (message.rankUncertainty !== undefined && message.rankUncertainty !== 0) {
      obj.rankUncertainty = Math.round(message.rankUncertainty);
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgServerToGCRequestBatchPlayerResourcesResponse_Result>,
  ): CMsgServerToGCRequestBatchPlayerResourcesResponse_Result {
    return CMsgServerToGCRequestBatchPlayerResourcesResponse_Result.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgServerToGCRequestBatchPlayerResourcesResponse_Result>,
  ): CMsgServerToGCRequestBatchPlayerResourcesResponse_Result {
    const message = createBaseCMsgServerToGCRequestBatchPlayerResourcesResponse_Result();
    message.accountId = object.accountId ?? 0;
    message.rank = object.rank ?? 0;
    message.rankCalibrated = object.rankCalibrated ?? false;
    message.lowPriority = object.lowPriority ?? false;
    message.isNewPlayer = object.isNewPlayer ?? false;
    message.isGuidePlayer = object.isGuidePlayer ?? false;
    message.commLevel = object.commLevel ?? 0;
    message.behaviorLevel = object.behaviorLevel ?? 0;
    message.wins = object.wins ?? 0;
    message.losses = object.losses ?? 0;
    message.smurfCategory = object.smurfCategory ?? 0;
    message.commScore = object.commScore ?? 0;
    message.behaviorScore = object.behaviorScore ?? 0;
    message.rankUncertainty = object.rankUncertainty ?? 0;
    return message;
  },
};

function createBaseCMsgDOTAPlayerFailedToConnect(): CMsgDOTAPlayerFailedToConnect {
  return { failedLoaders: [], abandonedLoaders: [] };
}

export const CMsgDOTAPlayerFailedToConnect = {
  encode(message: CMsgDOTAPlayerFailedToConnect, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.failedLoaders) {
      writer.fixed64(v);
    }
    writer.ldelim();
    writer.uint32(18).fork();
    for (const v of message.abandonedLoaders) {
      writer.fixed64(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTAPlayerFailedToConnect {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAPlayerFailedToConnect();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 9) {
            message.failedLoaders.push(longToString(reader.fixed64() as Long));

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.failedLoaders.push(longToString(reader.fixed64() as Long));
            }

            continue;
          }

          break;
        case 2:
          if (tag === 17) {
            message.abandonedLoaders.push(longToString(reader.fixed64() as Long));

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.abandonedLoaders.push(longToString(reader.fixed64() as Long));
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAPlayerFailedToConnect {
    return {
      failedLoaders: globalThis.Array.isArray(object?.failedLoaders)
        ? object.failedLoaders.map((e: any) => globalThis.String(e))
        : [],
      abandonedLoaders: globalThis.Array.isArray(object?.abandonedLoaders)
        ? object.abandonedLoaders.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: CMsgDOTAPlayerFailedToConnect): unknown {
    const obj: any = {};
    if (message.failedLoaders?.length) {
      obj.failedLoaders = message.failedLoaders;
    }
    if (message.abandonedLoaders?.length) {
      obj.abandonedLoaders = message.abandonedLoaders;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTAPlayerFailedToConnect>): CMsgDOTAPlayerFailedToConnect {
    return CMsgDOTAPlayerFailedToConnect.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTAPlayerFailedToConnect>): CMsgDOTAPlayerFailedToConnect {
    const message = createBaseCMsgDOTAPlayerFailedToConnect();
    message.failedLoaders = object.failedLoaders?.map((e) => e) || [];
    message.abandonedLoaders = object.abandonedLoaders?.map((e) => e) || [];
    return message;
  },
};

function createBaseCMsgGCToRelayConnect(): CMsgGCToRelayConnect {
  return {
    sourceTvPublicAddr: 0,
    sourceTvPrivateAddr: 0,
    sourceTvPort: 0,
    gameServerSteamId: "0",
    parentCount: 0,
    tvUniqueSecretCode: "0",
    sourceTvSteamid: "0",
  };
}

export const CMsgGCToRelayConnect = {
  encode(message: CMsgGCToRelayConnect, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sourceTvPublicAddr !== undefined && message.sourceTvPublicAddr !== 0) {
      writer.uint32(8).uint32(message.sourceTvPublicAddr);
    }
    if (message.sourceTvPrivateAddr !== undefined && message.sourceTvPrivateAddr !== 0) {
      writer.uint32(16).uint32(message.sourceTvPrivateAddr);
    }
    if (message.sourceTvPort !== undefined && message.sourceTvPort !== 0) {
      writer.uint32(24).uint32(message.sourceTvPort);
    }
    if (message.gameServerSteamId !== undefined && message.gameServerSteamId !== "0") {
      writer.uint32(32).uint64(message.gameServerSteamId);
    }
    if (message.parentCount !== undefined && message.parentCount !== 0) {
      writer.uint32(40).uint32(message.parentCount);
    }
    if (message.tvUniqueSecretCode !== undefined && message.tvUniqueSecretCode !== "0") {
      writer.uint32(49).fixed64(message.tvUniqueSecretCode);
    }
    if (message.sourceTvSteamid !== undefined && message.sourceTvSteamid !== "0") {
      writer.uint32(57).fixed64(message.sourceTvSteamid);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToRelayConnect {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToRelayConnect();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.sourceTvPublicAddr = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.sourceTvPrivateAddr = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.sourceTvPort = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.gameServerSteamId = longToString(reader.uint64() as Long);
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.parentCount = reader.uint32();
          continue;
        case 6:
          if (tag !== 49) {
            break;
          }

          message.tvUniqueSecretCode = longToString(reader.fixed64() as Long);
          continue;
        case 7:
          if (tag !== 57) {
            break;
          }

          message.sourceTvSteamid = longToString(reader.fixed64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToRelayConnect {
    return {
      sourceTvPublicAddr: isSet(object.sourceTvPublicAddr) ? globalThis.Number(object.sourceTvPublicAddr) : 0,
      sourceTvPrivateAddr: isSet(object.sourceTvPrivateAddr) ? globalThis.Number(object.sourceTvPrivateAddr) : 0,
      sourceTvPort: isSet(object.sourceTvPort) ? globalThis.Number(object.sourceTvPort) : 0,
      gameServerSteamId: isSet(object.gameServerSteamId) ? globalThis.String(object.gameServerSteamId) : "0",
      parentCount: isSet(object.parentCount) ? globalThis.Number(object.parentCount) : 0,
      tvUniqueSecretCode: isSet(object.tvUniqueSecretCode) ? globalThis.String(object.tvUniqueSecretCode) : "0",
      sourceTvSteamid: isSet(object.sourceTvSteamid) ? globalThis.String(object.sourceTvSteamid) : "0",
    };
  },

  toJSON(message: CMsgGCToRelayConnect): unknown {
    const obj: any = {};
    if (message.sourceTvPublicAddr !== undefined && message.sourceTvPublicAddr !== 0) {
      obj.sourceTvPublicAddr = Math.round(message.sourceTvPublicAddr);
    }
    if (message.sourceTvPrivateAddr !== undefined && message.sourceTvPrivateAddr !== 0) {
      obj.sourceTvPrivateAddr = Math.round(message.sourceTvPrivateAddr);
    }
    if (message.sourceTvPort !== undefined && message.sourceTvPort !== 0) {
      obj.sourceTvPort = Math.round(message.sourceTvPort);
    }
    if (message.gameServerSteamId !== undefined && message.gameServerSteamId !== "0") {
      obj.gameServerSteamId = message.gameServerSteamId;
    }
    if (message.parentCount !== undefined && message.parentCount !== 0) {
      obj.parentCount = Math.round(message.parentCount);
    }
    if (message.tvUniqueSecretCode !== undefined && message.tvUniqueSecretCode !== "0") {
      obj.tvUniqueSecretCode = message.tvUniqueSecretCode;
    }
    if (message.sourceTvSteamid !== undefined && message.sourceTvSteamid !== "0") {
      obj.sourceTvSteamid = message.sourceTvSteamid;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCToRelayConnect>): CMsgGCToRelayConnect {
    return CMsgGCToRelayConnect.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCToRelayConnect>): CMsgGCToRelayConnect {
    const message = createBaseCMsgGCToRelayConnect();
    message.sourceTvPublicAddr = object.sourceTvPublicAddr ?? 0;
    message.sourceTvPrivateAddr = object.sourceTvPrivateAddr ?? 0;
    message.sourceTvPort = object.sourceTvPort ?? 0;
    message.gameServerSteamId = object.gameServerSteamId ?? "0";
    message.parentCount = object.parentCount ?? 0;
    message.tvUniqueSecretCode = object.tvUniqueSecretCode ?? "0";
    message.sourceTvSteamid = object.sourceTvSteamid ?? "0";
    return message;
  },
};

function createBaseCMsgGCGCToLANServerRelayConnect(): CMsgGCGCToLANServerRelayConnect {
  return { relaySteamid: "0" };
}

export const CMsgGCGCToLANServerRelayConnect = {
  encode(message: CMsgGCGCToLANServerRelayConnect, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.relaySteamid !== undefined && message.relaySteamid !== "0") {
      writer.uint32(9).fixed64(message.relaySteamid);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCGCToLANServerRelayConnect {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCGCToLANServerRelayConnect();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.relaySteamid = longToString(reader.fixed64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCGCToLANServerRelayConnect {
    return { relaySteamid: isSet(object.relaySteamid) ? globalThis.String(object.relaySteamid) : "0" };
  },

  toJSON(message: CMsgGCGCToLANServerRelayConnect): unknown {
    const obj: any = {};
    if (message.relaySteamid !== undefined && message.relaySteamid !== "0") {
      obj.relaySteamid = message.relaySteamid;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCGCToLANServerRelayConnect>): CMsgGCGCToLANServerRelayConnect {
    return CMsgGCGCToLANServerRelayConnect.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCGCToLANServerRelayConnect>): CMsgGCGCToLANServerRelayConnect {
    const message = createBaseCMsgGCGCToLANServerRelayConnect();
    message.relaySteamid = object.relaySteamid ?? "0";
    return message;
  },
};

function createBaseCMsgGCBanStatusRequest(): CMsgGCBanStatusRequest {
  return { accountId: 0 };
}

export const CMsgGCBanStatusRequest = {
  encode(message: CMsgGCBanStatusRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.accountId !== undefined && message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCBanStatusRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCBanStatusRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCBanStatusRequest {
    return { accountId: isSet(object.accountId) ? globalThis.Number(object.accountId) : 0 };
  },

  toJSON(message: CMsgGCBanStatusRequest): unknown {
    const obj: any = {};
    if (message.accountId !== undefined && message.accountId !== 0) {
      obj.accountId = Math.round(message.accountId);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCBanStatusRequest>): CMsgGCBanStatusRequest {
    return CMsgGCBanStatusRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCBanStatusRequest>): CMsgGCBanStatusRequest {
    const message = createBaseCMsgGCBanStatusRequest();
    message.accountId = object.accountId ?? 0;
    return message;
  },
};

function createBaseCMsgGCBanStatusResponse(): CMsgGCBanStatusResponse {
  return { result: 0, lowPriority: false, textChatBanned: false, voiceChatBanned: false };
}

export const CMsgGCBanStatusResponse = {
  encode(message: CMsgGCBanStatusResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result !== undefined && message.result !== 0) {
      writer.uint32(8).uint32(message.result);
    }
    if (message.lowPriority !== undefined && message.lowPriority !== false) {
      writer.uint32(16).bool(message.lowPriority);
    }
    if (message.textChatBanned !== undefined && message.textChatBanned !== false) {
      writer.uint32(24).bool(message.textChatBanned);
    }
    if (message.voiceChatBanned !== undefined && message.voiceChatBanned !== false) {
      writer.uint32(32).bool(message.voiceChatBanned);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCBanStatusResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCBanStatusResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.result = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.lowPriority = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.textChatBanned = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.voiceChatBanned = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCBanStatusResponse {
    return {
      result: isSet(object.result) ? globalThis.Number(object.result) : 0,
      lowPriority: isSet(object.lowPriority) ? globalThis.Boolean(object.lowPriority) : false,
      textChatBanned: isSet(object.textChatBanned) ? globalThis.Boolean(object.textChatBanned) : false,
      voiceChatBanned: isSet(object.voiceChatBanned) ? globalThis.Boolean(object.voiceChatBanned) : false,
    };
  },

  toJSON(message: CMsgGCBanStatusResponse): unknown {
    const obj: any = {};
    if (message.result !== undefined && message.result !== 0) {
      obj.result = Math.round(message.result);
    }
    if (message.lowPriority !== undefined && message.lowPriority !== false) {
      obj.lowPriority = message.lowPriority;
    }
    if (message.textChatBanned !== undefined && message.textChatBanned !== false) {
      obj.textChatBanned = message.textChatBanned;
    }
    if (message.voiceChatBanned !== undefined && message.voiceChatBanned !== false) {
      obj.voiceChatBanned = message.voiceChatBanned;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCBanStatusResponse>): CMsgGCBanStatusResponse {
    return CMsgGCBanStatusResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCBanStatusResponse>): CMsgGCBanStatusResponse {
    const message = createBaseCMsgGCBanStatusResponse();
    message.result = object.result ?? 0;
    message.lowPriority = object.lowPriority ?? false;
    message.textChatBanned = object.textChatBanned ?? false;
    message.voiceChatBanned = object.voiceChatBanned ?? false;
    return message;
  },
};

function createBaseCMsgTournamentItemEvent(): CMsgTournamentItemEvent {
  return {
    killerAccountId: 0,
    victimAccountId: 0,
    eventType: 0,
    tvDelay: 0,
    dotaTime: 0,
    replayTime: 0,
    lootList: "",
    eventTeam: 0,
    multiKillCount: 0,
    winnerScore: 0,
    loserScore: 0,
    heroStatues: [],
  };
}

export const CMsgTournamentItemEvent = {
  encode(message: CMsgTournamentItemEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.killerAccountId !== undefined && message.killerAccountId !== 0) {
      writer.uint32(13).fixed32(message.killerAccountId);
    }
    if (message.victimAccountId !== undefined && message.victimAccountId !== 0) {
      writer.uint32(21).fixed32(message.victimAccountId);
    }
    if (message.eventType !== undefined && message.eventType !== 0) {
      writer.uint32(24).int32(message.eventType);
    }
    if (message.tvDelay !== undefined && message.tvDelay !== 0) {
      writer.uint32(32).int32(message.tvDelay);
    }
    if (message.dotaTime !== undefined && message.dotaTime !== 0) {
      writer.uint32(40).int32(message.dotaTime);
    }
    if (message.replayTime !== undefined && message.replayTime !== 0) {
      writer.uint32(53).float(message.replayTime);
    }
    if (message.lootList !== undefined && message.lootList !== "") {
      writer.uint32(58).string(message.lootList);
    }
    if (message.eventTeam !== undefined && message.eventTeam !== 0) {
      writer.uint32(64).uint32(message.eventTeam);
    }
    if (message.multiKillCount !== undefined && message.multiKillCount !== 0) {
      writer.uint32(72).uint32(message.multiKillCount);
    }
    if (message.winnerScore !== undefined && message.winnerScore !== 0) {
      writer.uint32(80).uint32(message.winnerScore);
    }
    if (message.loserScore !== undefined && message.loserScore !== 0) {
      writer.uint32(88).uint32(message.loserScore);
    }
    for (const v of message.heroStatues) {
      CProtoItemHeroStatue.encode(v!, writer.uint32(98).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgTournamentItemEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgTournamentItemEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.killerAccountId = reader.fixed32();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.victimAccountId = reader.fixed32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.eventType = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.tvDelay = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.dotaTime = reader.int32();
          continue;
        case 6:
          if (tag !== 53) {
            break;
          }

          message.replayTime = reader.float();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.lootList = reader.string();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.eventTeam = reader.uint32();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.multiKillCount = reader.uint32();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.winnerScore = reader.uint32();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.loserScore = reader.uint32();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.heroStatues.push(CProtoItemHeroStatue.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgTournamentItemEvent {
    return {
      killerAccountId: isSet(object.killerAccountId) ? globalThis.Number(object.killerAccountId) : 0,
      victimAccountId: isSet(object.victimAccountId) ? globalThis.Number(object.victimAccountId) : 0,
      eventType: isSet(object.eventType) ? dOTATournamentEventsFromJSON(object.eventType) : 0,
      tvDelay: isSet(object.tvDelay) ? globalThis.Number(object.tvDelay) : 0,
      dotaTime: isSet(object.dotaTime) ? globalThis.Number(object.dotaTime) : 0,
      replayTime: isSet(object.replayTime) ? globalThis.Number(object.replayTime) : 0,
      lootList: isSet(object.lootList) ? globalThis.String(object.lootList) : "",
      eventTeam: isSet(object.eventTeam) ? globalThis.Number(object.eventTeam) : 0,
      multiKillCount: isSet(object.multiKillCount) ? globalThis.Number(object.multiKillCount) : 0,
      winnerScore: isSet(object.winnerScore) ? globalThis.Number(object.winnerScore) : 0,
      loserScore: isSet(object.loserScore) ? globalThis.Number(object.loserScore) : 0,
      heroStatues: globalThis.Array.isArray(object?.heroStatues)
        ? object.heroStatues.map((e: any) => CProtoItemHeroStatue.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgTournamentItemEvent): unknown {
    const obj: any = {};
    if (message.killerAccountId !== undefined && message.killerAccountId !== 0) {
      obj.killerAccountId = Math.round(message.killerAccountId);
    }
    if (message.victimAccountId !== undefined && message.victimAccountId !== 0) {
      obj.victimAccountId = Math.round(message.victimAccountId);
    }
    if (message.eventType !== undefined && message.eventType !== 0) {
      obj.eventType = dOTATournamentEventsToJSON(message.eventType);
    }
    if (message.tvDelay !== undefined && message.tvDelay !== 0) {
      obj.tvDelay = Math.round(message.tvDelay);
    }
    if (message.dotaTime !== undefined && message.dotaTime !== 0) {
      obj.dotaTime = Math.round(message.dotaTime);
    }
    if (message.replayTime !== undefined && message.replayTime !== 0) {
      obj.replayTime = message.replayTime;
    }
    if (message.lootList !== undefined && message.lootList !== "") {
      obj.lootList = message.lootList;
    }
    if (message.eventTeam !== undefined && message.eventTeam !== 0) {
      obj.eventTeam = Math.round(message.eventTeam);
    }
    if (message.multiKillCount !== undefined && message.multiKillCount !== 0) {
      obj.multiKillCount = Math.round(message.multiKillCount);
    }
    if (message.winnerScore !== undefined && message.winnerScore !== 0) {
      obj.winnerScore = Math.round(message.winnerScore);
    }
    if (message.loserScore !== undefined && message.loserScore !== 0) {
      obj.loserScore = Math.round(message.loserScore);
    }
    if (message.heroStatues?.length) {
      obj.heroStatues = message.heroStatues.map((e) => CProtoItemHeroStatue.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgTournamentItemEvent>): CMsgTournamentItemEvent {
    return CMsgTournamentItemEvent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgTournamentItemEvent>): CMsgTournamentItemEvent {
    const message = createBaseCMsgTournamentItemEvent();
    message.killerAccountId = object.killerAccountId ?? 0;
    message.victimAccountId = object.victimAccountId ?? 0;
    message.eventType = object.eventType ?? 0;
    message.tvDelay = object.tvDelay ?? 0;
    message.dotaTime = object.dotaTime ?? 0;
    message.replayTime = object.replayTime ?? 0;
    message.lootList = object.lootList ?? "";
    message.eventTeam = object.eventTeam ?? 0;
    message.multiKillCount = object.multiKillCount ?? 0;
    message.winnerScore = object.winnerScore ?? 0;
    message.loserScore = object.loserScore ?? 0;
    message.heroStatues = object.heroStatues?.map((e) => CProtoItemHeroStatue.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgTournamentItemEventResponse(): CMsgTournamentItemEventResponse {
  return { eventType: 0, viewersGranted: 0 };
}

export const CMsgTournamentItemEventResponse = {
  encode(message: CMsgTournamentItemEventResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.eventType !== undefined && message.eventType !== 0) {
      writer.uint32(8).int32(message.eventType);
    }
    if (message.viewersGranted !== undefined && message.viewersGranted !== 0) {
      writer.uint32(48).uint32(message.viewersGranted);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgTournamentItemEventResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgTournamentItemEventResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.eventType = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.viewersGranted = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgTournamentItemEventResponse {
    return {
      eventType: isSet(object.eventType) ? dOTATournamentEventsFromJSON(object.eventType) : 0,
      viewersGranted: isSet(object.viewersGranted) ? globalThis.Number(object.viewersGranted) : 0,
    };
  },

  toJSON(message: CMsgTournamentItemEventResponse): unknown {
    const obj: any = {};
    if (message.eventType !== undefined && message.eventType !== 0) {
      obj.eventType = dOTATournamentEventsToJSON(message.eventType);
    }
    if (message.viewersGranted !== undefined && message.viewersGranted !== 0) {
      obj.viewersGranted = Math.round(message.viewersGranted);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgTournamentItemEventResponse>): CMsgTournamentItemEventResponse {
    return CMsgTournamentItemEventResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgTournamentItemEventResponse>): CMsgTournamentItemEventResponse {
    const message = createBaseCMsgTournamentItemEventResponse();
    message.eventType = object.eventType ?? 0;
    message.viewersGranted = object.viewersGranted ?? 0;
    return message;
  },
};

function createBaseCMsgTeamFanfare(): CMsgTeamFanfare {
  return { matchId: "0" };
}

export const CMsgTeamFanfare = {
  encode(message: CMsgTeamFanfare, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.matchId !== undefined && message.matchId !== "0") {
      writer.uint32(8).uint64(message.matchId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgTeamFanfare {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgTeamFanfare();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.matchId = longToString(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgTeamFanfare {
    return { matchId: isSet(object.matchId) ? globalThis.String(object.matchId) : "0" };
  },

  toJSON(message: CMsgTeamFanfare): unknown {
    const obj: any = {};
    if (message.matchId !== undefined && message.matchId !== "0") {
      obj.matchId = message.matchId;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgTeamFanfare>): CMsgTeamFanfare {
    return CMsgTeamFanfare.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgTeamFanfare>): CMsgTeamFanfare {
    const message = createBaseCMsgTeamFanfare();
    message.matchId = object.matchId ?? "0";
    return message;
  },
};

function createBaseCMsgResponseTeamFanfare(): CMsgResponseTeamFanfare {
  return { fanfareGoodguys: 0, fanfareBadguys: 0 };
}

export const CMsgResponseTeamFanfare = {
  encode(message: CMsgResponseTeamFanfare, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.fanfareGoodguys !== undefined && message.fanfareGoodguys !== 0) {
      writer.uint32(8).uint32(message.fanfareGoodguys);
    }
    if (message.fanfareBadguys !== undefined && message.fanfareBadguys !== 0) {
      writer.uint32(16).uint32(message.fanfareBadguys);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgResponseTeamFanfare {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgResponseTeamFanfare();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.fanfareGoodguys = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.fanfareBadguys = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgResponseTeamFanfare {
    return {
      fanfareGoodguys: isSet(object.fanfareGoodguys) ? globalThis.Number(object.fanfareGoodguys) : 0,
      fanfareBadguys: isSet(object.fanfareBadguys) ? globalThis.Number(object.fanfareBadguys) : 0,
    };
  },

  toJSON(message: CMsgResponseTeamFanfare): unknown {
    const obj: any = {};
    if (message.fanfareGoodguys !== undefined && message.fanfareGoodguys !== 0) {
      obj.fanfareGoodguys = Math.round(message.fanfareGoodguys);
    }
    if (message.fanfareBadguys !== undefined && message.fanfareBadguys !== 0) {
      obj.fanfareBadguys = Math.round(message.fanfareBadguys);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgResponseTeamFanfare>): CMsgResponseTeamFanfare {
    return CMsgResponseTeamFanfare.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgResponseTeamFanfare>): CMsgResponseTeamFanfare {
    const message = createBaseCMsgResponseTeamFanfare();
    message.fanfareGoodguys = object.fanfareGoodguys ?? 0;
    message.fanfareBadguys = object.fanfareBadguys ?? 0;
    return message;
  },
};

function createBaseCMsgDOTAAwardEventPoints(): CMsgDOTAAwardEventPoints {
  return { awardPoints: [], matchId: "0", eventId: 0, timestamp: 0, auditAction: 0 };
}

export const CMsgDOTAAwardEventPoints = {
  encode(message: CMsgDOTAAwardEventPoints, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.awardPoints) {
      CMsgDOTAAwardEventPoints_AwardPoints.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.matchId !== undefined && message.matchId !== "0") {
      writer.uint32(16).uint64(message.matchId);
    }
    if (message.eventId !== undefined && message.eventId !== 0) {
      writer.uint32(32).int32(message.eventId);
    }
    if (message.timestamp !== undefined && message.timestamp !== 0) {
      writer.uint32(40).uint32(message.timestamp);
    }
    if (message.auditAction !== undefined && message.auditAction !== 0) {
      writer.uint32(48).uint32(message.auditAction);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTAAwardEventPoints {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAAwardEventPoints();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.awardPoints.push(CMsgDOTAAwardEventPoints_AwardPoints.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.matchId = longToString(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.eventId = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.timestamp = reader.uint32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.auditAction = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAAwardEventPoints {
    return {
      awardPoints: globalThis.Array.isArray(object?.awardPoints)
        ? object.awardPoints.map((e: any) => CMsgDOTAAwardEventPoints_AwardPoints.fromJSON(e))
        : [],
      matchId: isSet(object.matchId) ? globalThis.String(object.matchId) : "0",
      eventId: isSet(object.eventId) ? eEventFromJSON(object.eventId) : 0,
      timestamp: isSet(object.timestamp) ? globalThis.Number(object.timestamp) : 0,
      auditAction: isSet(object.auditAction) ? globalThis.Number(object.auditAction) : 0,
    };
  },

  toJSON(message: CMsgDOTAAwardEventPoints): unknown {
    const obj: any = {};
    if (message.awardPoints?.length) {
      obj.awardPoints = message.awardPoints.map((e) => CMsgDOTAAwardEventPoints_AwardPoints.toJSON(e));
    }
    if (message.matchId !== undefined && message.matchId !== "0") {
      obj.matchId = message.matchId;
    }
    if (message.eventId !== undefined && message.eventId !== 0) {
      obj.eventId = eEventToJSON(message.eventId);
    }
    if (message.timestamp !== undefined && message.timestamp !== 0) {
      obj.timestamp = Math.round(message.timestamp);
    }
    if (message.auditAction !== undefined && message.auditAction !== 0) {
      obj.auditAction = Math.round(message.auditAction);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTAAwardEventPoints>): CMsgDOTAAwardEventPoints {
    return CMsgDOTAAwardEventPoints.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTAAwardEventPoints>): CMsgDOTAAwardEventPoints {
    const message = createBaseCMsgDOTAAwardEventPoints();
    message.awardPoints = object.awardPoints?.map((e) => CMsgDOTAAwardEventPoints_AwardPoints.fromPartial(e)) || [];
    message.matchId = object.matchId ?? "0";
    message.eventId = object.eventId ?? 0;
    message.timestamp = object.timestamp ?? 0;
    message.auditAction = object.auditAction ?? 0;
    return message;
  },
};

function createBaseCMsgDOTAAwardEventPoints_AwardPoints(): CMsgDOTAAwardEventPoints_AwardPoints {
  return {
    accountId: 0,
    points: 0,
    premiumPoints: 0,
    tradeBanTime: 0,
    eligibleForPeriodicAdjustment: false,
    pointCapPeriodicResourceId: 0,
  };
}

export const CMsgDOTAAwardEventPoints_AwardPoints = {
  encode(message: CMsgDOTAAwardEventPoints_AwardPoints, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.accountId !== undefined && message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    if (message.points !== undefined && message.points !== 0) {
      writer.uint32(16).int32(message.points);
    }
    if (message.premiumPoints !== undefined && message.premiumPoints !== 0) {
      writer.uint32(24).int32(message.premiumPoints);
    }
    if (message.tradeBanTime !== undefined && message.tradeBanTime !== 0) {
      writer.uint32(40).uint32(message.tradeBanTime);
    }
    if (message.eligibleForPeriodicAdjustment !== undefined && message.eligibleForPeriodicAdjustment !== false) {
      writer.uint32(48).bool(message.eligibleForPeriodicAdjustment);
    }
    if (message.pointCapPeriodicResourceId !== undefined && message.pointCapPeriodicResourceId !== 0) {
      writer.uint32(56).uint32(message.pointCapPeriodicResourceId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTAAwardEventPoints_AwardPoints {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAAwardEventPoints_AwardPoints();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.points = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.premiumPoints = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.tradeBanTime = reader.uint32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.eligibleForPeriodicAdjustment = reader.bool();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.pointCapPeriodicResourceId = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAAwardEventPoints_AwardPoints {
    return {
      accountId: isSet(object.accountId) ? globalThis.Number(object.accountId) : 0,
      points: isSet(object.points) ? globalThis.Number(object.points) : 0,
      premiumPoints: isSet(object.premiumPoints) ? globalThis.Number(object.premiumPoints) : 0,
      tradeBanTime: isSet(object.tradeBanTime) ? globalThis.Number(object.tradeBanTime) : 0,
      eligibleForPeriodicAdjustment: isSet(object.eligibleForPeriodicAdjustment)
        ? globalThis.Boolean(object.eligibleForPeriodicAdjustment)
        : false,
      pointCapPeriodicResourceId: isSet(object.pointCapPeriodicResourceId)
        ? globalThis.Number(object.pointCapPeriodicResourceId)
        : 0,
    };
  },

  toJSON(message: CMsgDOTAAwardEventPoints_AwardPoints): unknown {
    const obj: any = {};
    if (message.accountId !== undefined && message.accountId !== 0) {
      obj.accountId = Math.round(message.accountId);
    }
    if (message.points !== undefined && message.points !== 0) {
      obj.points = Math.round(message.points);
    }
    if (message.premiumPoints !== undefined && message.premiumPoints !== 0) {
      obj.premiumPoints = Math.round(message.premiumPoints);
    }
    if (message.tradeBanTime !== undefined && message.tradeBanTime !== 0) {
      obj.tradeBanTime = Math.round(message.tradeBanTime);
    }
    if (message.eligibleForPeriodicAdjustment !== undefined && message.eligibleForPeriodicAdjustment !== false) {
      obj.eligibleForPeriodicAdjustment = message.eligibleForPeriodicAdjustment;
    }
    if (message.pointCapPeriodicResourceId !== undefined && message.pointCapPeriodicResourceId !== 0) {
      obj.pointCapPeriodicResourceId = Math.round(message.pointCapPeriodicResourceId);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTAAwardEventPoints_AwardPoints>): CMsgDOTAAwardEventPoints_AwardPoints {
    return CMsgDOTAAwardEventPoints_AwardPoints.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTAAwardEventPoints_AwardPoints>): CMsgDOTAAwardEventPoints_AwardPoints {
    const message = createBaseCMsgDOTAAwardEventPoints_AwardPoints();
    message.accountId = object.accountId ?? 0;
    message.points = object.points ?? 0;
    message.premiumPoints = object.premiumPoints ?? 0;
    message.tradeBanTime = object.tradeBanTime ?? 0;
    message.eligibleForPeriodicAdjustment = object.eligibleForPeriodicAdjustment ?? false;
    message.pointCapPeriodicResourceId = object.pointCapPeriodicResourceId ?? 0;
    return message;
  },
};

function createBaseCMsgGCToServerPingRequest(): CMsgGCToServerPingRequest {
  return { requestId: "0", requestTime: "0" };
}

export const CMsgGCToServerPingRequest = {
  encode(message: CMsgGCToServerPingRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.requestId !== undefined && message.requestId !== "0") {
      writer.uint32(9).fixed64(message.requestId);
    }
    if (message.requestTime !== undefined && message.requestTime !== "0") {
      writer.uint32(16).uint64(message.requestTime);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToServerPingRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToServerPingRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.requestId = longToString(reader.fixed64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.requestTime = longToString(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToServerPingRequest {
    return {
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "0",
      requestTime: isSet(object.requestTime) ? globalThis.String(object.requestTime) : "0",
    };
  },

  toJSON(message: CMsgGCToServerPingRequest): unknown {
    const obj: any = {};
    if (message.requestId !== undefined && message.requestId !== "0") {
      obj.requestId = message.requestId;
    }
    if (message.requestTime !== undefined && message.requestTime !== "0") {
      obj.requestTime = message.requestTime;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCToServerPingRequest>): CMsgGCToServerPingRequest {
    return CMsgGCToServerPingRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCToServerPingRequest>): CMsgGCToServerPingRequest {
    const message = createBaseCMsgGCToServerPingRequest();
    message.requestId = object.requestId ?? "0";
    message.requestTime = object.requestTime ?? "0";
    return message;
  },
};

function createBaseCMsgGCToServerPingResponse(): CMsgGCToServerPingResponse {
  return { requestId: "0", requestTime: "0", cluster: 0 };
}

export const CMsgGCToServerPingResponse = {
  encode(message: CMsgGCToServerPingResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.requestId !== undefined && message.requestId !== "0") {
      writer.uint32(9).fixed64(message.requestId);
    }
    if (message.requestTime !== undefined && message.requestTime !== "0") {
      writer.uint32(16).uint64(message.requestTime);
    }
    if (message.cluster !== undefined && message.cluster !== 0) {
      writer.uint32(24).uint32(message.cluster);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToServerPingResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToServerPingResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.requestId = longToString(reader.fixed64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.requestTime = longToString(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.cluster = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToServerPingResponse {
    return {
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "0",
      requestTime: isSet(object.requestTime) ? globalThis.String(object.requestTime) : "0",
      cluster: isSet(object.cluster) ? globalThis.Number(object.cluster) : 0,
    };
  },

  toJSON(message: CMsgGCToServerPingResponse): unknown {
    const obj: any = {};
    if (message.requestId !== undefined && message.requestId !== "0") {
      obj.requestId = message.requestId;
    }
    if (message.requestTime !== undefined && message.requestTime !== "0") {
      obj.requestTime = message.requestTime;
    }
    if (message.cluster !== undefined && message.cluster !== 0) {
      obj.cluster = Math.round(message.cluster);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCToServerPingResponse>): CMsgGCToServerPingResponse {
    return CMsgGCToServerPingResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCToServerPingResponse>): CMsgGCToServerPingResponse {
    const message = createBaseCMsgGCToServerPingResponse();
    message.requestId = object.requestId ?? "0";
    message.requestTime = object.requestTime ?? "0";
    message.cluster = object.cluster ?? 0;
    return message;
  },
};

function createBaseCMsgServerToGCMatchConnectionStats(): CMsgServerToGCMatchConnectionStats {
  return { matchId: "0", regionId: 0, leagueId: 0, players: [], clusterId: 0 };
}

export const CMsgServerToGCMatchConnectionStats = {
  encode(message: CMsgServerToGCMatchConnectionStats, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.matchId !== undefined && message.matchId !== "0") {
      writer.uint32(8).uint64(message.matchId);
    }
    if (message.regionId !== undefined && message.regionId !== 0) {
      writer.uint32(16).uint32(message.regionId);
    }
    if (message.leagueId !== undefined && message.leagueId !== 0) {
      writer.uint32(24).uint32(message.leagueId);
    }
    for (const v of message.players) {
      CMsgServerToGCMatchConnectionStats_Player.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    if (message.clusterId !== undefined && message.clusterId !== 0) {
      writer.uint32(40).uint32(message.clusterId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgServerToGCMatchConnectionStats {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgServerToGCMatchConnectionStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.matchId = longToString(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.regionId = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.leagueId = reader.uint32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.players.push(CMsgServerToGCMatchConnectionStats_Player.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.clusterId = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgServerToGCMatchConnectionStats {
    return {
      matchId: isSet(object.matchId) ? globalThis.String(object.matchId) : "0",
      regionId: isSet(object.regionId) ? globalThis.Number(object.regionId) : 0,
      leagueId: isSet(object.leagueId) ? globalThis.Number(object.leagueId) : 0,
      players: globalThis.Array.isArray(object?.players)
        ? object.players.map((e: any) => CMsgServerToGCMatchConnectionStats_Player.fromJSON(e))
        : [],
      clusterId: isSet(object.clusterId) ? globalThis.Number(object.clusterId) : 0,
    };
  },

  toJSON(message: CMsgServerToGCMatchConnectionStats): unknown {
    const obj: any = {};
    if (message.matchId !== undefined && message.matchId !== "0") {
      obj.matchId = message.matchId;
    }
    if (message.regionId !== undefined && message.regionId !== 0) {
      obj.regionId = Math.round(message.regionId);
    }
    if (message.leagueId !== undefined && message.leagueId !== 0) {
      obj.leagueId = Math.round(message.leagueId);
    }
    if (message.players?.length) {
      obj.players = message.players.map((e) => CMsgServerToGCMatchConnectionStats_Player.toJSON(e));
    }
    if (message.clusterId !== undefined && message.clusterId !== 0) {
      obj.clusterId = Math.round(message.clusterId);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgServerToGCMatchConnectionStats>): CMsgServerToGCMatchConnectionStats {
    return CMsgServerToGCMatchConnectionStats.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgServerToGCMatchConnectionStats>): CMsgServerToGCMatchConnectionStats {
    const message = createBaseCMsgServerToGCMatchConnectionStats();
    message.matchId = object.matchId ?? "0";
    message.regionId = object.regionId ?? 0;
    message.leagueId = object.leagueId ?? 0;
    message.players = object.players?.map((e) => CMsgServerToGCMatchConnectionStats_Player.fromPartial(e)) || [];
    message.clusterId = object.clusterId ?? 0;
    return message;
  },
};

function createBaseCMsgServerToGCMatchConnectionStats_Player(): CMsgServerToGCMatchConnectionStats_Player {
  return { accountId: 0, ip: 0, avgPingMs: 0, packetLoss: 0, pingDeviation: 0, fullResends: 0 };
}

export const CMsgServerToGCMatchConnectionStats_Player = {
  encode(message: CMsgServerToGCMatchConnectionStats_Player, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.accountId !== undefined && message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    if (message.ip !== undefined && message.ip !== 0) {
      writer.uint32(21).fixed32(message.ip);
    }
    if (message.avgPingMs !== undefined && message.avgPingMs !== 0) {
      writer.uint32(24).uint32(message.avgPingMs);
    }
    if (message.packetLoss !== undefined && message.packetLoss !== 0) {
      writer.uint32(45).float(message.packetLoss);
    }
    if (message.pingDeviation !== undefined && message.pingDeviation !== 0) {
      writer.uint32(53).float(message.pingDeviation);
    }
    if (message.fullResends !== undefined && message.fullResends !== 0) {
      writer.uint32(56).uint32(message.fullResends);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgServerToGCMatchConnectionStats_Player {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgServerToGCMatchConnectionStats_Player();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.ip = reader.fixed32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.avgPingMs = reader.uint32();
          continue;
        case 5:
          if (tag !== 45) {
            break;
          }

          message.packetLoss = reader.float();
          continue;
        case 6:
          if (tag !== 53) {
            break;
          }

          message.pingDeviation = reader.float();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.fullResends = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgServerToGCMatchConnectionStats_Player {
    return {
      accountId: isSet(object.accountId) ? globalThis.Number(object.accountId) : 0,
      ip: isSet(object.ip) ? globalThis.Number(object.ip) : 0,
      avgPingMs: isSet(object.avgPingMs) ? globalThis.Number(object.avgPingMs) : 0,
      packetLoss: isSet(object.packetLoss) ? globalThis.Number(object.packetLoss) : 0,
      pingDeviation: isSet(object.pingDeviation) ? globalThis.Number(object.pingDeviation) : 0,
      fullResends: isSet(object.fullResends) ? globalThis.Number(object.fullResends) : 0,
    };
  },

  toJSON(message: CMsgServerToGCMatchConnectionStats_Player): unknown {
    const obj: any = {};
    if (message.accountId !== undefined && message.accountId !== 0) {
      obj.accountId = Math.round(message.accountId);
    }
    if (message.ip !== undefined && message.ip !== 0) {
      obj.ip = Math.round(message.ip);
    }
    if (message.avgPingMs !== undefined && message.avgPingMs !== 0) {
      obj.avgPingMs = Math.round(message.avgPingMs);
    }
    if (message.packetLoss !== undefined && message.packetLoss !== 0) {
      obj.packetLoss = message.packetLoss;
    }
    if (message.pingDeviation !== undefined && message.pingDeviation !== 0) {
      obj.pingDeviation = message.pingDeviation;
    }
    if (message.fullResends !== undefined && message.fullResends !== 0) {
      obj.fullResends = Math.round(message.fullResends);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgServerToGCMatchConnectionStats_Player>): CMsgServerToGCMatchConnectionStats_Player {
    return CMsgServerToGCMatchConnectionStats_Player.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgServerToGCMatchConnectionStats_Player>,
  ): CMsgServerToGCMatchConnectionStats_Player {
    const message = createBaseCMsgServerToGCMatchConnectionStats_Player();
    message.accountId = object.accountId ?? 0;
    message.ip = object.ip ?? 0;
    message.avgPingMs = object.avgPingMs ?? 0;
    message.packetLoss = object.packetLoss ?? 0;
    message.pingDeviation = object.pingDeviation ?? 0;
    message.fullResends = object.fullResends ?? 0;
    return message;
  },
};

function createBaseCMsgServerGCUpdateSpectatorCount(): CMsgServerGCUpdateSpectatorCount {
  return { spectatorCount: 0 };
}

export const CMsgServerGCUpdateSpectatorCount = {
  encode(message: CMsgServerGCUpdateSpectatorCount, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.spectatorCount !== undefined && message.spectatorCount !== 0) {
      writer.uint32(8).uint32(message.spectatorCount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgServerGCUpdateSpectatorCount {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgServerGCUpdateSpectatorCount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.spectatorCount = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgServerGCUpdateSpectatorCount {
    return { spectatorCount: isSet(object.spectatorCount) ? globalThis.Number(object.spectatorCount) : 0 };
  },

  toJSON(message: CMsgServerGCUpdateSpectatorCount): unknown {
    const obj: any = {};
    if (message.spectatorCount !== undefined && message.spectatorCount !== 0) {
      obj.spectatorCount = Math.round(message.spectatorCount);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgServerGCUpdateSpectatorCount>): CMsgServerGCUpdateSpectatorCount {
    return CMsgServerGCUpdateSpectatorCount.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgServerGCUpdateSpectatorCount>): CMsgServerGCUpdateSpectatorCount {
    const message = createBaseCMsgServerGCUpdateSpectatorCount();
    message.spectatorCount = object.spectatorCount ?? 0;
    return message;
  },
};

function createBaseCSerializedCombatLog(): CSerializedCombatLog {
  return { version: 0, dictionary: undefined, entries: [] };
}

export const CSerializedCombatLog = {
  encode(message: CSerializedCombatLog, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.version !== undefined && message.version !== 0) {
      writer.uint32(8).uint32(message.version);
    }
    if (message.dictionary !== undefined) {
      CSerializedCombatLog_Dictionary.encode(message.dictionary, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.entries) {
      CMsgDOTACombatLogEntry.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CSerializedCombatLog {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCSerializedCombatLog();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.version = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.dictionary = CSerializedCombatLog_Dictionary.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.entries.push(CMsgDOTACombatLogEntry.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CSerializedCombatLog {
    return {
      version: isSet(object.version) ? globalThis.Number(object.version) : 0,
      dictionary: isSet(object.dictionary) ? CSerializedCombatLog_Dictionary.fromJSON(object.dictionary) : undefined,
      entries: globalThis.Array.isArray(object?.entries)
        ? object.entries.map((e: any) => CMsgDOTACombatLogEntry.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CSerializedCombatLog): unknown {
    const obj: any = {};
    if (message.version !== undefined && message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    if (message.dictionary !== undefined) {
      obj.dictionary = CSerializedCombatLog_Dictionary.toJSON(message.dictionary);
    }
    if (message.entries?.length) {
      obj.entries = message.entries.map((e) => CMsgDOTACombatLogEntry.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CSerializedCombatLog>): CSerializedCombatLog {
    return CSerializedCombatLog.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CSerializedCombatLog>): CSerializedCombatLog {
    const message = createBaseCSerializedCombatLog();
    message.version = object.version ?? 0;
    message.dictionary = (object.dictionary !== undefined && object.dictionary !== null)
      ? CSerializedCombatLog_Dictionary.fromPartial(object.dictionary)
      : undefined;
    message.entries = object.entries?.map((e) => CMsgDOTACombatLogEntry.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCSerializedCombatLog_Dictionary(): CSerializedCombatLog_Dictionary {
  return { strings: [] };
}

export const CSerializedCombatLog_Dictionary = {
  encode(message: CSerializedCombatLog_Dictionary, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.strings) {
      CSerializedCombatLog_Dictionary_DictString.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CSerializedCombatLog_Dictionary {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCSerializedCombatLog_Dictionary();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.strings.push(CSerializedCombatLog_Dictionary_DictString.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CSerializedCombatLog_Dictionary {
    return {
      strings: globalThis.Array.isArray(object?.strings)
        ? object.strings.map((e: any) => CSerializedCombatLog_Dictionary_DictString.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CSerializedCombatLog_Dictionary): unknown {
    const obj: any = {};
    if (message.strings?.length) {
      obj.strings = message.strings.map((e) => CSerializedCombatLog_Dictionary_DictString.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CSerializedCombatLog_Dictionary>): CSerializedCombatLog_Dictionary {
    return CSerializedCombatLog_Dictionary.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CSerializedCombatLog_Dictionary>): CSerializedCombatLog_Dictionary {
    const message = createBaseCSerializedCombatLog_Dictionary();
    message.strings = object.strings?.map((e) => CSerializedCombatLog_Dictionary_DictString.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCSerializedCombatLog_Dictionary_DictString(): CSerializedCombatLog_Dictionary_DictString {
  return { id: 0, value: "" };
}

export const CSerializedCombatLog_Dictionary_DictString = {
  encode(message: CSerializedCombatLog_Dictionary_DictString, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).uint32(message.id);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CSerializedCombatLog_Dictionary_DictString {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCSerializedCombatLog_Dictionary_DictString();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CSerializedCombatLog_Dictionary_DictString {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: CSerializedCombatLog_Dictionary_DictString): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<CSerializedCombatLog_Dictionary_DictString>): CSerializedCombatLog_Dictionary_DictString {
    return CSerializedCombatLog_Dictionary_DictString.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CSerializedCombatLog_Dictionary_DictString>,
  ): CSerializedCombatLog_Dictionary_DictString {
    const message = createBaseCSerializedCombatLog_Dictionary_DictString();
    message.id = object.id ?? 0;
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseCMsgServerToGCVictoryPredictions(): CMsgServerToGCVictoryPredictions {
  return { records: [] };
}

export const CMsgServerToGCVictoryPredictions = {
  encode(message: CMsgServerToGCVictoryPredictions, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.records) {
      CMsgServerToGCVictoryPredictions_Record.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgServerToGCVictoryPredictions {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgServerToGCVictoryPredictions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.records.push(CMsgServerToGCVictoryPredictions_Record.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgServerToGCVictoryPredictions {
    return {
      records: globalThis.Array.isArray(object?.records)
        ? object.records.map((e: any) => CMsgServerToGCVictoryPredictions_Record.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgServerToGCVictoryPredictions): unknown {
    const obj: any = {};
    if (message.records?.length) {
      obj.records = message.records.map((e) => CMsgServerToGCVictoryPredictions_Record.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgServerToGCVictoryPredictions>): CMsgServerToGCVictoryPredictions {
    return CMsgServerToGCVictoryPredictions.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgServerToGCVictoryPredictions>): CMsgServerToGCVictoryPredictions {
    const message = createBaseCMsgServerToGCVictoryPredictions();
    message.records = object.records?.map((e) => CMsgServerToGCVictoryPredictions_Record.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgServerToGCVictoryPredictions_PredictionItem(): CMsgServerToGCVictoryPredictions_PredictionItem {
  return { itemId: "0", itemDef: 0 };
}

export const CMsgServerToGCVictoryPredictions_PredictionItem = {
  encode(
    message: CMsgServerToGCVictoryPredictions_PredictionItem,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.itemId !== undefined && message.itemId !== "0") {
      writer.uint32(8).uint64(message.itemId);
    }
    if (message.itemDef !== undefined && message.itemDef !== 0) {
      writer.uint32(16).uint32(message.itemDef);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgServerToGCVictoryPredictions_PredictionItem {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgServerToGCVictoryPredictions_PredictionItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.itemId = longToString(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.itemDef = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgServerToGCVictoryPredictions_PredictionItem {
    return {
      itemId: isSet(object.itemId) ? globalThis.String(object.itemId) : "0",
      itemDef: isSet(object.itemDef) ? globalThis.Number(object.itemDef) : 0,
    };
  },

  toJSON(message: CMsgServerToGCVictoryPredictions_PredictionItem): unknown {
    const obj: any = {};
    if (message.itemId !== undefined && message.itemId !== "0") {
      obj.itemId = message.itemId;
    }
    if (message.itemDef !== undefined && message.itemDef !== 0) {
      obj.itemDef = Math.round(message.itemDef);
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgServerToGCVictoryPredictions_PredictionItem>,
  ): CMsgServerToGCVictoryPredictions_PredictionItem {
    return CMsgServerToGCVictoryPredictions_PredictionItem.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgServerToGCVictoryPredictions_PredictionItem>,
  ): CMsgServerToGCVictoryPredictions_PredictionItem {
    const message = createBaseCMsgServerToGCVictoryPredictions_PredictionItem();
    message.itemId = object.itemId ?? "0";
    message.itemDef = object.itemDef ?? 0;
    return message;
  },
};

function createBaseCMsgServerToGCVictoryPredictions_Record(): CMsgServerToGCVictoryPredictions_Record {
  return { accountId: 0, itemIds: [], predictionItems: [] };
}

export const CMsgServerToGCVictoryPredictions_Record = {
  encode(message: CMsgServerToGCVictoryPredictions_Record, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.accountId !== undefined && message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    writer.uint32(42).fork();
    for (const v of message.itemIds) {
      writer.uint64(v);
    }
    writer.ldelim();
    for (const v of message.predictionItems) {
      CMsgServerToGCVictoryPredictions_PredictionItem.encode(v!, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgServerToGCVictoryPredictions_Record {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgServerToGCVictoryPredictions_Record();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        case 5:
          if (tag === 40) {
            message.itemIds.push(longToString(reader.uint64() as Long));

            continue;
          }

          if (tag === 42) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.itemIds.push(longToString(reader.uint64() as Long));
            }

            continue;
          }

          break;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.predictionItems.push(CMsgServerToGCVictoryPredictions_PredictionItem.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgServerToGCVictoryPredictions_Record {
    return {
      accountId: isSet(object.accountId) ? globalThis.Number(object.accountId) : 0,
      itemIds: globalThis.Array.isArray(object?.itemIds) ? object.itemIds.map((e: any) => globalThis.String(e)) : [],
      predictionItems: globalThis.Array.isArray(object?.predictionItems)
        ? object.predictionItems.map((e: any) => CMsgServerToGCVictoryPredictions_PredictionItem.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgServerToGCVictoryPredictions_Record): unknown {
    const obj: any = {};
    if (message.accountId !== undefined && message.accountId !== 0) {
      obj.accountId = Math.round(message.accountId);
    }
    if (message.itemIds?.length) {
      obj.itemIds = message.itemIds;
    }
    if (message.predictionItems?.length) {
      obj.predictionItems = message.predictionItems.map((e) =>
        CMsgServerToGCVictoryPredictions_PredictionItem.toJSON(e)
      );
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgServerToGCVictoryPredictions_Record>): CMsgServerToGCVictoryPredictions_Record {
    return CMsgServerToGCVictoryPredictions_Record.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgServerToGCVictoryPredictions_Record>): CMsgServerToGCVictoryPredictions_Record {
    const message = createBaseCMsgServerToGCVictoryPredictions_Record();
    message.accountId = object.accountId ?? 0;
    message.itemIds = object.itemIds?.map((e) => e) || [];
    message.predictionItems =
      object.predictionItems?.map((e) => CMsgServerToGCVictoryPredictions_PredictionItem.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgServerToGCRequestStatus(): CMsgServerToGCRequestStatus {
  return {};
}

export const CMsgServerToGCRequestStatus = {
  encode(_: CMsgServerToGCRequestStatus, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgServerToGCRequestStatus {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgServerToGCRequestStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CMsgServerToGCRequestStatus {
    return {};
  },

  toJSON(_: CMsgServerToGCRequestStatus): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<CMsgServerToGCRequestStatus>): CMsgServerToGCRequestStatus {
    return CMsgServerToGCRequestStatus.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<CMsgServerToGCRequestStatus>): CMsgServerToGCRequestStatus {
    const message = createBaseCMsgServerToGCRequestStatus();
    return message;
  },
};

function createBaseCMsgServerToGCRequestStatusResponse(): CMsgServerToGCRequestStatusResponse {
  return { response: 0 };
}

export const CMsgServerToGCRequestStatusResponse = {
  encode(message: CMsgServerToGCRequestStatusResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.response !== undefined && message.response !== 0) {
      writer.uint32(8).uint32(message.response);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgServerToGCRequestStatusResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgServerToGCRequestStatusResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.response = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgServerToGCRequestStatusResponse {
    return { response: isSet(object.response) ? globalThis.Number(object.response) : 0 };
  },

  toJSON(message: CMsgServerToGCRequestStatusResponse): unknown {
    const obj: any = {};
    if (message.response !== undefined && message.response !== 0) {
      obj.response = Math.round(message.response);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgServerToGCRequestStatusResponse>): CMsgServerToGCRequestStatusResponse {
    return CMsgServerToGCRequestStatusResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgServerToGCRequestStatusResponse>): CMsgServerToGCRequestStatusResponse {
    const message = createBaseCMsgServerToGCRequestStatusResponse();
    message.response = object.response ?? 0;
    return message;
  },
};

function createBaseCMsgGCToServerEvaluateToxicChat(): CMsgGCToServerEvaluateToxicChat {
  return { targetAccountId: 0, reporterAccountId: 0 };
}

export const CMsgGCToServerEvaluateToxicChat = {
  encode(message: CMsgGCToServerEvaluateToxicChat, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.targetAccountId !== undefined && message.targetAccountId !== 0) {
      writer.uint32(8).uint32(message.targetAccountId);
    }
    if (message.reporterAccountId !== undefined && message.reporterAccountId !== 0) {
      writer.uint32(16).uint32(message.reporterAccountId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToServerEvaluateToxicChat {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToServerEvaluateToxicChat();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.targetAccountId = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.reporterAccountId = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToServerEvaluateToxicChat {
    return {
      targetAccountId: isSet(object.targetAccountId) ? globalThis.Number(object.targetAccountId) : 0,
      reporterAccountId: isSet(object.reporterAccountId) ? globalThis.Number(object.reporterAccountId) : 0,
    };
  },

  toJSON(message: CMsgGCToServerEvaluateToxicChat): unknown {
    const obj: any = {};
    if (message.targetAccountId !== undefined && message.targetAccountId !== 0) {
      obj.targetAccountId = Math.round(message.targetAccountId);
    }
    if (message.reporterAccountId !== undefined && message.reporterAccountId !== 0) {
      obj.reporterAccountId = Math.round(message.reporterAccountId);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCToServerEvaluateToxicChat>): CMsgGCToServerEvaluateToxicChat {
    return CMsgGCToServerEvaluateToxicChat.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCToServerEvaluateToxicChat>): CMsgGCToServerEvaluateToxicChat {
    const message = createBaseCMsgGCToServerEvaluateToxicChat();
    message.targetAccountId = object.targetAccountId ?? 0;
    message.reporterAccountId = object.reporterAccountId ?? 0;
    return message;
  },
};

function createBaseCMsgServerToGCEvaluateToxicChat(): CMsgServerToGCEvaluateToxicChat {
  return { targetAccountId: 0, reporterAccountId: 0, matchId: "0", timestamp: [], line: [] };
}

export const CMsgServerToGCEvaluateToxicChat = {
  encode(message: CMsgServerToGCEvaluateToxicChat, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.targetAccountId !== undefined && message.targetAccountId !== 0) {
      writer.uint32(8).uint32(message.targetAccountId);
    }
    if (message.reporterAccountId !== undefined && message.reporterAccountId !== 0) {
      writer.uint32(16).uint32(message.reporterAccountId);
    }
    if (message.matchId !== undefined && message.matchId !== "0") {
      writer.uint32(25).fixed64(message.matchId);
    }
    writer.uint32(34).fork();
    for (const v of message.timestamp) {
      writer.uint32(v);
    }
    writer.ldelim();
    for (const v of message.line) {
      writer.uint32(42).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgServerToGCEvaluateToxicChat {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgServerToGCEvaluateToxicChat();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.targetAccountId = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.reporterAccountId = reader.uint32();
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.matchId = longToString(reader.fixed64() as Long);
          continue;
        case 4:
          if (tag === 32) {
            message.timestamp.push(reader.uint32());

            continue;
          }

          if (tag === 34) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.timestamp.push(reader.uint32());
            }

            continue;
          }

          break;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.line.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgServerToGCEvaluateToxicChat {
    return {
      targetAccountId: isSet(object.targetAccountId) ? globalThis.Number(object.targetAccountId) : 0,
      reporterAccountId: isSet(object.reporterAccountId) ? globalThis.Number(object.reporterAccountId) : 0,
      matchId: isSet(object.matchId) ? globalThis.String(object.matchId) : "0",
      timestamp: globalThis.Array.isArray(object?.timestamp)
        ? object.timestamp.map((e: any) => globalThis.Number(e))
        : [],
      line: globalThis.Array.isArray(object?.line) ? object.line.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: CMsgServerToGCEvaluateToxicChat): unknown {
    const obj: any = {};
    if (message.targetAccountId !== undefined && message.targetAccountId !== 0) {
      obj.targetAccountId = Math.round(message.targetAccountId);
    }
    if (message.reporterAccountId !== undefined && message.reporterAccountId !== 0) {
      obj.reporterAccountId = Math.round(message.reporterAccountId);
    }
    if (message.matchId !== undefined && message.matchId !== "0") {
      obj.matchId = message.matchId;
    }
    if (message.timestamp?.length) {
      obj.timestamp = message.timestamp.map((e) => Math.round(e));
    }
    if (message.line?.length) {
      obj.line = message.line;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgServerToGCEvaluateToxicChat>): CMsgServerToGCEvaluateToxicChat {
    return CMsgServerToGCEvaluateToxicChat.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgServerToGCEvaluateToxicChat>): CMsgServerToGCEvaluateToxicChat {
    const message = createBaseCMsgServerToGCEvaluateToxicChat();
    message.targetAccountId = object.targetAccountId ?? 0;
    message.reporterAccountId = object.reporterAccountId ?? 0;
    message.matchId = object.matchId ?? "0";
    message.timestamp = object.timestamp?.map((e) => e) || [];
    message.line = object.line?.map((e) => e) || [];
    return message;
  },
};

function createBaseCMsgServerToGCEvaluateToxicChatResponse(): CMsgServerToGCEvaluateToxicChatResponse {
  return { targetAccountId: 0, reporterAccountId: 0, banReason: 0, banDuration: 0, toxicityScore: 0 };
}

export const CMsgServerToGCEvaluateToxicChatResponse = {
  encode(message: CMsgServerToGCEvaluateToxicChatResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.targetAccountId !== undefined && message.targetAccountId !== 0) {
      writer.uint32(8).uint32(message.targetAccountId);
    }
    if (message.reporterAccountId !== undefined && message.reporterAccountId !== 0) {
      writer.uint32(16).uint32(message.reporterAccountId);
    }
    if (message.banReason !== undefined && message.banReason !== 0) {
      writer.uint32(24).uint32(message.banReason);
    }
    if (message.banDuration !== undefined && message.banDuration !== 0) {
      writer.uint32(32).uint32(message.banDuration);
    }
    if (message.toxicityScore !== undefined && message.toxicityScore !== 0) {
      writer.uint32(45).float(message.toxicityScore);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgServerToGCEvaluateToxicChatResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgServerToGCEvaluateToxicChatResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.targetAccountId = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.reporterAccountId = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.banReason = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.banDuration = reader.uint32();
          continue;
        case 5:
          if (tag !== 45) {
            break;
          }

          message.toxicityScore = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgServerToGCEvaluateToxicChatResponse {
    return {
      targetAccountId: isSet(object.targetAccountId) ? globalThis.Number(object.targetAccountId) : 0,
      reporterAccountId: isSet(object.reporterAccountId) ? globalThis.Number(object.reporterAccountId) : 0,
      banReason: isSet(object.banReason) ? globalThis.Number(object.banReason) : 0,
      banDuration: isSet(object.banDuration) ? globalThis.Number(object.banDuration) : 0,
      toxicityScore: isSet(object.toxicityScore) ? globalThis.Number(object.toxicityScore) : 0,
    };
  },

  toJSON(message: CMsgServerToGCEvaluateToxicChatResponse): unknown {
    const obj: any = {};
    if (message.targetAccountId !== undefined && message.targetAccountId !== 0) {
      obj.targetAccountId = Math.round(message.targetAccountId);
    }
    if (message.reporterAccountId !== undefined && message.reporterAccountId !== 0) {
      obj.reporterAccountId = Math.round(message.reporterAccountId);
    }
    if (message.banReason !== undefined && message.banReason !== 0) {
      obj.banReason = Math.round(message.banReason);
    }
    if (message.banDuration !== undefined && message.banDuration !== 0) {
      obj.banDuration = Math.round(message.banDuration);
    }
    if (message.toxicityScore !== undefined && message.toxicityScore !== 0) {
      obj.toxicityScore = message.toxicityScore;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgServerToGCEvaluateToxicChatResponse>): CMsgServerToGCEvaluateToxicChatResponse {
    return CMsgServerToGCEvaluateToxicChatResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgServerToGCEvaluateToxicChatResponse>): CMsgServerToGCEvaluateToxicChatResponse {
    const message = createBaseCMsgServerToGCEvaluateToxicChatResponse();
    message.targetAccountId = object.targetAccountId ?? 0;
    message.reporterAccountId = object.reporterAccountId ?? 0;
    message.banReason = object.banReason ?? 0;
    message.banDuration = object.banDuration ?? 0;
    message.toxicityScore = object.toxicityScore ?? 0;
    return message;
  },
};

function createBaseCMsgSignOutAssassinMiniGameInfo(): CMsgSignOutAssassinMiniGameInfo {
  return {
    winningPlayers: [],
    losingPlayers: [],
    arcanaOwners: [],
    assassinWon: false,
    targetHeroId: 0,
    contractCompleted: false,
    contractCompleteTime: 0,
    paIsRadiant: false,
  };
}

export const CMsgSignOutAssassinMiniGameInfo = {
  encode(message: CMsgSignOutAssassinMiniGameInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.winningPlayers) {
      writer.fixed64(v);
    }
    writer.ldelim();
    writer.uint32(18).fork();
    for (const v of message.losingPlayers) {
      writer.fixed64(v);
    }
    writer.ldelim();
    writer.uint32(26).fork();
    for (const v of message.arcanaOwners) {
      writer.fixed64(v);
    }
    writer.ldelim();
    if (message.assassinWon !== undefined && message.assassinWon !== false) {
      writer.uint32(32).bool(message.assassinWon);
    }
    if (message.targetHeroId !== undefined && message.targetHeroId !== 0) {
      writer.uint32(40).int32(message.targetHeroId);
    }
    if (message.contractCompleted !== undefined && message.contractCompleted !== false) {
      writer.uint32(48).bool(message.contractCompleted);
    }
    if (message.contractCompleteTime !== undefined && message.contractCompleteTime !== 0) {
      writer.uint32(61).float(message.contractCompleteTime);
    }
    if (message.paIsRadiant !== undefined && message.paIsRadiant !== false) {
      writer.uint32(64).bool(message.paIsRadiant);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSignOutAssassinMiniGameInfo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSignOutAssassinMiniGameInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 9) {
            message.winningPlayers.push(longToString(reader.fixed64() as Long));

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.winningPlayers.push(longToString(reader.fixed64() as Long));
            }

            continue;
          }

          break;
        case 2:
          if (tag === 17) {
            message.losingPlayers.push(longToString(reader.fixed64() as Long));

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.losingPlayers.push(longToString(reader.fixed64() as Long));
            }

            continue;
          }

          break;
        case 3:
          if (tag === 25) {
            message.arcanaOwners.push(longToString(reader.fixed64() as Long));

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.arcanaOwners.push(longToString(reader.fixed64() as Long));
            }

            continue;
          }

          break;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.assassinWon = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.targetHeroId = reader.int32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.contractCompleted = reader.bool();
          continue;
        case 7:
          if (tag !== 61) {
            break;
          }

          message.contractCompleteTime = reader.float();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.paIsRadiant = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSignOutAssassinMiniGameInfo {
    return {
      winningPlayers: globalThis.Array.isArray(object?.winningPlayers)
        ? object.winningPlayers.map((e: any) => globalThis.String(e))
        : [],
      losingPlayers: globalThis.Array.isArray(object?.losingPlayers)
        ? object.losingPlayers.map((e: any) => globalThis.String(e))
        : [],
      arcanaOwners: globalThis.Array.isArray(object?.arcanaOwners)
        ? object.arcanaOwners.map((e: any) => globalThis.String(e))
        : [],
      assassinWon: isSet(object.assassinWon) ? globalThis.Boolean(object.assassinWon) : false,
      targetHeroId: isSet(object.targetHeroId) ? globalThis.Number(object.targetHeroId) : 0,
      contractCompleted: isSet(object.contractCompleted) ? globalThis.Boolean(object.contractCompleted) : false,
      contractCompleteTime: isSet(object.contractCompleteTime) ? globalThis.Number(object.contractCompleteTime) : 0,
      paIsRadiant: isSet(object.paIsRadiant) ? globalThis.Boolean(object.paIsRadiant) : false,
    };
  },

  toJSON(message: CMsgSignOutAssassinMiniGameInfo): unknown {
    const obj: any = {};
    if (message.winningPlayers?.length) {
      obj.winningPlayers = message.winningPlayers;
    }
    if (message.losingPlayers?.length) {
      obj.losingPlayers = message.losingPlayers;
    }
    if (message.arcanaOwners?.length) {
      obj.arcanaOwners = message.arcanaOwners;
    }
    if (message.assassinWon !== undefined && message.assassinWon !== false) {
      obj.assassinWon = message.assassinWon;
    }
    if (message.targetHeroId !== undefined && message.targetHeroId !== 0) {
      obj.targetHeroId = Math.round(message.targetHeroId);
    }
    if (message.contractCompleted !== undefined && message.contractCompleted !== false) {
      obj.contractCompleted = message.contractCompleted;
    }
    if (message.contractCompleteTime !== undefined && message.contractCompleteTime !== 0) {
      obj.contractCompleteTime = message.contractCompleteTime;
    }
    if (message.paIsRadiant !== undefined && message.paIsRadiant !== false) {
      obj.paIsRadiant = message.paIsRadiant;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSignOutAssassinMiniGameInfo>): CMsgSignOutAssassinMiniGameInfo {
    return CMsgSignOutAssassinMiniGameInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSignOutAssassinMiniGameInfo>): CMsgSignOutAssassinMiniGameInfo {
    const message = createBaseCMsgSignOutAssassinMiniGameInfo();
    message.winningPlayers = object.winningPlayers?.map((e) => e) || [];
    message.losingPlayers = object.losingPlayers?.map((e) => e) || [];
    message.arcanaOwners = object.arcanaOwners?.map((e) => e) || [];
    message.assassinWon = object.assassinWon ?? false;
    message.targetHeroId = object.targetHeroId ?? 0;
    message.contractCompleted = object.contractCompleted ?? false;
    message.contractCompleteTime = object.contractCompleteTime ?? 0;
    message.paIsRadiant = object.paIsRadiant ?? false;
    return message;
  },
};

function createBaseCMsgServerToGCKillSummaries(): CMsgServerToGCKillSummaries {
  return { ingameeventId: 0, summaries: [] };
}

export const CMsgServerToGCKillSummaries = {
  encode(message: CMsgServerToGCKillSummaries, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.ingameeventId !== undefined && message.ingameeventId !== 0) {
      writer.uint32(8).uint32(message.ingameeventId);
    }
    for (const v of message.summaries) {
      CMsgServerToGCKillSummaries_KillSummary.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgServerToGCKillSummaries {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgServerToGCKillSummaries();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.ingameeventId = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.summaries.push(CMsgServerToGCKillSummaries_KillSummary.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgServerToGCKillSummaries {
    return {
      ingameeventId: isSet(object.ingameeventId) ? globalThis.Number(object.ingameeventId) : 0,
      summaries: globalThis.Array.isArray(object?.summaries)
        ? object.summaries.map((e: any) => CMsgServerToGCKillSummaries_KillSummary.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgServerToGCKillSummaries): unknown {
    const obj: any = {};
    if (message.ingameeventId !== undefined && message.ingameeventId !== 0) {
      obj.ingameeventId = Math.round(message.ingameeventId);
    }
    if (message.summaries?.length) {
      obj.summaries = message.summaries.map((e) => CMsgServerToGCKillSummaries_KillSummary.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgServerToGCKillSummaries>): CMsgServerToGCKillSummaries {
    return CMsgServerToGCKillSummaries.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgServerToGCKillSummaries>): CMsgServerToGCKillSummaries {
    const message = createBaseCMsgServerToGCKillSummaries();
    message.ingameeventId = object.ingameeventId ?? 0;
    message.summaries = object.summaries?.map((e) => CMsgServerToGCKillSummaries_KillSummary.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgServerToGCKillSummaries_KillSummary(): CMsgServerToGCKillSummaries_KillSummary {
  return { killerHeroId: 0, victimHeroId: 0, killCount: 0 };
}

export const CMsgServerToGCKillSummaries_KillSummary = {
  encode(message: CMsgServerToGCKillSummaries_KillSummary, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.killerHeroId !== undefined && message.killerHeroId !== 0) {
      writer.uint32(8).uint32(message.killerHeroId);
    }
    if (message.victimHeroId !== undefined && message.victimHeroId !== 0) {
      writer.uint32(16).uint32(message.victimHeroId);
    }
    if (message.killCount !== undefined && message.killCount !== 0) {
      writer.uint32(24).uint32(message.killCount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgServerToGCKillSummaries_KillSummary {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgServerToGCKillSummaries_KillSummary();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.killerHeroId = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.victimHeroId = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.killCount = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgServerToGCKillSummaries_KillSummary {
    return {
      killerHeroId: isSet(object.killerHeroId) ? globalThis.Number(object.killerHeroId) : 0,
      victimHeroId: isSet(object.victimHeroId) ? globalThis.Number(object.victimHeroId) : 0,
      killCount: isSet(object.killCount) ? globalThis.Number(object.killCount) : 0,
    };
  },

  toJSON(message: CMsgServerToGCKillSummaries_KillSummary): unknown {
    const obj: any = {};
    if (message.killerHeroId !== undefined && message.killerHeroId !== 0) {
      obj.killerHeroId = Math.round(message.killerHeroId);
    }
    if (message.victimHeroId !== undefined && message.victimHeroId !== 0) {
      obj.victimHeroId = Math.round(message.victimHeroId);
    }
    if (message.killCount !== undefined && message.killCount !== 0) {
      obj.killCount = Math.round(message.killCount);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgServerToGCKillSummaries_KillSummary>): CMsgServerToGCKillSummaries_KillSummary {
    return CMsgServerToGCKillSummaries_KillSummary.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgServerToGCKillSummaries_KillSummary>): CMsgServerToGCKillSummaries_KillSummary {
    const message = createBaseCMsgServerToGCKillSummaries_KillSummary();
    message.killerHeroId = object.killerHeroId ?? 0;
    message.victimHeroId = object.victimHeroId ?? 0;
    message.killCount = object.killCount ?? 0;
    return message;
  },
};

function createBaseCMsgServerToGCLockCharmTrading(): CMsgServerToGCLockCharmTrading {
  return { accountId: 0, itemId: "0" };
}

export const CMsgServerToGCLockCharmTrading = {
  encode(message: CMsgServerToGCLockCharmTrading, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.accountId !== undefined && message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    if (message.itemId !== undefined && message.itemId !== "0") {
      writer.uint32(16).uint64(message.itemId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgServerToGCLockCharmTrading {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgServerToGCLockCharmTrading();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.itemId = longToString(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgServerToGCLockCharmTrading {
    return {
      accountId: isSet(object.accountId) ? globalThis.Number(object.accountId) : 0,
      itemId: isSet(object.itemId) ? globalThis.String(object.itemId) : "0",
    };
  },

  toJSON(message: CMsgServerToGCLockCharmTrading): unknown {
    const obj: any = {};
    if (message.accountId !== undefined && message.accountId !== 0) {
      obj.accountId = Math.round(message.accountId);
    }
    if (message.itemId !== undefined && message.itemId !== "0") {
      obj.itemId = message.itemId;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgServerToGCLockCharmTrading>): CMsgServerToGCLockCharmTrading {
    return CMsgServerToGCLockCharmTrading.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgServerToGCLockCharmTrading>): CMsgServerToGCLockCharmTrading {
    const message = createBaseCMsgServerToGCLockCharmTrading();
    message.accountId = object.accountId ?? 0;
    message.itemId = object.itemId ?? "0";
    return message;
  },
};

function createBaseCMsgSignOutUpdatePlayerChallenge(): CMsgSignOutUpdatePlayerChallenge {
  return { accountId: 0, completed: [], rerolled: [], matchId: "0", heroId: 0 };
}

export const CMsgSignOutUpdatePlayerChallenge = {
  encode(message: CMsgSignOutUpdatePlayerChallenge, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.accountId !== undefined && message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    for (const v of message.completed) {
      CMsgSignOutUpdatePlayerChallenge_Challenge.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.rerolled) {
      CMsgSignOutUpdatePlayerChallenge_Challenge.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    if (message.matchId !== undefined && message.matchId !== "0") {
      writer.uint32(32).uint64(message.matchId);
    }
    if (message.heroId !== undefined && message.heroId !== 0) {
      writer.uint32(40).int32(message.heroId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSignOutUpdatePlayerChallenge {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSignOutUpdatePlayerChallenge();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.completed.push(CMsgSignOutUpdatePlayerChallenge_Challenge.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.rerolled.push(CMsgSignOutUpdatePlayerChallenge_Challenge.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.matchId = longToString(reader.uint64() as Long);
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.heroId = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSignOutUpdatePlayerChallenge {
    return {
      accountId: isSet(object.accountId) ? globalThis.Number(object.accountId) : 0,
      completed: globalThis.Array.isArray(object?.completed)
        ? object.completed.map((e: any) => CMsgSignOutUpdatePlayerChallenge_Challenge.fromJSON(e))
        : [],
      rerolled: globalThis.Array.isArray(object?.rerolled)
        ? object.rerolled.map((e: any) => CMsgSignOutUpdatePlayerChallenge_Challenge.fromJSON(e))
        : [],
      matchId: isSet(object.matchId) ? globalThis.String(object.matchId) : "0",
      heroId: isSet(object.heroId) ? globalThis.Number(object.heroId) : 0,
    };
  },

  toJSON(message: CMsgSignOutUpdatePlayerChallenge): unknown {
    const obj: any = {};
    if (message.accountId !== undefined && message.accountId !== 0) {
      obj.accountId = Math.round(message.accountId);
    }
    if (message.completed?.length) {
      obj.completed = message.completed.map((e) => CMsgSignOutUpdatePlayerChallenge_Challenge.toJSON(e));
    }
    if (message.rerolled?.length) {
      obj.rerolled = message.rerolled.map((e) => CMsgSignOutUpdatePlayerChallenge_Challenge.toJSON(e));
    }
    if (message.matchId !== undefined && message.matchId !== "0") {
      obj.matchId = message.matchId;
    }
    if (message.heroId !== undefined && message.heroId !== 0) {
      obj.heroId = Math.round(message.heroId);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSignOutUpdatePlayerChallenge>): CMsgSignOutUpdatePlayerChallenge {
    return CMsgSignOutUpdatePlayerChallenge.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSignOutUpdatePlayerChallenge>): CMsgSignOutUpdatePlayerChallenge {
    const message = createBaseCMsgSignOutUpdatePlayerChallenge();
    message.accountId = object.accountId ?? 0;
    message.completed = object.completed?.map((e) => CMsgSignOutUpdatePlayerChallenge_Challenge.fromPartial(e)) || [];
    message.rerolled = object.rerolled?.map((e) => CMsgSignOutUpdatePlayerChallenge_Challenge.fromPartial(e)) || [];
    message.matchId = object.matchId ?? "0";
    message.heroId = object.heroId ?? 0;
    return message;
  },
};

function createBaseCMsgSignOutUpdatePlayerChallenge_Challenge(): CMsgSignOutUpdatePlayerChallenge_Challenge {
  return { eventId: 0, slotId: 0, sequenceId: 0, progress: 0, challengeRank: 0 };
}

export const CMsgSignOutUpdatePlayerChallenge_Challenge = {
  encode(message: CMsgSignOutUpdatePlayerChallenge_Challenge, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.eventId !== undefined && message.eventId !== 0) {
      writer.uint32(8).int32(message.eventId);
    }
    if (message.slotId !== undefined && message.slotId !== 0) {
      writer.uint32(16).uint32(message.slotId);
    }
    if (message.sequenceId !== undefined && message.sequenceId !== 0) {
      writer.uint32(24).uint32(message.sequenceId);
    }
    if (message.progress !== undefined && message.progress !== 0) {
      writer.uint32(32).uint32(message.progress);
    }
    if (message.challengeRank !== undefined && message.challengeRank !== 0) {
      writer.uint32(40).uint32(message.challengeRank);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSignOutUpdatePlayerChallenge_Challenge {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSignOutUpdatePlayerChallenge_Challenge();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.eventId = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.slotId = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.sequenceId = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.progress = reader.uint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.challengeRank = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSignOutUpdatePlayerChallenge_Challenge {
    return {
      eventId: isSet(object.eventId) ? eEventFromJSON(object.eventId) : 0,
      slotId: isSet(object.slotId) ? globalThis.Number(object.slotId) : 0,
      sequenceId: isSet(object.sequenceId) ? globalThis.Number(object.sequenceId) : 0,
      progress: isSet(object.progress) ? globalThis.Number(object.progress) : 0,
      challengeRank: isSet(object.challengeRank) ? globalThis.Number(object.challengeRank) : 0,
    };
  },

  toJSON(message: CMsgSignOutUpdatePlayerChallenge_Challenge): unknown {
    const obj: any = {};
    if (message.eventId !== undefined && message.eventId !== 0) {
      obj.eventId = eEventToJSON(message.eventId);
    }
    if (message.slotId !== undefined && message.slotId !== 0) {
      obj.slotId = Math.round(message.slotId);
    }
    if (message.sequenceId !== undefined && message.sequenceId !== 0) {
      obj.sequenceId = Math.round(message.sequenceId);
    }
    if (message.progress !== undefined && message.progress !== 0) {
      obj.progress = Math.round(message.progress);
    }
    if (message.challengeRank !== undefined && message.challengeRank !== 0) {
      obj.challengeRank = Math.round(message.challengeRank);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSignOutUpdatePlayerChallenge_Challenge>): CMsgSignOutUpdatePlayerChallenge_Challenge {
    return CMsgSignOutUpdatePlayerChallenge_Challenge.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgSignOutUpdatePlayerChallenge_Challenge>,
  ): CMsgSignOutUpdatePlayerChallenge_Challenge {
    const message = createBaseCMsgSignOutUpdatePlayerChallenge_Challenge();
    message.eventId = object.eventId ?? 0;
    message.slotId = object.slotId ?? 0;
    message.sequenceId = object.sequenceId ?? 0;
    message.progress = object.progress ?? 0;
    message.challengeRank = object.challengeRank ?? 0;
    return message;
  },
};

function createBaseCMsgServerToGCRerollPlayerChallenge(): CMsgServerToGCRerollPlayerChallenge {
  return { accountId: 0, rerollMsg: undefined };
}

export const CMsgServerToGCRerollPlayerChallenge = {
  encode(message: CMsgServerToGCRerollPlayerChallenge, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.accountId !== undefined && message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    if (message.rerollMsg !== undefined) {
      CMsgClientToGCRerollPlayerChallenge.encode(message.rerollMsg, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgServerToGCRerollPlayerChallenge {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgServerToGCRerollPlayerChallenge();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.rerollMsg = CMsgClientToGCRerollPlayerChallenge.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgServerToGCRerollPlayerChallenge {
    return {
      accountId: isSet(object.accountId) ? globalThis.Number(object.accountId) : 0,
      rerollMsg: isSet(object.rerollMsg) ? CMsgClientToGCRerollPlayerChallenge.fromJSON(object.rerollMsg) : undefined,
    };
  },

  toJSON(message: CMsgServerToGCRerollPlayerChallenge): unknown {
    const obj: any = {};
    if (message.accountId !== undefined && message.accountId !== 0) {
      obj.accountId = Math.round(message.accountId);
    }
    if (message.rerollMsg !== undefined) {
      obj.rerollMsg = CMsgClientToGCRerollPlayerChallenge.toJSON(message.rerollMsg);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgServerToGCRerollPlayerChallenge>): CMsgServerToGCRerollPlayerChallenge {
    return CMsgServerToGCRerollPlayerChallenge.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgServerToGCRerollPlayerChallenge>): CMsgServerToGCRerollPlayerChallenge {
    const message = createBaseCMsgServerToGCRerollPlayerChallenge();
    message.accountId = object.accountId ?? 0;
    message.rerollMsg = (object.rerollMsg !== undefined && object.rerollMsg !== null)
      ? CMsgClientToGCRerollPlayerChallenge.fromPartial(object.rerollMsg)
      : undefined;
    return message;
  },
};

function createBaseCMsgSpendWager(): CMsgSpendWager {
  return { players: [], eventId: 0, timestamp: 0, matchId: "0", serverSteamId: "0" };
}

export const CMsgSpendWager = {
  encode(message: CMsgSpendWager, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.players) {
      CMsgSpendWager_Player.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.eventId !== undefined && message.eventId !== 0) {
      writer.uint32(16).int32(message.eventId);
    }
    if (message.timestamp !== undefined && message.timestamp !== 0) {
      writer.uint32(24).uint32(message.timestamp);
    }
    if (message.matchId !== undefined && message.matchId !== "0") {
      writer.uint32(32).uint64(message.matchId);
    }
    if (message.serverSteamId !== undefined && message.serverSteamId !== "0") {
      writer.uint32(40).uint64(message.serverSteamId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSpendWager {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSpendWager();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.players.push(CMsgSpendWager_Player.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.eventId = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.timestamp = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.matchId = longToString(reader.uint64() as Long);
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.serverSteamId = longToString(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSpendWager {
    return {
      players: globalThis.Array.isArray(object?.players)
        ? object.players.map((e: any) => CMsgSpendWager_Player.fromJSON(e))
        : [],
      eventId: isSet(object.eventId) ? eEventFromJSON(object.eventId) : 0,
      timestamp: isSet(object.timestamp) ? globalThis.Number(object.timestamp) : 0,
      matchId: isSet(object.matchId) ? globalThis.String(object.matchId) : "0",
      serverSteamId: isSet(object.serverSteamId) ? globalThis.String(object.serverSteamId) : "0",
    };
  },

  toJSON(message: CMsgSpendWager): unknown {
    const obj: any = {};
    if (message.players?.length) {
      obj.players = message.players.map((e) => CMsgSpendWager_Player.toJSON(e));
    }
    if (message.eventId !== undefined && message.eventId !== 0) {
      obj.eventId = eEventToJSON(message.eventId);
    }
    if (message.timestamp !== undefined && message.timestamp !== 0) {
      obj.timestamp = Math.round(message.timestamp);
    }
    if (message.matchId !== undefined && message.matchId !== "0") {
      obj.matchId = message.matchId;
    }
    if (message.serverSteamId !== undefined && message.serverSteamId !== "0") {
      obj.serverSteamId = message.serverSteamId;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSpendWager>): CMsgSpendWager {
    return CMsgSpendWager.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSpendWager>): CMsgSpendWager {
    const message = createBaseCMsgSpendWager();
    message.players = object.players?.map((e) => CMsgSpendWager_Player.fromPartial(e)) || [];
    message.eventId = object.eventId ?? 0;
    message.timestamp = object.timestamp ?? 0;
    message.matchId = object.matchId ?? "0";
    message.serverSteamId = object.serverSteamId ?? "0";
    return message;
  },
};

function createBaseCMsgSpendWager_Player(): CMsgSpendWager_Player {
  return { accountId: 0, wager: 0, wagerTokenItemId: "0" };
}

export const CMsgSpendWager_Player = {
  encode(message: CMsgSpendWager_Player, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.accountId !== undefined && message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    if (message.wager !== undefined && message.wager !== 0) {
      writer.uint32(16).uint32(message.wager);
    }
    if (message.wagerTokenItemId !== undefined && message.wagerTokenItemId !== "0") {
      writer.uint32(24).uint64(message.wagerTokenItemId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSpendWager_Player {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSpendWager_Player();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.wager = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.wagerTokenItemId = longToString(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSpendWager_Player {
    return {
      accountId: isSet(object.accountId) ? globalThis.Number(object.accountId) : 0,
      wager: isSet(object.wager) ? globalThis.Number(object.wager) : 0,
      wagerTokenItemId: isSet(object.wagerTokenItemId) ? globalThis.String(object.wagerTokenItemId) : "0",
    };
  },

  toJSON(message: CMsgSpendWager_Player): unknown {
    const obj: any = {};
    if (message.accountId !== undefined && message.accountId !== 0) {
      obj.accountId = Math.round(message.accountId);
    }
    if (message.wager !== undefined && message.wager !== 0) {
      obj.wager = Math.round(message.wager);
    }
    if (message.wagerTokenItemId !== undefined && message.wagerTokenItemId !== "0") {
      obj.wagerTokenItemId = message.wagerTokenItemId;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSpendWager_Player>): CMsgSpendWager_Player {
    return CMsgSpendWager_Player.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSpendWager_Player>): CMsgSpendWager_Player {
    const message = createBaseCMsgSpendWager_Player();
    message.accountId = object.accountId ?? 0;
    message.wager = object.wager ?? 0;
    message.wagerTokenItemId = object.wagerTokenItemId ?? "0";
    return message;
  },
};

function createBaseCMsgSignOutXPCoins(): CMsgSignOutXPCoins {
  return { players: [], eventId: 0, matchId: "0", timestamp: 0 };
}

export const CMsgSignOutXPCoins = {
  encode(message: CMsgSignOutXPCoins, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.players) {
      CMsgSignOutXPCoins_Player.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.eventId !== undefined && message.eventId !== 0) {
      writer.uint32(16).int32(message.eventId);
    }
    if (message.matchId !== undefined && message.matchId !== "0") {
      writer.uint32(24).uint64(message.matchId);
    }
    if (message.timestamp !== undefined && message.timestamp !== 0) {
      writer.uint32(32).uint32(message.timestamp);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSignOutXPCoins {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSignOutXPCoins();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.players.push(CMsgSignOutXPCoins_Player.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.eventId = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.matchId = longToString(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.timestamp = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSignOutXPCoins {
    return {
      players: globalThis.Array.isArray(object?.players)
        ? object.players.map((e: any) => CMsgSignOutXPCoins_Player.fromJSON(e))
        : [],
      eventId: isSet(object.eventId) ? eEventFromJSON(object.eventId) : 0,
      matchId: isSet(object.matchId) ? globalThis.String(object.matchId) : "0",
      timestamp: isSet(object.timestamp) ? globalThis.Number(object.timestamp) : 0,
    };
  },

  toJSON(message: CMsgSignOutXPCoins): unknown {
    const obj: any = {};
    if (message.players?.length) {
      obj.players = message.players.map((e) => CMsgSignOutXPCoins_Player.toJSON(e));
    }
    if (message.eventId !== undefined && message.eventId !== 0) {
      obj.eventId = eEventToJSON(message.eventId);
    }
    if (message.matchId !== undefined && message.matchId !== "0") {
      obj.matchId = message.matchId;
    }
    if (message.timestamp !== undefined && message.timestamp !== 0) {
      obj.timestamp = Math.round(message.timestamp);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSignOutXPCoins>): CMsgSignOutXPCoins {
    return CMsgSignOutXPCoins.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSignOutXPCoins>): CMsgSignOutXPCoins {
    const message = createBaseCMsgSignOutXPCoins();
    message.players = object.players?.map((e) => CMsgSignOutXPCoins_Player.fromPartial(e)) || [];
    message.eventId = object.eventId ?? 0;
    message.matchId = object.matchId ?? "0";
    message.timestamp = object.timestamp ?? 0;
    return message;
  },
};

function createBaseCMsgSignOutXPCoins_Player(): CMsgSignOutXPCoins_Player {
  return { accountId: 0, xpGained: 0, coinsSpent: 0, wagerTokenItemId: "0", rankWager: 0, wagerStreak: 0 };
}

export const CMsgSignOutXPCoins_Player = {
  encode(message: CMsgSignOutXPCoins_Player, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.accountId !== undefined && message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    if (message.xpGained !== undefined && message.xpGained !== 0) {
      writer.uint32(16).uint32(message.xpGained);
    }
    if (message.coinsSpent !== undefined && message.coinsSpent !== 0) {
      writer.uint32(24).uint32(message.coinsSpent);
    }
    if (message.wagerTokenItemId !== undefined && message.wagerTokenItemId !== "0") {
      writer.uint32(32).uint64(message.wagerTokenItemId);
    }
    if (message.rankWager !== undefined && message.rankWager !== 0) {
      writer.uint32(40).uint32(message.rankWager);
    }
    if (message.wagerStreak !== undefined && message.wagerStreak !== 0) {
      writer.uint32(48).uint32(message.wagerStreak);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSignOutXPCoins_Player {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSignOutXPCoins_Player();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.xpGained = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.coinsSpent = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.wagerTokenItemId = longToString(reader.uint64() as Long);
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.rankWager = reader.uint32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.wagerStreak = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSignOutXPCoins_Player {
    return {
      accountId: isSet(object.accountId) ? globalThis.Number(object.accountId) : 0,
      xpGained: isSet(object.xpGained) ? globalThis.Number(object.xpGained) : 0,
      coinsSpent: isSet(object.coinsSpent) ? globalThis.Number(object.coinsSpent) : 0,
      wagerTokenItemId: isSet(object.wagerTokenItemId) ? globalThis.String(object.wagerTokenItemId) : "0",
      rankWager: isSet(object.rankWager) ? globalThis.Number(object.rankWager) : 0,
      wagerStreak: isSet(object.wagerStreak) ? globalThis.Number(object.wagerStreak) : 0,
    };
  },

  toJSON(message: CMsgSignOutXPCoins_Player): unknown {
    const obj: any = {};
    if (message.accountId !== undefined && message.accountId !== 0) {
      obj.accountId = Math.round(message.accountId);
    }
    if (message.xpGained !== undefined && message.xpGained !== 0) {
      obj.xpGained = Math.round(message.xpGained);
    }
    if (message.coinsSpent !== undefined && message.coinsSpent !== 0) {
      obj.coinsSpent = Math.round(message.coinsSpent);
    }
    if (message.wagerTokenItemId !== undefined && message.wagerTokenItemId !== "0") {
      obj.wagerTokenItemId = message.wagerTokenItemId;
    }
    if (message.rankWager !== undefined && message.rankWager !== 0) {
      obj.rankWager = Math.round(message.rankWager);
    }
    if (message.wagerStreak !== undefined && message.wagerStreak !== 0) {
      obj.wagerStreak = Math.round(message.wagerStreak);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSignOutXPCoins_Player>): CMsgSignOutXPCoins_Player {
    return CMsgSignOutXPCoins_Player.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSignOutXPCoins_Player>): CMsgSignOutXPCoins_Player {
    const message = createBaseCMsgSignOutXPCoins_Player();
    message.accountId = object.accountId ?? 0;
    message.xpGained = object.xpGained ?? 0;
    message.coinsSpent = object.coinsSpent ?? 0;
    message.wagerTokenItemId = object.wagerTokenItemId ?? "0";
    message.rankWager = object.rankWager ?? 0;
    message.wagerStreak = object.wagerStreak ?? 0;
    return message;
  },
};

function createBaseCMsgSignOutBounties(): CMsgSignOutBounties {
  return { bounties: [], eventId: 0, matchId: "0", timestamp: 0 };
}

export const CMsgSignOutBounties = {
  encode(message: CMsgSignOutBounties, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.bounties) {
      CMsgSignOutBounties_Bounty.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.eventId !== undefined && message.eventId !== 0) {
      writer.uint32(16).int32(message.eventId);
    }
    if (message.matchId !== undefined && message.matchId !== "0") {
      writer.uint32(24).uint64(message.matchId);
    }
    if (message.timestamp !== undefined && message.timestamp !== 0) {
      writer.uint32(32).uint32(message.timestamp);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSignOutBounties {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSignOutBounties();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.bounties.push(CMsgSignOutBounties_Bounty.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.eventId = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.matchId = longToString(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.timestamp = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSignOutBounties {
    return {
      bounties: globalThis.Array.isArray(object?.bounties)
        ? object.bounties.map((e: any) => CMsgSignOutBounties_Bounty.fromJSON(e))
        : [],
      eventId: isSet(object.eventId) ? eEventFromJSON(object.eventId) : 0,
      matchId: isSet(object.matchId) ? globalThis.String(object.matchId) : "0",
      timestamp: isSet(object.timestamp) ? globalThis.Number(object.timestamp) : 0,
    };
  },

  toJSON(message: CMsgSignOutBounties): unknown {
    const obj: any = {};
    if (message.bounties?.length) {
      obj.bounties = message.bounties.map((e) => CMsgSignOutBounties_Bounty.toJSON(e));
    }
    if (message.eventId !== undefined && message.eventId !== 0) {
      obj.eventId = eEventToJSON(message.eventId);
    }
    if (message.matchId !== undefined && message.matchId !== "0") {
      obj.matchId = message.matchId;
    }
    if (message.timestamp !== undefined && message.timestamp !== 0) {
      obj.timestamp = Math.round(message.timestamp);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSignOutBounties>): CMsgSignOutBounties {
    return CMsgSignOutBounties.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSignOutBounties>): CMsgSignOutBounties {
    const message = createBaseCMsgSignOutBounties();
    message.bounties = object.bounties?.map((e) => CMsgSignOutBounties_Bounty.fromPartial(e)) || [];
    message.eventId = object.eventId ?? 0;
    message.matchId = object.matchId ?? "0";
    message.timestamp = object.timestamp ?? 0;
    return message;
  },
};

function createBaseCMsgSignOutBounties_Bounty(): CMsgSignOutBounties_Bounty {
  return { issuerAccountId: 0, completerAccountId: 0, targetAccountId: 0 };
}

export const CMsgSignOutBounties_Bounty = {
  encode(message: CMsgSignOutBounties_Bounty, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.issuerAccountId !== undefined && message.issuerAccountId !== 0) {
      writer.uint32(8).uint32(message.issuerAccountId);
    }
    if (message.completerAccountId !== undefined && message.completerAccountId !== 0) {
      writer.uint32(16).uint32(message.completerAccountId);
    }
    if (message.targetAccountId !== undefined && message.targetAccountId !== 0) {
      writer.uint32(24).uint32(message.targetAccountId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSignOutBounties_Bounty {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSignOutBounties_Bounty();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.issuerAccountId = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.completerAccountId = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.targetAccountId = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSignOutBounties_Bounty {
    return {
      issuerAccountId: isSet(object.issuerAccountId) ? globalThis.Number(object.issuerAccountId) : 0,
      completerAccountId: isSet(object.completerAccountId) ? globalThis.Number(object.completerAccountId) : 0,
      targetAccountId: isSet(object.targetAccountId) ? globalThis.Number(object.targetAccountId) : 0,
    };
  },

  toJSON(message: CMsgSignOutBounties_Bounty): unknown {
    const obj: any = {};
    if (message.issuerAccountId !== undefined && message.issuerAccountId !== 0) {
      obj.issuerAccountId = Math.round(message.issuerAccountId);
    }
    if (message.completerAccountId !== undefined && message.completerAccountId !== 0) {
      obj.completerAccountId = Math.round(message.completerAccountId);
    }
    if (message.targetAccountId !== undefined && message.targetAccountId !== 0) {
      obj.targetAccountId = Math.round(message.targetAccountId);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSignOutBounties_Bounty>): CMsgSignOutBounties_Bounty {
    return CMsgSignOutBounties_Bounty.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSignOutBounties_Bounty>): CMsgSignOutBounties_Bounty {
    const message = createBaseCMsgSignOutBounties_Bounty();
    message.issuerAccountId = object.issuerAccountId ?? 0;
    message.completerAccountId = object.completerAccountId ?? 0;
    message.targetAccountId = object.targetAccountId ?? 0;
    return message;
  },
};

function createBaseCMsgSignOutCommunityGoalProgress(): CMsgSignOutCommunityGoalProgress {
  return { eventId: 0, eventIncrements: [] };
}

export const CMsgSignOutCommunityGoalProgress = {
  encode(message: CMsgSignOutCommunityGoalProgress, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.eventId !== undefined && message.eventId !== 0) {
      writer.uint32(8).int32(message.eventId);
    }
    for (const v of message.eventIncrements) {
      CMsgSignOutCommunityGoalProgress_EventGoalIncrement.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSignOutCommunityGoalProgress {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSignOutCommunityGoalProgress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.eventId = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.eventIncrements.push(
            CMsgSignOutCommunityGoalProgress_EventGoalIncrement.decode(reader, reader.uint32()),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSignOutCommunityGoalProgress {
    return {
      eventId: isSet(object.eventId) ? eEventFromJSON(object.eventId) : 0,
      eventIncrements: globalThis.Array.isArray(object?.eventIncrements)
        ? object.eventIncrements.map((e: any) => CMsgSignOutCommunityGoalProgress_EventGoalIncrement.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgSignOutCommunityGoalProgress): unknown {
    const obj: any = {};
    if (message.eventId !== undefined && message.eventId !== 0) {
      obj.eventId = eEventToJSON(message.eventId);
    }
    if (message.eventIncrements?.length) {
      obj.eventIncrements = message.eventIncrements.map((e) =>
        CMsgSignOutCommunityGoalProgress_EventGoalIncrement.toJSON(e)
      );
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSignOutCommunityGoalProgress>): CMsgSignOutCommunityGoalProgress {
    return CMsgSignOutCommunityGoalProgress.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSignOutCommunityGoalProgress>): CMsgSignOutCommunityGoalProgress {
    const message = createBaseCMsgSignOutCommunityGoalProgress();
    message.eventId = object.eventId ?? 0;
    message.eventIncrements =
      object.eventIncrements?.map((e) => CMsgSignOutCommunityGoalProgress_EventGoalIncrement.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgSignOutCommunityGoalProgress_EventGoalIncrement(): CMsgSignOutCommunityGoalProgress_EventGoalIncrement {
  return { eventGoalId: 0, incrementAmount: 0 };
}

export const CMsgSignOutCommunityGoalProgress_EventGoalIncrement = {
  encode(
    message: CMsgSignOutCommunityGoalProgress_EventGoalIncrement,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.eventGoalId !== undefined && message.eventGoalId !== 0) {
      writer.uint32(8).uint32(message.eventGoalId);
    }
    if (message.incrementAmount !== undefined && message.incrementAmount !== 0) {
      writer.uint32(16).uint32(message.incrementAmount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSignOutCommunityGoalProgress_EventGoalIncrement {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSignOutCommunityGoalProgress_EventGoalIncrement();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.eventGoalId = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.incrementAmount = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSignOutCommunityGoalProgress_EventGoalIncrement {
    return {
      eventGoalId: isSet(object.eventGoalId) ? globalThis.Number(object.eventGoalId) : 0,
      incrementAmount: isSet(object.incrementAmount) ? globalThis.Number(object.incrementAmount) : 0,
    };
  },

  toJSON(message: CMsgSignOutCommunityGoalProgress_EventGoalIncrement): unknown {
    const obj: any = {};
    if (message.eventGoalId !== undefined && message.eventGoalId !== 0) {
      obj.eventGoalId = Math.round(message.eventGoalId);
    }
    if (message.incrementAmount !== undefined && message.incrementAmount !== 0) {
      obj.incrementAmount = Math.round(message.incrementAmount);
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgSignOutCommunityGoalProgress_EventGoalIncrement>,
  ): CMsgSignOutCommunityGoalProgress_EventGoalIncrement {
    return CMsgSignOutCommunityGoalProgress_EventGoalIncrement.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgSignOutCommunityGoalProgress_EventGoalIncrement>,
  ): CMsgSignOutCommunityGoalProgress_EventGoalIncrement {
    const message = createBaseCMsgSignOutCommunityGoalProgress_EventGoalIncrement();
    message.eventGoalId = object.eventGoalId ?? 0;
    message.incrementAmount = object.incrementAmount ?? 0;
    return message;
  },
};

function createBaseCMsgServerToGCCloseCompendiumInGamePredictionVoting(): CMsgServerToGCCloseCompendiumInGamePredictionVoting {
  return { matchId: "0", hltvDelay: 0, leagueId: 0 };
}

export const CMsgServerToGCCloseCompendiumInGamePredictionVoting = {
  encode(
    message: CMsgServerToGCCloseCompendiumInGamePredictionVoting,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.matchId !== undefined && message.matchId !== "0") {
      writer.uint32(8).uint64(message.matchId);
    }
    if (message.hltvDelay !== undefined && message.hltvDelay !== 0) {
      writer.uint32(16).uint32(message.hltvDelay);
    }
    if (message.leagueId !== undefined && message.leagueId !== 0) {
      writer.uint32(24).uint32(message.leagueId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgServerToGCCloseCompendiumInGamePredictionVoting {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgServerToGCCloseCompendiumInGamePredictionVoting();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.matchId = longToString(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.hltvDelay = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.leagueId = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgServerToGCCloseCompendiumInGamePredictionVoting {
    return {
      matchId: isSet(object.matchId) ? globalThis.String(object.matchId) : "0",
      hltvDelay: isSet(object.hltvDelay) ? globalThis.Number(object.hltvDelay) : 0,
      leagueId: isSet(object.leagueId) ? globalThis.Number(object.leagueId) : 0,
    };
  },

  toJSON(message: CMsgServerToGCCloseCompendiumInGamePredictionVoting): unknown {
    const obj: any = {};
    if (message.matchId !== undefined && message.matchId !== "0") {
      obj.matchId = message.matchId;
    }
    if (message.hltvDelay !== undefined && message.hltvDelay !== 0) {
      obj.hltvDelay = Math.round(message.hltvDelay);
    }
    if (message.leagueId !== undefined && message.leagueId !== 0) {
      obj.leagueId = Math.round(message.leagueId);
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgServerToGCCloseCompendiumInGamePredictionVoting>,
  ): CMsgServerToGCCloseCompendiumInGamePredictionVoting {
    return CMsgServerToGCCloseCompendiumInGamePredictionVoting.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgServerToGCCloseCompendiumInGamePredictionVoting>,
  ): CMsgServerToGCCloseCompendiumInGamePredictionVoting {
    const message = createBaseCMsgServerToGCCloseCompendiumInGamePredictionVoting();
    message.matchId = object.matchId ?? "0";
    message.hltvDelay = object.hltvDelay ?? 0;
    message.leagueId = object.leagueId ?? 0;
    return message;
  },
};

function createBaseCMsgServerToGCCloseCompendiumInGamePredictionVotingResponse(): CMsgServerToGCCloseCompendiumInGamePredictionVotingResponse {
  return { result: false };
}

export const CMsgServerToGCCloseCompendiumInGamePredictionVotingResponse = {
  encode(
    message: CMsgServerToGCCloseCompendiumInGamePredictionVotingResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.result !== undefined && message.result !== false) {
      writer.uint32(8).bool(message.result);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgServerToGCCloseCompendiumInGamePredictionVotingResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgServerToGCCloseCompendiumInGamePredictionVotingResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.result = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgServerToGCCloseCompendiumInGamePredictionVotingResponse {
    return { result: isSet(object.result) ? globalThis.Boolean(object.result) : false };
  },

  toJSON(message: CMsgServerToGCCloseCompendiumInGamePredictionVotingResponse): unknown {
    const obj: any = {};
    if (message.result !== undefined && message.result !== false) {
      obj.result = message.result;
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgServerToGCCloseCompendiumInGamePredictionVotingResponse>,
  ): CMsgServerToGCCloseCompendiumInGamePredictionVotingResponse {
    return CMsgServerToGCCloseCompendiumInGamePredictionVotingResponse.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgServerToGCCloseCompendiumInGamePredictionVotingResponse>,
  ): CMsgServerToGCCloseCompendiumInGamePredictionVotingResponse {
    const message = createBaseCMsgServerToGCCloseCompendiumInGamePredictionVotingResponse();
    message.result = object.result ?? false;
    return message;
  },
};

function createBaseCMsgServerToGCCompendiumInGamePredictionResults(): CMsgServerToGCCompendiumInGamePredictionResults {
  return { matchId: "0", results: [], leagueId: 0, leagueNodeId: 0 };
}

export const CMsgServerToGCCompendiumInGamePredictionResults = {
  encode(
    message: CMsgServerToGCCompendiumInGamePredictionResults,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.matchId !== undefined && message.matchId !== "0") {
      writer.uint32(8).uint64(message.matchId);
    }
    for (const v of message.results) {
      CMsgServerToGCCompendiumInGamePredictionResults_PredictionResult.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.leagueId !== undefined && message.leagueId !== 0) {
      writer.uint32(24).uint32(message.leagueId);
    }
    if (message.leagueNodeId !== undefined && message.leagueNodeId !== 0) {
      writer.uint32(32).uint32(message.leagueNodeId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgServerToGCCompendiumInGamePredictionResults {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgServerToGCCompendiumInGamePredictionResults();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.matchId = longToString(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.results.push(
            CMsgServerToGCCompendiumInGamePredictionResults_PredictionResult.decode(reader, reader.uint32()),
          );
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.leagueId = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.leagueNodeId = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgServerToGCCompendiumInGamePredictionResults {
    return {
      matchId: isSet(object.matchId) ? globalThis.String(object.matchId) : "0",
      results: globalThis.Array.isArray(object?.results)
        ? object.results.map((e: any) => CMsgServerToGCCompendiumInGamePredictionResults_PredictionResult.fromJSON(e))
        : [],
      leagueId: isSet(object.leagueId) ? globalThis.Number(object.leagueId) : 0,
      leagueNodeId: isSet(object.leagueNodeId) ? globalThis.Number(object.leagueNodeId) : 0,
    };
  },

  toJSON(message: CMsgServerToGCCompendiumInGamePredictionResults): unknown {
    const obj: any = {};
    if (message.matchId !== undefined && message.matchId !== "0") {
      obj.matchId = message.matchId;
    }
    if (message.results?.length) {
      obj.results = message.results.map((e) =>
        CMsgServerToGCCompendiumInGamePredictionResults_PredictionResult.toJSON(e)
      );
    }
    if (message.leagueId !== undefined && message.leagueId !== 0) {
      obj.leagueId = Math.round(message.leagueId);
    }
    if (message.leagueNodeId !== undefined && message.leagueNodeId !== 0) {
      obj.leagueNodeId = Math.round(message.leagueNodeId);
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgServerToGCCompendiumInGamePredictionResults>,
  ): CMsgServerToGCCompendiumInGamePredictionResults {
    return CMsgServerToGCCompendiumInGamePredictionResults.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgServerToGCCompendiumInGamePredictionResults>,
  ): CMsgServerToGCCompendiumInGamePredictionResults {
    const message = createBaseCMsgServerToGCCompendiumInGamePredictionResults();
    message.matchId = object.matchId ?? "0";
    message.results =
      object.results?.map((e) => CMsgServerToGCCompendiumInGamePredictionResults_PredictionResult.fromPartial(e)) || [];
    message.leagueId = object.leagueId ?? 0;
    message.leagueNodeId = object.leagueNodeId ?? 0;
    return message;
  },
};

function createBaseCMsgServerToGCCompendiumInGamePredictionResults_PredictionResult(): CMsgServerToGCCompendiumInGamePredictionResults_PredictionResult {
  return { predictionId: 0, predictionValue: 0, predictionValueIsMask: false };
}

export const CMsgServerToGCCompendiumInGamePredictionResults_PredictionResult = {
  encode(
    message: CMsgServerToGCCompendiumInGamePredictionResults_PredictionResult,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.predictionId !== undefined && message.predictionId !== 0) {
      writer.uint32(8).uint32(message.predictionId);
    }
    if (message.predictionValue !== undefined && message.predictionValue !== 0) {
      writer.uint32(16).uint32(message.predictionValue);
    }
    if (message.predictionValueIsMask !== undefined && message.predictionValueIsMask !== false) {
      writer.uint32(24).bool(message.predictionValueIsMask);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): CMsgServerToGCCompendiumInGamePredictionResults_PredictionResult {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgServerToGCCompendiumInGamePredictionResults_PredictionResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.predictionId = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.predictionValue = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.predictionValueIsMask = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgServerToGCCompendiumInGamePredictionResults_PredictionResult {
    return {
      predictionId: isSet(object.predictionId) ? globalThis.Number(object.predictionId) : 0,
      predictionValue: isSet(object.predictionValue) ? globalThis.Number(object.predictionValue) : 0,
      predictionValueIsMask: isSet(object.predictionValueIsMask)
        ? globalThis.Boolean(object.predictionValueIsMask)
        : false,
    };
  },

  toJSON(message: CMsgServerToGCCompendiumInGamePredictionResults_PredictionResult): unknown {
    const obj: any = {};
    if (message.predictionId !== undefined && message.predictionId !== 0) {
      obj.predictionId = Math.round(message.predictionId);
    }
    if (message.predictionValue !== undefined && message.predictionValue !== 0) {
      obj.predictionValue = Math.round(message.predictionValue);
    }
    if (message.predictionValueIsMask !== undefined && message.predictionValueIsMask !== false) {
      obj.predictionValueIsMask = message.predictionValueIsMask;
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgServerToGCCompendiumInGamePredictionResults_PredictionResult>,
  ): CMsgServerToGCCompendiumInGamePredictionResults_PredictionResult {
    return CMsgServerToGCCompendiumInGamePredictionResults_PredictionResult.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgServerToGCCompendiumInGamePredictionResults_PredictionResult>,
  ): CMsgServerToGCCompendiumInGamePredictionResults_PredictionResult {
    const message = createBaseCMsgServerToGCCompendiumInGamePredictionResults_PredictionResult();
    message.predictionId = object.predictionId ?? 0;
    message.predictionValue = object.predictionValue ?? 0;
    message.predictionValueIsMask = object.predictionValueIsMask ?? false;
    return message;
  },
};

function createBaseCMsgServerToGCCompendiumChosenInGamePredictions(): CMsgServerToGCCompendiumChosenInGamePredictions {
  return { matchId: "0", predictionsChosen: [], leagueId: 0 };
}

export const CMsgServerToGCCompendiumChosenInGamePredictions = {
  encode(
    message: CMsgServerToGCCompendiumChosenInGamePredictions,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.matchId !== undefined && message.matchId !== "0") {
      writer.uint32(8).uint64(message.matchId);
    }
    for (const v of message.predictionsChosen) {
      CMsgServerToGCCompendiumChosenInGamePredictions_Prediction.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.leagueId !== undefined && message.leagueId !== 0) {
      writer.uint32(24).uint32(message.leagueId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgServerToGCCompendiumChosenInGamePredictions {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgServerToGCCompendiumChosenInGamePredictions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.matchId = longToString(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.predictionsChosen.push(
            CMsgServerToGCCompendiumChosenInGamePredictions_Prediction.decode(reader, reader.uint32()),
          );
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.leagueId = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgServerToGCCompendiumChosenInGamePredictions {
    return {
      matchId: isSet(object.matchId) ? globalThis.String(object.matchId) : "0",
      predictionsChosen: globalThis.Array.isArray(object?.predictionsChosen)
        ? object.predictionsChosen.map((e: any) =>
          CMsgServerToGCCompendiumChosenInGamePredictions_Prediction.fromJSON(e)
        )
        : [],
      leagueId: isSet(object.leagueId) ? globalThis.Number(object.leagueId) : 0,
    };
  },

  toJSON(message: CMsgServerToGCCompendiumChosenInGamePredictions): unknown {
    const obj: any = {};
    if (message.matchId !== undefined && message.matchId !== "0") {
      obj.matchId = message.matchId;
    }
    if (message.predictionsChosen?.length) {
      obj.predictionsChosen = message.predictionsChosen.map((e) =>
        CMsgServerToGCCompendiumChosenInGamePredictions_Prediction.toJSON(e)
      );
    }
    if (message.leagueId !== undefined && message.leagueId !== 0) {
      obj.leagueId = Math.round(message.leagueId);
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgServerToGCCompendiumChosenInGamePredictions>,
  ): CMsgServerToGCCompendiumChosenInGamePredictions {
    return CMsgServerToGCCompendiumChosenInGamePredictions.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgServerToGCCompendiumChosenInGamePredictions>,
  ): CMsgServerToGCCompendiumChosenInGamePredictions {
    const message = createBaseCMsgServerToGCCompendiumChosenInGamePredictions();
    message.matchId = object.matchId ?? "0";
    message.predictionsChosen =
      object.predictionsChosen?.map((e) => CMsgServerToGCCompendiumChosenInGamePredictions_Prediction.fromPartial(e)) ||
      [];
    message.leagueId = object.leagueId ?? 0;
    return message;
  },
};

function createBaseCMsgServerToGCCompendiumChosenInGamePredictions_Prediction(): CMsgServerToGCCompendiumChosenInGamePredictions_Prediction {
  return { predictionId: 0 };
}

export const CMsgServerToGCCompendiumChosenInGamePredictions_Prediction = {
  encode(
    message: CMsgServerToGCCompendiumChosenInGamePredictions_Prediction,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.predictionId !== undefined && message.predictionId !== 0) {
      writer.uint32(8).uint32(message.predictionId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgServerToGCCompendiumChosenInGamePredictions_Prediction {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgServerToGCCompendiumChosenInGamePredictions_Prediction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.predictionId = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgServerToGCCompendiumChosenInGamePredictions_Prediction {
    return { predictionId: isSet(object.predictionId) ? globalThis.Number(object.predictionId) : 0 };
  },

  toJSON(message: CMsgServerToGCCompendiumChosenInGamePredictions_Prediction): unknown {
    const obj: any = {};
    if (message.predictionId !== undefined && message.predictionId !== 0) {
      obj.predictionId = Math.round(message.predictionId);
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgServerToGCCompendiumChosenInGamePredictions_Prediction>,
  ): CMsgServerToGCCompendiumChosenInGamePredictions_Prediction {
    return CMsgServerToGCCompendiumChosenInGamePredictions_Prediction.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgServerToGCCompendiumChosenInGamePredictions_Prediction>,
  ): CMsgServerToGCCompendiumChosenInGamePredictions_Prediction {
    const message = createBaseCMsgServerToGCCompendiumChosenInGamePredictions_Prediction();
    message.predictionId = object.predictionId ?? 0;
    return message;
  },
};

function createBaseCMsgGCToGCCompendiumInGamePredictionResults(): CMsgGCToGCCompendiumInGamePredictionResults {
  return { results: undefined };
}

export const CMsgGCToGCCompendiumInGamePredictionResults = {
  encode(message: CMsgGCToGCCompendiumInGamePredictionResults, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.results !== undefined) {
      CMsgServerToGCCompendiumInGamePredictionResults.encode(message.results, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToGCCompendiumInGamePredictionResults {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToGCCompendiumInGamePredictionResults();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.results = CMsgServerToGCCompendiumInGamePredictionResults.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToGCCompendiumInGamePredictionResults {
    return {
      results: isSet(object.results)
        ? CMsgServerToGCCompendiumInGamePredictionResults.fromJSON(object.results)
        : undefined,
    };
  },

  toJSON(message: CMsgGCToGCCompendiumInGamePredictionResults): unknown {
    const obj: any = {};
    if (message.results !== undefined) {
      obj.results = CMsgServerToGCCompendiumInGamePredictionResults.toJSON(message.results);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCToGCCompendiumInGamePredictionResults>): CMsgGCToGCCompendiumInGamePredictionResults {
    return CMsgGCToGCCompendiumInGamePredictionResults.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgGCToGCCompendiumInGamePredictionResults>,
  ): CMsgGCToGCCompendiumInGamePredictionResults {
    const message = createBaseCMsgGCToGCCompendiumInGamePredictionResults();
    message.results = (object.results !== undefined && object.results !== null)
      ? CMsgServerToGCCompendiumInGamePredictionResults.fromPartial(object.results)
      : undefined;
    return message;
  },
};

function createBaseCMsgServerToGCMatchPlayerItemPurchaseHistory(): CMsgServerToGCMatchPlayerItemPurchaseHistory {
  return { matchId: "0", mmr: 0, players: [] };
}

export const CMsgServerToGCMatchPlayerItemPurchaseHistory = {
  encode(message: CMsgServerToGCMatchPlayerItemPurchaseHistory, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.matchId !== undefined && message.matchId !== "0") {
      writer.uint32(8).uint64(message.matchId);
    }
    if (message.mmr !== undefined && message.mmr !== 0) {
      writer.uint32(16).uint32(message.mmr);
    }
    for (const v of message.players) {
      CMsgServerToGCMatchPlayerItemPurchaseHistory_Player.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgServerToGCMatchPlayerItemPurchaseHistory {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgServerToGCMatchPlayerItemPurchaseHistory();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.matchId = longToString(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.mmr = reader.uint32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.players.push(CMsgServerToGCMatchPlayerItemPurchaseHistory_Player.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgServerToGCMatchPlayerItemPurchaseHistory {
    return {
      matchId: isSet(object.matchId) ? globalThis.String(object.matchId) : "0",
      mmr: isSet(object.mmr) ? globalThis.Number(object.mmr) : 0,
      players: globalThis.Array.isArray(object?.players)
        ? object.players.map((e: any) => CMsgServerToGCMatchPlayerItemPurchaseHistory_Player.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgServerToGCMatchPlayerItemPurchaseHistory): unknown {
    const obj: any = {};
    if (message.matchId !== undefined && message.matchId !== "0") {
      obj.matchId = message.matchId;
    }
    if (message.mmr !== undefined && message.mmr !== 0) {
      obj.mmr = Math.round(message.mmr);
    }
    if (message.players?.length) {
      obj.players = message.players.map((e) => CMsgServerToGCMatchPlayerItemPurchaseHistory_Player.toJSON(e));
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgServerToGCMatchPlayerItemPurchaseHistory>,
  ): CMsgServerToGCMatchPlayerItemPurchaseHistory {
    return CMsgServerToGCMatchPlayerItemPurchaseHistory.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgServerToGCMatchPlayerItemPurchaseHistory>,
  ): CMsgServerToGCMatchPlayerItemPurchaseHistory {
    const message = createBaseCMsgServerToGCMatchPlayerItemPurchaseHistory();
    message.matchId = object.matchId ?? "0";
    message.mmr = object.mmr ?? 0;
    message.players = object.players?.map((e) => CMsgServerToGCMatchPlayerItemPurchaseHistory_Player.fromPartial(e)) ||
      [];
    return message;
  },
};

function createBaseCMsgServerToGCMatchPlayerItemPurchaseHistory_ItemPurchase(): CMsgServerToGCMatchPlayerItemPurchaseHistory_ItemPurchase {
  return { item: -1, gold: 0, netWorth: 0, gameTime: 0, inventoryItems: [], talentsSkilled: [] };
}

export const CMsgServerToGCMatchPlayerItemPurchaseHistory_ItemPurchase = {
  encode(
    message: CMsgServerToGCMatchPlayerItemPurchaseHistory_ItemPurchase,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.item !== undefined && message.item !== -1) {
      writer.uint32(8).int32(message.item);
    }
    if (message.gold !== undefined && message.gold !== 0) {
      writer.uint32(16).uint32(message.gold);
    }
    if (message.netWorth !== undefined && message.netWorth !== 0) {
      writer.uint32(24).uint32(message.netWorth);
    }
    if (message.gameTime !== undefined && message.gameTime !== 0) {
      writer.uint32(32).uint32(message.gameTime);
    }
    writer.uint32(42).fork();
    for (const v of message.inventoryItems) {
      writer.int32(v);
    }
    writer.ldelim();
    writer.uint32(58).fork();
    for (const v of message.talentsSkilled) {
      writer.bool(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgServerToGCMatchPlayerItemPurchaseHistory_ItemPurchase {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgServerToGCMatchPlayerItemPurchaseHistory_ItemPurchase();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.item = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.gold = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.netWorth = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.gameTime = reader.uint32();
          continue;
        case 5:
          if (tag === 40) {
            message.inventoryItems.push(reader.int32());

            continue;
          }

          if (tag === 42) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.inventoryItems.push(reader.int32());
            }

            continue;
          }

          break;
        case 7:
          if (tag === 56) {
            message.talentsSkilled.push(reader.bool());

            continue;
          }

          if (tag === 58) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.talentsSkilled.push(reader.bool());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgServerToGCMatchPlayerItemPurchaseHistory_ItemPurchase {
    return {
      item: isSet(object.item) ? globalThis.Number(object.item) : -1,
      gold: isSet(object.gold) ? globalThis.Number(object.gold) : 0,
      netWorth: isSet(object.netWorth) ? globalThis.Number(object.netWorth) : 0,
      gameTime: isSet(object.gameTime) ? globalThis.Number(object.gameTime) : 0,
      inventoryItems: globalThis.Array.isArray(object?.inventoryItems)
        ? object.inventoryItems.map((e: any) => globalThis.Number(e))
        : [],
      talentsSkilled: globalThis.Array.isArray(object?.talentsSkilled)
        ? object.talentsSkilled.map((e: any) => globalThis.Boolean(e))
        : [],
    };
  },

  toJSON(message: CMsgServerToGCMatchPlayerItemPurchaseHistory_ItemPurchase): unknown {
    const obj: any = {};
    if (message.item !== undefined && message.item !== -1) {
      obj.item = Math.round(message.item);
    }
    if (message.gold !== undefined && message.gold !== 0) {
      obj.gold = Math.round(message.gold);
    }
    if (message.netWorth !== undefined && message.netWorth !== 0) {
      obj.netWorth = Math.round(message.netWorth);
    }
    if (message.gameTime !== undefined && message.gameTime !== 0) {
      obj.gameTime = Math.round(message.gameTime);
    }
    if (message.inventoryItems?.length) {
      obj.inventoryItems = message.inventoryItems.map((e) => Math.round(e));
    }
    if (message.talentsSkilled?.length) {
      obj.talentsSkilled = message.talentsSkilled;
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgServerToGCMatchPlayerItemPurchaseHistory_ItemPurchase>,
  ): CMsgServerToGCMatchPlayerItemPurchaseHistory_ItemPurchase {
    return CMsgServerToGCMatchPlayerItemPurchaseHistory_ItemPurchase.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgServerToGCMatchPlayerItemPurchaseHistory_ItemPurchase>,
  ): CMsgServerToGCMatchPlayerItemPurchaseHistory_ItemPurchase {
    const message = createBaseCMsgServerToGCMatchPlayerItemPurchaseHistory_ItemPurchase();
    message.item = object.item ?? -1;
    message.gold = object.gold ?? 0;
    message.netWorth = object.netWorth ?? 0;
    message.gameTime = object.gameTime ?? 0;
    message.inventoryItems = object.inventoryItems?.map((e) => e) || [];
    message.talentsSkilled = object.talentsSkilled?.map((e) => e) || [];
    return message;
  },
};

function createBaseCMsgServerToGCMatchPlayerItemPurchaseHistory_Player(): CMsgServerToGCMatchPlayerItemPurchaseHistory_Player {
  return {
    playerSlot: 0,
    accountId: 0,
    heroId: 0,
    alliedHeroIds: [],
    enemyHeroIds: [],
    itemPurchases: [],
    lane: 0,
    isWinner: false,
  };
}

export const CMsgServerToGCMatchPlayerItemPurchaseHistory_Player = {
  encode(
    message: CMsgServerToGCMatchPlayerItemPurchaseHistory_Player,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.playerSlot !== undefined && message.playerSlot !== 0) {
      writer.uint32(8).uint32(message.playerSlot);
    }
    if (message.accountId !== undefined && message.accountId !== 0) {
      writer.uint32(16).uint32(message.accountId);
    }
    if (message.heroId !== undefined && message.heroId !== 0) {
      writer.uint32(24).int32(message.heroId);
    }
    writer.uint32(34).fork();
    for (const v of message.alliedHeroIds) {
      writer.int32(v);
    }
    writer.ldelim();
    writer.uint32(42).fork();
    for (const v of message.enemyHeroIds) {
      writer.int32(v);
    }
    writer.ldelim();
    for (const v of message.itemPurchases) {
      CMsgServerToGCMatchPlayerItemPurchaseHistory_ItemPurchase.encode(v!, writer.uint32(50).fork()).ldelim();
    }
    if (message.lane !== undefined && message.lane !== 0) {
      writer.uint32(56).uint32(message.lane);
    }
    if (message.isWinner !== undefined && message.isWinner !== false) {
      writer.uint32(64).bool(message.isWinner);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgServerToGCMatchPlayerItemPurchaseHistory_Player {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgServerToGCMatchPlayerItemPurchaseHistory_Player();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.playerSlot = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.heroId = reader.int32();
          continue;
        case 4:
          if (tag === 32) {
            message.alliedHeroIds.push(reader.int32());

            continue;
          }

          if (tag === 34) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.alliedHeroIds.push(reader.int32());
            }

            continue;
          }

          break;
        case 5:
          if (tag === 40) {
            message.enemyHeroIds.push(reader.int32());

            continue;
          }

          if (tag === 42) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.enemyHeroIds.push(reader.int32());
            }

            continue;
          }

          break;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.itemPurchases.push(
            CMsgServerToGCMatchPlayerItemPurchaseHistory_ItemPurchase.decode(reader, reader.uint32()),
          );
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.lane = reader.uint32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.isWinner = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgServerToGCMatchPlayerItemPurchaseHistory_Player {
    return {
      playerSlot: isSet(object.playerSlot) ? globalThis.Number(object.playerSlot) : 0,
      accountId: isSet(object.accountId) ? globalThis.Number(object.accountId) : 0,
      heroId: isSet(object.heroId) ? globalThis.Number(object.heroId) : 0,
      alliedHeroIds: globalThis.Array.isArray(object?.alliedHeroIds)
        ? object.alliedHeroIds.map((e: any) => globalThis.Number(e))
        : [],
      enemyHeroIds: globalThis.Array.isArray(object?.enemyHeroIds)
        ? object.enemyHeroIds.map((e: any) => globalThis.Number(e))
        : [],
      itemPurchases: globalThis.Array.isArray(object?.itemPurchases)
        ? object.itemPurchases.map((e: any) => CMsgServerToGCMatchPlayerItemPurchaseHistory_ItemPurchase.fromJSON(e))
        : [],
      lane: isSet(object.lane) ? globalThis.Number(object.lane) : 0,
      isWinner: isSet(object.isWinner) ? globalThis.Boolean(object.isWinner) : false,
    };
  },

  toJSON(message: CMsgServerToGCMatchPlayerItemPurchaseHistory_Player): unknown {
    const obj: any = {};
    if (message.playerSlot !== undefined && message.playerSlot !== 0) {
      obj.playerSlot = Math.round(message.playerSlot);
    }
    if (message.accountId !== undefined && message.accountId !== 0) {
      obj.accountId = Math.round(message.accountId);
    }
    if (message.heroId !== undefined && message.heroId !== 0) {
      obj.heroId = Math.round(message.heroId);
    }
    if (message.alliedHeroIds?.length) {
      obj.alliedHeroIds = message.alliedHeroIds.map((e) => Math.round(e));
    }
    if (message.enemyHeroIds?.length) {
      obj.enemyHeroIds = message.enemyHeroIds.map((e) => Math.round(e));
    }
    if (message.itemPurchases?.length) {
      obj.itemPurchases = message.itemPurchases.map((e) =>
        CMsgServerToGCMatchPlayerItemPurchaseHistory_ItemPurchase.toJSON(e)
      );
    }
    if (message.lane !== undefined && message.lane !== 0) {
      obj.lane = Math.round(message.lane);
    }
    if (message.isWinner !== undefined && message.isWinner !== false) {
      obj.isWinner = message.isWinner;
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgServerToGCMatchPlayerItemPurchaseHistory_Player>,
  ): CMsgServerToGCMatchPlayerItemPurchaseHistory_Player {
    return CMsgServerToGCMatchPlayerItemPurchaseHistory_Player.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgServerToGCMatchPlayerItemPurchaseHistory_Player>,
  ): CMsgServerToGCMatchPlayerItemPurchaseHistory_Player {
    const message = createBaseCMsgServerToGCMatchPlayerItemPurchaseHistory_Player();
    message.playerSlot = object.playerSlot ?? 0;
    message.accountId = object.accountId ?? 0;
    message.heroId = object.heroId ?? 0;
    message.alliedHeroIds = object.alliedHeroIds?.map((e) => e) || [];
    message.enemyHeroIds = object.enemyHeroIds?.map((e) => e) || [];
    message.itemPurchases =
      object.itemPurchases?.map((e) => CMsgServerToGCMatchPlayerItemPurchaseHistory_ItemPurchase.fromPartial(e)) || [];
    message.lane = object.lane ?? 0;
    message.isWinner = object.isWinner ?? false;
    return message;
  },
};

function createBaseCMsgServerToGCMatchPlayerNeutralItemEquipHistory(): CMsgServerToGCMatchPlayerNeutralItemEquipHistory {
  return { matchId: "0", players: [] };
}

export const CMsgServerToGCMatchPlayerNeutralItemEquipHistory = {
  encode(
    message: CMsgServerToGCMatchPlayerNeutralItemEquipHistory,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.matchId !== undefined && message.matchId !== "0") {
      writer.uint32(8).uint64(message.matchId);
    }
    for (const v of message.players) {
      CMsgServerToGCMatchPlayerNeutralItemEquipHistory_Player.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgServerToGCMatchPlayerNeutralItemEquipHistory {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgServerToGCMatchPlayerNeutralItemEquipHistory();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.matchId = longToString(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.players.push(CMsgServerToGCMatchPlayerNeutralItemEquipHistory_Player.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgServerToGCMatchPlayerNeutralItemEquipHistory {
    return {
      matchId: isSet(object.matchId) ? globalThis.String(object.matchId) : "0",
      players: globalThis.Array.isArray(object?.players)
        ? object.players.map((e: any) => CMsgServerToGCMatchPlayerNeutralItemEquipHistory_Player.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgServerToGCMatchPlayerNeutralItemEquipHistory): unknown {
    const obj: any = {};
    if (message.matchId !== undefined && message.matchId !== "0") {
      obj.matchId = message.matchId;
    }
    if (message.players?.length) {
      obj.players = message.players.map((e) => CMsgServerToGCMatchPlayerNeutralItemEquipHistory_Player.toJSON(e));
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgServerToGCMatchPlayerNeutralItemEquipHistory>,
  ): CMsgServerToGCMatchPlayerNeutralItemEquipHistory {
    return CMsgServerToGCMatchPlayerNeutralItemEquipHistory.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgServerToGCMatchPlayerNeutralItemEquipHistory>,
  ): CMsgServerToGCMatchPlayerNeutralItemEquipHistory {
    const message = createBaseCMsgServerToGCMatchPlayerNeutralItemEquipHistory();
    message.matchId = object.matchId ?? "0";
    message.players =
      object.players?.map((e) => CMsgServerToGCMatchPlayerNeutralItemEquipHistory_Player.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgServerToGCMatchPlayerNeutralItemEquipHistory_ItemEquip(): CMsgServerToGCMatchPlayerNeutralItemEquipHistory_ItemEquip {
  return { item: -1, gameTime: 0, inventoryItems: [], talentsSkilled: [], availableNeutralItems: [] };
}

export const CMsgServerToGCMatchPlayerNeutralItemEquipHistory_ItemEquip = {
  encode(
    message: CMsgServerToGCMatchPlayerNeutralItemEquipHistory_ItemEquip,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.item !== undefined && message.item !== -1) {
      writer.uint32(8).int32(message.item);
    }
    if (message.gameTime !== undefined && message.gameTime !== 0) {
      writer.uint32(16).uint32(message.gameTime);
    }
    writer.uint32(26).fork();
    for (const v of message.inventoryItems) {
      writer.int32(v);
    }
    writer.ldelim();
    writer.uint32(34).fork();
    for (const v of message.talentsSkilled) {
      writer.bool(v);
    }
    writer.ldelim();
    writer.uint32(42).fork();
    for (const v of message.availableNeutralItems) {
      writer.int32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgServerToGCMatchPlayerNeutralItemEquipHistory_ItemEquip {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgServerToGCMatchPlayerNeutralItemEquipHistory_ItemEquip();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.item = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.gameTime = reader.uint32();
          continue;
        case 3:
          if (tag === 24) {
            message.inventoryItems.push(reader.int32());

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.inventoryItems.push(reader.int32());
            }

            continue;
          }

          break;
        case 4:
          if (tag === 32) {
            message.talentsSkilled.push(reader.bool());

            continue;
          }

          if (tag === 34) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.talentsSkilled.push(reader.bool());
            }

            continue;
          }

          break;
        case 5:
          if (tag === 40) {
            message.availableNeutralItems.push(reader.int32());

            continue;
          }

          if (tag === 42) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.availableNeutralItems.push(reader.int32());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgServerToGCMatchPlayerNeutralItemEquipHistory_ItemEquip {
    return {
      item: isSet(object.item) ? globalThis.Number(object.item) : -1,
      gameTime: isSet(object.gameTime) ? globalThis.Number(object.gameTime) : 0,
      inventoryItems: globalThis.Array.isArray(object?.inventoryItems)
        ? object.inventoryItems.map((e: any) => globalThis.Number(e))
        : [],
      talentsSkilled: globalThis.Array.isArray(object?.talentsSkilled)
        ? object.talentsSkilled.map((e: any) => globalThis.Boolean(e))
        : [],
      availableNeutralItems: globalThis.Array.isArray(object?.availableNeutralItems)
        ? object.availableNeutralItems.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: CMsgServerToGCMatchPlayerNeutralItemEquipHistory_ItemEquip): unknown {
    const obj: any = {};
    if (message.item !== undefined && message.item !== -1) {
      obj.item = Math.round(message.item);
    }
    if (message.gameTime !== undefined && message.gameTime !== 0) {
      obj.gameTime = Math.round(message.gameTime);
    }
    if (message.inventoryItems?.length) {
      obj.inventoryItems = message.inventoryItems.map((e) => Math.round(e));
    }
    if (message.talentsSkilled?.length) {
      obj.talentsSkilled = message.talentsSkilled;
    }
    if (message.availableNeutralItems?.length) {
      obj.availableNeutralItems = message.availableNeutralItems.map((e) => Math.round(e));
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgServerToGCMatchPlayerNeutralItemEquipHistory_ItemEquip>,
  ): CMsgServerToGCMatchPlayerNeutralItemEquipHistory_ItemEquip {
    return CMsgServerToGCMatchPlayerNeutralItemEquipHistory_ItemEquip.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgServerToGCMatchPlayerNeutralItemEquipHistory_ItemEquip>,
  ): CMsgServerToGCMatchPlayerNeutralItemEquipHistory_ItemEquip {
    const message = createBaseCMsgServerToGCMatchPlayerNeutralItemEquipHistory_ItemEquip();
    message.item = object.item ?? -1;
    message.gameTime = object.gameTime ?? 0;
    message.inventoryItems = object.inventoryItems?.map((e) => e) || [];
    message.talentsSkilled = object.talentsSkilled?.map((e) => e) || [];
    message.availableNeutralItems = object.availableNeutralItems?.map((e) => e) || [];
    return message;
  },
};

function createBaseCMsgServerToGCMatchPlayerNeutralItemEquipHistory_Player(): CMsgServerToGCMatchPlayerNeutralItemEquipHistory_Player {
  return { accountId: 0, alliedHeroIds: [], enemyHeroIds: [], itemEquips: [], isWinner: false };
}

export const CMsgServerToGCMatchPlayerNeutralItemEquipHistory_Player = {
  encode(
    message: CMsgServerToGCMatchPlayerNeutralItemEquipHistory_Player,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.accountId !== undefined && message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    writer.uint32(18).fork();
    for (const v of message.alliedHeroIds) {
      writer.int32(v);
    }
    writer.ldelim();
    writer.uint32(26).fork();
    for (const v of message.enemyHeroIds) {
      writer.int32(v);
    }
    writer.ldelim();
    for (const v of message.itemEquips) {
      CMsgServerToGCMatchPlayerNeutralItemEquipHistory_ItemEquip.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    if (message.isWinner !== undefined && message.isWinner !== false) {
      writer.uint32(40).bool(message.isWinner);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgServerToGCMatchPlayerNeutralItemEquipHistory_Player {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgServerToGCMatchPlayerNeutralItemEquipHistory_Player();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        case 2:
          if (tag === 16) {
            message.alliedHeroIds.push(reader.int32());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.alliedHeroIds.push(reader.int32());
            }

            continue;
          }

          break;
        case 3:
          if (tag === 24) {
            message.enemyHeroIds.push(reader.int32());

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.enemyHeroIds.push(reader.int32());
            }

            continue;
          }

          break;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.itemEquips.push(
            CMsgServerToGCMatchPlayerNeutralItemEquipHistory_ItemEquip.decode(reader, reader.uint32()),
          );
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.isWinner = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgServerToGCMatchPlayerNeutralItemEquipHistory_Player {
    return {
      accountId: isSet(object.accountId) ? globalThis.Number(object.accountId) : 0,
      alliedHeroIds: globalThis.Array.isArray(object?.alliedHeroIds)
        ? object.alliedHeroIds.map((e: any) => globalThis.Number(e))
        : [],
      enemyHeroIds: globalThis.Array.isArray(object?.enemyHeroIds)
        ? object.enemyHeroIds.map((e: any) => globalThis.Number(e))
        : [],
      itemEquips: globalThis.Array.isArray(object?.itemEquips)
        ? object.itemEquips.map((e: any) => CMsgServerToGCMatchPlayerNeutralItemEquipHistory_ItemEquip.fromJSON(e))
        : [],
      isWinner: isSet(object.isWinner) ? globalThis.Boolean(object.isWinner) : false,
    };
  },

  toJSON(message: CMsgServerToGCMatchPlayerNeutralItemEquipHistory_Player): unknown {
    const obj: any = {};
    if (message.accountId !== undefined && message.accountId !== 0) {
      obj.accountId = Math.round(message.accountId);
    }
    if (message.alliedHeroIds?.length) {
      obj.alliedHeroIds = message.alliedHeroIds.map((e) => Math.round(e));
    }
    if (message.enemyHeroIds?.length) {
      obj.enemyHeroIds = message.enemyHeroIds.map((e) => Math.round(e));
    }
    if (message.itemEquips?.length) {
      obj.itemEquips = message.itemEquips.map((e) =>
        CMsgServerToGCMatchPlayerNeutralItemEquipHistory_ItemEquip.toJSON(e)
      );
    }
    if (message.isWinner !== undefined && message.isWinner !== false) {
      obj.isWinner = message.isWinner;
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgServerToGCMatchPlayerNeutralItemEquipHistory_Player>,
  ): CMsgServerToGCMatchPlayerNeutralItemEquipHistory_Player {
    return CMsgServerToGCMatchPlayerNeutralItemEquipHistory_Player.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgServerToGCMatchPlayerNeutralItemEquipHistory_Player>,
  ): CMsgServerToGCMatchPlayerNeutralItemEquipHistory_Player {
    const message = createBaseCMsgServerToGCMatchPlayerNeutralItemEquipHistory_Player();
    message.accountId = object.accountId ?? 0;
    message.alliedHeroIds = object.alliedHeroIds?.map((e) => e) || [];
    message.enemyHeroIds = object.enemyHeroIds?.map((e) => e) || [];
    message.itemEquips =
      object.itemEquips?.map((e) => CMsgServerToGCMatchPlayerNeutralItemEquipHistory_ItemEquip.fromPartial(e)) || [];
    message.isWinner = object.isWinner ?? false;
    return message;
  },
};

function createBaseCMsgServerToGCMatchStateHistory(): CMsgServerToGCMatchStateHistory {
  return { matchId: "0", radiantWon: false, mmr: 0, matchStates: [] };
}

export const CMsgServerToGCMatchStateHistory = {
  encode(message: CMsgServerToGCMatchStateHistory, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.matchId !== undefined && message.matchId !== "0") {
      writer.uint32(8).uint64(message.matchId);
    }
    if (message.radiantWon !== undefined && message.radiantWon !== false) {
      writer.uint32(16).bool(message.radiantWon);
    }
    if (message.mmr !== undefined && message.mmr !== 0) {
      writer.uint32(24).uint32(message.mmr);
    }
    for (const v of message.matchStates) {
      CMsgServerToGCMatchStateHistory_MatchState.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgServerToGCMatchStateHistory {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgServerToGCMatchStateHistory();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.matchId = longToString(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.radiantWon = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.mmr = reader.uint32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.matchStates.push(CMsgServerToGCMatchStateHistory_MatchState.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgServerToGCMatchStateHistory {
    return {
      matchId: isSet(object.matchId) ? globalThis.String(object.matchId) : "0",
      radiantWon: isSet(object.radiantWon) ? globalThis.Boolean(object.radiantWon) : false,
      mmr: isSet(object.mmr) ? globalThis.Number(object.mmr) : 0,
      matchStates: globalThis.Array.isArray(object?.matchStates)
        ? object.matchStates.map((e: any) => CMsgServerToGCMatchStateHistory_MatchState.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgServerToGCMatchStateHistory): unknown {
    const obj: any = {};
    if (message.matchId !== undefined && message.matchId !== "0") {
      obj.matchId = message.matchId;
    }
    if (message.radiantWon !== undefined && message.radiantWon !== false) {
      obj.radiantWon = message.radiantWon;
    }
    if (message.mmr !== undefined && message.mmr !== 0) {
      obj.mmr = Math.round(message.mmr);
    }
    if (message.matchStates?.length) {
      obj.matchStates = message.matchStates.map((e) => CMsgServerToGCMatchStateHistory_MatchState.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgServerToGCMatchStateHistory>): CMsgServerToGCMatchStateHistory {
    return CMsgServerToGCMatchStateHistory.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgServerToGCMatchStateHistory>): CMsgServerToGCMatchStateHistory {
    const message = createBaseCMsgServerToGCMatchStateHistory();
    message.matchId = object.matchId ?? "0";
    message.radiantWon = object.radiantWon ?? false;
    message.mmr = object.mmr ?? 0;
    message.matchStates = object.matchStates?.map((e) => CMsgServerToGCMatchStateHistory_MatchState.fromPartial(e)) ||
      [];
    return message;
  },
};

function createBaseCMsgServerToGCMatchStateHistory_PlayerState(): CMsgServerToGCMatchStateHistory_PlayerState {
  return {
    heroId: 0,
    netWorth: 0,
    level: 0,
    deaths: 0,
    respawnTime: 0,
    hasBuyback: false,
    hasAegis: false,
    hasRapier: false,
    distance: 0,
  };
}

export const CMsgServerToGCMatchStateHistory_PlayerState = {
  encode(message: CMsgServerToGCMatchStateHistory_PlayerState, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.heroId !== undefined && message.heroId !== 0) {
      writer.uint32(8).int32(message.heroId);
    }
    if (message.netWorth !== undefined && message.netWorth !== 0) {
      writer.uint32(16).uint32(message.netWorth);
    }
    if (message.level !== undefined && message.level !== 0) {
      writer.uint32(24).uint32(message.level);
    }
    if (message.deaths !== undefined && message.deaths !== 0) {
      writer.uint32(32).uint32(message.deaths);
    }
    if (message.respawnTime !== undefined && message.respawnTime !== 0) {
      writer.uint32(40).uint32(message.respawnTime);
    }
    if (message.hasBuyback !== undefined && message.hasBuyback !== false) {
      writer.uint32(48).bool(message.hasBuyback);
    }
    if (message.hasAegis !== undefined && message.hasAegis !== false) {
      writer.uint32(56).bool(message.hasAegis);
    }
    if (message.hasRapier !== undefined && message.hasRapier !== false) {
      writer.uint32(64).bool(message.hasRapier);
    }
    if (message.distance !== undefined && message.distance !== 0) {
      writer.uint32(72).uint32(message.distance);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgServerToGCMatchStateHistory_PlayerState {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgServerToGCMatchStateHistory_PlayerState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.heroId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.netWorth = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.level = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.deaths = reader.uint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.respawnTime = reader.uint32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.hasBuyback = reader.bool();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.hasAegis = reader.bool();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.hasRapier = reader.bool();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.distance = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgServerToGCMatchStateHistory_PlayerState {
    return {
      heroId: isSet(object.heroId) ? globalThis.Number(object.heroId) : 0,
      netWorth: isSet(object.netWorth) ? globalThis.Number(object.netWorth) : 0,
      level: isSet(object.level) ? globalThis.Number(object.level) : 0,
      deaths: isSet(object.deaths) ? globalThis.Number(object.deaths) : 0,
      respawnTime: isSet(object.respawnTime) ? globalThis.Number(object.respawnTime) : 0,
      hasBuyback: isSet(object.hasBuyback) ? globalThis.Boolean(object.hasBuyback) : false,
      hasAegis: isSet(object.hasAegis) ? globalThis.Boolean(object.hasAegis) : false,
      hasRapier: isSet(object.hasRapier) ? globalThis.Boolean(object.hasRapier) : false,
      distance: isSet(object.distance) ? globalThis.Number(object.distance) : 0,
    };
  },

  toJSON(message: CMsgServerToGCMatchStateHistory_PlayerState): unknown {
    const obj: any = {};
    if (message.heroId !== undefined && message.heroId !== 0) {
      obj.heroId = Math.round(message.heroId);
    }
    if (message.netWorth !== undefined && message.netWorth !== 0) {
      obj.netWorth = Math.round(message.netWorth);
    }
    if (message.level !== undefined && message.level !== 0) {
      obj.level = Math.round(message.level);
    }
    if (message.deaths !== undefined && message.deaths !== 0) {
      obj.deaths = Math.round(message.deaths);
    }
    if (message.respawnTime !== undefined && message.respawnTime !== 0) {
      obj.respawnTime = Math.round(message.respawnTime);
    }
    if (message.hasBuyback !== undefined && message.hasBuyback !== false) {
      obj.hasBuyback = message.hasBuyback;
    }
    if (message.hasAegis !== undefined && message.hasAegis !== false) {
      obj.hasAegis = message.hasAegis;
    }
    if (message.hasRapier !== undefined && message.hasRapier !== false) {
      obj.hasRapier = message.hasRapier;
    }
    if (message.distance !== undefined && message.distance !== 0) {
      obj.distance = Math.round(message.distance);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgServerToGCMatchStateHistory_PlayerState>): CMsgServerToGCMatchStateHistory_PlayerState {
    return CMsgServerToGCMatchStateHistory_PlayerState.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgServerToGCMatchStateHistory_PlayerState>,
  ): CMsgServerToGCMatchStateHistory_PlayerState {
    const message = createBaseCMsgServerToGCMatchStateHistory_PlayerState();
    message.heroId = object.heroId ?? 0;
    message.netWorth = object.netWorth ?? 0;
    message.level = object.level ?? 0;
    message.deaths = object.deaths ?? 0;
    message.respawnTime = object.respawnTime ?? 0;
    message.hasBuyback = object.hasBuyback ?? false;
    message.hasAegis = object.hasAegis ?? false;
    message.hasRapier = object.hasRapier ?? false;
    message.distance = object.distance ?? 0;
    return message;
  },
};

function createBaseCMsgServerToGCMatchStateHistory_TeamState(): CMsgServerToGCMatchStateHistory_TeamState {
  return {
    team: 0,
    playerStates: [],
    towerHealthPct: [],
    barracksHealthPct: [],
    ancientHealthPct: 0,
    glyphCooldown: 0,
    kills: 0,
    creepDistanceSafe: 0,
    creepDistanceMid: 0,
    creepDistanceOff: 0,
  };
}

export const CMsgServerToGCMatchStateHistory_TeamState = {
  encode(message: CMsgServerToGCMatchStateHistory_TeamState, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.team !== undefined && message.team !== 0) {
      writer.uint32(8).uint32(message.team);
    }
    for (const v of message.playerStates) {
      CMsgServerToGCMatchStateHistory_PlayerState.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    writer.uint32(26).fork();
    for (const v of message.towerHealthPct) {
      writer.uint32(v);
    }
    writer.ldelim();
    writer.uint32(34).fork();
    for (const v of message.barracksHealthPct) {
      writer.uint32(v);
    }
    writer.ldelim();
    if (message.ancientHealthPct !== undefined && message.ancientHealthPct !== 0) {
      writer.uint32(40).uint32(message.ancientHealthPct);
    }
    if (message.glyphCooldown !== undefined && message.glyphCooldown !== 0) {
      writer.uint32(48).uint32(message.glyphCooldown);
    }
    if (message.kills !== undefined && message.kills !== 0) {
      writer.uint32(56).uint32(message.kills);
    }
    if (message.creepDistanceSafe !== undefined && message.creepDistanceSafe !== 0) {
      writer.uint32(64).uint32(message.creepDistanceSafe);
    }
    if (message.creepDistanceMid !== undefined && message.creepDistanceMid !== 0) {
      writer.uint32(72).uint32(message.creepDistanceMid);
    }
    if (message.creepDistanceOff !== undefined && message.creepDistanceOff !== 0) {
      writer.uint32(80).uint32(message.creepDistanceOff);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgServerToGCMatchStateHistory_TeamState {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgServerToGCMatchStateHistory_TeamState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.team = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.playerStates.push(CMsgServerToGCMatchStateHistory_PlayerState.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag === 24) {
            message.towerHealthPct.push(reader.uint32());

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.towerHealthPct.push(reader.uint32());
            }

            continue;
          }

          break;
        case 4:
          if (tag === 32) {
            message.barracksHealthPct.push(reader.uint32());

            continue;
          }

          if (tag === 34) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.barracksHealthPct.push(reader.uint32());
            }

            continue;
          }

          break;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.ancientHealthPct = reader.uint32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.glyphCooldown = reader.uint32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.kills = reader.uint32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.creepDistanceSafe = reader.uint32();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.creepDistanceMid = reader.uint32();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.creepDistanceOff = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgServerToGCMatchStateHistory_TeamState {
    return {
      team: isSet(object.team) ? globalThis.Number(object.team) : 0,
      playerStates: globalThis.Array.isArray(object?.playerStates)
        ? object.playerStates.map((e: any) => CMsgServerToGCMatchStateHistory_PlayerState.fromJSON(e))
        : [],
      towerHealthPct: globalThis.Array.isArray(object?.towerHealthPct)
        ? object.towerHealthPct.map((e: any) => globalThis.Number(e))
        : [],
      barracksHealthPct: globalThis.Array.isArray(object?.barracksHealthPct)
        ? object.barracksHealthPct.map((e: any) => globalThis.Number(e))
        : [],
      ancientHealthPct: isSet(object.ancientHealthPct) ? globalThis.Number(object.ancientHealthPct) : 0,
      glyphCooldown: isSet(object.glyphCooldown) ? globalThis.Number(object.glyphCooldown) : 0,
      kills: isSet(object.kills) ? globalThis.Number(object.kills) : 0,
      creepDistanceSafe: isSet(object.creepDistanceSafe) ? globalThis.Number(object.creepDistanceSafe) : 0,
      creepDistanceMid: isSet(object.creepDistanceMid) ? globalThis.Number(object.creepDistanceMid) : 0,
      creepDistanceOff: isSet(object.creepDistanceOff) ? globalThis.Number(object.creepDistanceOff) : 0,
    };
  },

  toJSON(message: CMsgServerToGCMatchStateHistory_TeamState): unknown {
    const obj: any = {};
    if (message.team !== undefined && message.team !== 0) {
      obj.team = Math.round(message.team);
    }
    if (message.playerStates?.length) {
      obj.playerStates = message.playerStates.map((e) => CMsgServerToGCMatchStateHistory_PlayerState.toJSON(e));
    }
    if (message.towerHealthPct?.length) {
      obj.towerHealthPct = message.towerHealthPct.map((e) => Math.round(e));
    }
    if (message.barracksHealthPct?.length) {
      obj.barracksHealthPct = message.barracksHealthPct.map((e) => Math.round(e));
    }
    if (message.ancientHealthPct !== undefined && message.ancientHealthPct !== 0) {
      obj.ancientHealthPct = Math.round(message.ancientHealthPct);
    }
    if (message.glyphCooldown !== undefined && message.glyphCooldown !== 0) {
      obj.glyphCooldown = Math.round(message.glyphCooldown);
    }
    if (message.kills !== undefined && message.kills !== 0) {
      obj.kills = Math.round(message.kills);
    }
    if (message.creepDistanceSafe !== undefined && message.creepDistanceSafe !== 0) {
      obj.creepDistanceSafe = Math.round(message.creepDistanceSafe);
    }
    if (message.creepDistanceMid !== undefined && message.creepDistanceMid !== 0) {
      obj.creepDistanceMid = Math.round(message.creepDistanceMid);
    }
    if (message.creepDistanceOff !== undefined && message.creepDistanceOff !== 0) {
      obj.creepDistanceOff = Math.round(message.creepDistanceOff);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgServerToGCMatchStateHistory_TeamState>): CMsgServerToGCMatchStateHistory_TeamState {
    return CMsgServerToGCMatchStateHistory_TeamState.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgServerToGCMatchStateHistory_TeamState>,
  ): CMsgServerToGCMatchStateHistory_TeamState {
    const message = createBaseCMsgServerToGCMatchStateHistory_TeamState();
    message.team = object.team ?? 0;
    message.playerStates =
      object.playerStates?.map((e) => CMsgServerToGCMatchStateHistory_PlayerState.fromPartial(e)) || [];
    message.towerHealthPct = object.towerHealthPct?.map((e) => e) || [];
    message.barracksHealthPct = object.barracksHealthPct?.map((e) => e) || [];
    message.ancientHealthPct = object.ancientHealthPct ?? 0;
    message.glyphCooldown = object.glyphCooldown ?? 0;
    message.kills = object.kills ?? 0;
    message.creepDistanceSafe = object.creepDistanceSafe ?? 0;
    message.creepDistanceMid = object.creepDistanceMid ?? 0;
    message.creepDistanceOff = object.creepDistanceOff ?? 0;
    return message;
  },
};

function createBaseCMsgServerToGCMatchStateHistory_MatchState(): CMsgServerToGCMatchStateHistory_MatchState {
  return { gameTime: 0, radiantState: undefined, direState: undefined };
}

export const CMsgServerToGCMatchStateHistory_MatchState = {
  encode(message: CMsgServerToGCMatchStateHistory_MatchState, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.gameTime !== undefined && message.gameTime !== 0) {
      writer.uint32(8).uint32(message.gameTime);
    }
    if (message.radiantState !== undefined) {
      CMsgServerToGCMatchStateHistory_TeamState.encode(message.radiantState, writer.uint32(18).fork()).ldelim();
    }
    if (message.direState !== undefined) {
      CMsgServerToGCMatchStateHistory_TeamState.encode(message.direState, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgServerToGCMatchStateHistory_MatchState {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgServerToGCMatchStateHistory_MatchState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.gameTime = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.radiantState = CMsgServerToGCMatchStateHistory_TeamState.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.direState = CMsgServerToGCMatchStateHistory_TeamState.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgServerToGCMatchStateHistory_MatchState {
    return {
      gameTime: isSet(object.gameTime) ? globalThis.Number(object.gameTime) : 0,
      radiantState: isSet(object.radiantState)
        ? CMsgServerToGCMatchStateHistory_TeamState.fromJSON(object.radiantState)
        : undefined,
      direState: isSet(object.direState)
        ? CMsgServerToGCMatchStateHistory_TeamState.fromJSON(object.direState)
        : undefined,
    };
  },

  toJSON(message: CMsgServerToGCMatchStateHistory_MatchState): unknown {
    const obj: any = {};
    if (message.gameTime !== undefined && message.gameTime !== 0) {
      obj.gameTime = Math.round(message.gameTime);
    }
    if (message.radiantState !== undefined) {
      obj.radiantState = CMsgServerToGCMatchStateHistory_TeamState.toJSON(message.radiantState);
    }
    if (message.direState !== undefined) {
      obj.direState = CMsgServerToGCMatchStateHistory_TeamState.toJSON(message.direState);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgServerToGCMatchStateHistory_MatchState>): CMsgServerToGCMatchStateHistory_MatchState {
    return CMsgServerToGCMatchStateHistory_MatchState.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgServerToGCMatchStateHistory_MatchState>,
  ): CMsgServerToGCMatchStateHistory_MatchState {
    const message = createBaseCMsgServerToGCMatchStateHistory_MatchState();
    message.gameTime = object.gameTime ?? 0;
    message.radiantState = (object.radiantState !== undefined && object.radiantState !== null)
      ? CMsgServerToGCMatchStateHistory_TeamState.fromPartial(object.radiantState)
      : undefined;
    message.direState = (object.direState !== undefined && object.direState !== null)
      ? CMsgServerToGCMatchStateHistory_TeamState.fromPartial(object.direState)
      : undefined;
    return message;
  },
};

function createBaseCMsgMatchStateSteamMLEntry(): CMsgMatchStateSteamMLEntry {
  return { matchState: undefined, mmr: 0, radiantWon: false };
}

export const CMsgMatchStateSteamMLEntry = {
  encode(message: CMsgMatchStateSteamMLEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.matchState !== undefined) {
      CMsgServerToGCMatchStateHistory_MatchState.encode(message.matchState, writer.uint32(10).fork()).ldelim();
    }
    if (message.mmr !== undefined && message.mmr !== 0) {
      writer.uint32(16).uint32(message.mmr);
    }
    if (message.radiantWon !== undefined && message.radiantWon !== false) {
      writer.uint32(24).bool(message.radiantWon);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgMatchStateSteamMLEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgMatchStateSteamMLEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.matchState = CMsgServerToGCMatchStateHistory_MatchState.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.mmr = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.radiantWon = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgMatchStateSteamMLEntry {
    return {
      matchState: isSet(object.matchState)
        ? CMsgServerToGCMatchStateHistory_MatchState.fromJSON(object.matchState)
        : undefined,
      mmr: isSet(object.mmr) ? globalThis.Number(object.mmr) : 0,
      radiantWon: isSet(object.radiantWon) ? globalThis.Boolean(object.radiantWon) : false,
    };
  },

  toJSON(message: CMsgMatchStateSteamMLEntry): unknown {
    const obj: any = {};
    if (message.matchState !== undefined) {
      obj.matchState = CMsgServerToGCMatchStateHistory_MatchState.toJSON(message.matchState);
    }
    if (message.mmr !== undefined && message.mmr !== 0) {
      obj.mmr = Math.round(message.mmr);
    }
    if (message.radiantWon !== undefined && message.radiantWon !== false) {
      obj.radiantWon = message.radiantWon;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgMatchStateSteamMLEntry>): CMsgMatchStateSteamMLEntry {
    return CMsgMatchStateSteamMLEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgMatchStateSteamMLEntry>): CMsgMatchStateSteamMLEntry {
    const message = createBaseCMsgMatchStateSteamMLEntry();
    message.matchState = (object.matchState !== undefined && object.matchState !== null)
      ? CMsgServerToGCMatchStateHistory_MatchState.fromPartial(object.matchState)
      : undefined;
    message.mmr = object.mmr ?? 0;
    message.radiantWon = object.radiantWon ?? false;
    return message;
  },
};

function createBaseCMsgLaneSelectionSteamMLEntry(): CMsgLaneSelectionSteamMLEntry {
  return { heroIds: [], lanes: [] };
}

export const CMsgLaneSelectionSteamMLEntry = {
  encode(message: CMsgLaneSelectionSteamMLEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.heroIds) {
      writer.int32(v);
    }
    writer.ldelim();
    writer.uint32(18).fork();
    for (const v of message.lanes) {
      writer.uint32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgLaneSelectionSteamMLEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgLaneSelectionSteamMLEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.heroIds.push(reader.int32());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.heroIds.push(reader.int32());
            }

            continue;
          }

          break;
        case 2:
          if (tag === 16) {
            message.lanes.push(reader.uint32());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.lanes.push(reader.uint32());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgLaneSelectionSteamMLEntry {
    return {
      heroIds: globalThis.Array.isArray(object?.heroIds) ? object.heroIds.map((e: any) => globalThis.Number(e)) : [],
      lanes: globalThis.Array.isArray(object?.lanes) ? object.lanes.map((e: any) => globalThis.Number(e)) : [],
    };
  },

  toJSON(message: CMsgLaneSelectionSteamMLEntry): unknown {
    const obj: any = {};
    if (message.heroIds?.length) {
      obj.heroIds = message.heroIds.map((e) => Math.round(e));
    }
    if (message.lanes?.length) {
      obj.lanes = message.lanes.map((e) => Math.round(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgLaneSelectionSteamMLEntry>): CMsgLaneSelectionSteamMLEntry {
    return CMsgLaneSelectionSteamMLEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgLaneSelectionSteamMLEntry>): CMsgLaneSelectionSteamMLEntry {
    const message = createBaseCMsgLaneSelectionSteamMLEntry();
    message.heroIds = object.heroIds?.map((e) => e) || [];
    message.lanes = object.lanes?.map((e) => e) || [];
    return message;
  },
};

function createBaseCMsgAbilitySelectionSteamMLEntry(): CMsgAbilitySelectionSteamMLEntry {
  return { mmr: 0, heroId: 0, enemyHeroIds: [], lane: 0, abilities: [], selectedAbility: -1 };
}

export const CMsgAbilitySelectionSteamMLEntry = {
  encode(message: CMsgAbilitySelectionSteamMLEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.mmr !== undefined && message.mmr !== 0) {
      writer.uint32(8).uint32(message.mmr);
    }
    if (message.heroId !== undefined && message.heroId !== 0) {
      writer.uint32(16).int32(message.heroId);
    }
    writer.uint32(26).fork();
    for (const v of message.enemyHeroIds) {
      writer.int32(v);
    }
    writer.ldelim();
    if (message.lane !== undefined && message.lane !== 0) {
      writer.uint32(32).uint32(message.lane);
    }
    writer.uint32(42).fork();
    for (const v of message.abilities) {
      writer.int32(v);
    }
    writer.ldelim();
    if (message.selectedAbility !== undefined && message.selectedAbility !== -1) {
      writer.uint32(48).int32(message.selectedAbility);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgAbilitySelectionSteamMLEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgAbilitySelectionSteamMLEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.mmr = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.heroId = reader.int32();
          continue;
        case 3:
          if (tag === 24) {
            message.enemyHeroIds.push(reader.int32());

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.enemyHeroIds.push(reader.int32());
            }

            continue;
          }

          break;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.lane = reader.uint32();
          continue;
        case 5:
          if (tag === 40) {
            message.abilities.push(reader.int32());

            continue;
          }

          if (tag === 42) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.abilities.push(reader.int32());
            }

            continue;
          }

          break;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.selectedAbility = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgAbilitySelectionSteamMLEntry {
    return {
      mmr: isSet(object.mmr) ? globalThis.Number(object.mmr) : 0,
      heroId: isSet(object.heroId) ? globalThis.Number(object.heroId) : 0,
      enemyHeroIds: globalThis.Array.isArray(object?.enemyHeroIds)
        ? object.enemyHeroIds.map((e: any) => globalThis.Number(e))
        : [],
      lane: isSet(object.lane) ? globalThis.Number(object.lane) : 0,
      abilities: globalThis.Array.isArray(object?.abilities)
        ? object.abilities.map((e: any) => globalThis.Number(e))
        : [],
      selectedAbility: isSet(object.selectedAbility) ? globalThis.Number(object.selectedAbility) : -1,
    };
  },

  toJSON(message: CMsgAbilitySelectionSteamMLEntry): unknown {
    const obj: any = {};
    if (message.mmr !== undefined && message.mmr !== 0) {
      obj.mmr = Math.round(message.mmr);
    }
    if (message.heroId !== undefined && message.heroId !== 0) {
      obj.heroId = Math.round(message.heroId);
    }
    if (message.enemyHeroIds?.length) {
      obj.enemyHeroIds = message.enemyHeroIds.map((e) => Math.round(e));
    }
    if (message.lane !== undefined && message.lane !== 0) {
      obj.lane = Math.round(message.lane);
    }
    if (message.abilities?.length) {
      obj.abilities = message.abilities.map((e) => Math.round(e));
    }
    if (message.selectedAbility !== undefined && message.selectedAbility !== -1) {
      obj.selectedAbility = Math.round(message.selectedAbility);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgAbilitySelectionSteamMLEntry>): CMsgAbilitySelectionSteamMLEntry {
    return CMsgAbilitySelectionSteamMLEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgAbilitySelectionSteamMLEntry>): CMsgAbilitySelectionSteamMLEntry {
    const message = createBaseCMsgAbilitySelectionSteamMLEntry();
    message.mmr = object.mmr ?? 0;
    message.heroId = object.heroId ?? 0;
    message.enemyHeroIds = object.enemyHeroIds?.map((e) => e) || [];
    message.lane = object.lane ?? 0;
    message.abilities = object.abilities?.map((e) => e) || [];
    message.selectedAbility = object.selectedAbility ?? -1;
    return message;
  },
};

function createBaseCMsgItemPurchasePregameSteamMLEntry(): CMsgItemPurchasePregameSteamMLEntry {
  return { mmr: 0, lane: 0, balance: 0, heroId: 0, alliedHeroIds: [], enemyHeroIds: [], items: [] };
}

export const CMsgItemPurchasePregameSteamMLEntry = {
  encode(message: CMsgItemPurchasePregameSteamMLEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.mmr !== undefined && message.mmr !== 0) {
      writer.uint32(8).uint32(message.mmr);
    }
    if (message.lane !== undefined && message.lane !== 0) {
      writer.uint32(16).uint32(message.lane);
    }
    if (message.balance !== undefined && message.balance !== 0) {
      writer.uint32(29).float(message.balance);
    }
    if (message.heroId !== undefined && message.heroId !== 0) {
      writer.uint32(32).int32(message.heroId);
    }
    writer.uint32(42).fork();
    for (const v of message.alliedHeroIds) {
      writer.int32(v);
    }
    writer.ldelim();
    writer.uint32(50).fork();
    for (const v of message.enemyHeroIds) {
      writer.int32(v);
    }
    writer.ldelim();
    writer.uint32(58).fork();
    for (const v of message.items) {
      writer.int32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgItemPurchasePregameSteamMLEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgItemPurchasePregameSteamMLEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.mmr = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.lane = reader.uint32();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.balance = reader.float();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.heroId = reader.int32();
          continue;
        case 5:
          if (tag === 40) {
            message.alliedHeroIds.push(reader.int32());

            continue;
          }

          if (tag === 42) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.alliedHeroIds.push(reader.int32());
            }

            continue;
          }

          break;
        case 6:
          if (tag === 48) {
            message.enemyHeroIds.push(reader.int32());

            continue;
          }

          if (tag === 50) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.enemyHeroIds.push(reader.int32());
            }

            continue;
          }

          break;
        case 7:
          if (tag === 56) {
            message.items.push(reader.int32());

            continue;
          }

          if (tag === 58) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.items.push(reader.int32());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgItemPurchasePregameSteamMLEntry {
    return {
      mmr: isSet(object.mmr) ? globalThis.Number(object.mmr) : 0,
      lane: isSet(object.lane) ? globalThis.Number(object.lane) : 0,
      balance: isSet(object.balance) ? globalThis.Number(object.balance) : 0,
      heroId: isSet(object.heroId) ? globalThis.Number(object.heroId) : 0,
      alliedHeroIds: globalThis.Array.isArray(object?.alliedHeroIds)
        ? object.alliedHeroIds.map((e: any) => globalThis.Number(e))
        : [],
      enemyHeroIds: globalThis.Array.isArray(object?.enemyHeroIds)
        ? object.enemyHeroIds.map((e: any) => globalThis.Number(e))
        : [],
      items: globalThis.Array.isArray(object?.items) ? object.items.map((e: any) => globalThis.Number(e)) : [],
    };
  },

  toJSON(message: CMsgItemPurchasePregameSteamMLEntry): unknown {
    const obj: any = {};
    if (message.mmr !== undefined && message.mmr !== 0) {
      obj.mmr = Math.round(message.mmr);
    }
    if (message.lane !== undefined && message.lane !== 0) {
      obj.lane = Math.round(message.lane);
    }
    if (message.balance !== undefined && message.balance !== 0) {
      obj.balance = message.balance;
    }
    if (message.heroId !== undefined && message.heroId !== 0) {
      obj.heroId = Math.round(message.heroId);
    }
    if (message.alliedHeroIds?.length) {
      obj.alliedHeroIds = message.alliedHeroIds.map((e) => Math.round(e));
    }
    if (message.enemyHeroIds?.length) {
      obj.enemyHeroIds = message.enemyHeroIds.map((e) => Math.round(e));
    }
    if (message.items?.length) {
      obj.items = message.items.map((e) => Math.round(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgItemPurchasePregameSteamMLEntry>): CMsgItemPurchasePregameSteamMLEntry {
    return CMsgItemPurchasePregameSteamMLEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgItemPurchasePregameSteamMLEntry>): CMsgItemPurchasePregameSteamMLEntry {
    const message = createBaseCMsgItemPurchasePregameSteamMLEntry();
    message.mmr = object.mmr ?? 0;
    message.lane = object.lane ?? 0;
    message.balance = object.balance ?? 0;
    message.heroId = object.heroId ?? 0;
    message.alliedHeroIds = object.alliedHeroIds?.map((e) => e) || [];
    message.enemyHeroIds = object.enemyHeroIds?.map((e) => e) || [];
    message.items = object.items?.map((e) => e) || [];
    return message;
  },
};

function createBaseCMsgItemPurchaseSteamMLEntry(): CMsgItemPurchaseSteamMLEntry {
  return { mmr: 0, lane: 0, heroId: 0, alliedHeroIds: [], enemyHeroIds: [], items: [], itemsToBePurchased: [] };
}

export const CMsgItemPurchaseSteamMLEntry = {
  encode(message: CMsgItemPurchaseSteamMLEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.mmr !== undefined && message.mmr !== 0) {
      writer.uint32(8).uint32(message.mmr);
    }
    if (message.lane !== undefined && message.lane !== 0) {
      writer.uint32(16).uint32(message.lane);
    }
    if (message.heroId !== undefined && message.heroId !== 0) {
      writer.uint32(24).int32(message.heroId);
    }
    writer.uint32(34).fork();
    for (const v of message.alliedHeroIds) {
      writer.int32(v);
    }
    writer.ldelim();
    writer.uint32(42).fork();
    for (const v of message.enemyHeroIds) {
      writer.int32(v);
    }
    writer.ldelim();
    writer.uint32(50).fork();
    for (const v of message.items) {
      writer.int32(v);
    }
    writer.ldelim();
    writer.uint32(58).fork();
    for (const v of message.itemsToBePurchased) {
      writer.int32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgItemPurchaseSteamMLEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgItemPurchaseSteamMLEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.mmr = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.lane = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.heroId = reader.int32();
          continue;
        case 4:
          if (tag === 32) {
            message.alliedHeroIds.push(reader.int32());

            continue;
          }

          if (tag === 34) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.alliedHeroIds.push(reader.int32());
            }

            continue;
          }

          break;
        case 5:
          if (tag === 40) {
            message.enemyHeroIds.push(reader.int32());

            continue;
          }

          if (tag === 42) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.enemyHeroIds.push(reader.int32());
            }

            continue;
          }

          break;
        case 6:
          if (tag === 48) {
            message.items.push(reader.int32());

            continue;
          }

          if (tag === 50) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.items.push(reader.int32());
            }

            continue;
          }

          break;
        case 7:
          if (tag === 56) {
            message.itemsToBePurchased.push(reader.int32());

            continue;
          }

          if (tag === 58) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.itemsToBePurchased.push(reader.int32());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgItemPurchaseSteamMLEntry {
    return {
      mmr: isSet(object.mmr) ? globalThis.Number(object.mmr) : 0,
      lane: isSet(object.lane) ? globalThis.Number(object.lane) : 0,
      heroId: isSet(object.heroId) ? globalThis.Number(object.heroId) : 0,
      alliedHeroIds: globalThis.Array.isArray(object?.alliedHeroIds)
        ? object.alliedHeroIds.map((e: any) => globalThis.Number(e))
        : [],
      enemyHeroIds: globalThis.Array.isArray(object?.enemyHeroIds)
        ? object.enemyHeroIds.map((e: any) => globalThis.Number(e))
        : [],
      items: globalThis.Array.isArray(object?.items) ? object.items.map((e: any) => globalThis.Number(e)) : [],
      itemsToBePurchased: globalThis.Array.isArray(object?.itemsToBePurchased)
        ? object.itemsToBePurchased.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: CMsgItemPurchaseSteamMLEntry): unknown {
    const obj: any = {};
    if (message.mmr !== undefined && message.mmr !== 0) {
      obj.mmr = Math.round(message.mmr);
    }
    if (message.lane !== undefined && message.lane !== 0) {
      obj.lane = Math.round(message.lane);
    }
    if (message.heroId !== undefined && message.heroId !== 0) {
      obj.heroId = Math.round(message.heroId);
    }
    if (message.alliedHeroIds?.length) {
      obj.alliedHeroIds = message.alliedHeroIds.map((e) => Math.round(e));
    }
    if (message.enemyHeroIds?.length) {
      obj.enemyHeroIds = message.enemyHeroIds.map((e) => Math.round(e));
    }
    if (message.items?.length) {
      obj.items = message.items.map((e) => Math.round(e));
    }
    if (message.itemsToBePurchased?.length) {
      obj.itemsToBePurchased = message.itemsToBePurchased.map((e) => Math.round(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgItemPurchaseSteamMLEntry>): CMsgItemPurchaseSteamMLEntry {
    return CMsgItemPurchaseSteamMLEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgItemPurchaseSteamMLEntry>): CMsgItemPurchaseSteamMLEntry {
    const message = createBaseCMsgItemPurchaseSteamMLEntry();
    message.mmr = object.mmr ?? 0;
    message.lane = object.lane ?? 0;
    message.heroId = object.heroId ?? 0;
    message.alliedHeroIds = object.alliedHeroIds?.map((e) => e) || [];
    message.enemyHeroIds = object.enemyHeroIds?.map((e) => e) || [];
    message.items = object.items?.map((e) => e) || [];
    message.itemsToBePurchased = object.itemsToBePurchased?.map((e) => e) || [];
    return message;
  },
};

function createBaseCMsgItemPurchaseSequenceSteamMLEntry(): CMsgItemPurchaseSequenceSteamMLEntry {
  return { mmr: 0, lane: 0, heroId: 0, alliedHeroIds: [], enemyHeroIds: [], items: [], itemToBePurchased: -1 };
}

export const CMsgItemPurchaseSequenceSteamMLEntry = {
  encode(message: CMsgItemPurchaseSequenceSteamMLEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.mmr !== undefined && message.mmr !== 0) {
      writer.uint32(8).uint32(message.mmr);
    }
    if (message.lane !== undefined && message.lane !== 0) {
      writer.uint32(16).uint32(message.lane);
    }
    if (message.heroId !== undefined && message.heroId !== 0) {
      writer.uint32(24).int32(message.heroId);
    }
    writer.uint32(34).fork();
    for (const v of message.alliedHeroIds) {
      writer.int32(v);
    }
    writer.ldelim();
    writer.uint32(42).fork();
    for (const v of message.enemyHeroIds) {
      writer.int32(v);
    }
    writer.ldelim();
    writer.uint32(50).fork();
    for (const v of message.items) {
      writer.int32(v);
    }
    writer.ldelim();
    if (message.itemToBePurchased !== undefined && message.itemToBePurchased !== -1) {
      writer.uint32(56).int32(message.itemToBePurchased);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgItemPurchaseSequenceSteamMLEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgItemPurchaseSequenceSteamMLEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.mmr = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.lane = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.heroId = reader.int32();
          continue;
        case 4:
          if (tag === 32) {
            message.alliedHeroIds.push(reader.int32());

            continue;
          }

          if (tag === 34) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.alliedHeroIds.push(reader.int32());
            }

            continue;
          }

          break;
        case 5:
          if (tag === 40) {
            message.enemyHeroIds.push(reader.int32());

            continue;
          }

          if (tag === 42) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.enemyHeroIds.push(reader.int32());
            }

            continue;
          }

          break;
        case 6:
          if (tag === 48) {
            message.items.push(reader.int32());

            continue;
          }

          if (tag === 50) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.items.push(reader.int32());
            }

            continue;
          }

          break;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.itemToBePurchased = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgItemPurchaseSequenceSteamMLEntry {
    return {
      mmr: isSet(object.mmr) ? globalThis.Number(object.mmr) : 0,
      lane: isSet(object.lane) ? globalThis.Number(object.lane) : 0,
      heroId: isSet(object.heroId) ? globalThis.Number(object.heroId) : 0,
      alliedHeroIds: globalThis.Array.isArray(object?.alliedHeroIds)
        ? object.alliedHeroIds.map((e: any) => globalThis.Number(e))
        : [],
      enemyHeroIds: globalThis.Array.isArray(object?.enemyHeroIds)
        ? object.enemyHeroIds.map((e: any) => globalThis.Number(e))
        : [],
      items: globalThis.Array.isArray(object?.items) ? object.items.map((e: any) => globalThis.Number(e)) : [],
      itemToBePurchased: isSet(object.itemToBePurchased) ? globalThis.Number(object.itemToBePurchased) : -1,
    };
  },

  toJSON(message: CMsgItemPurchaseSequenceSteamMLEntry): unknown {
    const obj: any = {};
    if (message.mmr !== undefined && message.mmr !== 0) {
      obj.mmr = Math.round(message.mmr);
    }
    if (message.lane !== undefined && message.lane !== 0) {
      obj.lane = Math.round(message.lane);
    }
    if (message.heroId !== undefined && message.heroId !== 0) {
      obj.heroId = Math.round(message.heroId);
    }
    if (message.alliedHeroIds?.length) {
      obj.alliedHeroIds = message.alliedHeroIds.map((e) => Math.round(e));
    }
    if (message.enemyHeroIds?.length) {
      obj.enemyHeroIds = message.enemyHeroIds.map((e) => Math.round(e));
    }
    if (message.items?.length) {
      obj.items = message.items.map((e) => Math.round(e));
    }
    if (message.itemToBePurchased !== undefined && message.itemToBePurchased !== -1) {
      obj.itemToBePurchased = Math.round(message.itemToBePurchased);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgItemPurchaseSequenceSteamMLEntry>): CMsgItemPurchaseSequenceSteamMLEntry {
    return CMsgItemPurchaseSequenceSteamMLEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgItemPurchaseSequenceSteamMLEntry>): CMsgItemPurchaseSequenceSteamMLEntry {
    const message = createBaseCMsgItemPurchaseSequenceSteamMLEntry();
    message.mmr = object.mmr ?? 0;
    message.lane = object.lane ?? 0;
    message.heroId = object.heroId ?? 0;
    message.alliedHeroIds = object.alliedHeroIds?.map((e) => e) || [];
    message.enemyHeroIds = object.enemyHeroIds?.map((e) => e) || [];
    message.items = object.items?.map((e) => e) || [];
    message.itemToBePurchased = object.itemToBePurchased ?? -1;
    return message;
  },
};

function createBaseCMsgServerToGCCavernCrawlIsHeroActive(): CMsgServerToGCCavernCrawlIsHeroActive {
  return { eventId: 0, accountId: 0, preferredMapVariant: 255, heroId: 0, turboMode: false };
}

export const CMsgServerToGCCavernCrawlIsHeroActive = {
  encode(message: CMsgServerToGCCavernCrawlIsHeroActive, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.eventId !== undefined && message.eventId !== 0) {
      writer.uint32(8).uint32(message.eventId);
    }
    if (message.accountId !== undefined && message.accountId !== 0) {
      writer.uint32(16).uint32(message.accountId);
    }
    if (message.preferredMapVariant !== undefined && message.preferredMapVariant !== 255) {
      writer.uint32(24).uint32(message.preferredMapVariant);
    }
    if (message.heroId !== undefined && message.heroId !== 0) {
      writer.uint32(32).int32(message.heroId);
    }
    if (message.turboMode !== undefined && message.turboMode !== false) {
      writer.uint32(40).bool(message.turboMode);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgServerToGCCavernCrawlIsHeroActive {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgServerToGCCavernCrawlIsHeroActive();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.eventId = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.preferredMapVariant = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.heroId = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.turboMode = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgServerToGCCavernCrawlIsHeroActive {
    return {
      eventId: isSet(object.eventId) ? globalThis.Number(object.eventId) : 0,
      accountId: isSet(object.accountId) ? globalThis.Number(object.accountId) : 0,
      preferredMapVariant: isSet(object.preferredMapVariant) ? globalThis.Number(object.preferredMapVariant) : 255,
      heroId: isSet(object.heroId) ? globalThis.Number(object.heroId) : 0,
      turboMode: isSet(object.turboMode) ? globalThis.Boolean(object.turboMode) : false,
    };
  },

  toJSON(message: CMsgServerToGCCavernCrawlIsHeroActive): unknown {
    const obj: any = {};
    if (message.eventId !== undefined && message.eventId !== 0) {
      obj.eventId = Math.round(message.eventId);
    }
    if (message.accountId !== undefined && message.accountId !== 0) {
      obj.accountId = Math.round(message.accountId);
    }
    if (message.preferredMapVariant !== undefined && message.preferredMapVariant !== 255) {
      obj.preferredMapVariant = Math.round(message.preferredMapVariant);
    }
    if (message.heroId !== undefined && message.heroId !== 0) {
      obj.heroId = Math.round(message.heroId);
    }
    if (message.turboMode !== undefined && message.turboMode !== false) {
      obj.turboMode = message.turboMode;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgServerToGCCavernCrawlIsHeroActive>): CMsgServerToGCCavernCrawlIsHeroActive {
    return CMsgServerToGCCavernCrawlIsHeroActive.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgServerToGCCavernCrawlIsHeroActive>): CMsgServerToGCCavernCrawlIsHeroActive {
    const message = createBaseCMsgServerToGCCavernCrawlIsHeroActive();
    message.eventId = object.eventId ?? 0;
    message.accountId = object.accountId ?? 0;
    message.preferredMapVariant = object.preferredMapVariant ?? 255;
    message.heroId = object.heroId ?? 0;
    message.turboMode = object.turboMode ?? false;
    return message;
  },
};

function createBaseCMsgServerToGCPlayerChallengeHistory(): CMsgServerToGCPlayerChallengeHistory {
  return { matchId: "0", averageRank: 0, challengeRecords: [] };
}

export const CMsgServerToGCPlayerChallengeHistory = {
  encode(message: CMsgServerToGCPlayerChallengeHistory, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.matchId !== undefined && message.matchId !== "0") {
      writer.uint32(8).uint64(message.matchId);
    }
    if (message.averageRank !== undefined && message.averageRank !== 0) {
      writer.uint32(16).uint32(message.averageRank);
    }
    for (const v of message.challengeRecords) {
      CMsgServerToGCPlayerChallengeHistory_PlayerChallenge.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgServerToGCPlayerChallengeHistory {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgServerToGCPlayerChallengeHistory();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.matchId = longToString(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.averageRank = reader.uint32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.challengeRecords.push(
            CMsgServerToGCPlayerChallengeHistory_PlayerChallenge.decode(reader, reader.uint32()),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgServerToGCPlayerChallengeHistory {
    return {
      matchId: isSet(object.matchId) ? globalThis.String(object.matchId) : "0",
      averageRank: isSet(object.averageRank) ? globalThis.Number(object.averageRank) : 0,
      challengeRecords: globalThis.Array.isArray(object?.challengeRecords)
        ? object.challengeRecords.map((e: any) => CMsgServerToGCPlayerChallengeHistory_PlayerChallenge.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgServerToGCPlayerChallengeHistory): unknown {
    const obj: any = {};
    if (message.matchId !== undefined && message.matchId !== "0") {
      obj.matchId = message.matchId;
    }
    if (message.averageRank !== undefined && message.averageRank !== 0) {
      obj.averageRank = Math.round(message.averageRank);
    }
    if (message.challengeRecords?.length) {
      obj.challengeRecords = message.challengeRecords.map((e) =>
        CMsgServerToGCPlayerChallengeHistory_PlayerChallenge.toJSON(e)
      );
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgServerToGCPlayerChallengeHistory>): CMsgServerToGCPlayerChallengeHistory {
    return CMsgServerToGCPlayerChallengeHistory.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgServerToGCPlayerChallengeHistory>): CMsgServerToGCPlayerChallengeHistory {
    const message = createBaseCMsgServerToGCPlayerChallengeHistory();
    message.matchId = object.matchId ?? "0";
    message.averageRank = object.averageRank ?? 0;
    message.challengeRecords =
      object.challengeRecords?.map((e) => CMsgServerToGCPlayerChallengeHistory_PlayerChallenge.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgServerToGCPlayerChallengeHistory_PlayerChallenge(): CMsgServerToGCPlayerChallengeHistory_PlayerChallenge {
  return {
    accountId: 0,
    challengeType: 0,
    challengeId1: 0,
    challengeId2: 0,
    progressValueStart: 0,
    progressValueEnd: 0,
    teamWon: false,
    auditData: "0",
    heroId: 0,
    rankCompleted: 0,
  };
}

export const CMsgServerToGCPlayerChallengeHistory_PlayerChallenge = {
  encode(
    message: CMsgServerToGCPlayerChallengeHistory_PlayerChallenge,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.accountId !== undefined && message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    if (message.challengeType !== undefined && message.challengeType !== 0) {
      writer.uint32(16).int32(message.challengeType);
    }
    if (message.challengeId1 !== undefined && message.challengeId1 !== 0) {
      writer.uint32(24).uint32(message.challengeId1);
    }
    if (message.challengeId2 !== undefined && message.challengeId2 !== 0) {
      writer.uint32(32).uint32(message.challengeId2);
    }
    if (message.progressValueStart !== undefined && message.progressValueStart !== 0) {
      writer.uint32(40).uint32(message.progressValueStart);
    }
    if (message.progressValueEnd !== undefined && message.progressValueEnd !== 0) {
      writer.uint32(48).uint32(message.progressValueEnd);
    }
    if (message.teamWon !== undefined && message.teamWon !== false) {
      writer.uint32(56).bool(message.teamWon);
    }
    if (message.auditData !== undefined && message.auditData !== "0") {
      writer.uint32(64).uint64(message.auditData);
    }
    if (message.heroId !== undefined && message.heroId !== 0) {
      writer.uint32(72).int32(message.heroId);
    }
    if (message.rankCompleted !== undefined && message.rankCompleted !== 0) {
      writer.uint32(80).uint32(message.rankCompleted);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgServerToGCPlayerChallengeHistory_PlayerChallenge {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgServerToGCPlayerChallengeHistory_PlayerChallenge();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.challengeType = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.challengeId1 = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.challengeId2 = reader.uint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.progressValueStart = reader.uint32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.progressValueEnd = reader.uint32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.teamWon = reader.bool();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.auditData = longToString(reader.uint64() as Long);
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.heroId = reader.int32();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.rankCompleted = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgServerToGCPlayerChallengeHistory_PlayerChallenge {
    return {
      accountId: isSet(object.accountId) ? globalThis.Number(object.accountId) : 0,
      challengeType: isSet(object.challengeType) ? ePlayerChallengeHistoryTypeFromJSON(object.challengeType) : 0,
      challengeId1: isSet(object.challengeId1) ? globalThis.Number(object.challengeId1) : 0,
      challengeId2: isSet(object.challengeId2) ? globalThis.Number(object.challengeId2) : 0,
      progressValueStart: isSet(object.progressValueStart) ? globalThis.Number(object.progressValueStart) : 0,
      progressValueEnd: isSet(object.progressValueEnd) ? globalThis.Number(object.progressValueEnd) : 0,
      teamWon: isSet(object.teamWon) ? globalThis.Boolean(object.teamWon) : false,
      auditData: isSet(object.auditData) ? globalThis.String(object.auditData) : "0",
      heroId: isSet(object.heroId) ? globalThis.Number(object.heroId) : 0,
      rankCompleted: isSet(object.rankCompleted) ? globalThis.Number(object.rankCompleted) : 0,
    };
  },

  toJSON(message: CMsgServerToGCPlayerChallengeHistory_PlayerChallenge): unknown {
    const obj: any = {};
    if (message.accountId !== undefined && message.accountId !== 0) {
      obj.accountId = Math.round(message.accountId);
    }
    if (message.challengeType !== undefined && message.challengeType !== 0) {
      obj.challengeType = ePlayerChallengeHistoryTypeToJSON(message.challengeType);
    }
    if (message.challengeId1 !== undefined && message.challengeId1 !== 0) {
      obj.challengeId1 = Math.round(message.challengeId1);
    }
    if (message.challengeId2 !== undefined && message.challengeId2 !== 0) {
      obj.challengeId2 = Math.round(message.challengeId2);
    }
    if (message.progressValueStart !== undefined && message.progressValueStart !== 0) {
      obj.progressValueStart = Math.round(message.progressValueStart);
    }
    if (message.progressValueEnd !== undefined && message.progressValueEnd !== 0) {
      obj.progressValueEnd = Math.round(message.progressValueEnd);
    }
    if (message.teamWon !== undefined && message.teamWon !== false) {
      obj.teamWon = message.teamWon;
    }
    if (message.auditData !== undefined && message.auditData !== "0") {
      obj.auditData = message.auditData;
    }
    if (message.heroId !== undefined && message.heroId !== 0) {
      obj.heroId = Math.round(message.heroId);
    }
    if (message.rankCompleted !== undefined && message.rankCompleted !== 0) {
      obj.rankCompleted = Math.round(message.rankCompleted);
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgServerToGCPlayerChallengeHistory_PlayerChallenge>,
  ): CMsgServerToGCPlayerChallengeHistory_PlayerChallenge {
    return CMsgServerToGCPlayerChallengeHistory_PlayerChallenge.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgServerToGCPlayerChallengeHistory_PlayerChallenge>,
  ): CMsgServerToGCPlayerChallengeHistory_PlayerChallenge {
    const message = createBaseCMsgServerToGCPlayerChallengeHistory_PlayerChallenge();
    message.accountId = object.accountId ?? 0;
    message.challengeType = object.challengeType ?? 0;
    message.challengeId1 = object.challengeId1 ?? 0;
    message.challengeId2 = object.challengeId2 ?? 0;
    message.progressValueStart = object.progressValueStart ?? 0;
    message.progressValueEnd = object.progressValueEnd ?? 0;
    message.teamWon = object.teamWon ?? false;
    message.auditData = object.auditData ?? "0";
    message.heroId = object.heroId ?? 0;
    message.rankCompleted = object.rankCompleted ?? 0;
    return message;
  },
};

function createBaseCMsgServerToGCCavernCrawlIsHeroActiveResponse(): CMsgServerToGCCavernCrawlIsHeroActiveResponse {
  return { result: false, mapVariant: 255, potentialWinnings: 0, mapResults: [], potentialPlusShardWinnings: 0 };
}

export const CMsgServerToGCCavernCrawlIsHeroActiveResponse = {
  encode(message: CMsgServerToGCCavernCrawlIsHeroActiveResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result !== undefined && message.result !== false) {
      writer.uint32(8).bool(message.result);
    }
    if (message.mapVariant !== undefined && message.mapVariant !== 255) {
      writer.uint32(40).uint32(message.mapVariant);
    }
    if (message.potentialWinnings !== undefined && message.potentialWinnings !== 0) {
      writer.uint32(16).uint32(message.potentialWinnings);
    }
    for (const v of message.mapResults) {
      CMsgServerToGCCavernCrawlIsHeroActiveResponse_MapResults.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    if (message.potentialPlusShardWinnings !== undefined && message.potentialPlusShardWinnings !== 0) {
      writer.uint32(32).uint32(message.potentialPlusShardWinnings);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgServerToGCCavernCrawlIsHeroActiveResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgServerToGCCavernCrawlIsHeroActiveResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.result = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.mapVariant = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.potentialWinnings = reader.uint32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.mapResults.push(
            CMsgServerToGCCavernCrawlIsHeroActiveResponse_MapResults.decode(reader, reader.uint32()),
          );
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.potentialPlusShardWinnings = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgServerToGCCavernCrawlIsHeroActiveResponse {
    return {
      result: isSet(object.result) ? globalThis.Boolean(object.result) : false,
      mapVariant: isSet(object.mapVariant) ? globalThis.Number(object.mapVariant) : 255,
      potentialWinnings: isSet(object.potentialWinnings) ? globalThis.Number(object.potentialWinnings) : 0,
      mapResults: globalThis.Array.isArray(object?.mapResults)
        ? object.mapResults.map((e: any) => CMsgServerToGCCavernCrawlIsHeroActiveResponse_MapResults.fromJSON(e))
        : [],
      potentialPlusShardWinnings: isSet(object.potentialPlusShardWinnings)
        ? globalThis.Number(object.potentialPlusShardWinnings)
        : 0,
    };
  },

  toJSON(message: CMsgServerToGCCavernCrawlIsHeroActiveResponse): unknown {
    const obj: any = {};
    if (message.result !== undefined && message.result !== false) {
      obj.result = message.result;
    }
    if (message.mapVariant !== undefined && message.mapVariant !== 255) {
      obj.mapVariant = Math.round(message.mapVariant);
    }
    if (message.potentialWinnings !== undefined && message.potentialWinnings !== 0) {
      obj.potentialWinnings = Math.round(message.potentialWinnings);
    }
    if (message.mapResults?.length) {
      obj.mapResults = message.mapResults.map((e) =>
        CMsgServerToGCCavernCrawlIsHeroActiveResponse_MapResults.toJSON(e)
      );
    }
    if (message.potentialPlusShardWinnings !== undefined && message.potentialPlusShardWinnings !== 0) {
      obj.potentialPlusShardWinnings = Math.round(message.potentialPlusShardWinnings);
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgServerToGCCavernCrawlIsHeroActiveResponse>,
  ): CMsgServerToGCCavernCrawlIsHeroActiveResponse {
    return CMsgServerToGCCavernCrawlIsHeroActiveResponse.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgServerToGCCavernCrawlIsHeroActiveResponse>,
  ): CMsgServerToGCCavernCrawlIsHeroActiveResponse {
    const message = createBaseCMsgServerToGCCavernCrawlIsHeroActiveResponse();
    message.result = object.result ?? false;
    message.mapVariant = object.mapVariant ?? 255;
    message.potentialWinnings = object.potentialWinnings ?? 0;
    message.mapResults =
      object.mapResults?.map((e) => CMsgServerToGCCavernCrawlIsHeroActiveResponse_MapResults.fromPartial(e)) || [];
    message.potentialPlusShardWinnings = object.potentialPlusShardWinnings ?? 0;
    return message;
  },
};

function createBaseCMsgServerToGCCavernCrawlIsHeroActiveResponse_MapResults(): CMsgServerToGCCavernCrawlIsHeroActiveResponse_MapResults {
  return { pathIdCompleted: 255, roomIdClaimed: 255 };
}

export const CMsgServerToGCCavernCrawlIsHeroActiveResponse_MapResults = {
  encode(
    message: CMsgServerToGCCavernCrawlIsHeroActiveResponse_MapResults,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.pathIdCompleted !== undefined && message.pathIdCompleted !== 255) {
      writer.uint32(8).uint32(message.pathIdCompleted);
    }
    if (message.roomIdClaimed !== undefined && message.roomIdClaimed !== 255) {
      writer.uint32(16).uint32(message.roomIdClaimed);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgServerToGCCavernCrawlIsHeroActiveResponse_MapResults {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgServerToGCCavernCrawlIsHeroActiveResponse_MapResults();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.pathIdCompleted = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.roomIdClaimed = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgServerToGCCavernCrawlIsHeroActiveResponse_MapResults {
    return {
      pathIdCompleted: isSet(object.pathIdCompleted) ? globalThis.Number(object.pathIdCompleted) : 255,
      roomIdClaimed: isSet(object.roomIdClaimed) ? globalThis.Number(object.roomIdClaimed) : 255,
    };
  },

  toJSON(message: CMsgServerToGCCavernCrawlIsHeroActiveResponse_MapResults): unknown {
    const obj: any = {};
    if (message.pathIdCompleted !== undefined && message.pathIdCompleted !== 255) {
      obj.pathIdCompleted = Math.round(message.pathIdCompleted);
    }
    if (message.roomIdClaimed !== undefined && message.roomIdClaimed !== 255) {
      obj.roomIdClaimed = Math.round(message.roomIdClaimed);
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgServerToGCCavernCrawlIsHeroActiveResponse_MapResults>,
  ): CMsgServerToGCCavernCrawlIsHeroActiveResponse_MapResults {
    return CMsgServerToGCCavernCrawlIsHeroActiveResponse_MapResults.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgServerToGCCavernCrawlIsHeroActiveResponse_MapResults>,
  ): CMsgServerToGCCavernCrawlIsHeroActiveResponse_MapResults {
    const message = createBaseCMsgServerToGCCavernCrawlIsHeroActiveResponse_MapResults();
    message.pathIdCompleted = object.pathIdCompleted ?? 255;
    message.roomIdClaimed = object.roomIdClaimed ?? 255;
    return message;
  },
};

function createBaseCMsgNeutralItemStats(): CMsgNeutralItemStats {
  return { neutralItems: [] };
}

export const CMsgNeutralItemStats = {
  encode(message: CMsgNeutralItemStats, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.neutralItems) {
      CMsgNeutralItemStats_NeutralItem.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgNeutralItemStats {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgNeutralItemStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.neutralItems.push(CMsgNeutralItemStats_NeutralItem.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgNeutralItemStats {
    return {
      neutralItems: globalThis.Array.isArray(object?.neutralItems)
        ? object.neutralItems.map((e: any) => CMsgNeutralItemStats_NeutralItem.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgNeutralItemStats): unknown {
    const obj: any = {};
    if (message.neutralItems?.length) {
      obj.neutralItems = message.neutralItems.map((e) => CMsgNeutralItemStats_NeutralItem.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgNeutralItemStats>): CMsgNeutralItemStats {
    return CMsgNeutralItemStats.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgNeutralItemStats>): CMsgNeutralItemStats {
    const message = createBaseCMsgNeutralItemStats();
    message.neutralItems = object.neutralItems?.map((e) => CMsgNeutralItemStats_NeutralItem.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgNeutralItemStats_NeutralItem(): CMsgNeutralItemStats_NeutralItem {
  return { itemId: -1, timeDropped: 0, team: 0, timeLastEquipped: 0, timeLastUnequipped: 0, durationEquipped: 0 };
}

export const CMsgNeutralItemStats_NeutralItem = {
  encode(message: CMsgNeutralItemStats_NeutralItem, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.itemId !== undefined && message.itemId !== -1) {
      writer.uint32(8).int32(message.itemId);
    }
    if (message.timeDropped !== undefined && message.timeDropped !== 0) {
      writer.uint32(16).uint32(message.timeDropped);
    }
    if (message.team !== undefined && message.team !== 0) {
      writer.uint32(24).uint32(message.team);
    }
    if (message.timeLastEquipped !== undefined && message.timeLastEquipped !== 0) {
      writer.uint32(32).uint32(message.timeLastEquipped);
    }
    if (message.timeLastUnequipped !== undefined && message.timeLastUnequipped !== 0) {
      writer.uint32(40).uint32(message.timeLastUnequipped);
    }
    if (message.durationEquipped !== undefined && message.durationEquipped !== 0) {
      writer.uint32(48).uint32(message.durationEquipped);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgNeutralItemStats_NeutralItem {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgNeutralItemStats_NeutralItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.itemId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.timeDropped = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.team = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.timeLastEquipped = reader.uint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.timeLastUnequipped = reader.uint32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.durationEquipped = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgNeutralItemStats_NeutralItem {
    return {
      itemId: isSet(object.itemId) ? globalThis.Number(object.itemId) : -1,
      timeDropped: isSet(object.timeDropped) ? globalThis.Number(object.timeDropped) : 0,
      team: isSet(object.team) ? globalThis.Number(object.team) : 0,
      timeLastEquipped: isSet(object.timeLastEquipped) ? globalThis.Number(object.timeLastEquipped) : 0,
      timeLastUnequipped: isSet(object.timeLastUnequipped) ? globalThis.Number(object.timeLastUnequipped) : 0,
      durationEquipped: isSet(object.durationEquipped) ? globalThis.Number(object.durationEquipped) : 0,
    };
  },

  toJSON(message: CMsgNeutralItemStats_NeutralItem): unknown {
    const obj: any = {};
    if (message.itemId !== undefined && message.itemId !== -1) {
      obj.itemId = Math.round(message.itemId);
    }
    if (message.timeDropped !== undefined && message.timeDropped !== 0) {
      obj.timeDropped = Math.round(message.timeDropped);
    }
    if (message.team !== undefined && message.team !== 0) {
      obj.team = Math.round(message.team);
    }
    if (message.timeLastEquipped !== undefined && message.timeLastEquipped !== 0) {
      obj.timeLastEquipped = Math.round(message.timeLastEquipped);
    }
    if (message.timeLastUnequipped !== undefined && message.timeLastUnequipped !== 0) {
      obj.timeLastUnequipped = Math.round(message.timeLastUnequipped);
    }
    if (message.durationEquipped !== undefined && message.durationEquipped !== 0) {
      obj.durationEquipped = Math.round(message.durationEquipped);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgNeutralItemStats_NeutralItem>): CMsgNeutralItemStats_NeutralItem {
    return CMsgNeutralItemStats_NeutralItem.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgNeutralItemStats_NeutralItem>): CMsgNeutralItemStats_NeutralItem {
    const message = createBaseCMsgNeutralItemStats_NeutralItem();
    message.itemId = object.itemId ?? -1;
    message.timeDropped = object.timeDropped ?? 0;
    message.team = object.team ?? 0;
    message.timeLastEquipped = object.timeLastEquipped ?? 0;
    message.timeLastUnequipped = object.timeLastUnequipped ?? 0;
    message.durationEquipped = object.durationEquipped ?? 0;
    return message;
  },
};

function createBaseCMsgGCToServerLobbyHeroBanRates(): CMsgGCToServerLobbyHeroBanRates {
  return { banData: [] };
}

export const CMsgGCToServerLobbyHeroBanRates = {
  encode(message: CMsgGCToServerLobbyHeroBanRates, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.banData) {
      CMsgGCToServerLobbyHeroBanRates_HeroBanEntry.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToServerLobbyHeroBanRates {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToServerLobbyHeroBanRates();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.banData.push(CMsgGCToServerLobbyHeroBanRates_HeroBanEntry.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToServerLobbyHeroBanRates {
    return {
      banData: globalThis.Array.isArray(object?.banData)
        ? object.banData.map((e: any) => CMsgGCToServerLobbyHeroBanRates_HeroBanEntry.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgGCToServerLobbyHeroBanRates): unknown {
    const obj: any = {};
    if (message.banData?.length) {
      obj.banData = message.banData.map((e) => CMsgGCToServerLobbyHeroBanRates_HeroBanEntry.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCToServerLobbyHeroBanRates>): CMsgGCToServerLobbyHeroBanRates {
    return CMsgGCToServerLobbyHeroBanRates.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCToServerLobbyHeroBanRates>): CMsgGCToServerLobbyHeroBanRates {
    const message = createBaseCMsgGCToServerLobbyHeroBanRates();
    message.banData = object.banData?.map((e) => CMsgGCToServerLobbyHeroBanRates_HeroBanEntry.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgGCToServerLobbyHeroBanRates_HeroBanEntry(): CMsgGCToServerLobbyHeroBanRates_HeroBanEntry {
  return { heroId: 0, banCount: 0, pickCount: 0 };
}

export const CMsgGCToServerLobbyHeroBanRates_HeroBanEntry = {
  encode(message: CMsgGCToServerLobbyHeroBanRates_HeroBanEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.heroId !== undefined && message.heroId !== 0) {
      writer.uint32(8).int32(message.heroId);
    }
    if (message.banCount !== undefined && message.banCount !== 0) {
      writer.uint32(16).uint32(message.banCount);
    }
    if (message.pickCount !== undefined && message.pickCount !== 0) {
      writer.uint32(24).uint32(message.pickCount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToServerLobbyHeroBanRates_HeroBanEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToServerLobbyHeroBanRates_HeroBanEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.heroId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.banCount = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.pickCount = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToServerLobbyHeroBanRates_HeroBanEntry {
    return {
      heroId: isSet(object.heroId) ? globalThis.Number(object.heroId) : 0,
      banCount: isSet(object.banCount) ? globalThis.Number(object.banCount) : 0,
      pickCount: isSet(object.pickCount) ? globalThis.Number(object.pickCount) : 0,
    };
  },

  toJSON(message: CMsgGCToServerLobbyHeroBanRates_HeroBanEntry): unknown {
    const obj: any = {};
    if (message.heroId !== undefined && message.heroId !== 0) {
      obj.heroId = Math.round(message.heroId);
    }
    if (message.banCount !== undefined && message.banCount !== 0) {
      obj.banCount = Math.round(message.banCount);
    }
    if (message.pickCount !== undefined && message.pickCount !== 0) {
      obj.pickCount = Math.round(message.pickCount);
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgGCToServerLobbyHeroBanRates_HeroBanEntry>,
  ): CMsgGCToServerLobbyHeroBanRates_HeroBanEntry {
    return CMsgGCToServerLobbyHeroBanRates_HeroBanEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgGCToServerLobbyHeroBanRates_HeroBanEntry>,
  ): CMsgGCToServerLobbyHeroBanRates_HeroBanEntry {
    const message = createBaseCMsgGCToServerLobbyHeroBanRates_HeroBanEntry();
    message.heroId = object.heroId ?? 0;
    message.banCount = object.banCount ?? 0;
    message.pickCount = object.pickCount ?? 0;
    return message;
  },
};

function createBaseCMsgSignOutGuildContractProgress(): CMsgSignOutGuildContractProgress {
  return { playerContracts: [] };
}

export const CMsgSignOutGuildContractProgress = {
  encode(message: CMsgSignOutGuildContractProgress, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.playerContracts) {
      CMsgSignOutGuildContractProgress_PlayerContract.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSignOutGuildContractProgress {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSignOutGuildContractProgress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.playerContracts.push(CMsgSignOutGuildContractProgress_PlayerContract.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSignOutGuildContractProgress {
    return {
      playerContracts: globalThis.Array.isArray(object?.playerContracts)
        ? object.playerContracts.map((e: any) => CMsgSignOutGuildContractProgress_PlayerContract.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgSignOutGuildContractProgress): unknown {
    const obj: any = {};
    if (message.playerContracts?.length) {
      obj.playerContracts = message.playerContracts.map((e) =>
        CMsgSignOutGuildContractProgress_PlayerContract.toJSON(e)
      );
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSignOutGuildContractProgress>): CMsgSignOutGuildContractProgress {
    return CMsgSignOutGuildContractProgress.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSignOutGuildContractProgress>): CMsgSignOutGuildContractProgress {
    const message = createBaseCMsgSignOutGuildContractProgress();
    message.playerContracts =
      object.playerContracts?.map((e) => CMsgSignOutGuildContractProgress_PlayerContract.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgSignOutGuildContractProgress_CompletedGuildEventContracts(): CMsgSignOutGuildContractProgress_CompletedGuildEventContracts {
  return { guildId: 0, eventId: 0, contracts: [] };
}

export const CMsgSignOutGuildContractProgress_CompletedGuildEventContracts = {
  encode(
    message: CMsgSignOutGuildContractProgress_CompletedGuildEventContracts,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.guildId !== undefined && message.guildId !== 0) {
      writer.uint32(8).uint32(message.guildId);
    }
    if (message.eventId !== undefined && message.eventId !== 0) {
      writer.uint32(16).uint32(message.eventId);
    }
    writer.uint32(26).fork();
    for (const v of message.contracts) {
      writer.uint64(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): CMsgSignOutGuildContractProgress_CompletedGuildEventContracts {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSignOutGuildContractProgress_CompletedGuildEventContracts();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.guildId = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.eventId = reader.uint32();
          continue;
        case 3:
          if (tag === 24) {
            message.contracts.push(longToString(reader.uint64() as Long));

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.contracts.push(longToString(reader.uint64() as Long));
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSignOutGuildContractProgress_CompletedGuildEventContracts {
    return {
      guildId: isSet(object.guildId) ? globalThis.Number(object.guildId) : 0,
      eventId: isSet(object.eventId) ? globalThis.Number(object.eventId) : 0,
      contracts: globalThis.Array.isArray(object?.contracts)
        ? object.contracts.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: CMsgSignOutGuildContractProgress_CompletedGuildEventContracts): unknown {
    const obj: any = {};
    if (message.guildId !== undefined && message.guildId !== 0) {
      obj.guildId = Math.round(message.guildId);
    }
    if (message.eventId !== undefined && message.eventId !== 0) {
      obj.eventId = Math.round(message.eventId);
    }
    if (message.contracts?.length) {
      obj.contracts = message.contracts;
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgSignOutGuildContractProgress_CompletedGuildEventContracts>,
  ): CMsgSignOutGuildContractProgress_CompletedGuildEventContracts {
    return CMsgSignOutGuildContractProgress_CompletedGuildEventContracts.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgSignOutGuildContractProgress_CompletedGuildEventContracts>,
  ): CMsgSignOutGuildContractProgress_CompletedGuildEventContracts {
    const message = createBaseCMsgSignOutGuildContractProgress_CompletedGuildEventContracts();
    message.guildId = object.guildId ?? 0;
    message.eventId = object.eventId ?? 0;
    message.contracts = object.contracts?.map((e) => e) || [];
    return message;
  },
};

function createBaseCMsgSignOutGuildContractProgress_PlayerContract(): CMsgSignOutGuildContractProgress_PlayerContract {
  return { accountId: 0, completedContracts: [] };
}

export const CMsgSignOutGuildContractProgress_PlayerContract = {
  encode(
    message: CMsgSignOutGuildContractProgress_PlayerContract,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.accountId !== undefined && message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    for (const v of message.completedContracts) {
      CMsgSignOutGuildContractProgress_CompletedGuildEventContracts.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSignOutGuildContractProgress_PlayerContract {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSignOutGuildContractProgress_PlayerContract();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.completedContracts.push(
            CMsgSignOutGuildContractProgress_CompletedGuildEventContracts.decode(reader, reader.uint32()),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSignOutGuildContractProgress_PlayerContract {
    return {
      accountId: isSet(object.accountId) ? globalThis.Number(object.accountId) : 0,
      completedContracts: globalThis.Array.isArray(object?.completedContracts)
        ? object.completedContracts.map((e: any) =>
          CMsgSignOutGuildContractProgress_CompletedGuildEventContracts.fromJSON(e)
        )
        : [],
    };
  },

  toJSON(message: CMsgSignOutGuildContractProgress_PlayerContract): unknown {
    const obj: any = {};
    if (message.accountId !== undefined && message.accountId !== 0) {
      obj.accountId = Math.round(message.accountId);
    }
    if (message.completedContracts?.length) {
      obj.completedContracts = message.completedContracts.map((e) =>
        CMsgSignOutGuildContractProgress_CompletedGuildEventContracts.toJSON(e)
      );
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgSignOutGuildContractProgress_PlayerContract>,
  ): CMsgSignOutGuildContractProgress_PlayerContract {
    return CMsgSignOutGuildContractProgress_PlayerContract.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgSignOutGuildContractProgress_PlayerContract>,
  ): CMsgSignOutGuildContractProgress_PlayerContract {
    const message = createBaseCMsgSignOutGuildContractProgress_PlayerContract();
    message.accountId = object.accountId ?? 0;
    message.completedContracts =
      object.completedContracts?.map((e) =>
        CMsgSignOutGuildContractProgress_CompletedGuildEventContracts.fromPartial(e)
      ) || [];
    return message;
  },
};

function createBaseCMsgSignOutGuildChallengeProgress(): CMsgSignOutGuildChallengeProgress {
  return { guildChallengesProgresses: [] };
}

export const CMsgSignOutGuildChallengeProgress = {
  encode(message: CMsgSignOutGuildChallengeProgress, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.guildChallengesProgresses) {
      CMsgSignOutGuildChallengeProgress_ChallengeProgress.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSignOutGuildChallengeProgress {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSignOutGuildChallengeProgress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.guildChallengesProgresses.push(
            CMsgSignOutGuildChallengeProgress_ChallengeProgress.decode(reader, reader.uint32()),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSignOutGuildChallengeProgress {
    return {
      guildChallengesProgresses: globalThis.Array.isArray(object?.guildChallengesProgresses)
        ? object.guildChallengesProgresses.map((e: any) =>
          CMsgSignOutGuildChallengeProgress_ChallengeProgress.fromJSON(e)
        )
        : [],
    };
  },

  toJSON(message: CMsgSignOutGuildChallengeProgress): unknown {
    const obj: any = {};
    if (message.guildChallengesProgresses?.length) {
      obj.guildChallengesProgresses = message.guildChallengesProgresses.map((e) =>
        CMsgSignOutGuildChallengeProgress_ChallengeProgress.toJSON(e)
      );
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSignOutGuildChallengeProgress>): CMsgSignOutGuildChallengeProgress {
    return CMsgSignOutGuildChallengeProgress.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSignOutGuildChallengeProgress>): CMsgSignOutGuildChallengeProgress {
    const message = createBaseCMsgSignOutGuildChallengeProgress();
    message.guildChallengesProgresses =
      object.guildChallengesProgresses?.map((e) =>
        CMsgSignOutGuildChallengeProgress_ChallengeProgress.fromPartial(e)
      ) || [];
    return message;
  },
};

function createBaseCMsgSignOutGuildChallengeProgress_ChallengeProgress(): CMsgSignOutGuildChallengeProgress_ChallengeProgress {
  return {
    guildId: 0,
    eventId: 0,
    challengeInstanceId: 0,
    challengeInstanceTimestamp: 0,
    challengePeriodSerial: 0,
    progress: 0,
    challengeParameter: 0,
  };
}

export const CMsgSignOutGuildChallengeProgress_ChallengeProgress = {
  encode(
    message: CMsgSignOutGuildChallengeProgress_ChallengeProgress,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.guildId !== undefined && message.guildId !== 0) {
      writer.uint32(8).uint32(message.guildId);
    }
    if (message.eventId !== undefined && message.eventId !== 0) {
      writer.uint32(16).uint32(message.eventId);
    }
    if (message.challengeInstanceId !== undefined && message.challengeInstanceId !== 0) {
      writer.uint32(24).uint32(message.challengeInstanceId);
    }
    if (message.challengeInstanceTimestamp !== undefined && message.challengeInstanceTimestamp !== 0) {
      writer.uint32(32).uint32(message.challengeInstanceTimestamp);
    }
    if (message.challengePeriodSerial !== undefined && message.challengePeriodSerial !== 0) {
      writer.uint32(40).uint32(message.challengePeriodSerial);
    }
    if (message.progress !== undefined && message.progress !== 0) {
      writer.uint32(48).uint32(message.progress);
    }
    if (message.challengeParameter !== undefined && message.challengeParameter !== 0) {
      writer.uint32(56).uint32(message.challengeParameter);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSignOutGuildChallengeProgress_ChallengeProgress {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSignOutGuildChallengeProgress_ChallengeProgress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.guildId = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.eventId = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.challengeInstanceId = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.challengeInstanceTimestamp = reader.uint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.challengePeriodSerial = reader.uint32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.progress = reader.uint32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.challengeParameter = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSignOutGuildChallengeProgress_ChallengeProgress {
    return {
      guildId: isSet(object.guildId) ? globalThis.Number(object.guildId) : 0,
      eventId: isSet(object.eventId) ? globalThis.Number(object.eventId) : 0,
      challengeInstanceId: isSet(object.challengeInstanceId) ? globalThis.Number(object.challengeInstanceId) : 0,
      challengeInstanceTimestamp: isSet(object.challengeInstanceTimestamp)
        ? globalThis.Number(object.challengeInstanceTimestamp)
        : 0,
      challengePeriodSerial: isSet(object.challengePeriodSerial) ? globalThis.Number(object.challengePeriodSerial) : 0,
      progress: isSet(object.progress) ? globalThis.Number(object.progress) : 0,
      challengeParameter: isSet(object.challengeParameter) ? globalThis.Number(object.challengeParameter) : 0,
    };
  },

  toJSON(message: CMsgSignOutGuildChallengeProgress_ChallengeProgress): unknown {
    const obj: any = {};
    if (message.guildId !== undefined && message.guildId !== 0) {
      obj.guildId = Math.round(message.guildId);
    }
    if (message.eventId !== undefined && message.eventId !== 0) {
      obj.eventId = Math.round(message.eventId);
    }
    if (message.challengeInstanceId !== undefined && message.challengeInstanceId !== 0) {
      obj.challengeInstanceId = Math.round(message.challengeInstanceId);
    }
    if (message.challengeInstanceTimestamp !== undefined && message.challengeInstanceTimestamp !== 0) {
      obj.challengeInstanceTimestamp = Math.round(message.challengeInstanceTimestamp);
    }
    if (message.challengePeriodSerial !== undefined && message.challengePeriodSerial !== 0) {
      obj.challengePeriodSerial = Math.round(message.challengePeriodSerial);
    }
    if (message.progress !== undefined && message.progress !== 0) {
      obj.progress = Math.round(message.progress);
    }
    if (message.challengeParameter !== undefined && message.challengeParameter !== 0) {
      obj.challengeParameter = Math.round(message.challengeParameter);
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgSignOutGuildChallengeProgress_ChallengeProgress>,
  ): CMsgSignOutGuildChallengeProgress_ChallengeProgress {
    return CMsgSignOutGuildChallengeProgress_ChallengeProgress.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgSignOutGuildChallengeProgress_ChallengeProgress>,
  ): CMsgSignOutGuildChallengeProgress_ChallengeProgress {
    const message = createBaseCMsgSignOutGuildChallengeProgress_ChallengeProgress();
    message.guildId = object.guildId ?? 0;
    message.eventId = object.eventId ?? 0;
    message.challengeInstanceId = object.challengeInstanceId ?? 0;
    message.challengeInstanceTimestamp = object.challengeInstanceTimestamp ?? 0;
    message.challengePeriodSerial = object.challengePeriodSerial ?? 0;
    message.progress = object.progress ?? 0;
    message.challengeParameter = object.challengeParameter ?? 0;
    return message;
  },
};

function createBaseCMsgSignOutMVPStats(): CMsgSignOutMVPStats {
  return { matchId: "0", gameMode: 0, winningTeam: 0, gameTime: 0, players: [] };
}

export const CMsgSignOutMVPStats = {
  encode(message: CMsgSignOutMVPStats, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.matchId !== undefined && message.matchId !== "0") {
      writer.uint32(8).uint64(message.matchId);
    }
    if (message.gameMode !== undefined && message.gameMode !== 0) {
      writer.uint32(16).uint32(message.gameMode);
    }
    if (message.winningTeam !== undefined && message.winningTeam !== 0) {
      writer.uint32(24).uint32(message.winningTeam);
    }
    if (message.gameTime !== undefined && message.gameTime !== 0) {
      writer.uint32(37).float(message.gameTime);
    }
    for (const v of message.players) {
      CMsgSignOutMVPStats_Player.encode(v!, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSignOutMVPStats {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSignOutMVPStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.matchId = longToString(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.gameMode = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.winningTeam = reader.uint32();
          continue;
        case 4:
          if (tag !== 37) {
            break;
          }

          message.gameTime = reader.float();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.players.push(CMsgSignOutMVPStats_Player.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSignOutMVPStats {
    return {
      matchId: isSet(object.matchId) ? globalThis.String(object.matchId) : "0",
      gameMode: isSet(object.gameMode) ? globalThis.Number(object.gameMode) : 0,
      winningTeam: isSet(object.winningTeam) ? globalThis.Number(object.winningTeam) : 0,
      gameTime: isSet(object.gameTime) ? globalThis.Number(object.gameTime) : 0,
      players: globalThis.Array.isArray(object?.players)
        ? object.players.map((e: any) => CMsgSignOutMVPStats_Player.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgSignOutMVPStats): unknown {
    const obj: any = {};
    if (message.matchId !== undefined && message.matchId !== "0") {
      obj.matchId = message.matchId;
    }
    if (message.gameMode !== undefined && message.gameMode !== 0) {
      obj.gameMode = Math.round(message.gameMode);
    }
    if (message.winningTeam !== undefined && message.winningTeam !== 0) {
      obj.winningTeam = Math.round(message.winningTeam);
    }
    if (message.gameTime !== undefined && message.gameTime !== 0) {
      obj.gameTime = message.gameTime;
    }
    if (message.players?.length) {
      obj.players = message.players.map((e) => CMsgSignOutMVPStats_Player.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSignOutMVPStats>): CMsgSignOutMVPStats {
    return CMsgSignOutMVPStats.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSignOutMVPStats>): CMsgSignOutMVPStats {
    const message = createBaseCMsgSignOutMVPStats();
    message.matchId = object.matchId ?? "0";
    message.gameMode = object.gameMode ?? 0;
    message.winningTeam = object.winningTeam ?? 0;
    message.gameTime = object.gameTime ?? 0;
    message.players = object.players?.map((e) => CMsgSignOutMVPStats_Player.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgSignOutMVPStats_Player(): CMsgSignOutMVPStats_Player {
  return {
    teamId: 0,
    teamNetworthRank: 0,
    accountId: 0,
    playerSlot: 0,
    rank: 0,
    heroId: 0,
    role: 0,
    kills: 0,
    deaths: 0,
    assists: 0,
    xp: 0,
    netWorth: 0,
    supportGoldSpent: 0,
    wardsPlaced: 0,
    wardsSpottedForDewarding: 0,
    campsStacked: 0,
    lastHits: 0,
    denies: 0,
    buildingDamage: 0,
    otherDamage: 0,
    tripleKills: 0,
    rampages: 0,
    firstBlood: 0,
    killEaterEvents: [],
    highestKillstreak: 0,
  };
}

export const CMsgSignOutMVPStats_Player = {
  encode(message: CMsgSignOutMVPStats_Player, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.teamId !== undefined && message.teamId !== 0) {
      writer.uint32(8).uint32(message.teamId);
    }
    if (message.teamNetworthRank !== undefined && message.teamNetworthRank !== 0) {
      writer.uint32(16).uint32(message.teamNetworthRank);
    }
    if (message.accountId !== undefined && message.accountId !== 0) {
      writer.uint32(24).uint32(message.accountId);
    }
    if (message.playerSlot !== undefined && message.playerSlot !== 0) {
      writer.uint32(256).uint32(message.playerSlot);
    }
    if (message.rank !== undefined && message.rank !== 0) {
      writer.uint32(264).uint32(message.rank);
    }
    if (message.heroId !== undefined && message.heroId !== 0) {
      writer.uint32(32).int32(message.heroId);
    }
    if (message.role !== undefined && message.role !== 0) {
      writer.uint32(40).uint32(message.role);
    }
    if (message.kills !== undefined && message.kills !== 0) {
      writer.uint32(48).int32(message.kills);
    }
    if (message.deaths !== undefined && message.deaths !== 0) {
      writer.uint32(56).int32(message.deaths);
    }
    if (message.assists !== undefined && message.assists !== 0) {
      writer.uint32(64).int32(message.assists);
    }
    if (message.xp !== undefined && message.xp !== 0) {
      writer.uint32(72).int32(message.xp);
    }
    if (message.netWorth !== undefined && message.netWorth !== 0) {
      writer.uint32(80).int32(message.netWorth);
    }
    if (message.supportGoldSpent !== undefined && message.supportGoldSpent !== 0) {
      writer.uint32(96).int32(message.supportGoldSpent);
    }
    if (message.wardsPlaced !== undefined && message.wardsPlaced !== 0) {
      writer.uint32(104).int32(message.wardsPlaced);
    }
    if (message.wardsSpottedForDewarding !== undefined && message.wardsSpottedForDewarding !== 0) {
      writer.uint32(112).int32(message.wardsSpottedForDewarding);
    }
    if (message.campsStacked !== undefined && message.campsStacked !== 0) {
      writer.uint32(120).int32(message.campsStacked);
    }
    if (message.lastHits !== undefined && message.lastHits !== 0) {
      writer.uint32(128).int32(message.lastHits);
    }
    if (message.denies !== undefined && message.denies !== 0) {
      writer.uint32(136).int32(message.denies);
    }
    if (message.buildingDamage !== undefined && message.buildingDamage !== 0) {
      writer.uint32(152).int32(message.buildingDamage);
    }
    if (message.otherDamage !== undefined && message.otherDamage !== 0) {
      writer.uint32(160).int32(message.otherDamage);
    }
    if (message.tripleKills !== undefined && message.tripleKills !== 0) {
      writer.uint32(208).int32(message.tripleKills);
    }
    if (message.rampages !== undefined && message.rampages !== 0) {
      writer.uint32(224).int32(message.rampages);
    }
    if (message.firstBlood !== undefined && message.firstBlood !== 0) {
      writer.uint32(248).int32(message.firstBlood);
    }
    for (const v of message.killEaterEvents) {
      CMsgSignOutMVPStats_Player_KillEaterEvent.encode(v!, writer.uint32(274).fork()).ldelim();
    }
    if (message.highestKillstreak !== undefined && message.highestKillstreak !== 0) {
      writer.uint32(280).uint32(message.highestKillstreak);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSignOutMVPStats_Player {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSignOutMVPStats_Player();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.teamId = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.teamNetworthRank = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        case 32:
          if (tag !== 256) {
            break;
          }

          message.playerSlot = reader.uint32();
          continue;
        case 33:
          if (tag !== 264) {
            break;
          }

          message.rank = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.heroId = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.role = reader.uint32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.kills = reader.int32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.deaths = reader.int32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.assists = reader.int32();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.xp = reader.int32();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.netWorth = reader.int32();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.supportGoldSpent = reader.int32();
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.wardsPlaced = reader.int32();
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.wardsSpottedForDewarding = reader.int32();
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.campsStacked = reader.int32();
          continue;
        case 16:
          if (tag !== 128) {
            break;
          }

          message.lastHits = reader.int32();
          continue;
        case 17:
          if (tag !== 136) {
            break;
          }

          message.denies = reader.int32();
          continue;
        case 19:
          if (tag !== 152) {
            break;
          }

          message.buildingDamage = reader.int32();
          continue;
        case 20:
          if (tag !== 160) {
            break;
          }

          message.otherDamage = reader.int32();
          continue;
        case 26:
          if (tag !== 208) {
            break;
          }

          message.tripleKills = reader.int32();
          continue;
        case 28:
          if (tag !== 224) {
            break;
          }

          message.rampages = reader.int32();
          continue;
        case 31:
          if (tag !== 248) {
            break;
          }

          message.firstBlood = reader.int32();
          continue;
        case 34:
          if (tag !== 274) {
            break;
          }

          message.killEaterEvents.push(CMsgSignOutMVPStats_Player_KillEaterEvent.decode(reader, reader.uint32()));
          continue;
        case 35:
          if (tag !== 280) {
            break;
          }

          message.highestKillstreak = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSignOutMVPStats_Player {
    return {
      teamId: isSet(object.teamId) ? globalThis.Number(object.teamId) : 0,
      teamNetworthRank: isSet(object.teamNetworthRank) ? globalThis.Number(object.teamNetworthRank) : 0,
      accountId: isSet(object.accountId) ? globalThis.Number(object.accountId) : 0,
      playerSlot: isSet(object.playerSlot) ? globalThis.Number(object.playerSlot) : 0,
      rank: isSet(object.rank) ? globalThis.Number(object.rank) : 0,
      heroId: isSet(object.heroId) ? globalThis.Number(object.heroId) : 0,
      role: isSet(object.role) ? globalThis.Number(object.role) : 0,
      kills: isSet(object.kills) ? globalThis.Number(object.kills) : 0,
      deaths: isSet(object.deaths) ? globalThis.Number(object.deaths) : 0,
      assists: isSet(object.assists) ? globalThis.Number(object.assists) : 0,
      xp: isSet(object.xp) ? globalThis.Number(object.xp) : 0,
      netWorth: isSet(object.netWorth) ? globalThis.Number(object.netWorth) : 0,
      supportGoldSpent: isSet(object.supportGoldSpent) ? globalThis.Number(object.supportGoldSpent) : 0,
      wardsPlaced: isSet(object.wardsPlaced) ? globalThis.Number(object.wardsPlaced) : 0,
      wardsSpottedForDewarding: isSet(object.wardsSpottedForDewarding)
        ? globalThis.Number(object.wardsSpottedForDewarding)
        : 0,
      campsStacked: isSet(object.campsStacked) ? globalThis.Number(object.campsStacked) : 0,
      lastHits: isSet(object.lastHits) ? globalThis.Number(object.lastHits) : 0,
      denies: isSet(object.denies) ? globalThis.Number(object.denies) : 0,
      buildingDamage: isSet(object.buildingDamage) ? globalThis.Number(object.buildingDamage) : 0,
      otherDamage: isSet(object.otherDamage) ? globalThis.Number(object.otherDamage) : 0,
      tripleKills: isSet(object.tripleKills) ? globalThis.Number(object.tripleKills) : 0,
      rampages: isSet(object.rampages) ? globalThis.Number(object.rampages) : 0,
      firstBlood: isSet(object.firstBlood) ? globalThis.Number(object.firstBlood) : 0,
      killEaterEvents: globalThis.Array.isArray(object?.killEaterEvents)
        ? object.killEaterEvents.map((e: any) => CMsgSignOutMVPStats_Player_KillEaterEvent.fromJSON(e))
        : [],
      highestKillstreak: isSet(object.highestKillstreak) ? globalThis.Number(object.highestKillstreak) : 0,
    };
  },

  toJSON(message: CMsgSignOutMVPStats_Player): unknown {
    const obj: any = {};
    if (message.teamId !== undefined && message.teamId !== 0) {
      obj.teamId = Math.round(message.teamId);
    }
    if (message.teamNetworthRank !== undefined && message.teamNetworthRank !== 0) {
      obj.teamNetworthRank = Math.round(message.teamNetworthRank);
    }
    if (message.accountId !== undefined && message.accountId !== 0) {
      obj.accountId = Math.round(message.accountId);
    }
    if (message.playerSlot !== undefined && message.playerSlot !== 0) {
      obj.playerSlot = Math.round(message.playerSlot);
    }
    if (message.rank !== undefined && message.rank !== 0) {
      obj.rank = Math.round(message.rank);
    }
    if (message.heroId !== undefined && message.heroId !== 0) {
      obj.heroId = Math.round(message.heroId);
    }
    if (message.role !== undefined && message.role !== 0) {
      obj.role = Math.round(message.role);
    }
    if (message.kills !== undefined && message.kills !== 0) {
      obj.kills = Math.round(message.kills);
    }
    if (message.deaths !== undefined && message.deaths !== 0) {
      obj.deaths = Math.round(message.deaths);
    }
    if (message.assists !== undefined && message.assists !== 0) {
      obj.assists = Math.round(message.assists);
    }
    if (message.xp !== undefined && message.xp !== 0) {
      obj.xp = Math.round(message.xp);
    }
    if (message.netWorth !== undefined && message.netWorth !== 0) {
      obj.netWorth = Math.round(message.netWorth);
    }
    if (message.supportGoldSpent !== undefined && message.supportGoldSpent !== 0) {
      obj.supportGoldSpent = Math.round(message.supportGoldSpent);
    }
    if (message.wardsPlaced !== undefined && message.wardsPlaced !== 0) {
      obj.wardsPlaced = Math.round(message.wardsPlaced);
    }
    if (message.wardsSpottedForDewarding !== undefined && message.wardsSpottedForDewarding !== 0) {
      obj.wardsSpottedForDewarding = Math.round(message.wardsSpottedForDewarding);
    }
    if (message.campsStacked !== undefined && message.campsStacked !== 0) {
      obj.campsStacked = Math.round(message.campsStacked);
    }
    if (message.lastHits !== undefined && message.lastHits !== 0) {
      obj.lastHits = Math.round(message.lastHits);
    }
    if (message.denies !== undefined && message.denies !== 0) {
      obj.denies = Math.round(message.denies);
    }
    if (message.buildingDamage !== undefined && message.buildingDamage !== 0) {
      obj.buildingDamage = Math.round(message.buildingDamage);
    }
    if (message.otherDamage !== undefined && message.otherDamage !== 0) {
      obj.otherDamage = Math.round(message.otherDamage);
    }
    if (message.tripleKills !== undefined && message.tripleKills !== 0) {
      obj.tripleKills = Math.round(message.tripleKills);
    }
    if (message.rampages !== undefined && message.rampages !== 0) {
      obj.rampages = Math.round(message.rampages);
    }
    if (message.firstBlood !== undefined && message.firstBlood !== 0) {
      obj.firstBlood = Math.round(message.firstBlood);
    }
    if (message.killEaterEvents?.length) {
      obj.killEaterEvents = message.killEaterEvents.map((e) => CMsgSignOutMVPStats_Player_KillEaterEvent.toJSON(e));
    }
    if (message.highestKillstreak !== undefined && message.highestKillstreak !== 0) {
      obj.highestKillstreak = Math.round(message.highestKillstreak);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSignOutMVPStats_Player>): CMsgSignOutMVPStats_Player {
    return CMsgSignOutMVPStats_Player.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSignOutMVPStats_Player>): CMsgSignOutMVPStats_Player {
    const message = createBaseCMsgSignOutMVPStats_Player();
    message.teamId = object.teamId ?? 0;
    message.teamNetworthRank = object.teamNetworthRank ?? 0;
    message.accountId = object.accountId ?? 0;
    message.playerSlot = object.playerSlot ?? 0;
    message.rank = object.rank ?? 0;
    message.heroId = object.heroId ?? 0;
    message.role = object.role ?? 0;
    message.kills = object.kills ?? 0;
    message.deaths = object.deaths ?? 0;
    message.assists = object.assists ?? 0;
    message.xp = object.xp ?? 0;
    message.netWorth = object.netWorth ?? 0;
    message.supportGoldSpent = object.supportGoldSpent ?? 0;
    message.wardsPlaced = object.wardsPlaced ?? 0;
    message.wardsSpottedForDewarding = object.wardsSpottedForDewarding ?? 0;
    message.campsStacked = object.campsStacked ?? 0;
    message.lastHits = object.lastHits ?? 0;
    message.denies = object.denies ?? 0;
    message.buildingDamage = object.buildingDamage ?? 0;
    message.otherDamage = object.otherDamage ?? 0;
    message.tripleKills = object.tripleKills ?? 0;
    message.rampages = object.rampages ?? 0;
    message.firstBlood = object.firstBlood ?? 0;
    message.killEaterEvents =
      object.killEaterEvents?.map((e) => CMsgSignOutMVPStats_Player_KillEaterEvent.fromPartial(e)) || [];
    message.highestKillstreak = object.highestKillstreak ?? 0;
    return message;
  },
};

function createBaseCMsgSignOutMVPStats_Player_KillEaterEvent(): CMsgSignOutMVPStats_Player_KillEaterEvent {
  return { eventType: 0, amount: 0 };
}

export const CMsgSignOutMVPStats_Player_KillEaterEvent = {
  encode(message: CMsgSignOutMVPStats_Player_KillEaterEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.eventType !== 0) {
      writer.uint32(8).uint32(message.eventType);
    }
    if (message.amount !== 0) {
      writer.uint32(16).uint32(message.amount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSignOutMVPStats_Player_KillEaterEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSignOutMVPStats_Player_KillEaterEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.eventType = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.amount = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSignOutMVPStats_Player_KillEaterEvent {
    return {
      eventType: isSet(object.eventType) ? globalThis.Number(object.eventType) : 0,
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
    };
  },

  toJSON(message: CMsgSignOutMVPStats_Player_KillEaterEvent): unknown {
    const obj: any = {};
    if (message.eventType !== 0) {
      obj.eventType = Math.round(message.eventType);
    }
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSignOutMVPStats_Player_KillEaterEvent>): CMsgSignOutMVPStats_Player_KillEaterEvent {
    return CMsgSignOutMVPStats_Player_KillEaterEvent.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgSignOutMVPStats_Player_KillEaterEvent>,
  ): CMsgSignOutMVPStats_Player_KillEaterEvent {
    const message = createBaseCMsgSignOutMVPStats_Player_KillEaterEvent();
    message.eventType = object.eventType ?? 0;
    message.amount = object.amount ?? 0;
    return message;
  },
};

function createBaseCMsgGCToServerRecordTrainingData(): CMsgGCToServerRecordTrainingData {
  return { enable: false };
}

export const CMsgGCToServerRecordTrainingData = {
  encode(message: CMsgGCToServerRecordTrainingData, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.enable !== undefined && message.enable !== false) {
      writer.uint32(8).bool(message.enable);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToServerRecordTrainingData {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToServerRecordTrainingData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.enable = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToServerRecordTrainingData {
    return { enable: isSet(object.enable) ? globalThis.Boolean(object.enable) : false };
  },

  toJSON(message: CMsgGCToServerRecordTrainingData): unknown {
    const obj: any = {};
    if (message.enable !== undefined && message.enable !== false) {
      obj.enable = message.enable;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCToServerRecordTrainingData>): CMsgGCToServerRecordTrainingData {
    return CMsgGCToServerRecordTrainingData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCToServerRecordTrainingData>): CMsgGCToServerRecordTrainingData {
    const message = createBaseCMsgGCToServerRecordTrainingData();
    message.enable = object.enable ?? false;
    return message;
  },
};

function createBaseCMsgServerToGCGetGuildContracts(): CMsgServerToGCGetGuildContracts {
  return { accountIds: [] };
}

export const CMsgServerToGCGetGuildContracts = {
  encode(message: CMsgServerToGCGetGuildContracts, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.accountIds) {
      writer.uint32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgServerToGCGetGuildContracts {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgServerToGCGetGuildContracts();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.accountIds.push(reader.uint32());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.accountIds.push(reader.uint32());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgServerToGCGetGuildContracts {
    return {
      accountIds: globalThis.Array.isArray(object?.accountIds)
        ? object.accountIds.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: CMsgServerToGCGetGuildContracts): unknown {
    const obj: any = {};
    if (message.accountIds?.length) {
      obj.accountIds = message.accountIds.map((e) => Math.round(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgServerToGCGetGuildContracts>): CMsgServerToGCGetGuildContracts {
    return CMsgServerToGCGetGuildContracts.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgServerToGCGetGuildContracts>): CMsgServerToGCGetGuildContracts {
    const message = createBaseCMsgServerToGCGetGuildContracts();
    message.accountIds = object.accountIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseCMsgServerToGCGetGuildContractsResponse(): CMsgServerToGCGetGuildContractsResponse {
  return { playerContracts: [] };
}

export const CMsgServerToGCGetGuildContractsResponse = {
  encode(message: CMsgServerToGCGetGuildContractsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.playerContracts) {
      CMsgServerToGCGetGuildContractsResponse_Player.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgServerToGCGetGuildContractsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgServerToGCGetGuildContractsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.playerContracts.push(CMsgServerToGCGetGuildContractsResponse_Player.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgServerToGCGetGuildContractsResponse {
    return {
      playerContracts: globalThis.Array.isArray(object?.playerContracts)
        ? object.playerContracts.map((e: any) => CMsgServerToGCGetGuildContractsResponse_Player.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgServerToGCGetGuildContractsResponse): unknown {
    const obj: any = {};
    if (message.playerContracts?.length) {
      obj.playerContracts = message.playerContracts.map((e) =>
        CMsgServerToGCGetGuildContractsResponse_Player.toJSON(e)
      );
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgServerToGCGetGuildContractsResponse>): CMsgServerToGCGetGuildContractsResponse {
    return CMsgServerToGCGetGuildContractsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgServerToGCGetGuildContractsResponse>): CMsgServerToGCGetGuildContractsResponse {
    const message = createBaseCMsgServerToGCGetGuildContractsResponse();
    message.playerContracts =
      object.playerContracts?.map((e) => CMsgServerToGCGetGuildContractsResponse_Player.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgServerToGCGetGuildContractsResponse_ContractDetails(): CMsgServerToGCGetGuildContractsResponse_ContractDetails {
  return { contractId: "0", challengeInstanceId: 0, challengeParameter: 0, contractStars: 0, contractSlot: 0 };
}

export const CMsgServerToGCGetGuildContractsResponse_ContractDetails = {
  encode(
    message: CMsgServerToGCGetGuildContractsResponse_ContractDetails,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.contractId !== undefined && message.contractId !== "0") {
      writer.uint32(8).uint64(message.contractId);
    }
    if (message.challengeInstanceId !== undefined && message.challengeInstanceId !== 0) {
      writer.uint32(16).uint32(message.challengeInstanceId);
    }
    if (message.challengeParameter !== undefined && message.challengeParameter !== 0) {
      writer.uint32(24).uint32(message.challengeParameter);
    }
    if (message.contractStars !== undefined && message.contractStars !== 0) {
      writer.uint32(32).uint32(message.contractStars);
    }
    if (message.contractSlot !== undefined && message.contractSlot !== 0) {
      writer.uint32(40).uint32(message.contractSlot);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgServerToGCGetGuildContractsResponse_ContractDetails {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgServerToGCGetGuildContractsResponse_ContractDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.contractId = longToString(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.challengeInstanceId = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.challengeParameter = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.contractStars = reader.uint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.contractSlot = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgServerToGCGetGuildContractsResponse_ContractDetails {
    return {
      contractId: isSet(object.contractId) ? globalThis.String(object.contractId) : "0",
      challengeInstanceId: isSet(object.challengeInstanceId) ? globalThis.Number(object.challengeInstanceId) : 0,
      challengeParameter: isSet(object.challengeParameter) ? globalThis.Number(object.challengeParameter) : 0,
      contractStars: isSet(object.contractStars) ? globalThis.Number(object.contractStars) : 0,
      contractSlot: isSet(object.contractSlot) ? globalThis.Number(object.contractSlot) : 0,
    };
  },

  toJSON(message: CMsgServerToGCGetGuildContractsResponse_ContractDetails): unknown {
    const obj: any = {};
    if (message.contractId !== undefined && message.contractId !== "0") {
      obj.contractId = message.contractId;
    }
    if (message.challengeInstanceId !== undefined && message.challengeInstanceId !== 0) {
      obj.challengeInstanceId = Math.round(message.challengeInstanceId);
    }
    if (message.challengeParameter !== undefined && message.challengeParameter !== 0) {
      obj.challengeParameter = Math.round(message.challengeParameter);
    }
    if (message.contractStars !== undefined && message.contractStars !== 0) {
      obj.contractStars = Math.round(message.contractStars);
    }
    if (message.contractSlot !== undefined && message.contractSlot !== 0) {
      obj.contractSlot = Math.round(message.contractSlot);
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgServerToGCGetGuildContractsResponse_ContractDetails>,
  ): CMsgServerToGCGetGuildContractsResponse_ContractDetails {
    return CMsgServerToGCGetGuildContractsResponse_ContractDetails.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgServerToGCGetGuildContractsResponse_ContractDetails>,
  ): CMsgServerToGCGetGuildContractsResponse_ContractDetails {
    const message = createBaseCMsgServerToGCGetGuildContractsResponse_ContractDetails();
    message.contractId = object.contractId ?? "0";
    message.challengeInstanceId = object.challengeInstanceId ?? 0;
    message.challengeParameter = object.challengeParameter ?? 0;
    message.contractStars = object.contractStars ?? 0;
    message.contractSlot = object.contractSlot ?? 0;
    return message;
  },
};

function createBaseCMsgServerToGCGetGuildContractsResponse_Player(): CMsgServerToGCGetGuildContractsResponse_Player {
  return { accountId: 0, guildId: 0, eventId: 0, contracts: [] };
}

export const CMsgServerToGCGetGuildContractsResponse_Player = {
  encode(
    message: CMsgServerToGCGetGuildContractsResponse_Player,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.accountId !== undefined && message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    if (message.guildId !== undefined && message.guildId !== 0) {
      writer.uint32(16).uint32(message.guildId);
    }
    if (message.eventId !== undefined && message.eventId !== 0) {
      writer.uint32(24).int32(message.eventId);
    }
    for (const v of message.contracts) {
      CMsgServerToGCGetGuildContractsResponse_ContractDetails.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgServerToGCGetGuildContractsResponse_Player {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgServerToGCGetGuildContractsResponse_Player();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.guildId = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.eventId = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.contracts.push(
            CMsgServerToGCGetGuildContractsResponse_ContractDetails.decode(reader, reader.uint32()),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgServerToGCGetGuildContractsResponse_Player {
    return {
      accountId: isSet(object.accountId) ? globalThis.Number(object.accountId) : 0,
      guildId: isSet(object.guildId) ? globalThis.Number(object.guildId) : 0,
      eventId: isSet(object.eventId) ? eEventFromJSON(object.eventId) : 0,
      contracts: globalThis.Array.isArray(object?.contracts)
        ? object.contracts.map((e: any) => CMsgServerToGCGetGuildContractsResponse_ContractDetails.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgServerToGCGetGuildContractsResponse_Player): unknown {
    const obj: any = {};
    if (message.accountId !== undefined && message.accountId !== 0) {
      obj.accountId = Math.round(message.accountId);
    }
    if (message.guildId !== undefined && message.guildId !== 0) {
      obj.guildId = Math.round(message.guildId);
    }
    if (message.eventId !== undefined && message.eventId !== 0) {
      obj.eventId = eEventToJSON(message.eventId);
    }
    if (message.contracts?.length) {
      obj.contracts = message.contracts.map((e) => CMsgServerToGCGetGuildContractsResponse_ContractDetails.toJSON(e));
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgServerToGCGetGuildContractsResponse_Player>,
  ): CMsgServerToGCGetGuildContractsResponse_Player {
    return CMsgServerToGCGetGuildContractsResponse_Player.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgServerToGCGetGuildContractsResponse_Player>,
  ): CMsgServerToGCGetGuildContractsResponse_Player {
    const message = createBaseCMsgServerToGCGetGuildContractsResponse_Player();
    message.accountId = object.accountId ?? 0;
    message.guildId = object.guildId ?? 0;
    message.eventId = object.eventId ?? 0;
    message.contracts =
      object.contracts?.map((e) => CMsgServerToGCGetGuildContractsResponse_ContractDetails.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgMatchDiretideCandy(): CMsgMatchDiretideCandy {
  return { playerCandyData: [], eventId: 0 };
}

export const CMsgMatchDiretideCandy = {
  encode(message: CMsgMatchDiretideCandy, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.playerCandyData) {
      CMsgMatchDiretideCandy_PlayerCandy.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.eventId !== undefined && message.eventId !== 0) {
      writer.uint32(16).int32(message.eventId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgMatchDiretideCandy {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgMatchDiretideCandy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.playerCandyData.push(CMsgMatchDiretideCandy_PlayerCandy.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.eventId = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgMatchDiretideCandy {
    return {
      playerCandyData: globalThis.Array.isArray(object?.playerCandyData)
        ? object.playerCandyData.map((e: any) => CMsgMatchDiretideCandy_PlayerCandy.fromJSON(e))
        : [],
      eventId: isSet(object.eventId) ? eEventFromJSON(object.eventId) : 0,
    };
  },

  toJSON(message: CMsgMatchDiretideCandy): unknown {
    const obj: any = {};
    if (message.playerCandyData?.length) {
      obj.playerCandyData = message.playerCandyData.map((e) => CMsgMatchDiretideCandy_PlayerCandy.toJSON(e));
    }
    if (message.eventId !== undefined && message.eventId !== 0) {
      obj.eventId = eEventToJSON(message.eventId);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgMatchDiretideCandy>): CMsgMatchDiretideCandy {
    return CMsgMatchDiretideCandy.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgMatchDiretideCandy>): CMsgMatchDiretideCandy {
    const message = createBaseCMsgMatchDiretideCandy();
    message.playerCandyData = object.playerCandyData?.map((e) => CMsgMatchDiretideCandy_PlayerCandy.fromPartial(e)) ||
      [];
    message.eventId = object.eventId ?? 0;
    return message;
  },
};

function createBaseCMsgMatchDiretideCandy_CandyDetails(): CMsgMatchDiretideCandy_CandyDetails {
  return { amount: 0, audit: 0 };
}

export const CMsgMatchDiretideCandy_CandyDetails = {
  encode(message: CMsgMatchDiretideCandy_CandyDetails, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.amount !== undefined && message.amount !== 0) {
      writer.uint32(8).uint32(message.amount);
    }
    if (message.audit !== undefined && message.audit !== 0) {
      writer.uint32(16).uint32(message.audit);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgMatchDiretideCandy_CandyDetails {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgMatchDiretideCandy_CandyDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.amount = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.audit = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgMatchDiretideCandy_CandyDetails {
    return {
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      audit: isSet(object.audit) ? globalThis.Number(object.audit) : 0,
    };
  },

  toJSON(message: CMsgMatchDiretideCandy_CandyDetails): unknown {
    const obj: any = {};
    if (message.amount !== undefined && message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    if (message.audit !== undefined && message.audit !== 0) {
      obj.audit = Math.round(message.audit);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgMatchDiretideCandy_CandyDetails>): CMsgMatchDiretideCandy_CandyDetails {
    return CMsgMatchDiretideCandy_CandyDetails.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgMatchDiretideCandy_CandyDetails>): CMsgMatchDiretideCandy_CandyDetails {
    const message = createBaseCMsgMatchDiretideCandy_CandyDetails();
    message.amount = object.amount ?? 0;
    message.audit = object.audit ?? 0;
    return message;
  },
};

function createBaseCMsgMatchDiretideCandy_PlayerCandy(): CMsgMatchDiretideCandy_PlayerCandy {
  return { accountId: 0, candyAmount: 0, consumesPeriodicResource: false, candyBreakdown: [] };
}

export const CMsgMatchDiretideCandy_PlayerCandy = {
  encode(message: CMsgMatchDiretideCandy_PlayerCandy, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.accountId !== undefined && message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    if (message.candyAmount !== undefined && message.candyAmount !== 0) {
      writer.uint32(24).uint32(message.candyAmount);
    }
    if (message.consumesPeriodicResource !== undefined && message.consumesPeriodicResource !== false) {
      writer.uint32(32).bool(message.consumesPeriodicResource);
    }
    for (const v of message.candyBreakdown) {
      CMsgMatchDiretideCandy_CandyDetails.encode(v!, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgMatchDiretideCandy_PlayerCandy {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgMatchDiretideCandy_PlayerCandy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.candyAmount = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.consumesPeriodicResource = reader.bool();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.candyBreakdown.push(CMsgMatchDiretideCandy_CandyDetails.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgMatchDiretideCandy_PlayerCandy {
    return {
      accountId: isSet(object.accountId) ? globalThis.Number(object.accountId) : 0,
      candyAmount: isSet(object.candyAmount) ? globalThis.Number(object.candyAmount) : 0,
      consumesPeriodicResource: isSet(object.consumesPeriodicResource)
        ? globalThis.Boolean(object.consumesPeriodicResource)
        : false,
      candyBreakdown: globalThis.Array.isArray(object?.candyBreakdown)
        ? object.candyBreakdown.map((e: any) => CMsgMatchDiretideCandy_CandyDetails.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgMatchDiretideCandy_PlayerCandy): unknown {
    const obj: any = {};
    if (message.accountId !== undefined && message.accountId !== 0) {
      obj.accountId = Math.round(message.accountId);
    }
    if (message.candyAmount !== undefined && message.candyAmount !== 0) {
      obj.candyAmount = Math.round(message.candyAmount);
    }
    if (message.consumesPeriodicResource !== undefined && message.consumesPeriodicResource !== false) {
      obj.consumesPeriodicResource = message.consumesPeriodicResource;
    }
    if (message.candyBreakdown?.length) {
      obj.candyBreakdown = message.candyBreakdown.map((e) => CMsgMatchDiretideCandy_CandyDetails.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgMatchDiretideCandy_PlayerCandy>): CMsgMatchDiretideCandy_PlayerCandy {
    return CMsgMatchDiretideCandy_PlayerCandy.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgMatchDiretideCandy_PlayerCandy>): CMsgMatchDiretideCandy_PlayerCandy {
    const message = createBaseCMsgMatchDiretideCandy_PlayerCandy();
    message.accountId = object.accountId ?? 0;
    message.candyAmount = object.candyAmount ?? 0;
    message.consumesPeriodicResource = object.consumesPeriodicResource ?? false;
    message.candyBreakdown = object.candyBreakdown?.map((e) => CMsgMatchDiretideCandy_CandyDetails.fromPartial(e)) ||
      [];
    return message;
  },
};

function createBaseCMsgGCToServerCheerData(): CMsgGCToServerCheerData {
  return { cheerTypes: [] };
}

export const CMsgGCToServerCheerData = {
  encode(message: CMsgGCToServerCheerData, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.cheerTypes) {
      CMsgGCToServerCheerData_CheerTypeCount.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToServerCheerData {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToServerCheerData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.cheerTypes.push(CMsgGCToServerCheerData_CheerTypeCount.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToServerCheerData {
    return {
      cheerTypes: globalThis.Array.isArray(object?.cheerTypes)
        ? object.cheerTypes.map((e: any) => CMsgGCToServerCheerData_CheerTypeCount.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgGCToServerCheerData): unknown {
    const obj: any = {};
    if (message.cheerTypes?.length) {
      obj.cheerTypes = message.cheerTypes.map((e) => CMsgGCToServerCheerData_CheerTypeCount.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCToServerCheerData>): CMsgGCToServerCheerData {
    return CMsgGCToServerCheerData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCToServerCheerData>): CMsgGCToServerCheerData {
    const message = createBaseCMsgGCToServerCheerData();
    message.cheerTypes = object.cheerTypes?.map((e) => CMsgGCToServerCheerData_CheerTypeCount.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgGCToServerCheerData_CheerTypeCount(): CMsgGCToServerCheerData_CheerTypeCount {
  return { cheerType: 0, cheerCount: 0 };
}

export const CMsgGCToServerCheerData_CheerTypeCount = {
  encode(message: CMsgGCToServerCheerData_CheerTypeCount, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.cheerType !== undefined && message.cheerType !== 0) {
      writer.uint32(8).uint32(message.cheerType);
    }
    if (message.cheerCount !== undefined && message.cheerCount !== 0) {
      writer.uint32(16).uint32(message.cheerCount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToServerCheerData_CheerTypeCount {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToServerCheerData_CheerTypeCount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.cheerType = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.cheerCount = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToServerCheerData_CheerTypeCount {
    return {
      cheerType: isSet(object.cheerType) ? globalThis.Number(object.cheerType) : 0,
      cheerCount: isSet(object.cheerCount) ? globalThis.Number(object.cheerCount) : 0,
    };
  },

  toJSON(message: CMsgGCToServerCheerData_CheerTypeCount): unknown {
    const obj: any = {};
    if (message.cheerType !== undefined && message.cheerType !== 0) {
      obj.cheerType = Math.round(message.cheerType);
    }
    if (message.cheerCount !== undefined && message.cheerCount !== 0) {
      obj.cheerCount = Math.round(message.cheerCount);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCToServerCheerData_CheerTypeCount>): CMsgGCToServerCheerData_CheerTypeCount {
    return CMsgGCToServerCheerData_CheerTypeCount.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCToServerCheerData_CheerTypeCount>): CMsgGCToServerCheerData_CheerTypeCount {
    const message = createBaseCMsgGCToServerCheerData_CheerTypeCount();
    message.cheerType = object.cheerType ?? 0;
    message.cheerCount = object.cheerCount ?? 0;
    return message;
  },
};

function createBaseCMsgCheerConfig(): CMsgCheerConfig {
  return {
    cheersEnabled: false,
    isValidLeagueId: false,
    windowDuration: 0,
    windowBucketCount: 0,
    crowdLevelPushTime: 0,
    crowdLevelLow: 0,
    crowdLevelMedium: 0,
    crowdLevelHigh: 0,
    cheerScaleStart: 0,
    cheerScaleSpeed: 0,
    cheerScalePushMark: 0,
    cheerScalePullMark: 0,
    cheerScalePctOfMaxCpsClamp: 0,
    cheerScaleDampenerValue: 0,
    cheerScaleDampenerLerpTime: 0,
    cheerFactorBronze: 0,
    cheerFactorSilver: 0,
    cheerFactorGold: 0,
  };
}

export const CMsgCheerConfig = {
  encode(message: CMsgCheerConfig, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.cheersEnabled !== undefined && message.cheersEnabled !== false) {
      writer.uint32(8).bool(message.cheersEnabled);
    }
    if (message.isValidLeagueId !== undefined && message.isValidLeagueId !== false) {
      writer.uint32(16).bool(message.isValidLeagueId);
    }
    if (message.windowDuration !== undefined && message.windowDuration !== 0) {
      writer.uint32(29).float(message.windowDuration);
    }
    if (message.windowBucketCount !== undefined && message.windowBucketCount !== 0) {
      writer.uint32(32).uint32(message.windowBucketCount);
    }
    if (message.crowdLevelPushTime !== undefined && message.crowdLevelPushTime !== 0) {
      writer.uint32(53).float(message.crowdLevelPushTime);
    }
    if (message.crowdLevelLow !== undefined && message.crowdLevelLow !== 0) {
      writer.uint32(80).uint32(message.crowdLevelLow);
    }
    if (message.crowdLevelMedium !== undefined && message.crowdLevelMedium !== 0) {
      writer.uint32(88).uint32(message.crowdLevelMedium);
    }
    if (message.crowdLevelHigh !== undefined && message.crowdLevelHigh !== 0) {
      writer.uint32(96).uint32(message.crowdLevelHigh);
    }
    if (message.cheerScaleStart !== undefined && message.cheerScaleStart !== 0) {
      writer.uint32(109).float(message.cheerScaleStart);
    }
    if (message.cheerScaleSpeed !== undefined && message.cheerScaleSpeed !== 0) {
      writer.uint32(117).float(message.cheerScaleSpeed);
    }
    if (message.cheerScalePushMark !== undefined && message.cheerScalePushMark !== 0) {
      writer.uint32(120).uint32(message.cheerScalePushMark);
    }
    if (message.cheerScalePullMark !== undefined && message.cheerScalePullMark !== 0) {
      writer.uint32(128).uint32(message.cheerScalePullMark);
    }
    if (message.cheerScalePctOfMaxCpsClamp !== undefined && message.cheerScalePctOfMaxCpsClamp !== 0) {
      writer.uint32(141).float(message.cheerScalePctOfMaxCpsClamp);
    }
    if (message.cheerScaleDampenerValue !== undefined && message.cheerScaleDampenerValue !== 0) {
      writer.uint32(173).float(message.cheerScaleDampenerValue);
    }
    if (message.cheerScaleDampenerLerpTime !== undefined && message.cheerScaleDampenerLerpTime !== 0) {
      writer.uint32(176).uint32(message.cheerScaleDampenerLerpTime);
    }
    if (message.cheerFactorBronze !== undefined && message.cheerFactorBronze !== 0) {
      writer.uint32(149).float(message.cheerFactorBronze);
    }
    if (message.cheerFactorSilver !== undefined && message.cheerFactorSilver !== 0) {
      writer.uint32(157).float(message.cheerFactorSilver);
    }
    if (message.cheerFactorGold !== undefined && message.cheerFactorGold !== 0) {
      writer.uint32(165).float(message.cheerFactorGold);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgCheerConfig {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgCheerConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.cheersEnabled = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.isValidLeagueId = reader.bool();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.windowDuration = reader.float();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.windowBucketCount = reader.uint32();
          continue;
        case 6:
          if (tag !== 53) {
            break;
          }

          message.crowdLevelPushTime = reader.float();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.crowdLevelLow = reader.uint32();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.crowdLevelMedium = reader.uint32();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.crowdLevelHigh = reader.uint32();
          continue;
        case 13:
          if (tag !== 109) {
            break;
          }

          message.cheerScaleStart = reader.float();
          continue;
        case 14:
          if (tag !== 117) {
            break;
          }

          message.cheerScaleSpeed = reader.float();
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.cheerScalePushMark = reader.uint32();
          continue;
        case 16:
          if (tag !== 128) {
            break;
          }

          message.cheerScalePullMark = reader.uint32();
          continue;
        case 17:
          if (tag !== 141) {
            break;
          }

          message.cheerScalePctOfMaxCpsClamp = reader.float();
          continue;
        case 21:
          if (tag !== 173) {
            break;
          }

          message.cheerScaleDampenerValue = reader.float();
          continue;
        case 22:
          if (tag !== 176) {
            break;
          }

          message.cheerScaleDampenerLerpTime = reader.uint32();
          continue;
        case 18:
          if (tag !== 149) {
            break;
          }

          message.cheerFactorBronze = reader.float();
          continue;
        case 19:
          if (tag !== 157) {
            break;
          }

          message.cheerFactorSilver = reader.float();
          continue;
        case 20:
          if (tag !== 165) {
            break;
          }

          message.cheerFactorGold = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgCheerConfig {
    return {
      cheersEnabled: isSet(object.cheersEnabled) ? globalThis.Boolean(object.cheersEnabled) : false,
      isValidLeagueId: isSet(object.isValidLeagueId) ? globalThis.Boolean(object.isValidLeagueId) : false,
      windowDuration: isSet(object.windowDuration) ? globalThis.Number(object.windowDuration) : 0,
      windowBucketCount: isSet(object.windowBucketCount) ? globalThis.Number(object.windowBucketCount) : 0,
      crowdLevelPushTime: isSet(object.crowdLevelPushTime) ? globalThis.Number(object.crowdLevelPushTime) : 0,
      crowdLevelLow: isSet(object.crowdLevelLow) ? globalThis.Number(object.crowdLevelLow) : 0,
      crowdLevelMedium: isSet(object.crowdLevelMedium) ? globalThis.Number(object.crowdLevelMedium) : 0,
      crowdLevelHigh: isSet(object.crowdLevelHigh) ? globalThis.Number(object.crowdLevelHigh) : 0,
      cheerScaleStart: isSet(object.cheerScaleStart) ? globalThis.Number(object.cheerScaleStart) : 0,
      cheerScaleSpeed: isSet(object.cheerScaleSpeed) ? globalThis.Number(object.cheerScaleSpeed) : 0,
      cheerScalePushMark: isSet(object.cheerScalePushMark) ? globalThis.Number(object.cheerScalePushMark) : 0,
      cheerScalePullMark: isSet(object.cheerScalePullMark) ? globalThis.Number(object.cheerScalePullMark) : 0,
      cheerScalePctOfMaxCpsClamp: isSet(object.cheerScalePctOfMaxCpsClamp)
        ? globalThis.Number(object.cheerScalePctOfMaxCpsClamp)
        : 0,
      cheerScaleDampenerValue: isSet(object.cheerScaleDampenerValue)
        ? globalThis.Number(object.cheerScaleDampenerValue)
        : 0,
      cheerScaleDampenerLerpTime: isSet(object.cheerScaleDampenerLerpTime)
        ? globalThis.Number(object.cheerScaleDampenerLerpTime)
        : 0,
      cheerFactorBronze: isSet(object.cheerFactorBronze) ? globalThis.Number(object.cheerFactorBronze) : 0,
      cheerFactorSilver: isSet(object.cheerFactorSilver) ? globalThis.Number(object.cheerFactorSilver) : 0,
      cheerFactorGold: isSet(object.cheerFactorGold) ? globalThis.Number(object.cheerFactorGold) : 0,
    };
  },

  toJSON(message: CMsgCheerConfig): unknown {
    const obj: any = {};
    if (message.cheersEnabled !== undefined && message.cheersEnabled !== false) {
      obj.cheersEnabled = message.cheersEnabled;
    }
    if (message.isValidLeagueId !== undefined && message.isValidLeagueId !== false) {
      obj.isValidLeagueId = message.isValidLeagueId;
    }
    if (message.windowDuration !== undefined && message.windowDuration !== 0) {
      obj.windowDuration = message.windowDuration;
    }
    if (message.windowBucketCount !== undefined && message.windowBucketCount !== 0) {
      obj.windowBucketCount = Math.round(message.windowBucketCount);
    }
    if (message.crowdLevelPushTime !== undefined && message.crowdLevelPushTime !== 0) {
      obj.crowdLevelPushTime = message.crowdLevelPushTime;
    }
    if (message.crowdLevelLow !== undefined && message.crowdLevelLow !== 0) {
      obj.crowdLevelLow = Math.round(message.crowdLevelLow);
    }
    if (message.crowdLevelMedium !== undefined && message.crowdLevelMedium !== 0) {
      obj.crowdLevelMedium = Math.round(message.crowdLevelMedium);
    }
    if (message.crowdLevelHigh !== undefined && message.crowdLevelHigh !== 0) {
      obj.crowdLevelHigh = Math.round(message.crowdLevelHigh);
    }
    if (message.cheerScaleStart !== undefined && message.cheerScaleStart !== 0) {
      obj.cheerScaleStart = message.cheerScaleStart;
    }
    if (message.cheerScaleSpeed !== undefined && message.cheerScaleSpeed !== 0) {
      obj.cheerScaleSpeed = message.cheerScaleSpeed;
    }
    if (message.cheerScalePushMark !== undefined && message.cheerScalePushMark !== 0) {
      obj.cheerScalePushMark = Math.round(message.cheerScalePushMark);
    }
    if (message.cheerScalePullMark !== undefined && message.cheerScalePullMark !== 0) {
      obj.cheerScalePullMark = Math.round(message.cheerScalePullMark);
    }
    if (message.cheerScalePctOfMaxCpsClamp !== undefined && message.cheerScalePctOfMaxCpsClamp !== 0) {
      obj.cheerScalePctOfMaxCpsClamp = message.cheerScalePctOfMaxCpsClamp;
    }
    if (message.cheerScaleDampenerValue !== undefined && message.cheerScaleDampenerValue !== 0) {
      obj.cheerScaleDampenerValue = message.cheerScaleDampenerValue;
    }
    if (message.cheerScaleDampenerLerpTime !== undefined && message.cheerScaleDampenerLerpTime !== 0) {
      obj.cheerScaleDampenerLerpTime = Math.round(message.cheerScaleDampenerLerpTime);
    }
    if (message.cheerFactorBronze !== undefined && message.cheerFactorBronze !== 0) {
      obj.cheerFactorBronze = message.cheerFactorBronze;
    }
    if (message.cheerFactorSilver !== undefined && message.cheerFactorSilver !== 0) {
      obj.cheerFactorSilver = message.cheerFactorSilver;
    }
    if (message.cheerFactorGold !== undefined && message.cheerFactorGold !== 0) {
      obj.cheerFactorGold = message.cheerFactorGold;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgCheerConfig>): CMsgCheerConfig {
    return CMsgCheerConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgCheerConfig>): CMsgCheerConfig {
    const message = createBaseCMsgCheerConfig();
    message.cheersEnabled = object.cheersEnabled ?? false;
    message.isValidLeagueId = object.isValidLeagueId ?? false;
    message.windowDuration = object.windowDuration ?? 0;
    message.windowBucketCount = object.windowBucketCount ?? 0;
    message.crowdLevelPushTime = object.crowdLevelPushTime ?? 0;
    message.crowdLevelLow = object.crowdLevelLow ?? 0;
    message.crowdLevelMedium = object.crowdLevelMedium ?? 0;
    message.crowdLevelHigh = object.crowdLevelHigh ?? 0;
    message.cheerScaleStart = object.cheerScaleStart ?? 0;
    message.cheerScaleSpeed = object.cheerScaleSpeed ?? 0;
    message.cheerScalePushMark = object.cheerScalePushMark ?? 0;
    message.cheerScalePullMark = object.cheerScalePullMark ?? 0;
    message.cheerScalePctOfMaxCpsClamp = object.cheerScalePctOfMaxCpsClamp ?? 0;
    message.cheerScaleDampenerValue = object.cheerScaleDampenerValue ?? 0;
    message.cheerScaleDampenerLerpTime = object.cheerScaleDampenerLerpTime ?? 0;
    message.cheerFactorBronze = object.cheerFactorBronze ?? 0;
    message.cheerFactorSilver = object.cheerFactorSilver ?? 0;
    message.cheerFactorGold = object.cheerFactorGold ?? 0;
    return message;
  },
};

function createBaseCMsgGCToServerCheerConfig(): CMsgGCToServerCheerConfig {
  return { cheerConfig: undefined };
}

export const CMsgGCToServerCheerConfig = {
  encode(message: CMsgGCToServerCheerConfig, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.cheerConfig !== undefined) {
      CMsgCheerConfig.encode(message.cheerConfig, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToServerCheerConfig {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToServerCheerConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.cheerConfig = CMsgCheerConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToServerCheerConfig {
    return { cheerConfig: isSet(object.cheerConfig) ? CMsgCheerConfig.fromJSON(object.cheerConfig) : undefined };
  },

  toJSON(message: CMsgGCToServerCheerConfig): unknown {
    const obj: any = {};
    if (message.cheerConfig !== undefined) {
      obj.cheerConfig = CMsgCheerConfig.toJSON(message.cheerConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCToServerCheerConfig>): CMsgGCToServerCheerConfig {
    return CMsgGCToServerCheerConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCToServerCheerConfig>): CMsgGCToServerCheerConfig {
    const message = createBaseCMsgGCToServerCheerConfig();
    message.cheerConfig = (object.cheerConfig !== undefined && object.cheerConfig !== null)
      ? CMsgCheerConfig.fromPartial(object.cheerConfig)
      : undefined;
    return message;
  },
};

function createBaseCMsgServerToGCGetCheerConfig(): CMsgServerToGCGetCheerConfig {
  return { leagueId: 0 };
}

export const CMsgServerToGCGetCheerConfig = {
  encode(message: CMsgServerToGCGetCheerConfig, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.leagueId !== undefined && message.leagueId !== 0) {
      writer.uint32(8).uint32(message.leagueId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgServerToGCGetCheerConfig {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgServerToGCGetCheerConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.leagueId = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgServerToGCGetCheerConfig {
    return { leagueId: isSet(object.leagueId) ? globalThis.Number(object.leagueId) : 0 };
  },

  toJSON(message: CMsgServerToGCGetCheerConfig): unknown {
    const obj: any = {};
    if (message.leagueId !== undefined && message.leagueId !== 0) {
      obj.leagueId = Math.round(message.leagueId);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgServerToGCGetCheerConfig>): CMsgServerToGCGetCheerConfig {
    return CMsgServerToGCGetCheerConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgServerToGCGetCheerConfig>): CMsgServerToGCGetCheerConfig {
    const message = createBaseCMsgServerToGCGetCheerConfig();
    message.leagueId = object.leagueId ?? 0;
    return message;
  },
};

function createBaseCMsgServerToGCGetCheerConfigResponse(): CMsgServerToGCGetCheerConfigResponse {
  return { cheerConfig: undefined };
}

export const CMsgServerToGCGetCheerConfigResponse = {
  encode(message: CMsgServerToGCGetCheerConfigResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.cheerConfig !== undefined) {
      CMsgCheerConfig.encode(message.cheerConfig, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgServerToGCGetCheerConfigResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgServerToGCGetCheerConfigResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.cheerConfig = CMsgCheerConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgServerToGCGetCheerConfigResponse {
    return { cheerConfig: isSet(object.cheerConfig) ? CMsgCheerConfig.fromJSON(object.cheerConfig) : undefined };
  },

  toJSON(message: CMsgServerToGCGetCheerConfigResponse): unknown {
    const obj: any = {};
    if (message.cheerConfig !== undefined) {
      obj.cheerConfig = CMsgCheerConfig.toJSON(message.cheerConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgServerToGCGetCheerConfigResponse>): CMsgServerToGCGetCheerConfigResponse {
    return CMsgServerToGCGetCheerConfigResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgServerToGCGetCheerConfigResponse>): CMsgServerToGCGetCheerConfigResponse {
    const message = createBaseCMsgServerToGCGetCheerConfigResponse();
    message.cheerConfig = (object.cheerConfig !== undefined && object.cheerConfig !== null)
      ? CMsgCheerConfig.fromPartial(object.cheerConfig)
      : undefined;
    return message;
  },
};

function createBaseCMsgGCToServerCheerScalesOverride(): CMsgGCToServerCheerScalesOverride {
  return { scales: [] };
}

export const CMsgGCToServerCheerScalesOverride = {
  encode(message: CMsgGCToServerCheerScalesOverride, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.scales) {
      writer.float(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToServerCheerScalesOverride {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToServerCheerScalesOverride();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 13) {
            message.scales.push(reader.float());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.scales.push(reader.float());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToServerCheerScalesOverride {
    return {
      scales: globalThis.Array.isArray(object?.scales) ? object.scales.map((e: any) => globalThis.Number(e)) : [],
    };
  },

  toJSON(message: CMsgGCToServerCheerScalesOverride): unknown {
    const obj: any = {};
    if (message.scales?.length) {
      obj.scales = message.scales;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCToServerCheerScalesOverride>): CMsgGCToServerCheerScalesOverride {
    return CMsgGCToServerCheerScalesOverride.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCToServerCheerScalesOverride>): CMsgGCToServerCheerScalesOverride {
    const message = createBaseCMsgGCToServerCheerScalesOverride();
    message.scales = object.scales?.map((e) => e) || [];
    return message;
  },
};

function createBaseCMsgGCToServerGetCheerState(): CMsgGCToServerGetCheerState {
  return {};
}

export const CMsgGCToServerGetCheerState = {
  encode(_: CMsgGCToServerGetCheerState, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToServerGetCheerState {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToServerGetCheerState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CMsgGCToServerGetCheerState {
    return {};
  },

  toJSON(_: CMsgGCToServerGetCheerState): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<CMsgGCToServerGetCheerState>): CMsgGCToServerGetCheerState {
    return CMsgGCToServerGetCheerState.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<CMsgGCToServerGetCheerState>): CMsgGCToServerGetCheerState {
    const message = createBaseCMsgGCToServerGetCheerState();
    return message;
  },
};

function createBaseCMsgCheerTypeState(): CMsgCheerTypeState {
  return { cheerCounts: [], maxPerSecond: 0, cheerScale: 0, overrideScale: 0 };
}

export const CMsgCheerTypeState = {
  encode(message: CMsgCheerTypeState, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.cheerCounts) {
      writer.uint32(v);
    }
    writer.ldelim();
    if (message.maxPerSecond !== undefined && message.maxPerSecond !== 0) {
      writer.uint32(21).float(message.maxPerSecond);
    }
    if (message.cheerScale !== undefined && message.cheerScale !== 0) {
      writer.uint32(29).float(message.cheerScale);
    }
    if (message.overrideScale !== undefined && message.overrideScale !== 0) {
      writer.uint32(37).float(message.overrideScale);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgCheerTypeState {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgCheerTypeState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.cheerCounts.push(reader.uint32());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.cheerCounts.push(reader.uint32());
            }

            continue;
          }

          break;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.maxPerSecond = reader.float();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.cheerScale = reader.float();
          continue;
        case 4:
          if (tag !== 37) {
            break;
          }

          message.overrideScale = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgCheerTypeState {
    return {
      cheerCounts: globalThis.Array.isArray(object?.cheerCounts)
        ? object.cheerCounts.map((e: any) => globalThis.Number(e))
        : [],
      maxPerSecond: isSet(object.maxPerSecond) ? globalThis.Number(object.maxPerSecond) : 0,
      cheerScale: isSet(object.cheerScale) ? globalThis.Number(object.cheerScale) : 0,
      overrideScale: isSet(object.overrideScale) ? globalThis.Number(object.overrideScale) : 0,
    };
  },

  toJSON(message: CMsgCheerTypeState): unknown {
    const obj: any = {};
    if (message.cheerCounts?.length) {
      obj.cheerCounts = message.cheerCounts.map((e) => Math.round(e));
    }
    if (message.maxPerSecond !== undefined && message.maxPerSecond !== 0) {
      obj.maxPerSecond = message.maxPerSecond;
    }
    if (message.cheerScale !== undefined && message.cheerScale !== 0) {
      obj.cheerScale = message.cheerScale;
    }
    if (message.overrideScale !== undefined && message.overrideScale !== 0) {
      obj.overrideScale = message.overrideScale;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgCheerTypeState>): CMsgCheerTypeState {
    return CMsgCheerTypeState.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgCheerTypeState>): CMsgCheerTypeState {
    const message = createBaseCMsgCheerTypeState();
    message.cheerCounts = object.cheerCounts?.map((e) => e) || [];
    message.maxPerSecond = object.maxPerSecond ?? 0;
    message.cheerScale = object.cheerScale ?? 0;
    message.overrideScale = object.overrideScale ?? 0;
    return message;
  },
};

function createBaseCMsgCheerState(): CMsgCheerState {
  return { cheerTypes: [], radiantCrowdLevel: 0, direCrowdLevel: 0 };
}

export const CMsgCheerState = {
  encode(message: CMsgCheerState, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.cheerTypes) {
      CMsgCheerTypeState.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.radiantCrowdLevel !== undefined && message.radiantCrowdLevel !== 0) {
      writer.uint32(16).uint32(message.radiantCrowdLevel);
    }
    if (message.direCrowdLevel !== undefined && message.direCrowdLevel !== 0) {
      writer.uint32(24).uint32(message.direCrowdLevel);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgCheerState {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgCheerState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.cheerTypes.push(CMsgCheerTypeState.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.radiantCrowdLevel = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.direCrowdLevel = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgCheerState {
    return {
      cheerTypes: globalThis.Array.isArray(object?.cheerTypes)
        ? object.cheerTypes.map((e: any) => CMsgCheerTypeState.fromJSON(e))
        : [],
      radiantCrowdLevel: isSet(object.radiantCrowdLevel) ? globalThis.Number(object.radiantCrowdLevel) : 0,
      direCrowdLevel: isSet(object.direCrowdLevel) ? globalThis.Number(object.direCrowdLevel) : 0,
    };
  },

  toJSON(message: CMsgCheerState): unknown {
    const obj: any = {};
    if (message.cheerTypes?.length) {
      obj.cheerTypes = message.cheerTypes.map((e) => CMsgCheerTypeState.toJSON(e));
    }
    if (message.radiantCrowdLevel !== undefined && message.radiantCrowdLevel !== 0) {
      obj.radiantCrowdLevel = Math.round(message.radiantCrowdLevel);
    }
    if (message.direCrowdLevel !== undefined && message.direCrowdLevel !== 0) {
      obj.direCrowdLevel = Math.round(message.direCrowdLevel);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgCheerState>): CMsgCheerState {
    return CMsgCheerState.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgCheerState>): CMsgCheerState {
    const message = createBaseCMsgCheerState();
    message.cheerTypes = object.cheerTypes?.map((e) => CMsgCheerTypeState.fromPartial(e)) || [];
    message.radiantCrowdLevel = object.radiantCrowdLevel ?? 0;
    message.direCrowdLevel = object.direCrowdLevel ?? 0;
    return message;
  },
};

function createBaseCMsgServerToGCReportCheerState(): CMsgServerToGCReportCheerState {
  return { cheerConfig: undefined, cheerState: undefined };
}

export const CMsgServerToGCReportCheerState = {
  encode(message: CMsgServerToGCReportCheerState, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.cheerConfig !== undefined) {
      CMsgCheerConfig.encode(message.cheerConfig, writer.uint32(10).fork()).ldelim();
    }
    if (message.cheerState !== undefined) {
      CMsgCheerState.encode(message.cheerState, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgServerToGCReportCheerState {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgServerToGCReportCheerState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.cheerConfig = CMsgCheerConfig.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.cheerState = CMsgCheerState.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgServerToGCReportCheerState {
    return {
      cheerConfig: isSet(object.cheerConfig) ? CMsgCheerConfig.fromJSON(object.cheerConfig) : undefined,
      cheerState: isSet(object.cheerState) ? CMsgCheerState.fromJSON(object.cheerState) : undefined,
    };
  },

  toJSON(message: CMsgServerToGCReportCheerState): unknown {
    const obj: any = {};
    if (message.cheerConfig !== undefined) {
      obj.cheerConfig = CMsgCheerConfig.toJSON(message.cheerConfig);
    }
    if (message.cheerState !== undefined) {
      obj.cheerState = CMsgCheerState.toJSON(message.cheerState);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgServerToGCReportCheerState>): CMsgServerToGCReportCheerState {
    return CMsgServerToGCReportCheerState.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgServerToGCReportCheerState>): CMsgServerToGCReportCheerState {
    const message = createBaseCMsgServerToGCReportCheerState();
    message.cheerConfig = (object.cheerConfig !== undefined && object.cheerConfig !== null)
      ? CMsgCheerConfig.fromPartial(object.cheerConfig)
      : undefined;
    message.cheerState = (object.cheerState !== undefined && object.cheerState !== null)
      ? CMsgCheerState.fromPartial(object.cheerState)
      : undefined;
    return message;
  },
};

function createBaseCMsgServerToGCGetStickerHeroes(): CMsgServerToGCGetStickerHeroes {
  return { accountIds: [] };
}

export const CMsgServerToGCGetStickerHeroes = {
  encode(message: CMsgServerToGCGetStickerHeroes, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.accountIds) {
      writer.uint32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgServerToGCGetStickerHeroes {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgServerToGCGetStickerHeroes();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.accountIds.push(reader.uint32());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.accountIds.push(reader.uint32());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgServerToGCGetStickerHeroes {
    return {
      accountIds: globalThis.Array.isArray(object?.accountIds)
        ? object.accountIds.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: CMsgServerToGCGetStickerHeroes): unknown {
    const obj: any = {};
    if (message.accountIds?.length) {
      obj.accountIds = message.accountIds.map((e) => Math.round(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgServerToGCGetStickerHeroes>): CMsgServerToGCGetStickerHeroes {
    return CMsgServerToGCGetStickerHeroes.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgServerToGCGetStickerHeroes>): CMsgServerToGCGetStickerHeroes {
    const message = createBaseCMsgServerToGCGetStickerHeroes();
    message.accountIds = object.accountIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseCMsgServerToGCGetStickerHeroesResponse(): CMsgServerToGCGetStickerHeroesResponse {
  return { players: [] };
}

export const CMsgServerToGCGetStickerHeroesResponse = {
  encode(message: CMsgServerToGCGetStickerHeroesResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.players) {
      CMsgServerToGCGetStickerHeroesResponse_Player.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgServerToGCGetStickerHeroesResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgServerToGCGetStickerHeroesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.players.push(CMsgServerToGCGetStickerHeroesResponse_Player.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgServerToGCGetStickerHeroesResponse {
    return {
      players: globalThis.Array.isArray(object?.players)
        ? object.players.map((e: any) => CMsgServerToGCGetStickerHeroesResponse_Player.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgServerToGCGetStickerHeroesResponse): unknown {
    const obj: any = {};
    if (message.players?.length) {
      obj.players = message.players.map((e) => CMsgServerToGCGetStickerHeroesResponse_Player.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgServerToGCGetStickerHeroesResponse>): CMsgServerToGCGetStickerHeroesResponse {
    return CMsgServerToGCGetStickerHeroesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgServerToGCGetStickerHeroesResponse>): CMsgServerToGCGetStickerHeroesResponse {
    const message = createBaseCMsgServerToGCGetStickerHeroesResponse();
    message.players = object.players?.map((e) => CMsgServerToGCGetStickerHeroesResponse_Player.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgServerToGCGetStickerHeroesResponse_Player(): CMsgServerToGCGetStickerHeroesResponse_Player {
  return { accountId: 0, stickers: undefined };
}

export const CMsgServerToGCGetStickerHeroesResponse_Player = {
  encode(message: CMsgServerToGCGetStickerHeroesResponse_Player, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.accountId !== undefined && message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    if (message.stickers !== undefined) {
      CMsgStickerHeroes.encode(message.stickers, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgServerToGCGetStickerHeroesResponse_Player {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgServerToGCGetStickerHeroesResponse_Player();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.stickers = CMsgStickerHeroes.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgServerToGCGetStickerHeroesResponse_Player {
    return {
      accountId: isSet(object.accountId) ? globalThis.Number(object.accountId) : 0,
      stickers: isSet(object.stickers) ? CMsgStickerHeroes.fromJSON(object.stickers) : undefined,
    };
  },

  toJSON(message: CMsgServerToGCGetStickerHeroesResponse_Player): unknown {
    const obj: any = {};
    if (message.accountId !== undefined && message.accountId !== 0) {
      obj.accountId = Math.round(message.accountId);
    }
    if (message.stickers !== undefined) {
      obj.stickers = CMsgStickerHeroes.toJSON(message.stickers);
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgServerToGCGetStickerHeroesResponse_Player>,
  ): CMsgServerToGCGetStickerHeroesResponse_Player {
    return CMsgServerToGCGetStickerHeroesResponse_Player.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgServerToGCGetStickerHeroesResponse_Player>,
  ): CMsgServerToGCGetStickerHeroesResponse_Player {
    const message = createBaseCMsgServerToGCGetStickerHeroesResponse_Player();
    message.accountId = object.accountId ?? 0;
    message.stickers = (object.stickers !== undefined && object.stickers !== null)
      ? CMsgStickerHeroes.fromPartial(object.stickers)
      : undefined;
    return message;
  },
};

function createBaseCMsgSteamLearnMatchInfo(): CMsgSteamLearnMatchInfo {
  return { averageMmr: 0, radiantWon: false, duration: 0, gameMode: 0, lobbyType: 0 };
}

export const CMsgSteamLearnMatchInfo = {
  encode(message: CMsgSteamLearnMatchInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.averageMmr !== undefined && message.averageMmr !== 0) {
      writer.uint32(8).uint32(message.averageMmr);
    }
    if (message.radiantWon !== undefined && message.radiantWon !== false) {
      writer.uint32(16).bool(message.radiantWon);
    }
    if (message.duration !== undefined && message.duration !== 0) {
      writer.uint32(24).uint32(message.duration);
    }
    if (message.gameMode !== undefined && message.gameMode !== 0) {
      writer.uint32(32).uint32(message.gameMode);
    }
    if (message.lobbyType !== undefined && message.lobbyType !== 0) {
      writer.uint32(40).uint32(message.lobbyType);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSteamLearnMatchInfo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSteamLearnMatchInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.averageMmr = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.radiantWon = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.duration = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.gameMode = reader.uint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.lobbyType = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSteamLearnMatchInfo {
    return {
      averageMmr: isSet(object.averageMmr) ? globalThis.Number(object.averageMmr) : 0,
      radiantWon: isSet(object.radiantWon) ? globalThis.Boolean(object.radiantWon) : false,
      duration: isSet(object.duration) ? globalThis.Number(object.duration) : 0,
      gameMode: isSet(object.gameMode) ? globalThis.Number(object.gameMode) : 0,
      lobbyType: isSet(object.lobbyType) ? globalThis.Number(object.lobbyType) : 0,
    };
  },

  toJSON(message: CMsgSteamLearnMatchInfo): unknown {
    const obj: any = {};
    if (message.averageMmr !== undefined && message.averageMmr !== 0) {
      obj.averageMmr = Math.round(message.averageMmr);
    }
    if (message.radiantWon !== undefined && message.radiantWon !== false) {
      obj.radiantWon = message.radiantWon;
    }
    if (message.duration !== undefined && message.duration !== 0) {
      obj.duration = Math.round(message.duration);
    }
    if (message.gameMode !== undefined && message.gameMode !== 0) {
      obj.gameMode = Math.round(message.gameMode);
    }
    if (message.lobbyType !== undefined && message.lobbyType !== 0) {
      obj.lobbyType = Math.round(message.lobbyType);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSteamLearnMatchInfo>): CMsgSteamLearnMatchInfo {
    return CMsgSteamLearnMatchInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSteamLearnMatchInfo>): CMsgSteamLearnMatchInfo {
    const message = createBaseCMsgSteamLearnMatchInfo();
    message.averageMmr = object.averageMmr ?? 0;
    message.radiantWon = object.radiantWon ?? false;
    message.duration = object.duration ?? 0;
    message.gameMode = object.gameMode ?? 0;
    message.lobbyType = object.lobbyType ?? 0;
    return message;
  },
};

function createBaseCMsgSteamLearnMatchInfoPlayer(): CMsgSteamLearnMatchInfoPlayer {
  return { averageMmr: 0, teamWon: false, duration: 0, gameMode: 0, lobbyType: 0, playerMmr: 0 };
}

export const CMsgSteamLearnMatchInfoPlayer = {
  encode(message: CMsgSteamLearnMatchInfoPlayer, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.averageMmr !== undefined && message.averageMmr !== 0) {
      writer.uint32(8).uint32(message.averageMmr);
    }
    if (message.teamWon !== undefined && message.teamWon !== false) {
      writer.uint32(16).bool(message.teamWon);
    }
    if (message.duration !== undefined && message.duration !== 0) {
      writer.uint32(24).uint32(message.duration);
    }
    if (message.gameMode !== undefined && message.gameMode !== 0) {
      writer.uint32(32).uint32(message.gameMode);
    }
    if (message.lobbyType !== undefined && message.lobbyType !== 0) {
      writer.uint32(40).uint32(message.lobbyType);
    }
    if (message.playerMmr !== undefined && message.playerMmr !== 0) {
      writer.uint32(48).uint32(message.playerMmr);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSteamLearnMatchInfoPlayer {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSteamLearnMatchInfoPlayer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.averageMmr = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.teamWon = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.duration = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.gameMode = reader.uint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.lobbyType = reader.uint32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.playerMmr = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSteamLearnMatchInfoPlayer {
    return {
      averageMmr: isSet(object.averageMmr) ? globalThis.Number(object.averageMmr) : 0,
      teamWon: isSet(object.teamWon) ? globalThis.Boolean(object.teamWon) : false,
      duration: isSet(object.duration) ? globalThis.Number(object.duration) : 0,
      gameMode: isSet(object.gameMode) ? globalThis.Number(object.gameMode) : 0,
      lobbyType: isSet(object.lobbyType) ? globalThis.Number(object.lobbyType) : 0,
      playerMmr: isSet(object.playerMmr) ? globalThis.Number(object.playerMmr) : 0,
    };
  },

  toJSON(message: CMsgSteamLearnMatchInfoPlayer): unknown {
    const obj: any = {};
    if (message.averageMmr !== undefined && message.averageMmr !== 0) {
      obj.averageMmr = Math.round(message.averageMmr);
    }
    if (message.teamWon !== undefined && message.teamWon !== false) {
      obj.teamWon = message.teamWon;
    }
    if (message.duration !== undefined && message.duration !== 0) {
      obj.duration = Math.round(message.duration);
    }
    if (message.gameMode !== undefined && message.gameMode !== 0) {
      obj.gameMode = Math.round(message.gameMode);
    }
    if (message.lobbyType !== undefined && message.lobbyType !== 0) {
      obj.lobbyType = Math.round(message.lobbyType);
    }
    if (message.playerMmr !== undefined && message.playerMmr !== 0) {
      obj.playerMmr = Math.round(message.playerMmr);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSteamLearnMatchInfoPlayer>): CMsgSteamLearnMatchInfoPlayer {
    return CMsgSteamLearnMatchInfoPlayer.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSteamLearnMatchInfoPlayer>): CMsgSteamLearnMatchInfoPlayer {
    const message = createBaseCMsgSteamLearnMatchInfoPlayer();
    message.averageMmr = object.averageMmr ?? 0;
    message.teamWon = object.teamWon ?? false;
    message.duration = object.duration ?? 0;
    message.gameMode = object.gameMode ?? 0;
    message.lobbyType = object.lobbyType ?? 0;
    message.playerMmr = object.playerMmr ?? 0;
    return message;
  },
};

function createBaseCMsgSteamLearnMatchInfoTeam(): CMsgSteamLearnMatchInfoTeam {
  return { radiantPlayers: [], direPlayers: [], radiantTeamWon: false };
}

export const CMsgSteamLearnMatchInfoTeam = {
  encode(message: CMsgSteamLearnMatchInfoTeam, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.radiantPlayers) {
      CMsgSteamLearnMatchInfoTeam_Player.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.direPlayers) {
      CMsgSteamLearnMatchInfoTeam_Player.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.radiantTeamWon !== undefined && message.radiantTeamWon !== false) {
      writer.uint32(24).bool(message.radiantTeamWon);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSteamLearnMatchInfoTeam {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSteamLearnMatchInfoTeam();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.radiantPlayers.push(CMsgSteamLearnMatchInfoTeam_Player.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.direPlayers.push(CMsgSteamLearnMatchInfoTeam_Player.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.radiantTeamWon = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSteamLearnMatchInfoTeam {
    return {
      radiantPlayers: globalThis.Array.isArray(object?.radiantPlayers)
        ? object.radiantPlayers.map((e: any) => CMsgSteamLearnMatchInfoTeam_Player.fromJSON(e))
        : [],
      direPlayers: globalThis.Array.isArray(object?.direPlayers)
        ? object.direPlayers.map((e: any) => CMsgSteamLearnMatchInfoTeam_Player.fromJSON(e))
        : [],
      radiantTeamWon: isSet(object.radiantTeamWon) ? globalThis.Boolean(object.radiantTeamWon) : false,
    };
  },

  toJSON(message: CMsgSteamLearnMatchInfoTeam): unknown {
    const obj: any = {};
    if (message.radiantPlayers?.length) {
      obj.radiantPlayers = message.radiantPlayers.map((e) => CMsgSteamLearnMatchInfoTeam_Player.toJSON(e));
    }
    if (message.direPlayers?.length) {
      obj.direPlayers = message.direPlayers.map((e) => CMsgSteamLearnMatchInfoTeam_Player.toJSON(e));
    }
    if (message.radiantTeamWon !== undefined && message.radiantTeamWon !== false) {
      obj.radiantTeamWon = message.radiantTeamWon;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSteamLearnMatchInfoTeam>): CMsgSteamLearnMatchInfoTeam {
    return CMsgSteamLearnMatchInfoTeam.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSteamLearnMatchInfoTeam>): CMsgSteamLearnMatchInfoTeam {
    const message = createBaseCMsgSteamLearnMatchInfoTeam();
    message.radiantPlayers = object.radiantPlayers?.map((e) => CMsgSteamLearnMatchInfoTeam_Player.fromPartial(e)) || [];
    message.direPlayers = object.direPlayers?.map((e) => CMsgSteamLearnMatchInfoTeam_Player.fromPartial(e)) || [];
    message.radiantTeamWon = object.radiantTeamWon ?? false;
    return message;
  },
};

function createBaseCMsgSteamLearnMatchInfoTeam_Player(): CMsgSteamLearnMatchInfoTeam_Player {
  return {
    prematchMmr: 0,
    prematchRankUncertainty: 0,
    prematchBehaviorScore: 0,
    prematchCommScore: 0,
    numPlayersInParty: 0,
  };
}

export const CMsgSteamLearnMatchInfoTeam_Player = {
  encode(message: CMsgSteamLearnMatchInfoTeam_Player, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.prematchMmr !== undefined && message.prematchMmr !== 0) {
      writer.uint32(8).uint32(message.prematchMmr);
    }
    if (message.prematchRankUncertainty !== undefined && message.prematchRankUncertainty !== 0) {
      writer.uint32(16).uint32(message.prematchRankUncertainty);
    }
    if (message.prematchBehaviorScore !== undefined && message.prematchBehaviorScore !== 0) {
      writer.uint32(24).uint32(message.prematchBehaviorScore);
    }
    if (message.prematchCommScore !== undefined && message.prematchCommScore !== 0) {
      writer.uint32(32).uint32(message.prematchCommScore);
    }
    if (message.numPlayersInParty !== undefined && message.numPlayersInParty !== 0) {
      writer.uint32(40).uint32(message.numPlayersInParty);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSteamLearnMatchInfoTeam_Player {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSteamLearnMatchInfoTeam_Player();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.prematchMmr = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.prematchRankUncertainty = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.prematchBehaviorScore = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.prematchCommScore = reader.uint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.numPlayersInParty = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSteamLearnMatchInfoTeam_Player {
    return {
      prematchMmr: isSet(object.prematchMmr) ? globalThis.Number(object.prematchMmr) : 0,
      prematchRankUncertainty: isSet(object.prematchRankUncertainty)
        ? globalThis.Number(object.prematchRankUncertainty)
        : 0,
      prematchBehaviorScore: isSet(object.prematchBehaviorScore) ? globalThis.Number(object.prematchBehaviorScore) : 0,
      prematchCommScore: isSet(object.prematchCommScore) ? globalThis.Number(object.prematchCommScore) : 0,
      numPlayersInParty: isSet(object.numPlayersInParty) ? globalThis.Number(object.numPlayersInParty) : 0,
    };
  },

  toJSON(message: CMsgSteamLearnMatchInfoTeam_Player): unknown {
    const obj: any = {};
    if (message.prematchMmr !== undefined && message.prematchMmr !== 0) {
      obj.prematchMmr = Math.round(message.prematchMmr);
    }
    if (message.prematchRankUncertainty !== undefined && message.prematchRankUncertainty !== 0) {
      obj.prematchRankUncertainty = Math.round(message.prematchRankUncertainty);
    }
    if (message.prematchBehaviorScore !== undefined && message.prematchBehaviorScore !== 0) {
      obj.prematchBehaviorScore = Math.round(message.prematchBehaviorScore);
    }
    if (message.prematchCommScore !== undefined && message.prematchCommScore !== 0) {
      obj.prematchCommScore = Math.round(message.prematchCommScore);
    }
    if (message.numPlayersInParty !== undefined && message.numPlayersInParty !== 0) {
      obj.numPlayersInParty = Math.round(message.numPlayersInParty);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSteamLearnMatchInfoTeam_Player>): CMsgSteamLearnMatchInfoTeam_Player {
    return CMsgSteamLearnMatchInfoTeam_Player.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSteamLearnMatchInfoTeam_Player>): CMsgSteamLearnMatchInfoTeam_Player {
    const message = createBaseCMsgSteamLearnMatchInfoTeam_Player();
    message.prematchMmr = object.prematchMmr ?? 0;
    message.prematchRankUncertainty = object.prematchRankUncertainty ?? 0;
    message.prematchBehaviorScore = object.prematchBehaviorScore ?? 0;
    message.prematchCommScore = object.prematchCommScore ?? 0;
    message.numPlayersInParty = object.numPlayersInParty ?? 0;
    return message;
  },
};

function createBaseCMsgSteamLearnMatchHeroesV3(): CMsgSteamLearnMatchHeroesV3 {
  return {
    radiantHeroIds: [],
    direHeroIds: [],
    radiantLanes: [],
    direLanes: [],
    radiantHeroFacets: [],
    direHeroFacets: [],
    radiantPositions: [],
    direPositions: [],
  };
}

export const CMsgSteamLearnMatchHeroesV3 = {
  encode(message: CMsgSteamLearnMatchHeroesV3, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.radiantHeroIds) {
      writer.int32(v);
    }
    writer.ldelim();
    writer.uint32(18).fork();
    for (const v of message.direHeroIds) {
      writer.int32(v);
    }
    writer.ldelim();
    writer.uint32(26).fork();
    for (const v of message.radiantLanes) {
      writer.uint32(v);
    }
    writer.ldelim();
    writer.uint32(34).fork();
    for (const v of message.direLanes) {
      writer.uint32(v);
    }
    writer.ldelim();
    writer.uint32(42).fork();
    for (const v of message.radiantHeroFacets) {
      writer.uint32(v);
    }
    writer.ldelim();
    writer.uint32(50).fork();
    for (const v of message.direHeroFacets) {
      writer.uint32(v);
    }
    writer.ldelim();
    writer.uint32(58).fork();
    for (const v of message.radiantPositions) {
      writer.uint32(v);
    }
    writer.ldelim();
    writer.uint32(66).fork();
    for (const v of message.direPositions) {
      writer.uint32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSteamLearnMatchHeroesV3 {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSteamLearnMatchHeroesV3();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.radiantHeroIds.push(reader.int32());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.radiantHeroIds.push(reader.int32());
            }

            continue;
          }

          break;
        case 2:
          if (tag === 16) {
            message.direHeroIds.push(reader.int32());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.direHeroIds.push(reader.int32());
            }

            continue;
          }

          break;
        case 3:
          if (tag === 24) {
            message.radiantLanes.push(reader.uint32());

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.radiantLanes.push(reader.uint32());
            }

            continue;
          }

          break;
        case 4:
          if (tag === 32) {
            message.direLanes.push(reader.uint32());

            continue;
          }

          if (tag === 34) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.direLanes.push(reader.uint32());
            }

            continue;
          }

          break;
        case 5:
          if (tag === 40) {
            message.radiantHeroFacets.push(reader.uint32());

            continue;
          }

          if (tag === 42) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.radiantHeroFacets.push(reader.uint32());
            }

            continue;
          }

          break;
        case 6:
          if (tag === 48) {
            message.direHeroFacets.push(reader.uint32());

            continue;
          }

          if (tag === 50) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.direHeroFacets.push(reader.uint32());
            }

            continue;
          }

          break;
        case 7:
          if (tag === 56) {
            message.radiantPositions.push(reader.uint32());

            continue;
          }

          if (tag === 58) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.radiantPositions.push(reader.uint32());
            }

            continue;
          }

          break;
        case 8:
          if (tag === 64) {
            message.direPositions.push(reader.uint32());

            continue;
          }

          if (tag === 66) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.direPositions.push(reader.uint32());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSteamLearnMatchHeroesV3 {
    return {
      radiantHeroIds: globalThis.Array.isArray(object?.radiantHeroIds)
        ? object.radiantHeroIds.map((e: any) => globalThis.Number(e))
        : [],
      direHeroIds: globalThis.Array.isArray(object?.direHeroIds)
        ? object.direHeroIds.map((e: any) => globalThis.Number(e))
        : [],
      radiantLanes: globalThis.Array.isArray(object?.radiantLanes)
        ? object.radiantLanes.map((e: any) => globalThis.Number(e))
        : [],
      direLanes: globalThis.Array.isArray(object?.direLanes)
        ? object.direLanes.map((e: any) => globalThis.Number(e))
        : [],
      radiantHeroFacets: globalThis.Array.isArray(object?.radiantHeroFacets)
        ? object.radiantHeroFacets.map((e: any) => globalThis.Number(e))
        : [],
      direHeroFacets: globalThis.Array.isArray(object?.direHeroFacets)
        ? object.direHeroFacets.map((e: any) => globalThis.Number(e))
        : [],
      radiantPositions: globalThis.Array.isArray(object?.radiantPositions)
        ? object.radiantPositions.map((e: any) => globalThis.Number(e))
        : [],
      direPositions: globalThis.Array.isArray(object?.direPositions)
        ? object.direPositions.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: CMsgSteamLearnMatchHeroesV3): unknown {
    const obj: any = {};
    if (message.radiantHeroIds?.length) {
      obj.radiantHeroIds = message.radiantHeroIds.map((e) => Math.round(e));
    }
    if (message.direHeroIds?.length) {
      obj.direHeroIds = message.direHeroIds.map((e) => Math.round(e));
    }
    if (message.radiantLanes?.length) {
      obj.radiantLanes = message.radiantLanes.map((e) => Math.round(e));
    }
    if (message.direLanes?.length) {
      obj.direLanes = message.direLanes.map((e) => Math.round(e));
    }
    if (message.radiantHeroFacets?.length) {
      obj.radiantHeroFacets = message.radiantHeroFacets.map((e) => Math.round(e));
    }
    if (message.direHeroFacets?.length) {
      obj.direHeroFacets = message.direHeroFacets.map((e) => Math.round(e));
    }
    if (message.radiantPositions?.length) {
      obj.radiantPositions = message.radiantPositions.map((e) => Math.round(e));
    }
    if (message.direPositions?.length) {
      obj.direPositions = message.direPositions.map((e) => Math.round(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSteamLearnMatchHeroesV3>): CMsgSteamLearnMatchHeroesV3 {
    return CMsgSteamLearnMatchHeroesV3.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSteamLearnMatchHeroesV3>): CMsgSteamLearnMatchHeroesV3 {
    const message = createBaseCMsgSteamLearnMatchHeroesV3();
    message.radiantHeroIds = object.radiantHeroIds?.map((e) => e) || [];
    message.direHeroIds = object.direHeroIds?.map((e) => e) || [];
    message.radiantLanes = object.radiantLanes?.map((e) => e) || [];
    message.direLanes = object.direLanes?.map((e) => e) || [];
    message.radiantHeroFacets = object.radiantHeroFacets?.map((e) => e) || [];
    message.direHeroFacets = object.direHeroFacets?.map((e) => e) || [];
    message.radiantPositions = object.radiantPositions?.map((e) => e) || [];
    message.direPositions = object.direPositions?.map((e) => e) || [];
    return message;
  },
};

function createBaseCMsgSteamLearnMatchHeroV3(): CMsgSteamLearnMatchHeroV3 {
  return {
    heroId: 0,
    lane: 0,
    position: 0,
    alliedHeroIds: [],
    enemyHeroIds: [],
    heroFacet: 0,
    alliedHeroFacets: [],
    enemyHerofacets: [],
  };
}

export const CMsgSteamLearnMatchHeroV3 = {
  encode(message: CMsgSteamLearnMatchHeroV3, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.heroId !== undefined && message.heroId !== 0) {
      writer.uint32(8).int32(message.heroId);
    }
    if (message.lane !== undefined && message.lane !== 0) {
      writer.uint32(16).uint32(message.lane);
    }
    if (message.position !== undefined && message.position !== 0) {
      writer.uint32(64).uint32(message.position);
    }
    writer.uint32(26).fork();
    for (const v of message.alliedHeroIds) {
      writer.int32(v);
    }
    writer.ldelim();
    writer.uint32(34).fork();
    for (const v of message.enemyHeroIds) {
      writer.int32(v);
    }
    writer.ldelim();
    if (message.heroFacet !== undefined && message.heroFacet !== 0) {
      writer.uint32(40).uint32(message.heroFacet);
    }
    writer.uint32(50).fork();
    for (const v of message.alliedHeroFacets) {
      writer.uint32(v);
    }
    writer.ldelim();
    writer.uint32(58).fork();
    for (const v of message.enemyHerofacets) {
      writer.uint32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSteamLearnMatchHeroV3 {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSteamLearnMatchHeroV3();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.heroId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.lane = reader.uint32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.position = reader.uint32();
          continue;
        case 3:
          if (tag === 24) {
            message.alliedHeroIds.push(reader.int32());

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.alliedHeroIds.push(reader.int32());
            }

            continue;
          }

          break;
        case 4:
          if (tag === 32) {
            message.enemyHeroIds.push(reader.int32());

            continue;
          }

          if (tag === 34) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.enemyHeroIds.push(reader.int32());
            }

            continue;
          }

          break;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.heroFacet = reader.uint32();
          continue;
        case 6:
          if (tag === 48) {
            message.alliedHeroFacets.push(reader.uint32());

            continue;
          }

          if (tag === 50) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.alliedHeroFacets.push(reader.uint32());
            }

            continue;
          }

          break;
        case 7:
          if (tag === 56) {
            message.enemyHerofacets.push(reader.uint32());

            continue;
          }

          if (tag === 58) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.enemyHerofacets.push(reader.uint32());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSteamLearnMatchHeroV3 {
    return {
      heroId: isSet(object.heroId) ? globalThis.Number(object.heroId) : 0,
      lane: isSet(object.lane) ? globalThis.Number(object.lane) : 0,
      position: isSet(object.position) ? globalThis.Number(object.position) : 0,
      alliedHeroIds: globalThis.Array.isArray(object?.alliedHeroIds)
        ? object.alliedHeroIds.map((e: any) => globalThis.Number(e))
        : [],
      enemyHeroIds: globalThis.Array.isArray(object?.enemyHeroIds)
        ? object.enemyHeroIds.map((e: any) => globalThis.Number(e))
        : [],
      heroFacet: isSet(object.heroFacet) ? globalThis.Number(object.heroFacet) : 0,
      alliedHeroFacets: globalThis.Array.isArray(object?.alliedHeroFacets)
        ? object.alliedHeroFacets.map((e: any) => globalThis.Number(e))
        : [],
      enemyHerofacets: globalThis.Array.isArray(object?.enemyHerofacets)
        ? object.enemyHerofacets.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: CMsgSteamLearnMatchHeroV3): unknown {
    const obj: any = {};
    if (message.heroId !== undefined && message.heroId !== 0) {
      obj.heroId = Math.round(message.heroId);
    }
    if (message.lane !== undefined && message.lane !== 0) {
      obj.lane = Math.round(message.lane);
    }
    if (message.position !== undefined && message.position !== 0) {
      obj.position = Math.round(message.position);
    }
    if (message.alliedHeroIds?.length) {
      obj.alliedHeroIds = message.alliedHeroIds.map((e) => Math.round(e));
    }
    if (message.enemyHeroIds?.length) {
      obj.enemyHeroIds = message.enemyHeroIds.map((e) => Math.round(e));
    }
    if (message.heroFacet !== undefined && message.heroFacet !== 0) {
      obj.heroFacet = Math.round(message.heroFacet);
    }
    if (message.alliedHeroFacets?.length) {
      obj.alliedHeroFacets = message.alliedHeroFacets.map((e) => Math.round(e));
    }
    if (message.enemyHerofacets?.length) {
      obj.enemyHerofacets = message.enemyHerofacets.map((e) => Math.round(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSteamLearnMatchHeroV3>): CMsgSteamLearnMatchHeroV3 {
    return CMsgSteamLearnMatchHeroV3.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSteamLearnMatchHeroV3>): CMsgSteamLearnMatchHeroV3 {
    const message = createBaseCMsgSteamLearnMatchHeroV3();
    message.heroId = object.heroId ?? 0;
    message.lane = object.lane ?? 0;
    message.position = object.position ?? 0;
    message.alliedHeroIds = object.alliedHeroIds?.map((e) => e) || [];
    message.enemyHeroIds = object.enemyHeroIds?.map((e) => e) || [];
    message.heroFacet = object.heroFacet ?? 0;
    message.alliedHeroFacets = object.alliedHeroFacets?.map((e) => e) || [];
    message.enemyHerofacets = object.enemyHerofacets?.map((e) => e) || [];
    return message;
  },
};

function createBaseCMsgSteamLearnPlayerTimedStats(): CMsgSteamLearnPlayerTimedStats {
  return { statBuckets: [] };
}

export const CMsgSteamLearnPlayerTimedStats = {
  encode(message: CMsgSteamLearnPlayerTimedStats, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.statBuckets) {
      CMsgSteamLearnPlayerTimedStats_StatBucket.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSteamLearnPlayerTimedStats {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSteamLearnPlayerTimedStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.statBuckets.push(CMsgSteamLearnPlayerTimedStats_StatBucket.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSteamLearnPlayerTimedStats {
    return {
      statBuckets: globalThis.Array.isArray(object?.statBuckets)
        ? object.statBuckets.map((e: any) => CMsgSteamLearnPlayerTimedStats_StatBucket.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgSteamLearnPlayerTimedStats): unknown {
    const obj: any = {};
    if (message.statBuckets?.length) {
      obj.statBuckets = message.statBuckets.map((e) => CMsgSteamLearnPlayerTimedStats_StatBucket.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSteamLearnPlayerTimedStats>): CMsgSteamLearnPlayerTimedStats {
    return CMsgSteamLearnPlayerTimedStats.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSteamLearnPlayerTimedStats>): CMsgSteamLearnPlayerTimedStats {
    const message = createBaseCMsgSteamLearnPlayerTimedStats();
    message.statBuckets = object.statBuckets?.map((e) => CMsgSteamLearnPlayerTimedStats_StatBucket.fromPartial(e)) ||
      [];
    return message;
  },
};

function createBaseCMsgSteamLearnPlayerTimedStats_StatBucket(): CMsgSteamLearnPlayerTimedStats_StatBucket {
  return {
    gameTime: 0,
    kills: 0,
    deaths: 0,
    assists: 0,
    experience: 0,
    lastHits: 0,
    denies: 0,
    netWorth: 0,
    idleTime: 0,
    commandsIssued: 0,
    sentryWardsPlaced: 0,
    observerWardsPlaced: 0,
  };
}

export const CMsgSteamLearnPlayerTimedStats_StatBucket = {
  encode(message: CMsgSteamLearnPlayerTimedStats_StatBucket, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.gameTime !== undefined && message.gameTime !== 0) {
      writer.uint32(13).float(message.gameTime);
    }
    if (message.kills !== undefined && message.kills !== 0) {
      writer.uint32(16).uint32(message.kills);
    }
    if (message.deaths !== undefined && message.deaths !== 0) {
      writer.uint32(24).uint32(message.deaths);
    }
    if (message.assists !== undefined && message.assists !== 0) {
      writer.uint32(32).uint32(message.assists);
    }
    if (message.experience !== undefined && message.experience !== 0) {
      writer.uint32(40).uint32(message.experience);
    }
    if (message.lastHits !== undefined && message.lastHits !== 0) {
      writer.uint32(48).uint32(message.lastHits);
    }
    if (message.denies !== undefined && message.denies !== 0) {
      writer.uint32(56).uint32(message.denies);
    }
    if (message.netWorth !== undefined && message.netWorth !== 0) {
      writer.uint32(64).uint32(message.netWorth);
    }
    if (message.idleTime !== undefined && message.idleTime !== 0) {
      writer.uint32(77).float(message.idleTime);
    }
    if (message.commandsIssued !== undefined && message.commandsIssued !== 0) {
      writer.uint32(80).uint32(message.commandsIssued);
    }
    if (message.sentryWardsPlaced !== undefined && message.sentryWardsPlaced !== 0) {
      writer.uint32(88).uint32(message.sentryWardsPlaced);
    }
    if (message.observerWardsPlaced !== undefined && message.observerWardsPlaced !== 0) {
      writer.uint32(96).uint32(message.observerWardsPlaced);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSteamLearnPlayerTimedStats_StatBucket {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSteamLearnPlayerTimedStats_StatBucket();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.gameTime = reader.float();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.kills = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.deaths = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.assists = reader.uint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.experience = reader.uint32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.lastHits = reader.uint32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.denies = reader.uint32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.netWorth = reader.uint32();
          continue;
        case 9:
          if (tag !== 77) {
            break;
          }

          message.idleTime = reader.float();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.commandsIssued = reader.uint32();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.sentryWardsPlaced = reader.uint32();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.observerWardsPlaced = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSteamLearnPlayerTimedStats_StatBucket {
    return {
      gameTime: isSet(object.gameTime) ? globalThis.Number(object.gameTime) : 0,
      kills: isSet(object.kills) ? globalThis.Number(object.kills) : 0,
      deaths: isSet(object.deaths) ? globalThis.Number(object.deaths) : 0,
      assists: isSet(object.assists) ? globalThis.Number(object.assists) : 0,
      experience: isSet(object.experience) ? globalThis.Number(object.experience) : 0,
      lastHits: isSet(object.lastHits) ? globalThis.Number(object.lastHits) : 0,
      denies: isSet(object.denies) ? globalThis.Number(object.denies) : 0,
      netWorth: isSet(object.netWorth) ? globalThis.Number(object.netWorth) : 0,
      idleTime: isSet(object.idleTime) ? globalThis.Number(object.idleTime) : 0,
      commandsIssued: isSet(object.commandsIssued) ? globalThis.Number(object.commandsIssued) : 0,
      sentryWardsPlaced: isSet(object.sentryWardsPlaced) ? globalThis.Number(object.sentryWardsPlaced) : 0,
      observerWardsPlaced: isSet(object.observerWardsPlaced) ? globalThis.Number(object.observerWardsPlaced) : 0,
    };
  },

  toJSON(message: CMsgSteamLearnPlayerTimedStats_StatBucket): unknown {
    const obj: any = {};
    if (message.gameTime !== undefined && message.gameTime !== 0) {
      obj.gameTime = message.gameTime;
    }
    if (message.kills !== undefined && message.kills !== 0) {
      obj.kills = Math.round(message.kills);
    }
    if (message.deaths !== undefined && message.deaths !== 0) {
      obj.deaths = Math.round(message.deaths);
    }
    if (message.assists !== undefined && message.assists !== 0) {
      obj.assists = Math.round(message.assists);
    }
    if (message.experience !== undefined && message.experience !== 0) {
      obj.experience = Math.round(message.experience);
    }
    if (message.lastHits !== undefined && message.lastHits !== 0) {
      obj.lastHits = Math.round(message.lastHits);
    }
    if (message.denies !== undefined && message.denies !== 0) {
      obj.denies = Math.round(message.denies);
    }
    if (message.netWorth !== undefined && message.netWorth !== 0) {
      obj.netWorth = Math.round(message.netWorth);
    }
    if (message.idleTime !== undefined && message.idleTime !== 0) {
      obj.idleTime = message.idleTime;
    }
    if (message.commandsIssued !== undefined && message.commandsIssued !== 0) {
      obj.commandsIssued = Math.round(message.commandsIssued);
    }
    if (message.sentryWardsPlaced !== undefined && message.sentryWardsPlaced !== 0) {
      obj.sentryWardsPlaced = Math.round(message.sentryWardsPlaced);
    }
    if (message.observerWardsPlaced !== undefined && message.observerWardsPlaced !== 0) {
      obj.observerWardsPlaced = Math.round(message.observerWardsPlaced);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSteamLearnPlayerTimedStats_StatBucket>): CMsgSteamLearnPlayerTimedStats_StatBucket {
    return CMsgSteamLearnPlayerTimedStats_StatBucket.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgSteamLearnPlayerTimedStats_StatBucket>,
  ): CMsgSteamLearnPlayerTimedStats_StatBucket {
    const message = createBaseCMsgSteamLearnPlayerTimedStats_StatBucket();
    message.gameTime = object.gameTime ?? 0;
    message.kills = object.kills ?? 0;
    message.deaths = object.deaths ?? 0;
    message.assists = object.assists ?? 0;
    message.experience = object.experience ?? 0;
    message.lastHits = object.lastHits ?? 0;
    message.denies = object.denies ?? 0;
    message.netWorth = object.netWorth ?? 0;
    message.idleTime = object.idleTime ?? 0;
    message.commandsIssued = object.commandsIssued ?? 0;
    message.sentryWardsPlaced = object.sentryWardsPlaced ?? 0;
    message.observerWardsPlaced = object.observerWardsPlaced ?? 0;
    return message;
  },
};

function createBaseCMsgSteamLearnMatchStateV5(): CMsgSteamLearnMatchStateV5 {
  return { gameTime: 0, radiantState: undefined, direState: undefined };
}

export const CMsgSteamLearnMatchStateV5 = {
  encode(message: CMsgSteamLearnMatchStateV5, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.gameTime !== undefined && message.gameTime !== 0) {
      writer.uint32(13).float(message.gameTime);
    }
    if (message.radiantState !== undefined) {
      CMsgSteamLearnMatchStateV5_TeamState.encode(message.radiantState, writer.uint32(18).fork()).ldelim();
    }
    if (message.direState !== undefined) {
      CMsgSteamLearnMatchStateV5_TeamState.encode(message.direState, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSteamLearnMatchStateV5 {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSteamLearnMatchStateV5();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.gameTime = reader.float();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.radiantState = CMsgSteamLearnMatchStateV5_TeamState.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.direState = CMsgSteamLearnMatchStateV5_TeamState.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSteamLearnMatchStateV5 {
    return {
      gameTime: isSet(object.gameTime) ? globalThis.Number(object.gameTime) : 0,
      radiantState: isSet(object.radiantState)
        ? CMsgSteamLearnMatchStateV5_TeamState.fromJSON(object.radiantState)
        : undefined,
      direState: isSet(object.direState) ? CMsgSteamLearnMatchStateV5_TeamState.fromJSON(object.direState) : undefined,
    };
  },

  toJSON(message: CMsgSteamLearnMatchStateV5): unknown {
    const obj: any = {};
    if (message.gameTime !== undefined && message.gameTime !== 0) {
      obj.gameTime = message.gameTime;
    }
    if (message.radiantState !== undefined) {
      obj.radiantState = CMsgSteamLearnMatchStateV5_TeamState.toJSON(message.radiantState);
    }
    if (message.direState !== undefined) {
      obj.direState = CMsgSteamLearnMatchStateV5_TeamState.toJSON(message.direState);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSteamLearnMatchStateV5>): CMsgSteamLearnMatchStateV5 {
    return CMsgSteamLearnMatchStateV5.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSteamLearnMatchStateV5>): CMsgSteamLearnMatchStateV5 {
    const message = createBaseCMsgSteamLearnMatchStateV5();
    message.gameTime = object.gameTime ?? 0;
    message.radiantState = (object.radiantState !== undefined && object.radiantState !== null)
      ? CMsgSteamLearnMatchStateV5_TeamState.fromPartial(object.radiantState)
      : undefined;
    message.direState = (object.direState !== undefined && object.direState !== null)
      ? CMsgSteamLearnMatchStateV5_TeamState.fromPartial(object.direState)
      : undefined;
    return message;
  },
};

function createBaseCMsgSteamLearnMatchStateV5_PlayerState(): CMsgSteamLearnMatchStateV5_PlayerState {
  return {
    heroId: 0,
    netWorth: 0,
    level: 0,
    deaths: 0,
    respawnTime: 0,
    hasBuyback: false,
    hasAegis: false,
    hasRapier: false,
    distance: 0,
    heroFacet: 0,
  };
}

export const CMsgSteamLearnMatchStateV5_PlayerState = {
  encode(message: CMsgSteamLearnMatchStateV5_PlayerState, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.heroId !== undefined && message.heroId !== 0) {
      writer.uint32(8).int32(message.heroId);
    }
    if (message.netWorth !== undefined && message.netWorth !== 0) {
      writer.uint32(16).uint32(message.netWorth);
    }
    if (message.level !== undefined && message.level !== 0) {
      writer.uint32(24).uint32(message.level);
    }
    if (message.deaths !== undefined && message.deaths !== 0) {
      writer.uint32(32).uint32(message.deaths);
    }
    if (message.respawnTime !== undefined && message.respawnTime !== 0) {
      writer.uint32(40).uint32(message.respawnTime);
    }
    if (message.hasBuyback !== undefined && message.hasBuyback !== false) {
      writer.uint32(48).bool(message.hasBuyback);
    }
    if (message.hasAegis !== undefined && message.hasAegis !== false) {
      writer.uint32(56).bool(message.hasAegis);
    }
    if (message.hasRapier !== undefined && message.hasRapier !== false) {
      writer.uint32(64).bool(message.hasRapier);
    }
    if (message.distance !== undefined && message.distance !== 0) {
      writer.uint32(72).uint32(message.distance);
    }
    if (message.heroFacet !== undefined && message.heroFacet !== 0) {
      writer.uint32(80).uint32(message.heroFacet);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSteamLearnMatchStateV5_PlayerState {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSteamLearnMatchStateV5_PlayerState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.heroId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.netWorth = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.level = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.deaths = reader.uint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.respawnTime = reader.uint32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.hasBuyback = reader.bool();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.hasAegis = reader.bool();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.hasRapier = reader.bool();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.distance = reader.uint32();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.heroFacet = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSteamLearnMatchStateV5_PlayerState {
    return {
      heroId: isSet(object.heroId) ? globalThis.Number(object.heroId) : 0,
      netWorth: isSet(object.netWorth) ? globalThis.Number(object.netWorth) : 0,
      level: isSet(object.level) ? globalThis.Number(object.level) : 0,
      deaths: isSet(object.deaths) ? globalThis.Number(object.deaths) : 0,
      respawnTime: isSet(object.respawnTime) ? globalThis.Number(object.respawnTime) : 0,
      hasBuyback: isSet(object.hasBuyback) ? globalThis.Boolean(object.hasBuyback) : false,
      hasAegis: isSet(object.hasAegis) ? globalThis.Boolean(object.hasAegis) : false,
      hasRapier: isSet(object.hasRapier) ? globalThis.Boolean(object.hasRapier) : false,
      distance: isSet(object.distance) ? globalThis.Number(object.distance) : 0,
      heroFacet: isSet(object.heroFacet) ? globalThis.Number(object.heroFacet) : 0,
    };
  },

  toJSON(message: CMsgSteamLearnMatchStateV5_PlayerState): unknown {
    const obj: any = {};
    if (message.heroId !== undefined && message.heroId !== 0) {
      obj.heroId = Math.round(message.heroId);
    }
    if (message.netWorth !== undefined && message.netWorth !== 0) {
      obj.netWorth = Math.round(message.netWorth);
    }
    if (message.level !== undefined && message.level !== 0) {
      obj.level = Math.round(message.level);
    }
    if (message.deaths !== undefined && message.deaths !== 0) {
      obj.deaths = Math.round(message.deaths);
    }
    if (message.respawnTime !== undefined && message.respawnTime !== 0) {
      obj.respawnTime = Math.round(message.respawnTime);
    }
    if (message.hasBuyback !== undefined && message.hasBuyback !== false) {
      obj.hasBuyback = message.hasBuyback;
    }
    if (message.hasAegis !== undefined && message.hasAegis !== false) {
      obj.hasAegis = message.hasAegis;
    }
    if (message.hasRapier !== undefined && message.hasRapier !== false) {
      obj.hasRapier = message.hasRapier;
    }
    if (message.distance !== undefined && message.distance !== 0) {
      obj.distance = Math.round(message.distance);
    }
    if (message.heroFacet !== undefined && message.heroFacet !== 0) {
      obj.heroFacet = Math.round(message.heroFacet);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSteamLearnMatchStateV5_PlayerState>): CMsgSteamLearnMatchStateV5_PlayerState {
    return CMsgSteamLearnMatchStateV5_PlayerState.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSteamLearnMatchStateV5_PlayerState>): CMsgSteamLearnMatchStateV5_PlayerState {
    const message = createBaseCMsgSteamLearnMatchStateV5_PlayerState();
    message.heroId = object.heroId ?? 0;
    message.netWorth = object.netWorth ?? 0;
    message.level = object.level ?? 0;
    message.deaths = object.deaths ?? 0;
    message.respawnTime = object.respawnTime ?? 0;
    message.hasBuyback = object.hasBuyback ?? false;
    message.hasAegis = object.hasAegis ?? false;
    message.hasRapier = object.hasRapier ?? false;
    message.distance = object.distance ?? 0;
    message.heroFacet = object.heroFacet ?? 0;
    return message;
  },
};

function createBaseCMsgSteamLearnMatchStateV5_TeamState(): CMsgSteamLearnMatchStateV5_TeamState {
  return {
    team: 0,
    playerStates: [],
    towerHealthPct: [],
    barracksHealthPct: [],
    ancientHealthPct: 0,
    glyphCooldown: 0,
    kills: 0,
    creepDistanceSafe: 0,
    creepDistanceMid: 0,
    creepDistanceOff: 0,
  };
}

export const CMsgSteamLearnMatchStateV5_TeamState = {
  encode(message: CMsgSteamLearnMatchStateV5_TeamState, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.team !== undefined && message.team !== 0) {
      writer.uint32(8).uint32(message.team);
    }
    for (const v of message.playerStates) {
      CMsgSteamLearnMatchStateV5_PlayerState.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    writer.uint32(26).fork();
    for (const v of message.towerHealthPct) {
      writer.uint32(v);
    }
    writer.ldelim();
    writer.uint32(34).fork();
    for (const v of message.barracksHealthPct) {
      writer.uint32(v);
    }
    writer.ldelim();
    if (message.ancientHealthPct !== undefined && message.ancientHealthPct !== 0) {
      writer.uint32(40).uint32(message.ancientHealthPct);
    }
    if (message.glyphCooldown !== undefined && message.glyphCooldown !== 0) {
      writer.uint32(48).uint32(message.glyphCooldown);
    }
    if (message.kills !== undefined && message.kills !== 0) {
      writer.uint32(56).uint32(message.kills);
    }
    if (message.creepDistanceSafe !== undefined && message.creepDistanceSafe !== 0) {
      writer.uint32(64).uint32(message.creepDistanceSafe);
    }
    if (message.creepDistanceMid !== undefined && message.creepDistanceMid !== 0) {
      writer.uint32(72).uint32(message.creepDistanceMid);
    }
    if (message.creepDistanceOff !== undefined && message.creepDistanceOff !== 0) {
      writer.uint32(80).uint32(message.creepDistanceOff);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSteamLearnMatchStateV5_TeamState {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSteamLearnMatchStateV5_TeamState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.team = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.playerStates.push(CMsgSteamLearnMatchStateV5_PlayerState.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag === 24) {
            message.towerHealthPct.push(reader.uint32());

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.towerHealthPct.push(reader.uint32());
            }

            continue;
          }

          break;
        case 4:
          if (tag === 32) {
            message.barracksHealthPct.push(reader.uint32());

            continue;
          }

          if (tag === 34) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.barracksHealthPct.push(reader.uint32());
            }

            continue;
          }

          break;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.ancientHealthPct = reader.uint32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.glyphCooldown = reader.uint32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.kills = reader.uint32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.creepDistanceSafe = reader.uint32();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.creepDistanceMid = reader.uint32();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.creepDistanceOff = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSteamLearnMatchStateV5_TeamState {
    return {
      team: isSet(object.team) ? globalThis.Number(object.team) : 0,
      playerStates: globalThis.Array.isArray(object?.playerStates)
        ? object.playerStates.map((e: any) => CMsgSteamLearnMatchStateV5_PlayerState.fromJSON(e))
        : [],
      towerHealthPct: globalThis.Array.isArray(object?.towerHealthPct)
        ? object.towerHealthPct.map((e: any) => globalThis.Number(e))
        : [],
      barracksHealthPct: globalThis.Array.isArray(object?.barracksHealthPct)
        ? object.barracksHealthPct.map((e: any) => globalThis.Number(e))
        : [],
      ancientHealthPct: isSet(object.ancientHealthPct) ? globalThis.Number(object.ancientHealthPct) : 0,
      glyphCooldown: isSet(object.glyphCooldown) ? globalThis.Number(object.glyphCooldown) : 0,
      kills: isSet(object.kills) ? globalThis.Number(object.kills) : 0,
      creepDistanceSafe: isSet(object.creepDistanceSafe) ? globalThis.Number(object.creepDistanceSafe) : 0,
      creepDistanceMid: isSet(object.creepDistanceMid) ? globalThis.Number(object.creepDistanceMid) : 0,
      creepDistanceOff: isSet(object.creepDistanceOff) ? globalThis.Number(object.creepDistanceOff) : 0,
    };
  },

  toJSON(message: CMsgSteamLearnMatchStateV5_TeamState): unknown {
    const obj: any = {};
    if (message.team !== undefined && message.team !== 0) {
      obj.team = Math.round(message.team);
    }
    if (message.playerStates?.length) {
      obj.playerStates = message.playerStates.map((e) => CMsgSteamLearnMatchStateV5_PlayerState.toJSON(e));
    }
    if (message.towerHealthPct?.length) {
      obj.towerHealthPct = message.towerHealthPct.map((e) => Math.round(e));
    }
    if (message.barracksHealthPct?.length) {
      obj.barracksHealthPct = message.barracksHealthPct.map((e) => Math.round(e));
    }
    if (message.ancientHealthPct !== undefined && message.ancientHealthPct !== 0) {
      obj.ancientHealthPct = Math.round(message.ancientHealthPct);
    }
    if (message.glyphCooldown !== undefined && message.glyphCooldown !== 0) {
      obj.glyphCooldown = Math.round(message.glyphCooldown);
    }
    if (message.kills !== undefined && message.kills !== 0) {
      obj.kills = Math.round(message.kills);
    }
    if (message.creepDistanceSafe !== undefined && message.creepDistanceSafe !== 0) {
      obj.creepDistanceSafe = Math.round(message.creepDistanceSafe);
    }
    if (message.creepDistanceMid !== undefined && message.creepDistanceMid !== 0) {
      obj.creepDistanceMid = Math.round(message.creepDistanceMid);
    }
    if (message.creepDistanceOff !== undefined && message.creepDistanceOff !== 0) {
      obj.creepDistanceOff = Math.round(message.creepDistanceOff);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSteamLearnMatchStateV5_TeamState>): CMsgSteamLearnMatchStateV5_TeamState {
    return CMsgSteamLearnMatchStateV5_TeamState.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSteamLearnMatchStateV5_TeamState>): CMsgSteamLearnMatchStateV5_TeamState {
    const message = createBaseCMsgSteamLearnMatchStateV5_TeamState();
    message.team = object.team ?? 0;
    message.playerStates = object.playerStates?.map((e) => CMsgSteamLearnMatchStateV5_PlayerState.fromPartial(e)) || [];
    message.towerHealthPct = object.towerHealthPct?.map((e) => e) || [];
    message.barracksHealthPct = object.barracksHealthPct?.map((e) => e) || [];
    message.ancientHealthPct = object.ancientHealthPct ?? 0;
    message.glyphCooldown = object.glyphCooldown ?? 0;
    message.kills = object.kills ?? 0;
    message.creepDistanceSafe = object.creepDistanceSafe ?? 0;
    message.creepDistanceMid = object.creepDistanceMid ?? 0;
    message.creepDistanceOff = object.creepDistanceOff ?? 0;
    return message;
  },
};

function createBaseCMsgSteamLearnItemPurchase(): CMsgSteamLearnItemPurchase {
  return {
    itemId: -1,
    inventoryItems: [],
    purchaseHistory: [],
    gold: 0,
    netWorth: 0,
    isRadiantTeam: 0,
    gameTime: 0,
    isUsingDotaPlus: false,
  };
}

export const CMsgSteamLearnItemPurchase = {
  encode(message: CMsgSteamLearnItemPurchase, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.itemId !== undefined && message.itemId !== -1) {
      writer.uint32(8).int32(message.itemId);
    }
    writer.uint32(18).fork();
    for (const v of message.inventoryItems) {
      writer.int32(v);
    }
    writer.ldelim();
    writer.uint32(26).fork();
    for (const v of message.purchaseHistory) {
      writer.int32(v);
    }
    writer.ldelim();
    if (message.gold !== undefined && message.gold !== 0) {
      writer.uint32(32).uint32(message.gold);
    }
    if (message.netWorth !== undefined && message.netWorth !== 0) {
      writer.uint32(40).uint32(message.netWorth);
    }
    if (message.isRadiantTeam !== undefined && message.isRadiantTeam !== 0) {
      writer.uint32(48).uint32(message.isRadiantTeam);
    }
    if (message.gameTime !== undefined && message.gameTime !== 0) {
      writer.uint32(61).float(message.gameTime);
    }
    if (message.isUsingDotaPlus !== undefined && message.isUsingDotaPlus !== false) {
      writer.uint32(64).bool(message.isUsingDotaPlus);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSteamLearnItemPurchase {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSteamLearnItemPurchase();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.itemId = reader.int32();
          continue;
        case 2:
          if (tag === 16) {
            message.inventoryItems.push(reader.int32());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.inventoryItems.push(reader.int32());
            }

            continue;
          }

          break;
        case 3:
          if (tag === 24) {
            message.purchaseHistory.push(reader.int32());

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.purchaseHistory.push(reader.int32());
            }

            continue;
          }

          break;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.gold = reader.uint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.netWorth = reader.uint32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.isRadiantTeam = reader.uint32();
          continue;
        case 7:
          if (tag !== 61) {
            break;
          }

          message.gameTime = reader.float();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.isUsingDotaPlus = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSteamLearnItemPurchase {
    return {
      itemId: isSet(object.itemId) ? globalThis.Number(object.itemId) : -1,
      inventoryItems: globalThis.Array.isArray(object?.inventoryItems)
        ? object.inventoryItems.map((e: any) => globalThis.Number(e))
        : [],
      purchaseHistory: globalThis.Array.isArray(object?.purchaseHistory)
        ? object.purchaseHistory.map((e: any) => globalThis.Number(e))
        : [],
      gold: isSet(object.gold) ? globalThis.Number(object.gold) : 0,
      netWorth: isSet(object.netWorth) ? globalThis.Number(object.netWorth) : 0,
      isRadiantTeam: isSet(object.isRadiantTeam) ? globalThis.Number(object.isRadiantTeam) : 0,
      gameTime: isSet(object.gameTime) ? globalThis.Number(object.gameTime) : 0,
      isUsingDotaPlus: isSet(object.isUsingDotaPlus) ? globalThis.Boolean(object.isUsingDotaPlus) : false,
    };
  },

  toJSON(message: CMsgSteamLearnItemPurchase): unknown {
    const obj: any = {};
    if (message.itemId !== undefined && message.itemId !== -1) {
      obj.itemId = Math.round(message.itemId);
    }
    if (message.inventoryItems?.length) {
      obj.inventoryItems = message.inventoryItems.map((e) => Math.round(e));
    }
    if (message.purchaseHistory?.length) {
      obj.purchaseHistory = message.purchaseHistory.map((e) => Math.round(e));
    }
    if (message.gold !== undefined && message.gold !== 0) {
      obj.gold = Math.round(message.gold);
    }
    if (message.netWorth !== undefined && message.netWorth !== 0) {
      obj.netWorth = Math.round(message.netWorth);
    }
    if (message.isRadiantTeam !== undefined && message.isRadiantTeam !== 0) {
      obj.isRadiantTeam = Math.round(message.isRadiantTeam);
    }
    if (message.gameTime !== undefined && message.gameTime !== 0) {
      obj.gameTime = message.gameTime;
    }
    if (message.isUsingDotaPlus !== undefined && message.isUsingDotaPlus !== false) {
      obj.isUsingDotaPlus = message.isUsingDotaPlus;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSteamLearnItemPurchase>): CMsgSteamLearnItemPurchase {
    return CMsgSteamLearnItemPurchase.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSteamLearnItemPurchase>): CMsgSteamLearnItemPurchase {
    const message = createBaseCMsgSteamLearnItemPurchase();
    message.itemId = object.itemId ?? -1;
    message.inventoryItems = object.inventoryItems?.map((e) => e) || [];
    message.purchaseHistory = object.purchaseHistory?.map((e) => e) || [];
    message.gold = object.gold ?? 0;
    message.netWorth = object.netWorth ?? 0;
    message.isRadiantTeam = object.isRadiantTeam ?? 0;
    message.gameTime = object.gameTime ?? 0;
    message.isUsingDotaPlus = object.isUsingDotaPlus ?? false;
    return message;
  },
};

function createBaseCMsgSteamLearnPreGameItemPurchases(): CMsgSteamLearnPreGameItemPurchases {
  return { itemIds: [], isRadiantTeam: 0, isUsingDotaPlus: false };
}

export const CMsgSteamLearnPreGameItemPurchases = {
  encode(message: CMsgSteamLearnPreGameItemPurchases, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.itemIds) {
      writer.int32(v);
    }
    writer.ldelim();
    if (message.isRadiantTeam !== undefined && message.isRadiantTeam !== 0) {
      writer.uint32(16).uint32(message.isRadiantTeam);
    }
    if (message.isUsingDotaPlus !== undefined && message.isUsingDotaPlus !== false) {
      writer.uint32(24).bool(message.isUsingDotaPlus);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSteamLearnPreGameItemPurchases {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSteamLearnPreGameItemPurchases();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.itemIds.push(reader.int32());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.itemIds.push(reader.int32());
            }

            continue;
          }

          break;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.isRadiantTeam = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.isUsingDotaPlus = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSteamLearnPreGameItemPurchases {
    return {
      itemIds: globalThis.Array.isArray(object?.itemIds) ? object.itemIds.map((e: any) => globalThis.Number(e)) : [],
      isRadiantTeam: isSet(object.isRadiantTeam) ? globalThis.Number(object.isRadiantTeam) : 0,
      isUsingDotaPlus: isSet(object.isUsingDotaPlus) ? globalThis.Boolean(object.isUsingDotaPlus) : false,
    };
  },

  toJSON(message: CMsgSteamLearnPreGameItemPurchases): unknown {
    const obj: any = {};
    if (message.itemIds?.length) {
      obj.itemIds = message.itemIds.map((e) => Math.round(e));
    }
    if (message.isRadiantTeam !== undefined && message.isRadiantTeam !== 0) {
      obj.isRadiantTeam = Math.round(message.isRadiantTeam);
    }
    if (message.isUsingDotaPlus !== undefined && message.isUsingDotaPlus !== false) {
      obj.isUsingDotaPlus = message.isUsingDotaPlus;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSteamLearnPreGameItemPurchases>): CMsgSteamLearnPreGameItemPurchases {
    return CMsgSteamLearnPreGameItemPurchases.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSteamLearnPreGameItemPurchases>): CMsgSteamLearnPreGameItemPurchases {
    const message = createBaseCMsgSteamLearnPreGameItemPurchases();
    message.itemIds = object.itemIds?.map((e) => e) || [];
    message.isRadiantTeam = object.isRadiantTeam ?? 0;
    message.isUsingDotaPlus = object.isUsingDotaPlus ?? false;
    return message;
  },
};

function createBaseCMsgSteamLearnNeutralItemPurchase(): CMsgSteamLearnNeutralItemPurchase {
  return { itemId: -1, tier: 0, isRadiantTeam: 0, isUsingDotaPlus: false };
}

export const CMsgSteamLearnNeutralItemPurchase = {
  encode(message: CMsgSteamLearnNeutralItemPurchase, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.itemId !== undefined && message.itemId !== -1) {
      writer.uint32(8).int32(message.itemId);
    }
    if (message.tier !== undefined && message.tier !== 0) {
      writer.uint32(16).uint32(message.tier);
    }
    if (message.isRadiantTeam !== undefined && message.isRadiantTeam !== 0) {
      writer.uint32(24).uint32(message.isRadiantTeam);
    }
    if (message.isUsingDotaPlus !== undefined && message.isUsingDotaPlus !== false) {
      writer.uint32(32).bool(message.isUsingDotaPlus);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSteamLearnNeutralItemPurchase {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSteamLearnNeutralItemPurchase();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.itemId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.tier = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.isRadiantTeam = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.isUsingDotaPlus = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSteamLearnNeutralItemPurchase {
    return {
      itemId: isSet(object.itemId) ? globalThis.Number(object.itemId) : -1,
      tier: isSet(object.tier) ? globalThis.Number(object.tier) : 0,
      isRadiantTeam: isSet(object.isRadiantTeam) ? globalThis.Number(object.isRadiantTeam) : 0,
      isUsingDotaPlus: isSet(object.isUsingDotaPlus) ? globalThis.Boolean(object.isUsingDotaPlus) : false,
    };
  },

  toJSON(message: CMsgSteamLearnNeutralItemPurchase): unknown {
    const obj: any = {};
    if (message.itemId !== undefined && message.itemId !== -1) {
      obj.itemId = Math.round(message.itemId);
    }
    if (message.tier !== undefined && message.tier !== 0) {
      obj.tier = Math.round(message.tier);
    }
    if (message.isRadiantTeam !== undefined && message.isRadiantTeam !== 0) {
      obj.isRadiantTeam = Math.round(message.isRadiantTeam);
    }
    if (message.isUsingDotaPlus !== undefined && message.isUsingDotaPlus !== false) {
      obj.isUsingDotaPlus = message.isUsingDotaPlus;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSteamLearnNeutralItemPurchase>): CMsgSteamLearnNeutralItemPurchase {
    return CMsgSteamLearnNeutralItemPurchase.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSteamLearnNeutralItemPurchase>): CMsgSteamLearnNeutralItemPurchase {
    const message = createBaseCMsgSteamLearnNeutralItemPurchase();
    message.itemId = object.itemId ?? -1;
    message.tier = object.tier ?? 0;
    message.isRadiantTeam = object.isRadiantTeam ?? 0;
    message.isUsingDotaPlus = object.isUsingDotaPlus ?? false;
    return message;
  },
};

function createBaseCMsgSteamLearnNeutralItemPurchaseV2(): CMsgSteamLearnNeutralItemPurchaseV2 {
  return { tier: 0, trinketId: -1, enhancementId: -1, previousTrinketId: -1 };
}

export const CMsgSteamLearnNeutralItemPurchaseV2 = {
  encode(message: CMsgSteamLearnNeutralItemPurchaseV2, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.tier !== undefined && message.tier !== 0) {
      writer.uint32(8).uint32(message.tier);
    }
    if (message.trinketId !== undefined && message.trinketId !== -1) {
      writer.uint32(16).int32(message.trinketId);
    }
    if (message.enhancementId !== undefined && message.enhancementId !== -1) {
      writer.uint32(24).int32(message.enhancementId);
    }
    if (message.previousTrinketId !== undefined && message.previousTrinketId !== -1) {
      writer.uint32(32).int32(message.previousTrinketId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSteamLearnNeutralItemPurchaseV2 {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSteamLearnNeutralItemPurchaseV2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.tier = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.trinketId = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.enhancementId = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.previousTrinketId = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSteamLearnNeutralItemPurchaseV2 {
    return {
      tier: isSet(object.tier) ? globalThis.Number(object.tier) : 0,
      trinketId: isSet(object.trinketId) ? globalThis.Number(object.trinketId) : -1,
      enhancementId: isSet(object.enhancementId) ? globalThis.Number(object.enhancementId) : -1,
      previousTrinketId: isSet(object.previousTrinketId) ? globalThis.Number(object.previousTrinketId) : -1,
    };
  },

  toJSON(message: CMsgSteamLearnNeutralItemPurchaseV2): unknown {
    const obj: any = {};
    if (message.tier !== undefined && message.tier !== 0) {
      obj.tier = Math.round(message.tier);
    }
    if (message.trinketId !== undefined && message.trinketId !== -1) {
      obj.trinketId = Math.round(message.trinketId);
    }
    if (message.enhancementId !== undefined && message.enhancementId !== -1) {
      obj.enhancementId = Math.round(message.enhancementId);
    }
    if (message.previousTrinketId !== undefined && message.previousTrinketId !== -1) {
      obj.previousTrinketId = Math.round(message.previousTrinketId);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSteamLearnNeutralItemPurchaseV2>): CMsgSteamLearnNeutralItemPurchaseV2 {
    return CMsgSteamLearnNeutralItemPurchaseV2.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSteamLearnNeutralItemPurchaseV2>): CMsgSteamLearnNeutralItemPurchaseV2 {
    const message = createBaseCMsgSteamLearnNeutralItemPurchaseV2();
    message.tier = object.tier ?? 0;
    message.trinketId = object.trinketId ?? -1;
    message.enhancementId = object.enhancementId ?? -1;
    message.previousTrinketId = object.previousTrinketId ?? -1;
    return message;
  },
};

function createBaseCMsgSteamLearnAbilitySkill(): CMsgSteamLearnAbilitySkill {
  return { abilityId: -1, skilledAbilities: [], gameTime: 0, isUsingDotaPlus: false };
}

export const CMsgSteamLearnAbilitySkill = {
  encode(message: CMsgSteamLearnAbilitySkill, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.abilityId !== undefined && message.abilityId !== -1) {
      writer.uint32(8).int32(message.abilityId);
    }
    writer.uint32(18).fork();
    for (const v of message.skilledAbilities) {
      writer.int32(v);
    }
    writer.ldelim();
    if (message.gameTime !== undefined && message.gameTime !== 0) {
      writer.uint32(29).float(message.gameTime);
    }
    if (message.isUsingDotaPlus !== undefined && message.isUsingDotaPlus !== false) {
      writer.uint32(32).bool(message.isUsingDotaPlus);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSteamLearnAbilitySkill {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSteamLearnAbilitySkill();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.abilityId = reader.int32();
          continue;
        case 2:
          if (tag === 16) {
            message.skilledAbilities.push(reader.int32());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.skilledAbilities.push(reader.int32());
            }

            continue;
          }

          break;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.gameTime = reader.float();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.isUsingDotaPlus = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSteamLearnAbilitySkill {
    return {
      abilityId: isSet(object.abilityId) ? globalThis.Number(object.abilityId) : -1,
      skilledAbilities: globalThis.Array.isArray(object?.skilledAbilities)
        ? object.skilledAbilities.map((e: any) => globalThis.Number(e))
        : [],
      gameTime: isSet(object.gameTime) ? globalThis.Number(object.gameTime) : 0,
      isUsingDotaPlus: isSet(object.isUsingDotaPlus) ? globalThis.Boolean(object.isUsingDotaPlus) : false,
    };
  },

  toJSON(message: CMsgSteamLearnAbilitySkill): unknown {
    const obj: any = {};
    if (message.abilityId !== undefined && message.abilityId !== -1) {
      obj.abilityId = Math.round(message.abilityId);
    }
    if (message.skilledAbilities?.length) {
      obj.skilledAbilities = message.skilledAbilities.map((e) => Math.round(e));
    }
    if (message.gameTime !== undefined && message.gameTime !== 0) {
      obj.gameTime = message.gameTime;
    }
    if (message.isUsingDotaPlus !== undefined && message.isUsingDotaPlus !== false) {
      obj.isUsingDotaPlus = message.isUsingDotaPlus;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSteamLearnAbilitySkill>): CMsgSteamLearnAbilitySkill {
    return CMsgSteamLearnAbilitySkill.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSteamLearnAbilitySkill>): CMsgSteamLearnAbilitySkill {
    const message = createBaseCMsgSteamLearnAbilitySkill();
    message.abilityId = object.abilityId ?? -1;
    message.skilledAbilities = object.skilledAbilities?.map((e) => e) || [];
    message.gameTime = object.gameTime ?? 0;
    message.isUsingDotaPlus = object.isUsingDotaPlus ?? false;
    return message;
  },
};

function createBaseCMsgSteamLearnEarlyGameItemPurchasesV2(): CMsgSteamLearnEarlyGameItemPurchasesV2 {
  return { itemIds: [], otherItemIds: [] };
}

export const CMsgSteamLearnEarlyGameItemPurchasesV2 = {
  encode(message: CMsgSteamLearnEarlyGameItemPurchasesV2, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.itemIds) {
      writer.int32(v);
    }
    writer.ldelim();
    writer.uint32(18).fork();
    for (const v of message.otherItemIds) {
      writer.int32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSteamLearnEarlyGameItemPurchasesV2 {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSteamLearnEarlyGameItemPurchasesV2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.itemIds.push(reader.int32());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.itemIds.push(reader.int32());
            }

            continue;
          }

          break;
        case 2:
          if (tag === 16) {
            message.otherItemIds.push(reader.int32());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.otherItemIds.push(reader.int32());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSteamLearnEarlyGameItemPurchasesV2 {
    return {
      itemIds: globalThis.Array.isArray(object?.itemIds) ? object.itemIds.map((e: any) => globalThis.Number(e)) : [],
      otherItemIds: globalThis.Array.isArray(object?.otherItemIds)
        ? object.otherItemIds.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: CMsgSteamLearnEarlyGameItemPurchasesV2): unknown {
    const obj: any = {};
    if (message.itemIds?.length) {
      obj.itemIds = message.itemIds.map((e) => Math.round(e));
    }
    if (message.otherItemIds?.length) {
      obj.otherItemIds = message.otherItemIds.map((e) => Math.round(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSteamLearnEarlyGameItemPurchasesV2>): CMsgSteamLearnEarlyGameItemPurchasesV2 {
    return CMsgSteamLearnEarlyGameItemPurchasesV2.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSteamLearnEarlyGameItemPurchasesV2>): CMsgSteamLearnEarlyGameItemPurchasesV2 {
    const message = createBaseCMsgSteamLearnEarlyGameItemPurchasesV2();
    message.itemIds = object.itemIds?.map((e) => e) || [];
    message.otherItemIds = object.otherItemIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseCMsgSteamLearnLateGameItemPurchasesV2(): CMsgSteamLearnLateGameItemPurchasesV2 {
  return { itemIds: [], otherItemIds: [] };
}

export const CMsgSteamLearnLateGameItemPurchasesV2 = {
  encode(message: CMsgSteamLearnLateGameItemPurchasesV2, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.itemIds) {
      writer.int32(v);
    }
    writer.ldelim();
    writer.uint32(18).fork();
    for (const v of message.otherItemIds) {
      writer.int32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSteamLearnLateGameItemPurchasesV2 {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSteamLearnLateGameItemPurchasesV2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.itemIds.push(reader.int32());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.itemIds.push(reader.int32());
            }

            continue;
          }

          break;
        case 2:
          if (tag === 16) {
            message.otherItemIds.push(reader.int32());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.otherItemIds.push(reader.int32());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSteamLearnLateGameItemPurchasesV2 {
    return {
      itemIds: globalThis.Array.isArray(object?.itemIds) ? object.itemIds.map((e: any) => globalThis.Number(e)) : [],
      otherItemIds: globalThis.Array.isArray(object?.otherItemIds)
        ? object.otherItemIds.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: CMsgSteamLearnLateGameItemPurchasesV2): unknown {
    const obj: any = {};
    if (message.itemIds?.length) {
      obj.itemIds = message.itemIds.map((e) => Math.round(e));
    }
    if (message.otherItemIds?.length) {
      obj.otherItemIds = message.otherItemIds.map((e) => Math.round(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSteamLearnLateGameItemPurchasesV2>): CMsgSteamLearnLateGameItemPurchasesV2 {
    return CMsgSteamLearnLateGameItemPurchasesV2.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSteamLearnLateGameItemPurchasesV2>): CMsgSteamLearnLateGameItemPurchasesV2 {
    const message = createBaseCMsgSteamLearnLateGameItemPurchasesV2();
    message.itemIds = object.itemIds?.map((e) => e) || [];
    message.otherItemIds = object.otherItemIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseCMsgSteamLearnMainGameItemPurchases(): CMsgSteamLearnMainGameItemPurchases {
  return { itemIds: [] };
}

export const CMsgSteamLearnMainGameItemPurchases = {
  encode(message: CMsgSteamLearnMainGameItemPurchases, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.itemIds) {
      writer.int32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSteamLearnMainGameItemPurchases {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSteamLearnMainGameItemPurchases();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.itemIds.push(reader.int32());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.itemIds.push(reader.int32());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSteamLearnMainGameItemPurchases {
    return {
      itemIds: globalThis.Array.isArray(object?.itemIds) ? object.itemIds.map((e: any) => globalThis.Number(e)) : [],
    };
  },

  toJSON(message: CMsgSteamLearnMainGameItemPurchases): unknown {
    const obj: any = {};
    if (message.itemIds?.length) {
      obj.itemIds = message.itemIds.map((e) => Math.round(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSteamLearnMainGameItemPurchases>): CMsgSteamLearnMainGameItemPurchases {
    return CMsgSteamLearnMainGameItemPurchases.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSteamLearnMainGameItemPurchases>): CMsgSteamLearnMainGameItemPurchases {
    const message = createBaseCMsgSteamLearnMainGameItemPurchases();
    message.itemIds = object.itemIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseCMsgSteamLearnWardPlacement(): CMsgSteamLearnWardPlacement {
  return { wardLoc: undefined, existingWardLocs: [], team: 0 };
}

export const CMsgSteamLearnWardPlacement = {
  encode(message: CMsgSteamLearnWardPlacement, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.wardLoc !== undefined) {
      CMsgSteamLearnWardPlacement_Location.encode(message.wardLoc, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.existingWardLocs) {
      CMsgSteamLearnWardPlacement_Location.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.team !== undefined && message.team !== 0) {
      writer.uint32(24).uint32(message.team);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSteamLearnWardPlacement {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSteamLearnWardPlacement();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.wardLoc = CMsgSteamLearnWardPlacement_Location.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.existingWardLocs.push(CMsgSteamLearnWardPlacement_Location.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.team = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSteamLearnWardPlacement {
    return {
      wardLoc: isSet(object.wardLoc) ? CMsgSteamLearnWardPlacement_Location.fromJSON(object.wardLoc) : undefined,
      existingWardLocs: globalThis.Array.isArray(object?.existingWardLocs)
        ? object.existingWardLocs.map((e: any) => CMsgSteamLearnWardPlacement_Location.fromJSON(e))
        : [],
      team: isSet(object.team) ? globalThis.Number(object.team) : 0,
    };
  },

  toJSON(message: CMsgSteamLearnWardPlacement): unknown {
    const obj: any = {};
    if (message.wardLoc !== undefined) {
      obj.wardLoc = CMsgSteamLearnWardPlacement_Location.toJSON(message.wardLoc);
    }
    if (message.existingWardLocs?.length) {
      obj.existingWardLocs = message.existingWardLocs.map((e) => CMsgSteamLearnWardPlacement_Location.toJSON(e));
    }
    if (message.team !== undefined && message.team !== 0) {
      obj.team = Math.round(message.team);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSteamLearnWardPlacement>): CMsgSteamLearnWardPlacement {
    return CMsgSteamLearnWardPlacement.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSteamLearnWardPlacement>): CMsgSteamLearnWardPlacement {
    const message = createBaseCMsgSteamLearnWardPlacement();
    message.wardLoc = (object.wardLoc !== undefined && object.wardLoc !== null)
      ? CMsgSteamLearnWardPlacement_Location.fromPartial(object.wardLoc)
      : undefined;
    message.existingWardLocs =
      object.existingWardLocs?.map((e) => CMsgSteamLearnWardPlacement_Location.fromPartial(e)) || [];
    message.team = object.team ?? 0;
    return message;
  },
};

function createBaseCMsgSteamLearnWardPlacement_Location(): CMsgSteamLearnWardPlacement_Location {
  return { x: 0, y: 0 };
}

export const CMsgSteamLearnWardPlacement_Location = {
  encode(message: CMsgSteamLearnWardPlacement_Location, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.x !== undefined && message.x !== 0) {
      writer.uint32(13).float(message.x);
    }
    if (message.y !== undefined && message.y !== 0) {
      writer.uint32(21).float(message.y);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSteamLearnWardPlacement_Location {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSteamLearnWardPlacement_Location();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.x = reader.float();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.y = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSteamLearnWardPlacement_Location {
    return {
      x: isSet(object.x) ? globalThis.Number(object.x) : 0,
      y: isSet(object.y) ? globalThis.Number(object.y) : 0,
    };
  },

  toJSON(message: CMsgSteamLearnWardPlacement_Location): unknown {
    const obj: any = {};
    if (message.x !== undefined && message.x !== 0) {
      obj.x = message.x;
    }
    if (message.y !== undefined && message.y !== 0) {
      obj.y = message.y;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSteamLearnWardPlacement_Location>): CMsgSteamLearnWardPlacement_Location {
    return CMsgSteamLearnWardPlacement_Location.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSteamLearnWardPlacement_Location>): CMsgSteamLearnWardPlacement_Location {
    const message = createBaseCMsgSteamLearnWardPlacement_Location();
    message.x = object.x ?? 0;
    message.y = object.y ?? 0;
    return message;
  },
};

function createBaseCMsgSteamLearnPlayerMatchState(): CMsgSteamLearnPlayerMatchState {
  return {
    netWorth: 0,
    level: 0,
    deaths: 0,
    respawnTime: 0,
    hasBuyback: false,
    hasAegis: false,
    hasRapier: false,
    teamNetWorth: 0,
    enemyTeamNetWorth: 0,
    teamKills: 0,
    enemyTeamKills: 0,
    gameTime: 0,
  };
}

export const CMsgSteamLearnPlayerMatchState = {
  encode(message: CMsgSteamLearnPlayerMatchState, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.netWorth !== undefined && message.netWorth !== 0) {
      writer.uint32(8).uint32(message.netWorth);
    }
    if (message.level !== undefined && message.level !== 0) {
      writer.uint32(16).uint32(message.level);
    }
    if (message.deaths !== undefined && message.deaths !== 0) {
      writer.uint32(24).uint32(message.deaths);
    }
    if (message.respawnTime !== undefined && message.respawnTime !== 0) {
      writer.uint32(32).uint32(message.respawnTime);
    }
    if (message.hasBuyback !== undefined && message.hasBuyback !== false) {
      writer.uint32(40).bool(message.hasBuyback);
    }
    if (message.hasAegis !== undefined && message.hasAegis !== false) {
      writer.uint32(48).bool(message.hasAegis);
    }
    if (message.hasRapier !== undefined && message.hasRapier !== false) {
      writer.uint32(56).bool(message.hasRapier);
    }
    if (message.teamNetWorth !== undefined && message.teamNetWorth !== 0) {
      writer.uint32(64).uint32(message.teamNetWorth);
    }
    if (message.enemyTeamNetWorth !== undefined && message.enemyTeamNetWorth !== 0) {
      writer.uint32(72).uint32(message.enemyTeamNetWorth);
    }
    if (message.teamKills !== undefined && message.teamKills !== 0) {
      writer.uint32(80).uint32(message.teamKills);
    }
    if (message.enemyTeamKills !== undefined && message.enemyTeamKills !== 0) {
      writer.uint32(88).uint32(message.enemyTeamKills);
    }
    if (message.gameTime !== undefined && message.gameTime !== 0) {
      writer.uint32(101).float(message.gameTime);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSteamLearnPlayerMatchState {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSteamLearnPlayerMatchState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.netWorth = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.level = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.deaths = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.respawnTime = reader.uint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.hasBuyback = reader.bool();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.hasAegis = reader.bool();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.hasRapier = reader.bool();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.teamNetWorth = reader.uint32();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.enemyTeamNetWorth = reader.uint32();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.teamKills = reader.uint32();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.enemyTeamKills = reader.uint32();
          continue;
        case 12:
          if (tag !== 101) {
            break;
          }

          message.gameTime = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSteamLearnPlayerMatchState {
    return {
      netWorth: isSet(object.netWorth) ? globalThis.Number(object.netWorth) : 0,
      level: isSet(object.level) ? globalThis.Number(object.level) : 0,
      deaths: isSet(object.deaths) ? globalThis.Number(object.deaths) : 0,
      respawnTime: isSet(object.respawnTime) ? globalThis.Number(object.respawnTime) : 0,
      hasBuyback: isSet(object.hasBuyback) ? globalThis.Boolean(object.hasBuyback) : false,
      hasAegis: isSet(object.hasAegis) ? globalThis.Boolean(object.hasAegis) : false,
      hasRapier: isSet(object.hasRapier) ? globalThis.Boolean(object.hasRapier) : false,
      teamNetWorth: isSet(object.teamNetWorth) ? globalThis.Number(object.teamNetWorth) : 0,
      enemyTeamNetWorth: isSet(object.enemyTeamNetWorth) ? globalThis.Number(object.enemyTeamNetWorth) : 0,
      teamKills: isSet(object.teamKills) ? globalThis.Number(object.teamKills) : 0,
      enemyTeamKills: isSet(object.enemyTeamKills) ? globalThis.Number(object.enemyTeamKills) : 0,
      gameTime: isSet(object.gameTime) ? globalThis.Number(object.gameTime) : 0,
    };
  },

  toJSON(message: CMsgSteamLearnPlayerMatchState): unknown {
    const obj: any = {};
    if (message.netWorth !== undefined && message.netWorth !== 0) {
      obj.netWorth = Math.round(message.netWorth);
    }
    if (message.level !== undefined && message.level !== 0) {
      obj.level = Math.round(message.level);
    }
    if (message.deaths !== undefined && message.deaths !== 0) {
      obj.deaths = Math.round(message.deaths);
    }
    if (message.respawnTime !== undefined && message.respawnTime !== 0) {
      obj.respawnTime = Math.round(message.respawnTime);
    }
    if (message.hasBuyback !== undefined && message.hasBuyback !== false) {
      obj.hasBuyback = message.hasBuyback;
    }
    if (message.hasAegis !== undefined && message.hasAegis !== false) {
      obj.hasAegis = message.hasAegis;
    }
    if (message.hasRapier !== undefined && message.hasRapier !== false) {
      obj.hasRapier = message.hasRapier;
    }
    if (message.teamNetWorth !== undefined && message.teamNetWorth !== 0) {
      obj.teamNetWorth = Math.round(message.teamNetWorth);
    }
    if (message.enemyTeamNetWorth !== undefined && message.enemyTeamNetWorth !== 0) {
      obj.enemyTeamNetWorth = Math.round(message.enemyTeamNetWorth);
    }
    if (message.teamKills !== undefined && message.teamKills !== 0) {
      obj.teamKills = Math.round(message.teamKills);
    }
    if (message.enemyTeamKills !== undefined && message.enemyTeamKills !== 0) {
      obj.enemyTeamKills = Math.round(message.enemyTeamKills);
    }
    if (message.gameTime !== undefined && message.gameTime !== 0) {
      obj.gameTime = message.gameTime;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSteamLearnPlayerMatchState>): CMsgSteamLearnPlayerMatchState {
    return CMsgSteamLearnPlayerMatchState.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSteamLearnPlayerMatchState>): CMsgSteamLearnPlayerMatchState {
    const message = createBaseCMsgSteamLearnPlayerMatchState();
    message.netWorth = object.netWorth ?? 0;
    message.level = object.level ?? 0;
    message.deaths = object.deaths ?? 0;
    message.respawnTime = object.respawnTime ?? 0;
    message.hasBuyback = object.hasBuyback ?? false;
    message.hasAegis = object.hasAegis ?? false;
    message.hasRapier = object.hasRapier ?? false;
    message.teamNetWorth = object.teamNetWorth ?? 0;
    message.enemyTeamNetWorth = object.enemyTeamNetWorth ?? 0;
    message.teamKills = object.teamKills ?? 0;
    message.enemyTeamKills = object.enemyTeamKills ?? 0;
    message.gameTime = object.gameTime ?? 0;
    return message;
  },
};

function createBaseCMsgSignOutMuertaMinigame(): CMsgSignOutMuertaMinigame {
  return { eventGameData: Buffer.alloc(0) };
}

export const CMsgSignOutMuertaMinigame = {
  encode(message: CMsgSignOutMuertaMinigame, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.eventGameData !== undefined && message.eventGameData.length !== 0) {
      writer.uint32(10).bytes(message.eventGameData);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSignOutMuertaMinigame {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSignOutMuertaMinigame();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.eventGameData = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSignOutMuertaMinigame {
    return {
      eventGameData: isSet(object.eventGameData) ? Buffer.from(bytesFromBase64(object.eventGameData)) : Buffer.alloc(0),
    };
  },

  toJSON(message: CMsgSignOutMuertaMinigame): unknown {
    const obj: any = {};
    if (message.eventGameData !== undefined && message.eventGameData.length !== 0) {
      obj.eventGameData = base64FromBytes(message.eventGameData);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSignOutMuertaMinigame>): CMsgSignOutMuertaMinigame {
    return CMsgSignOutMuertaMinigame.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSignOutMuertaMinigame>): CMsgSignOutMuertaMinigame {
    const message = createBaseCMsgSignOutMuertaMinigame();
    message.eventGameData = object.eventGameData ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseCMsgSignOutMapStats(): CMsgSignOutMapStats {
  return { players: [], globalStats: undefined };
}

export const CMsgSignOutMapStats = {
  encode(message: CMsgSignOutMapStats, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.players) {
      CMsgSignOutMapStats_Player.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.globalStats !== undefined) {
      CMsgMapStatsSnapshot.encode(message.globalStats, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSignOutMapStats {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSignOutMapStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.players.push(CMsgSignOutMapStats_Player.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.globalStats = CMsgMapStatsSnapshot.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSignOutMapStats {
    return {
      players: globalThis.Array.isArray(object?.players)
        ? object.players.map((e: any) => CMsgSignOutMapStats_Player.fromJSON(e))
        : [],
      globalStats: isSet(object.globalStats) ? CMsgMapStatsSnapshot.fromJSON(object.globalStats) : undefined,
    };
  },

  toJSON(message: CMsgSignOutMapStats): unknown {
    const obj: any = {};
    if (message.players?.length) {
      obj.players = message.players.map((e) => CMsgSignOutMapStats_Player.toJSON(e));
    }
    if (message.globalStats !== undefined) {
      obj.globalStats = CMsgMapStatsSnapshot.toJSON(message.globalStats);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSignOutMapStats>): CMsgSignOutMapStats {
    return CMsgSignOutMapStats.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSignOutMapStats>): CMsgSignOutMapStats {
    const message = createBaseCMsgSignOutMapStats();
    message.players = object.players?.map((e) => CMsgSignOutMapStats_Player.fromPartial(e)) || [];
    message.globalStats = (object.globalStats !== undefined && object.globalStats !== null)
      ? CMsgMapStatsSnapshot.fromPartial(object.globalStats)
      : undefined;
    return message;
  },
};

function createBaseCMsgSignOutMapStats_Player(): CMsgSignOutMapStats_Player {
  return { accountId: 0, personalStats: undefined };
}

export const CMsgSignOutMapStats_Player = {
  encode(message: CMsgSignOutMapStats_Player, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.accountId !== undefined && message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    if (message.personalStats !== undefined) {
      CMsgMapStatsSnapshot.encode(message.personalStats, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSignOutMapStats_Player {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSignOutMapStats_Player();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.personalStats = CMsgMapStatsSnapshot.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSignOutMapStats_Player {
    return {
      accountId: isSet(object.accountId) ? globalThis.Number(object.accountId) : 0,
      personalStats: isSet(object.personalStats) ? CMsgMapStatsSnapshot.fromJSON(object.personalStats) : undefined,
    };
  },

  toJSON(message: CMsgSignOutMapStats_Player): unknown {
    const obj: any = {};
    if (message.accountId !== undefined && message.accountId !== 0) {
      obj.accountId = Math.round(message.accountId);
    }
    if (message.personalStats !== undefined) {
      obj.personalStats = CMsgMapStatsSnapshot.toJSON(message.personalStats);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSignOutMapStats_Player>): CMsgSignOutMapStats_Player {
    return CMsgSignOutMapStats_Player.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSignOutMapStats_Player>): CMsgSignOutMapStats_Player {
    const message = createBaseCMsgSignOutMapStats_Player();
    message.accountId = object.accountId ?? 0;
    message.personalStats = (object.personalStats !== undefined && object.personalStats !== null)
      ? CMsgMapStatsSnapshot.fromPartial(object.personalStats)
      : undefined;
    return message;
  },
};

function createBaseCMsgServerToGCNewBloomGift(): CMsgServerToGCNewBloomGift {
  return { defindex: 0, gifterAccountId: 0, targetAccountIds: [] };
}

export const CMsgServerToGCNewBloomGift = {
  encode(message: CMsgServerToGCNewBloomGift, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.defindex !== undefined && message.defindex !== 0) {
      writer.uint32(8).uint32(message.defindex);
    }
    if (message.gifterAccountId !== undefined && message.gifterAccountId !== 0) {
      writer.uint32(16).uint32(message.gifterAccountId);
    }
    writer.uint32(26).fork();
    for (const v of message.targetAccountIds) {
      writer.uint32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgServerToGCNewBloomGift {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgServerToGCNewBloomGift();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.defindex = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.gifterAccountId = reader.uint32();
          continue;
        case 3:
          if (tag === 24) {
            message.targetAccountIds.push(reader.uint32());

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.targetAccountIds.push(reader.uint32());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgServerToGCNewBloomGift {
    return {
      defindex: isSet(object.defindex) ? globalThis.Number(object.defindex) : 0,
      gifterAccountId: isSet(object.gifterAccountId) ? globalThis.Number(object.gifterAccountId) : 0,
      targetAccountIds: globalThis.Array.isArray(object?.targetAccountIds)
        ? object.targetAccountIds.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: CMsgServerToGCNewBloomGift): unknown {
    const obj: any = {};
    if (message.defindex !== undefined && message.defindex !== 0) {
      obj.defindex = Math.round(message.defindex);
    }
    if (message.gifterAccountId !== undefined && message.gifterAccountId !== 0) {
      obj.gifterAccountId = Math.round(message.gifterAccountId);
    }
    if (message.targetAccountIds?.length) {
      obj.targetAccountIds = message.targetAccountIds.map((e) => Math.round(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgServerToGCNewBloomGift>): CMsgServerToGCNewBloomGift {
    return CMsgServerToGCNewBloomGift.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgServerToGCNewBloomGift>): CMsgServerToGCNewBloomGift {
    const message = createBaseCMsgServerToGCNewBloomGift();
    message.defindex = object.defindex ?? 0;
    message.gifterAccountId = object.gifterAccountId ?? 0;
    message.targetAccountIds = object.targetAccountIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseCMsgServerToGCNewBloomGiftResponse(): CMsgServerToGCNewBloomGiftResponse {
  return { result: 1, receivedAccountIds: [] };
}

export const CMsgServerToGCNewBloomGiftResponse = {
  encode(message: CMsgServerToGCNewBloomGiftResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result !== undefined && message.result !== 1) {
      writer.uint32(8).int32(message.result);
    }
    writer.uint32(18).fork();
    for (const v of message.receivedAccountIds) {
      writer.uint32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgServerToGCNewBloomGiftResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgServerToGCNewBloomGiftResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.result = reader.int32() as any;
          continue;
        case 2:
          if (tag === 16) {
            message.receivedAccountIds.push(reader.uint32());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.receivedAccountIds.push(reader.uint32());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgServerToGCNewBloomGiftResponse {
    return {
      result: isSet(object.result) ? eNewBloomGiftingResponseFromJSON(object.result) : 1,
      receivedAccountIds: globalThis.Array.isArray(object?.receivedAccountIds)
        ? object.receivedAccountIds.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: CMsgServerToGCNewBloomGiftResponse): unknown {
    const obj: any = {};
    if (message.result !== undefined && message.result !== 1) {
      obj.result = eNewBloomGiftingResponseToJSON(message.result);
    }
    if (message.receivedAccountIds?.length) {
      obj.receivedAccountIds = message.receivedAccountIds.map((e) => Math.round(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgServerToGCNewBloomGiftResponse>): CMsgServerToGCNewBloomGiftResponse {
    return CMsgServerToGCNewBloomGiftResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgServerToGCNewBloomGiftResponse>): CMsgServerToGCNewBloomGiftResponse {
    const message = createBaseCMsgServerToGCNewBloomGiftResponse();
    message.result = object.result ?? 1;
    message.receivedAccountIds = object.receivedAccountIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseCMsgSignOutOverworld(): CMsgSignOutOverworld {
  return { players: [], eventId: 0 };
}

export const CMsgSignOutOverworld = {
  encode(message: CMsgSignOutOverworld, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.players) {
      CMsgSignOutOverworld_Player.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.eventId !== undefined && message.eventId !== 0) {
      writer.uint32(16).int32(message.eventId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSignOutOverworld {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSignOutOverworld();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.players.push(CMsgSignOutOverworld_Player.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.eventId = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSignOutOverworld {
    return {
      players: globalThis.Array.isArray(object?.players)
        ? object.players.map((e: any) => CMsgSignOutOverworld_Player.fromJSON(e))
        : [],
      eventId: isSet(object.eventId) ? eEventFromJSON(object.eventId) : 0,
    };
  },

  toJSON(message: CMsgSignOutOverworld): unknown {
    const obj: any = {};
    if (message.players?.length) {
      obj.players = message.players.map((e) => CMsgSignOutOverworld_Player.toJSON(e));
    }
    if (message.eventId !== undefined && message.eventId !== 0) {
      obj.eventId = eEventToJSON(message.eventId);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSignOutOverworld>): CMsgSignOutOverworld {
    return CMsgSignOutOverworld.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSignOutOverworld>): CMsgSignOutOverworld {
    const message = createBaseCMsgSignOutOverworld();
    message.players = object.players?.map((e) => CMsgSignOutOverworld_Player.fromPartial(e)) || [];
    message.eventId = object.eventId ?? 0;
    return message;
  },
};

function createBaseCMsgSignOutOverworld_Player(): CMsgSignOutOverworld_Player {
  return { accountId: 0, overworldId: 0, desiredTokenRewards: [] };
}

export const CMsgSignOutOverworld_Player = {
  encode(message: CMsgSignOutOverworld_Player, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.accountId !== undefined && message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    if (message.overworldId !== undefined && message.overworldId !== 0) {
      writer.uint32(16).uint32(message.overworldId);
    }
    writer.uint32(26).fork();
    for (const v of message.desiredTokenRewards) {
      writer.uint32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSignOutOverworld_Player {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSignOutOverworld_Player();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.overworldId = reader.uint32();
          continue;
        case 3:
          if (tag === 24) {
            message.desiredTokenRewards.push(reader.uint32());

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.desiredTokenRewards.push(reader.uint32());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSignOutOverworld_Player {
    return {
      accountId: isSet(object.accountId) ? globalThis.Number(object.accountId) : 0,
      overworldId: isSet(object.overworldId) ? globalThis.Number(object.overworldId) : 0,
      desiredTokenRewards: globalThis.Array.isArray(object?.desiredTokenRewards)
        ? object.desiredTokenRewards.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: CMsgSignOutOverworld_Player): unknown {
    const obj: any = {};
    if (message.accountId !== undefined && message.accountId !== 0) {
      obj.accountId = Math.round(message.accountId);
    }
    if (message.overworldId !== undefined && message.overworldId !== 0) {
      obj.overworldId = Math.round(message.overworldId);
    }
    if (message.desiredTokenRewards?.length) {
      obj.desiredTokenRewards = message.desiredTokenRewards.map((e) => Math.round(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSignOutOverworld_Player>): CMsgSignOutOverworld_Player {
    return CMsgSignOutOverworld_Player.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSignOutOverworld_Player>): CMsgSignOutOverworld_Player {
    const message = createBaseCMsgSignOutOverworld_Player();
    message.accountId = object.accountId ?? 0;
    message.overworldId = object.overworldId ?? 0;
    message.desiredTokenRewards = object.desiredTokenRewards?.map((e) => e) || [];
    return message;
  },
};

function createBaseCMsgSignOutCraftworks(): CMsgSignOutCraftworks {
  return { players: [], eventId: 0 };
}

export const CMsgSignOutCraftworks = {
  encode(message: CMsgSignOutCraftworks, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.players) {
      CMsgSignOutCraftworks_Player.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.eventId !== undefined && message.eventId !== 0) {
      writer.uint32(16).int32(message.eventId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSignOutCraftworks {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSignOutCraftworks();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.players.push(CMsgSignOutCraftworks_Player.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.eventId = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSignOutCraftworks {
    return {
      players: globalThis.Array.isArray(object?.players)
        ? object.players.map((e: any) => CMsgSignOutCraftworks_Player.fromJSON(e))
        : [],
      eventId: isSet(object.eventId) ? eEventFromJSON(object.eventId) : 0,
    };
  },

  toJSON(message: CMsgSignOutCraftworks): unknown {
    const obj: any = {};
    if (message.players?.length) {
      obj.players = message.players.map((e) => CMsgSignOutCraftworks_Player.toJSON(e));
    }
    if (message.eventId !== undefined && message.eventId !== 0) {
      obj.eventId = eEventToJSON(message.eventId);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSignOutCraftworks>): CMsgSignOutCraftworks {
    return CMsgSignOutCraftworks.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSignOutCraftworks>): CMsgSignOutCraftworks {
    const message = createBaseCMsgSignOutCraftworks();
    message.players = object.players?.map((e) => CMsgSignOutCraftworks_Player.fromPartial(e)) || [];
    message.eventId = object.eventId ?? 0;
    return message;
  },
};

function createBaseCMsgSignOutCraftworks_Player(): CMsgSignOutCraftworks_Player {
  return { accountId: 0, components: undefined };
}

export const CMsgSignOutCraftworks_Player = {
  encode(message: CMsgSignOutCraftworks_Player, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.accountId !== undefined && message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    if (message.components !== undefined) {
      CMsgCraftworksComponents.encode(message.components, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSignOutCraftworks_Player {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSignOutCraftworks_Player();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.components = CMsgCraftworksComponents.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSignOutCraftworks_Player {
    return {
      accountId: isSet(object.accountId) ? globalThis.Number(object.accountId) : 0,
      components: isSet(object.components) ? CMsgCraftworksComponents.fromJSON(object.components) : undefined,
    };
  },

  toJSON(message: CMsgSignOutCraftworks_Player): unknown {
    const obj: any = {};
    if (message.accountId !== undefined && message.accountId !== 0) {
      obj.accountId = Math.round(message.accountId);
    }
    if (message.components !== undefined) {
      obj.components = CMsgCraftworksComponents.toJSON(message.components);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSignOutCraftworks_Player>): CMsgSignOutCraftworks_Player {
    return CMsgSignOutCraftworks_Player.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSignOutCraftworks_Player>): CMsgSignOutCraftworks_Player {
    const message = createBaseCMsgSignOutCraftworks_Player();
    message.accountId = object.accountId ?? 0;
    message.components = (object.components !== undefined && object.components !== null)
      ? CMsgCraftworksComponents.fromPartial(object.components)
      : undefined;
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function longToString(long: Long) {
  return long.toString();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

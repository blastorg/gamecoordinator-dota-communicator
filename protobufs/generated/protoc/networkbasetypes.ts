// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.176.1
//   protoc               v5.26.1
// source: networkbasetypes.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";

export enum SignonStateT {
  SIGNONSTATE_NONE = 0,
  SIGNONSTATE_CHALLENGE = 1,
  SIGNONSTATE_CONNECTED = 2,
  SIGNONSTATE_NEW = 3,
  SIGNONSTATE_PRESPAWN = 4,
  SIGNONSTATE_SPAWN = 5,
  SIGNONSTATE_FULL = 6,
  SIGNONSTATE_CHANGELEVEL = 7,
}

export function signonStateTFromJSON(object: any): SignonStateT {
  switch (object) {
    case 0:
    case "SIGNONSTATE_NONE":
      return SignonStateT.SIGNONSTATE_NONE;
    case 1:
    case "SIGNONSTATE_CHALLENGE":
      return SignonStateT.SIGNONSTATE_CHALLENGE;
    case 2:
    case "SIGNONSTATE_CONNECTED":
      return SignonStateT.SIGNONSTATE_CONNECTED;
    case 3:
    case "SIGNONSTATE_NEW":
      return SignonStateT.SIGNONSTATE_NEW;
    case 4:
    case "SIGNONSTATE_PRESPAWN":
      return SignonStateT.SIGNONSTATE_PRESPAWN;
    case 5:
    case "SIGNONSTATE_SPAWN":
      return SignonStateT.SIGNONSTATE_SPAWN;
    case 6:
    case "SIGNONSTATE_FULL":
      return SignonStateT.SIGNONSTATE_FULL;
    case 7:
    case "SIGNONSTATE_CHANGELEVEL":
      return SignonStateT.SIGNONSTATE_CHANGELEVEL;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum SignonStateT");
  }
}

export function signonStateTToJSON(object: SignonStateT): string {
  switch (object) {
    case SignonStateT.SIGNONSTATE_NONE:
      return "SIGNONSTATE_NONE";
    case SignonStateT.SIGNONSTATE_CHALLENGE:
      return "SIGNONSTATE_CHALLENGE";
    case SignonStateT.SIGNONSTATE_CONNECTED:
      return "SIGNONSTATE_CONNECTED";
    case SignonStateT.SIGNONSTATE_NEW:
      return "SIGNONSTATE_NEW";
    case SignonStateT.SIGNONSTATE_PRESPAWN:
      return "SIGNONSTATE_PRESPAWN";
    case SignonStateT.SIGNONSTATE_SPAWN:
      return "SIGNONSTATE_SPAWN";
    case SignonStateT.SIGNONSTATE_FULL:
      return "SIGNONSTATE_FULL";
    case SignonStateT.SIGNONSTATE_CHANGELEVEL:
      return "SIGNONSTATE_CHANGELEVEL";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum SignonStateT");
  }
}

export enum NETMessages {
  net_NOP = 0,
  net_Disconnect_Legacy = 1,
  net_SplitScreenUser = 3,
  net_Tick = 4,
  net_StringCmd = 5,
  net_SetConVar = 6,
  net_SignonState = 7,
  net_SpawnGroup_Load = 8,
  net_SpawnGroup_ManifestUpdate = 9,
  net_SpawnGroup_SetCreationTick = 11,
  net_SpawnGroup_Unload = 12,
  net_SpawnGroup_LoadCompleted = 13,
  net_DebugOverlay = 15,
}

export function nETMessagesFromJSON(object: any): NETMessages {
  switch (object) {
    case 0:
    case "net_NOP":
      return NETMessages.net_NOP;
    case 1:
    case "net_Disconnect_Legacy":
      return NETMessages.net_Disconnect_Legacy;
    case 3:
    case "net_SplitScreenUser":
      return NETMessages.net_SplitScreenUser;
    case 4:
    case "net_Tick":
      return NETMessages.net_Tick;
    case 5:
    case "net_StringCmd":
      return NETMessages.net_StringCmd;
    case 6:
    case "net_SetConVar":
      return NETMessages.net_SetConVar;
    case 7:
    case "net_SignonState":
      return NETMessages.net_SignonState;
    case 8:
    case "net_SpawnGroup_Load":
      return NETMessages.net_SpawnGroup_Load;
    case 9:
    case "net_SpawnGroup_ManifestUpdate":
      return NETMessages.net_SpawnGroup_ManifestUpdate;
    case 11:
    case "net_SpawnGroup_SetCreationTick":
      return NETMessages.net_SpawnGroup_SetCreationTick;
    case 12:
    case "net_SpawnGroup_Unload":
      return NETMessages.net_SpawnGroup_Unload;
    case 13:
    case "net_SpawnGroup_LoadCompleted":
      return NETMessages.net_SpawnGroup_LoadCompleted;
    case 15:
    case "net_DebugOverlay":
      return NETMessages.net_DebugOverlay;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum NETMessages");
  }
}

export function nETMessagesToJSON(object: NETMessages): string {
  switch (object) {
    case NETMessages.net_NOP:
      return "net_NOP";
    case NETMessages.net_Disconnect_Legacy:
      return "net_Disconnect_Legacy";
    case NETMessages.net_SplitScreenUser:
      return "net_SplitScreenUser";
    case NETMessages.net_Tick:
      return "net_Tick";
    case NETMessages.net_StringCmd:
      return "net_StringCmd";
    case NETMessages.net_SetConVar:
      return "net_SetConVar";
    case NETMessages.net_SignonState:
      return "net_SignonState";
    case NETMessages.net_SpawnGroup_Load:
      return "net_SpawnGroup_Load";
    case NETMessages.net_SpawnGroup_ManifestUpdate:
      return "net_SpawnGroup_ManifestUpdate";
    case NETMessages.net_SpawnGroup_SetCreationTick:
      return "net_SpawnGroup_SetCreationTick";
    case NETMessages.net_SpawnGroup_Unload:
      return "net_SpawnGroup_Unload";
    case NETMessages.net_SpawnGroup_LoadCompleted:
      return "net_SpawnGroup_LoadCompleted";
    case NETMessages.net_DebugOverlay:
      return "net_DebugOverlay";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum NETMessages");
  }
}

export enum SpawnGroupFlagsT {
  SPAWN_GROUP_LOAD_ENTITIES_FROM_SAVE = 1,
  SPAWN_GROUP_DONT_SPAWN_ENTITIES = 2,
  SPAWN_GROUP_SYNCHRONOUS_SPAWN = 4,
  SPAWN_GROUP_IS_INITIAL_SPAWN_GROUP = 8,
  SPAWN_GROUP_CREATE_CLIENT_ONLY_ENTITIES = 16,
  SPAWN_GROUP_BLOCK_UNTIL_LOADED = 64,
  SPAWN_GROUP_LOAD_STREAMING_DATA = 128,
  SPAWN_GROUP_CREATE_NEW_SCENE_WORLD = 256,
}

export function spawnGroupFlagsTFromJSON(object: any): SpawnGroupFlagsT {
  switch (object) {
    case 1:
    case "SPAWN_GROUP_LOAD_ENTITIES_FROM_SAVE":
      return SpawnGroupFlagsT.SPAWN_GROUP_LOAD_ENTITIES_FROM_SAVE;
    case 2:
    case "SPAWN_GROUP_DONT_SPAWN_ENTITIES":
      return SpawnGroupFlagsT.SPAWN_GROUP_DONT_SPAWN_ENTITIES;
    case 4:
    case "SPAWN_GROUP_SYNCHRONOUS_SPAWN":
      return SpawnGroupFlagsT.SPAWN_GROUP_SYNCHRONOUS_SPAWN;
    case 8:
    case "SPAWN_GROUP_IS_INITIAL_SPAWN_GROUP":
      return SpawnGroupFlagsT.SPAWN_GROUP_IS_INITIAL_SPAWN_GROUP;
    case 16:
    case "SPAWN_GROUP_CREATE_CLIENT_ONLY_ENTITIES":
      return SpawnGroupFlagsT.SPAWN_GROUP_CREATE_CLIENT_ONLY_ENTITIES;
    case 64:
    case "SPAWN_GROUP_BLOCK_UNTIL_LOADED":
      return SpawnGroupFlagsT.SPAWN_GROUP_BLOCK_UNTIL_LOADED;
    case 128:
    case "SPAWN_GROUP_LOAD_STREAMING_DATA":
      return SpawnGroupFlagsT.SPAWN_GROUP_LOAD_STREAMING_DATA;
    case 256:
    case "SPAWN_GROUP_CREATE_NEW_SCENE_WORLD":
      return SpawnGroupFlagsT.SPAWN_GROUP_CREATE_NEW_SCENE_WORLD;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum SpawnGroupFlagsT");
  }
}

export function spawnGroupFlagsTToJSON(object: SpawnGroupFlagsT): string {
  switch (object) {
    case SpawnGroupFlagsT.SPAWN_GROUP_LOAD_ENTITIES_FROM_SAVE:
      return "SPAWN_GROUP_LOAD_ENTITIES_FROM_SAVE";
    case SpawnGroupFlagsT.SPAWN_GROUP_DONT_SPAWN_ENTITIES:
      return "SPAWN_GROUP_DONT_SPAWN_ENTITIES";
    case SpawnGroupFlagsT.SPAWN_GROUP_SYNCHRONOUS_SPAWN:
      return "SPAWN_GROUP_SYNCHRONOUS_SPAWN";
    case SpawnGroupFlagsT.SPAWN_GROUP_IS_INITIAL_SPAWN_GROUP:
      return "SPAWN_GROUP_IS_INITIAL_SPAWN_GROUP";
    case SpawnGroupFlagsT.SPAWN_GROUP_CREATE_CLIENT_ONLY_ENTITIES:
      return "SPAWN_GROUP_CREATE_CLIENT_ONLY_ENTITIES";
    case SpawnGroupFlagsT.SPAWN_GROUP_BLOCK_UNTIL_LOADED:
      return "SPAWN_GROUP_BLOCK_UNTIL_LOADED";
    case SpawnGroupFlagsT.SPAWN_GROUP_LOAD_STREAMING_DATA:
      return "SPAWN_GROUP_LOAD_STREAMING_DATA";
    case SpawnGroupFlagsT.SPAWN_GROUP_CREATE_NEW_SCENE_WORLD:
      return "SPAWN_GROUP_CREATE_NEW_SCENE_WORLD";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum SpawnGroupFlagsT");
  }
}

export interface CMsgVector {
  x?: number | undefined;
  y?: number | undefined;
  z?: number | undefined;
  w?: number | undefined;
}

export interface CMsgVector2D {
  x?: number | undefined;
  y?: number | undefined;
}

export interface CMsgQAngle {
  x?: number | undefined;
  y?: number | undefined;
  z?: number | undefined;
}

export interface CMsgQuaternion {
  x?: number | undefined;
  y?: number | undefined;
  z?: number | undefined;
  w?: number | undefined;
}

export interface CMsgTransform {
  position?: CMsgVector | undefined;
  scale?: number | undefined;
  orientation?: CMsgQuaternion | undefined;
}

export interface CMsgRGBA {
  r?: number | undefined;
  g?: number | undefined;
  b?: number | undefined;
  a?: number | undefined;
}

export interface CMsgPlayerInfo {
  name?: string | undefined;
  xuid?: string | undefined;
  userid?: number | undefined;
  steamid?: string | undefined;
  fakeplayer?: boolean | undefined;
  ishltv?: boolean | undefined;
}

export interface CEntityMsg {
  targetEntity?: number | undefined;
}

export interface CMsgCVars {
  cvars: CMsgCVars_CVar[];
}

export interface CMsgCVars_CVar {
  name?: string | undefined;
  value?: string | undefined;
}

export interface CNETMsgNOP {
}

export interface CNETMsgSplitScreenUser {
  slot?: number | undefined;
}

export interface CNETMsgTick {
  tick?: number | undefined;
  hostComputationtime?: number | undefined;
  hostComputationtimeStdDeviation?: number | undefined;
  legacyHostLoss?: number | undefined;
  hostUnfilteredFrametime?: number | undefined;
  hltvReplayFlags?: number | undefined;
  expectedLongTick?: number | undefined;
  expectedLongTickReason?: string | undefined;
  hostFrameDroppedPctX10?: number | undefined;
  hostFrameIrregularArrivalPctX10?: number | undefined;
}

export interface CNETMsgStringCmd {
  command?: string | undefined;
  predictionSync?: number | undefined;
}

export interface CNETMsgSetConVar {
  convars?: CMsgCVars | undefined;
}

export interface CNETMsgSignonState {
  signonState?: SignonStateT | undefined;
  spawnCount?: number | undefined;
  numServerPlayers?: number | undefined;
  playersNetworkids: string[];
  mapName?: string | undefined;
  addons?: string | undefined;
}

export interface CSVCMsgGameEvent {
  eventName?: string | undefined;
  eventid?: number | undefined;
  keys: CSVCMsgGameEvent_keyT[];
}

export interface CSVCMsgGameEvent_keyT {
  type?: number | undefined;
  valString?: string | undefined;
  valFloat?: number | undefined;
  valLong?: number | undefined;
  valShort?: number | undefined;
  valByte?: number | undefined;
  valBool?: boolean | undefined;
  valUint64?: string | undefined;
}

export interface CSVCMsgListGameEvents {
  events: CSVCMsgListGameEvents_eventT[];
}

export interface CSVCMsgListGameEvents_eventT {
  tick?: number | undefined;
  event?: CSVCMsgGameEvent | undefined;
}

export interface CNETMsgSpawnGroupLoad {
  worldname?: string | undefined;
  entitylumpname?: string | undefined;
  entityfiltername?: string | undefined;
  spawngrouphandle?: number | undefined;
  spawngroupownerhandle?: number | undefined;
  worldOffsetPos?: CMsgVector | undefined;
  worldOffsetAngle?: CMsgQAngle | undefined;
  spawngroupmanifest?: Buffer | undefined;
  flags?: number | undefined;
  tickcount?: number | undefined;
  manifestincomplete?: boolean | undefined;
  localnamefixup?: string | undefined;
  parentnamefixup?: string | undefined;
  manifestloadpriority?: number | undefined;
  worldgroupid?: number | undefined;
  creationsequence?: number | undefined;
  savegamefilename?: string | undefined;
  spawngroupparenthandle?: number | undefined;
  leveltransition?: boolean | undefined;
  worldgroupname?: string | undefined;
}

export interface CNETMsgSpawnGroupManifestUpdate {
  spawngrouphandle?: number | undefined;
  spawngroupmanifest?: Buffer | undefined;
  manifestincomplete?: boolean | undefined;
}

export interface CNETMsgSpawnGroupSetCreationTick {
  spawngrouphandle?: number | undefined;
  tickcount?: number | undefined;
  creationsequence?: number | undefined;
}

export interface CNETMsgSpawnGroupUnload {
  spawngrouphandle?: number | undefined;
  flags?: number | undefined;
  tickcount?: number | undefined;
}

export interface CNETMsgSpawnGroupLoadCompleted {
  spawngrouphandle?: number | undefined;
}

export interface CSVCMsgGameSessionConfiguration {
  isMultiplayer?: boolean | undefined;
  isLoadsavegame?: boolean | undefined;
  isBackgroundMap?: boolean | undefined;
  isHeadless?: boolean | undefined;
  minClientLimit?: number | undefined;
  maxClientLimit?: number | undefined;
  maxClients?: number | undefined;
  tickInterval?: number | undefined;
  hostname?: string | undefined;
  savegamename?: string | undefined;
  s1Mapname?: string | undefined;
  gamemode?: string | undefined;
  serverIpAddress?: string | undefined;
  data?: Buffer | undefined;
  isLocalonly?: boolean | undefined;
  noSteamServer?: boolean | undefined;
  isTransition?: boolean | undefined;
  previouslevel?: string | undefined;
  landmarkname?: string | undefined;
}

export interface CNETMsgDebugOverlay {
  etype?: number | undefined;
  vectors: CMsgVector[];
  colors: CMsgRGBA[];
  dimensions: number[];
  times: number[];
  bools: boolean[];
  uint64s: string[];
  strings: string[];
}

function createBaseCMsgVector(): CMsgVector {
  return { x: 0, y: 0, z: 0, w: 0 };
}

export const CMsgVector = {
  encode(message: CMsgVector, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.x !== undefined && message.x !== 0) {
      writer.uint32(13).float(message.x);
    }
    if (message.y !== undefined && message.y !== 0) {
      writer.uint32(21).float(message.y);
    }
    if (message.z !== undefined && message.z !== 0) {
      writer.uint32(29).float(message.z);
    }
    if (message.w !== undefined && message.w !== 0) {
      writer.uint32(37).float(message.w);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgVector {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgVector();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.x = reader.float();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.y = reader.float();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.z = reader.float();
          continue;
        case 4:
          if (tag !== 37) {
            break;
          }

          message.w = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgVector {
    return {
      x: isSet(object.x) ? globalThis.Number(object.x) : 0,
      y: isSet(object.y) ? globalThis.Number(object.y) : 0,
      z: isSet(object.z) ? globalThis.Number(object.z) : 0,
      w: isSet(object.w) ? globalThis.Number(object.w) : 0,
    };
  },

  toJSON(message: CMsgVector): unknown {
    const obj: any = {};
    if (message.x !== undefined && message.x !== 0) {
      obj.x = message.x;
    }
    if (message.y !== undefined && message.y !== 0) {
      obj.y = message.y;
    }
    if (message.z !== undefined && message.z !== 0) {
      obj.z = message.z;
    }
    if (message.w !== undefined && message.w !== 0) {
      obj.w = message.w;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgVector>): CMsgVector {
    return CMsgVector.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgVector>): CMsgVector {
    const message = createBaseCMsgVector();
    message.x = object.x ?? 0;
    message.y = object.y ?? 0;
    message.z = object.z ?? 0;
    message.w = object.w ?? 0;
    return message;
  },
};

function createBaseCMsgVector2D(): CMsgVector2D {
  return { x: 0, y: 0 };
}

export const CMsgVector2D = {
  encode(message: CMsgVector2D, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.x !== undefined && message.x !== 0) {
      writer.uint32(13).float(message.x);
    }
    if (message.y !== undefined && message.y !== 0) {
      writer.uint32(21).float(message.y);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgVector2D {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgVector2D();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.x = reader.float();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.y = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgVector2D {
    return {
      x: isSet(object.x) ? globalThis.Number(object.x) : 0,
      y: isSet(object.y) ? globalThis.Number(object.y) : 0,
    };
  },

  toJSON(message: CMsgVector2D): unknown {
    const obj: any = {};
    if (message.x !== undefined && message.x !== 0) {
      obj.x = message.x;
    }
    if (message.y !== undefined && message.y !== 0) {
      obj.y = message.y;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgVector2D>): CMsgVector2D {
    return CMsgVector2D.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgVector2D>): CMsgVector2D {
    const message = createBaseCMsgVector2D();
    message.x = object.x ?? 0;
    message.y = object.y ?? 0;
    return message;
  },
};

function createBaseCMsgQAngle(): CMsgQAngle {
  return { x: 0, y: 0, z: 0 };
}

export const CMsgQAngle = {
  encode(message: CMsgQAngle, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.x !== undefined && message.x !== 0) {
      writer.uint32(13).float(message.x);
    }
    if (message.y !== undefined && message.y !== 0) {
      writer.uint32(21).float(message.y);
    }
    if (message.z !== undefined && message.z !== 0) {
      writer.uint32(29).float(message.z);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgQAngle {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgQAngle();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.x = reader.float();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.y = reader.float();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.z = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgQAngle {
    return {
      x: isSet(object.x) ? globalThis.Number(object.x) : 0,
      y: isSet(object.y) ? globalThis.Number(object.y) : 0,
      z: isSet(object.z) ? globalThis.Number(object.z) : 0,
    };
  },

  toJSON(message: CMsgQAngle): unknown {
    const obj: any = {};
    if (message.x !== undefined && message.x !== 0) {
      obj.x = message.x;
    }
    if (message.y !== undefined && message.y !== 0) {
      obj.y = message.y;
    }
    if (message.z !== undefined && message.z !== 0) {
      obj.z = message.z;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgQAngle>): CMsgQAngle {
    return CMsgQAngle.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgQAngle>): CMsgQAngle {
    const message = createBaseCMsgQAngle();
    message.x = object.x ?? 0;
    message.y = object.y ?? 0;
    message.z = object.z ?? 0;
    return message;
  },
};

function createBaseCMsgQuaternion(): CMsgQuaternion {
  return { x: 0, y: 0, z: 0, w: 0 };
}

export const CMsgQuaternion = {
  encode(message: CMsgQuaternion, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.x !== undefined && message.x !== 0) {
      writer.uint32(13).float(message.x);
    }
    if (message.y !== undefined && message.y !== 0) {
      writer.uint32(21).float(message.y);
    }
    if (message.z !== undefined && message.z !== 0) {
      writer.uint32(29).float(message.z);
    }
    if (message.w !== undefined && message.w !== 0) {
      writer.uint32(37).float(message.w);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgQuaternion {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgQuaternion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.x = reader.float();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.y = reader.float();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.z = reader.float();
          continue;
        case 4:
          if (tag !== 37) {
            break;
          }

          message.w = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgQuaternion {
    return {
      x: isSet(object.x) ? globalThis.Number(object.x) : 0,
      y: isSet(object.y) ? globalThis.Number(object.y) : 0,
      z: isSet(object.z) ? globalThis.Number(object.z) : 0,
      w: isSet(object.w) ? globalThis.Number(object.w) : 0,
    };
  },

  toJSON(message: CMsgQuaternion): unknown {
    const obj: any = {};
    if (message.x !== undefined && message.x !== 0) {
      obj.x = message.x;
    }
    if (message.y !== undefined && message.y !== 0) {
      obj.y = message.y;
    }
    if (message.z !== undefined && message.z !== 0) {
      obj.z = message.z;
    }
    if (message.w !== undefined && message.w !== 0) {
      obj.w = message.w;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgQuaternion>): CMsgQuaternion {
    return CMsgQuaternion.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgQuaternion>): CMsgQuaternion {
    const message = createBaseCMsgQuaternion();
    message.x = object.x ?? 0;
    message.y = object.y ?? 0;
    message.z = object.z ?? 0;
    message.w = object.w ?? 0;
    return message;
  },
};

function createBaseCMsgTransform(): CMsgTransform {
  return { position: undefined, scale: 0, orientation: undefined };
}

export const CMsgTransform = {
  encode(message: CMsgTransform, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.position !== undefined) {
      CMsgVector.encode(message.position, writer.uint32(10).fork()).ldelim();
    }
    if (message.scale !== undefined && message.scale !== 0) {
      writer.uint32(21).float(message.scale);
    }
    if (message.orientation !== undefined) {
      CMsgQuaternion.encode(message.orientation, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgTransform {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgTransform();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.position = CMsgVector.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.scale = reader.float();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.orientation = CMsgQuaternion.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgTransform {
    return {
      position: isSet(object.position) ? CMsgVector.fromJSON(object.position) : undefined,
      scale: isSet(object.scale) ? globalThis.Number(object.scale) : 0,
      orientation: isSet(object.orientation) ? CMsgQuaternion.fromJSON(object.orientation) : undefined,
    };
  },

  toJSON(message: CMsgTransform): unknown {
    const obj: any = {};
    if (message.position !== undefined) {
      obj.position = CMsgVector.toJSON(message.position);
    }
    if (message.scale !== undefined && message.scale !== 0) {
      obj.scale = message.scale;
    }
    if (message.orientation !== undefined) {
      obj.orientation = CMsgQuaternion.toJSON(message.orientation);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgTransform>): CMsgTransform {
    return CMsgTransform.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgTransform>): CMsgTransform {
    const message = createBaseCMsgTransform();
    message.position = (object.position !== undefined && object.position !== null)
      ? CMsgVector.fromPartial(object.position)
      : undefined;
    message.scale = object.scale ?? 0;
    message.orientation = (object.orientation !== undefined && object.orientation !== null)
      ? CMsgQuaternion.fromPartial(object.orientation)
      : undefined;
    return message;
  },
};

function createBaseCMsgRGBA(): CMsgRGBA {
  return { r: 0, g: 0, b: 0, a: 0 };
}

export const CMsgRGBA = {
  encode(message: CMsgRGBA, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.r !== undefined && message.r !== 0) {
      writer.uint32(8).int32(message.r);
    }
    if (message.g !== undefined && message.g !== 0) {
      writer.uint32(16).int32(message.g);
    }
    if (message.b !== undefined && message.b !== 0) {
      writer.uint32(24).int32(message.b);
    }
    if (message.a !== undefined && message.a !== 0) {
      writer.uint32(32).int32(message.a);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgRGBA {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgRGBA();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.r = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.g = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.b = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.a = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgRGBA {
    return {
      r: isSet(object.r) ? globalThis.Number(object.r) : 0,
      g: isSet(object.g) ? globalThis.Number(object.g) : 0,
      b: isSet(object.b) ? globalThis.Number(object.b) : 0,
      a: isSet(object.a) ? globalThis.Number(object.a) : 0,
    };
  },

  toJSON(message: CMsgRGBA): unknown {
    const obj: any = {};
    if (message.r !== undefined && message.r !== 0) {
      obj.r = Math.round(message.r);
    }
    if (message.g !== undefined && message.g !== 0) {
      obj.g = Math.round(message.g);
    }
    if (message.b !== undefined && message.b !== 0) {
      obj.b = Math.round(message.b);
    }
    if (message.a !== undefined && message.a !== 0) {
      obj.a = Math.round(message.a);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgRGBA>): CMsgRGBA {
    return CMsgRGBA.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgRGBA>): CMsgRGBA {
    const message = createBaseCMsgRGBA();
    message.r = object.r ?? 0;
    message.g = object.g ?? 0;
    message.b = object.b ?? 0;
    message.a = object.a ?? 0;
    return message;
  },
};

function createBaseCMsgPlayerInfo(): CMsgPlayerInfo {
  return { name: "", xuid: "0", userid: 0, steamid: "0", fakeplayer: false, ishltv: false };
}

export const CMsgPlayerInfo = {
  encode(message: CMsgPlayerInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.xuid !== undefined && message.xuid !== "0") {
      writer.uint32(17).fixed64(message.xuid);
    }
    if (message.userid !== undefined && message.userid !== 0) {
      writer.uint32(24).int32(message.userid);
    }
    if (message.steamid !== undefined && message.steamid !== "0") {
      writer.uint32(33).fixed64(message.steamid);
    }
    if (message.fakeplayer !== undefined && message.fakeplayer !== false) {
      writer.uint32(40).bool(message.fakeplayer);
    }
    if (message.ishltv !== undefined && message.ishltv !== false) {
      writer.uint32(48).bool(message.ishltv);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgPlayerInfo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgPlayerInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.xuid = longToString(reader.fixed64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.userid = reader.int32();
          continue;
        case 4:
          if (tag !== 33) {
            break;
          }

          message.steamid = longToString(reader.fixed64() as Long);
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.fakeplayer = reader.bool();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.ishltv = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgPlayerInfo {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      xuid: isSet(object.xuid) ? globalThis.String(object.xuid) : "0",
      userid: isSet(object.userid) ? globalThis.Number(object.userid) : 0,
      steamid: isSet(object.steamid) ? globalThis.String(object.steamid) : "0",
      fakeplayer: isSet(object.fakeplayer) ? globalThis.Boolean(object.fakeplayer) : false,
      ishltv: isSet(object.ishltv) ? globalThis.Boolean(object.ishltv) : false,
    };
  },

  toJSON(message: CMsgPlayerInfo): unknown {
    const obj: any = {};
    if (message.name !== undefined && message.name !== "") {
      obj.name = message.name;
    }
    if (message.xuid !== undefined && message.xuid !== "0") {
      obj.xuid = message.xuid;
    }
    if (message.userid !== undefined && message.userid !== 0) {
      obj.userid = Math.round(message.userid);
    }
    if (message.steamid !== undefined && message.steamid !== "0") {
      obj.steamid = message.steamid;
    }
    if (message.fakeplayer !== undefined && message.fakeplayer !== false) {
      obj.fakeplayer = message.fakeplayer;
    }
    if (message.ishltv !== undefined && message.ishltv !== false) {
      obj.ishltv = message.ishltv;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgPlayerInfo>): CMsgPlayerInfo {
    return CMsgPlayerInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgPlayerInfo>): CMsgPlayerInfo {
    const message = createBaseCMsgPlayerInfo();
    message.name = object.name ?? "";
    message.xuid = object.xuid ?? "0";
    message.userid = object.userid ?? 0;
    message.steamid = object.steamid ?? "0";
    message.fakeplayer = object.fakeplayer ?? false;
    message.ishltv = object.ishltv ?? false;
    return message;
  },
};

function createBaseCEntityMsg(): CEntityMsg {
  return { targetEntity: 16777215 };
}

export const CEntityMsg = {
  encode(message: CEntityMsg, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.targetEntity !== undefined && message.targetEntity !== 16777215) {
      writer.uint32(8).uint32(message.targetEntity);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CEntityMsg {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCEntityMsg();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.targetEntity = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CEntityMsg {
    return { targetEntity: isSet(object.targetEntity) ? globalThis.Number(object.targetEntity) : 16777215 };
  },

  toJSON(message: CEntityMsg): unknown {
    const obj: any = {};
    if (message.targetEntity !== undefined && message.targetEntity !== 16777215) {
      obj.targetEntity = Math.round(message.targetEntity);
    }
    return obj;
  },

  create(base?: DeepPartial<CEntityMsg>): CEntityMsg {
    return CEntityMsg.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CEntityMsg>): CEntityMsg {
    const message = createBaseCEntityMsg();
    message.targetEntity = object.targetEntity ?? 16777215;
    return message;
  },
};

function createBaseCMsgCVars(): CMsgCVars {
  return { cvars: [] };
}

export const CMsgCVars = {
  encode(message: CMsgCVars, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.cvars) {
      CMsgCVars_CVar.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgCVars {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgCVars();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.cvars.push(CMsgCVars_CVar.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgCVars {
    return {
      cvars: globalThis.Array.isArray(object?.cvars) ? object.cvars.map((e: any) => CMsgCVars_CVar.fromJSON(e)) : [],
    };
  },

  toJSON(message: CMsgCVars): unknown {
    const obj: any = {};
    if (message.cvars?.length) {
      obj.cvars = message.cvars.map((e) => CMsgCVars_CVar.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgCVars>): CMsgCVars {
    return CMsgCVars.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgCVars>): CMsgCVars {
    const message = createBaseCMsgCVars();
    message.cvars = object.cvars?.map((e) => CMsgCVars_CVar.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgCVars_CVar(): CMsgCVars_CVar {
  return { name: "", value: "" };
}

export const CMsgCVars_CVar = {
  encode(message: CMsgCVars_CVar, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.value !== undefined && message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgCVars_CVar {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgCVars_CVar();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgCVars_CVar {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: CMsgCVars_CVar): unknown {
    const obj: any = {};
    if (message.name !== undefined && message.name !== "") {
      obj.name = message.name;
    }
    if (message.value !== undefined && message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgCVars_CVar>): CMsgCVars_CVar {
    return CMsgCVars_CVar.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgCVars_CVar>): CMsgCVars_CVar {
    const message = createBaseCMsgCVars_CVar();
    message.name = object.name ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseCNETMsgNOP(): CNETMsgNOP {
  return {};
}

export const CNETMsgNOP = {
  encode(_: CNETMsgNOP, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CNETMsgNOP {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCNETMsgNOP();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CNETMsgNOP {
    return {};
  },

  toJSON(_: CNETMsgNOP): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<CNETMsgNOP>): CNETMsgNOP {
    return CNETMsgNOP.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<CNETMsgNOP>): CNETMsgNOP {
    const message = createBaseCNETMsgNOP();
    return message;
  },
};

function createBaseCNETMsgSplitScreenUser(): CNETMsgSplitScreenUser {
  return { slot: 0 };
}

export const CNETMsgSplitScreenUser = {
  encode(message: CNETMsgSplitScreenUser, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.slot !== undefined && message.slot !== 0) {
      writer.uint32(8).int32(message.slot);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CNETMsgSplitScreenUser {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCNETMsgSplitScreenUser();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.slot = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CNETMsgSplitScreenUser {
    return { slot: isSet(object.slot) ? globalThis.Number(object.slot) : 0 };
  },

  toJSON(message: CNETMsgSplitScreenUser): unknown {
    const obj: any = {};
    if (message.slot !== undefined && message.slot !== 0) {
      obj.slot = Math.round(message.slot);
    }
    return obj;
  },

  create(base?: DeepPartial<CNETMsgSplitScreenUser>): CNETMsgSplitScreenUser {
    return CNETMsgSplitScreenUser.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CNETMsgSplitScreenUser>): CNETMsgSplitScreenUser {
    const message = createBaseCNETMsgSplitScreenUser();
    message.slot = object.slot ?? 0;
    return message;
  },
};

function createBaseCNETMsgTick(): CNETMsgTick {
  return {
    tick: 0,
    hostComputationtime: 0,
    hostComputationtimeStdDeviation: 0,
    legacyHostLoss: 0,
    hostUnfilteredFrametime: 0,
    hltvReplayFlags: 0,
    expectedLongTick: 0,
    expectedLongTickReason: "",
    hostFrameDroppedPctX10: 0,
    hostFrameIrregularArrivalPctX10: 0,
  };
}

export const CNETMsgTick = {
  encode(message: CNETMsgTick, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.tick !== undefined && message.tick !== 0) {
      writer.uint32(8).uint32(message.tick);
    }
    if (message.hostComputationtime !== undefined && message.hostComputationtime !== 0) {
      writer.uint32(32).uint32(message.hostComputationtime);
    }
    if (message.hostComputationtimeStdDeviation !== undefined && message.hostComputationtimeStdDeviation !== 0) {
      writer.uint32(40).uint32(message.hostComputationtimeStdDeviation);
    }
    if (message.legacyHostLoss !== undefined && message.legacyHostLoss !== 0) {
      writer.uint32(56).uint32(message.legacyHostLoss);
    }
    if (message.hostUnfilteredFrametime !== undefined && message.hostUnfilteredFrametime !== 0) {
      writer.uint32(64).uint32(message.hostUnfilteredFrametime);
    }
    if (message.hltvReplayFlags !== undefined && message.hltvReplayFlags !== 0) {
      writer.uint32(72).uint32(message.hltvReplayFlags);
    }
    if (message.expectedLongTick !== undefined && message.expectedLongTick !== 0) {
      writer.uint32(80).uint32(message.expectedLongTick);
    }
    if (message.expectedLongTickReason !== undefined && message.expectedLongTickReason !== "") {
      writer.uint32(90).string(message.expectedLongTickReason);
    }
    if (message.hostFrameDroppedPctX10 !== undefined && message.hostFrameDroppedPctX10 !== 0) {
      writer.uint32(96).uint32(message.hostFrameDroppedPctX10);
    }
    if (message.hostFrameIrregularArrivalPctX10 !== undefined && message.hostFrameIrregularArrivalPctX10 !== 0) {
      writer.uint32(104).uint32(message.hostFrameIrregularArrivalPctX10);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CNETMsgTick {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCNETMsgTick();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.tick = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.hostComputationtime = reader.uint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.hostComputationtimeStdDeviation = reader.uint32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.legacyHostLoss = reader.uint32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.hostUnfilteredFrametime = reader.uint32();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.hltvReplayFlags = reader.uint32();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.expectedLongTick = reader.uint32();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.expectedLongTickReason = reader.string();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.hostFrameDroppedPctX10 = reader.uint32();
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.hostFrameIrregularArrivalPctX10 = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CNETMsgTick {
    return {
      tick: isSet(object.tick) ? globalThis.Number(object.tick) : 0,
      hostComputationtime: isSet(object.hostComputationtime) ? globalThis.Number(object.hostComputationtime) : 0,
      hostComputationtimeStdDeviation: isSet(object.hostComputationtimeStdDeviation)
        ? globalThis.Number(object.hostComputationtimeStdDeviation)
        : 0,
      legacyHostLoss: isSet(object.legacyHostLoss) ? globalThis.Number(object.legacyHostLoss) : 0,
      hostUnfilteredFrametime: isSet(object.hostUnfilteredFrametime)
        ? globalThis.Number(object.hostUnfilteredFrametime)
        : 0,
      hltvReplayFlags: isSet(object.hltvReplayFlags) ? globalThis.Number(object.hltvReplayFlags) : 0,
      expectedLongTick: isSet(object.expectedLongTick) ? globalThis.Number(object.expectedLongTick) : 0,
      expectedLongTickReason: isSet(object.expectedLongTickReason)
        ? globalThis.String(object.expectedLongTickReason)
        : "",
      hostFrameDroppedPctX10: isSet(object.hostFrameDroppedPctX10)
        ? globalThis.Number(object.hostFrameDroppedPctX10)
        : 0,
      hostFrameIrregularArrivalPctX10: isSet(object.hostFrameIrregularArrivalPctX10)
        ? globalThis.Number(object.hostFrameIrregularArrivalPctX10)
        : 0,
    };
  },

  toJSON(message: CNETMsgTick): unknown {
    const obj: any = {};
    if (message.tick !== undefined && message.tick !== 0) {
      obj.tick = Math.round(message.tick);
    }
    if (message.hostComputationtime !== undefined && message.hostComputationtime !== 0) {
      obj.hostComputationtime = Math.round(message.hostComputationtime);
    }
    if (message.hostComputationtimeStdDeviation !== undefined && message.hostComputationtimeStdDeviation !== 0) {
      obj.hostComputationtimeStdDeviation = Math.round(message.hostComputationtimeStdDeviation);
    }
    if (message.legacyHostLoss !== undefined && message.legacyHostLoss !== 0) {
      obj.legacyHostLoss = Math.round(message.legacyHostLoss);
    }
    if (message.hostUnfilteredFrametime !== undefined && message.hostUnfilteredFrametime !== 0) {
      obj.hostUnfilteredFrametime = Math.round(message.hostUnfilteredFrametime);
    }
    if (message.hltvReplayFlags !== undefined && message.hltvReplayFlags !== 0) {
      obj.hltvReplayFlags = Math.round(message.hltvReplayFlags);
    }
    if (message.expectedLongTick !== undefined && message.expectedLongTick !== 0) {
      obj.expectedLongTick = Math.round(message.expectedLongTick);
    }
    if (message.expectedLongTickReason !== undefined && message.expectedLongTickReason !== "") {
      obj.expectedLongTickReason = message.expectedLongTickReason;
    }
    if (message.hostFrameDroppedPctX10 !== undefined && message.hostFrameDroppedPctX10 !== 0) {
      obj.hostFrameDroppedPctX10 = Math.round(message.hostFrameDroppedPctX10);
    }
    if (message.hostFrameIrregularArrivalPctX10 !== undefined && message.hostFrameIrregularArrivalPctX10 !== 0) {
      obj.hostFrameIrregularArrivalPctX10 = Math.round(message.hostFrameIrregularArrivalPctX10);
    }
    return obj;
  },

  create(base?: DeepPartial<CNETMsgTick>): CNETMsgTick {
    return CNETMsgTick.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CNETMsgTick>): CNETMsgTick {
    const message = createBaseCNETMsgTick();
    message.tick = object.tick ?? 0;
    message.hostComputationtime = object.hostComputationtime ?? 0;
    message.hostComputationtimeStdDeviation = object.hostComputationtimeStdDeviation ?? 0;
    message.legacyHostLoss = object.legacyHostLoss ?? 0;
    message.hostUnfilteredFrametime = object.hostUnfilteredFrametime ?? 0;
    message.hltvReplayFlags = object.hltvReplayFlags ?? 0;
    message.expectedLongTick = object.expectedLongTick ?? 0;
    message.expectedLongTickReason = object.expectedLongTickReason ?? "";
    message.hostFrameDroppedPctX10 = object.hostFrameDroppedPctX10 ?? 0;
    message.hostFrameIrregularArrivalPctX10 = object.hostFrameIrregularArrivalPctX10 ?? 0;
    return message;
  },
};

function createBaseCNETMsgStringCmd(): CNETMsgStringCmd {
  return { command: "", predictionSync: 0 };
}

export const CNETMsgStringCmd = {
  encode(message: CNETMsgStringCmd, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.command !== undefined && message.command !== "") {
      writer.uint32(10).string(message.command);
    }
    if (message.predictionSync !== undefined && message.predictionSync !== 0) {
      writer.uint32(16).uint32(message.predictionSync);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CNETMsgStringCmd {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCNETMsgStringCmd();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.command = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.predictionSync = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CNETMsgStringCmd {
    return {
      command: isSet(object.command) ? globalThis.String(object.command) : "",
      predictionSync: isSet(object.predictionSync) ? globalThis.Number(object.predictionSync) : 0,
    };
  },

  toJSON(message: CNETMsgStringCmd): unknown {
    const obj: any = {};
    if (message.command !== undefined && message.command !== "") {
      obj.command = message.command;
    }
    if (message.predictionSync !== undefined && message.predictionSync !== 0) {
      obj.predictionSync = Math.round(message.predictionSync);
    }
    return obj;
  },

  create(base?: DeepPartial<CNETMsgStringCmd>): CNETMsgStringCmd {
    return CNETMsgStringCmd.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CNETMsgStringCmd>): CNETMsgStringCmd {
    const message = createBaseCNETMsgStringCmd();
    message.command = object.command ?? "";
    message.predictionSync = object.predictionSync ?? 0;
    return message;
  },
};

function createBaseCNETMsgSetConVar(): CNETMsgSetConVar {
  return { convars: undefined };
}

export const CNETMsgSetConVar = {
  encode(message: CNETMsgSetConVar, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.convars !== undefined) {
      CMsgCVars.encode(message.convars, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CNETMsgSetConVar {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCNETMsgSetConVar();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.convars = CMsgCVars.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CNETMsgSetConVar {
    return { convars: isSet(object.convars) ? CMsgCVars.fromJSON(object.convars) : undefined };
  },

  toJSON(message: CNETMsgSetConVar): unknown {
    const obj: any = {};
    if (message.convars !== undefined) {
      obj.convars = CMsgCVars.toJSON(message.convars);
    }
    return obj;
  },

  create(base?: DeepPartial<CNETMsgSetConVar>): CNETMsgSetConVar {
    return CNETMsgSetConVar.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CNETMsgSetConVar>): CNETMsgSetConVar {
    const message = createBaseCNETMsgSetConVar();
    message.convars = (object.convars !== undefined && object.convars !== null)
      ? CMsgCVars.fromPartial(object.convars)
      : undefined;
    return message;
  },
};

function createBaseCNETMsgSignonState(): CNETMsgSignonState {
  return { signonState: 0, spawnCount: 0, numServerPlayers: 0, playersNetworkids: [], mapName: "", addons: "" };
}

export const CNETMsgSignonState = {
  encode(message: CNETMsgSignonState, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.signonState !== undefined && message.signonState !== 0) {
      writer.uint32(8).int32(message.signonState);
    }
    if (message.spawnCount !== undefined && message.spawnCount !== 0) {
      writer.uint32(16).uint32(message.spawnCount);
    }
    if (message.numServerPlayers !== undefined && message.numServerPlayers !== 0) {
      writer.uint32(24).uint32(message.numServerPlayers);
    }
    for (const v of message.playersNetworkids) {
      writer.uint32(34).string(v!);
    }
    if (message.mapName !== undefined && message.mapName !== "") {
      writer.uint32(42).string(message.mapName);
    }
    if (message.addons !== undefined && message.addons !== "") {
      writer.uint32(50).string(message.addons);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CNETMsgSignonState {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCNETMsgSignonState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.signonState = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.spawnCount = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.numServerPlayers = reader.uint32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.playersNetworkids.push(reader.string());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.mapName = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.addons = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CNETMsgSignonState {
    return {
      signonState: isSet(object.signonState) ? signonStateTFromJSON(object.signonState) : 0,
      spawnCount: isSet(object.spawnCount) ? globalThis.Number(object.spawnCount) : 0,
      numServerPlayers: isSet(object.numServerPlayers) ? globalThis.Number(object.numServerPlayers) : 0,
      playersNetworkids: globalThis.Array.isArray(object?.playersNetworkids)
        ? object.playersNetworkids.map((e: any) => globalThis.String(e))
        : [],
      mapName: isSet(object.mapName) ? globalThis.String(object.mapName) : "",
      addons: isSet(object.addons) ? globalThis.String(object.addons) : "",
    };
  },

  toJSON(message: CNETMsgSignonState): unknown {
    const obj: any = {};
    if (message.signonState !== undefined && message.signonState !== 0) {
      obj.signonState = signonStateTToJSON(message.signonState);
    }
    if (message.spawnCount !== undefined && message.spawnCount !== 0) {
      obj.spawnCount = Math.round(message.spawnCount);
    }
    if (message.numServerPlayers !== undefined && message.numServerPlayers !== 0) {
      obj.numServerPlayers = Math.round(message.numServerPlayers);
    }
    if (message.playersNetworkids?.length) {
      obj.playersNetworkids = message.playersNetworkids;
    }
    if (message.mapName !== undefined && message.mapName !== "") {
      obj.mapName = message.mapName;
    }
    if (message.addons !== undefined && message.addons !== "") {
      obj.addons = message.addons;
    }
    return obj;
  },

  create(base?: DeepPartial<CNETMsgSignonState>): CNETMsgSignonState {
    return CNETMsgSignonState.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CNETMsgSignonState>): CNETMsgSignonState {
    const message = createBaseCNETMsgSignonState();
    message.signonState = object.signonState ?? 0;
    message.spawnCount = object.spawnCount ?? 0;
    message.numServerPlayers = object.numServerPlayers ?? 0;
    message.playersNetworkids = object.playersNetworkids?.map((e) => e) || [];
    message.mapName = object.mapName ?? "";
    message.addons = object.addons ?? "";
    return message;
  },
};

function createBaseCSVCMsgGameEvent(): CSVCMsgGameEvent {
  return { eventName: "", eventid: 0, keys: [] };
}

export const CSVCMsgGameEvent = {
  encode(message: CSVCMsgGameEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.eventName !== undefined && message.eventName !== "") {
      writer.uint32(10).string(message.eventName);
    }
    if (message.eventid !== undefined && message.eventid !== 0) {
      writer.uint32(16).int32(message.eventid);
    }
    for (const v of message.keys) {
      CSVCMsgGameEvent_keyT.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CSVCMsgGameEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCSVCMsgGameEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.eventName = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.eventid = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.keys.push(CSVCMsgGameEvent_keyT.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CSVCMsgGameEvent {
    return {
      eventName: isSet(object.eventName) ? globalThis.String(object.eventName) : "",
      eventid: isSet(object.eventid) ? globalThis.Number(object.eventid) : 0,
      keys: globalThis.Array.isArray(object?.keys)
        ? object.keys.map((e: any) => CSVCMsgGameEvent_keyT.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CSVCMsgGameEvent): unknown {
    const obj: any = {};
    if (message.eventName !== undefined && message.eventName !== "") {
      obj.eventName = message.eventName;
    }
    if (message.eventid !== undefined && message.eventid !== 0) {
      obj.eventid = Math.round(message.eventid);
    }
    if (message.keys?.length) {
      obj.keys = message.keys.map((e) => CSVCMsgGameEvent_keyT.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CSVCMsgGameEvent>): CSVCMsgGameEvent {
    return CSVCMsgGameEvent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CSVCMsgGameEvent>): CSVCMsgGameEvent {
    const message = createBaseCSVCMsgGameEvent();
    message.eventName = object.eventName ?? "";
    message.eventid = object.eventid ?? 0;
    message.keys = object.keys?.map((e) => CSVCMsgGameEvent_keyT.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCSVCMsgGameEvent_keyT(): CSVCMsgGameEvent_keyT {
  return { type: 0, valString: "", valFloat: 0, valLong: 0, valShort: 0, valByte: 0, valBool: false, valUint64: "0" };
}

export const CSVCMsgGameEvent_keyT = {
  encode(message: CSVCMsgGameEvent_keyT, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.type !== undefined && message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.valString !== undefined && message.valString !== "") {
      writer.uint32(18).string(message.valString);
    }
    if (message.valFloat !== undefined && message.valFloat !== 0) {
      writer.uint32(29).float(message.valFloat);
    }
    if (message.valLong !== undefined && message.valLong !== 0) {
      writer.uint32(32).int32(message.valLong);
    }
    if (message.valShort !== undefined && message.valShort !== 0) {
      writer.uint32(40).int32(message.valShort);
    }
    if (message.valByte !== undefined && message.valByte !== 0) {
      writer.uint32(48).int32(message.valByte);
    }
    if (message.valBool !== undefined && message.valBool !== false) {
      writer.uint32(56).bool(message.valBool);
    }
    if (message.valUint64 !== undefined && message.valUint64 !== "0") {
      writer.uint32(64).uint64(message.valUint64);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CSVCMsgGameEvent_keyT {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCSVCMsgGameEvent_keyT();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.valString = reader.string();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.valFloat = reader.float();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.valLong = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.valShort = reader.int32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.valByte = reader.int32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.valBool = reader.bool();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.valUint64 = longToString(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CSVCMsgGameEvent_keyT {
    return {
      type: isSet(object.type) ? globalThis.Number(object.type) : 0,
      valString: isSet(object.valString) ? globalThis.String(object.valString) : "",
      valFloat: isSet(object.valFloat) ? globalThis.Number(object.valFloat) : 0,
      valLong: isSet(object.valLong) ? globalThis.Number(object.valLong) : 0,
      valShort: isSet(object.valShort) ? globalThis.Number(object.valShort) : 0,
      valByte: isSet(object.valByte) ? globalThis.Number(object.valByte) : 0,
      valBool: isSet(object.valBool) ? globalThis.Boolean(object.valBool) : false,
      valUint64: isSet(object.valUint64) ? globalThis.String(object.valUint64) : "0",
    };
  },

  toJSON(message: CSVCMsgGameEvent_keyT): unknown {
    const obj: any = {};
    if (message.type !== undefined && message.type !== 0) {
      obj.type = Math.round(message.type);
    }
    if (message.valString !== undefined && message.valString !== "") {
      obj.valString = message.valString;
    }
    if (message.valFloat !== undefined && message.valFloat !== 0) {
      obj.valFloat = message.valFloat;
    }
    if (message.valLong !== undefined && message.valLong !== 0) {
      obj.valLong = Math.round(message.valLong);
    }
    if (message.valShort !== undefined && message.valShort !== 0) {
      obj.valShort = Math.round(message.valShort);
    }
    if (message.valByte !== undefined && message.valByte !== 0) {
      obj.valByte = Math.round(message.valByte);
    }
    if (message.valBool !== undefined && message.valBool !== false) {
      obj.valBool = message.valBool;
    }
    if (message.valUint64 !== undefined && message.valUint64 !== "0") {
      obj.valUint64 = message.valUint64;
    }
    return obj;
  },

  create(base?: DeepPartial<CSVCMsgGameEvent_keyT>): CSVCMsgGameEvent_keyT {
    return CSVCMsgGameEvent_keyT.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CSVCMsgGameEvent_keyT>): CSVCMsgGameEvent_keyT {
    const message = createBaseCSVCMsgGameEvent_keyT();
    message.type = object.type ?? 0;
    message.valString = object.valString ?? "";
    message.valFloat = object.valFloat ?? 0;
    message.valLong = object.valLong ?? 0;
    message.valShort = object.valShort ?? 0;
    message.valByte = object.valByte ?? 0;
    message.valBool = object.valBool ?? false;
    message.valUint64 = object.valUint64 ?? "0";
    return message;
  },
};

function createBaseCSVCMsgListGameEvents(): CSVCMsgListGameEvents {
  return { events: [] };
}

export const CSVCMsgListGameEvents = {
  encode(message: CSVCMsgListGameEvents, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.events) {
      CSVCMsgListGameEvents_eventT.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CSVCMsgListGameEvents {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCSVCMsgListGameEvents();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.events.push(CSVCMsgListGameEvents_eventT.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CSVCMsgListGameEvents {
    return {
      events: globalThis.Array.isArray(object?.events)
        ? object.events.map((e: any) => CSVCMsgListGameEvents_eventT.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CSVCMsgListGameEvents): unknown {
    const obj: any = {};
    if (message.events?.length) {
      obj.events = message.events.map((e) => CSVCMsgListGameEvents_eventT.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CSVCMsgListGameEvents>): CSVCMsgListGameEvents {
    return CSVCMsgListGameEvents.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CSVCMsgListGameEvents>): CSVCMsgListGameEvents {
    const message = createBaseCSVCMsgListGameEvents();
    message.events = object.events?.map((e) => CSVCMsgListGameEvents_eventT.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCSVCMsgListGameEvents_eventT(): CSVCMsgListGameEvents_eventT {
  return { tick: 0, event: undefined };
}

export const CSVCMsgListGameEvents_eventT = {
  encode(message: CSVCMsgListGameEvents_eventT, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.tick !== undefined && message.tick !== 0) {
      writer.uint32(8).int32(message.tick);
    }
    if (message.event !== undefined) {
      CSVCMsgGameEvent.encode(message.event, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CSVCMsgListGameEvents_eventT {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCSVCMsgListGameEvents_eventT();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.tick = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.event = CSVCMsgGameEvent.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CSVCMsgListGameEvents_eventT {
    return {
      tick: isSet(object.tick) ? globalThis.Number(object.tick) : 0,
      event: isSet(object.event) ? CSVCMsgGameEvent.fromJSON(object.event) : undefined,
    };
  },

  toJSON(message: CSVCMsgListGameEvents_eventT): unknown {
    const obj: any = {};
    if (message.tick !== undefined && message.tick !== 0) {
      obj.tick = Math.round(message.tick);
    }
    if (message.event !== undefined) {
      obj.event = CSVCMsgGameEvent.toJSON(message.event);
    }
    return obj;
  },

  create(base?: DeepPartial<CSVCMsgListGameEvents_eventT>): CSVCMsgListGameEvents_eventT {
    return CSVCMsgListGameEvents_eventT.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CSVCMsgListGameEvents_eventT>): CSVCMsgListGameEvents_eventT {
    const message = createBaseCSVCMsgListGameEvents_eventT();
    message.tick = object.tick ?? 0;
    message.event = (object.event !== undefined && object.event !== null)
      ? CSVCMsgGameEvent.fromPartial(object.event)
      : undefined;
    return message;
  },
};

function createBaseCNETMsgSpawnGroupLoad(): CNETMsgSpawnGroupLoad {
  return {
    worldname: "",
    entitylumpname: "",
    entityfiltername: "",
    spawngrouphandle: 0,
    spawngroupownerhandle: 0,
    worldOffsetPos: undefined,
    worldOffsetAngle: undefined,
    spawngroupmanifest: Buffer.alloc(0),
    flags: 0,
    tickcount: 0,
    manifestincomplete: false,
    localnamefixup: "",
    parentnamefixup: "",
    manifestloadpriority: 0,
    worldgroupid: 0,
    creationsequence: 0,
    savegamefilename: "",
    spawngroupparenthandle: 0,
    leveltransition: false,
    worldgroupname: "",
  };
}

export const CNETMsgSpawnGroupLoad = {
  encode(message: CNETMsgSpawnGroupLoad, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.worldname !== undefined && message.worldname !== "") {
      writer.uint32(10).string(message.worldname);
    }
    if (message.entitylumpname !== undefined && message.entitylumpname !== "") {
      writer.uint32(18).string(message.entitylumpname);
    }
    if (message.entityfiltername !== undefined && message.entityfiltername !== "") {
      writer.uint32(26).string(message.entityfiltername);
    }
    if (message.spawngrouphandle !== undefined && message.spawngrouphandle !== 0) {
      writer.uint32(32).uint32(message.spawngrouphandle);
    }
    if (message.spawngroupownerhandle !== undefined && message.spawngroupownerhandle !== 0) {
      writer.uint32(40).uint32(message.spawngroupownerhandle);
    }
    if (message.worldOffsetPos !== undefined) {
      CMsgVector.encode(message.worldOffsetPos, writer.uint32(50).fork()).ldelim();
    }
    if (message.worldOffsetAngle !== undefined) {
      CMsgQAngle.encode(message.worldOffsetAngle, writer.uint32(58).fork()).ldelim();
    }
    if (message.spawngroupmanifest !== undefined && message.spawngroupmanifest.length !== 0) {
      writer.uint32(66).bytes(message.spawngroupmanifest);
    }
    if (message.flags !== undefined && message.flags !== 0) {
      writer.uint32(72).uint32(message.flags);
    }
    if (message.tickcount !== undefined && message.tickcount !== 0) {
      writer.uint32(80).int32(message.tickcount);
    }
    if (message.manifestincomplete !== undefined && message.manifestincomplete !== false) {
      writer.uint32(88).bool(message.manifestincomplete);
    }
    if (message.localnamefixup !== undefined && message.localnamefixup !== "") {
      writer.uint32(98).string(message.localnamefixup);
    }
    if (message.parentnamefixup !== undefined && message.parentnamefixup !== "") {
      writer.uint32(106).string(message.parentnamefixup);
    }
    if (message.manifestloadpriority !== undefined && message.manifestloadpriority !== 0) {
      writer.uint32(112).int32(message.manifestloadpriority);
    }
    if (message.worldgroupid !== undefined && message.worldgroupid !== 0) {
      writer.uint32(120).uint32(message.worldgroupid);
    }
    if (message.creationsequence !== undefined && message.creationsequence !== 0) {
      writer.uint32(128).uint32(message.creationsequence);
    }
    if (message.savegamefilename !== undefined && message.savegamefilename !== "") {
      writer.uint32(138).string(message.savegamefilename);
    }
    if (message.spawngroupparenthandle !== undefined && message.spawngroupparenthandle !== 0) {
      writer.uint32(144).uint32(message.spawngroupparenthandle);
    }
    if (message.leveltransition !== undefined && message.leveltransition !== false) {
      writer.uint32(152).bool(message.leveltransition);
    }
    if (message.worldgroupname !== undefined && message.worldgroupname !== "") {
      writer.uint32(162).string(message.worldgroupname);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CNETMsgSpawnGroupLoad {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCNETMsgSpawnGroupLoad();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.worldname = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.entitylumpname = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.entityfiltername = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.spawngrouphandle = reader.uint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.spawngroupownerhandle = reader.uint32();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.worldOffsetPos = CMsgVector.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.worldOffsetAngle = CMsgQAngle.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.spawngroupmanifest = reader.bytes() as Buffer;
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.flags = reader.uint32();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.tickcount = reader.int32();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.manifestincomplete = reader.bool();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.localnamefixup = reader.string();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.parentnamefixup = reader.string();
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.manifestloadpriority = reader.int32();
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.worldgroupid = reader.uint32();
          continue;
        case 16:
          if (tag !== 128) {
            break;
          }

          message.creationsequence = reader.uint32();
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.savegamefilename = reader.string();
          continue;
        case 18:
          if (tag !== 144) {
            break;
          }

          message.spawngroupparenthandle = reader.uint32();
          continue;
        case 19:
          if (tag !== 152) {
            break;
          }

          message.leveltransition = reader.bool();
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.worldgroupname = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CNETMsgSpawnGroupLoad {
    return {
      worldname: isSet(object.worldname) ? globalThis.String(object.worldname) : "",
      entitylumpname: isSet(object.entitylumpname) ? globalThis.String(object.entitylumpname) : "",
      entityfiltername: isSet(object.entityfiltername) ? globalThis.String(object.entityfiltername) : "",
      spawngrouphandle: isSet(object.spawngrouphandle) ? globalThis.Number(object.spawngrouphandle) : 0,
      spawngroupownerhandle: isSet(object.spawngroupownerhandle) ? globalThis.Number(object.spawngroupownerhandle) : 0,
      worldOffsetPos: isSet(object.worldOffsetPos) ? CMsgVector.fromJSON(object.worldOffsetPos) : undefined,
      worldOffsetAngle: isSet(object.worldOffsetAngle) ? CMsgQAngle.fromJSON(object.worldOffsetAngle) : undefined,
      spawngroupmanifest: isSet(object.spawngroupmanifest)
        ? Buffer.from(bytesFromBase64(object.spawngroupmanifest))
        : Buffer.alloc(0),
      flags: isSet(object.flags) ? globalThis.Number(object.flags) : 0,
      tickcount: isSet(object.tickcount) ? globalThis.Number(object.tickcount) : 0,
      manifestincomplete: isSet(object.manifestincomplete) ? globalThis.Boolean(object.manifestincomplete) : false,
      localnamefixup: isSet(object.localnamefixup) ? globalThis.String(object.localnamefixup) : "",
      parentnamefixup: isSet(object.parentnamefixup) ? globalThis.String(object.parentnamefixup) : "",
      manifestloadpriority: isSet(object.manifestloadpriority) ? globalThis.Number(object.manifestloadpriority) : 0,
      worldgroupid: isSet(object.worldgroupid) ? globalThis.Number(object.worldgroupid) : 0,
      creationsequence: isSet(object.creationsequence) ? globalThis.Number(object.creationsequence) : 0,
      savegamefilename: isSet(object.savegamefilename) ? globalThis.String(object.savegamefilename) : "",
      spawngroupparenthandle: isSet(object.spawngroupparenthandle)
        ? globalThis.Number(object.spawngroupparenthandle)
        : 0,
      leveltransition: isSet(object.leveltransition) ? globalThis.Boolean(object.leveltransition) : false,
      worldgroupname: isSet(object.worldgroupname) ? globalThis.String(object.worldgroupname) : "",
    };
  },

  toJSON(message: CNETMsgSpawnGroupLoad): unknown {
    const obj: any = {};
    if (message.worldname !== undefined && message.worldname !== "") {
      obj.worldname = message.worldname;
    }
    if (message.entitylumpname !== undefined && message.entitylumpname !== "") {
      obj.entitylumpname = message.entitylumpname;
    }
    if (message.entityfiltername !== undefined && message.entityfiltername !== "") {
      obj.entityfiltername = message.entityfiltername;
    }
    if (message.spawngrouphandle !== undefined && message.spawngrouphandle !== 0) {
      obj.spawngrouphandle = Math.round(message.spawngrouphandle);
    }
    if (message.spawngroupownerhandle !== undefined && message.spawngroupownerhandle !== 0) {
      obj.spawngroupownerhandle = Math.round(message.spawngroupownerhandle);
    }
    if (message.worldOffsetPos !== undefined) {
      obj.worldOffsetPos = CMsgVector.toJSON(message.worldOffsetPos);
    }
    if (message.worldOffsetAngle !== undefined) {
      obj.worldOffsetAngle = CMsgQAngle.toJSON(message.worldOffsetAngle);
    }
    if (message.spawngroupmanifest !== undefined && message.spawngroupmanifest.length !== 0) {
      obj.spawngroupmanifest = base64FromBytes(message.spawngroupmanifest);
    }
    if (message.flags !== undefined && message.flags !== 0) {
      obj.flags = Math.round(message.flags);
    }
    if (message.tickcount !== undefined && message.tickcount !== 0) {
      obj.tickcount = Math.round(message.tickcount);
    }
    if (message.manifestincomplete !== undefined && message.manifestincomplete !== false) {
      obj.manifestincomplete = message.manifestincomplete;
    }
    if (message.localnamefixup !== undefined && message.localnamefixup !== "") {
      obj.localnamefixup = message.localnamefixup;
    }
    if (message.parentnamefixup !== undefined && message.parentnamefixup !== "") {
      obj.parentnamefixup = message.parentnamefixup;
    }
    if (message.manifestloadpriority !== undefined && message.manifestloadpriority !== 0) {
      obj.manifestloadpriority = Math.round(message.manifestloadpriority);
    }
    if (message.worldgroupid !== undefined && message.worldgroupid !== 0) {
      obj.worldgroupid = Math.round(message.worldgroupid);
    }
    if (message.creationsequence !== undefined && message.creationsequence !== 0) {
      obj.creationsequence = Math.round(message.creationsequence);
    }
    if (message.savegamefilename !== undefined && message.savegamefilename !== "") {
      obj.savegamefilename = message.savegamefilename;
    }
    if (message.spawngroupparenthandle !== undefined && message.spawngroupparenthandle !== 0) {
      obj.spawngroupparenthandle = Math.round(message.spawngroupparenthandle);
    }
    if (message.leveltransition !== undefined && message.leveltransition !== false) {
      obj.leveltransition = message.leveltransition;
    }
    if (message.worldgroupname !== undefined && message.worldgroupname !== "") {
      obj.worldgroupname = message.worldgroupname;
    }
    return obj;
  },

  create(base?: DeepPartial<CNETMsgSpawnGroupLoad>): CNETMsgSpawnGroupLoad {
    return CNETMsgSpawnGroupLoad.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CNETMsgSpawnGroupLoad>): CNETMsgSpawnGroupLoad {
    const message = createBaseCNETMsgSpawnGroupLoad();
    message.worldname = object.worldname ?? "";
    message.entitylumpname = object.entitylumpname ?? "";
    message.entityfiltername = object.entityfiltername ?? "";
    message.spawngrouphandle = object.spawngrouphandle ?? 0;
    message.spawngroupownerhandle = object.spawngroupownerhandle ?? 0;
    message.worldOffsetPos = (object.worldOffsetPos !== undefined && object.worldOffsetPos !== null)
      ? CMsgVector.fromPartial(object.worldOffsetPos)
      : undefined;
    message.worldOffsetAngle = (object.worldOffsetAngle !== undefined && object.worldOffsetAngle !== null)
      ? CMsgQAngle.fromPartial(object.worldOffsetAngle)
      : undefined;
    message.spawngroupmanifest = object.spawngroupmanifest ?? Buffer.alloc(0);
    message.flags = object.flags ?? 0;
    message.tickcount = object.tickcount ?? 0;
    message.manifestincomplete = object.manifestincomplete ?? false;
    message.localnamefixup = object.localnamefixup ?? "";
    message.parentnamefixup = object.parentnamefixup ?? "";
    message.manifestloadpriority = object.manifestloadpriority ?? 0;
    message.worldgroupid = object.worldgroupid ?? 0;
    message.creationsequence = object.creationsequence ?? 0;
    message.savegamefilename = object.savegamefilename ?? "";
    message.spawngroupparenthandle = object.spawngroupparenthandle ?? 0;
    message.leveltransition = object.leveltransition ?? false;
    message.worldgroupname = object.worldgroupname ?? "";
    return message;
  },
};

function createBaseCNETMsgSpawnGroupManifestUpdate(): CNETMsgSpawnGroupManifestUpdate {
  return { spawngrouphandle: 0, spawngroupmanifest: Buffer.alloc(0), manifestincomplete: false };
}

export const CNETMsgSpawnGroupManifestUpdate = {
  encode(message: CNETMsgSpawnGroupManifestUpdate, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.spawngrouphandle !== undefined && message.spawngrouphandle !== 0) {
      writer.uint32(8).uint32(message.spawngrouphandle);
    }
    if (message.spawngroupmanifest !== undefined && message.spawngroupmanifest.length !== 0) {
      writer.uint32(18).bytes(message.spawngroupmanifest);
    }
    if (message.manifestincomplete !== undefined && message.manifestincomplete !== false) {
      writer.uint32(24).bool(message.manifestincomplete);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CNETMsgSpawnGroupManifestUpdate {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCNETMsgSpawnGroupManifestUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.spawngrouphandle = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.spawngroupmanifest = reader.bytes() as Buffer;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.manifestincomplete = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CNETMsgSpawnGroupManifestUpdate {
    return {
      spawngrouphandle: isSet(object.spawngrouphandle) ? globalThis.Number(object.spawngrouphandle) : 0,
      spawngroupmanifest: isSet(object.spawngroupmanifest)
        ? Buffer.from(bytesFromBase64(object.spawngroupmanifest))
        : Buffer.alloc(0),
      manifestincomplete: isSet(object.manifestincomplete) ? globalThis.Boolean(object.manifestincomplete) : false,
    };
  },

  toJSON(message: CNETMsgSpawnGroupManifestUpdate): unknown {
    const obj: any = {};
    if (message.spawngrouphandle !== undefined && message.spawngrouphandle !== 0) {
      obj.spawngrouphandle = Math.round(message.spawngrouphandle);
    }
    if (message.spawngroupmanifest !== undefined && message.spawngroupmanifest.length !== 0) {
      obj.spawngroupmanifest = base64FromBytes(message.spawngroupmanifest);
    }
    if (message.manifestincomplete !== undefined && message.manifestincomplete !== false) {
      obj.manifestincomplete = message.manifestincomplete;
    }
    return obj;
  },

  create(base?: DeepPartial<CNETMsgSpawnGroupManifestUpdate>): CNETMsgSpawnGroupManifestUpdate {
    return CNETMsgSpawnGroupManifestUpdate.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CNETMsgSpawnGroupManifestUpdate>): CNETMsgSpawnGroupManifestUpdate {
    const message = createBaseCNETMsgSpawnGroupManifestUpdate();
    message.spawngrouphandle = object.spawngrouphandle ?? 0;
    message.spawngroupmanifest = object.spawngroupmanifest ?? Buffer.alloc(0);
    message.manifestincomplete = object.manifestincomplete ?? false;
    return message;
  },
};

function createBaseCNETMsgSpawnGroupSetCreationTick(): CNETMsgSpawnGroupSetCreationTick {
  return { spawngrouphandle: 0, tickcount: 0, creationsequence: 0 };
}

export const CNETMsgSpawnGroupSetCreationTick = {
  encode(message: CNETMsgSpawnGroupSetCreationTick, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.spawngrouphandle !== undefined && message.spawngrouphandle !== 0) {
      writer.uint32(8).uint32(message.spawngrouphandle);
    }
    if (message.tickcount !== undefined && message.tickcount !== 0) {
      writer.uint32(16).int32(message.tickcount);
    }
    if (message.creationsequence !== undefined && message.creationsequence !== 0) {
      writer.uint32(24).uint32(message.creationsequence);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CNETMsgSpawnGroupSetCreationTick {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCNETMsgSpawnGroupSetCreationTick();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.spawngrouphandle = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.tickcount = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.creationsequence = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CNETMsgSpawnGroupSetCreationTick {
    return {
      spawngrouphandle: isSet(object.spawngrouphandle) ? globalThis.Number(object.spawngrouphandle) : 0,
      tickcount: isSet(object.tickcount) ? globalThis.Number(object.tickcount) : 0,
      creationsequence: isSet(object.creationsequence) ? globalThis.Number(object.creationsequence) : 0,
    };
  },

  toJSON(message: CNETMsgSpawnGroupSetCreationTick): unknown {
    const obj: any = {};
    if (message.spawngrouphandle !== undefined && message.spawngrouphandle !== 0) {
      obj.spawngrouphandle = Math.round(message.spawngrouphandle);
    }
    if (message.tickcount !== undefined && message.tickcount !== 0) {
      obj.tickcount = Math.round(message.tickcount);
    }
    if (message.creationsequence !== undefined && message.creationsequence !== 0) {
      obj.creationsequence = Math.round(message.creationsequence);
    }
    return obj;
  },

  create(base?: DeepPartial<CNETMsgSpawnGroupSetCreationTick>): CNETMsgSpawnGroupSetCreationTick {
    return CNETMsgSpawnGroupSetCreationTick.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CNETMsgSpawnGroupSetCreationTick>): CNETMsgSpawnGroupSetCreationTick {
    const message = createBaseCNETMsgSpawnGroupSetCreationTick();
    message.spawngrouphandle = object.spawngrouphandle ?? 0;
    message.tickcount = object.tickcount ?? 0;
    message.creationsequence = object.creationsequence ?? 0;
    return message;
  },
};

function createBaseCNETMsgSpawnGroupUnload(): CNETMsgSpawnGroupUnload {
  return { spawngrouphandle: 0, flags: 0, tickcount: 0 };
}

export const CNETMsgSpawnGroupUnload = {
  encode(message: CNETMsgSpawnGroupUnload, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.spawngrouphandle !== undefined && message.spawngrouphandle !== 0) {
      writer.uint32(8).uint32(message.spawngrouphandle);
    }
    if (message.flags !== undefined && message.flags !== 0) {
      writer.uint32(16).uint32(message.flags);
    }
    if (message.tickcount !== undefined && message.tickcount !== 0) {
      writer.uint32(24).int32(message.tickcount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CNETMsgSpawnGroupUnload {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCNETMsgSpawnGroupUnload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.spawngrouphandle = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.flags = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.tickcount = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CNETMsgSpawnGroupUnload {
    return {
      spawngrouphandle: isSet(object.spawngrouphandle) ? globalThis.Number(object.spawngrouphandle) : 0,
      flags: isSet(object.flags) ? globalThis.Number(object.flags) : 0,
      tickcount: isSet(object.tickcount) ? globalThis.Number(object.tickcount) : 0,
    };
  },

  toJSON(message: CNETMsgSpawnGroupUnload): unknown {
    const obj: any = {};
    if (message.spawngrouphandle !== undefined && message.spawngrouphandle !== 0) {
      obj.spawngrouphandle = Math.round(message.spawngrouphandle);
    }
    if (message.flags !== undefined && message.flags !== 0) {
      obj.flags = Math.round(message.flags);
    }
    if (message.tickcount !== undefined && message.tickcount !== 0) {
      obj.tickcount = Math.round(message.tickcount);
    }
    return obj;
  },

  create(base?: DeepPartial<CNETMsgSpawnGroupUnload>): CNETMsgSpawnGroupUnload {
    return CNETMsgSpawnGroupUnload.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CNETMsgSpawnGroupUnload>): CNETMsgSpawnGroupUnload {
    const message = createBaseCNETMsgSpawnGroupUnload();
    message.spawngrouphandle = object.spawngrouphandle ?? 0;
    message.flags = object.flags ?? 0;
    message.tickcount = object.tickcount ?? 0;
    return message;
  },
};

function createBaseCNETMsgSpawnGroupLoadCompleted(): CNETMsgSpawnGroupLoadCompleted {
  return { spawngrouphandle: 0 };
}

export const CNETMsgSpawnGroupLoadCompleted = {
  encode(message: CNETMsgSpawnGroupLoadCompleted, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.spawngrouphandle !== undefined && message.spawngrouphandle !== 0) {
      writer.uint32(8).uint32(message.spawngrouphandle);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CNETMsgSpawnGroupLoadCompleted {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCNETMsgSpawnGroupLoadCompleted();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.spawngrouphandle = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CNETMsgSpawnGroupLoadCompleted {
    return { spawngrouphandle: isSet(object.spawngrouphandle) ? globalThis.Number(object.spawngrouphandle) : 0 };
  },

  toJSON(message: CNETMsgSpawnGroupLoadCompleted): unknown {
    const obj: any = {};
    if (message.spawngrouphandle !== undefined && message.spawngrouphandle !== 0) {
      obj.spawngrouphandle = Math.round(message.spawngrouphandle);
    }
    return obj;
  },

  create(base?: DeepPartial<CNETMsgSpawnGroupLoadCompleted>): CNETMsgSpawnGroupLoadCompleted {
    return CNETMsgSpawnGroupLoadCompleted.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CNETMsgSpawnGroupLoadCompleted>): CNETMsgSpawnGroupLoadCompleted {
    const message = createBaseCNETMsgSpawnGroupLoadCompleted();
    message.spawngrouphandle = object.spawngrouphandle ?? 0;
    return message;
  },
};

function createBaseCSVCMsgGameSessionConfiguration(): CSVCMsgGameSessionConfiguration {
  return {
    isMultiplayer: false,
    isLoadsavegame: false,
    isBackgroundMap: false,
    isHeadless: false,
    minClientLimit: 0,
    maxClientLimit: 0,
    maxClients: 0,
    tickInterval: 0,
    hostname: "",
    savegamename: "",
    s1Mapname: "",
    gamemode: "",
    serverIpAddress: "",
    data: Buffer.alloc(0),
    isLocalonly: false,
    noSteamServer: false,
    isTransition: false,
    previouslevel: "",
    landmarkname: "",
  };
}

export const CSVCMsgGameSessionConfiguration = {
  encode(message: CSVCMsgGameSessionConfiguration, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.isMultiplayer !== undefined && message.isMultiplayer !== false) {
      writer.uint32(8).bool(message.isMultiplayer);
    }
    if (message.isLoadsavegame !== undefined && message.isLoadsavegame !== false) {
      writer.uint32(16).bool(message.isLoadsavegame);
    }
    if (message.isBackgroundMap !== undefined && message.isBackgroundMap !== false) {
      writer.uint32(24).bool(message.isBackgroundMap);
    }
    if (message.isHeadless !== undefined && message.isHeadless !== false) {
      writer.uint32(32).bool(message.isHeadless);
    }
    if (message.minClientLimit !== undefined && message.minClientLimit !== 0) {
      writer.uint32(40).uint32(message.minClientLimit);
    }
    if (message.maxClientLimit !== undefined && message.maxClientLimit !== 0) {
      writer.uint32(48).uint32(message.maxClientLimit);
    }
    if (message.maxClients !== undefined && message.maxClients !== 0) {
      writer.uint32(56).uint32(message.maxClients);
    }
    if (message.tickInterval !== undefined && message.tickInterval !== 0) {
      writer.uint32(69).fixed32(message.tickInterval);
    }
    if (message.hostname !== undefined && message.hostname !== "") {
      writer.uint32(74).string(message.hostname);
    }
    if (message.savegamename !== undefined && message.savegamename !== "") {
      writer.uint32(82).string(message.savegamename);
    }
    if (message.s1Mapname !== undefined && message.s1Mapname !== "") {
      writer.uint32(90).string(message.s1Mapname);
    }
    if (message.gamemode !== undefined && message.gamemode !== "") {
      writer.uint32(98).string(message.gamemode);
    }
    if (message.serverIpAddress !== undefined && message.serverIpAddress !== "") {
      writer.uint32(106).string(message.serverIpAddress);
    }
    if (message.data !== undefined && message.data.length !== 0) {
      writer.uint32(114).bytes(message.data);
    }
    if (message.isLocalonly !== undefined && message.isLocalonly !== false) {
      writer.uint32(120).bool(message.isLocalonly);
    }
    if (message.noSteamServer !== undefined && message.noSteamServer !== false) {
      writer.uint32(152).bool(message.noSteamServer);
    }
    if (message.isTransition !== undefined && message.isTransition !== false) {
      writer.uint32(128).bool(message.isTransition);
    }
    if (message.previouslevel !== undefined && message.previouslevel !== "") {
      writer.uint32(138).string(message.previouslevel);
    }
    if (message.landmarkname !== undefined && message.landmarkname !== "") {
      writer.uint32(146).string(message.landmarkname);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CSVCMsgGameSessionConfiguration {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCSVCMsgGameSessionConfiguration();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.isMultiplayer = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.isLoadsavegame = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.isBackgroundMap = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.isHeadless = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.minClientLimit = reader.uint32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.maxClientLimit = reader.uint32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.maxClients = reader.uint32();
          continue;
        case 8:
          if (tag !== 69) {
            break;
          }

          message.tickInterval = reader.fixed32();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.hostname = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.savegamename = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.s1Mapname = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.gamemode = reader.string();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.serverIpAddress = reader.string();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.data = reader.bytes() as Buffer;
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.isLocalonly = reader.bool();
          continue;
        case 19:
          if (tag !== 152) {
            break;
          }

          message.noSteamServer = reader.bool();
          continue;
        case 16:
          if (tag !== 128) {
            break;
          }

          message.isTransition = reader.bool();
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.previouslevel = reader.string();
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.landmarkname = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CSVCMsgGameSessionConfiguration {
    return {
      isMultiplayer: isSet(object.isMultiplayer) ? globalThis.Boolean(object.isMultiplayer) : false,
      isLoadsavegame: isSet(object.isLoadsavegame) ? globalThis.Boolean(object.isLoadsavegame) : false,
      isBackgroundMap: isSet(object.isBackgroundMap) ? globalThis.Boolean(object.isBackgroundMap) : false,
      isHeadless: isSet(object.isHeadless) ? globalThis.Boolean(object.isHeadless) : false,
      minClientLimit: isSet(object.minClientLimit) ? globalThis.Number(object.minClientLimit) : 0,
      maxClientLimit: isSet(object.maxClientLimit) ? globalThis.Number(object.maxClientLimit) : 0,
      maxClients: isSet(object.maxClients) ? globalThis.Number(object.maxClients) : 0,
      tickInterval: isSet(object.tickInterval) ? globalThis.Number(object.tickInterval) : 0,
      hostname: isSet(object.hostname) ? globalThis.String(object.hostname) : "",
      savegamename: isSet(object.savegamename) ? globalThis.String(object.savegamename) : "",
      s1Mapname: isSet(object.s1Mapname) ? globalThis.String(object.s1Mapname) : "",
      gamemode: isSet(object.gamemode) ? globalThis.String(object.gamemode) : "",
      serverIpAddress: isSet(object.serverIpAddress) ? globalThis.String(object.serverIpAddress) : "",
      data: isSet(object.data) ? Buffer.from(bytesFromBase64(object.data)) : Buffer.alloc(0),
      isLocalonly: isSet(object.isLocalonly) ? globalThis.Boolean(object.isLocalonly) : false,
      noSteamServer: isSet(object.noSteamServer) ? globalThis.Boolean(object.noSteamServer) : false,
      isTransition: isSet(object.isTransition) ? globalThis.Boolean(object.isTransition) : false,
      previouslevel: isSet(object.previouslevel) ? globalThis.String(object.previouslevel) : "",
      landmarkname: isSet(object.landmarkname) ? globalThis.String(object.landmarkname) : "",
    };
  },

  toJSON(message: CSVCMsgGameSessionConfiguration): unknown {
    const obj: any = {};
    if (message.isMultiplayer !== undefined && message.isMultiplayer !== false) {
      obj.isMultiplayer = message.isMultiplayer;
    }
    if (message.isLoadsavegame !== undefined && message.isLoadsavegame !== false) {
      obj.isLoadsavegame = message.isLoadsavegame;
    }
    if (message.isBackgroundMap !== undefined && message.isBackgroundMap !== false) {
      obj.isBackgroundMap = message.isBackgroundMap;
    }
    if (message.isHeadless !== undefined && message.isHeadless !== false) {
      obj.isHeadless = message.isHeadless;
    }
    if (message.minClientLimit !== undefined && message.minClientLimit !== 0) {
      obj.minClientLimit = Math.round(message.minClientLimit);
    }
    if (message.maxClientLimit !== undefined && message.maxClientLimit !== 0) {
      obj.maxClientLimit = Math.round(message.maxClientLimit);
    }
    if (message.maxClients !== undefined && message.maxClients !== 0) {
      obj.maxClients = Math.round(message.maxClients);
    }
    if (message.tickInterval !== undefined && message.tickInterval !== 0) {
      obj.tickInterval = Math.round(message.tickInterval);
    }
    if (message.hostname !== undefined && message.hostname !== "") {
      obj.hostname = message.hostname;
    }
    if (message.savegamename !== undefined && message.savegamename !== "") {
      obj.savegamename = message.savegamename;
    }
    if (message.s1Mapname !== undefined && message.s1Mapname !== "") {
      obj.s1Mapname = message.s1Mapname;
    }
    if (message.gamemode !== undefined && message.gamemode !== "") {
      obj.gamemode = message.gamemode;
    }
    if (message.serverIpAddress !== undefined && message.serverIpAddress !== "") {
      obj.serverIpAddress = message.serverIpAddress;
    }
    if (message.data !== undefined && message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    if (message.isLocalonly !== undefined && message.isLocalonly !== false) {
      obj.isLocalonly = message.isLocalonly;
    }
    if (message.noSteamServer !== undefined && message.noSteamServer !== false) {
      obj.noSteamServer = message.noSteamServer;
    }
    if (message.isTransition !== undefined && message.isTransition !== false) {
      obj.isTransition = message.isTransition;
    }
    if (message.previouslevel !== undefined && message.previouslevel !== "") {
      obj.previouslevel = message.previouslevel;
    }
    if (message.landmarkname !== undefined && message.landmarkname !== "") {
      obj.landmarkname = message.landmarkname;
    }
    return obj;
  },

  create(base?: DeepPartial<CSVCMsgGameSessionConfiguration>): CSVCMsgGameSessionConfiguration {
    return CSVCMsgGameSessionConfiguration.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CSVCMsgGameSessionConfiguration>): CSVCMsgGameSessionConfiguration {
    const message = createBaseCSVCMsgGameSessionConfiguration();
    message.isMultiplayer = object.isMultiplayer ?? false;
    message.isLoadsavegame = object.isLoadsavegame ?? false;
    message.isBackgroundMap = object.isBackgroundMap ?? false;
    message.isHeadless = object.isHeadless ?? false;
    message.minClientLimit = object.minClientLimit ?? 0;
    message.maxClientLimit = object.maxClientLimit ?? 0;
    message.maxClients = object.maxClients ?? 0;
    message.tickInterval = object.tickInterval ?? 0;
    message.hostname = object.hostname ?? "";
    message.savegamename = object.savegamename ?? "";
    message.s1Mapname = object.s1Mapname ?? "";
    message.gamemode = object.gamemode ?? "";
    message.serverIpAddress = object.serverIpAddress ?? "";
    message.data = object.data ?? Buffer.alloc(0);
    message.isLocalonly = object.isLocalonly ?? false;
    message.noSteamServer = object.noSteamServer ?? false;
    message.isTransition = object.isTransition ?? false;
    message.previouslevel = object.previouslevel ?? "";
    message.landmarkname = object.landmarkname ?? "";
    return message;
  },
};

function createBaseCNETMsgDebugOverlay(): CNETMsgDebugOverlay {
  return { etype: 0, vectors: [], colors: [], dimensions: [], times: [], bools: [], uint64s: [], strings: [] };
}

export const CNETMsgDebugOverlay = {
  encode(message: CNETMsgDebugOverlay, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.etype !== undefined && message.etype !== 0) {
      writer.uint32(8).int32(message.etype);
    }
    for (const v of message.vectors) {
      CMsgVector.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.colors) {
      CMsgRGBA.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    writer.uint32(34).fork();
    for (const v of message.dimensions) {
      writer.float(v);
    }
    writer.ldelim();
    writer.uint32(42).fork();
    for (const v of message.times) {
      writer.float(v);
    }
    writer.ldelim();
    writer.uint32(50).fork();
    for (const v of message.bools) {
      writer.bool(v);
    }
    writer.ldelim();
    writer.uint32(58).fork();
    for (const v of message.uint64s) {
      writer.uint64(v);
    }
    writer.ldelim();
    for (const v of message.strings) {
      writer.uint32(66).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CNETMsgDebugOverlay {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCNETMsgDebugOverlay();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.etype = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.vectors.push(CMsgVector.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.colors.push(CMsgRGBA.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag === 37) {
            message.dimensions.push(reader.float());

            continue;
          }

          if (tag === 34) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.dimensions.push(reader.float());
            }

            continue;
          }

          break;
        case 5:
          if (tag === 45) {
            message.times.push(reader.float());

            continue;
          }

          if (tag === 42) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.times.push(reader.float());
            }

            continue;
          }

          break;
        case 6:
          if (tag === 48) {
            message.bools.push(reader.bool());

            continue;
          }

          if (tag === 50) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.bools.push(reader.bool());
            }

            continue;
          }

          break;
        case 7:
          if (tag === 56) {
            message.uint64s.push(longToString(reader.uint64() as Long));

            continue;
          }

          if (tag === 58) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.uint64s.push(longToString(reader.uint64() as Long));
            }

            continue;
          }

          break;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.strings.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CNETMsgDebugOverlay {
    return {
      etype: isSet(object.etype) ? globalThis.Number(object.etype) : 0,
      vectors: globalThis.Array.isArray(object?.vectors) ? object.vectors.map((e: any) => CMsgVector.fromJSON(e)) : [],
      colors: globalThis.Array.isArray(object?.colors) ? object.colors.map((e: any) => CMsgRGBA.fromJSON(e)) : [],
      dimensions: globalThis.Array.isArray(object?.dimensions)
        ? object.dimensions.map((e: any) => globalThis.Number(e))
        : [],
      times: globalThis.Array.isArray(object?.times) ? object.times.map((e: any) => globalThis.Number(e)) : [],
      bools: globalThis.Array.isArray(object?.bools) ? object.bools.map((e: any) => globalThis.Boolean(e)) : [],
      uint64s: globalThis.Array.isArray(object?.uint64s) ? object.uint64s.map((e: any) => globalThis.String(e)) : [],
      strings: globalThis.Array.isArray(object?.strings) ? object.strings.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: CNETMsgDebugOverlay): unknown {
    const obj: any = {};
    if (message.etype !== undefined && message.etype !== 0) {
      obj.etype = Math.round(message.etype);
    }
    if (message.vectors?.length) {
      obj.vectors = message.vectors.map((e) => CMsgVector.toJSON(e));
    }
    if (message.colors?.length) {
      obj.colors = message.colors.map((e) => CMsgRGBA.toJSON(e));
    }
    if (message.dimensions?.length) {
      obj.dimensions = message.dimensions;
    }
    if (message.times?.length) {
      obj.times = message.times;
    }
    if (message.bools?.length) {
      obj.bools = message.bools;
    }
    if (message.uint64s?.length) {
      obj.uint64s = message.uint64s;
    }
    if (message.strings?.length) {
      obj.strings = message.strings;
    }
    return obj;
  },

  create(base?: DeepPartial<CNETMsgDebugOverlay>): CNETMsgDebugOverlay {
    return CNETMsgDebugOverlay.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CNETMsgDebugOverlay>): CNETMsgDebugOverlay {
    const message = createBaseCNETMsgDebugOverlay();
    message.etype = object.etype ?? 0;
    message.vectors = object.vectors?.map((e) => CMsgVector.fromPartial(e)) || [];
    message.colors = object.colors?.map((e) => CMsgRGBA.fromPartial(e)) || [];
    message.dimensions = object.dimensions?.map((e) => e) || [];
    message.times = object.times?.map((e) => e) || [];
    message.bools = object.bools?.map((e) => e) || [];
    message.uint64s = object.uint64s?.map((e) => e) || [];
    message.strings = object.strings?.map((e) => e) || [];
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function longToString(long: Long) {
  return long.toString();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

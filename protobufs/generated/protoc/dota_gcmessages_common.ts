// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.176.1
//   protoc               v5.26.1
// source: dota_gcmessages_common.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";
import {
  CMsgPendingEventAward,
  DOTAGameMode,
  dOTAGameModeFromJSON,
  dOTAGameModeToJSON,
  dotaGcTeam,
  dotaGcTeamFromJSON,
  dotaGcTeamToJSON,
  EEvent,
  eEventFromJSON,
  eEventToJSON,
  ELeaguePhase,
  eLeaguePhaseFromJSON,
  eLeaguePhaseToJSON,
  ELeagueRegion,
  eLeagueRegionFromJSON,
  eLeagueRegionToJSON,
  EMatchOutcome,
  eMatchOutcomeFromJSON,
  eMatchOutcomeToJSON,
} from "./dota_shared_enums";

export enum ESpecialPingValue {
  k_ESpecialPingValue_NoData = 16382,
  k_ESpecialPingValue_Failed = 16383,
}

export function eSpecialPingValueFromJSON(object: any): ESpecialPingValue {
  switch (object) {
    case 16382:
    case "k_ESpecialPingValue_NoData":
      return ESpecialPingValue.k_ESpecialPingValue_NoData;
    case 16383:
    case "k_ESpecialPingValue_Failed":
      return ESpecialPingValue.k_ESpecialPingValue_Failed;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ESpecialPingValue");
  }
}

export function eSpecialPingValueToJSON(object: ESpecialPingValue): string {
  switch (object) {
    case ESpecialPingValue.k_ESpecialPingValue_NoData:
      return "k_ESpecialPingValue_NoData";
    case ESpecialPingValue.k_ESpecialPingValue_Failed:
      return "k_ESpecialPingValue_Failed";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ESpecialPingValue");
  }
}

export enum EDOTAGCSessionNeed {
  k_EDOTAGCSessionNeed_Unknown = 0,
  k_EDOTAGCSessionNeed_UserNoSessionNeeded = 100,
  k_EDOTAGCSessionNeed_UserInOnlineGame = 101,
  k_EDOTAGCSessionNeed_UserInLocalGame = 102,
  k_EDOTAGCSessionNeed_UserInUIWasConnected = 103,
  k_EDOTAGCSessionNeed_UserInUINeverConnected = 104,
  k_EDOTAGCSessionNeed_UserTutorials = 105,
  k_EDOTAGCSessionNeed_UserInUIWasConnectedIdle = 106,
  k_EDOTAGCSessionNeed_UserInUINeverConnectedIdle = 107,
  k_EDOTAGCSessionNeed_GameServerOnline = 200,
  k_EDOTAGCSessionNeed_GameServerLocal = 201,
  k_EDOTAGCSessionNeed_GameServerIdle = 202,
  k_EDOTAGCSessionNeed_GameServerRelay = 203,
  k_EDOTAGCSessionNeed_GameServerLocalUpload = 204,
}

export function eDOTAGCSessionNeedFromJSON(object: any): EDOTAGCSessionNeed {
  switch (object) {
    case 0:
    case "k_EDOTAGCSessionNeed_Unknown":
      return EDOTAGCSessionNeed.k_EDOTAGCSessionNeed_Unknown;
    case 100:
    case "k_EDOTAGCSessionNeed_UserNoSessionNeeded":
      return EDOTAGCSessionNeed.k_EDOTAGCSessionNeed_UserNoSessionNeeded;
    case 101:
    case "k_EDOTAGCSessionNeed_UserInOnlineGame":
      return EDOTAGCSessionNeed.k_EDOTAGCSessionNeed_UserInOnlineGame;
    case 102:
    case "k_EDOTAGCSessionNeed_UserInLocalGame":
      return EDOTAGCSessionNeed.k_EDOTAGCSessionNeed_UserInLocalGame;
    case 103:
    case "k_EDOTAGCSessionNeed_UserInUIWasConnected":
      return EDOTAGCSessionNeed.k_EDOTAGCSessionNeed_UserInUIWasConnected;
    case 104:
    case "k_EDOTAGCSessionNeed_UserInUINeverConnected":
      return EDOTAGCSessionNeed.k_EDOTAGCSessionNeed_UserInUINeverConnected;
    case 105:
    case "k_EDOTAGCSessionNeed_UserTutorials":
      return EDOTAGCSessionNeed.k_EDOTAGCSessionNeed_UserTutorials;
    case 106:
    case "k_EDOTAGCSessionNeed_UserInUIWasConnectedIdle":
      return EDOTAGCSessionNeed.k_EDOTAGCSessionNeed_UserInUIWasConnectedIdle;
    case 107:
    case "k_EDOTAGCSessionNeed_UserInUINeverConnectedIdle":
      return EDOTAGCSessionNeed.k_EDOTAGCSessionNeed_UserInUINeverConnectedIdle;
    case 200:
    case "k_EDOTAGCSessionNeed_GameServerOnline":
      return EDOTAGCSessionNeed.k_EDOTAGCSessionNeed_GameServerOnline;
    case 201:
    case "k_EDOTAGCSessionNeed_GameServerLocal":
      return EDOTAGCSessionNeed.k_EDOTAGCSessionNeed_GameServerLocal;
    case 202:
    case "k_EDOTAGCSessionNeed_GameServerIdle":
      return EDOTAGCSessionNeed.k_EDOTAGCSessionNeed_GameServerIdle;
    case 203:
    case "k_EDOTAGCSessionNeed_GameServerRelay":
      return EDOTAGCSessionNeed.k_EDOTAGCSessionNeed_GameServerRelay;
    case 204:
    case "k_EDOTAGCSessionNeed_GameServerLocalUpload":
      return EDOTAGCSessionNeed.k_EDOTAGCSessionNeed_GameServerLocalUpload;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum EDOTAGCSessionNeed");
  }
}

export function eDOTAGCSessionNeedToJSON(object: EDOTAGCSessionNeed): string {
  switch (object) {
    case EDOTAGCSessionNeed.k_EDOTAGCSessionNeed_Unknown:
      return "k_EDOTAGCSessionNeed_Unknown";
    case EDOTAGCSessionNeed.k_EDOTAGCSessionNeed_UserNoSessionNeeded:
      return "k_EDOTAGCSessionNeed_UserNoSessionNeeded";
    case EDOTAGCSessionNeed.k_EDOTAGCSessionNeed_UserInOnlineGame:
      return "k_EDOTAGCSessionNeed_UserInOnlineGame";
    case EDOTAGCSessionNeed.k_EDOTAGCSessionNeed_UserInLocalGame:
      return "k_EDOTAGCSessionNeed_UserInLocalGame";
    case EDOTAGCSessionNeed.k_EDOTAGCSessionNeed_UserInUIWasConnected:
      return "k_EDOTAGCSessionNeed_UserInUIWasConnected";
    case EDOTAGCSessionNeed.k_EDOTAGCSessionNeed_UserInUINeverConnected:
      return "k_EDOTAGCSessionNeed_UserInUINeverConnected";
    case EDOTAGCSessionNeed.k_EDOTAGCSessionNeed_UserTutorials:
      return "k_EDOTAGCSessionNeed_UserTutorials";
    case EDOTAGCSessionNeed.k_EDOTAGCSessionNeed_UserInUIWasConnectedIdle:
      return "k_EDOTAGCSessionNeed_UserInUIWasConnectedIdle";
    case EDOTAGCSessionNeed.k_EDOTAGCSessionNeed_UserInUINeverConnectedIdle:
      return "k_EDOTAGCSessionNeed_UserInUINeverConnectedIdle";
    case EDOTAGCSessionNeed.k_EDOTAGCSessionNeed_GameServerOnline:
      return "k_EDOTAGCSessionNeed_GameServerOnline";
    case EDOTAGCSessionNeed.k_EDOTAGCSessionNeed_GameServerLocal:
      return "k_EDOTAGCSessionNeed_GameServerLocal";
    case EDOTAGCSessionNeed.k_EDOTAGCSessionNeed_GameServerIdle:
      return "k_EDOTAGCSessionNeed_GameServerIdle";
    case EDOTAGCSessionNeed.k_EDOTAGCSessionNeed_GameServerRelay:
      return "k_EDOTAGCSessionNeed_GameServerRelay";
    case EDOTAGCSessionNeed.k_EDOTAGCSessionNeed_GameServerLocalUpload:
      return "k_EDOTAGCSessionNeed_GameServerLocalUpload";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum EDOTAGCSessionNeed");
  }
}

export enum EDOTAMatchPlayerTimeCustomStat {
  k_EDOTA_MatchPlayerTimeCustomStat_HPRegenUnderT1Towers = 1,
  k_EDOTA_MatchPlayerTimeCustomStat_MagicDamageReducedWithNewFormula_Absolute = 2,
  k_EDOTA_MatchPlayerTimeCustomStat_MagicDamageReducedWithNewFormula_PercentOfTotalHP = 3,
}

export function eDOTAMatchPlayerTimeCustomStatFromJSON(object: any): EDOTAMatchPlayerTimeCustomStat {
  switch (object) {
    case 1:
    case "k_EDOTA_MatchPlayerTimeCustomStat_HPRegenUnderT1Towers":
      return EDOTAMatchPlayerTimeCustomStat.k_EDOTA_MatchPlayerTimeCustomStat_HPRegenUnderT1Towers;
    case 2:
    case "k_EDOTA_MatchPlayerTimeCustomStat_MagicDamageReducedWithNewFormula_Absolute":
      return EDOTAMatchPlayerTimeCustomStat.k_EDOTA_MatchPlayerTimeCustomStat_MagicDamageReducedWithNewFormula_Absolute;
    case 3:
    case "k_EDOTA_MatchPlayerTimeCustomStat_MagicDamageReducedWithNewFormula_PercentOfTotalHP":
      return EDOTAMatchPlayerTimeCustomStat
        .k_EDOTA_MatchPlayerTimeCustomStat_MagicDamageReducedWithNewFormula_PercentOfTotalHP;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum EDOTAMatchPlayerTimeCustomStat");
  }
}

export function eDOTAMatchPlayerTimeCustomStatToJSON(object: EDOTAMatchPlayerTimeCustomStat): string {
  switch (object) {
    case EDOTAMatchPlayerTimeCustomStat.k_EDOTA_MatchPlayerTimeCustomStat_HPRegenUnderT1Towers:
      return "k_EDOTA_MatchPlayerTimeCustomStat_HPRegenUnderT1Towers";
    case EDOTAMatchPlayerTimeCustomStat.k_EDOTA_MatchPlayerTimeCustomStat_MagicDamageReducedWithNewFormula_Absolute:
      return "k_EDOTA_MatchPlayerTimeCustomStat_MagicDamageReducedWithNewFormula_Absolute";
    case EDOTAMatchPlayerTimeCustomStat
      .k_EDOTA_MatchPlayerTimeCustomStat_MagicDamageReducedWithNewFormula_PercentOfTotalHP:
      return "k_EDOTA_MatchPlayerTimeCustomStat_MagicDamageReducedWithNewFormula_PercentOfTotalHP";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum EDOTAMatchPlayerTimeCustomStat");
  }
}

export enum DOTATournamentEvents {
  TE_FIRST_BLOOD = 0,
  TE_GAME_END = 1,
  TE_MULTI_KILL = 2,
  TE_HERO_DENY = 3,
  TE_AEGIS_DENY = 4,
  TE_AEGIS_STOLEN = 5,
  TE_GODLIKE = 6,
  TE_COURIER_KILL = 7,
  TE_ECHOSLAM = 8,
  TE_RAPIER = 9,
  TE_EARLY_ROSHAN = 10,
  TE_BLACK_HOLE = 11,
}

export function dOTATournamentEventsFromJSON(object: any): DOTATournamentEvents {
  switch (object) {
    case 0:
    case "TE_FIRST_BLOOD":
      return DOTATournamentEvents.TE_FIRST_BLOOD;
    case 1:
    case "TE_GAME_END":
      return DOTATournamentEvents.TE_GAME_END;
    case 2:
    case "TE_MULTI_KILL":
      return DOTATournamentEvents.TE_MULTI_KILL;
    case 3:
    case "TE_HERO_DENY":
      return DOTATournamentEvents.TE_HERO_DENY;
    case 4:
    case "TE_AEGIS_DENY":
      return DOTATournamentEvents.TE_AEGIS_DENY;
    case 5:
    case "TE_AEGIS_STOLEN":
      return DOTATournamentEvents.TE_AEGIS_STOLEN;
    case 6:
    case "TE_GODLIKE":
      return DOTATournamentEvents.TE_GODLIKE;
    case 7:
    case "TE_COURIER_KILL":
      return DOTATournamentEvents.TE_COURIER_KILL;
    case 8:
    case "TE_ECHOSLAM":
      return DOTATournamentEvents.TE_ECHOSLAM;
    case 9:
    case "TE_RAPIER":
      return DOTATournamentEvents.TE_RAPIER;
    case 10:
    case "TE_EARLY_ROSHAN":
      return DOTATournamentEvents.TE_EARLY_ROSHAN;
    case 11:
    case "TE_BLACK_HOLE":
      return DOTATournamentEvents.TE_BLACK_HOLE;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum DOTATournamentEvents");
  }
}

export function dOTATournamentEventsToJSON(object: DOTATournamentEvents): string {
  switch (object) {
    case DOTATournamentEvents.TE_FIRST_BLOOD:
      return "TE_FIRST_BLOOD";
    case DOTATournamentEvents.TE_GAME_END:
      return "TE_GAME_END";
    case DOTATournamentEvents.TE_MULTI_KILL:
      return "TE_MULTI_KILL";
    case DOTATournamentEvents.TE_HERO_DENY:
      return "TE_HERO_DENY";
    case DOTATournamentEvents.TE_AEGIS_DENY:
      return "TE_AEGIS_DENY";
    case DOTATournamentEvents.TE_AEGIS_STOLEN:
      return "TE_AEGIS_STOLEN";
    case DOTATournamentEvents.TE_GODLIKE:
      return "TE_GODLIKE";
    case DOTATournamentEvents.TE_COURIER_KILL:
      return "TE_COURIER_KILL";
    case DOTATournamentEvents.TE_ECHOSLAM:
      return "TE_ECHOSLAM";
    case DOTATournamentEvents.TE_RAPIER:
      return "TE_RAPIER";
    case DOTATournamentEvents.TE_EARLY_ROSHAN:
      return "TE_EARLY_ROSHAN";
    case DOTATournamentEvents.TE_BLACK_HOLE:
      return "TE_BLACK_HOLE";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum DOTATournamentEvents");
  }
}

export enum EBroadcastTimelineEvent {
  EBroadcastTimelineEvent_MatchStarted = 1,
  EBroadcastTimelineEvent_GameStateChanged = 2,
  EBroadcastTimelineEvent_TowerDeath = 3,
  EBroadcastTimelineEvent_BarracksDeath = 4,
  EBroadcastTimelineEvent_AncientDeath = 5,
  EBroadcastTimelineEvent_RoshanDeath = 6,
  EBroadcastTimelineEvent_HeroDeath = 7,
  EBroadcastTimelineEvent_TeamFight = 8,
  EBroadcastTimelineEvent_FirstBlood = 9,
}

export function eBroadcastTimelineEventFromJSON(object: any): EBroadcastTimelineEvent {
  switch (object) {
    case 1:
    case "EBroadcastTimelineEvent_MatchStarted":
      return EBroadcastTimelineEvent.EBroadcastTimelineEvent_MatchStarted;
    case 2:
    case "EBroadcastTimelineEvent_GameStateChanged":
      return EBroadcastTimelineEvent.EBroadcastTimelineEvent_GameStateChanged;
    case 3:
    case "EBroadcastTimelineEvent_TowerDeath":
      return EBroadcastTimelineEvent.EBroadcastTimelineEvent_TowerDeath;
    case 4:
    case "EBroadcastTimelineEvent_BarracksDeath":
      return EBroadcastTimelineEvent.EBroadcastTimelineEvent_BarracksDeath;
    case 5:
    case "EBroadcastTimelineEvent_AncientDeath":
      return EBroadcastTimelineEvent.EBroadcastTimelineEvent_AncientDeath;
    case 6:
    case "EBroadcastTimelineEvent_RoshanDeath":
      return EBroadcastTimelineEvent.EBroadcastTimelineEvent_RoshanDeath;
    case 7:
    case "EBroadcastTimelineEvent_HeroDeath":
      return EBroadcastTimelineEvent.EBroadcastTimelineEvent_HeroDeath;
    case 8:
    case "EBroadcastTimelineEvent_TeamFight":
      return EBroadcastTimelineEvent.EBroadcastTimelineEvent_TeamFight;
    case 9:
    case "EBroadcastTimelineEvent_FirstBlood":
      return EBroadcastTimelineEvent.EBroadcastTimelineEvent_FirstBlood;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum EBroadcastTimelineEvent");
  }
}

export function eBroadcastTimelineEventToJSON(object: EBroadcastTimelineEvent): string {
  switch (object) {
    case EBroadcastTimelineEvent.EBroadcastTimelineEvent_MatchStarted:
      return "EBroadcastTimelineEvent_MatchStarted";
    case EBroadcastTimelineEvent.EBroadcastTimelineEvent_GameStateChanged:
      return "EBroadcastTimelineEvent_GameStateChanged";
    case EBroadcastTimelineEvent.EBroadcastTimelineEvent_TowerDeath:
      return "EBroadcastTimelineEvent_TowerDeath";
    case EBroadcastTimelineEvent.EBroadcastTimelineEvent_BarracksDeath:
      return "EBroadcastTimelineEvent_BarracksDeath";
    case EBroadcastTimelineEvent.EBroadcastTimelineEvent_AncientDeath:
      return "EBroadcastTimelineEvent_AncientDeath";
    case EBroadcastTimelineEvent.EBroadcastTimelineEvent_RoshanDeath:
      return "EBroadcastTimelineEvent_RoshanDeath";
    case EBroadcastTimelineEvent.EBroadcastTimelineEvent_HeroDeath:
      return "EBroadcastTimelineEvent_HeroDeath";
    case EBroadcastTimelineEvent.EBroadcastTimelineEvent_TeamFight:
      return "EBroadcastTimelineEvent_TeamFight";
    case EBroadcastTimelineEvent.EBroadcastTimelineEvent_FirstBlood:
      return "EBroadcastTimelineEvent_FirstBlood";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum EBroadcastTimelineEvent");
  }
}

export enum ECustomGameWhitelistState {
  CUSTOM_GAME_WHITELIST_STATE_UNKNOWN = 0,
  CUSTOM_GAME_WHITELIST_STATE_APPROVED = 1,
  CUSTOM_GAME_WHITELIST_STATE_REJECTED = 2,
}

export function eCustomGameWhitelistStateFromJSON(object: any): ECustomGameWhitelistState {
  switch (object) {
    case 0:
    case "CUSTOM_GAME_WHITELIST_STATE_UNKNOWN":
      return ECustomGameWhitelistState.CUSTOM_GAME_WHITELIST_STATE_UNKNOWN;
    case 1:
    case "CUSTOM_GAME_WHITELIST_STATE_APPROVED":
      return ECustomGameWhitelistState.CUSTOM_GAME_WHITELIST_STATE_APPROVED;
    case 2:
    case "CUSTOM_GAME_WHITELIST_STATE_REJECTED":
      return ECustomGameWhitelistState.CUSTOM_GAME_WHITELIST_STATE_REJECTED;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ECustomGameWhitelistState");
  }
}

export function eCustomGameWhitelistStateToJSON(object: ECustomGameWhitelistState): string {
  switch (object) {
    case ECustomGameWhitelistState.CUSTOM_GAME_WHITELIST_STATE_UNKNOWN:
      return "CUSTOM_GAME_WHITELIST_STATE_UNKNOWN";
    case ECustomGameWhitelistState.CUSTOM_GAME_WHITELIST_STATE_APPROVED:
      return "CUSTOM_GAME_WHITELIST_STATE_APPROVED";
    case ECustomGameWhitelistState.CUSTOM_GAME_WHITELIST_STATE_REJECTED:
      return "CUSTOM_GAME_WHITELIST_STATE_REJECTED";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ECustomGameWhitelistState");
  }
}

export enum EDOTATriviaQuestionCategory {
  k_EDOTATriviaQuestionCategory_AbilityIcon = 0,
  k_EDOTATriviaQuestionCategory_AbilityCooldown = 1,
  k_EDOTATriviaQuestionCategory_HeroAttributes = 2,
  k_EDOTATriviaQuestionCategory_HeroMovementSpeed = 3,
  k_EDOTATriviaQuestionCategory_TalentTree = 4,
  k_EDOTATriviaQuestionCategory_HeroStats = 5,
  k_EDOTATriviaQuestionCategory_ItemPrice = 6,
  k_EDOTATriviaQuestionCategory_AbilitySound = 7,
  k_EDOTATriviaQuestionCategory_InvokerSpells = 8,
  k_EDOTATriviaQuestionCategory_AbilityManaCost = 9,
  k_EDOTATriviaQuestionCategory_HeroAttackSound = 10,
  k_EDOTATriviaQuestionCategory_AbilityName = 11,
  k_EDOTATriviaQuestionCategory_ItemComponents = 12,
  k_EDOTATriviaQuestionCategory_ItemLore = 13,
  k_EDOTATriviaQuestionCategory_ItemPassives = 14,
  k_EDOTATriviaQuestionCategory_STATIC_QUESTIONS_END = 15,
  k_EDOTATriviaQuestionCategory_DYNAMIC_QUESTIONS_START = 99,
  k_EDOTATriviaQuestionCategory_Dynamic_ItemBuild = 100,
}

export function eDOTATriviaQuestionCategoryFromJSON(object: any): EDOTATriviaQuestionCategory {
  switch (object) {
    case 0:
    case "k_EDOTATriviaQuestionCategory_AbilityIcon":
      return EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_AbilityIcon;
    case 1:
    case "k_EDOTATriviaQuestionCategory_AbilityCooldown":
      return EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_AbilityCooldown;
    case 2:
    case "k_EDOTATriviaQuestionCategory_HeroAttributes":
      return EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_HeroAttributes;
    case 3:
    case "k_EDOTATriviaQuestionCategory_HeroMovementSpeed":
      return EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_HeroMovementSpeed;
    case 4:
    case "k_EDOTATriviaQuestionCategory_TalentTree":
      return EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_TalentTree;
    case 5:
    case "k_EDOTATriviaQuestionCategory_HeroStats":
      return EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_HeroStats;
    case 6:
    case "k_EDOTATriviaQuestionCategory_ItemPrice":
      return EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_ItemPrice;
    case 7:
    case "k_EDOTATriviaQuestionCategory_AbilitySound":
      return EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_AbilitySound;
    case 8:
    case "k_EDOTATriviaQuestionCategory_InvokerSpells":
      return EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_InvokerSpells;
    case 9:
    case "k_EDOTATriviaQuestionCategory_AbilityManaCost":
      return EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_AbilityManaCost;
    case 10:
    case "k_EDOTATriviaQuestionCategory_HeroAttackSound":
      return EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_HeroAttackSound;
    case 11:
    case "k_EDOTATriviaQuestionCategory_AbilityName":
      return EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_AbilityName;
    case 12:
    case "k_EDOTATriviaQuestionCategory_ItemComponents":
      return EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_ItemComponents;
    case 13:
    case "k_EDOTATriviaQuestionCategory_ItemLore":
      return EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_ItemLore;
    case 14:
    case "k_EDOTATriviaQuestionCategory_ItemPassives":
      return EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_ItemPassives;
    case 15:
    case "k_EDOTATriviaQuestionCategory_STATIC_QUESTIONS_END":
      return EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_STATIC_QUESTIONS_END;
    case 99:
    case "k_EDOTATriviaQuestionCategory_DYNAMIC_QUESTIONS_START":
      return EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_DYNAMIC_QUESTIONS_START;
    case 100:
    case "k_EDOTATriviaQuestionCategory_Dynamic_ItemBuild":
      return EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_Dynamic_ItemBuild;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum EDOTATriviaQuestionCategory");
  }
}

export function eDOTATriviaQuestionCategoryToJSON(object: EDOTATriviaQuestionCategory): string {
  switch (object) {
    case EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_AbilityIcon:
      return "k_EDOTATriviaQuestionCategory_AbilityIcon";
    case EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_AbilityCooldown:
      return "k_EDOTATriviaQuestionCategory_AbilityCooldown";
    case EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_HeroAttributes:
      return "k_EDOTATriviaQuestionCategory_HeroAttributes";
    case EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_HeroMovementSpeed:
      return "k_EDOTATriviaQuestionCategory_HeroMovementSpeed";
    case EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_TalentTree:
      return "k_EDOTATriviaQuestionCategory_TalentTree";
    case EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_HeroStats:
      return "k_EDOTATriviaQuestionCategory_HeroStats";
    case EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_ItemPrice:
      return "k_EDOTATriviaQuestionCategory_ItemPrice";
    case EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_AbilitySound:
      return "k_EDOTATriviaQuestionCategory_AbilitySound";
    case EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_InvokerSpells:
      return "k_EDOTATriviaQuestionCategory_InvokerSpells";
    case EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_AbilityManaCost:
      return "k_EDOTATriviaQuestionCategory_AbilityManaCost";
    case EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_HeroAttackSound:
      return "k_EDOTATriviaQuestionCategory_HeroAttackSound";
    case EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_AbilityName:
      return "k_EDOTATriviaQuestionCategory_AbilityName";
    case EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_ItemComponents:
      return "k_EDOTATriviaQuestionCategory_ItemComponents";
    case EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_ItemLore:
      return "k_EDOTATriviaQuestionCategory_ItemLore";
    case EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_ItemPassives:
      return "k_EDOTATriviaQuestionCategory_ItemPassives";
    case EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_STATIC_QUESTIONS_END:
      return "k_EDOTATriviaQuestionCategory_STATIC_QUESTIONS_END";
    case EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_DYNAMIC_QUESTIONS_START:
      return "k_EDOTATriviaQuestionCategory_DYNAMIC_QUESTIONS_START";
    case EDOTATriviaQuestionCategory.k_EDOTATriviaQuestionCategory_Dynamic_ItemBuild:
      return "k_EDOTATriviaQuestionCategory_Dynamic_ItemBuild";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum EDOTATriviaQuestionCategory");
  }
}

export enum EOverwatchConviction {
  k_EOverwatchConviction_None = 0,
  k_EOverwatchConviction_NotGuilty = 1,
  k_EOverwatchConviction_GuiltUnclear = 2,
  k_EOverwatchConviction_Guilty = 3,
}

export function eOverwatchConvictionFromJSON(object: any): EOverwatchConviction {
  switch (object) {
    case 0:
    case "k_EOverwatchConviction_None":
      return EOverwatchConviction.k_EOverwatchConviction_None;
    case 1:
    case "k_EOverwatchConviction_NotGuilty":
      return EOverwatchConviction.k_EOverwatchConviction_NotGuilty;
    case 2:
    case "k_EOverwatchConviction_GuiltUnclear":
      return EOverwatchConviction.k_EOverwatchConviction_GuiltUnclear;
    case 3:
    case "k_EOverwatchConviction_Guilty":
      return EOverwatchConviction.k_EOverwatchConviction_Guilty;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum EOverwatchConviction");
  }
}

export function eOverwatchConvictionToJSON(object: EOverwatchConviction): string {
  switch (object) {
    case EOverwatchConviction.k_EOverwatchConviction_None:
      return "k_EOverwatchConviction_None";
    case EOverwatchConviction.k_EOverwatchConviction_NotGuilty:
      return "k_EOverwatchConviction_NotGuilty";
    case EOverwatchConviction.k_EOverwatchConviction_GuiltUnclear:
      return "k_EOverwatchConviction_GuiltUnclear";
    case EOverwatchConviction.k_EOverwatchConviction_Guilty:
      return "k_EOverwatchConviction_Guilty";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum EOverwatchConviction");
  }
}

export enum EHeroRelicRarity {
  HERO_RELIC_RARITY_INVALID = -1,
  HERO_RELIC_RARITY_COMMON = 0,
  HERO_RELIC_RARITY_RARE = 1,
}

export function eHeroRelicRarityFromJSON(object: any): EHeroRelicRarity {
  switch (object) {
    case -1:
    case "HERO_RELIC_RARITY_INVALID":
      return EHeroRelicRarity.HERO_RELIC_RARITY_INVALID;
    case 0:
    case "HERO_RELIC_RARITY_COMMON":
      return EHeroRelicRarity.HERO_RELIC_RARITY_COMMON;
    case 1:
    case "HERO_RELIC_RARITY_RARE":
      return EHeroRelicRarity.HERO_RELIC_RARITY_RARE;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum EHeroRelicRarity");
  }
}

export function eHeroRelicRarityToJSON(object: EHeroRelicRarity): string {
  switch (object) {
    case EHeroRelicRarity.HERO_RELIC_RARITY_INVALID:
      return "HERO_RELIC_RARITY_INVALID";
    case EHeroRelicRarity.HERO_RELIC_RARITY_COMMON:
      return "HERO_RELIC_RARITY_COMMON";
    case EHeroRelicRarity.HERO_RELIC_RARITY_RARE:
      return "HERO_RELIC_RARITY_RARE";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum EHeroRelicRarity");
  }
}

export enum EStickerbookAuditAction {
  STICKERBOOK_AUDIT_CREATE_PAGE = 0,
  STICKERBOOK_AUDIT_DELETE_PAGE = 1,
  STICKERBOOK_AUDIT_STICK_STICKERS = 2,
  STICKERBOOK_AUDIT_REPLACE_STICKERS = 3,
  STICKERBOOK_AUDIT_HERO_STICKER = 4,
}

export function eStickerbookAuditActionFromJSON(object: any): EStickerbookAuditAction {
  switch (object) {
    case 0:
    case "STICKERBOOK_AUDIT_CREATE_PAGE":
      return EStickerbookAuditAction.STICKERBOOK_AUDIT_CREATE_PAGE;
    case 1:
    case "STICKERBOOK_AUDIT_DELETE_PAGE":
      return EStickerbookAuditAction.STICKERBOOK_AUDIT_DELETE_PAGE;
    case 2:
    case "STICKERBOOK_AUDIT_STICK_STICKERS":
      return EStickerbookAuditAction.STICKERBOOK_AUDIT_STICK_STICKERS;
    case 3:
    case "STICKERBOOK_AUDIT_REPLACE_STICKERS":
      return EStickerbookAuditAction.STICKERBOOK_AUDIT_REPLACE_STICKERS;
    case 4:
    case "STICKERBOOK_AUDIT_HERO_STICKER":
      return EStickerbookAuditAction.STICKERBOOK_AUDIT_HERO_STICKER;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum EStickerbookAuditAction");
  }
}

export function eStickerbookAuditActionToJSON(object: EStickerbookAuditAction): string {
  switch (object) {
    case EStickerbookAuditAction.STICKERBOOK_AUDIT_CREATE_PAGE:
      return "STICKERBOOK_AUDIT_CREATE_PAGE";
    case EStickerbookAuditAction.STICKERBOOK_AUDIT_DELETE_PAGE:
      return "STICKERBOOK_AUDIT_DELETE_PAGE";
    case EStickerbookAuditAction.STICKERBOOK_AUDIT_STICK_STICKERS:
      return "STICKERBOOK_AUDIT_STICK_STICKERS";
    case EStickerbookAuditAction.STICKERBOOK_AUDIT_REPLACE_STICKERS:
      return "STICKERBOOK_AUDIT_REPLACE_STICKERS";
    case EStickerbookAuditAction.STICKERBOOK_AUDIT_HERO_STICKER:
      return "STICKERBOOK_AUDIT_HERO_STICKER";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum EStickerbookAuditAction");
  }
}

export enum EStickerbookPageType {
  STICKER_PAGE_GENERIC = 0,
  STICKER_PAGE_TEAM = 1,
  STICKER_PAGE_TALENT = 2,
}

export function eStickerbookPageTypeFromJSON(object: any): EStickerbookPageType {
  switch (object) {
    case 0:
    case "STICKER_PAGE_GENERIC":
      return EStickerbookPageType.STICKER_PAGE_GENERIC;
    case 1:
    case "STICKER_PAGE_TEAM":
      return EStickerbookPageType.STICKER_PAGE_TEAM;
    case 2:
    case "STICKER_PAGE_TALENT":
      return EStickerbookPageType.STICKER_PAGE_TALENT;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum EStickerbookPageType");
  }
}

export function eStickerbookPageTypeToJSON(object: EStickerbookPageType): string {
  switch (object) {
    case EStickerbookPageType.STICKER_PAGE_GENERIC:
      return "STICKER_PAGE_GENERIC";
    case EStickerbookPageType.STICKER_PAGE_TEAM:
      return "STICKER_PAGE_TEAM";
    case EStickerbookPageType.STICKER_PAGE_TALENT:
      return "STICKER_PAGE_TALENT";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum EStickerbookPageType");
  }
}

export enum ENewBloomGiftingResponse {
  kENewBloomGifting_Success = 0,
  kENewBloomGifting_UnknownFailure = 1,
  kENewBloomGifting_MalformedRequest = 2,
  kENewBloomGifting_FeatureDisabled = 3,
  kENewBloomGifting_ItemNotFound = 4,
  kENewBloomGifting_PlayerNotAllowedToGiveGifts = 5,
  kENewBloomGifting_TargetNotAllowedToReceiveGifts = 6,
  kENewBloomGifting_ServerNotAuthorized = 100,
  kENewBloomGifting_PlayerNotInLobby = 101,
  kENewBloomGifting_TargetNotInLobby = 102,
  kENewBloomGifting_LobbyNotEligible = 103,
  kENewBloomGifting_TargetNotFriend = 200,
  kENewBloomGifting_TargetFriendDurationTooShort = 201,
}

export function eNewBloomGiftingResponseFromJSON(object: any): ENewBloomGiftingResponse {
  switch (object) {
    case 0:
    case "kENewBloomGifting_Success":
      return ENewBloomGiftingResponse.kENewBloomGifting_Success;
    case 1:
    case "kENewBloomGifting_UnknownFailure":
      return ENewBloomGiftingResponse.kENewBloomGifting_UnknownFailure;
    case 2:
    case "kENewBloomGifting_MalformedRequest":
      return ENewBloomGiftingResponse.kENewBloomGifting_MalformedRequest;
    case 3:
    case "kENewBloomGifting_FeatureDisabled":
      return ENewBloomGiftingResponse.kENewBloomGifting_FeatureDisabled;
    case 4:
    case "kENewBloomGifting_ItemNotFound":
      return ENewBloomGiftingResponse.kENewBloomGifting_ItemNotFound;
    case 5:
    case "kENewBloomGifting_PlayerNotAllowedToGiveGifts":
      return ENewBloomGiftingResponse.kENewBloomGifting_PlayerNotAllowedToGiveGifts;
    case 6:
    case "kENewBloomGifting_TargetNotAllowedToReceiveGifts":
      return ENewBloomGiftingResponse.kENewBloomGifting_TargetNotAllowedToReceiveGifts;
    case 100:
    case "kENewBloomGifting_ServerNotAuthorized":
      return ENewBloomGiftingResponse.kENewBloomGifting_ServerNotAuthorized;
    case 101:
    case "kENewBloomGifting_PlayerNotInLobby":
      return ENewBloomGiftingResponse.kENewBloomGifting_PlayerNotInLobby;
    case 102:
    case "kENewBloomGifting_TargetNotInLobby":
      return ENewBloomGiftingResponse.kENewBloomGifting_TargetNotInLobby;
    case 103:
    case "kENewBloomGifting_LobbyNotEligible":
      return ENewBloomGiftingResponse.kENewBloomGifting_LobbyNotEligible;
    case 200:
    case "kENewBloomGifting_TargetNotFriend":
      return ENewBloomGiftingResponse.kENewBloomGifting_TargetNotFriend;
    case 201:
    case "kENewBloomGifting_TargetFriendDurationTooShort":
      return ENewBloomGiftingResponse.kENewBloomGifting_TargetFriendDurationTooShort;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ENewBloomGiftingResponse");
  }
}

export function eNewBloomGiftingResponseToJSON(object: ENewBloomGiftingResponse): string {
  switch (object) {
    case ENewBloomGiftingResponse.kENewBloomGifting_Success:
      return "kENewBloomGifting_Success";
    case ENewBloomGiftingResponse.kENewBloomGifting_UnknownFailure:
      return "kENewBloomGifting_UnknownFailure";
    case ENewBloomGiftingResponse.kENewBloomGifting_MalformedRequest:
      return "kENewBloomGifting_MalformedRequest";
    case ENewBloomGiftingResponse.kENewBloomGifting_FeatureDisabled:
      return "kENewBloomGifting_FeatureDisabled";
    case ENewBloomGiftingResponse.kENewBloomGifting_ItemNotFound:
      return "kENewBloomGifting_ItemNotFound";
    case ENewBloomGiftingResponse.kENewBloomGifting_PlayerNotAllowedToGiveGifts:
      return "kENewBloomGifting_PlayerNotAllowedToGiveGifts";
    case ENewBloomGiftingResponse.kENewBloomGifting_TargetNotAllowedToReceiveGifts:
      return "kENewBloomGifting_TargetNotAllowedToReceiveGifts";
    case ENewBloomGiftingResponse.kENewBloomGifting_ServerNotAuthorized:
      return "kENewBloomGifting_ServerNotAuthorized";
    case ENewBloomGiftingResponse.kENewBloomGifting_PlayerNotInLobby:
      return "kENewBloomGifting_PlayerNotInLobby";
    case ENewBloomGiftingResponse.kENewBloomGifting_TargetNotInLobby:
      return "kENewBloomGifting_TargetNotInLobby";
    case ENewBloomGiftingResponse.kENewBloomGifting_LobbyNotEligible:
      return "kENewBloomGifting_LobbyNotEligible";
    case ENewBloomGiftingResponse.kENewBloomGifting_TargetNotFriend:
      return "kENewBloomGifting_TargetNotFriend";
    case ENewBloomGiftingResponse.kENewBloomGifting_TargetFriendDurationTooShort:
      return "kENewBloomGifting_TargetFriendDurationTooShort";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ENewBloomGiftingResponse");
  }
}

export interface CSODOTAGameAccountClient {
  accountId?: number | undefined;
  wins?: number | undefined;
  losses?: number | undefined;
  xp?: number | undefined;
  level?: number | undefined;
  initialSkill?: number | undefined;
  leaverCount?: number | undefined;
  secondaryLeaverCount?: number | undefined;
  lowPriorityUntilDate?: number | undefined;
  preventTextChatUntilDate?: number | undefined;
  preventVoiceUntilDate?: number | undefined;
  preventPublicTextChatUntilDate?: number | undefined;
  preventNewPlayerChatUntilDate?: number | undefined;
  lastAbandonedGameDate?: number | undefined;
  lastSecondaryAbandonedGameDate?: number | undefined;
  leaverPenaltyCount?: number | undefined;
  completedGameStreak?: number | undefined;
  accountDisabledUntilDate?: number | undefined;
  accountDisabledCount?: number | undefined;
  matchDisabledUntilDate?: number | undefined;
  matchDisabledCount?: number | undefined;
  shutdownlawterminatetimestamp?: number | undefined;
  lowPriorityGamesRemaining?: number | undefined;
  recruitmentLevel?: number | undefined;
  hasNewNotifications?: boolean | undefined;
  isLeagueAdmin?: boolean | undefined;
  casualGamesPlayed?: number | undefined;
  soloCompetitiveGamesPlayed?: number | undefined;
  partyCompetitiveGamesPlayed?: number | undefined;
  casual1v1GamesPlayed?: number | undefined;
  currAllHeroChallengeId?: number | undefined;
  playTimePoints?: number | undefined;
  accountFlags?: number | undefined;
  playTimeLevel?: number | undefined;
  playerBehaviorSeqNumLastReport?: number | undefined;
  playerBehaviorScoreLastReport?: number | undefined;
  playerBehaviorReportOldData?: boolean | undefined;
  tourneySkillLevel?: number | undefined;
  tourneyRecentParticipationDate?: number | undefined;
  anchoredPhoneNumberId?: string | undefined;
  rankedMatchmakingBanUntilDate?: number | undefined;
  recentGameTime1?: number | undefined;
  recentGameTime2?: number | undefined;
  recentGameTime3?: number | undefined;
  favoriteTeamPacked?: string | undefined;
  recentReportTime?: number | undefined;
  customGameDisabledUntilDate?: number | undefined;
  recentWinTime1?: number | undefined;
  recentWinTime2?: number | undefined;
  recentWinTime3?: number | undefined;
  coachRating?: number | undefined;
  queuePoints?: number | undefined;
  roleHandicaps: CSODOTAGameAccountClient_RoleHandicap[];
  eventModeRecentTime?: number | undefined;
  mmrRecalibrationTime?: number | undefined;
  bannedHeroIds: number[];
}

export interface CSODOTAGameAccountClient_RoleHandicap {
  role?: number | undefined;
  handicap?: number | undefined;
}

export interface CSODOTAGameAccountPlus {
  accountId?: number | undefined;
  originalStartDate?: number | undefined;
  plusFlags?: number | undefined;
  plusStatus?: number | undefined;
  prepaidTimeStart?: number | undefined;
  prepaidTimeBalance?: number | undefined;
  nextPaymentDate?: number | undefined;
  steamAgreementId?: string | undefined;
}

export interface CSODOTAChatWheel {
  messageId?: number | undefined;
}

export interface CMsgLobbyFeaturedGamemodeProgress {
  accounts: CMsgLobbyFeaturedGamemodeProgress_AccountProgress[];
}

export interface CMsgLobbyFeaturedGamemodeProgress_AccountProgress {
  accountId?: number | undefined;
  currentValue?: number | undefined;
  maxValue?: number | undefined;
}

export interface CMsgBattleCupVictory {
  accountId?: number | undefined;
  winDate?: number | undefined;
  validUntil?: number | undefined;
  skillLevel?: number | undefined;
  tournamentId?: number | undefined;
  divisionId?: number | undefined;
  teamId?: number | undefined;
  streak?: number | undefined;
  trophyId?: number | undefined;
}

export interface CMsgLobbyBattleCupVictoryList {
  winners: CMsgBattleCupVictory[];
}

export interface CMsgDOTABroadcastNotification {
  message?: string | undefined;
}

export interface CProtoItemHeroStatue {
  heroId?: number | undefined;
  statusEffectIndex?: number | undefined;
  sequenceName?: string | undefined;
  cycle?: number | undefined;
  wearable: number[];
  inscription?: string | undefined;
  style: number[];
  tournamentDrop?: boolean | undefined;
}

export interface CMatchPlayerAbilityUpgrade {
  ability?: number | undefined;
  time?: number | undefined;
}

export interface CMatchPlayerTimedCustomStat {
  stat?: EDOTAMatchPlayerTimeCustomStat | undefined;
  value?: number | undefined;
}

export interface CMatchPlayerTimedStats {
  time?: number | undefined;
  kills?: number | undefined;
  deaths?: number | undefined;
  assists?: number | undefined;
  netWorth?: number | undefined;
  xp?: number | undefined;
  lastHits?: number | undefined;
  denies?: number | undefined;
  bountyRuneGold?: number | undefined;
  rangeCreepUpgradeGold?: number | undefined;
  observerWardsDewarded?: number | undefined;
  reliableGoldEarned?: number | undefined;
  goldLossPrevented?: number | undefined;
  heroKillGold?: number | undefined;
  creepKillGold?: number | undefined;
  buildingGold?: number | undefined;
  otherGold?: number | undefined;
  comebackGold?: number | undefined;
  experimentalGold?: number | undefined;
  experimental2Gold?: number | undefined;
  creepDenyGold?: number | undefined;
  tpScrollsPurchased1?: number | undefined;
  tpScrollsPurchased2?: number | undefined;
  tpScrollsPurchased3?: number | undefined;
  tpScrollsPurchased4?: number | undefined;
  tpScrollsPurchased5?: number | undefined;
  neutralGold?: number | undefined;
  courierGold?: number | undefined;
  roshanGold?: number | undefined;
  incomeGold?: number | undefined;
  itemValue?: number | undefined;
  supportGoldSpent?: number | undefined;
  campsStacked?: number | undefined;
  wardsPlaced?: number | undefined;
  tripleKills?: number | undefined;
  rampages?: number | undefined;
  customStats: CMatchPlayerTimedCustomStat[];
}

export interface CMatchTeamTimedStats {
  time?: number | undefined;
  enemyTowersKilled?: number | undefined;
  enemyBarracksKilled?: number | undefined;
  enemyTowersStatus?: number | undefined;
  enemyBarracksStatus?: number | undefined;
}

export interface CMatchAdditionalUnitInventory {
  unitName?: string | undefined;
  items: number[];
}

export interface CMatchPlayerPermanentBuff {
  permanentBuff?: number | undefined;
  stackCount?: number | undefined;
  grantTime?: number | undefined;
}

export interface CMatchHeroSelectEvent {
  isPick?: boolean | undefined;
  team?: number | undefined;
  heroId?: number | undefined;
}

export interface CMatchClip {
  matchId?: string | undefined;
  playerAccountId?: number | undefined;
  gameTimeSeconds?: number | undefined;
  durationSeconds?: number | undefined;
  playerId?: number | undefined;
  heroId?: number | undefined;
  abilityId?: number | undefined;
  cameraMode?: number | undefined;
  comment?: string | undefined;
}

export interface CPartySearchClientParty {
  partyId?: string | undefined;
  beaconType?: number | undefined;
  partyMembers: number[];
}

export interface CMsgDOTAHasItemQuery {
  accountId?: number | undefined;
  itemId?: string | undefined;
}

export interface CMsgDOTAHasItemResponse {
  hasItem?: boolean | undefined;
}

export interface CMsgGCGetPlayerCardItemInfo {
  accountId?: number | undefined;
  playerCardItemIds: string[];
  allForEvent?: number | undefined;
}

export interface CMsgGCGetPlayerCardItemInfoResponse {
  playerCardInfos: CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo[];
}

export interface CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo {
  playerCardItemId?: string | undefined;
  accountId?: number | undefined;
  packedBonuses?: string | undefined;
}

export interface CSODOTAMapLocationState {
  accountId?: number | undefined;
  locationId?: number | undefined;
  completed?: boolean | undefined;
}

export interface CMsgLeagueAdminList {
  accountIds: number[];
}

export interface CMsgDOTAProfileCard {
  accountId?: number | undefined;
  slots: CMsgDOTAProfileCard_Slot[];
  badgePoints?: number | undefined;
  eventId?: number | undefined;
  recentBattleCupVictory?: CMsgBattleCupVictory | undefined;
  rankTier?: number | undefined;
  leaderboardRank?: number | undefined;
  isPlusSubscriber?: boolean | undefined;
  plusOriginalStartDate?: number | undefined;
  rankTierScore?: number | undefined;
  leaderboardRankCore?: number | undefined;
  title?: number | undefined;
  favoriteTeamPacked?: string | undefined;
  lifetimeGames?: number | undefined;
  eventLevel?: number | undefined;
}

export enum CMsgDOTAProfileCard_EStatID {
  k_eStat_Wins = 3,
  k_eStat_Commends = 4,
  k_eStat_GamesPlayed = 5,
  k_eStat_FirstMatchDate = 6,
  k_eStat_PreviousSeasonRank = 7,
  k_eStat_GamesMVP = 8,
}

export function cMsgDOTAProfileCard_EStatIDFromJSON(object: any): CMsgDOTAProfileCard_EStatID {
  switch (object) {
    case 3:
    case "k_eStat_Wins":
      return CMsgDOTAProfileCard_EStatID.k_eStat_Wins;
    case 4:
    case "k_eStat_Commends":
      return CMsgDOTAProfileCard_EStatID.k_eStat_Commends;
    case 5:
    case "k_eStat_GamesPlayed":
      return CMsgDOTAProfileCard_EStatID.k_eStat_GamesPlayed;
    case 6:
    case "k_eStat_FirstMatchDate":
      return CMsgDOTAProfileCard_EStatID.k_eStat_FirstMatchDate;
    case 7:
    case "k_eStat_PreviousSeasonRank":
      return CMsgDOTAProfileCard_EStatID.k_eStat_PreviousSeasonRank;
    case 8:
    case "k_eStat_GamesMVP":
      return CMsgDOTAProfileCard_EStatID.k_eStat_GamesMVP;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum CMsgDOTAProfileCard_EStatID");
  }
}

export function cMsgDOTAProfileCard_EStatIDToJSON(object: CMsgDOTAProfileCard_EStatID): string {
  switch (object) {
    case CMsgDOTAProfileCard_EStatID.k_eStat_Wins:
      return "k_eStat_Wins";
    case CMsgDOTAProfileCard_EStatID.k_eStat_Commends:
      return "k_eStat_Commends";
    case CMsgDOTAProfileCard_EStatID.k_eStat_GamesPlayed:
      return "k_eStat_GamesPlayed";
    case CMsgDOTAProfileCard_EStatID.k_eStat_FirstMatchDate:
      return "k_eStat_FirstMatchDate";
    case CMsgDOTAProfileCard_EStatID.k_eStat_PreviousSeasonRank:
      return "k_eStat_PreviousSeasonRank";
    case CMsgDOTAProfileCard_EStatID.k_eStat_GamesMVP:
      return "k_eStat_GamesMVP";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum CMsgDOTAProfileCard_EStatID");
  }
}

export interface CMsgDOTAProfileCard_Slot {
  slotId?: number | undefined;
  trophy?: CMsgDOTAProfileCard_Slot_Trophy | undefined;
  stat?: CMsgDOTAProfileCard_Slot_Stat | undefined;
  item?: CMsgDOTAProfileCard_Slot_Item | undefined;
  hero?: CMsgDOTAProfileCard_Slot_Hero | undefined;
  emoticon?: CMsgDOTAProfileCard_Slot_Emoticon | undefined;
  team?: CMsgDOTAProfileCard_Slot_Team | undefined;
}

export interface CMsgDOTAProfileCard_Slot_Trophy {
  trophyId?: number | undefined;
  trophyScore?: number | undefined;
}

export interface CMsgDOTAProfileCard_Slot_Stat {
  statId?: CMsgDOTAProfileCard_EStatID | undefined;
  statScore?: number | undefined;
}

export interface CMsgDOTAProfileCard_Slot_Item {
  serializedItem?: Buffer | undefined;
  itemId?: string | undefined;
}

export interface CMsgDOTAProfileCard_Slot_Hero {
  heroId?: number | undefined;
  heroWins?: number | undefined;
  heroLosses?: number | undefined;
}

export interface CMsgDOTAProfileCard_Slot_Emoticon {
  emoticonId?: number | undefined;
}

export interface CMsgDOTAProfileCard_Slot_Team {
  teamId?: number | undefined;
}

export interface CSODOTAPlayerChallenge {
  accountId?: number | undefined;
  eventId?: number | undefined;
  slotId?: number | undefined;
  intParam0?: number | undefined;
  intParam1?: number | undefined;
  createdTime?: number | undefined;
  completed?: number | undefined;
  sequenceId?: number | undefined;
  challengeTier?: number | undefined;
  flags?: number | undefined;
  attempts?: number | undefined;
  completeLimit?: number | undefined;
  questRank?: number | undefined;
  maxQuestRank?: number | undefined;
  instanceId?: number | undefined;
  heroId?: number | undefined;
  templateId?: number | undefined;
}

export interface CMsgClientToGCRerollPlayerChallenge {
  eventId?: EEvent | undefined;
  sequenceId?: number | undefined;
  heroId?: number | undefined;
}

export interface CMsgGCRerollPlayerChallengeResponse {
  result?: CMsgGCRerollPlayerChallengeResponse_EResult | undefined;
}

export enum CMsgGCRerollPlayerChallengeResponse_EResult {
  eResult_Success = 0,
  eResult_Dropped = 1,
  eResult_NotFound = 2,
  eResult_CantReroll = 3,
  eResult_ServerError = 4,
}

export function cMsgGCRerollPlayerChallengeResponse_EResultFromJSON(
  object: any,
): CMsgGCRerollPlayerChallengeResponse_EResult {
  switch (object) {
    case 0:
    case "eResult_Success":
      return CMsgGCRerollPlayerChallengeResponse_EResult.eResult_Success;
    case 1:
    case "eResult_Dropped":
      return CMsgGCRerollPlayerChallengeResponse_EResult.eResult_Dropped;
    case 2:
    case "eResult_NotFound":
      return CMsgGCRerollPlayerChallengeResponse_EResult.eResult_NotFound;
    case 3:
    case "eResult_CantReroll":
      return CMsgGCRerollPlayerChallengeResponse_EResult.eResult_CantReroll;
    case 4:
    case "eResult_ServerError":
      return CMsgGCRerollPlayerChallengeResponse_EResult.eResult_ServerError;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgGCRerollPlayerChallengeResponse_EResult",
      );
  }
}

export function cMsgGCRerollPlayerChallengeResponse_EResultToJSON(
  object: CMsgGCRerollPlayerChallengeResponse_EResult,
): string {
  switch (object) {
    case CMsgGCRerollPlayerChallengeResponse_EResult.eResult_Success:
      return "eResult_Success";
    case CMsgGCRerollPlayerChallengeResponse_EResult.eResult_Dropped:
      return "eResult_Dropped";
    case CMsgGCRerollPlayerChallengeResponse_EResult.eResult_NotFound:
      return "eResult_NotFound";
    case CMsgGCRerollPlayerChallengeResponse_EResult.eResult_CantReroll:
      return "eResult_CantReroll";
    case CMsgGCRerollPlayerChallengeResponse_EResult.eResult_ServerError:
      return "eResult_ServerError";
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgGCRerollPlayerChallengeResponse_EResult",
      );
  }
}

export interface CMsgGCTopCustomGamesList {
  topCustomGames: string[];
  gameOfTheDay?: string | undefined;
}

export interface CMsgDOTARealtimeGameStats {
  match?: CMsgDOTARealtimeGameStats_MatchDetails | undefined;
  teams: CMsgDOTARealtimeGameStats_TeamDetails[];
  buildings: CMsgDOTARealtimeGameStats_BuildingDetails[];
  graphData?: CMsgDOTARealtimeGameStats_GraphData | undefined;
  deltaFrame?: boolean | undefined;
}

export interface CMsgDOTARealtimeGameStats_TeamDetails {
  teamNumber?: number | undefined;
  teamId?: number | undefined;
  teamName?: string | undefined;
  teamLogo?: string | undefined;
  teamTag?: string | undefined;
  score?: number | undefined;
  netWorth?: number | undefined;
  players: CMsgDOTARealtimeGameStats_PlayerDetails[];
  onlyTeam?: boolean | undefined;
  cheers?: number | undefined;
  teamLogoUrl?: string | undefined;
}

export interface CMsgDOTARealtimeGameStats_ItemDetails {
  itemAbilityId?: number | undefined;
  name?: string | undefined;
  time?: number | undefined;
  sold?: boolean | undefined;
  stackcount?: number | undefined;
}

export interface CMsgDOTARealtimeGameStats_AbilityDetails {
  id?: number | undefined;
  name?: string | undefined;
  level?: number | undefined;
  cooldown?: number | undefined;
  cooldownMax?: number | undefined;
}

export interface CMsgDOTARealtimeGameStats_HeroToHeroStats {
  victimid?: number | undefined;
  kills?: number | undefined;
  assists?: number | undefined;
}

export interface CMsgDOTARealtimeGameStats_AbilityList {
  id: number[];
}

export interface CMsgDOTARealtimeGameStats_PlayerDetails {
  accountid?: number | undefined;
  playerid?: number | undefined;
  name?: string | undefined;
  team?: number | undefined;
  heroid?: number | undefined;
  healthpoints?: number | undefined;
  maxhealthpoints?: number | undefined;
  healthregenrate?: number | undefined;
  manapoints?: number | undefined;
  maxmanapoints?: number | undefined;
  manaregenrate?: number | undefined;
  baseStrength?: number | undefined;
  baseAgility?: number | undefined;
  baseIntelligence?: number | undefined;
  baseArmor?: number | undefined;
  baseMovespeed?: number | undefined;
  baseDamage?: number | undefined;
  strength?: number | undefined;
  agility?: number | undefined;
  intelligence?: number | undefined;
  armor?: number | undefined;
  movespeed?: number | undefined;
  damage?: number | undefined;
  heroDamage?: number | undefined;
  towerDamage?: number | undefined;
  abilities: CMsgDOTARealtimeGameStats_AbilityDetails[];
  level?: number | undefined;
  killCount?: number | undefined;
  deathCount?: number | undefined;
  assistsCount?: number | undefined;
  deniesCount?: number | undefined;
  lhCount?: number | undefined;
  heroHealing?: number | undefined;
  goldPerMin?: number | undefined;
  xpPerMin?: number | undefined;
  netGold?: number | undefined;
  gold?: number | undefined;
  x?: number | undefined;
  y?: number | undefined;
  respawnTime?: number | undefined;
  ultimateCooldown?: number | undefined;
  hasBuyback?: boolean | undefined;
  items: CMsgDOTARealtimeGameStats_ItemDetails[];
  stashitems: CMsgDOTARealtimeGameStats_ItemDetails[];
  itemshoppinglist: CMsgDOTARealtimeGameStats_ItemDetails[];
  levelpoints: CMsgDOTARealtimeGameStats_AbilityList[];
  heroToHeroStats: CMsgDOTARealtimeGameStats_HeroToHeroStats[];
  hasUltimate?: boolean | undefined;
  hasUltimateMana?: boolean | undefined;
  teamSlot?: number | undefined;
}

export interface CMsgDOTARealtimeGameStats_BuildingDetails {
  team?: number | undefined;
  heading?: number | undefined;
  lane?: number | undefined;
  tier?: number | undefined;
  type?: number | undefined;
  x?: number | undefined;
  y?: number | undefined;
  destroyed?: boolean | undefined;
}

export interface CMsgDOTARealtimeGameStats_KillDetails {
  playerId?: number | undefined;
  deathTime?: number | undefined;
  killerPlayerId?: number | undefined;
}

export interface CMsgDOTARealtimeGameStats_BroadcasterDetails {
  playerId?: number | undefined;
}

export interface CMsgDOTARealtimeGameStats_PickBanDetails {
  hero?: number | undefined;
  team?: number | undefined;
}

export interface CMsgDOTARealtimeGameStats_MatchDetails {
  serverSteamId?: string | undefined;
  matchId?: string | undefined;
  timestamp?: number | undefined;
  timeOfDay?: number | undefined;
  isNightstalkerNight?: boolean | undefined;
  gameTime?: number | undefined;
  gameState?: number | undefined;
  teamidRadiant?: number | undefined;
  teamidDire?: number | undefined;
  picks: CMsgDOTARealtimeGameStats_PickBanDetails[];
  bans: CMsgDOTARealtimeGameStats_PickBanDetails[];
  kills: CMsgDOTARealtimeGameStats_KillDetails[];
  broadcasters: CMsgDOTARealtimeGameStats_BroadcasterDetails[];
  gameMode?: number | undefined;
  leagueId?: number | undefined;
  leagueNodeId?: number | undefined;
  singleTeam?: boolean | undefined;
  cheersPeak?: number | undefined;
  lobbyType?: number | undefined;
  startTimestamp?: number | undefined;
  isPlayerDraft?: boolean | undefined;
}

export interface CMsgDOTARealtimeGameStats_GraphData {
  graphGold: number[];
  graphXp: number[];
  graphKill: number[];
  graphTower: number[];
  graphRax: number[];
  teamLocStats: CMsgDOTARealtimeGameStats_GraphData_TeamLocationStats[];
}

export enum CMsgDOTARealtimeGameStats_GraphData_eStat {
  CreepGoldEarned = 0,
  KillGoldEarned = 1,
  DeathAndBuybackGoldLost = 2,
  XPEarned = 3,
}

export function cMsgDOTARealtimeGameStats_GraphData_eStatFromJSON(
  object: any,
): CMsgDOTARealtimeGameStats_GraphData_eStat {
  switch (object) {
    case 0:
    case "CreepGoldEarned":
      return CMsgDOTARealtimeGameStats_GraphData_eStat.CreepGoldEarned;
    case 1:
    case "KillGoldEarned":
      return CMsgDOTARealtimeGameStats_GraphData_eStat.KillGoldEarned;
    case 2:
    case "DeathAndBuybackGoldLost":
      return CMsgDOTARealtimeGameStats_GraphData_eStat.DeathAndBuybackGoldLost;
    case 3:
    case "XPEarned":
      return CMsgDOTARealtimeGameStats_GraphData_eStat.XPEarned;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgDOTARealtimeGameStats_GraphData_eStat",
      );
  }
}

export function cMsgDOTARealtimeGameStats_GraphData_eStatToJSON(
  object: CMsgDOTARealtimeGameStats_GraphData_eStat,
): string {
  switch (object) {
    case CMsgDOTARealtimeGameStats_GraphData_eStat.CreepGoldEarned:
      return "CreepGoldEarned";
    case CMsgDOTARealtimeGameStats_GraphData_eStat.KillGoldEarned:
      return "KillGoldEarned";
    case CMsgDOTARealtimeGameStats_GraphData_eStat.DeathAndBuybackGoldLost:
      return "DeathAndBuybackGoldLost";
    case CMsgDOTARealtimeGameStats_GraphData_eStat.XPEarned:
      return "XPEarned";
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgDOTARealtimeGameStats_GraphData_eStat",
      );
  }
}

export enum CMsgDOTARealtimeGameStats_GraphData_eLocation {
  BotLane = 0,
  MidLane = 1,
  TopLane = 2,
  Jungle = 3,
  Ancients = 4,
  Other = 5,
}

export function cMsgDOTARealtimeGameStats_GraphData_eLocationFromJSON(
  object: any,
): CMsgDOTARealtimeGameStats_GraphData_eLocation {
  switch (object) {
    case 0:
    case "BotLane":
      return CMsgDOTARealtimeGameStats_GraphData_eLocation.BotLane;
    case 1:
    case "MidLane":
      return CMsgDOTARealtimeGameStats_GraphData_eLocation.MidLane;
    case 2:
    case "TopLane":
      return CMsgDOTARealtimeGameStats_GraphData_eLocation.TopLane;
    case 3:
    case "Jungle":
      return CMsgDOTARealtimeGameStats_GraphData_eLocation.Jungle;
    case 4:
    case "Ancients":
      return CMsgDOTARealtimeGameStats_GraphData_eLocation.Ancients;
    case 5:
    case "Other":
      return CMsgDOTARealtimeGameStats_GraphData_eLocation.Other;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgDOTARealtimeGameStats_GraphData_eLocation",
      );
  }
}

export function cMsgDOTARealtimeGameStats_GraphData_eLocationToJSON(
  object: CMsgDOTARealtimeGameStats_GraphData_eLocation,
): string {
  switch (object) {
    case CMsgDOTARealtimeGameStats_GraphData_eLocation.BotLane:
      return "BotLane";
    case CMsgDOTARealtimeGameStats_GraphData_eLocation.MidLane:
      return "MidLane";
    case CMsgDOTARealtimeGameStats_GraphData_eLocation.TopLane:
      return "TopLane";
    case CMsgDOTARealtimeGameStats_GraphData_eLocation.Jungle:
      return "Jungle";
    case CMsgDOTARealtimeGameStats_GraphData_eLocation.Ancients:
      return "Ancients";
    case CMsgDOTARealtimeGameStats_GraphData_eLocation.Other:
      return "Other";
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgDOTARealtimeGameStats_GraphData_eLocation",
      );
  }
}

export interface CMsgDOTARealtimeGameStats_GraphData_LocationStats {
  stats: number[];
}

export interface CMsgDOTARealtimeGameStats_GraphData_TeamLocationStats {
  locStats: CMsgDOTARealtimeGameStats_GraphData_LocationStats[];
}

export interface CMsgDOTARealtimeGameStatsTerse {
  match?: CMsgDOTARealtimeGameStatsTerse_MatchDetails | undefined;
  teams: CMsgDOTARealtimeGameStatsTerse_TeamDetails[];
  buildings: CMsgDOTARealtimeGameStatsTerse_BuildingDetails[];
  graphData?: CMsgDOTARealtimeGameStatsTerse_GraphData | undefined;
  deltaFrame?: boolean | undefined;
}

export interface CMsgDOTARealtimeGameStatsTerse_TeamDetails {
  teamNumber?: number | undefined;
  teamId?: number | undefined;
  teamName?: string | undefined;
  teamTag?: string | undefined;
  teamLogo?: string | undefined;
  score?: number | undefined;
  netWorth?: number | undefined;
  teamLogoUrl?: string | undefined;
  players: CMsgDOTARealtimeGameStatsTerse_PlayerDetails[];
}

export interface CMsgDOTARealtimeGameStatsTerse_PlayerDetails {
  accountid?: number | undefined;
  playerid?: number | undefined;
  name?: string | undefined;
  team?: number | undefined;
  heroid?: number | undefined;
  level?: number | undefined;
  killCount?: number | undefined;
  deathCount?: number | undefined;
  assistsCount?: number | undefined;
  deniesCount?: number | undefined;
  lhCount?: number | undefined;
  gold?: number | undefined;
  x?: number | undefined;
  y?: number | undefined;
  netWorth?: number | undefined;
  abilities: number[];
  items: number[];
  teamSlot?: number | undefined;
}

export interface CMsgDOTARealtimeGameStatsTerse_BuildingDetails {
  team?: number | undefined;
  heading?: number | undefined;
  type?: number | undefined;
  lane?: number | undefined;
  tier?: number | undefined;
  x?: number | undefined;
  y?: number | undefined;
  destroyed?: boolean | undefined;
}

export interface CMsgDOTARealtimeGameStatsTerse_PickBanDetails {
  hero?: number | undefined;
  team?: number | undefined;
}

export interface CMsgDOTARealtimeGameStatsTerse_MatchDetails {
  serverSteamId?: string | undefined;
  matchId?: string | undefined;
  timestamp?: number | undefined;
  gameTime?: number | undefined;
  steamBroadcasterAccountIds: number[];
  gameMode?: number | undefined;
  leagueId?: number | undefined;
  leagueNodeId?: number | undefined;
  gameState?: number | undefined;
  picks: CMsgDOTARealtimeGameStatsTerse_PickBanDetails[];
  bans: CMsgDOTARealtimeGameStatsTerse_PickBanDetails[];
  lobbyType?: number | undefined;
  startTimestamp?: number | undefined;
  isPlayerDraft?: boolean | undefined;
}

export interface CMsgDOTARealtimeGameStatsTerse_GraphData {
  graphGold: number[];
}

export interface CMsgDOTABroadcastTimelineEvent {
  event?: EBroadcastTimelineEvent | undefined;
  timestamp?: number | undefined;
  data?: number | undefined;
  stringData?: string | undefined;
}

export interface CMsgGCToClientMatchGroupsVersion {
  matchgroupsVersion?: number | undefined;
}

export interface CMsgDOTASDOHeroStatsHistory {
  matchId?: string | undefined;
  gameMode?: number | undefined;
  lobbyType?: number | undefined;
  startTime?: number | undefined;
  won?: boolean | undefined;
  gpm?: number | undefined;
  xpm?: number | undefined;
  kills?: number | undefined;
  deaths?: number | undefined;
  assists?: number | undefined;
}

export interface CMsgPredictionChoice {
  value?: number | undefined;
  name?: string | undefined;
  minRawValue?: number | undefined;
  maxRawValue?: number | undefined;
}

export interface CMsgInGamePrediction {
  id?: number | undefined;
  name?: string | undefined;
  type?: CMsgInGamePrediction_EPredictionType | undefined;
  group?: CMsgInGamePrediction_ERandomSelectionGroupT | undefined;
  question?: string | undefined;
  choices: CMsgPredictionChoice[];
  requiredHeroes: string[];
  queryName?: string | undefined;
  queryValues: CMsgInGamePrediction_QueryKeyValues[];
  answerResolutionType?: CMsgInGamePrediction_EResolutionTypeT | undefined;
  pointsToGrant?: number | undefined;
  rewardAction?: number | undefined;
  debugForceSelection?: number | undefined;
  rawValueType?: CMsgInGamePrediction_ERawValueTypeT | undefined;
}

export enum CMsgInGamePrediction_ERawValueTypeT {
  Number = 0,
  Time = 1,
}

export function cMsgInGamePrediction_ERawValueTypeTFromJSON(object: any): CMsgInGamePrediction_ERawValueTypeT {
  switch (object) {
    case 0:
    case "Number":
      return CMsgInGamePrediction_ERawValueTypeT.Number;
    case 1:
    case "Time":
      return CMsgInGamePrediction_ERawValueTypeT.Time;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum CMsgInGamePrediction_ERawValueTypeT");
  }
}

export function cMsgInGamePrediction_ERawValueTypeTToJSON(object: CMsgInGamePrediction_ERawValueTypeT): string {
  switch (object) {
    case CMsgInGamePrediction_ERawValueTypeT.Number:
      return "Number";
    case CMsgInGamePrediction_ERawValueTypeT.Time:
      return "Time";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum CMsgInGamePrediction_ERawValueTypeT");
  }
}

export enum CMsgInGamePrediction_EPredictionType {
  Generic = 0,
  Hero = 1,
  Team = 2,
  Player = 3,
  Special = 4,
  YesNo = 5,
  QualifiersTeam = 6,
}

export function cMsgInGamePrediction_EPredictionTypeFromJSON(object: any): CMsgInGamePrediction_EPredictionType {
  switch (object) {
    case 0:
    case "Generic":
      return CMsgInGamePrediction_EPredictionType.Generic;
    case 1:
    case "Hero":
      return CMsgInGamePrediction_EPredictionType.Hero;
    case 2:
    case "Team":
      return CMsgInGamePrediction_EPredictionType.Team;
    case 3:
    case "Player":
      return CMsgInGamePrediction_EPredictionType.Player;
    case 4:
    case "Special":
      return CMsgInGamePrediction_EPredictionType.Special;
    case 5:
    case "YesNo":
      return CMsgInGamePrediction_EPredictionType.YesNo;
    case 6:
    case "QualifiersTeam":
      return CMsgInGamePrediction_EPredictionType.QualifiersTeam;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgInGamePrediction_EPredictionType",
      );
  }
}

export function cMsgInGamePrediction_EPredictionTypeToJSON(object: CMsgInGamePrediction_EPredictionType): string {
  switch (object) {
    case CMsgInGamePrediction_EPredictionType.Generic:
      return "Generic";
    case CMsgInGamePrediction_EPredictionType.Hero:
      return "Hero";
    case CMsgInGamePrediction_EPredictionType.Team:
      return "Team";
    case CMsgInGamePrediction_EPredictionType.Player:
      return "Player";
    case CMsgInGamePrediction_EPredictionType.Special:
      return "Special";
    case CMsgInGamePrediction_EPredictionType.YesNo:
      return "YesNo";
    case CMsgInGamePrediction_EPredictionType.QualifiersTeam:
      return "QualifiersTeam";
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgInGamePrediction_EPredictionType",
      );
  }
}

export enum CMsgInGamePrediction_EResolutionTypeT {
  InvalidQuery = 0,
  FirstToPassQuery = 1,
  LastToPassQuery = 2,
  LastRemainingQuery = 3,
  MaxToPassQuery = 4,
  MinToPassQuery = 5,
  SumQuery = 6,
  MaxTeamSumToPassQuery = 7,
  MinTeamSumToPassQuery = 8,
}

export function cMsgInGamePrediction_EResolutionTypeTFromJSON(object: any): CMsgInGamePrediction_EResolutionTypeT {
  switch (object) {
    case 0:
    case "InvalidQuery":
      return CMsgInGamePrediction_EResolutionTypeT.InvalidQuery;
    case 1:
    case "FirstToPassQuery":
      return CMsgInGamePrediction_EResolutionTypeT.FirstToPassQuery;
    case 2:
    case "LastToPassQuery":
      return CMsgInGamePrediction_EResolutionTypeT.LastToPassQuery;
    case 3:
    case "LastRemainingQuery":
      return CMsgInGamePrediction_EResolutionTypeT.LastRemainingQuery;
    case 4:
    case "MaxToPassQuery":
      return CMsgInGamePrediction_EResolutionTypeT.MaxToPassQuery;
    case 5:
    case "MinToPassQuery":
      return CMsgInGamePrediction_EResolutionTypeT.MinToPassQuery;
    case 6:
    case "SumQuery":
      return CMsgInGamePrediction_EResolutionTypeT.SumQuery;
    case 7:
    case "MaxTeamSumToPassQuery":
      return CMsgInGamePrediction_EResolutionTypeT.MaxTeamSumToPassQuery;
    case 8:
    case "MinTeamSumToPassQuery":
      return CMsgInGamePrediction_EResolutionTypeT.MinTeamSumToPassQuery;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgInGamePrediction_EResolutionTypeT",
      );
  }
}

export function cMsgInGamePrediction_EResolutionTypeTToJSON(object: CMsgInGamePrediction_EResolutionTypeT): string {
  switch (object) {
    case CMsgInGamePrediction_EResolutionTypeT.InvalidQuery:
      return "InvalidQuery";
    case CMsgInGamePrediction_EResolutionTypeT.FirstToPassQuery:
      return "FirstToPassQuery";
    case CMsgInGamePrediction_EResolutionTypeT.LastToPassQuery:
      return "LastToPassQuery";
    case CMsgInGamePrediction_EResolutionTypeT.LastRemainingQuery:
      return "LastRemainingQuery";
    case CMsgInGamePrediction_EResolutionTypeT.MaxToPassQuery:
      return "MaxToPassQuery";
    case CMsgInGamePrediction_EResolutionTypeT.MinToPassQuery:
      return "MinToPassQuery";
    case CMsgInGamePrediction_EResolutionTypeT.SumQuery:
      return "SumQuery";
    case CMsgInGamePrediction_EResolutionTypeT.MaxTeamSumToPassQuery:
      return "MaxTeamSumToPassQuery";
    case CMsgInGamePrediction_EResolutionTypeT.MinTeamSumToPassQuery:
      return "MinTeamSumToPassQuery";
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgInGamePrediction_EResolutionTypeT",
      );
  }
}

export enum CMsgInGamePrediction_ERandomSelectionGroupT {
  EarlyGame = 0,
  MidGame = 1,
  LateGame = 2,
  Count = 3,
}

export function cMsgInGamePrediction_ERandomSelectionGroupTFromJSON(
  object: any,
): CMsgInGamePrediction_ERandomSelectionGroupT {
  switch (object) {
    case 0:
    case "EarlyGame":
      return CMsgInGamePrediction_ERandomSelectionGroupT.EarlyGame;
    case 1:
    case "MidGame":
      return CMsgInGamePrediction_ERandomSelectionGroupT.MidGame;
    case 2:
    case "LateGame":
      return CMsgInGamePrediction_ERandomSelectionGroupT.LateGame;
    case 3:
    case "Count":
      return CMsgInGamePrediction_ERandomSelectionGroupT.Count;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgInGamePrediction_ERandomSelectionGroupT",
      );
  }
}

export function cMsgInGamePrediction_ERandomSelectionGroupTToJSON(
  object: CMsgInGamePrediction_ERandomSelectionGroupT,
): string {
  switch (object) {
    case CMsgInGamePrediction_ERandomSelectionGroupT.EarlyGame:
      return "EarlyGame";
    case CMsgInGamePrediction_ERandomSelectionGroupT.MidGame:
      return "MidGame";
    case CMsgInGamePrediction_ERandomSelectionGroupT.LateGame:
      return "LateGame";
    case CMsgInGamePrediction_ERandomSelectionGroupT.Count:
      return "Count";
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgInGamePrediction_ERandomSelectionGroupT",
      );
  }
}

export interface CMsgInGamePrediction_QueryKeyValues {
  name?: string | undefined;
  value?: string | undefined;
}

export interface CMsgDOTASeasonPredictions {
  predictions: CMsgDOTASeasonPredictions_Prediction[];
  inGamePredictions: CMsgInGamePrediction[];
  inGamePredictionCountPerGame?: number | undefined;
  inGamePredictionVotingPeriodMinutes?: number | undefined;
}

export interface CMsgDOTASeasonPredictions_Prediction {
  type?: CMsgDOTASeasonPredictions_Prediction_EPredictionType | undefined;
  question?: string | undefined;
  choices: CMsgPredictionChoice[];
  selectionId?: number | undefined;
  startDate?: number | undefined;
  lockDate?: number | undefined;
  reward?: number | undefined;
  answerType?: CMsgDOTASeasonPredictions_Prediction_EAnswerType | undefined;
  answerId?: number | undefined;
  answers: CMsgDOTASeasonPredictions_Prediction_Answers[];
  queryName?: string | undefined;
  lockOnSelectionId?: number | undefined;
  lockOnSelectionValue?: number | undefined;
  lockOnSelectionSet?: boolean | undefined;
  useAnswerValueRanges?: boolean | undefined;
  region?: ELeagueRegion | undefined;
  phases: ELeaguePhase[];
  rewardEvent?: EEvent | undefined;
  leagueNodeId?: number | undefined;
}

export enum CMsgDOTASeasonPredictions_Prediction_EPredictionType {
  Generic = 0,
  Hero = 1,
  Team = 2,
  Player = 3,
  Special = 4,
  YesNo = 5,
  QualifiersTeam = 6,
  LastChanceTeam = 7,
}

export function cMsgDOTASeasonPredictions_Prediction_EPredictionTypeFromJSON(
  object: any,
): CMsgDOTASeasonPredictions_Prediction_EPredictionType {
  switch (object) {
    case 0:
    case "Generic":
      return CMsgDOTASeasonPredictions_Prediction_EPredictionType.Generic;
    case 1:
    case "Hero":
      return CMsgDOTASeasonPredictions_Prediction_EPredictionType.Hero;
    case 2:
    case "Team":
      return CMsgDOTASeasonPredictions_Prediction_EPredictionType.Team;
    case 3:
    case "Player":
      return CMsgDOTASeasonPredictions_Prediction_EPredictionType.Player;
    case 4:
    case "Special":
      return CMsgDOTASeasonPredictions_Prediction_EPredictionType.Special;
    case 5:
    case "YesNo":
      return CMsgDOTASeasonPredictions_Prediction_EPredictionType.YesNo;
    case 6:
    case "QualifiersTeam":
      return CMsgDOTASeasonPredictions_Prediction_EPredictionType.QualifiersTeam;
    case 7:
    case "LastChanceTeam":
      return CMsgDOTASeasonPredictions_Prediction_EPredictionType.LastChanceTeam;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgDOTASeasonPredictions_Prediction_EPredictionType",
      );
  }
}

export function cMsgDOTASeasonPredictions_Prediction_EPredictionTypeToJSON(
  object: CMsgDOTASeasonPredictions_Prediction_EPredictionType,
): string {
  switch (object) {
    case CMsgDOTASeasonPredictions_Prediction_EPredictionType.Generic:
      return "Generic";
    case CMsgDOTASeasonPredictions_Prediction_EPredictionType.Hero:
      return "Hero";
    case CMsgDOTASeasonPredictions_Prediction_EPredictionType.Team:
      return "Team";
    case CMsgDOTASeasonPredictions_Prediction_EPredictionType.Player:
      return "Player";
    case CMsgDOTASeasonPredictions_Prediction_EPredictionType.Special:
      return "Special";
    case CMsgDOTASeasonPredictions_Prediction_EPredictionType.YesNo:
      return "YesNo";
    case CMsgDOTASeasonPredictions_Prediction_EPredictionType.QualifiersTeam:
      return "QualifiersTeam";
    case CMsgDOTASeasonPredictions_Prediction_EPredictionType.LastChanceTeam:
      return "LastChanceTeam";
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgDOTASeasonPredictions_Prediction_EPredictionType",
      );
  }
}

export enum CMsgDOTASeasonPredictions_Prediction_EAnswerType {
  SingleInt = 0,
  SingleFloat = 1,
  MultipleInt = 2,
  MultipleFloat = 3,
  AnswerTeam = 4,
  SingleTime = 5,
  MultipleTime = 6,
  NoAnswer = 7,
}

export function cMsgDOTASeasonPredictions_Prediction_EAnswerTypeFromJSON(
  object: any,
): CMsgDOTASeasonPredictions_Prediction_EAnswerType {
  switch (object) {
    case 0:
    case "SingleInt":
      return CMsgDOTASeasonPredictions_Prediction_EAnswerType.SingleInt;
    case 1:
    case "SingleFloat":
      return CMsgDOTASeasonPredictions_Prediction_EAnswerType.SingleFloat;
    case 2:
    case "MultipleInt":
      return CMsgDOTASeasonPredictions_Prediction_EAnswerType.MultipleInt;
    case 3:
    case "MultipleFloat":
      return CMsgDOTASeasonPredictions_Prediction_EAnswerType.MultipleFloat;
    case 4:
    case "AnswerTeam":
      return CMsgDOTASeasonPredictions_Prediction_EAnswerType.AnswerTeam;
    case 5:
    case "SingleTime":
      return CMsgDOTASeasonPredictions_Prediction_EAnswerType.SingleTime;
    case 6:
    case "MultipleTime":
      return CMsgDOTASeasonPredictions_Prediction_EAnswerType.MultipleTime;
    case 7:
    case "NoAnswer":
      return CMsgDOTASeasonPredictions_Prediction_EAnswerType.NoAnswer;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgDOTASeasonPredictions_Prediction_EAnswerType",
      );
  }
}

export function cMsgDOTASeasonPredictions_Prediction_EAnswerTypeToJSON(
  object: CMsgDOTASeasonPredictions_Prediction_EAnswerType,
): string {
  switch (object) {
    case CMsgDOTASeasonPredictions_Prediction_EAnswerType.SingleInt:
      return "SingleInt";
    case CMsgDOTASeasonPredictions_Prediction_EAnswerType.SingleFloat:
      return "SingleFloat";
    case CMsgDOTASeasonPredictions_Prediction_EAnswerType.MultipleInt:
      return "MultipleInt";
    case CMsgDOTASeasonPredictions_Prediction_EAnswerType.MultipleFloat:
      return "MultipleFloat";
    case CMsgDOTASeasonPredictions_Prediction_EAnswerType.AnswerTeam:
      return "AnswerTeam";
    case CMsgDOTASeasonPredictions_Prediction_EAnswerType.SingleTime:
      return "SingleTime";
    case CMsgDOTASeasonPredictions_Prediction_EAnswerType.MultipleTime:
      return "MultipleTime";
    case CMsgDOTASeasonPredictions_Prediction_EAnswerType.NoAnswer:
      return "NoAnswer";
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgDOTASeasonPredictions_Prediction_EAnswerType",
      );
  }
}

export interface CMsgDOTASeasonPredictions_Prediction_Answers {
  answerId?: number | undefined;
}

export interface CMsgAvailablePredictions {
  matchPredictions: CMsgAvailablePredictions_MatchPrediction[];
}

export interface CMsgAvailablePredictions_MatchPrediction {
  matchId?: string | undefined;
  predictions: CMsgInGamePrediction[];
}

export interface CMsgLeagueWatchedGames {
  leagues: CMsgLeagueWatchedGames_League[];
}

export interface CMsgLeagueWatchedGames_Series {
  nodeId?: number | undefined;
  game: number[];
}

export interface CMsgLeagueWatchedGames_League {
  leagueId?: number | undefined;
  series: CMsgLeagueWatchedGames_Series[];
}

export interface CMsgDOTAMatch {
  duration?: number | undefined;
  starttime?: number | undefined;
  players: CMsgDOTAMatch_Player[];
  matchId?: string | undefined;
  towerStatus: number[];
  barracksStatus: number[];
  cluster?: number | undefined;
  firstBloodTime?: number | undefined;
  replaySalt?: number | undefined;
  serverIp?: number | undefined;
  serverPort?: number | undefined;
  lobbyType?: number | undefined;
  humanPlayers?: number | undefined;
  averageSkill?: number | undefined;
  gameBalance?: number | undefined;
  radiantTeamId?: number | undefined;
  direTeamId?: number | undefined;
  leagueid?: number | undefined;
  radiantTeamName?: string | undefined;
  direTeamName?: string | undefined;
  radiantTeamLogo?: string | undefined;
  direTeamLogo?: string | undefined;
  radiantTeamLogoUrl?: string | undefined;
  direTeamLogoUrl?: string | undefined;
  radiantTeamComplete?: number | undefined;
  direTeamComplete?: number | undefined;
  gameMode?: DOTAGameMode | undefined;
  picksBans: CMatchHeroSelectEvent[];
  matchSeqNum?: string | undefined;
  replayState?: CMsgDOTAMatch_ReplayState | undefined;
  radiantGuildId?: number | undefined;
  direGuildId?: number | undefined;
  radiantTeamTag?: string | undefined;
  direTeamTag?: string | undefined;
  seriesId?: number | undefined;
  seriesType?: number | undefined;
  broadcasterChannels: CMsgDOTAMatch_BroadcasterChannel[];
  engine?: number | undefined;
  customGameData?: CMsgDOTAMatch_CustomGameData | undefined;
  matchFlags?: number | undefined;
  privateMetadataKey?: number | undefined;
  radiantTeamScore?: number | undefined;
  direTeamScore?: number | undefined;
  matchOutcome?: EMatchOutcome | undefined;
  tournamentId?: number | undefined;
  tournamentRound?: number | undefined;
  preGameDuration?: number | undefined;
  coaches: CMsgDOTAMatch_Coach[];
}

export enum CMsgDOTAMatch_ReplayState {
  REPLAY_AVAILABLE = 0,
  REPLAY_NOT_RECORDED = 1,
  REPLAY_EXPIRED = 2,
}

export function cMsgDOTAMatch_ReplayStateFromJSON(object: any): CMsgDOTAMatch_ReplayState {
  switch (object) {
    case 0:
    case "REPLAY_AVAILABLE":
      return CMsgDOTAMatch_ReplayState.REPLAY_AVAILABLE;
    case 1:
    case "REPLAY_NOT_RECORDED":
      return CMsgDOTAMatch_ReplayState.REPLAY_NOT_RECORDED;
    case 2:
    case "REPLAY_EXPIRED":
      return CMsgDOTAMatch_ReplayState.REPLAY_EXPIRED;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum CMsgDOTAMatch_ReplayState");
  }
}

export function cMsgDOTAMatch_ReplayStateToJSON(object: CMsgDOTAMatch_ReplayState): string {
  switch (object) {
    case CMsgDOTAMatch_ReplayState.REPLAY_AVAILABLE:
      return "REPLAY_AVAILABLE";
    case CMsgDOTAMatch_ReplayState.REPLAY_NOT_RECORDED:
      return "REPLAY_NOT_RECORDED";
    case CMsgDOTAMatch_ReplayState.REPLAY_EXPIRED:
      return "REPLAY_EXPIRED";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum CMsgDOTAMatch_ReplayState");
  }
}

export interface CMsgDOTAMatch_Player {
  accountId?: number | undefined;
  playerSlot?: number | undefined;
  heroId?: number | undefined;
  item0?: number | undefined;
  item1?: number | undefined;
  item2?: number | undefined;
  item3?: number | undefined;
  item4?: number | undefined;
  item5?: number | undefined;
  item6?: number | undefined;
  item7?: number | undefined;
  item8?: number | undefined;
  item9?: number | undefined;
  item10?: number | undefined;
  item10Lvl?: number | undefined;
  expectedTeamContribution?: number | undefined;
  scaledMetric?: number | undefined;
  previousRank?: number | undefined;
  rankChange?: number | undefined;
  mmrType?: number | undefined;
  kills?: number | undefined;
  deaths?: number | undefined;
  assists?: number | undefined;
  leaverStatus?: number | undefined;
  gold?: number | undefined;
  lastHits?: number | undefined;
  denies?: number | undefined;
  goldPerMin?: number | undefined;
  xpPerMin?: number | undefined;
  goldSpent?: number | undefined;
  heroDamage?: number | undefined;
  towerDamage?: number | undefined;
  heroHealing?: number | undefined;
  level?: number | undefined;
  timeLastSeen?: number | undefined;
  playerName?: string | undefined;
  supportAbilityValue?: number | undefined;
  feedingDetected?: boolean | undefined;
  searchRank?: number | undefined;
  searchRankUncertainty?: number | undefined;
  rankUncertaintyChange?: number | undefined;
  heroPlayCount?: number | undefined;
  partyId?: string | undefined;
  scaledHeroDamage?: number | undefined;
  scaledTowerDamage?: number | undefined;
  scaledHeroHealing?: number | undefined;
  scaledKills?: number | undefined;
  scaledDeaths?: number | undefined;
  scaledAssists?: number | undefined;
  claimedFarmGold?: number | undefined;
  supportGold?: number | undefined;
  claimedDenies?: number | undefined;
  claimedMisses?: number | undefined;
  misses?: number | undefined;
  abilityUpgrades: CMatchPlayerAbilityUpgrade[];
  additionalUnitsInventory: CMatchAdditionalUnitInventory[];
  permanentBuffs: CMatchPlayerPermanentBuff[];
  proName?: string | undefined;
  realName?: string | undefined;
  customGameData?: CMsgDOTAMatch_Player_CustomGameData | undefined;
  activePlusSubscription?: boolean | undefined;
  netWorth?: number | undefined;
  botDifficulty?: number | undefined;
  heroPickOrder?: number | undefined;
  heroWasRandomed?: boolean | undefined;
  heroWasDotaPlusSuggestion?: boolean | undefined;
  heroDamageReceived: CMsgDOTAMatch_Player_HeroDamageReceived[];
  heroDamageDealt: CMsgDOTAMatch_Player_HeroDamageReceived[];
  secondsDead?: number | undefined;
  goldLostToDeath?: number | undefined;
  laneSelectionFlags?: number | undefined;
  bountyRunes?: number | undefined;
  outpostsCaptured?: number | undefined;
  teamNumber?: dotaGcTeam | undefined;
  teamSlot?: number | undefined;
  selectedFacet?: number | undefined;
}

export enum CMsgDOTAMatch_Player_HeroDamageType {
  HERO_DAMAGE_PHYSICAL = 0,
  HERO_DAMAGE_MAGICAL = 1,
  HERO_DAMAGE_PURE = 2,
}

export function cMsgDOTAMatch_Player_HeroDamageTypeFromJSON(object: any): CMsgDOTAMatch_Player_HeroDamageType {
  switch (object) {
    case 0:
    case "HERO_DAMAGE_PHYSICAL":
      return CMsgDOTAMatch_Player_HeroDamageType.HERO_DAMAGE_PHYSICAL;
    case 1:
    case "HERO_DAMAGE_MAGICAL":
      return CMsgDOTAMatch_Player_HeroDamageType.HERO_DAMAGE_MAGICAL;
    case 2:
    case "HERO_DAMAGE_PURE":
      return CMsgDOTAMatch_Player_HeroDamageType.HERO_DAMAGE_PURE;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum CMsgDOTAMatch_Player_HeroDamageType");
  }
}

export function cMsgDOTAMatch_Player_HeroDamageTypeToJSON(object: CMsgDOTAMatch_Player_HeroDamageType): string {
  switch (object) {
    case CMsgDOTAMatch_Player_HeroDamageType.HERO_DAMAGE_PHYSICAL:
      return "HERO_DAMAGE_PHYSICAL";
    case CMsgDOTAMatch_Player_HeroDamageType.HERO_DAMAGE_MAGICAL:
      return "HERO_DAMAGE_MAGICAL";
    case CMsgDOTAMatch_Player_HeroDamageType.HERO_DAMAGE_PURE:
      return "HERO_DAMAGE_PURE";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum CMsgDOTAMatch_Player_HeroDamageType");
  }
}

export interface CMsgDOTAMatch_Player_CustomGameData {
  dotaTeam?: number | undefined;
  winner?: boolean | undefined;
}

export interface CMsgDOTAMatch_Player_HeroDamageReceived {
  preReduction?: number | undefined;
  postReduction?: number | undefined;
  damageType?: CMsgDOTAMatch_Player_HeroDamageType | undefined;
}

export interface CMsgDOTAMatch_BroadcasterInfo {
  accountId?: number | undefined;
  name?: string | undefined;
}

export interface CMsgDOTAMatch_BroadcasterChannel {
  countryCode?: string | undefined;
  description?: string | undefined;
  broadcasterInfos: CMsgDOTAMatch_BroadcasterInfo[];
  languageCode?: string | undefined;
}

export interface CMsgDOTAMatch_Coach {
  accountId?: number | undefined;
  coachName?: string | undefined;
  coachRating?: number | undefined;
  coachTeam?: number | undefined;
  coachPartyId?: string | undefined;
  isPrivateCoach?: boolean | undefined;
}

export interface CMsgDOTAMatch_CustomGameData {
  customGameId?: string | undefined;
  mapName?: string | undefined;
}

export interface CMsgPlayerCard {
  accountId?: number | undefined;
  statModifier: CMsgPlayerCard_StatModifier[];
}

export interface CMsgPlayerCard_StatModifier {
  stat?: number | undefined;
  value?: number | undefined;
}

export interface CMsgDOTAFantasyPlayerStats {
  playerAccountId?: number | undefined;
  matchId?: string | undefined;
  matchCompleted?: boolean | undefined;
  teamId?: number | undefined;
  leagueId?: number | undefined;
  delay?: number | undefined;
  seriesId?: number | undefined;
  seriesType?: number | undefined;
  kills?: number | undefined;
  deaths?: number | undefined;
  cs?: number | undefined;
  gpm?: number | undefined;
  towerKills?: number | undefined;
  roshanKills?: number | undefined;
  teamfightParticipation?: number | undefined;
  wardsPlaced?: number | undefined;
  campsStacked?: number | undefined;
  runesGrabbed?: number | undefined;
  firstBlood?: number | undefined;
  stuns?: number | undefined;
  smokes?: number | undefined;
  neutralTokens?: number | undefined;
  watchers?: number | undefined;
  lotuses?: number | undefined;
  tormentors?: number | undefined;
  courierKills?: number | undefined;
  titleStats?: string | undefined;
}

export interface CMsgDOTAFantasyPlayerMatchStats {
  matches: CMsgDOTAFantasyPlayerStats[];
}

export interface CMsgDOTABotDebugInfo {
  bots: CMsgDOTABotDebugInfo_Bot[];
  desirePushLaneTop?: number | undefined;
  desirePushLaneMid?: number | undefined;
  desirePushLaneBot?: number | undefined;
  desireDefendLaneTop?: number | undefined;
  desireDefendLaneMid?: number | undefined;
  desireDefendLaneBot?: number | undefined;
  desireFarmLaneTop?: number | undefined;
  desireFarmLaneMid?: number | undefined;
  desireFarmLaneBot?: number | undefined;
  desireFarmRoshan?: number | undefined;
  executionTime?: number | undefined;
  runeStatus: number[];
}

export interface CMsgDOTABotDebugInfo_Bot {
  playerOwnerId?: number | undefined;
  heroId?: number | undefined;
  difficulty?: number | undefined;
  powerCurrent?: number | undefined;
  powerMax?: number | undefined;
  moveTargetX?: number | undefined;
  moveTargetY?: number | undefined;
  moveTargetZ?: number | undefined;
  activeModeId?: number | undefined;
  executionTime?: number | undefined;
  modes: CMsgDOTABotDebugInfo_Bot_Mode[];
  action?: CMsgDOTABotDebugInfo_Bot_Action | undefined;
}

export interface CMsgDOTABotDebugInfo_Bot_Mode {
  modeId?: number | undefined;
  desire?: number | undefined;
  targetEntity?: number | undefined;
  targetX?: number | undefined;
  targetY?: number | undefined;
  targetZ?: number | undefined;
}

export interface CMsgDOTABotDebugInfo_Bot_Action {
  actionId?: number | undefined;
  actionTarget?: string | undefined;
}

export interface CMsgSuccessfulHero {
  heroId?: number | undefined;
  winPercent?: number | undefined;
  longestStreak?: number | undefined;
}

export interface CMsgRecentMatchInfo {
  matchId?: string | undefined;
  gameMode?: DOTAGameMode | undefined;
  kills?: number | undefined;
  deaths?: number | undefined;
  assists?: number | undefined;
  duration?: number | undefined;
  playerSlot?: number | undefined;
  matchOutcome?: EMatchOutcome | undefined;
  timestamp?: number | undefined;
  lobbyType?: number | undefined;
  teamNumber?: number | undefined;
}

export interface CMsgMatchTips {
  tips: CMsgMatchTips_SingleTip[];
}

export interface CMsgMatchTips_SingleTip {
  sourceAccountId?: number | undefined;
  targetAccountId?: number | undefined;
  tipAmount?: number | undefined;
  eventId?: EEvent | undefined;
}

export interface CMsgDOTAMatchMinimal {
  matchId?: string | undefined;
  startTime?: number | undefined;
  duration?: number | undefined;
  gameMode?: DOTAGameMode | undefined;
  players: CMsgDOTAMatchMinimal_Player[];
  tourney?: CMsgDOTAMatchMinimal_Tourney | undefined;
  matchOutcome?: EMatchOutcome | undefined;
  radiantScore?: number | undefined;
  direScore?: number | undefined;
  lobbyType?: number | undefined;
}

export interface CMsgDOTAMatchMinimal_Player {
  accountId?: number | undefined;
  heroId?: number | undefined;
  kills?: number | undefined;
  deaths?: number | undefined;
  assists?: number | undefined;
  items: number[];
  playerSlot?: number | undefined;
  proName?: string | undefined;
  level?: number | undefined;
  teamNumber?: dotaGcTeam | undefined;
}

export interface CMsgDOTAMatchMinimal_Tourney {
  leagueId?: number | undefined;
  seriesType?: number | undefined;
  seriesGame?: number | undefined;
  weekendTourneyTournamentId?: number | undefined;
  weekendTourneySeasonTrophyId?: number | undefined;
  weekendTourneyDivision?: number | undefined;
  weekendTourneySkillLevel?: number | undefined;
  radiantTeamId?: number | undefined;
  radiantTeamName?: string | undefined;
  radiantTeamLogo?: string | undefined;
  radiantTeamLogoUrl?: string | undefined;
  direTeamId?: number | undefined;
  direTeamName?: string | undefined;
  direTeamLogo?: string | undefined;
  direTeamLogoUrl?: string | undefined;
}

export interface CMsgConsumableUsage {
  itemDef?: number | undefined;
  quantityChange?: number | undefined;
}

export interface CMsgMatchConsumableUsage {
  playerConsumablesUsed: CMsgMatchConsumableUsage_PlayerUsage[];
}

export interface CMsgMatchConsumableUsage_PlayerUsage {
  accountId?: number | undefined;
  consumablesUsed: CMsgConsumableUsage[];
}

export interface CMsgMatchEventActionGrants {
  playerGrants: CMsgMatchEventActionGrants_PlayerGrants[];
}

export interface CMsgMatchEventActionGrants_PlayerGrants {
  accountId?: number | undefined;
  actionsGranted: CMsgPendingEventAward[];
}

export interface CMsgCustomGameWhitelist {
  version?: number | undefined;
  customGamesWhitelist: string[];
  disableWhitelist?: boolean | undefined;
}

export interface CMsgCustomGameWhitelistForEdit {
  whitelistEntries: CMsgCustomGameWhitelistForEdit_WhitelistEntry[];
}

export interface CMsgCustomGameWhitelistForEdit_WhitelistEntry {
  customGameId?: string | undefined;
  whitelistState?: ECustomGameWhitelistState | undefined;
}

export interface CMsgPlayerRecentMatchInfo {
  matchId?: string | undefined;
  timestamp?: number | undefined;
  duration?: number | undefined;
  win?: boolean | undefined;
  heroId?: number | undefined;
  kills?: number | undefined;
  deaths?: number | undefined;
  assists?: number | undefined;
}

export interface CMsgPlayerMatchRecord {
  wins?: number | undefined;
  losses?: number | undefined;
}

export interface CMsgPlayerRecentMatchOutcomes {
  outcomes?: number | undefined;
  matchCount?: number | undefined;
}

export interface CMsgPlayerRecentCommends {
  commends?: number | undefined;
  matchCount?: number | undefined;
}

export interface CMsgPlayerRecentAccomplishments {
  recentOutcomes?: CMsgPlayerRecentMatchOutcomes | undefined;
  totalRecord?: CMsgPlayerMatchRecord | undefined;
  predictionStreak?: number | undefined;
  plusPredictionStreak?: number | undefined;
  recentCommends?: CMsgPlayerRecentCommends | undefined;
  firstMatchTimestamp?: number | undefined;
  lastMatch?: CMsgPlayerRecentMatchInfo | undefined;
  recentMvps?: CMsgPlayerRecentMatchOutcomes | undefined;
}

export interface CMsgPlayerHeroRecentAccomplishments {
  recentOutcomes?: CMsgPlayerRecentMatchOutcomes | undefined;
  totalRecord?: CMsgPlayerMatchRecord | undefined;
  lastMatch?: CMsgPlayerRecentMatchInfo | undefined;
}

export interface CMsgRecentAccomplishments {
  playerAccomplishments?: CMsgPlayerRecentAccomplishments | undefined;
  heroAccomplishments?: CMsgPlayerHeroRecentAccomplishments | undefined;
}

export interface CMsgServerToGCRequestPlayerRecentAccomplishments {
  accountId?: number | undefined;
  heroId?: number | undefined;
}

export interface CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse {
  result?: CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse_EResponse | undefined;
  playerAccomplishments?: CMsgRecentAccomplishments | undefined;
}

export enum CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse_EResponse {
  k_eInternalError = 0,
  k_eSuccess = 1,
  k_eTooBusy = 2,
  k_eDisabled = 3,
}

export function cMsgServerToGCRequestPlayerRecentAccomplishmentsResponse_EResponseFromJSON(
  object: any,
): CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse_EResponse {
  switch (object) {
    case 0:
    case "k_eInternalError":
      return CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse_EResponse.k_eInternalError;
    case 1:
    case "k_eSuccess":
      return CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse_EResponse.k_eSuccess;
    case 2:
    case "k_eTooBusy":
      return CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse_EResponse.k_eTooBusy;
    case 3:
    case "k_eDisabled":
      return CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse_EResponse.k_eDisabled;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object +
          " for enum CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse_EResponse",
      );
  }
}

export function cMsgServerToGCRequestPlayerRecentAccomplishmentsResponse_EResponseToJSON(
  object: CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse_EResponse,
): string {
  switch (object) {
    case CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse_EResponse.k_eInternalError:
      return "k_eInternalError";
    case CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse_EResponse.k_eSuccess:
      return "k_eSuccess";
    case CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse_EResponse.k_eTooBusy:
      return "k_eTooBusy";
    case CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse_EResponse.k_eDisabled:
      return "k_eDisabled";
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object +
          " for enum CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse_EResponse",
      );
  }
}

export interface CMsgArcanaVoteMatchVotes {
  matchId?: number | undefined;
  heroId?: number | undefined;
  voteCount?: number | undefined;
}

export interface CMsgGCtoGCAssociatedExploiterAccountInfo {
  accountId?: number | undefined;
  numMatchesToSearch?: number | undefined;
  minSharedMatchCount?: number | undefined;
  numAdditionalPlayers?: number | undefined;
}

export interface CMsgGCtoGCAssociatedExploiterAccountInfoResponse {
  accounts: CMsgGCtoGCAssociatedExploiterAccountInfoResponse_Account[];
}

export interface CMsgGCtoGCAssociatedExploiterAccountInfoResponse_Account {
  accountId?: number | undefined;
  numCommonMatches?: number | undefined;
  earliestCommonMatch?: number | undefined;
  latestCommonMatch?: number | undefined;
  generation?: number | undefined;
  persona?: string | undefined;
  alreadyBanned?: boolean | undefined;
}

export interface CMsgPullTabsData {
  slots: CMsgPullTabsData_Slot[];
  jackpots: CMsgPullTabsData_Jackpot[];
  lastBoard?: number | undefined;
}

export interface CMsgPullTabsData_Slot {
  eventId?: number | undefined;
  boardId?: number | undefined;
  heroId?: number | undefined;
  actionId?: number | undefined;
  redeemed?: boolean | undefined;
}

export interface CMsgPullTabsData_Jackpot {
  boardId?: number | undefined;
  actionId?: number | undefined;
  heroId?: number | undefined;
}

export interface CMsgUnderDraftData {
  benchSlots: CMsgUnderDraftData_BenchSlot[];
  shopSlots: CMsgUnderDraftData_ShopSlot[];
  gold?: number | undefined;
  totalGold?: number | undefined;
  notRestorable?: boolean | undefined;
}

export interface CMsgUnderDraftData_BenchSlot {
  slotId?: number | undefined;
  heroId?: number | undefined;
  stars?: number | undefined;
}

export interface CMsgUnderDraftData_ShopSlot {
  slotId?: number | undefined;
  heroId?: number | undefined;
  isSpecialReward?: boolean | undefined;
}

export interface CMsgPlayerTitleData {
  title: number[];
  eventId: number[];
  active?: number | undefined;
}

export interface CMsgDOTATriviaQuestion {
  questionId?: number | undefined;
  category?: EDOTATriviaQuestionCategory | undefined;
  timestamp?: number | undefined;
  questionValue?: string | undefined;
  answerValues: string[];
  correctAnswerIndex?: number | undefined;
}

export interface CMsgDOTATriviaQuestionAnswersSummary {
  summaryAvailable?: boolean | undefined;
  pickedCount: number[];
}

export interface CMsgGameDataSpecialValueBonus {
  name?: string | undefined;
  value?: number | undefined;
  operation?: number | undefined;
}

export interface CMsgGameDataSpecialValues {
  name?: string | undefined;
  valuesFloat: number[];
  isPercentage?: boolean | undefined;
  headingLoc?: string | undefined;
  bonuses: CMsgGameDataSpecialValueBonus[];
  valuesShard: number[];
  valuesScepter: number[];
  facetBonus?: CMsgGameDataFacetAbilityBonus | undefined;
  requiredFacet?: string | undefined;
}

export interface CMsgGameDataFacetAbilityBonus {
  name?: string | undefined;
  values: number[];
  operation?: number | undefined;
}

export interface CMsgGameDataAbilityOrItem {
  id?: number | undefined;
  name?: string | undefined;
  nameLoc?: string | undefined;
  descLoc?: string | undefined;
  loreLoc?: string | undefined;
  notesLoc: string[];
  shardLoc?: string | undefined;
  scepterLoc?: string | undefined;
  facetsLoc: string[];
  type?: number | undefined;
  behavior?: string | undefined;
  targetTeam?: number | undefined;
  targetType?: number | undefined;
  flags?: number | undefined;
  damage?: number | undefined;
  immunity?: number | undefined;
  dispellable?: number | undefined;
  maxLevel?: number | undefined;
  castRanges: number[];
  castPoints: number[];
  channelTimes: number[];
  cooldowns: number[];
  durations: number[];
  damages: number[];
  manaCosts: number[];
  goldCosts: number[];
  healthCosts: number[];
  specialValues: CMsgGameDataSpecialValues[];
  isItem?: boolean | undefined;
  abilityHasScepter?: boolean | undefined;
  abilityHasShard?: boolean | undefined;
  abilityIsGrantedByScepter?: boolean | undefined;
  abilityIsGrantedByShard?: boolean | undefined;
  abilityIsInnate?: boolean | undefined;
  itemCost?: number | undefined;
  itemInitialCharges?: number | undefined;
  itemNeutralTier?: number | undefined;
  itemStockMax?: number | undefined;
  itemStockTime?: number | undefined;
  itemQuality?: number | undefined;
}

export interface CMsgGameDataAbilityOrItemList {
  abilities: CMsgGameDataAbilityOrItem[];
}

export interface CMsgGameDataHero {
  id?: number | undefined;
  name?: string | undefined;
  orderId?: number | undefined;
  nameLoc?: string | undefined;
  bioLoc?: string | undefined;
  hypeLoc?: string | undefined;
  npeDescLoc?: string | undefined;
  facets: CMsgGameDataHero_Facet[];
  strBase?: number | undefined;
  strGain?: number | undefined;
  agiBase?: number | undefined;
  agiGain?: number | undefined;
  intBase?: number | undefined;
  intGain?: number | undefined;
  primaryAttr?: number | undefined;
  complexity?: number | undefined;
  attackCapability?: number | undefined;
  roleLevels: number[];
  damageMin?: number | undefined;
  damageMax?: number | undefined;
  attackRate?: number | undefined;
  attackRange?: number | undefined;
  projectileSpeed?: number | undefined;
  armor?: number | undefined;
  magicResistance?: number | undefined;
  movementSpeed?: number | undefined;
  turnRate?: number | undefined;
  sightRangeDay?: number | undefined;
  sightRangeNight?: number | undefined;
  maxHealth?: number | undefined;
  healthRegen?: number | undefined;
  maxMana?: number | undefined;
  manaRegen?: number | undefined;
  abilities: CMsgGameDataAbilityOrItem[];
  talents: CMsgGameDataAbilityOrItem[];
  facetAbilities: CMsgGameDataAbilityOrItemList[];
}

export interface CMsgGameDataHero_Facet {
  color?: number | undefined;
  titleLoc?: string | undefined;
  descriptionLoc?: string | undefined;
  name?: string | undefined;
  icon?: string | undefined;
  gradientId?: number | undefined;
}

export interface CMsgGameDataAbilities {
  abilities: CMsgGameDataAbilityOrItem[];
}

export interface CMsgGameDataItems {
  items: CMsgGameDataAbilityOrItem[];
}

export interface CMsgGameDataHeroes {
  heroes: CMsgGameDataHero[];
}

export interface CMsgGameDataHeroList {
  heroes: CMsgGameDataHeroList_HeroInfo[];
}

export interface CMsgGameDataHeroList_HeroInfo {
  id?: number | undefined;
  name?: string | undefined;
  nameLoc?: string | undefined;
  nameEnglishLoc?: string | undefined;
  primaryAttr?: number | undefined;
  complexity?: number | undefined;
}

export interface CMsgGameDataItemAbilityList {
  itemabilities: CMsgGameDataItemAbilityList_ItemAbilityInfo[];
}

export interface CMsgGameDataItemAbilityList_ItemAbilityInfo {
  id?: number | undefined;
  name?: string | undefined;
  nameLoc?: string | undefined;
  nameEnglishLoc?: string | undefined;
  neutralItemTier?: number | undefined;
  isPregameSuggested?: boolean | undefined;
  isEarlygameSuggested?: boolean | undefined;
  isLategameSuggested?: boolean | undefined;
  recipes: CMsgGameDataItemAbilityList_ItemAbilityInfo_Recipe[];
}

export interface CMsgGameDataItemAbilityList_ItemAbilityInfo_Recipe {
  items: number[];
}

export interface CMsgLobbyAbilityDraftData {
  shuffleDraftOrder?: boolean | undefined;
}

export interface CSOEconItemDropRateBonus {
  accountId?: number | undefined;
  expirationDate?: number | undefined;
  bonus?: number | undefined;
  bonusCount?: number | undefined;
  itemId?: string | undefined;
  defIndex?: number | undefined;
  secondsLeft?: number | undefined;
  boosterType?: number | undefined;
}

export interface CSOEconItemTournamentPassport {
  accountId?: number | undefined;
  leagueId?: number | undefined;
  itemId?: string | undefined;
  originalPurchaserId?: number | undefined;
  passportsBought?: number | undefined;
  version?: number | undefined;
  defIndex?: number | undefined;
  rewardFlags?: number | undefined;
}

export interface CMsgStickerbookSticker {
  itemDefId?: number | undefined;
  stickerNum?: number | undefined;
  quality?: number | undefined;
  positionX?: number | undefined;
  positionY?: number | undefined;
  positionZ?: number | undefined;
  rotation?: number | undefined;
  scale?: number | undefined;
  sourceItemId?: string | undefined;
  depthBias?: number | undefined;
}

export interface CMsgStickerbookPage {
  pageNum?: number | undefined;
  eventId?: EEvent | undefined;
  teamId?: number | undefined;
  stickers: CMsgStickerbookSticker[];
  pageType?: EStickerbookPageType | undefined;
}

export interface CMsgStickerbookTeamPageOrderSequence {
  pageNumbers: number[];
}

export interface CMsgStickerbook {
  pages: CMsgStickerbookPage[];
  teamPageOrderSequence?: CMsgStickerbookTeamPageOrderSequence | undefined;
  favoritePageNum?: number | undefined;
}

export interface CMsgStickerHero {
  heroId?: number | undefined;
  itemDefId?: number | undefined;
  quality?: number | undefined;
  sourceItemId?: string | undefined;
}

export interface CMsgStickerHeroes {
  heroes: CMsgStickerHero[];
}

export interface CMsgHeroRoleStats {
  laneSelectionFlags?: number | undefined;
  matchCount?: number | undefined;
  winCount?: number | undefined;
}

export interface CMsgHeroRoleHeroStats {
  heroId?: number | undefined;
  roleStats: CMsgHeroRoleStats[];
}

export interface CMsgHeroRoleRankStats {
  rankTier?: number | undefined;
  heroStats: CMsgHeroRoleHeroStats[];
}

export interface CMsgHeroRoleAllRanksStats {
  startTimestamp?: number | undefined;
  endTimestamp?: number | undefined;
  rankStats: CMsgHeroRoleRankStats[];
}

export interface CMsgMapStatsSnapshot {
  timestamp?: number | undefined;
  lotusesGained?: string | undefined;
  wisdomRunesGained?: string | undefined;
  roshanKillsDay?: string | undefined;
  roshanKillsNight?: string | undefined;
  portalsUsed?: string | undefined;
  watchersTaken?: string | undefined;
  tormentorKills?: string | undefined;
  outpostsCaptured?: string | undefined;
  shieldRunesGained?: string | undefined;
}

export interface CMsgGlobalMapStats {
  current?: CMsgMapStatsSnapshot | undefined;
  windowStart?: CMsgMapStatsSnapshot | undefined;
  windowEnd?: CMsgMapStatsSnapshot | undefined;
}

export interface CMsgTrackedStat {
  trackedStatId?: number | undefined;
  trackedStatValue?: number | undefined;
}

export interface CMsgDOTAClaimEventActionResponse {
  result?: CMsgDOTAClaimEventActionResponse_ResultCode | undefined;
  rewardResults: CMsgDOTAClaimEventActionResponse_GrantedRewardData[];
  actionId?: number | undefined;
}

export enum CMsgDOTAClaimEventActionResponse_ResultCode {
  Success = 0,
  InvalidEvent = 1,
  EventNotActive = 2,
  InvalidAction = 3,
  ServerError = 4,
  InsufficientPoints = 5,
  InsufficentLevel = 6,
  AlreadyClaimed = 7,
  SDOLockFailure = 8,
  SDOLoadFailure = 9,
  EventNotOwned = 10,
  Timeout = 11,
  RequiresPlusSubscription = 12,
  InvalidItem = 13,
  AsyncRewards = 14,
}

export function cMsgDOTAClaimEventActionResponse_ResultCodeFromJSON(
  object: any,
): CMsgDOTAClaimEventActionResponse_ResultCode {
  switch (object) {
    case 0:
    case "Success":
      return CMsgDOTAClaimEventActionResponse_ResultCode.Success;
    case 1:
    case "InvalidEvent":
      return CMsgDOTAClaimEventActionResponse_ResultCode.InvalidEvent;
    case 2:
    case "EventNotActive":
      return CMsgDOTAClaimEventActionResponse_ResultCode.EventNotActive;
    case 3:
    case "InvalidAction":
      return CMsgDOTAClaimEventActionResponse_ResultCode.InvalidAction;
    case 4:
    case "ServerError":
      return CMsgDOTAClaimEventActionResponse_ResultCode.ServerError;
    case 5:
    case "InsufficientPoints":
      return CMsgDOTAClaimEventActionResponse_ResultCode.InsufficientPoints;
    case 6:
    case "InsufficentLevel":
      return CMsgDOTAClaimEventActionResponse_ResultCode.InsufficentLevel;
    case 7:
    case "AlreadyClaimed":
      return CMsgDOTAClaimEventActionResponse_ResultCode.AlreadyClaimed;
    case 8:
    case "SDOLockFailure":
      return CMsgDOTAClaimEventActionResponse_ResultCode.SDOLockFailure;
    case 9:
    case "SDOLoadFailure":
      return CMsgDOTAClaimEventActionResponse_ResultCode.SDOLoadFailure;
    case 10:
    case "EventNotOwned":
      return CMsgDOTAClaimEventActionResponse_ResultCode.EventNotOwned;
    case 11:
    case "Timeout":
      return CMsgDOTAClaimEventActionResponse_ResultCode.Timeout;
    case 12:
    case "RequiresPlusSubscription":
      return CMsgDOTAClaimEventActionResponse_ResultCode.RequiresPlusSubscription;
    case 13:
    case "InvalidItem":
      return CMsgDOTAClaimEventActionResponse_ResultCode.InvalidItem;
    case 14:
    case "AsyncRewards":
      return CMsgDOTAClaimEventActionResponse_ResultCode.AsyncRewards;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgDOTAClaimEventActionResponse_ResultCode",
      );
  }
}

export function cMsgDOTAClaimEventActionResponse_ResultCodeToJSON(
  object: CMsgDOTAClaimEventActionResponse_ResultCode,
): string {
  switch (object) {
    case CMsgDOTAClaimEventActionResponse_ResultCode.Success:
      return "Success";
    case CMsgDOTAClaimEventActionResponse_ResultCode.InvalidEvent:
      return "InvalidEvent";
    case CMsgDOTAClaimEventActionResponse_ResultCode.EventNotActive:
      return "EventNotActive";
    case CMsgDOTAClaimEventActionResponse_ResultCode.InvalidAction:
      return "InvalidAction";
    case CMsgDOTAClaimEventActionResponse_ResultCode.ServerError:
      return "ServerError";
    case CMsgDOTAClaimEventActionResponse_ResultCode.InsufficientPoints:
      return "InsufficientPoints";
    case CMsgDOTAClaimEventActionResponse_ResultCode.InsufficentLevel:
      return "InsufficentLevel";
    case CMsgDOTAClaimEventActionResponse_ResultCode.AlreadyClaimed:
      return "AlreadyClaimed";
    case CMsgDOTAClaimEventActionResponse_ResultCode.SDOLockFailure:
      return "SDOLockFailure";
    case CMsgDOTAClaimEventActionResponse_ResultCode.SDOLoadFailure:
      return "SDOLoadFailure";
    case CMsgDOTAClaimEventActionResponse_ResultCode.EventNotOwned:
      return "EventNotOwned";
    case CMsgDOTAClaimEventActionResponse_ResultCode.Timeout:
      return "Timeout";
    case CMsgDOTAClaimEventActionResponse_ResultCode.RequiresPlusSubscription:
      return "RequiresPlusSubscription";
    case CMsgDOTAClaimEventActionResponse_ResultCode.InvalidItem:
      return "InvalidItem";
    case CMsgDOTAClaimEventActionResponse_ResultCode.AsyncRewards:
      return "AsyncRewards";
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgDOTAClaimEventActionResponse_ResultCode",
      );
  }
}

export interface CMsgDOTAClaimEventActionResponse_MysteryItemRewardData {
  itemDef?: number | undefined;
  itemCategory?: number | undefined;
}

export interface CMsgDOTAClaimEventActionResponse_LootListRewardData {
  itemDef: number[];
}

export interface CMsgDOTAClaimEventActionResponse_ActionListRewardData {
  actionId?: number | undefined;
  resultRewardData?: Buffer | undefined;
}

export interface CMsgDOTAClaimEventActionResponse_OverworldTokenRewardData {
  tokens: CMsgDOTAClaimEventActionResponse_OverworldTokenRewardData_TokenQuantity[];
}

export interface CMsgDOTAClaimEventActionResponse_OverworldTokenRewardData_TokenQuantity {
  tokenId?: number | undefined;
  tokenCount?: number | undefined;
}

export interface CMsgDOTAClaimEventActionResponse_GrantedRewardData {
  grantIndex?: number | undefined;
  scoreIndex?: number | undefined;
  rewardIndex?: number | undefined;
  rewardData?: Buffer | undefined;
  actionId?: number | undefined;
}

export interface CMsgClientToGCDotaLabsFeedback {
  language?: number | undefined;
  feedbackItem?: number | undefined;
  feedback?: string | undefined;
}

export interface CMsgClientToGCDotaLabsFeedbackResponse {
  response?: CMsgClientToGCDotaLabsFeedbackResponse_EResponse | undefined;
}

export enum CMsgClientToGCDotaLabsFeedbackResponse_EResponse {
  k_eInternalError = 0,
  k_eSuccess = 1,
  k_eTooBusy = 2,
  k_eDisabled = 3,
  k_eTimeout = 4,
  k_eNotAllowed = 5,
  k_eInvalidItem = 6,
}

export function cMsgClientToGCDotaLabsFeedbackResponse_EResponseFromJSON(
  object: any,
): CMsgClientToGCDotaLabsFeedbackResponse_EResponse {
  switch (object) {
    case 0:
    case "k_eInternalError":
      return CMsgClientToGCDotaLabsFeedbackResponse_EResponse.k_eInternalError;
    case 1:
    case "k_eSuccess":
      return CMsgClientToGCDotaLabsFeedbackResponse_EResponse.k_eSuccess;
    case 2:
    case "k_eTooBusy":
      return CMsgClientToGCDotaLabsFeedbackResponse_EResponse.k_eTooBusy;
    case 3:
    case "k_eDisabled":
      return CMsgClientToGCDotaLabsFeedbackResponse_EResponse.k_eDisabled;
    case 4:
    case "k_eTimeout":
      return CMsgClientToGCDotaLabsFeedbackResponse_EResponse.k_eTimeout;
    case 5:
    case "k_eNotAllowed":
      return CMsgClientToGCDotaLabsFeedbackResponse_EResponse.k_eNotAllowed;
    case 6:
    case "k_eInvalidItem":
      return CMsgClientToGCDotaLabsFeedbackResponse_EResponse.k_eInvalidItem;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgClientToGCDotaLabsFeedbackResponse_EResponse",
      );
  }
}

export function cMsgClientToGCDotaLabsFeedbackResponse_EResponseToJSON(
  object: CMsgClientToGCDotaLabsFeedbackResponse_EResponse,
): string {
  switch (object) {
    case CMsgClientToGCDotaLabsFeedbackResponse_EResponse.k_eInternalError:
      return "k_eInternalError";
    case CMsgClientToGCDotaLabsFeedbackResponse_EResponse.k_eSuccess:
      return "k_eSuccess";
    case CMsgClientToGCDotaLabsFeedbackResponse_EResponse.k_eTooBusy:
      return "k_eTooBusy";
    case CMsgClientToGCDotaLabsFeedbackResponse_EResponse.k_eDisabled:
      return "k_eDisabled";
    case CMsgClientToGCDotaLabsFeedbackResponse_EResponse.k_eTimeout:
      return "k_eTimeout";
    case CMsgClientToGCDotaLabsFeedbackResponse_EResponse.k_eNotAllowed:
      return "k_eNotAllowed";
    case CMsgClientToGCDotaLabsFeedbackResponse_EResponse.k_eInvalidItem:
      return "k_eInvalidItem";
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum CMsgClientToGCDotaLabsFeedbackResponse_EResponse",
      );
  }
}

export interface CDotaMsgPredictionResult {
  accountId?: number | undefined;
  matchId?: string | undefined;
  correct?: boolean | undefined;
  predictions: CDotaMsgPredictionResult_Prediction[];
}

export interface CDotaMsgPredictionResult_Prediction {
  itemDef?: number | undefined;
  numCorrect?: number | undefined;
  numFails?: number | undefined;
  result?: CDotaMsgPredictionResult_Prediction_EResult | undefined;
  grantedItemDefs: number[];
}

export enum CDotaMsgPredictionResult_Prediction_EResult {
  k_eResult_ItemGranted = 1,
  k_eResult_Destroyed = 2,
}

export function cDotaMsgPredictionResult_Prediction_EResultFromJSON(
  object: any,
): CDotaMsgPredictionResult_Prediction_EResult {
  switch (object) {
    case 1:
    case "k_eResult_ItemGranted":
      return CDotaMsgPredictionResult_Prediction_EResult.k_eResult_ItemGranted;
    case 2:
    case "k_eResult_Destroyed":
      return CDotaMsgPredictionResult_Prediction_EResult.k_eResult_Destroyed;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum CDotaMsgPredictionResult_Prediction_EResult",
      );
  }
}

export function cDotaMsgPredictionResult_Prediction_EResultToJSON(
  object: CDotaMsgPredictionResult_Prediction_EResult,
): string {
  switch (object) {
    case CDotaMsgPredictionResult_Prediction_EResult.k_eResult_ItemGranted:
      return "k_eResult_ItemGranted";
    case CDotaMsgPredictionResult_Prediction_EResult.k_eResult_Destroyed:
      return "k_eResult_Destroyed";
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum CDotaMsgPredictionResult_Prediction_EResult",
      );
  }
}

function createBaseCSODOTAGameAccountClient(): CSODOTAGameAccountClient {
  return {
    accountId: 0,
    wins: 0,
    losses: 0,
    xp: 0,
    level: 0,
    initialSkill: 0,
    leaverCount: 0,
    secondaryLeaverCount: 0,
    lowPriorityUntilDate: 0,
    preventTextChatUntilDate: 0,
    preventVoiceUntilDate: 0,
    preventPublicTextChatUntilDate: 0,
    preventNewPlayerChatUntilDate: 0,
    lastAbandonedGameDate: 0,
    lastSecondaryAbandonedGameDate: 0,
    leaverPenaltyCount: 0,
    completedGameStreak: 0,
    accountDisabledUntilDate: 0,
    accountDisabledCount: 0,
    matchDisabledUntilDate: 0,
    matchDisabledCount: 0,
    shutdownlawterminatetimestamp: 0,
    lowPriorityGamesRemaining: 0,
    recruitmentLevel: 0,
    hasNewNotifications: false,
    isLeagueAdmin: false,
    casualGamesPlayed: 0,
    soloCompetitiveGamesPlayed: 0,
    partyCompetitiveGamesPlayed: 0,
    casual1v1GamesPlayed: 0,
    currAllHeroChallengeId: 0,
    playTimePoints: 0,
    accountFlags: 0,
    playTimeLevel: 0,
    playerBehaviorSeqNumLastReport: 0,
    playerBehaviorScoreLastReport: 0,
    playerBehaviorReportOldData: false,
    tourneySkillLevel: 0,
    tourneyRecentParticipationDate: 0,
    anchoredPhoneNumberId: "0",
    rankedMatchmakingBanUntilDate: 0,
    recentGameTime1: 0,
    recentGameTime2: 0,
    recentGameTime3: 0,
    favoriteTeamPacked: "0",
    recentReportTime: 0,
    customGameDisabledUntilDate: 0,
    recentWinTime1: 0,
    recentWinTime2: 0,
    recentWinTime3: 0,
    coachRating: 0,
    queuePoints: 0,
    roleHandicaps: [],
    eventModeRecentTime: 0,
    mmrRecalibrationTime: 0,
    bannedHeroIds: [],
  };
}

export const CSODOTAGameAccountClient = {
  encode(message: CSODOTAGameAccountClient, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.accountId !== undefined && message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    if (message.wins !== undefined && message.wins !== 0) {
      writer.uint32(24).uint32(message.wins);
    }
    if (message.losses !== undefined && message.losses !== 0) {
      writer.uint32(32).uint32(message.losses);
    }
    if (message.xp !== undefined && message.xp !== 0) {
      writer.uint32(96).uint32(message.xp);
    }
    if (message.level !== undefined && message.level !== 0) {
      writer.uint32(104).uint32(message.level);
    }
    if (message.initialSkill !== undefined && message.initialSkill !== 0) {
      writer.uint32(112).uint32(message.initialSkill);
    }
    if (message.leaverCount !== undefined && message.leaverCount !== 0) {
      writer.uint32(120).uint32(message.leaverCount);
    }
    if (message.secondaryLeaverCount !== undefined && message.secondaryLeaverCount !== 0) {
      writer.uint32(464).uint32(message.secondaryLeaverCount);
    }
    if (message.lowPriorityUntilDate !== undefined && message.lowPriorityUntilDate !== 0) {
      writer.uint32(144).uint32(message.lowPriorityUntilDate);
    }
    if (message.preventTextChatUntilDate !== undefined && message.preventTextChatUntilDate !== 0) {
      writer.uint32(160).uint32(message.preventTextChatUntilDate);
    }
    if (message.preventVoiceUntilDate !== undefined && message.preventVoiceUntilDate !== 0) {
      writer.uint32(168).uint32(message.preventVoiceUntilDate);
    }
    if (message.preventPublicTextChatUntilDate !== undefined && message.preventPublicTextChatUntilDate !== 0) {
      writer.uint32(688).uint32(message.preventPublicTextChatUntilDate);
    }
    if (message.preventNewPlayerChatUntilDate !== undefined && message.preventNewPlayerChatUntilDate !== 0) {
      writer.uint32(976).uint32(message.preventNewPlayerChatUntilDate);
    }
    if (message.lastAbandonedGameDate !== undefined && message.lastAbandonedGameDate !== 0) {
      writer.uint32(176).uint32(message.lastAbandonedGameDate);
    }
    if (message.lastSecondaryAbandonedGameDate !== undefined && message.lastSecondaryAbandonedGameDate !== 0) {
      writer.uint32(472).uint32(message.lastSecondaryAbandonedGameDate);
    }
    if (message.leaverPenaltyCount !== undefined && message.leaverPenaltyCount !== 0) {
      writer.uint32(184).uint32(message.leaverPenaltyCount);
    }
    if (message.completedGameStreak !== undefined && message.completedGameStreak !== 0) {
      writer.uint32(192).uint32(message.completedGameStreak);
    }
    if (message.accountDisabledUntilDate !== undefined && message.accountDisabledUntilDate !== 0) {
      writer.uint32(304).uint32(message.accountDisabledUntilDate);
    }
    if (message.accountDisabledCount !== undefined && message.accountDisabledCount !== 0) {
      writer.uint32(312).uint32(message.accountDisabledCount);
    }
    if (message.matchDisabledUntilDate !== undefined && message.matchDisabledUntilDate !== 0) {
      writer.uint32(328).uint32(message.matchDisabledUntilDate);
    }
    if (message.matchDisabledCount !== undefined && message.matchDisabledCount !== 0) {
      writer.uint32(336).uint32(message.matchDisabledCount);
    }
    if (message.shutdownlawterminatetimestamp !== undefined && message.shutdownlawterminatetimestamp !== 0) {
      writer.uint32(376).uint32(message.shutdownlawterminatetimestamp);
    }
    if (message.lowPriorityGamesRemaining !== undefined && message.lowPriorityGamesRemaining !== 0) {
      writer.uint32(384).uint32(message.lowPriorityGamesRemaining);
    }
    if (message.recruitmentLevel !== undefined && message.recruitmentLevel !== 0) {
      writer.uint32(440).uint32(message.recruitmentLevel);
    }
    if (message.hasNewNotifications !== undefined && message.hasNewNotifications !== false) {
      writer.uint32(448).bool(message.hasNewNotifications);
    }
    if (message.isLeagueAdmin !== undefined && message.isLeagueAdmin !== false) {
      writer.uint32(456).bool(message.isLeagueAdmin);
    }
    if (message.casualGamesPlayed !== undefined && message.casualGamesPlayed !== 0) {
      writer.uint32(480).uint32(message.casualGamesPlayed);
    }
    if (message.soloCompetitiveGamesPlayed !== undefined && message.soloCompetitiveGamesPlayed !== 0) {
      writer.uint32(488).uint32(message.soloCompetitiveGamesPlayed);
    }
    if (message.partyCompetitiveGamesPlayed !== undefined && message.partyCompetitiveGamesPlayed !== 0) {
      writer.uint32(496).uint32(message.partyCompetitiveGamesPlayed);
    }
    if (message.casual1v1GamesPlayed !== undefined && message.casual1v1GamesPlayed !== 0) {
      writer.uint32(520).uint32(message.casual1v1GamesPlayed);
    }
    if (message.currAllHeroChallengeId !== undefined && message.currAllHeroChallengeId !== 0) {
      writer.uint32(536).int32(message.currAllHeroChallengeId);
    }
    if (message.playTimePoints !== undefined && message.playTimePoints !== 0) {
      writer.uint32(544).uint32(message.playTimePoints);
    }
    if (message.accountFlags !== undefined && message.accountFlags !== 0) {
      writer.uint32(552).uint32(message.accountFlags);
    }
    if (message.playTimeLevel !== undefined && message.playTimeLevel !== 0) {
      writer.uint32(560).uint32(message.playTimeLevel);
    }
    if (message.playerBehaviorSeqNumLastReport !== undefined && message.playerBehaviorSeqNumLastReport !== 0) {
      writer.uint32(568).uint32(message.playerBehaviorSeqNumLastReport);
    }
    if (message.playerBehaviorScoreLastReport !== undefined && message.playerBehaviorScoreLastReport !== 0) {
      writer.uint32(576).uint32(message.playerBehaviorScoreLastReport);
    }
    if (message.playerBehaviorReportOldData !== undefined && message.playerBehaviorReportOldData !== false) {
      writer.uint32(584).bool(message.playerBehaviorReportOldData);
    }
    if (message.tourneySkillLevel !== undefined && message.tourneySkillLevel !== 0) {
      writer.uint32(592).uint32(message.tourneySkillLevel);
    }
    if (message.tourneyRecentParticipationDate !== undefined && message.tourneyRecentParticipationDate !== 0) {
      writer.uint32(680).uint32(message.tourneyRecentParticipationDate);
    }
    if (message.anchoredPhoneNumberId !== undefined && message.anchoredPhoneNumberId !== "0") {
      writer.uint32(704).uint64(message.anchoredPhoneNumberId);
    }
    if (message.rankedMatchmakingBanUntilDate !== undefined && message.rankedMatchmakingBanUntilDate !== 0) {
      writer.uint32(712).uint32(message.rankedMatchmakingBanUntilDate);
    }
    if (message.recentGameTime1 !== undefined && message.recentGameTime1 !== 0) {
      writer.uint32(720).uint32(message.recentGameTime1);
    }
    if (message.recentGameTime2 !== undefined && message.recentGameTime2 !== 0) {
      writer.uint32(728).uint32(message.recentGameTime2);
    }
    if (message.recentGameTime3 !== undefined && message.recentGameTime3 !== 0) {
      writer.uint32(736).uint32(message.recentGameTime3);
    }
    if (message.favoriteTeamPacked !== undefined && message.favoriteTeamPacked !== "0") {
      writer.uint32(824).uint64(message.favoriteTeamPacked);
    }
    if (message.recentReportTime !== undefined && message.recentReportTime !== 0) {
      writer.uint32(832).uint32(message.recentReportTime);
    }
    if (message.customGameDisabledUntilDate !== undefined && message.customGameDisabledUntilDate !== 0) {
      writer.uint32(840).uint32(message.customGameDisabledUntilDate);
    }
    if (message.recentWinTime1 !== undefined && message.recentWinTime1 !== 0) {
      writer.uint32(848).uint32(message.recentWinTime1);
    }
    if (message.recentWinTime2 !== undefined && message.recentWinTime2 !== 0) {
      writer.uint32(856).uint32(message.recentWinTime2);
    }
    if (message.recentWinTime3 !== undefined && message.recentWinTime3 !== 0) {
      writer.uint32(864).uint32(message.recentWinTime3);
    }
    if (message.coachRating !== undefined && message.coachRating !== 0) {
      writer.uint32(872).uint32(message.coachRating);
    }
    if (message.queuePoints !== undefined && message.queuePoints !== 0) {
      writer.uint32(912).uint32(message.queuePoints);
    }
    for (const v of message.roleHandicaps) {
      CSODOTAGameAccountClient_RoleHandicap.encode(v!, writer.uint32(922).fork()).ldelim();
    }
    if (message.eventModeRecentTime !== undefined && message.eventModeRecentTime !== 0) {
      writer.uint32(960).uint32(message.eventModeRecentTime);
    }
    if (message.mmrRecalibrationTime !== undefined && message.mmrRecalibrationTime !== 0) {
      writer.uint32(968).uint32(message.mmrRecalibrationTime);
    }
    writer.uint32(986).fork();
    for (const v of message.bannedHeroIds) {
      writer.int32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CSODOTAGameAccountClient {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCSODOTAGameAccountClient();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.wins = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.losses = reader.uint32();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.xp = reader.uint32();
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.level = reader.uint32();
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.initialSkill = reader.uint32();
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.leaverCount = reader.uint32();
          continue;
        case 58:
          if (tag !== 464) {
            break;
          }

          message.secondaryLeaverCount = reader.uint32();
          continue;
        case 18:
          if (tag !== 144) {
            break;
          }

          message.lowPriorityUntilDate = reader.uint32();
          continue;
        case 20:
          if (tag !== 160) {
            break;
          }

          message.preventTextChatUntilDate = reader.uint32();
          continue;
        case 21:
          if (tag !== 168) {
            break;
          }

          message.preventVoiceUntilDate = reader.uint32();
          continue;
        case 86:
          if (tag !== 688) {
            break;
          }

          message.preventPublicTextChatUntilDate = reader.uint32();
          continue;
        case 122:
          if (tag !== 976) {
            break;
          }

          message.preventNewPlayerChatUntilDate = reader.uint32();
          continue;
        case 22:
          if (tag !== 176) {
            break;
          }

          message.lastAbandonedGameDate = reader.uint32();
          continue;
        case 59:
          if (tag !== 472) {
            break;
          }

          message.lastSecondaryAbandonedGameDate = reader.uint32();
          continue;
        case 23:
          if (tag !== 184) {
            break;
          }

          message.leaverPenaltyCount = reader.uint32();
          continue;
        case 24:
          if (tag !== 192) {
            break;
          }

          message.completedGameStreak = reader.uint32();
          continue;
        case 38:
          if (tag !== 304) {
            break;
          }

          message.accountDisabledUntilDate = reader.uint32();
          continue;
        case 39:
          if (tag !== 312) {
            break;
          }

          message.accountDisabledCount = reader.uint32();
          continue;
        case 41:
          if (tag !== 328) {
            break;
          }

          message.matchDisabledUntilDate = reader.uint32();
          continue;
        case 42:
          if (tag !== 336) {
            break;
          }

          message.matchDisabledCount = reader.uint32();
          continue;
        case 47:
          if (tag !== 376) {
            break;
          }

          message.shutdownlawterminatetimestamp = reader.uint32();
          continue;
        case 48:
          if (tag !== 384) {
            break;
          }

          message.lowPriorityGamesRemaining = reader.uint32();
          continue;
        case 55:
          if (tag !== 440) {
            break;
          }

          message.recruitmentLevel = reader.uint32();
          continue;
        case 56:
          if (tag !== 448) {
            break;
          }

          message.hasNewNotifications = reader.bool();
          continue;
        case 57:
          if (tag !== 456) {
            break;
          }

          message.isLeagueAdmin = reader.bool();
          continue;
        case 60:
          if (tag !== 480) {
            break;
          }

          message.casualGamesPlayed = reader.uint32();
          continue;
        case 61:
          if (tag !== 488) {
            break;
          }

          message.soloCompetitiveGamesPlayed = reader.uint32();
          continue;
        case 62:
          if (tag !== 496) {
            break;
          }

          message.partyCompetitiveGamesPlayed = reader.uint32();
          continue;
        case 65:
          if (tag !== 520) {
            break;
          }

          message.casual1v1GamesPlayed = reader.uint32();
          continue;
        case 67:
          if (tag !== 536) {
            break;
          }

          message.currAllHeroChallengeId = reader.int32();
          continue;
        case 68:
          if (tag !== 544) {
            break;
          }

          message.playTimePoints = reader.uint32();
          continue;
        case 69:
          if (tag !== 552) {
            break;
          }

          message.accountFlags = reader.uint32();
          continue;
        case 70:
          if (tag !== 560) {
            break;
          }

          message.playTimeLevel = reader.uint32();
          continue;
        case 71:
          if (tag !== 568) {
            break;
          }

          message.playerBehaviorSeqNumLastReport = reader.uint32();
          continue;
        case 72:
          if (tag !== 576) {
            break;
          }

          message.playerBehaviorScoreLastReport = reader.uint32();
          continue;
        case 73:
          if (tag !== 584) {
            break;
          }

          message.playerBehaviorReportOldData = reader.bool();
          continue;
        case 74:
          if (tag !== 592) {
            break;
          }

          message.tourneySkillLevel = reader.uint32();
          continue;
        case 85:
          if (tag !== 680) {
            break;
          }

          message.tourneyRecentParticipationDate = reader.uint32();
          continue;
        case 88:
          if (tag !== 704) {
            break;
          }

          message.anchoredPhoneNumberId = longToString(reader.uint64() as Long);
          continue;
        case 89:
          if (tag !== 712) {
            break;
          }

          message.rankedMatchmakingBanUntilDate = reader.uint32();
          continue;
        case 90:
          if (tag !== 720) {
            break;
          }

          message.recentGameTime1 = reader.uint32();
          continue;
        case 91:
          if (tag !== 728) {
            break;
          }

          message.recentGameTime2 = reader.uint32();
          continue;
        case 92:
          if (tag !== 736) {
            break;
          }

          message.recentGameTime3 = reader.uint32();
          continue;
        case 103:
          if (tag !== 824) {
            break;
          }

          message.favoriteTeamPacked = longToString(reader.uint64() as Long);
          continue;
        case 104:
          if (tag !== 832) {
            break;
          }

          message.recentReportTime = reader.uint32();
          continue;
        case 105:
          if (tag !== 840) {
            break;
          }

          message.customGameDisabledUntilDate = reader.uint32();
          continue;
        case 106:
          if (tag !== 848) {
            break;
          }

          message.recentWinTime1 = reader.uint32();
          continue;
        case 107:
          if (tag !== 856) {
            break;
          }

          message.recentWinTime2 = reader.uint32();
          continue;
        case 108:
          if (tag !== 864) {
            break;
          }

          message.recentWinTime3 = reader.uint32();
          continue;
        case 109:
          if (tag !== 872) {
            break;
          }

          message.coachRating = reader.uint32();
          continue;
        case 114:
          if (tag !== 912) {
            break;
          }

          message.queuePoints = reader.uint32();
          continue;
        case 115:
          if (tag !== 922) {
            break;
          }

          message.roleHandicaps.push(CSODOTAGameAccountClient_RoleHandicap.decode(reader, reader.uint32()));
          continue;
        case 120:
          if (tag !== 960) {
            break;
          }

          message.eventModeRecentTime = reader.uint32();
          continue;
        case 121:
          if (tag !== 968) {
            break;
          }

          message.mmrRecalibrationTime = reader.uint32();
          continue;
        case 123:
          if (tag === 984) {
            message.bannedHeroIds.push(reader.int32());

            continue;
          }

          if (tag === 986) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.bannedHeroIds.push(reader.int32());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CSODOTAGameAccountClient {
    return {
      accountId: isSet(object.accountId) ? globalThis.Number(object.accountId) : 0,
      wins: isSet(object.wins) ? globalThis.Number(object.wins) : 0,
      losses: isSet(object.losses) ? globalThis.Number(object.losses) : 0,
      xp: isSet(object.xp) ? globalThis.Number(object.xp) : 0,
      level: isSet(object.level) ? globalThis.Number(object.level) : 0,
      initialSkill: isSet(object.initialSkill) ? globalThis.Number(object.initialSkill) : 0,
      leaverCount: isSet(object.leaverCount) ? globalThis.Number(object.leaverCount) : 0,
      secondaryLeaverCount: isSet(object.secondaryLeaverCount) ? globalThis.Number(object.secondaryLeaverCount) : 0,
      lowPriorityUntilDate: isSet(object.lowPriorityUntilDate) ? globalThis.Number(object.lowPriorityUntilDate) : 0,
      preventTextChatUntilDate: isSet(object.preventTextChatUntilDate)
        ? globalThis.Number(object.preventTextChatUntilDate)
        : 0,
      preventVoiceUntilDate: isSet(object.preventVoiceUntilDate) ? globalThis.Number(object.preventVoiceUntilDate) : 0,
      preventPublicTextChatUntilDate: isSet(object.preventPublicTextChatUntilDate)
        ? globalThis.Number(object.preventPublicTextChatUntilDate)
        : 0,
      preventNewPlayerChatUntilDate: isSet(object.preventNewPlayerChatUntilDate)
        ? globalThis.Number(object.preventNewPlayerChatUntilDate)
        : 0,
      lastAbandonedGameDate: isSet(object.lastAbandonedGameDate) ? globalThis.Number(object.lastAbandonedGameDate) : 0,
      lastSecondaryAbandonedGameDate: isSet(object.lastSecondaryAbandonedGameDate)
        ? globalThis.Number(object.lastSecondaryAbandonedGameDate)
        : 0,
      leaverPenaltyCount: isSet(object.leaverPenaltyCount) ? globalThis.Number(object.leaverPenaltyCount) : 0,
      completedGameStreak: isSet(object.completedGameStreak) ? globalThis.Number(object.completedGameStreak) : 0,
      accountDisabledUntilDate: isSet(object.accountDisabledUntilDate)
        ? globalThis.Number(object.accountDisabledUntilDate)
        : 0,
      accountDisabledCount: isSet(object.accountDisabledCount) ? globalThis.Number(object.accountDisabledCount) : 0,
      matchDisabledUntilDate: isSet(object.matchDisabledUntilDate)
        ? globalThis.Number(object.matchDisabledUntilDate)
        : 0,
      matchDisabledCount: isSet(object.matchDisabledCount) ? globalThis.Number(object.matchDisabledCount) : 0,
      shutdownlawterminatetimestamp: isSet(object.shutdownlawterminatetimestamp)
        ? globalThis.Number(object.shutdownlawterminatetimestamp)
        : 0,
      lowPriorityGamesRemaining: isSet(object.lowPriorityGamesRemaining)
        ? globalThis.Number(object.lowPriorityGamesRemaining)
        : 0,
      recruitmentLevel: isSet(object.recruitmentLevel) ? globalThis.Number(object.recruitmentLevel) : 0,
      hasNewNotifications: isSet(object.hasNewNotifications) ? globalThis.Boolean(object.hasNewNotifications) : false,
      isLeagueAdmin: isSet(object.isLeagueAdmin) ? globalThis.Boolean(object.isLeagueAdmin) : false,
      casualGamesPlayed: isSet(object.casualGamesPlayed) ? globalThis.Number(object.casualGamesPlayed) : 0,
      soloCompetitiveGamesPlayed: isSet(object.soloCompetitiveGamesPlayed)
        ? globalThis.Number(object.soloCompetitiveGamesPlayed)
        : 0,
      partyCompetitiveGamesPlayed: isSet(object.partyCompetitiveGamesPlayed)
        ? globalThis.Number(object.partyCompetitiveGamesPlayed)
        : 0,
      casual1v1GamesPlayed: isSet(object.casual1v1GamesPlayed) ? globalThis.Number(object.casual1v1GamesPlayed) : 0,
      currAllHeroChallengeId: isSet(object.currAllHeroChallengeId)
        ? globalThis.Number(object.currAllHeroChallengeId)
        : 0,
      playTimePoints: isSet(object.playTimePoints) ? globalThis.Number(object.playTimePoints) : 0,
      accountFlags: isSet(object.accountFlags) ? globalThis.Number(object.accountFlags) : 0,
      playTimeLevel: isSet(object.playTimeLevel) ? globalThis.Number(object.playTimeLevel) : 0,
      playerBehaviorSeqNumLastReport: isSet(object.playerBehaviorSeqNumLastReport)
        ? globalThis.Number(object.playerBehaviorSeqNumLastReport)
        : 0,
      playerBehaviorScoreLastReport: isSet(object.playerBehaviorScoreLastReport)
        ? globalThis.Number(object.playerBehaviorScoreLastReport)
        : 0,
      playerBehaviorReportOldData: isSet(object.playerBehaviorReportOldData)
        ? globalThis.Boolean(object.playerBehaviorReportOldData)
        : false,
      tourneySkillLevel: isSet(object.tourneySkillLevel) ? globalThis.Number(object.tourneySkillLevel) : 0,
      tourneyRecentParticipationDate: isSet(object.tourneyRecentParticipationDate)
        ? globalThis.Number(object.tourneyRecentParticipationDate)
        : 0,
      anchoredPhoneNumberId: isSet(object.anchoredPhoneNumberId)
        ? globalThis.String(object.anchoredPhoneNumberId)
        : "0",
      rankedMatchmakingBanUntilDate: isSet(object.rankedMatchmakingBanUntilDate)
        ? globalThis.Number(object.rankedMatchmakingBanUntilDate)
        : 0,
      recentGameTime1: isSet(object.recentGameTime1) ? globalThis.Number(object.recentGameTime1) : 0,
      recentGameTime2: isSet(object.recentGameTime2) ? globalThis.Number(object.recentGameTime2) : 0,
      recentGameTime3: isSet(object.recentGameTime3) ? globalThis.Number(object.recentGameTime3) : 0,
      favoriteTeamPacked: isSet(object.favoriteTeamPacked) ? globalThis.String(object.favoriteTeamPacked) : "0",
      recentReportTime: isSet(object.recentReportTime) ? globalThis.Number(object.recentReportTime) : 0,
      customGameDisabledUntilDate: isSet(object.customGameDisabledUntilDate)
        ? globalThis.Number(object.customGameDisabledUntilDate)
        : 0,
      recentWinTime1: isSet(object.recentWinTime1) ? globalThis.Number(object.recentWinTime1) : 0,
      recentWinTime2: isSet(object.recentWinTime2) ? globalThis.Number(object.recentWinTime2) : 0,
      recentWinTime3: isSet(object.recentWinTime3) ? globalThis.Number(object.recentWinTime3) : 0,
      coachRating: isSet(object.coachRating) ? globalThis.Number(object.coachRating) : 0,
      queuePoints: isSet(object.queuePoints) ? globalThis.Number(object.queuePoints) : 0,
      roleHandicaps: globalThis.Array.isArray(object?.roleHandicaps)
        ? object.roleHandicaps.map((e: any) => CSODOTAGameAccountClient_RoleHandicap.fromJSON(e))
        : [],
      eventModeRecentTime: isSet(object.eventModeRecentTime) ? globalThis.Number(object.eventModeRecentTime) : 0,
      mmrRecalibrationTime: isSet(object.mmrRecalibrationTime) ? globalThis.Number(object.mmrRecalibrationTime) : 0,
      bannedHeroIds: globalThis.Array.isArray(object?.bannedHeroIds)
        ? object.bannedHeroIds.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: CSODOTAGameAccountClient): unknown {
    const obj: any = {};
    if (message.accountId !== undefined && message.accountId !== 0) {
      obj.accountId = Math.round(message.accountId);
    }
    if (message.wins !== undefined && message.wins !== 0) {
      obj.wins = Math.round(message.wins);
    }
    if (message.losses !== undefined && message.losses !== 0) {
      obj.losses = Math.round(message.losses);
    }
    if (message.xp !== undefined && message.xp !== 0) {
      obj.xp = Math.round(message.xp);
    }
    if (message.level !== undefined && message.level !== 0) {
      obj.level = Math.round(message.level);
    }
    if (message.initialSkill !== undefined && message.initialSkill !== 0) {
      obj.initialSkill = Math.round(message.initialSkill);
    }
    if (message.leaverCount !== undefined && message.leaverCount !== 0) {
      obj.leaverCount = Math.round(message.leaverCount);
    }
    if (message.secondaryLeaverCount !== undefined && message.secondaryLeaverCount !== 0) {
      obj.secondaryLeaverCount = Math.round(message.secondaryLeaverCount);
    }
    if (message.lowPriorityUntilDate !== undefined && message.lowPriorityUntilDate !== 0) {
      obj.lowPriorityUntilDate = Math.round(message.lowPriorityUntilDate);
    }
    if (message.preventTextChatUntilDate !== undefined && message.preventTextChatUntilDate !== 0) {
      obj.preventTextChatUntilDate = Math.round(message.preventTextChatUntilDate);
    }
    if (message.preventVoiceUntilDate !== undefined && message.preventVoiceUntilDate !== 0) {
      obj.preventVoiceUntilDate = Math.round(message.preventVoiceUntilDate);
    }
    if (message.preventPublicTextChatUntilDate !== undefined && message.preventPublicTextChatUntilDate !== 0) {
      obj.preventPublicTextChatUntilDate = Math.round(message.preventPublicTextChatUntilDate);
    }
    if (message.preventNewPlayerChatUntilDate !== undefined && message.preventNewPlayerChatUntilDate !== 0) {
      obj.preventNewPlayerChatUntilDate = Math.round(message.preventNewPlayerChatUntilDate);
    }
    if (message.lastAbandonedGameDate !== undefined && message.lastAbandonedGameDate !== 0) {
      obj.lastAbandonedGameDate = Math.round(message.lastAbandonedGameDate);
    }
    if (message.lastSecondaryAbandonedGameDate !== undefined && message.lastSecondaryAbandonedGameDate !== 0) {
      obj.lastSecondaryAbandonedGameDate = Math.round(message.lastSecondaryAbandonedGameDate);
    }
    if (message.leaverPenaltyCount !== undefined && message.leaverPenaltyCount !== 0) {
      obj.leaverPenaltyCount = Math.round(message.leaverPenaltyCount);
    }
    if (message.completedGameStreak !== undefined && message.completedGameStreak !== 0) {
      obj.completedGameStreak = Math.round(message.completedGameStreak);
    }
    if (message.accountDisabledUntilDate !== undefined && message.accountDisabledUntilDate !== 0) {
      obj.accountDisabledUntilDate = Math.round(message.accountDisabledUntilDate);
    }
    if (message.accountDisabledCount !== undefined && message.accountDisabledCount !== 0) {
      obj.accountDisabledCount = Math.round(message.accountDisabledCount);
    }
    if (message.matchDisabledUntilDate !== undefined && message.matchDisabledUntilDate !== 0) {
      obj.matchDisabledUntilDate = Math.round(message.matchDisabledUntilDate);
    }
    if (message.matchDisabledCount !== undefined && message.matchDisabledCount !== 0) {
      obj.matchDisabledCount = Math.round(message.matchDisabledCount);
    }
    if (message.shutdownlawterminatetimestamp !== undefined && message.shutdownlawterminatetimestamp !== 0) {
      obj.shutdownlawterminatetimestamp = Math.round(message.shutdownlawterminatetimestamp);
    }
    if (message.lowPriorityGamesRemaining !== undefined && message.lowPriorityGamesRemaining !== 0) {
      obj.lowPriorityGamesRemaining = Math.round(message.lowPriorityGamesRemaining);
    }
    if (message.recruitmentLevel !== undefined && message.recruitmentLevel !== 0) {
      obj.recruitmentLevel = Math.round(message.recruitmentLevel);
    }
    if (message.hasNewNotifications !== undefined && message.hasNewNotifications !== false) {
      obj.hasNewNotifications = message.hasNewNotifications;
    }
    if (message.isLeagueAdmin !== undefined && message.isLeagueAdmin !== false) {
      obj.isLeagueAdmin = message.isLeagueAdmin;
    }
    if (message.casualGamesPlayed !== undefined && message.casualGamesPlayed !== 0) {
      obj.casualGamesPlayed = Math.round(message.casualGamesPlayed);
    }
    if (message.soloCompetitiveGamesPlayed !== undefined && message.soloCompetitiveGamesPlayed !== 0) {
      obj.soloCompetitiveGamesPlayed = Math.round(message.soloCompetitiveGamesPlayed);
    }
    if (message.partyCompetitiveGamesPlayed !== undefined && message.partyCompetitiveGamesPlayed !== 0) {
      obj.partyCompetitiveGamesPlayed = Math.round(message.partyCompetitiveGamesPlayed);
    }
    if (message.casual1v1GamesPlayed !== undefined && message.casual1v1GamesPlayed !== 0) {
      obj.casual1v1GamesPlayed = Math.round(message.casual1v1GamesPlayed);
    }
    if (message.currAllHeroChallengeId !== undefined && message.currAllHeroChallengeId !== 0) {
      obj.currAllHeroChallengeId = Math.round(message.currAllHeroChallengeId);
    }
    if (message.playTimePoints !== undefined && message.playTimePoints !== 0) {
      obj.playTimePoints = Math.round(message.playTimePoints);
    }
    if (message.accountFlags !== undefined && message.accountFlags !== 0) {
      obj.accountFlags = Math.round(message.accountFlags);
    }
    if (message.playTimeLevel !== undefined && message.playTimeLevel !== 0) {
      obj.playTimeLevel = Math.round(message.playTimeLevel);
    }
    if (message.playerBehaviorSeqNumLastReport !== undefined && message.playerBehaviorSeqNumLastReport !== 0) {
      obj.playerBehaviorSeqNumLastReport = Math.round(message.playerBehaviorSeqNumLastReport);
    }
    if (message.playerBehaviorScoreLastReport !== undefined && message.playerBehaviorScoreLastReport !== 0) {
      obj.playerBehaviorScoreLastReport = Math.round(message.playerBehaviorScoreLastReport);
    }
    if (message.playerBehaviorReportOldData !== undefined && message.playerBehaviorReportOldData !== false) {
      obj.playerBehaviorReportOldData = message.playerBehaviorReportOldData;
    }
    if (message.tourneySkillLevel !== undefined && message.tourneySkillLevel !== 0) {
      obj.tourneySkillLevel = Math.round(message.tourneySkillLevel);
    }
    if (message.tourneyRecentParticipationDate !== undefined && message.tourneyRecentParticipationDate !== 0) {
      obj.tourneyRecentParticipationDate = Math.round(message.tourneyRecentParticipationDate);
    }
    if (message.anchoredPhoneNumberId !== undefined && message.anchoredPhoneNumberId !== "0") {
      obj.anchoredPhoneNumberId = message.anchoredPhoneNumberId;
    }
    if (message.rankedMatchmakingBanUntilDate !== undefined && message.rankedMatchmakingBanUntilDate !== 0) {
      obj.rankedMatchmakingBanUntilDate = Math.round(message.rankedMatchmakingBanUntilDate);
    }
    if (message.recentGameTime1 !== undefined && message.recentGameTime1 !== 0) {
      obj.recentGameTime1 = Math.round(message.recentGameTime1);
    }
    if (message.recentGameTime2 !== undefined && message.recentGameTime2 !== 0) {
      obj.recentGameTime2 = Math.round(message.recentGameTime2);
    }
    if (message.recentGameTime3 !== undefined && message.recentGameTime3 !== 0) {
      obj.recentGameTime3 = Math.round(message.recentGameTime3);
    }
    if (message.favoriteTeamPacked !== undefined && message.favoriteTeamPacked !== "0") {
      obj.favoriteTeamPacked = message.favoriteTeamPacked;
    }
    if (message.recentReportTime !== undefined && message.recentReportTime !== 0) {
      obj.recentReportTime = Math.round(message.recentReportTime);
    }
    if (message.customGameDisabledUntilDate !== undefined && message.customGameDisabledUntilDate !== 0) {
      obj.customGameDisabledUntilDate = Math.round(message.customGameDisabledUntilDate);
    }
    if (message.recentWinTime1 !== undefined && message.recentWinTime1 !== 0) {
      obj.recentWinTime1 = Math.round(message.recentWinTime1);
    }
    if (message.recentWinTime2 !== undefined && message.recentWinTime2 !== 0) {
      obj.recentWinTime2 = Math.round(message.recentWinTime2);
    }
    if (message.recentWinTime3 !== undefined && message.recentWinTime3 !== 0) {
      obj.recentWinTime3 = Math.round(message.recentWinTime3);
    }
    if (message.coachRating !== undefined && message.coachRating !== 0) {
      obj.coachRating = Math.round(message.coachRating);
    }
    if (message.queuePoints !== undefined && message.queuePoints !== 0) {
      obj.queuePoints = Math.round(message.queuePoints);
    }
    if (message.roleHandicaps?.length) {
      obj.roleHandicaps = message.roleHandicaps.map((e) => CSODOTAGameAccountClient_RoleHandicap.toJSON(e));
    }
    if (message.eventModeRecentTime !== undefined && message.eventModeRecentTime !== 0) {
      obj.eventModeRecentTime = Math.round(message.eventModeRecentTime);
    }
    if (message.mmrRecalibrationTime !== undefined && message.mmrRecalibrationTime !== 0) {
      obj.mmrRecalibrationTime = Math.round(message.mmrRecalibrationTime);
    }
    if (message.bannedHeroIds?.length) {
      obj.bannedHeroIds = message.bannedHeroIds.map((e) => Math.round(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CSODOTAGameAccountClient>): CSODOTAGameAccountClient {
    return CSODOTAGameAccountClient.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CSODOTAGameAccountClient>): CSODOTAGameAccountClient {
    const message = createBaseCSODOTAGameAccountClient();
    message.accountId = object.accountId ?? 0;
    message.wins = object.wins ?? 0;
    message.losses = object.losses ?? 0;
    message.xp = object.xp ?? 0;
    message.level = object.level ?? 0;
    message.initialSkill = object.initialSkill ?? 0;
    message.leaverCount = object.leaverCount ?? 0;
    message.secondaryLeaverCount = object.secondaryLeaverCount ?? 0;
    message.lowPriorityUntilDate = object.lowPriorityUntilDate ?? 0;
    message.preventTextChatUntilDate = object.preventTextChatUntilDate ?? 0;
    message.preventVoiceUntilDate = object.preventVoiceUntilDate ?? 0;
    message.preventPublicTextChatUntilDate = object.preventPublicTextChatUntilDate ?? 0;
    message.preventNewPlayerChatUntilDate = object.preventNewPlayerChatUntilDate ?? 0;
    message.lastAbandonedGameDate = object.lastAbandonedGameDate ?? 0;
    message.lastSecondaryAbandonedGameDate = object.lastSecondaryAbandonedGameDate ?? 0;
    message.leaverPenaltyCount = object.leaverPenaltyCount ?? 0;
    message.completedGameStreak = object.completedGameStreak ?? 0;
    message.accountDisabledUntilDate = object.accountDisabledUntilDate ?? 0;
    message.accountDisabledCount = object.accountDisabledCount ?? 0;
    message.matchDisabledUntilDate = object.matchDisabledUntilDate ?? 0;
    message.matchDisabledCount = object.matchDisabledCount ?? 0;
    message.shutdownlawterminatetimestamp = object.shutdownlawterminatetimestamp ?? 0;
    message.lowPriorityGamesRemaining = object.lowPriorityGamesRemaining ?? 0;
    message.recruitmentLevel = object.recruitmentLevel ?? 0;
    message.hasNewNotifications = object.hasNewNotifications ?? false;
    message.isLeagueAdmin = object.isLeagueAdmin ?? false;
    message.casualGamesPlayed = object.casualGamesPlayed ?? 0;
    message.soloCompetitiveGamesPlayed = object.soloCompetitiveGamesPlayed ?? 0;
    message.partyCompetitiveGamesPlayed = object.partyCompetitiveGamesPlayed ?? 0;
    message.casual1v1GamesPlayed = object.casual1v1GamesPlayed ?? 0;
    message.currAllHeroChallengeId = object.currAllHeroChallengeId ?? 0;
    message.playTimePoints = object.playTimePoints ?? 0;
    message.accountFlags = object.accountFlags ?? 0;
    message.playTimeLevel = object.playTimeLevel ?? 0;
    message.playerBehaviorSeqNumLastReport = object.playerBehaviorSeqNumLastReport ?? 0;
    message.playerBehaviorScoreLastReport = object.playerBehaviorScoreLastReport ?? 0;
    message.playerBehaviorReportOldData = object.playerBehaviorReportOldData ?? false;
    message.tourneySkillLevel = object.tourneySkillLevel ?? 0;
    message.tourneyRecentParticipationDate = object.tourneyRecentParticipationDate ?? 0;
    message.anchoredPhoneNumberId = object.anchoredPhoneNumberId ?? "0";
    message.rankedMatchmakingBanUntilDate = object.rankedMatchmakingBanUntilDate ?? 0;
    message.recentGameTime1 = object.recentGameTime1 ?? 0;
    message.recentGameTime2 = object.recentGameTime2 ?? 0;
    message.recentGameTime3 = object.recentGameTime3 ?? 0;
    message.favoriteTeamPacked = object.favoriteTeamPacked ?? "0";
    message.recentReportTime = object.recentReportTime ?? 0;
    message.customGameDisabledUntilDate = object.customGameDisabledUntilDate ?? 0;
    message.recentWinTime1 = object.recentWinTime1 ?? 0;
    message.recentWinTime2 = object.recentWinTime2 ?? 0;
    message.recentWinTime3 = object.recentWinTime3 ?? 0;
    message.coachRating = object.coachRating ?? 0;
    message.queuePoints = object.queuePoints ?? 0;
    message.roleHandicaps = object.roleHandicaps?.map((e) => CSODOTAGameAccountClient_RoleHandicap.fromPartial(e)) ||
      [];
    message.eventModeRecentTime = object.eventModeRecentTime ?? 0;
    message.mmrRecalibrationTime = object.mmrRecalibrationTime ?? 0;
    message.bannedHeroIds = object.bannedHeroIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseCSODOTAGameAccountClient_RoleHandicap(): CSODOTAGameAccountClient_RoleHandicap {
  return { role: 0, handicap: 0 };
}

export const CSODOTAGameAccountClient_RoleHandicap = {
  encode(message: CSODOTAGameAccountClient_RoleHandicap, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.role !== undefined && message.role !== 0) {
      writer.uint32(8).uint32(message.role);
    }
    if (message.handicap !== undefined && message.handicap !== 0) {
      writer.uint32(21).float(message.handicap);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CSODOTAGameAccountClient_RoleHandicap {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCSODOTAGameAccountClient_RoleHandicap();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.role = reader.uint32();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.handicap = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CSODOTAGameAccountClient_RoleHandicap {
    return {
      role: isSet(object.role) ? globalThis.Number(object.role) : 0,
      handicap: isSet(object.handicap) ? globalThis.Number(object.handicap) : 0,
    };
  },

  toJSON(message: CSODOTAGameAccountClient_RoleHandicap): unknown {
    const obj: any = {};
    if (message.role !== undefined && message.role !== 0) {
      obj.role = Math.round(message.role);
    }
    if (message.handicap !== undefined && message.handicap !== 0) {
      obj.handicap = message.handicap;
    }
    return obj;
  },

  create(base?: DeepPartial<CSODOTAGameAccountClient_RoleHandicap>): CSODOTAGameAccountClient_RoleHandicap {
    return CSODOTAGameAccountClient_RoleHandicap.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CSODOTAGameAccountClient_RoleHandicap>): CSODOTAGameAccountClient_RoleHandicap {
    const message = createBaseCSODOTAGameAccountClient_RoleHandicap();
    message.role = object.role ?? 0;
    message.handicap = object.handicap ?? 0;
    return message;
  },
};

function createBaseCSODOTAGameAccountPlus(): CSODOTAGameAccountPlus {
  return {
    accountId: 0,
    originalStartDate: 0,
    plusFlags: 0,
    plusStatus: 0,
    prepaidTimeStart: 0,
    prepaidTimeBalance: 0,
    nextPaymentDate: 0,
    steamAgreementId: "0",
  };
}

export const CSODOTAGameAccountPlus = {
  encode(message: CSODOTAGameAccountPlus, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.accountId !== undefined && message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    if (message.originalStartDate !== undefined && message.originalStartDate !== 0) {
      writer.uint32(16).uint32(message.originalStartDate);
    }
    if (message.plusFlags !== undefined && message.plusFlags !== 0) {
      writer.uint32(24).uint32(message.plusFlags);
    }
    if (message.plusStatus !== undefined && message.plusStatus !== 0) {
      writer.uint32(32).uint32(message.plusStatus);
    }
    if (message.prepaidTimeStart !== undefined && message.prepaidTimeStart !== 0) {
      writer.uint32(40).uint32(message.prepaidTimeStart);
    }
    if (message.prepaidTimeBalance !== undefined && message.prepaidTimeBalance !== 0) {
      writer.uint32(48).uint32(message.prepaidTimeBalance);
    }
    if (message.nextPaymentDate !== undefined && message.nextPaymentDate !== 0) {
      writer.uint32(61).fixed32(message.nextPaymentDate);
    }
    if (message.steamAgreementId !== undefined && message.steamAgreementId !== "0") {
      writer.uint32(65).fixed64(message.steamAgreementId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CSODOTAGameAccountPlus {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCSODOTAGameAccountPlus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.originalStartDate = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.plusFlags = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.plusStatus = reader.uint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.prepaidTimeStart = reader.uint32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.prepaidTimeBalance = reader.uint32();
          continue;
        case 7:
          if (tag !== 61) {
            break;
          }

          message.nextPaymentDate = reader.fixed32();
          continue;
        case 8:
          if (tag !== 65) {
            break;
          }

          message.steamAgreementId = longToString(reader.fixed64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CSODOTAGameAccountPlus {
    return {
      accountId: isSet(object.accountId) ? globalThis.Number(object.accountId) : 0,
      originalStartDate: isSet(object.originalStartDate) ? globalThis.Number(object.originalStartDate) : 0,
      plusFlags: isSet(object.plusFlags) ? globalThis.Number(object.plusFlags) : 0,
      plusStatus: isSet(object.plusStatus) ? globalThis.Number(object.plusStatus) : 0,
      prepaidTimeStart: isSet(object.prepaidTimeStart) ? globalThis.Number(object.prepaidTimeStart) : 0,
      prepaidTimeBalance: isSet(object.prepaidTimeBalance) ? globalThis.Number(object.prepaidTimeBalance) : 0,
      nextPaymentDate: isSet(object.nextPaymentDate) ? globalThis.Number(object.nextPaymentDate) : 0,
      steamAgreementId: isSet(object.steamAgreementId) ? globalThis.String(object.steamAgreementId) : "0",
    };
  },

  toJSON(message: CSODOTAGameAccountPlus): unknown {
    const obj: any = {};
    if (message.accountId !== undefined && message.accountId !== 0) {
      obj.accountId = Math.round(message.accountId);
    }
    if (message.originalStartDate !== undefined && message.originalStartDate !== 0) {
      obj.originalStartDate = Math.round(message.originalStartDate);
    }
    if (message.plusFlags !== undefined && message.plusFlags !== 0) {
      obj.plusFlags = Math.round(message.plusFlags);
    }
    if (message.plusStatus !== undefined && message.plusStatus !== 0) {
      obj.plusStatus = Math.round(message.plusStatus);
    }
    if (message.prepaidTimeStart !== undefined && message.prepaidTimeStart !== 0) {
      obj.prepaidTimeStart = Math.round(message.prepaidTimeStart);
    }
    if (message.prepaidTimeBalance !== undefined && message.prepaidTimeBalance !== 0) {
      obj.prepaidTimeBalance = Math.round(message.prepaidTimeBalance);
    }
    if (message.nextPaymentDate !== undefined && message.nextPaymentDate !== 0) {
      obj.nextPaymentDate = Math.round(message.nextPaymentDate);
    }
    if (message.steamAgreementId !== undefined && message.steamAgreementId !== "0") {
      obj.steamAgreementId = message.steamAgreementId;
    }
    return obj;
  },

  create(base?: DeepPartial<CSODOTAGameAccountPlus>): CSODOTAGameAccountPlus {
    return CSODOTAGameAccountPlus.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CSODOTAGameAccountPlus>): CSODOTAGameAccountPlus {
    const message = createBaseCSODOTAGameAccountPlus();
    message.accountId = object.accountId ?? 0;
    message.originalStartDate = object.originalStartDate ?? 0;
    message.plusFlags = object.plusFlags ?? 0;
    message.plusStatus = object.plusStatus ?? 0;
    message.prepaidTimeStart = object.prepaidTimeStart ?? 0;
    message.prepaidTimeBalance = object.prepaidTimeBalance ?? 0;
    message.nextPaymentDate = object.nextPaymentDate ?? 0;
    message.steamAgreementId = object.steamAgreementId ?? "0";
    return message;
  },
};

function createBaseCSODOTAChatWheel(): CSODOTAChatWheel {
  return { messageId: 4294967295 };
}

export const CSODOTAChatWheel = {
  encode(message: CSODOTAChatWheel, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.messageId !== undefined && message.messageId !== 4294967295) {
      writer.uint32(8).uint32(message.messageId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CSODOTAChatWheel {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCSODOTAChatWheel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.messageId = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CSODOTAChatWheel {
    return { messageId: isSet(object.messageId) ? globalThis.Number(object.messageId) : 4294967295 };
  },

  toJSON(message: CSODOTAChatWheel): unknown {
    const obj: any = {};
    if (message.messageId !== undefined && message.messageId !== 4294967295) {
      obj.messageId = Math.round(message.messageId);
    }
    return obj;
  },

  create(base?: DeepPartial<CSODOTAChatWheel>): CSODOTAChatWheel {
    return CSODOTAChatWheel.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CSODOTAChatWheel>): CSODOTAChatWheel {
    const message = createBaseCSODOTAChatWheel();
    message.messageId = object.messageId ?? 4294967295;
    return message;
  },
};

function createBaseCMsgLobbyFeaturedGamemodeProgress(): CMsgLobbyFeaturedGamemodeProgress {
  return { accounts: [] };
}

export const CMsgLobbyFeaturedGamemodeProgress = {
  encode(message: CMsgLobbyFeaturedGamemodeProgress, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.accounts) {
      CMsgLobbyFeaturedGamemodeProgress_AccountProgress.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgLobbyFeaturedGamemodeProgress {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgLobbyFeaturedGamemodeProgress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.accounts.push(CMsgLobbyFeaturedGamemodeProgress_AccountProgress.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgLobbyFeaturedGamemodeProgress {
    return {
      accounts: globalThis.Array.isArray(object?.accounts)
        ? object.accounts.map((e: any) => CMsgLobbyFeaturedGamemodeProgress_AccountProgress.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgLobbyFeaturedGamemodeProgress): unknown {
    const obj: any = {};
    if (message.accounts?.length) {
      obj.accounts = message.accounts.map((e) => CMsgLobbyFeaturedGamemodeProgress_AccountProgress.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgLobbyFeaturedGamemodeProgress>): CMsgLobbyFeaturedGamemodeProgress {
    return CMsgLobbyFeaturedGamemodeProgress.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgLobbyFeaturedGamemodeProgress>): CMsgLobbyFeaturedGamemodeProgress {
    const message = createBaseCMsgLobbyFeaturedGamemodeProgress();
    message.accounts = object.accounts?.map((e) => CMsgLobbyFeaturedGamemodeProgress_AccountProgress.fromPartial(e)) ||
      [];
    return message;
  },
};

function createBaseCMsgLobbyFeaturedGamemodeProgress_AccountProgress(): CMsgLobbyFeaturedGamemodeProgress_AccountProgress {
  return { accountId: 0, currentValue: 0, maxValue: 0 };
}

export const CMsgLobbyFeaturedGamemodeProgress_AccountProgress = {
  encode(
    message: CMsgLobbyFeaturedGamemodeProgress_AccountProgress,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.accountId !== undefined && message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    if (message.currentValue !== undefined && message.currentValue !== 0) {
      writer.uint32(16).uint32(message.currentValue);
    }
    if (message.maxValue !== undefined && message.maxValue !== 0) {
      writer.uint32(24).uint32(message.maxValue);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgLobbyFeaturedGamemodeProgress_AccountProgress {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgLobbyFeaturedGamemodeProgress_AccountProgress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.currentValue = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.maxValue = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgLobbyFeaturedGamemodeProgress_AccountProgress {
    return {
      accountId: isSet(object.accountId) ? globalThis.Number(object.accountId) : 0,
      currentValue: isSet(object.currentValue) ? globalThis.Number(object.currentValue) : 0,
      maxValue: isSet(object.maxValue) ? globalThis.Number(object.maxValue) : 0,
    };
  },

  toJSON(message: CMsgLobbyFeaturedGamemodeProgress_AccountProgress): unknown {
    const obj: any = {};
    if (message.accountId !== undefined && message.accountId !== 0) {
      obj.accountId = Math.round(message.accountId);
    }
    if (message.currentValue !== undefined && message.currentValue !== 0) {
      obj.currentValue = Math.round(message.currentValue);
    }
    if (message.maxValue !== undefined && message.maxValue !== 0) {
      obj.maxValue = Math.round(message.maxValue);
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgLobbyFeaturedGamemodeProgress_AccountProgress>,
  ): CMsgLobbyFeaturedGamemodeProgress_AccountProgress {
    return CMsgLobbyFeaturedGamemodeProgress_AccountProgress.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgLobbyFeaturedGamemodeProgress_AccountProgress>,
  ): CMsgLobbyFeaturedGamemodeProgress_AccountProgress {
    const message = createBaseCMsgLobbyFeaturedGamemodeProgress_AccountProgress();
    message.accountId = object.accountId ?? 0;
    message.currentValue = object.currentValue ?? 0;
    message.maxValue = object.maxValue ?? 0;
    return message;
  },
};

function createBaseCMsgBattleCupVictory(): CMsgBattleCupVictory {
  return {
    accountId: 0,
    winDate: 0,
    validUntil: 0,
    skillLevel: 0,
    tournamentId: 0,
    divisionId: 0,
    teamId: 0,
    streak: 0,
    trophyId: 0,
  };
}

export const CMsgBattleCupVictory = {
  encode(message: CMsgBattleCupVictory, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.accountId !== undefined && message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    if (message.winDate !== undefined && message.winDate !== 0) {
      writer.uint32(16).uint32(message.winDate);
    }
    if (message.validUntil !== undefined && message.validUntil !== 0) {
      writer.uint32(24).uint32(message.validUntil);
    }
    if (message.skillLevel !== undefined && message.skillLevel !== 0) {
      writer.uint32(32).uint32(message.skillLevel);
    }
    if (message.tournamentId !== undefined && message.tournamentId !== 0) {
      writer.uint32(40).uint32(message.tournamentId);
    }
    if (message.divisionId !== undefined && message.divisionId !== 0) {
      writer.uint32(48).uint32(message.divisionId);
    }
    if (message.teamId !== undefined && message.teamId !== 0) {
      writer.uint32(56).uint32(message.teamId);
    }
    if (message.streak !== undefined && message.streak !== 0) {
      writer.uint32(64).uint32(message.streak);
    }
    if (message.trophyId !== undefined && message.trophyId !== 0) {
      writer.uint32(72).uint32(message.trophyId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgBattleCupVictory {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgBattleCupVictory();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.winDate = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.validUntil = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.skillLevel = reader.uint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.tournamentId = reader.uint32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.divisionId = reader.uint32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.teamId = reader.uint32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.streak = reader.uint32();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.trophyId = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgBattleCupVictory {
    return {
      accountId: isSet(object.accountId) ? globalThis.Number(object.accountId) : 0,
      winDate: isSet(object.winDate) ? globalThis.Number(object.winDate) : 0,
      validUntil: isSet(object.validUntil) ? globalThis.Number(object.validUntil) : 0,
      skillLevel: isSet(object.skillLevel) ? globalThis.Number(object.skillLevel) : 0,
      tournamentId: isSet(object.tournamentId) ? globalThis.Number(object.tournamentId) : 0,
      divisionId: isSet(object.divisionId) ? globalThis.Number(object.divisionId) : 0,
      teamId: isSet(object.teamId) ? globalThis.Number(object.teamId) : 0,
      streak: isSet(object.streak) ? globalThis.Number(object.streak) : 0,
      trophyId: isSet(object.trophyId) ? globalThis.Number(object.trophyId) : 0,
    };
  },

  toJSON(message: CMsgBattleCupVictory): unknown {
    const obj: any = {};
    if (message.accountId !== undefined && message.accountId !== 0) {
      obj.accountId = Math.round(message.accountId);
    }
    if (message.winDate !== undefined && message.winDate !== 0) {
      obj.winDate = Math.round(message.winDate);
    }
    if (message.validUntil !== undefined && message.validUntil !== 0) {
      obj.validUntil = Math.round(message.validUntil);
    }
    if (message.skillLevel !== undefined && message.skillLevel !== 0) {
      obj.skillLevel = Math.round(message.skillLevel);
    }
    if (message.tournamentId !== undefined && message.tournamentId !== 0) {
      obj.tournamentId = Math.round(message.tournamentId);
    }
    if (message.divisionId !== undefined && message.divisionId !== 0) {
      obj.divisionId = Math.round(message.divisionId);
    }
    if (message.teamId !== undefined && message.teamId !== 0) {
      obj.teamId = Math.round(message.teamId);
    }
    if (message.streak !== undefined && message.streak !== 0) {
      obj.streak = Math.round(message.streak);
    }
    if (message.trophyId !== undefined && message.trophyId !== 0) {
      obj.trophyId = Math.round(message.trophyId);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgBattleCupVictory>): CMsgBattleCupVictory {
    return CMsgBattleCupVictory.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgBattleCupVictory>): CMsgBattleCupVictory {
    const message = createBaseCMsgBattleCupVictory();
    message.accountId = object.accountId ?? 0;
    message.winDate = object.winDate ?? 0;
    message.validUntil = object.validUntil ?? 0;
    message.skillLevel = object.skillLevel ?? 0;
    message.tournamentId = object.tournamentId ?? 0;
    message.divisionId = object.divisionId ?? 0;
    message.teamId = object.teamId ?? 0;
    message.streak = object.streak ?? 0;
    message.trophyId = object.trophyId ?? 0;
    return message;
  },
};

function createBaseCMsgLobbyBattleCupVictoryList(): CMsgLobbyBattleCupVictoryList {
  return { winners: [] };
}

export const CMsgLobbyBattleCupVictoryList = {
  encode(message: CMsgLobbyBattleCupVictoryList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.winners) {
      CMsgBattleCupVictory.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgLobbyBattleCupVictoryList {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgLobbyBattleCupVictoryList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.winners.push(CMsgBattleCupVictory.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgLobbyBattleCupVictoryList {
    return {
      winners: globalThis.Array.isArray(object?.winners)
        ? object.winners.map((e: any) => CMsgBattleCupVictory.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgLobbyBattleCupVictoryList): unknown {
    const obj: any = {};
    if (message.winners?.length) {
      obj.winners = message.winners.map((e) => CMsgBattleCupVictory.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgLobbyBattleCupVictoryList>): CMsgLobbyBattleCupVictoryList {
    return CMsgLobbyBattleCupVictoryList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgLobbyBattleCupVictoryList>): CMsgLobbyBattleCupVictoryList {
    const message = createBaseCMsgLobbyBattleCupVictoryList();
    message.winners = object.winners?.map((e) => CMsgBattleCupVictory.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgDOTABroadcastNotification(): CMsgDOTABroadcastNotification {
  return { message: "" };
}

export const CMsgDOTABroadcastNotification = {
  encode(message: CMsgDOTABroadcastNotification, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.message !== undefined && message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTABroadcastNotification {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTABroadcastNotification();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTABroadcastNotification {
    return { message: isSet(object.message) ? globalThis.String(object.message) : "" };
  },

  toJSON(message: CMsgDOTABroadcastNotification): unknown {
    const obj: any = {};
    if (message.message !== undefined && message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTABroadcastNotification>): CMsgDOTABroadcastNotification {
    return CMsgDOTABroadcastNotification.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTABroadcastNotification>): CMsgDOTABroadcastNotification {
    const message = createBaseCMsgDOTABroadcastNotification();
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseCProtoItemHeroStatue(): CProtoItemHeroStatue {
  return {
    heroId: 0,
    statusEffectIndex: 0,
    sequenceName: "",
    cycle: 0,
    wearable: [],
    inscription: "",
    style: [],
    tournamentDrop: false,
  };
}

export const CProtoItemHeroStatue = {
  encode(message: CProtoItemHeroStatue, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.heroId !== undefined && message.heroId !== 0) {
      writer.uint32(8).int32(message.heroId);
    }
    if (message.statusEffectIndex !== undefined && message.statusEffectIndex !== 0) {
      writer.uint32(16).uint32(message.statusEffectIndex);
    }
    if (message.sequenceName !== undefined && message.sequenceName !== "") {
      writer.uint32(26).string(message.sequenceName);
    }
    if (message.cycle !== undefined && message.cycle !== 0) {
      writer.uint32(37).float(message.cycle);
    }
    writer.uint32(42).fork();
    for (const v of message.wearable) {
      writer.uint32(v);
    }
    writer.ldelim();
    if (message.inscription !== undefined && message.inscription !== "") {
      writer.uint32(50).string(message.inscription);
    }
    writer.uint32(58).fork();
    for (const v of message.style) {
      writer.uint32(v);
    }
    writer.ldelim();
    if (message.tournamentDrop !== undefined && message.tournamentDrop !== false) {
      writer.uint32(64).bool(message.tournamentDrop);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CProtoItemHeroStatue {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCProtoItemHeroStatue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.heroId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.statusEffectIndex = reader.uint32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.sequenceName = reader.string();
          continue;
        case 4:
          if (tag !== 37) {
            break;
          }

          message.cycle = reader.float();
          continue;
        case 5:
          if (tag === 40) {
            message.wearable.push(reader.uint32());

            continue;
          }

          if (tag === 42) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.wearable.push(reader.uint32());
            }

            continue;
          }

          break;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.inscription = reader.string();
          continue;
        case 7:
          if (tag === 56) {
            message.style.push(reader.uint32());

            continue;
          }

          if (tag === 58) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.style.push(reader.uint32());
            }

            continue;
          }

          break;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.tournamentDrop = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CProtoItemHeroStatue {
    return {
      heroId: isSet(object.heroId) ? globalThis.Number(object.heroId) : 0,
      statusEffectIndex: isSet(object.statusEffectIndex) ? globalThis.Number(object.statusEffectIndex) : 0,
      sequenceName: isSet(object.sequenceName) ? globalThis.String(object.sequenceName) : "",
      cycle: isSet(object.cycle) ? globalThis.Number(object.cycle) : 0,
      wearable: globalThis.Array.isArray(object?.wearable) ? object.wearable.map((e: any) => globalThis.Number(e)) : [],
      inscription: isSet(object.inscription) ? globalThis.String(object.inscription) : "",
      style: globalThis.Array.isArray(object?.style) ? object.style.map((e: any) => globalThis.Number(e)) : [],
      tournamentDrop: isSet(object.tournamentDrop) ? globalThis.Boolean(object.tournamentDrop) : false,
    };
  },

  toJSON(message: CProtoItemHeroStatue): unknown {
    const obj: any = {};
    if (message.heroId !== undefined && message.heroId !== 0) {
      obj.heroId = Math.round(message.heroId);
    }
    if (message.statusEffectIndex !== undefined && message.statusEffectIndex !== 0) {
      obj.statusEffectIndex = Math.round(message.statusEffectIndex);
    }
    if (message.sequenceName !== undefined && message.sequenceName !== "") {
      obj.sequenceName = message.sequenceName;
    }
    if (message.cycle !== undefined && message.cycle !== 0) {
      obj.cycle = message.cycle;
    }
    if (message.wearable?.length) {
      obj.wearable = message.wearable.map((e) => Math.round(e));
    }
    if (message.inscription !== undefined && message.inscription !== "") {
      obj.inscription = message.inscription;
    }
    if (message.style?.length) {
      obj.style = message.style.map((e) => Math.round(e));
    }
    if (message.tournamentDrop !== undefined && message.tournamentDrop !== false) {
      obj.tournamentDrop = message.tournamentDrop;
    }
    return obj;
  },

  create(base?: DeepPartial<CProtoItemHeroStatue>): CProtoItemHeroStatue {
    return CProtoItemHeroStatue.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CProtoItemHeroStatue>): CProtoItemHeroStatue {
    const message = createBaseCProtoItemHeroStatue();
    message.heroId = object.heroId ?? 0;
    message.statusEffectIndex = object.statusEffectIndex ?? 0;
    message.sequenceName = object.sequenceName ?? "";
    message.cycle = object.cycle ?? 0;
    message.wearable = object.wearable?.map((e) => e) || [];
    message.inscription = object.inscription ?? "";
    message.style = object.style?.map((e) => e) || [];
    message.tournamentDrop = object.tournamentDrop ?? false;
    return message;
  },
};

function createBaseCMatchPlayerAbilityUpgrade(): CMatchPlayerAbilityUpgrade {
  return { ability: -1, time: 0 };
}

export const CMatchPlayerAbilityUpgrade = {
  encode(message: CMatchPlayerAbilityUpgrade, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.ability !== undefined && message.ability !== -1) {
      writer.uint32(8).int32(message.ability);
    }
    if (message.time !== undefined && message.time !== 0) {
      writer.uint32(16).uint32(message.time);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMatchPlayerAbilityUpgrade {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMatchPlayerAbilityUpgrade();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.ability = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.time = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMatchPlayerAbilityUpgrade {
    return {
      ability: isSet(object.ability) ? globalThis.Number(object.ability) : -1,
      time: isSet(object.time) ? globalThis.Number(object.time) : 0,
    };
  },

  toJSON(message: CMatchPlayerAbilityUpgrade): unknown {
    const obj: any = {};
    if (message.ability !== undefined && message.ability !== -1) {
      obj.ability = Math.round(message.ability);
    }
    if (message.time !== undefined && message.time !== 0) {
      obj.time = Math.round(message.time);
    }
    return obj;
  },

  create(base?: DeepPartial<CMatchPlayerAbilityUpgrade>): CMatchPlayerAbilityUpgrade {
    return CMatchPlayerAbilityUpgrade.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMatchPlayerAbilityUpgrade>): CMatchPlayerAbilityUpgrade {
    const message = createBaseCMatchPlayerAbilityUpgrade();
    message.ability = object.ability ?? -1;
    message.time = object.time ?? 0;
    return message;
  },
};

function createBaseCMatchPlayerTimedCustomStat(): CMatchPlayerTimedCustomStat {
  return { stat: 1, value: 0 };
}

export const CMatchPlayerTimedCustomStat = {
  encode(message: CMatchPlayerTimedCustomStat, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.stat !== undefined && message.stat !== 1) {
      writer.uint32(16).int32(message.stat);
    }
    if (message.value !== undefined && message.value !== 0) {
      writer.uint32(29).float(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMatchPlayerTimedCustomStat {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMatchPlayerTimedCustomStat();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 16) {
            break;
          }

          message.stat = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.value = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMatchPlayerTimedCustomStat {
    return {
      stat: isSet(object.stat) ? eDOTAMatchPlayerTimeCustomStatFromJSON(object.stat) : 1,
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
    };
  },

  toJSON(message: CMatchPlayerTimedCustomStat): unknown {
    const obj: any = {};
    if (message.stat !== undefined && message.stat !== 1) {
      obj.stat = eDOTAMatchPlayerTimeCustomStatToJSON(message.stat);
    }
    if (message.value !== undefined && message.value !== 0) {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<CMatchPlayerTimedCustomStat>): CMatchPlayerTimedCustomStat {
    return CMatchPlayerTimedCustomStat.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMatchPlayerTimedCustomStat>): CMatchPlayerTimedCustomStat {
    const message = createBaseCMatchPlayerTimedCustomStat();
    message.stat = object.stat ?? 1;
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseCMatchPlayerTimedStats(): CMatchPlayerTimedStats {
  return {
    time: 0,
    kills: 0,
    deaths: 0,
    assists: 0,
    netWorth: 0,
    xp: 0,
    lastHits: 0,
    denies: 0,
    bountyRuneGold: 0,
    rangeCreepUpgradeGold: 0,
    observerWardsDewarded: 0,
    reliableGoldEarned: 0,
    goldLossPrevented: 0,
    heroKillGold: 0,
    creepKillGold: 0,
    buildingGold: 0,
    otherGold: 0,
    comebackGold: 0,
    experimentalGold: 0,
    experimental2Gold: 0,
    creepDenyGold: 0,
    tpScrollsPurchased1: 0,
    tpScrollsPurchased2: 0,
    tpScrollsPurchased3: 0,
    tpScrollsPurchased4: 0,
    tpScrollsPurchased5: 0,
    neutralGold: 0,
    courierGold: 0,
    roshanGold: 0,
    incomeGold: 0,
    itemValue: 0,
    supportGoldSpent: 0,
    campsStacked: 0,
    wardsPlaced: 0,
    tripleKills: 0,
    rampages: 0,
    customStats: [],
  };
}

export const CMatchPlayerTimedStats = {
  encode(message: CMatchPlayerTimedStats, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.time !== undefined && message.time !== 0) {
      writer.uint32(8).uint32(message.time);
    }
    if (message.kills !== undefined && message.kills !== 0) {
      writer.uint32(16).uint32(message.kills);
    }
    if (message.deaths !== undefined && message.deaths !== 0) {
      writer.uint32(24).uint32(message.deaths);
    }
    if (message.assists !== undefined && message.assists !== 0) {
      writer.uint32(32).uint32(message.assists);
    }
    if (message.netWorth !== undefined && message.netWorth !== 0) {
      writer.uint32(40).uint32(message.netWorth);
    }
    if (message.xp !== undefined && message.xp !== 0) {
      writer.uint32(48).uint32(message.xp);
    }
    if (message.lastHits !== undefined && message.lastHits !== 0) {
      writer.uint32(56).uint32(message.lastHits);
    }
    if (message.denies !== undefined && message.denies !== 0) {
      writer.uint32(64).uint32(message.denies);
    }
    if (message.bountyRuneGold !== undefined && message.bountyRuneGold !== 0) {
      writer.uint32(72).uint32(message.bountyRuneGold);
    }
    if (message.rangeCreepUpgradeGold !== undefined && message.rangeCreepUpgradeGold !== 0) {
      writer.uint32(80).uint32(message.rangeCreepUpgradeGold);
    }
    if (message.observerWardsDewarded !== undefined && message.observerWardsDewarded !== 0) {
      writer.uint32(88).uint32(message.observerWardsDewarded);
    }
    if (message.reliableGoldEarned !== undefined && message.reliableGoldEarned !== 0) {
      writer.uint32(96).uint32(message.reliableGoldEarned);
    }
    if (message.goldLossPrevented !== undefined && message.goldLossPrevented !== 0) {
      writer.uint32(104).uint32(message.goldLossPrevented);
    }
    if (message.heroKillGold !== undefined && message.heroKillGold !== 0) {
      writer.uint32(112).uint32(message.heroKillGold);
    }
    if (message.creepKillGold !== undefined && message.creepKillGold !== 0) {
      writer.uint32(120).uint32(message.creepKillGold);
    }
    if (message.buildingGold !== undefined && message.buildingGold !== 0) {
      writer.uint32(128).uint32(message.buildingGold);
    }
    if (message.otherGold !== undefined && message.otherGold !== 0) {
      writer.uint32(136).uint32(message.otherGold);
    }
    if (message.comebackGold !== undefined && message.comebackGold !== 0) {
      writer.uint32(144).uint32(message.comebackGold);
    }
    if (message.experimentalGold !== undefined && message.experimentalGold !== 0) {
      writer.uint32(152).uint32(message.experimentalGold);
    }
    if (message.experimental2Gold !== undefined && message.experimental2Gold !== 0) {
      writer.uint32(160).uint32(message.experimental2Gold);
    }
    if (message.creepDenyGold !== undefined && message.creepDenyGold !== 0) {
      writer.uint32(168).uint32(message.creepDenyGold);
    }
    if (message.tpScrollsPurchased1 !== undefined && message.tpScrollsPurchased1 !== 0) {
      writer.uint32(176).uint32(message.tpScrollsPurchased1);
    }
    if (message.tpScrollsPurchased2 !== undefined && message.tpScrollsPurchased2 !== 0) {
      writer.uint32(184).uint32(message.tpScrollsPurchased2);
    }
    if (message.tpScrollsPurchased3 !== undefined && message.tpScrollsPurchased3 !== 0) {
      writer.uint32(192).uint32(message.tpScrollsPurchased3);
    }
    if (message.tpScrollsPurchased4 !== undefined && message.tpScrollsPurchased4 !== 0) {
      writer.uint32(200).uint32(message.tpScrollsPurchased4);
    }
    if (message.tpScrollsPurchased5 !== undefined && message.tpScrollsPurchased5 !== 0) {
      writer.uint32(208).uint32(message.tpScrollsPurchased5);
    }
    if (message.neutralGold !== undefined && message.neutralGold !== 0) {
      writer.uint32(216).uint32(message.neutralGold);
    }
    if (message.courierGold !== undefined && message.courierGold !== 0) {
      writer.uint32(224).uint32(message.courierGold);
    }
    if (message.roshanGold !== undefined && message.roshanGold !== 0) {
      writer.uint32(232).uint32(message.roshanGold);
    }
    if (message.incomeGold !== undefined && message.incomeGold !== 0) {
      writer.uint32(240).uint32(message.incomeGold);
    }
    if (message.itemValue !== undefined && message.itemValue !== 0) {
      writer.uint32(288).uint32(message.itemValue);
    }
    if (message.supportGoldSpent !== undefined && message.supportGoldSpent !== 0) {
      writer.uint32(296).uint32(message.supportGoldSpent);
    }
    if (message.campsStacked !== undefined && message.campsStacked !== 0) {
      writer.uint32(304).uint32(message.campsStacked);
    }
    if (message.wardsPlaced !== undefined && message.wardsPlaced !== 0) {
      writer.uint32(312).uint32(message.wardsPlaced);
    }
    if (message.tripleKills !== undefined && message.tripleKills !== 0) {
      writer.uint32(320).uint32(message.tripleKills);
    }
    if (message.rampages !== undefined && message.rampages !== 0) {
      writer.uint32(328).uint32(message.rampages);
    }
    for (const v of message.customStats) {
      CMatchPlayerTimedCustomStat.encode(v!, writer.uint32(338).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMatchPlayerTimedStats {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMatchPlayerTimedStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.time = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.kills = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.deaths = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.assists = reader.uint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.netWorth = reader.uint32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.xp = reader.uint32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.lastHits = reader.uint32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.denies = reader.uint32();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.bountyRuneGold = reader.uint32();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.rangeCreepUpgradeGold = reader.uint32();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.observerWardsDewarded = reader.uint32();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.reliableGoldEarned = reader.uint32();
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.goldLossPrevented = reader.uint32();
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.heroKillGold = reader.uint32();
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.creepKillGold = reader.uint32();
          continue;
        case 16:
          if (tag !== 128) {
            break;
          }

          message.buildingGold = reader.uint32();
          continue;
        case 17:
          if (tag !== 136) {
            break;
          }

          message.otherGold = reader.uint32();
          continue;
        case 18:
          if (tag !== 144) {
            break;
          }

          message.comebackGold = reader.uint32();
          continue;
        case 19:
          if (tag !== 152) {
            break;
          }

          message.experimentalGold = reader.uint32();
          continue;
        case 20:
          if (tag !== 160) {
            break;
          }

          message.experimental2Gold = reader.uint32();
          continue;
        case 21:
          if (tag !== 168) {
            break;
          }

          message.creepDenyGold = reader.uint32();
          continue;
        case 22:
          if (tag !== 176) {
            break;
          }

          message.tpScrollsPurchased1 = reader.uint32();
          continue;
        case 23:
          if (tag !== 184) {
            break;
          }

          message.tpScrollsPurchased2 = reader.uint32();
          continue;
        case 24:
          if (tag !== 192) {
            break;
          }

          message.tpScrollsPurchased3 = reader.uint32();
          continue;
        case 25:
          if (tag !== 200) {
            break;
          }

          message.tpScrollsPurchased4 = reader.uint32();
          continue;
        case 26:
          if (tag !== 208) {
            break;
          }

          message.tpScrollsPurchased5 = reader.uint32();
          continue;
        case 27:
          if (tag !== 216) {
            break;
          }

          message.neutralGold = reader.uint32();
          continue;
        case 28:
          if (tag !== 224) {
            break;
          }

          message.courierGold = reader.uint32();
          continue;
        case 29:
          if (tag !== 232) {
            break;
          }

          message.roshanGold = reader.uint32();
          continue;
        case 30:
          if (tag !== 240) {
            break;
          }

          message.incomeGold = reader.uint32();
          continue;
        case 36:
          if (tag !== 288) {
            break;
          }

          message.itemValue = reader.uint32();
          continue;
        case 37:
          if (tag !== 296) {
            break;
          }

          message.supportGoldSpent = reader.uint32();
          continue;
        case 38:
          if (tag !== 304) {
            break;
          }

          message.campsStacked = reader.uint32();
          continue;
        case 39:
          if (tag !== 312) {
            break;
          }

          message.wardsPlaced = reader.uint32();
          continue;
        case 40:
          if (tag !== 320) {
            break;
          }

          message.tripleKills = reader.uint32();
          continue;
        case 41:
          if (tag !== 328) {
            break;
          }

          message.rampages = reader.uint32();
          continue;
        case 42:
          if (tag !== 338) {
            break;
          }

          message.customStats.push(CMatchPlayerTimedCustomStat.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMatchPlayerTimedStats {
    return {
      time: isSet(object.time) ? globalThis.Number(object.time) : 0,
      kills: isSet(object.kills) ? globalThis.Number(object.kills) : 0,
      deaths: isSet(object.deaths) ? globalThis.Number(object.deaths) : 0,
      assists: isSet(object.assists) ? globalThis.Number(object.assists) : 0,
      netWorth: isSet(object.netWorth) ? globalThis.Number(object.netWorth) : 0,
      xp: isSet(object.xp) ? globalThis.Number(object.xp) : 0,
      lastHits: isSet(object.lastHits) ? globalThis.Number(object.lastHits) : 0,
      denies: isSet(object.denies) ? globalThis.Number(object.denies) : 0,
      bountyRuneGold: isSet(object.bountyRuneGold) ? globalThis.Number(object.bountyRuneGold) : 0,
      rangeCreepUpgradeGold: isSet(object.rangeCreepUpgradeGold) ? globalThis.Number(object.rangeCreepUpgradeGold) : 0,
      observerWardsDewarded: isSet(object.observerWardsDewarded) ? globalThis.Number(object.observerWardsDewarded) : 0,
      reliableGoldEarned: isSet(object.reliableGoldEarned) ? globalThis.Number(object.reliableGoldEarned) : 0,
      goldLossPrevented: isSet(object.goldLossPrevented) ? globalThis.Number(object.goldLossPrevented) : 0,
      heroKillGold: isSet(object.heroKillGold) ? globalThis.Number(object.heroKillGold) : 0,
      creepKillGold: isSet(object.creepKillGold) ? globalThis.Number(object.creepKillGold) : 0,
      buildingGold: isSet(object.buildingGold) ? globalThis.Number(object.buildingGold) : 0,
      otherGold: isSet(object.otherGold) ? globalThis.Number(object.otherGold) : 0,
      comebackGold: isSet(object.comebackGold) ? globalThis.Number(object.comebackGold) : 0,
      experimentalGold: isSet(object.experimentalGold) ? globalThis.Number(object.experimentalGold) : 0,
      experimental2Gold: isSet(object.experimental2Gold) ? globalThis.Number(object.experimental2Gold) : 0,
      creepDenyGold: isSet(object.creepDenyGold) ? globalThis.Number(object.creepDenyGold) : 0,
      tpScrollsPurchased1: isSet(object.tpScrollsPurchased1) ? globalThis.Number(object.tpScrollsPurchased1) : 0,
      tpScrollsPurchased2: isSet(object.tpScrollsPurchased2) ? globalThis.Number(object.tpScrollsPurchased2) : 0,
      tpScrollsPurchased3: isSet(object.tpScrollsPurchased3) ? globalThis.Number(object.tpScrollsPurchased3) : 0,
      tpScrollsPurchased4: isSet(object.tpScrollsPurchased4) ? globalThis.Number(object.tpScrollsPurchased4) : 0,
      tpScrollsPurchased5: isSet(object.tpScrollsPurchased5) ? globalThis.Number(object.tpScrollsPurchased5) : 0,
      neutralGold: isSet(object.neutralGold) ? globalThis.Number(object.neutralGold) : 0,
      courierGold: isSet(object.courierGold) ? globalThis.Number(object.courierGold) : 0,
      roshanGold: isSet(object.roshanGold) ? globalThis.Number(object.roshanGold) : 0,
      incomeGold: isSet(object.incomeGold) ? globalThis.Number(object.incomeGold) : 0,
      itemValue: isSet(object.itemValue) ? globalThis.Number(object.itemValue) : 0,
      supportGoldSpent: isSet(object.supportGoldSpent) ? globalThis.Number(object.supportGoldSpent) : 0,
      campsStacked: isSet(object.campsStacked) ? globalThis.Number(object.campsStacked) : 0,
      wardsPlaced: isSet(object.wardsPlaced) ? globalThis.Number(object.wardsPlaced) : 0,
      tripleKills: isSet(object.tripleKills) ? globalThis.Number(object.tripleKills) : 0,
      rampages: isSet(object.rampages) ? globalThis.Number(object.rampages) : 0,
      customStats: globalThis.Array.isArray(object?.customStats)
        ? object.customStats.map((e: any) => CMatchPlayerTimedCustomStat.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMatchPlayerTimedStats): unknown {
    const obj: any = {};
    if (message.time !== undefined && message.time !== 0) {
      obj.time = Math.round(message.time);
    }
    if (message.kills !== undefined && message.kills !== 0) {
      obj.kills = Math.round(message.kills);
    }
    if (message.deaths !== undefined && message.deaths !== 0) {
      obj.deaths = Math.round(message.deaths);
    }
    if (message.assists !== undefined && message.assists !== 0) {
      obj.assists = Math.round(message.assists);
    }
    if (message.netWorth !== undefined && message.netWorth !== 0) {
      obj.netWorth = Math.round(message.netWorth);
    }
    if (message.xp !== undefined && message.xp !== 0) {
      obj.xp = Math.round(message.xp);
    }
    if (message.lastHits !== undefined && message.lastHits !== 0) {
      obj.lastHits = Math.round(message.lastHits);
    }
    if (message.denies !== undefined && message.denies !== 0) {
      obj.denies = Math.round(message.denies);
    }
    if (message.bountyRuneGold !== undefined && message.bountyRuneGold !== 0) {
      obj.bountyRuneGold = Math.round(message.bountyRuneGold);
    }
    if (message.rangeCreepUpgradeGold !== undefined && message.rangeCreepUpgradeGold !== 0) {
      obj.rangeCreepUpgradeGold = Math.round(message.rangeCreepUpgradeGold);
    }
    if (message.observerWardsDewarded !== undefined && message.observerWardsDewarded !== 0) {
      obj.observerWardsDewarded = Math.round(message.observerWardsDewarded);
    }
    if (message.reliableGoldEarned !== undefined && message.reliableGoldEarned !== 0) {
      obj.reliableGoldEarned = Math.round(message.reliableGoldEarned);
    }
    if (message.goldLossPrevented !== undefined && message.goldLossPrevented !== 0) {
      obj.goldLossPrevented = Math.round(message.goldLossPrevented);
    }
    if (message.heroKillGold !== undefined && message.heroKillGold !== 0) {
      obj.heroKillGold = Math.round(message.heroKillGold);
    }
    if (message.creepKillGold !== undefined && message.creepKillGold !== 0) {
      obj.creepKillGold = Math.round(message.creepKillGold);
    }
    if (message.buildingGold !== undefined && message.buildingGold !== 0) {
      obj.buildingGold = Math.round(message.buildingGold);
    }
    if (message.otherGold !== undefined && message.otherGold !== 0) {
      obj.otherGold = Math.round(message.otherGold);
    }
    if (message.comebackGold !== undefined && message.comebackGold !== 0) {
      obj.comebackGold = Math.round(message.comebackGold);
    }
    if (message.experimentalGold !== undefined && message.experimentalGold !== 0) {
      obj.experimentalGold = Math.round(message.experimentalGold);
    }
    if (message.experimental2Gold !== undefined && message.experimental2Gold !== 0) {
      obj.experimental2Gold = Math.round(message.experimental2Gold);
    }
    if (message.creepDenyGold !== undefined && message.creepDenyGold !== 0) {
      obj.creepDenyGold = Math.round(message.creepDenyGold);
    }
    if (message.tpScrollsPurchased1 !== undefined && message.tpScrollsPurchased1 !== 0) {
      obj.tpScrollsPurchased1 = Math.round(message.tpScrollsPurchased1);
    }
    if (message.tpScrollsPurchased2 !== undefined && message.tpScrollsPurchased2 !== 0) {
      obj.tpScrollsPurchased2 = Math.round(message.tpScrollsPurchased2);
    }
    if (message.tpScrollsPurchased3 !== undefined && message.tpScrollsPurchased3 !== 0) {
      obj.tpScrollsPurchased3 = Math.round(message.tpScrollsPurchased3);
    }
    if (message.tpScrollsPurchased4 !== undefined && message.tpScrollsPurchased4 !== 0) {
      obj.tpScrollsPurchased4 = Math.round(message.tpScrollsPurchased4);
    }
    if (message.tpScrollsPurchased5 !== undefined && message.tpScrollsPurchased5 !== 0) {
      obj.tpScrollsPurchased5 = Math.round(message.tpScrollsPurchased5);
    }
    if (message.neutralGold !== undefined && message.neutralGold !== 0) {
      obj.neutralGold = Math.round(message.neutralGold);
    }
    if (message.courierGold !== undefined && message.courierGold !== 0) {
      obj.courierGold = Math.round(message.courierGold);
    }
    if (message.roshanGold !== undefined && message.roshanGold !== 0) {
      obj.roshanGold = Math.round(message.roshanGold);
    }
    if (message.incomeGold !== undefined && message.incomeGold !== 0) {
      obj.incomeGold = Math.round(message.incomeGold);
    }
    if (message.itemValue !== undefined && message.itemValue !== 0) {
      obj.itemValue = Math.round(message.itemValue);
    }
    if (message.supportGoldSpent !== undefined && message.supportGoldSpent !== 0) {
      obj.supportGoldSpent = Math.round(message.supportGoldSpent);
    }
    if (message.campsStacked !== undefined && message.campsStacked !== 0) {
      obj.campsStacked = Math.round(message.campsStacked);
    }
    if (message.wardsPlaced !== undefined && message.wardsPlaced !== 0) {
      obj.wardsPlaced = Math.round(message.wardsPlaced);
    }
    if (message.tripleKills !== undefined && message.tripleKills !== 0) {
      obj.tripleKills = Math.round(message.tripleKills);
    }
    if (message.rampages !== undefined && message.rampages !== 0) {
      obj.rampages = Math.round(message.rampages);
    }
    if (message.customStats?.length) {
      obj.customStats = message.customStats.map((e) => CMatchPlayerTimedCustomStat.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMatchPlayerTimedStats>): CMatchPlayerTimedStats {
    return CMatchPlayerTimedStats.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMatchPlayerTimedStats>): CMatchPlayerTimedStats {
    const message = createBaseCMatchPlayerTimedStats();
    message.time = object.time ?? 0;
    message.kills = object.kills ?? 0;
    message.deaths = object.deaths ?? 0;
    message.assists = object.assists ?? 0;
    message.netWorth = object.netWorth ?? 0;
    message.xp = object.xp ?? 0;
    message.lastHits = object.lastHits ?? 0;
    message.denies = object.denies ?? 0;
    message.bountyRuneGold = object.bountyRuneGold ?? 0;
    message.rangeCreepUpgradeGold = object.rangeCreepUpgradeGold ?? 0;
    message.observerWardsDewarded = object.observerWardsDewarded ?? 0;
    message.reliableGoldEarned = object.reliableGoldEarned ?? 0;
    message.goldLossPrevented = object.goldLossPrevented ?? 0;
    message.heroKillGold = object.heroKillGold ?? 0;
    message.creepKillGold = object.creepKillGold ?? 0;
    message.buildingGold = object.buildingGold ?? 0;
    message.otherGold = object.otherGold ?? 0;
    message.comebackGold = object.comebackGold ?? 0;
    message.experimentalGold = object.experimentalGold ?? 0;
    message.experimental2Gold = object.experimental2Gold ?? 0;
    message.creepDenyGold = object.creepDenyGold ?? 0;
    message.tpScrollsPurchased1 = object.tpScrollsPurchased1 ?? 0;
    message.tpScrollsPurchased2 = object.tpScrollsPurchased2 ?? 0;
    message.tpScrollsPurchased3 = object.tpScrollsPurchased3 ?? 0;
    message.tpScrollsPurchased4 = object.tpScrollsPurchased4 ?? 0;
    message.tpScrollsPurchased5 = object.tpScrollsPurchased5 ?? 0;
    message.neutralGold = object.neutralGold ?? 0;
    message.courierGold = object.courierGold ?? 0;
    message.roshanGold = object.roshanGold ?? 0;
    message.incomeGold = object.incomeGold ?? 0;
    message.itemValue = object.itemValue ?? 0;
    message.supportGoldSpent = object.supportGoldSpent ?? 0;
    message.campsStacked = object.campsStacked ?? 0;
    message.wardsPlaced = object.wardsPlaced ?? 0;
    message.tripleKills = object.tripleKills ?? 0;
    message.rampages = object.rampages ?? 0;
    message.customStats = object.customStats?.map((e) => CMatchPlayerTimedCustomStat.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMatchTeamTimedStats(): CMatchTeamTimedStats {
  return { time: 0, enemyTowersKilled: 0, enemyBarracksKilled: 0, enemyTowersStatus: 0, enemyBarracksStatus: 0 };
}

export const CMatchTeamTimedStats = {
  encode(message: CMatchTeamTimedStats, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.time !== undefined && message.time !== 0) {
      writer.uint32(8).uint32(message.time);
    }
    if (message.enemyTowersKilled !== undefined && message.enemyTowersKilled !== 0) {
      writer.uint32(16).uint32(message.enemyTowersKilled);
    }
    if (message.enemyBarracksKilled !== undefined && message.enemyBarracksKilled !== 0) {
      writer.uint32(24).uint32(message.enemyBarracksKilled);
    }
    if (message.enemyTowersStatus !== undefined && message.enemyTowersStatus !== 0) {
      writer.uint32(32).uint32(message.enemyTowersStatus);
    }
    if (message.enemyBarracksStatus !== undefined && message.enemyBarracksStatus !== 0) {
      writer.uint32(40).uint32(message.enemyBarracksStatus);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMatchTeamTimedStats {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMatchTeamTimedStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.time = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.enemyTowersKilled = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.enemyBarracksKilled = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.enemyTowersStatus = reader.uint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.enemyBarracksStatus = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMatchTeamTimedStats {
    return {
      time: isSet(object.time) ? globalThis.Number(object.time) : 0,
      enemyTowersKilled: isSet(object.enemyTowersKilled) ? globalThis.Number(object.enemyTowersKilled) : 0,
      enemyBarracksKilled: isSet(object.enemyBarracksKilled) ? globalThis.Number(object.enemyBarracksKilled) : 0,
      enemyTowersStatus: isSet(object.enemyTowersStatus) ? globalThis.Number(object.enemyTowersStatus) : 0,
      enemyBarracksStatus: isSet(object.enemyBarracksStatus) ? globalThis.Number(object.enemyBarracksStatus) : 0,
    };
  },

  toJSON(message: CMatchTeamTimedStats): unknown {
    const obj: any = {};
    if (message.time !== undefined && message.time !== 0) {
      obj.time = Math.round(message.time);
    }
    if (message.enemyTowersKilled !== undefined && message.enemyTowersKilled !== 0) {
      obj.enemyTowersKilled = Math.round(message.enemyTowersKilled);
    }
    if (message.enemyBarracksKilled !== undefined && message.enemyBarracksKilled !== 0) {
      obj.enemyBarracksKilled = Math.round(message.enemyBarracksKilled);
    }
    if (message.enemyTowersStatus !== undefined && message.enemyTowersStatus !== 0) {
      obj.enemyTowersStatus = Math.round(message.enemyTowersStatus);
    }
    if (message.enemyBarracksStatus !== undefined && message.enemyBarracksStatus !== 0) {
      obj.enemyBarracksStatus = Math.round(message.enemyBarracksStatus);
    }
    return obj;
  },

  create(base?: DeepPartial<CMatchTeamTimedStats>): CMatchTeamTimedStats {
    return CMatchTeamTimedStats.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMatchTeamTimedStats>): CMatchTeamTimedStats {
    const message = createBaseCMatchTeamTimedStats();
    message.time = object.time ?? 0;
    message.enemyTowersKilled = object.enemyTowersKilled ?? 0;
    message.enemyBarracksKilled = object.enemyBarracksKilled ?? 0;
    message.enemyTowersStatus = object.enemyTowersStatus ?? 0;
    message.enemyBarracksStatus = object.enemyBarracksStatus ?? 0;
    return message;
  },
};

function createBaseCMatchAdditionalUnitInventory(): CMatchAdditionalUnitInventory {
  return { unitName: "", items: [] };
}

export const CMatchAdditionalUnitInventory = {
  encode(message: CMatchAdditionalUnitInventory, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.unitName !== undefined && message.unitName !== "") {
      writer.uint32(10).string(message.unitName);
    }
    writer.uint32(18).fork();
    for (const v of message.items) {
      writer.int32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMatchAdditionalUnitInventory {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMatchAdditionalUnitInventory();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.unitName = reader.string();
          continue;
        case 2:
          if (tag === 16) {
            message.items.push(reader.int32());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.items.push(reader.int32());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMatchAdditionalUnitInventory {
    return {
      unitName: isSet(object.unitName) ? globalThis.String(object.unitName) : "",
      items: globalThis.Array.isArray(object?.items) ? object.items.map((e: any) => globalThis.Number(e)) : [],
    };
  },

  toJSON(message: CMatchAdditionalUnitInventory): unknown {
    const obj: any = {};
    if (message.unitName !== undefined && message.unitName !== "") {
      obj.unitName = message.unitName;
    }
    if (message.items?.length) {
      obj.items = message.items.map((e) => Math.round(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMatchAdditionalUnitInventory>): CMatchAdditionalUnitInventory {
    return CMatchAdditionalUnitInventory.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMatchAdditionalUnitInventory>): CMatchAdditionalUnitInventory {
    const message = createBaseCMatchAdditionalUnitInventory();
    message.unitName = object.unitName ?? "";
    message.items = object.items?.map((e) => e) || [];
    return message;
  },
};

function createBaseCMatchPlayerPermanentBuff(): CMatchPlayerPermanentBuff {
  return { permanentBuff: 0, stackCount: 0, grantTime: 0 };
}

export const CMatchPlayerPermanentBuff = {
  encode(message: CMatchPlayerPermanentBuff, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.permanentBuff !== undefined && message.permanentBuff !== 0) {
      writer.uint32(8).uint32(message.permanentBuff);
    }
    if (message.stackCount !== undefined && message.stackCount !== 0) {
      writer.uint32(16).uint32(message.stackCount);
    }
    if (message.grantTime !== undefined && message.grantTime !== 0) {
      writer.uint32(24).uint32(message.grantTime);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMatchPlayerPermanentBuff {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMatchPlayerPermanentBuff();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.permanentBuff = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.stackCount = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.grantTime = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMatchPlayerPermanentBuff {
    return {
      permanentBuff: isSet(object.permanentBuff) ? globalThis.Number(object.permanentBuff) : 0,
      stackCount: isSet(object.stackCount) ? globalThis.Number(object.stackCount) : 0,
      grantTime: isSet(object.grantTime) ? globalThis.Number(object.grantTime) : 0,
    };
  },

  toJSON(message: CMatchPlayerPermanentBuff): unknown {
    const obj: any = {};
    if (message.permanentBuff !== undefined && message.permanentBuff !== 0) {
      obj.permanentBuff = Math.round(message.permanentBuff);
    }
    if (message.stackCount !== undefined && message.stackCount !== 0) {
      obj.stackCount = Math.round(message.stackCount);
    }
    if (message.grantTime !== undefined && message.grantTime !== 0) {
      obj.grantTime = Math.round(message.grantTime);
    }
    return obj;
  },

  create(base?: DeepPartial<CMatchPlayerPermanentBuff>): CMatchPlayerPermanentBuff {
    return CMatchPlayerPermanentBuff.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMatchPlayerPermanentBuff>): CMatchPlayerPermanentBuff {
    const message = createBaseCMatchPlayerPermanentBuff();
    message.permanentBuff = object.permanentBuff ?? 0;
    message.stackCount = object.stackCount ?? 0;
    message.grantTime = object.grantTime ?? 0;
    return message;
  },
};

function createBaseCMatchHeroSelectEvent(): CMatchHeroSelectEvent {
  return { isPick: false, team: 0, heroId: 0 };
}

export const CMatchHeroSelectEvent = {
  encode(message: CMatchHeroSelectEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.isPick !== undefined && message.isPick !== false) {
      writer.uint32(8).bool(message.isPick);
    }
    if (message.team !== undefined && message.team !== 0) {
      writer.uint32(16).uint32(message.team);
    }
    if (message.heroId !== undefined && message.heroId !== 0) {
      writer.uint32(24).int32(message.heroId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMatchHeroSelectEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMatchHeroSelectEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.isPick = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.team = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.heroId = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMatchHeroSelectEvent {
    return {
      isPick: isSet(object.isPick) ? globalThis.Boolean(object.isPick) : false,
      team: isSet(object.team) ? globalThis.Number(object.team) : 0,
      heroId: isSet(object.heroId) ? globalThis.Number(object.heroId) : 0,
    };
  },

  toJSON(message: CMatchHeroSelectEvent): unknown {
    const obj: any = {};
    if (message.isPick !== undefined && message.isPick !== false) {
      obj.isPick = message.isPick;
    }
    if (message.team !== undefined && message.team !== 0) {
      obj.team = Math.round(message.team);
    }
    if (message.heroId !== undefined && message.heroId !== 0) {
      obj.heroId = Math.round(message.heroId);
    }
    return obj;
  },

  create(base?: DeepPartial<CMatchHeroSelectEvent>): CMatchHeroSelectEvent {
    return CMatchHeroSelectEvent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMatchHeroSelectEvent>): CMatchHeroSelectEvent {
    const message = createBaseCMatchHeroSelectEvent();
    message.isPick = object.isPick ?? false;
    message.team = object.team ?? 0;
    message.heroId = object.heroId ?? 0;
    return message;
  },
};

function createBaseCMatchClip(): CMatchClip {
  return {
    matchId: "0",
    playerAccountId: 0,
    gameTimeSeconds: 0,
    durationSeconds: 0,
    playerId: 0,
    heroId: 0,
    abilityId: -1,
    cameraMode: 0,
    comment: "",
  };
}

export const CMatchClip = {
  encode(message: CMatchClip, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.matchId !== undefined && message.matchId !== "0") {
      writer.uint32(8).uint64(message.matchId);
    }
    if (message.playerAccountId !== undefined && message.playerAccountId !== 0) {
      writer.uint32(16).uint32(message.playerAccountId);
    }
    if (message.gameTimeSeconds !== undefined && message.gameTimeSeconds !== 0) {
      writer.uint32(24).uint32(message.gameTimeSeconds);
    }
    if (message.durationSeconds !== undefined && message.durationSeconds !== 0) {
      writer.uint32(32).uint32(message.durationSeconds);
    }
    if (message.playerId !== undefined && message.playerId !== 0) {
      writer.uint32(40).uint32(message.playerId);
    }
    if (message.heroId !== undefined && message.heroId !== 0) {
      writer.uint32(48).int32(message.heroId);
    }
    if (message.abilityId !== undefined && message.abilityId !== -1) {
      writer.uint32(56).int32(message.abilityId);
    }
    if (message.cameraMode !== undefined && message.cameraMode !== 0) {
      writer.uint32(64).uint32(message.cameraMode);
    }
    if (message.comment !== undefined && message.comment !== "") {
      writer.uint32(74).string(message.comment);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMatchClip {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMatchClip();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.matchId = longToString(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.playerAccountId = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.gameTimeSeconds = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.durationSeconds = reader.uint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.playerId = reader.uint32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.heroId = reader.int32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.abilityId = reader.int32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.cameraMode = reader.uint32();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.comment = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMatchClip {
    return {
      matchId: isSet(object.matchId) ? globalThis.String(object.matchId) : "0",
      playerAccountId: isSet(object.playerAccountId) ? globalThis.Number(object.playerAccountId) : 0,
      gameTimeSeconds: isSet(object.gameTimeSeconds) ? globalThis.Number(object.gameTimeSeconds) : 0,
      durationSeconds: isSet(object.durationSeconds) ? globalThis.Number(object.durationSeconds) : 0,
      playerId: isSet(object.playerId) ? globalThis.Number(object.playerId) : 0,
      heroId: isSet(object.heroId) ? globalThis.Number(object.heroId) : 0,
      abilityId: isSet(object.abilityId) ? globalThis.Number(object.abilityId) : -1,
      cameraMode: isSet(object.cameraMode) ? globalThis.Number(object.cameraMode) : 0,
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
    };
  },

  toJSON(message: CMatchClip): unknown {
    const obj: any = {};
    if (message.matchId !== undefined && message.matchId !== "0") {
      obj.matchId = message.matchId;
    }
    if (message.playerAccountId !== undefined && message.playerAccountId !== 0) {
      obj.playerAccountId = Math.round(message.playerAccountId);
    }
    if (message.gameTimeSeconds !== undefined && message.gameTimeSeconds !== 0) {
      obj.gameTimeSeconds = Math.round(message.gameTimeSeconds);
    }
    if (message.durationSeconds !== undefined && message.durationSeconds !== 0) {
      obj.durationSeconds = Math.round(message.durationSeconds);
    }
    if (message.playerId !== undefined && message.playerId !== 0) {
      obj.playerId = Math.round(message.playerId);
    }
    if (message.heroId !== undefined && message.heroId !== 0) {
      obj.heroId = Math.round(message.heroId);
    }
    if (message.abilityId !== undefined && message.abilityId !== -1) {
      obj.abilityId = Math.round(message.abilityId);
    }
    if (message.cameraMode !== undefined && message.cameraMode !== 0) {
      obj.cameraMode = Math.round(message.cameraMode);
    }
    if (message.comment !== undefined && message.comment !== "") {
      obj.comment = message.comment;
    }
    return obj;
  },

  create(base?: DeepPartial<CMatchClip>): CMatchClip {
    return CMatchClip.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMatchClip>): CMatchClip {
    const message = createBaseCMatchClip();
    message.matchId = object.matchId ?? "0";
    message.playerAccountId = object.playerAccountId ?? 0;
    message.gameTimeSeconds = object.gameTimeSeconds ?? 0;
    message.durationSeconds = object.durationSeconds ?? 0;
    message.playerId = object.playerId ?? 0;
    message.heroId = object.heroId ?? 0;
    message.abilityId = object.abilityId ?? -1;
    message.cameraMode = object.cameraMode ?? 0;
    message.comment = object.comment ?? "";
    return message;
  },
};

function createBaseCPartySearchClientParty(): CPartySearchClientParty {
  return { partyId: "0", beaconType: 0, partyMembers: [] };
}

export const CPartySearchClientParty = {
  encode(message: CPartySearchClientParty, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.partyId !== undefined && message.partyId !== "0") {
      writer.uint32(9).fixed64(message.partyId);
    }
    if (message.beaconType !== undefined && message.beaconType !== 0) {
      writer.uint32(16).int32(message.beaconType);
    }
    writer.uint32(26).fork();
    for (const v of message.partyMembers) {
      writer.fixed32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CPartySearchClientParty {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCPartySearchClientParty();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.partyId = longToString(reader.fixed64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.beaconType = reader.int32();
          continue;
        case 3:
          if (tag === 29) {
            message.partyMembers.push(reader.fixed32());

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.partyMembers.push(reader.fixed32());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CPartySearchClientParty {
    return {
      partyId: isSet(object.partyId) ? globalThis.String(object.partyId) : "0",
      beaconType: isSet(object.beaconType) ? globalThis.Number(object.beaconType) : 0,
      partyMembers: globalThis.Array.isArray(object?.partyMembers)
        ? object.partyMembers.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: CPartySearchClientParty): unknown {
    const obj: any = {};
    if (message.partyId !== undefined && message.partyId !== "0") {
      obj.partyId = message.partyId;
    }
    if (message.beaconType !== undefined && message.beaconType !== 0) {
      obj.beaconType = Math.round(message.beaconType);
    }
    if (message.partyMembers?.length) {
      obj.partyMembers = message.partyMembers.map((e) => Math.round(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CPartySearchClientParty>): CPartySearchClientParty {
    return CPartySearchClientParty.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CPartySearchClientParty>): CPartySearchClientParty {
    const message = createBaseCPartySearchClientParty();
    message.partyId = object.partyId ?? "0";
    message.beaconType = object.beaconType ?? 0;
    message.partyMembers = object.partyMembers?.map((e) => e) || [];
    return message;
  },
};

function createBaseCMsgDOTAHasItemQuery(): CMsgDOTAHasItemQuery {
  return { accountId: 0, itemId: "0" };
}

export const CMsgDOTAHasItemQuery = {
  encode(message: CMsgDOTAHasItemQuery, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.accountId !== undefined && message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    if (message.itemId !== undefined && message.itemId !== "0") {
      writer.uint32(16).uint64(message.itemId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTAHasItemQuery {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAHasItemQuery();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.itemId = longToString(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAHasItemQuery {
    return {
      accountId: isSet(object.accountId) ? globalThis.Number(object.accountId) : 0,
      itemId: isSet(object.itemId) ? globalThis.String(object.itemId) : "0",
    };
  },

  toJSON(message: CMsgDOTAHasItemQuery): unknown {
    const obj: any = {};
    if (message.accountId !== undefined && message.accountId !== 0) {
      obj.accountId = Math.round(message.accountId);
    }
    if (message.itemId !== undefined && message.itemId !== "0") {
      obj.itemId = message.itemId;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTAHasItemQuery>): CMsgDOTAHasItemQuery {
    return CMsgDOTAHasItemQuery.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTAHasItemQuery>): CMsgDOTAHasItemQuery {
    const message = createBaseCMsgDOTAHasItemQuery();
    message.accountId = object.accountId ?? 0;
    message.itemId = object.itemId ?? "0";
    return message;
  },
};

function createBaseCMsgDOTAHasItemResponse(): CMsgDOTAHasItemResponse {
  return { hasItem: false };
}

export const CMsgDOTAHasItemResponse = {
  encode(message: CMsgDOTAHasItemResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.hasItem !== undefined && message.hasItem !== false) {
      writer.uint32(8).bool(message.hasItem);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTAHasItemResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAHasItemResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.hasItem = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAHasItemResponse {
    return { hasItem: isSet(object.hasItem) ? globalThis.Boolean(object.hasItem) : false };
  },

  toJSON(message: CMsgDOTAHasItemResponse): unknown {
    const obj: any = {};
    if (message.hasItem !== undefined && message.hasItem !== false) {
      obj.hasItem = message.hasItem;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTAHasItemResponse>): CMsgDOTAHasItemResponse {
    return CMsgDOTAHasItemResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTAHasItemResponse>): CMsgDOTAHasItemResponse {
    const message = createBaseCMsgDOTAHasItemResponse();
    message.hasItem = object.hasItem ?? false;
    return message;
  },
};

function createBaseCMsgGCGetPlayerCardItemInfo(): CMsgGCGetPlayerCardItemInfo {
  return { accountId: 0, playerCardItemIds: [], allForEvent: 0 };
}

export const CMsgGCGetPlayerCardItemInfo = {
  encode(message: CMsgGCGetPlayerCardItemInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.accountId !== undefined && message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    writer.uint32(18).fork();
    for (const v of message.playerCardItemIds) {
      writer.uint64(v);
    }
    writer.ldelim();
    if (message.allForEvent !== undefined && message.allForEvent !== 0) {
      writer.uint32(24).uint32(message.allForEvent);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCGetPlayerCardItemInfo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCGetPlayerCardItemInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        case 2:
          if (tag === 16) {
            message.playerCardItemIds.push(longToString(reader.uint64() as Long));

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.playerCardItemIds.push(longToString(reader.uint64() as Long));
            }

            continue;
          }

          break;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.allForEvent = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCGetPlayerCardItemInfo {
    return {
      accountId: isSet(object.accountId) ? globalThis.Number(object.accountId) : 0,
      playerCardItemIds: globalThis.Array.isArray(object?.playerCardItemIds)
        ? object.playerCardItemIds.map((e: any) => globalThis.String(e))
        : [],
      allForEvent: isSet(object.allForEvent) ? globalThis.Number(object.allForEvent) : 0,
    };
  },

  toJSON(message: CMsgGCGetPlayerCardItemInfo): unknown {
    const obj: any = {};
    if (message.accountId !== undefined && message.accountId !== 0) {
      obj.accountId = Math.round(message.accountId);
    }
    if (message.playerCardItemIds?.length) {
      obj.playerCardItemIds = message.playerCardItemIds;
    }
    if (message.allForEvent !== undefined && message.allForEvent !== 0) {
      obj.allForEvent = Math.round(message.allForEvent);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCGetPlayerCardItemInfo>): CMsgGCGetPlayerCardItemInfo {
    return CMsgGCGetPlayerCardItemInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCGetPlayerCardItemInfo>): CMsgGCGetPlayerCardItemInfo {
    const message = createBaseCMsgGCGetPlayerCardItemInfo();
    message.accountId = object.accountId ?? 0;
    message.playerCardItemIds = object.playerCardItemIds?.map((e) => e) || [];
    message.allForEvent = object.allForEvent ?? 0;
    return message;
  },
};

function createBaseCMsgGCGetPlayerCardItemInfoResponse(): CMsgGCGetPlayerCardItemInfoResponse {
  return { playerCardInfos: [] };
}

export const CMsgGCGetPlayerCardItemInfoResponse = {
  encode(message: CMsgGCGetPlayerCardItemInfoResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.playerCardInfos) {
      CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCGetPlayerCardItemInfoResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCGetPlayerCardItemInfoResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.playerCardInfos.push(
            CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo.decode(reader, reader.uint32()),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCGetPlayerCardItemInfoResponse {
    return {
      playerCardInfos: globalThis.Array.isArray(object?.playerCardInfos)
        ? object.playerCardInfos.map((e: any) => CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgGCGetPlayerCardItemInfoResponse): unknown {
    const obj: any = {};
    if (message.playerCardInfos?.length) {
      obj.playerCardInfos = message.playerCardInfos.map((e) =>
        CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo.toJSON(e)
      );
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCGetPlayerCardItemInfoResponse>): CMsgGCGetPlayerCardItemInfoResponse {
    return CMsgGCGetPlayerCardItemInfoResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCGetPlayerCardItemInfoResponse>): CMsgGCGetPlayerCardItemInfoResponse {
    const message = createBaseCMsgGCGetPlayerCardItemInfoResponse();
    message.playerCardInfos =
      object.playerCardInfos?.map((e) => CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo(): CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo {
  return { playerCardItemId: "0", accountId: 0, packedBonuses: "0" };
}

export const CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo = {
  encode(
    message: CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.playerCardItemId !== undefined && message.playerCardItemId !== "0") {
      writer.uint32(8).uint64(message.playerCardItemId);
    }
    if (message.accountId !== undefined && message.accountId !== 0) {
      writer.uint32(16).uint32(message.accountId);
    }
    if (message.packedBonuses !== undefined && message.packedBonuses !== "0") {
      writer.uint32(24).uint64(message.packedBonuses);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.playerCardItemId = longToString(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.packedBonuses = longToString(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo {
    return {
      playerCardItemId: isSet(object.playerCardItemId) ? globalThis.String(object.playerCardItemId) : "0",
      accountId: isSet(object.accountId) ? globalThis.Number(object.accountId) : 0,
      packedBonuses: isSet(object.packedBonuses) ? globalThis.String(object.packedBonuses) : "0",
    };
  },

  toJSON(message: CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo): unknown {
    const obj: any = {};
    if (message.playerCardItemId !== undefined && message.playerCardItemId !== "0") {
      obj.playerCardItemId = message.playerCardItemId;
    }
    if (message.accountId !== undefined && message.accountId !== 0) {
      obj.accountId = Math.round(message.accountId);
    }
    if (message.packedBonuses !== undefined && message.packedBonuses !== "0") {
      obj.packedBonuses = message.packedBonuses;
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo>,
  ): CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo {
    return CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo>,
  ): CMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo {
    const message = createBaseCMsgGCGetPlayerCardItemInfoResponse_PlayerCardInfo();
    message.playerCardItemId = object.playerCardItemId ?? "0";
    message.accountId = object.accountId ?? 0;
    message.packedBonuses = object.packedBonuses ?? "0";
    return message;
  },
};

function createBaseCSODOTAMapLocationState(): CSODOTAMapLocationState {
  return { accountId: 0, locationId: 0, completed: false };
}

export const CSODOTAMapLocationState = {
  encode(message: CSODOTAMapLocationState, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.accountId !== undefined && message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    if (message.locationId !== undefined && message.locationId !== 0) {
      writer.uint32(16).int32(message.locationId);
    }
    if (message.completed !== undefined && message.completed !== false) {
      writer.uint32(24).bool(message.completed);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CSODOTAMapLocationState {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCSODOTAMapLocationState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.locationId = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.completed = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CSODOTAMapLocationState {
    return {
      accountId: isSet(object.accountId) ? globalThis.Number(object.accountId) : 0,
      locationId: isSet(object.locationId) ? globalThis.Number(object.locationId) : 0,
      completed: isSet(object.completed) ? globalThis.Boolean(object.completed) : false,
    };
  },

  toJSON(message: CSODOTAMapLocationState): unknown {
    const obj: any = {};
    if (message.accountId !== undefined && message.accountId !== 0) {
      obj.accountId = Math.round(message.accountId);
    }
    if (message.locationId !== undefined && message.locationId !== 0) {
      obj.locationId = Math.round(message.locationId);
    }
    if (message.completed !== undefined && message.completed !== false) {
      obj.completed = message.completed;
    }
    return obj;
  },

  create(base?: DeepPartial<CSODOTAMapLocationState>): CSODOTAMapLocationState {
    return CSODOTAMapLocationState.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CSODOTAMapLocationState>): CSODOTAMapLocationState {
    const message = createBaseCSODOTAMapLocationState();
    message.accountId = object.accountId ?? 0;
    message.locationId = object.locationId ?? 0;
    message.completed = object.completed ?? false;
    return message;
  },
};

function createBaseCMsgLeagueAdminList(): CMsgLeagueAdminList {
  return { accountIds: [] };
}

export const CMsgLeagueAdminList = {
  encode(message: CMsgLeagueAdminList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.accountIds) {
      writer.uint32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgLeagueAdminList {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgLeagueAdminList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.accountIds.push(reader.uint32());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.accountIds.push(reader.uint32());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgLeagueAdminList {
    return {
      accountIds: globalThis.Array.isArray(object?.accountIds)
        ? object.accountIds.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: CMsgLeagueAdminList): unknown {
    const obj: any = {};
    if (message.accountIds?.length) {
      obj.accountIds = message.accountIds.map((e) => Math.round(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgLeagueAdminList>): CMsgLeagueAdminList {
    return CMsgLeagueAdminList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgLeagueAdminList>): CMsgLeagueAdminList {
    const message = createBaseCMsgLeagueAdminList();
    message.accountIds = object.accountIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseCMsgDOTAProfileCard(): CMsgDOTAProfileCard {
  return {
    accountId: 0,
    slots: [],
    badgePoints: 0,
    eventId: 0,
    recentBattleCupVictory: undefined,
    rankTier: 0,
    leaderboardRank: 0,
    isPlusSubscriber: false,
    plusOriginalStartDate: 0,
    rankTierScore: 0,
    leaderboardRankCore: 0,
    title: 0,
    favoriteTeamPacked: "0",
    lifetimeGames: 0,
    eventLevel: 0,
  };
}

export const CMsgDOTAProfileCard = {
  encode(message: CMsgDOTAProfileCard, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.accountId !== undefined && message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    for (const v of message.slots) {
      CMsgDOTAProfileCard_Slot.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    if (message.badgePoints !== undefined && message.badgePoints !== 0) {
      writer.uint32(32).uint32(message.badgePoints);
    }
    if (message.eventId !== undefined && message.eventId !== 0) {
      writer.uint32(48).uint32(message.eventId);
    }
    if (message.recentBattleCupVictory !== undefined) {
      CMsgBattleCupVictory.encode(message.recentBattleCupVictory, writer.uint32(58).fork()).ldelim();
    }
    if (message.rankTier !== undefined && message.rankTier !== 0) {
      writer.uint32(64).uint32(message.rankTier);
    }
    if (message.leaderboardRank !== undefined && message.leaderboardRank !== 0) {
      writer.uint32(72).uint32(message.leaderboardRank);
    }
    if (message.isPlusSubscriber !== undefined && message.isPlusSubscriber !== false) {
      writer.uint32(80).bool(message.isPlusSubscriber);
    }
    if (message.plusOriginalStartDate !== undefined && message.plusOriginalStartDate !== 0) {
      writer.uint32(88).uint32(message.plusOriginalStartDate);
    }
    if (message.rankTierScore !== undefined && message.rankTierScore !== 0) {
      writer.uint32(96).uint32(message.rankTierScore);
    }
    if (message.leaderboardRankCore !== undefined && message.leaderboardRankCore !== 0) {
      writer.uint32(136).uint32(message.leaderboardRankCore);
    }
    if (message.title !== undefined && message.title !== 0) {
      writer.uint32(184).uint32(message.title);
    }
    if (message.favoriteTeamPacked !== undefined && message.favoriteTeamPacked !== "0") {
      writer.uint32(192).uint64(message.favoriteTeamPacked);
    }
    if (message.lifetimeGames !== undefined && message.lifetimeGames !== 0) {
      writer.uint32(200).uint32(message.lifetimeGames);
    }
    if (message.eventLevel !== undefined && message.eventLevel !== 0) {
      writer.uint32(208).uint32(message.eventLevel);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTAProfileCard {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAProfileCard();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.slots.push(CMsgDOTAProfileCard_Slot.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.badgePoints = reader.uint32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.eventId = reader.uint32();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.recentBattleCupVictory = CMsgBattleCupVictory.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.rankTier = reader.uint32();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.leaderboardRank = reader.uint32();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.isPlusSubscriber = reader.bool();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.plusOriginalStartDate = reader.uint32();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.rankTierScore = reader.uint32();
          continue;
        case 17:
          if (tag !== 136) {
            break;
          }

          message.leaderboardRankCore = reader.uint32();
          continue;
        case 23:
          if (tag !== 184) {
            break;
          }

          message.title = reader.uint32();
          continue;
        case 24:
          if (tag !== 192) {
            break;
          }

          message.favoriteTeamPacked = longToString(reader.uint64() as Long);
          continue;
        case 25:
          if (tag !== 200) {
            break;
          }

          message.lifetimeGames = reader.uint32();
          continue;
        case 26:
          if (tag !== 208) {
            break;
          }

          message.eventLevel = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAProfileCard {
    return {
      accountId: isSet(object.accountId) ? globalThis.Number(object.accountId) : 0,
      slots: globalThis.Array.isArray(object?.slots)
        ? object.slots.map((e: any) => CMsgDOTAProfileCard_Slot.fromJSON(e))
        : [],
      badgePoints: isSet(object.badgePoints) ? globalThis.Number(object.badgePoints) : 0,
      eventId: isSet(object.eventId) ? globalThis.Number(object.eventId) : 0,
      recentBattleCupVictory: isSet(object.recentBattleCupVictory)
        ? CMsgBattleCupVictory.fromJSON(object.recentBattleCupVictory)
        : undefined,
      rankTier: isSet(object.rankTier) ? globalThis.Number(object.rankTier) : 0,
      leaderboardRank: isSet(object.leaderboardRank) ? globalThis.Number(object.leaderboardRank) : 0,
      isPlusSubscriber: isSet(object.isPlusSubscriber) ? globalThis.Boolean(object.isPlusSubscriber) : false,
      plusOriginalStartDate: isSet(object.plusOriginalStartDate) ? globalThis.Number(object.plusOriginalStartDate) : 0,
      rankTierScore: isSet(object.rankTierScore) ? globalThis.Number(object.rankTierScore) : 0,
      leaderboardRankCore: isSet(object.leaderboardRankCore) ? globalThis.Number(object.leaderboardRankCore) : 0,
      title: isSet(object.title) ? globalThis.Number(object.title) : 0,
      favoriteTeamPacked: isSet(object.favoriteTeamPacked) ? globalThis.String(object.favoriteTeamPacked) : "0",
      lifetimeGames: isSet(object.lifetimeGames) ? globalThis.Number(object.lifetimeGames) : 0,
      eventLevel: isSet(object.eventLevel) ? globalThis.Number(object.eventLevel) : 0,
    };
  },

  toJSON(message: CMsgDOTAProfileCard): unknown {
    const obj: any = {};
    if (message.accountId !== undefined && message.accountId !== 0) {
      obj.accountId = Math.round(message.accountId);
    }
    if (message.slots?.length) {
      obj.slots = message.slots.map((e) => CMsgDOTAProfileCard_Slot.toJSON(e));
    }
    if (message.badgePoints !== undefined && message.badgePoints !== 0) {
      obj.badgePoints = Math.round(message.badgePoints);
    }
    if (message.eventId !== undefined && message.eventId !== 0) {
      obj.eventId = Math.round(message.eventId);
    }
    if (message.recentBattleCupVictory !== undefined) {
      obj.recentBattleCupVictory = CMsgBattleCupVictory.toJSON(message.recentBattleCupVictory);
    }
    if (message.rankTier !== undefined && message.rankTier !== 0) {
      obj.rankTier = Math.round(message.rankTier);
    }
    if (message.leaderboardRank !== undefined && message.leaderboardRank !== 0) {
      obj.leaderboardRank = Math.round(message.leaderboardRank);
    }
    if (message.isPlusSubscriber !== undefined && message.isPlusSubscriber !== false) {
      obj.isPlusSubscriber = message.isPlusSubscriber;
    }
    if (message.plusOriginalStartDate !== undefined && message.plusOriginalStartDate !== 0) {
      obj.plusOriginalStartDate = Math.round(message.plusOriginalStartDate);
    }
    if (message.rankTierScore !== undefined && message.rankTierScore !== 0) {
      obj.rankTierScore = Math.round(message.rankTierScore);
    }
    if (message.leaderboardRankCore !== undefined && message.leaderboardRankCore !== 0) {
      obj.leaderboardRankCore = Math.round(message.leaderboardRankCore);
    }
    if (message.title !== undefined && message.title !== 0) {
      obj.title = Math.round(message.title);
    }
    if (message.favoriteTeamPacked !== undefined && message.favoriteTeamPacked !== "0") {
      obj.favoriteTeamPacked = message.favoriteTeamPacked;
    }
    if (message.lifetimeGames !== undefined && message.lifetimeGames !== 0) {
      obj.lifetimeGames = Math.round(message.lifetimeGames);
    }
    if (message.eventLevel !== undefined && message.eventLevel !== 0) {
      obj.eventLevel = Math.round(message.eventLevel);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTAProfileCard>): CMsgDOTAProfileCard {
    return CMsgDOTAProfileCard.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTAProfileCard>): CMsgDOTAProfileCard {
    const message = createBaseCMsgDOTAProfileCard();
    message.accountId = object.accountId ?? 0;
    message.slots = object.slots?.map((e) => CMsgDOTAProfileCard_Slot.fromPartial(e)) || [];
    message.badgePoints = object.badgePoints ?? 0;
    message.eventId = object.eventId ?? 0;
    message.recentBattleCupVictory =
      (object.recentBattleCupVictory !== undefined && object.recentBattleCupVictory !== null)
        ? CMsgBattleCupVictory.fromPartial(object.recentBattleCupVictory)
        : undefined;
    message.rankTier = object.rankTier ?? 0;
    message.leaderboardRank = object.leaderboardRank ?? 0;
    message.isPlusSubscriber = object.isPlusSubscriber ?? false;
    message.plusOriginalStartDate = object.plusOriginalStartDate ?? 0;
    message.rankTierScore = object.rankTierScore ?? 0;
    message.leaderboardRankCore = object.leaderboardRankCore ?? 0;
    message.title = object.title ?? 0;
    message.favoriteTeamPacked = object.favoriteTeamPacked ?? "0";
    message.lifetimeGames = object.lifetimeGames ?? 0;
    message.eventLevel = object.eventLevel ?? 0;
    return message;
  },
};

function createBaseCMsgDOTAProfileCard_Slot(): CMsgDOTAProfileCard_Slot {
  return {
    slotId: 0,
    trophy: undefined,
    stat: undefined,
    item: undefined,
    hero: undefined,
    emoticon: undefined,
    team: undefined,
  };
}

export const CMsgDOTAProfileCard_Slot = {
  encode(message: CMsgDOTAProfileCard_Slot, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.slotId !== undefined && message.slotId !== 0) {
      writer.uint32(8).uint32(message.slotId);
    }
    if (message.trophy !== undefined) {
      CMsgDOTAProfileCard_Slot_Trophy.encode(message.trophy, writer.uint32(18).fork()).ldelim();
    }
    if (message.stat !== undefined) {
      CMsgDOTAProfileCard_Slot_Stat.encode(message.stat, writer.uint32(26).fork()).ldelim();
    }
    if (message.item !== undefined) {
      CMsgDOTAProfileCard_Slot_Item.encode(message.item, writer.uint32(34).fork()).ldelim();
    }
    if (message.hero !== undefined) {
      CMsgDOTAProfileCard_Slot_Hero.encode(message.hero, writer.uint32(42).fork()).ldelim();
    }
    if (message.emoticon !== undefined) {
      CMsgDOTAProfileCard_Slot_Emoticon.encode(message.emoticon, writer.uint32(50).fork()).ldelim();
    }
    if (message.team !== undefined) {
      CMsgDOTAProfileCard_Slot_Team.encode(message.team, writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTAProfileCard_Slot {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAProfileCard_Slot();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.slotId = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.trophy = CMsgDOTAProfileCard_Slot_Trophy.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.stat = CMsgDOTAProfileCard_Slot_Stat.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.item = CMsgDOTAProfileCard_Slot_Item.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.hero = CMsgDOTAProfileCard_Slot_Hero.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.emoticon = CMsgDOTAProfileCard_Slot_Emoticon.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.team = CMsgDOTAProfileCard_Slot_Team.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAProfileCard_Slot {
    return {
      slotId: isSet(object.slotId) ? globalThis.Number(object.slotId) : 0,
      trophy: isSet(object.trophy) ? CMsgDOTAProfileCard_Slot_Trophy.fromJSON(object.trophy) : undefined,
      stat: isSet(object.stat) ? CMsgDOTAProfileCard_Slot_Stat.fromJSON(object.stat) : undefined,
      item: isSet(object.item) ? CMsgDOTAProfileCard_Slot_Item.fromJSON(object.item) : undefined,
      hero: isSet(object.hero) ? CMsgDOTAProfileCard_Slot_Hero.fromJSON(object.hero) : undefined,
      emoticon: isSet(object.emoticon) ? CMsgDOTAProfileCard_Slot_Emoticon.fromJSON(object.emoticon) : undefined,
      team: isSet(object.team) ? CMsgDOTAProfileCard_Slot_Team.fromJSON(object.team) : undefined,
    };
  },

  toJSON(message: CMsgDOTAProfileCard_Slot): unknown {
    const obj: any = {};
    if (message.slotId !== undefined && message.slotId !== 0) {
      obj.slotId = Math.round(message.slotId);
    }
    if (message.trophy !== undefined) {
      obj.trophy = CMsgDOTAProfileCard_Slot_Trophy.toJSON(message.trophy);
    }
    if (message.stat !== undefined) {
      obj.stat = CMsgDOTAProfileCard_Slot_Stat.toJSON(message.stat);
    }
    if (message.item !== undefined) {
      obj.item = CMsgDOTAProfileCard_Slot_Item.toJSON(message.item);
    }
    if (message.hero !== undefined) {
      obj.hero = CMsgDOTAProfileCard_Slot_Hero.toJSON(message.hero);
    }
    if (message.emoticon !== undefined) {
      obj.emoticon = CMsgDOTAProfileCard_Slot_Emoticon.toJSON(message.emoticon);
    }
    if (message.team !== undefined) {
      obj.team = CMsgDOTAProfileCard_Slot_Team.toJSON(message.team);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTAProfileCard_Slot>): CMsgDOTAProfileCard_Slot {
    return CMsgDOTAProfileCard_Slot.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTAProfileCard_Slot>): CMsgDOTAProfileCard_Slot {
    const message = createBaseCMsgDOTAProfileCard_Slot();
    message.slotId = object.slotId ?? 0;
    message.trophy = (object.trophy !== undefined && object.trophy !== null)
      ? CMsgDOTAProfileCard_Slot_Trophy.fromPartial(object.trophy)
      : undefined;
    message.stat = (object.stat !== undefined && object.stat !== null)
      ? CMsgDOTAProfileCard_Slot_Stat.fromPartial(object.stat)
      : undefined;
    message.item = (object.item !== undefined && object.item !== null)
      ? CMsgDOTAProfileCard_Slot_Item.fromPartial(object.item)
      : undefined;
    message.hero = (object.hero !== undefined && object.hero !== null)
      ? CMsgDOTAProfileCard_Slot_Hero.fromPartial(object.hero)
      : undefined;
    message.emoticon = (object.emoticon !== undefined && object.emoticon !== null)
      ? CMsgDOTAProfileCard_Slot_Emoticon.fromPartial(object.emoticon)
      : undefined;
    message.team = (object.team !== undefined && object.team !== null)
      ? CMsgDOTAProfileCard_Slot_Team.fromPartial(object.team)
      : undefined;
    return message;
  },
};

function createBaseCMsgDOTAProfileCard_Slot_Trophy(): CMsgDOTAProfileCard_Slot_Trophy {
  return { trophyId: 0, trophyScore: 0 };
}

export const CMsgDOTAProfileCard_Slot_Trophy = {
  encode(message: CMsgDOTAProfileCard_Slot_Trophy, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.trophyId !== undefined && message.trophyId !== 0) {
      writer.uint32(8).uint32(message.trophyId);
    }
    if (message.trophyScore !== undefined && message.trophyScore !== 0) {
      writer.uint32(16).uint32(message.trophyScore);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTAProfileCard_Slot_Trophy {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAProfileCard_Slot_Trophy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.trophyId = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.trophyScore = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAProfileCard_Slot_Trophy {
    return {
      trophyId: isSet(object.trophyId) ? globalThis.Number(object.trophyId) : 0,
      trophyScore: isSet(object.trophyScore) ? globalThis.Number(object.trophyScore) : 0,
    };
  },

  toJSON(message: CMsgDOTAProfileCard_Slot_Trophy): unknown {
    const obj: any = {};
    if (message.trophyId !== undefined && message.trophyId !== 0) {
      obj.trophyId = Math.round(message.trophyId);
    }
    if (message.trophyScore !== undefined && message.trophyScore !== 0) {
      obj.trophyScore = Math.round(message.trophyScore);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTAProfileCard_Slot_Trophy>): CMsgDOTAProfileCard_Slot_Trophy {
    return CMsgDOTAProfileCard_Slot_Trophy.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTAProfileCard_Slot_Trophy>): CMsgDOTAProfileCard_Slot_Trophy {
    const message = createBaseCMsgDOTAProfileCard_Slot_Trophy();
    message.trophyId = object.trophyId ?? 0;
    message.trophyScore = object.trophyScore ?? 0;
    return message;
  },
};

function createBaseCMsgDOTAProfileCard_Slot_Stat(): CMsgDOTAProfileCard_Slot_Stat {
  return { statId: 3, statScore: 0 };
}

export const CMsgDOTAProfileCard_Slot_Stat = {
  encode(message: CMsgDOTAProfileCard_Slot_Stat, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.statId !== undefined && message.statId !== 3) {
      writer.uint32(8).int32(message.statId);
    }
    if (message.statScore !== undefined && message.statScore !== 0) {
      writer.uint32(16).uint32(message.statScore);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTAProfileCard_Slot_Stat {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAProfileCard_Slot_Stat();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.statId = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.statScore = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAProfileCard_Slot_Stat {
    return {
      statId: isSet(object.statId) ? cMsgDOTAProfileCard_EStatIDFromJSON(object.statId) : 3,
      statScore: isSet(object.statScore) ? globalThis.Number(object.statScore) : 0,
    };
  },

  toJSON(message: CMsgDOTAProfileCard_Slot_Stat): unknown {
    const obj: any = {};
    if (message.statId !== undefined && message.statId !== 3) {
      obj.statId = cMsgDOTAProfileCard_EStatIDToJSON(message.statId);
    }
    if (message.statScore !== undefined && message.statScore !== 0) {
      obj.statScore = Math.round(message.statScore);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTAProfileCard_Slot_Stat>): CMsgDOTAProfileCard_Slot_Stat {
    return CMsgDOTAProfileCard_Slot_Stat.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTAProfileCard_Slot_Stat>): CMsgDOTAProfileCard_Slot_Stat {
    const message = createBaseCMsgDOTAProfileCard_Slot_Stat();
    message.statId = object.statId ?? 3;
    message.statScore = object.statScore ?? 0;
    return message;
  },
};

function createBaseCMsgDOTAProfileCard_Slot_Item(): CMsgDOTAProfileCard_Slot_Item {
  return { serializedItem: Buffer.alloc(0), itemId: "0" };
}

export const CMsgDOTAProfileCard_Slot_Item = {
  encode(message: CMsgDOTAProfileCard_Slot_Item, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.serializedItem !== undefined && message.serializedItem.length !== 0) {
      writer.uint32(10).bytes(message.serializedItem);
    }
    if (message.itemId !== undefined && message.itemId !== "0") {
      writer.uint32(16).uint64(message.itemId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTAProfileCard_Slot_Item {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAProfileCard_Slot_Item();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.serializedItem = reader.bytes() as Buffer;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.itemId = longToString(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAProfileCard_Slot_Item {
    return {
      serializedItem: isSet(object.serializedItem)
        ? Buffer.from(bytesFromBase64(object.serializedItem))
        : Buffer.alloc(0),
      itemId: isSet(object.itemId) ? globalThis.String(object.itemId) : "0",
    };
  },

  toJSON(message: CMsgDOTAProfileCard_Slot_Item): unknown {
    const obj: any = {};
    if (message.serializedItem !== undefined && message.serializedItem.length !== 0) {
      obj.serializedItem = base64FromBytes(message.serializedItem);
    }
    if (message.itemId !== undefined && message.itemId !== "0") {
      obj.itemId = message.itemId;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTAProfileCard_Slot_Item>): CMsgDOTAProfileCard_Slot_Item {
    return CMsgDOTAProfileCard_Slot_Item.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTAProfileCard_Slot_Item>): CMsgDOTAProfileCard_Slot_Item {
    const message = createBaseCMsgDOTAProfileCard_Slot_Item();
    message.serializedItem = object.serializedItem ?? Buffer.alloc(0);
    message.itemId = object.itemId ?? "0";
    return message;
  },
};

function createBaseCMsgDOTAProfileCard_Slot_Hero(): CMsgDOTAProfileCard_Slot_Hero {
  return { heroId: 0, heroWins: 0, heroLosses: 0 };
}

export const CMsgDOTAProfileCard_Slot_Hero = {
  encode(message: CMsgDOTAProfileCard_Slot_Hero, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.heroId !== undefined && message.heroId !== 0) {
      writer.uint32(8).int32(message.heroId);
    }
    if (message.heroWins !== undefined && message.heroWins !== 0) {
      writer.uint32(16).uint32(message.heroWins);
    }
    if (message.heroLosses !== undefined && message.heroLosses !== 0) {
      writer.uint32(24).uint32(message.heroLosses);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTAProfileCard_Slot_Hero {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAProfileCard_Slot_Hero();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.heroId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.heroWins = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.heroLosses = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAProfileCard_Slot_Hero {
    return {
      heroId: isSet(object.heroId) ? globalThis.Number(object.heroId) : 0,
      heroWins: isSet(object.heroWins) ? globalThis.Number(object.heroWins) : 0,
      heroLosses: isSet(object.heroLosses) ? globalThis.Number(object.heroLosses) : 0,
    };
  },

  toJSON(message: CMsgDOTAProfileCard_Slot_Hero): unknown {
    const obj: any = {};
    if (message.heroId !== undefined && message.heroId !== 0) {
      obj.heroId = Math.round(message.heroId);
    }
    if (message.heroWins !== undefined && message.heroWins !== 0) {
      obj.heroWins = Math.round(message.heroWins);
    }
    if (message.heroLosses !== undefined && message.heroLosses !== 0) {
      obj.heroLosses = Math.round(message.heroLosses);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTAProfileCard_Slot_Hero>): CMsgDOTAProfileCard_Slot_Hero {
    return CMsgDOTAProfileCard_Slot_Hero.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTAProfileCard_Slot_Hero>): CMsgDOTAProfileCard_Slot_Hero {
    const message = createBaseCMsgDOTAProfileCard_Slot_Hero();
    message.heroId = object.heroId ?? 0;
    message.heroWins = object.heroWins ?? 0;
    message.heroLosses = object.heroLosses ?? 0;
    return message;
  },
};

function createBaseCMsgDOTAProfileCard_Slot_Emoticon(): CMsgDOTAProfileCard_Slot_Emoticon {
  return { emoticonId: 0 };
}

export const CMsgDOTAProfileCard_Slot_Emoticon = {
  encode(message: CMsgDOTAProfileCard_Slot_Emoticon, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.emoticonId !== undefined && message.emoticonId !== 0) {
      writer.uint32(8).uint32(message.emoticonId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTAProfileCard_Slot_Emoticon {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAProfileCard_Slot_Emoticon();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.emoticonId = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAProfileCard_Slot_Emoticon {
    return { emoticonId: isSet(object.emoticonId) ? globalThis.Number(object.emoticonId) : 0 };
  },

  toJSON(message: CMsgDOTAProfileCard_Slot_Emoticon): unknown {
    const obj: any = {};
    if (message.emoticonId !== undefined && message.emoticonId !== 0) {
      obj.emoticonId = Math.round(message.emoticonId);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTAProfileCard_Slot_Emoticon>): CMsgDOTAProfileCard_Slot_Emoticon {
    return CMsgDOTAProfileCard_Slot_Emoticon.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTAProfileCard_Slot_Emoticon>): CMsgDOTAProfileCard_Slot_Emoticon {
    const message = createBaseCMsgDOTAProfileCard_Slot_Emoticon();
    message.emoticonId = object.emoticonId ?? 0;
    return message;
  },
};

function createBaseCMsgDOTAProfileCard_Slot_Team(): CMsgDOTAProfileCard_Slot_Team {
  return { teamId: 0 };
}

export const CMsgDOTAProfileCard_Slot_Team = {
  encode(message: CMsgDOTAProfileCard_Slot_Team, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.teamId !== undefined && message.teamId !== 0) {
      writer.uint32(8).uint32(message.teamId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTAProfileCard_Slot_Team {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAProfileCard_Slot_Team();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.teamId = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAProfileCard_Slot_Team {
    return { teamId: isSet(object.teamId) ? globalThis.Number(object.teamId) : 0 };
  },

  toJSON(message: CMsgDOTAProfileCard_Slot_Team): unknown {
    const obj: any = {};
    if (message.teamId !== undefined && message.teamId !== 0) {
      obj.teamId = Math.round(message.teamId);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTAProfileCard_Slot_Team>): CMsgDOTAProfileCard_Slot_Team {
    return CMsgDOTAProfileCard_Slot_Team.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTAProfileCard_Slot_Team>): CMsgDOTAProfileCard_Slot_Team {
    const message = createBaseCMsgDOTAProfileCard_Slot_Team();
    message.teamId = object.teamId ?? 0;
    return message;
  },
};

function createBaseCSODOTAPlayerChallenge(): CSODOTAPlayerChallenge {
  return {
    accountId: 0,
    eventId: 0,
    slotId: 0,
    intParam0: 0,
    intParam1: 0,
    createdTime: 0,
    completed: 0,
    sequenceId: 0,
    challengeTier: 0,
    flags: 0,
    attempts: 0,
    completeLimit: 0,
    questRank: 0,
    maxQuestRank: 0,
    instanceId: 0,
    heroId: 0,
    templateId: 0,
  };
}

export const CSODOTAPlayerChallenge = {
  encode(message: CSODOTAPlayerChallenge, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.accountId !== undefined && message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    if (message.eventId !== undefined && message.eventId !== 0) {
      writer.uint32(16).uint32(message.eventId);
    }
    if (message.slotId !== undefined && message.slotId !== 0) {
      writer.uint32(24).uint32(message.slotId);
    }
    if (message.intParam0 !== undefined && message.intParam0 !== 0) {
      writer.uint32(40).uint32(message.intParam0);
    }
    if (message.intParam1 !== undefined && message.intParam1 !== 0) {
      writer.uint32(48).uint32(message.intParam1);
    }
    if (message.createdTime !== undefined && message.createdTime !== 0) {
      writer.uint32(56).uint32(message.createdTime);
    }
    if (message.completed !== undefined && message.completed !== 0) {
      writer.uint32(64).uint32(message.completed);
    }
    if (message.sequenceId !== undefined && message.sequenceId !== 0) {
      writer.uint32(72).uint32(message.sequenceId);
    }
    if (message.challengeTier !== undefined && message.challengeTier !== 0) {
      writer.uint32(80).uint32(message.challengeTier);
    }
    if (message.flags !== undefined && message.flags !== 0) {
      writer.uint32(88).uint32(message.flags);
    }
    if (message.attempts !== undefined && message.attempts !== 0) {
      writer.uint32(96).uint32(message.attempts);
    }
    if (message.completeLimit !== undefined && message.completeLimit !== 0) {
      writer.uint32(104).uint32(message.completeLimit);
    }
    if (message.questRank !== undefined && message.questRank !== 0) {
      writer.uint32(112).uint32(message.questRank);
    }
    if (message.maxQuestRank !== undefined && message.maxQuestRank !== 0) {
      writer.uint32(120).uint32(message.maxQuestRank);
    }
    if (message.instanceId !== undefined && message.instanceId !== 0) {
      writer.uint32(128).uint32(message.instanceId);
    }
    if (message.heroId !== undefined && message.heroId !== 0) {
      writer.uint32(136).int32(message.heroId);
    }
    if (message.templateId !== undefined && message.templateId !== 0) {
      writer.uint32(144).uint32(message.templateId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CSODOTAPlayerChallenge {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCSODOTAPlayerChallenge();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.eventId = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.slotId = reader.uint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.intParam0 = reader.uint32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.intParam1 = reader.uint32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.createdTime = reader.uint32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.completed = reader.uint32();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.sequenceId = reader.uint32();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.challengeTier = reader.uint32();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.flags = reader.uint32();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.attempts = reader.uint32();
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.completeLimit = reader.uint32();
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.questRank = reader.uint32();
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.maxQuestRank = reader.uint32();
          continue;
        case 16:
          if (tag !== 128) {
            break;
          }

          message.instanceId = reader.uint32();
          continue;
        case 17:
          if (tag !== 136) {
            break;
          }

          message.heroId = reader.int32();
          continue;
        case 18:
          if (tag !== 144) {
            break;
          }

          message.templateId = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CSODOTAPlayerChallenge {
    return {
      accountId: isSet(object.accountId) ? globalThis.Number(object.accountId) : 0,
      eventId: isSet(object.eventId) ? globalThis.Number(object.eventId) : 0,
      slotId: isSet(object.slotId) ? globalThis.Number(object.slotId) : 0,
      intParam0: isSet(object.intParam0) ? globalThis.Number(object.intParam0) : 0,
      intParam1: isSet(object.intParam1) ? globalThis.Number(object.intParam1) : 0,
      createdTime: isSet(object.createdTime) ? globalThis.Number(object.createdTime) : 0,
      completed: isSet(object.completed) ? globalThis.Number(object.completed) : 0,
      sequenceId: isSet(object.sequenceId) ? globalThis.Number(object.sequenceId) : 0,
      challengeTier: isSet(object.challengeTier) ? globalThis.Number(object.challengeTier) : 0,
      flags: isSet(object.flags) ? globalThis.Number(object.flags) : 0,
      attempts: isSet(object.attempts) ? globalThis.Number(object.attempts) : 0,
      completeLimit: isSet(object.completeLimit) ? globalThis.Number(object.completeLimit) : 0,
      questRank: isSet(object.questRank) ? globalThis.Number(object.questRank) : 0,
      maxQuestRank: isSet(object.maxQuestRank) ? globalThis.Number(object.maxQuestRank) : 0,
      instanceId: isSet(object.instanceId) ? globalThis.Number(object.instanceId) : 0,
      heroId: isSet(object.heroId) ? globalThis.Number(object.heroId) : 0,
      templateId: isSet(object.templateId) ? globalThis.Number(object.templateId) : 0,
    };
  },

  toJSON(message: CSODOTAPlayerChallenge): unknown {
    const obj: any = {};
    if (message.accountId !== undefined && message.accountId !== 0) {
      obj.accountId = Math.round(message.accountId);
    }
    if (message.eventId !== undefined && message.eventId !== 0) {
      obj.eventId = Math.round(message.eventId);
    }
    if (message.slotId !== undefined && message.slotId !== 0) {
      obj.slotId = Math.round(message.slotId);
    }
    if (message.intParam0 !== undefined && message.intParam0 !== 0) {
      obj.intParam0 = Math.round(message.intParam0);
    }
    if (message.intParam1 !== undefined && message.intParam1 !== 0) {
      obj.intParam1 = Math.round(message.intParam1);
    }
    if (message.createdTime !== undefined && message.createdTime !== 0) {
      obj.createdTime = Math.round(message.createdTime);
    }
    if (message.completed !== undefined && message.completed !== 0) {
      obj.completed = Math.round(message.completed);
    }
    if (message.sequenceId !== undefined && message.sequenceId !== 0) {
      obj.sequenceId = Math.round(message.sequenceId);
    }
    if (message.challengeTier !== undefined && message.challengeTier !== 0) {
      obj.challengeTier = Math.round(message.challengeTier);
    }
    if (message.flags !== undefined && message.flags !== 0) {
      obj.flags = Math.round(message.flags);
    }
    if (message.attempts !== undefined && message.attempts !== 0) {
      obj.attempts = Math.round(message.attempts);
    }
    if (message.completeLimit !== undefined && message.completeLimit !== 0) {
      obj.completeLimit = Math.round(message.completeLimit);
    }
    if (message.questRank !== undefined && message.questRank !== 0) {
      obj.questRank = Math.round(message.questRank);
    }
    if (message.maxQuestRank !== undefined && message.maxQuestRank !== 0) {
      obj.maxQuestRank = Math.round(message.maxQuestRank);
    }
    if (message.instanceId !== undefined && message.instanceId !== 0) {
      obj.instanceId = Math.round(message.instanceId);
    }
    if (message.heroId !== undefined && message.heroId !== 0) {
      obj.heroId = Math.round(message.heroId);
    }
    if (message.templateId !== undefined && message.templateId !== 0) {
      obj.templateId = Math.round(message.templateId);
    }
    return obj;
  },

  create(base?: DeepPartial<CSODOTAPlayerChallenge>): CSODOTAPlayerChallenge {
    return CSODOTAPlayerChallenge.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CSODOTAPlayerChallenge>): CSODOTAPlayerChallenge {
    const message = createBaseCSODOTAPlayerChallenge();
    message.accountId = object.accountId ?? 0;
    message.eventId = object.eventId ?? 0;
    message.slotId = object.slotId ?? 0;
    message.intParam0 = object.intParam0 ?? 0;
    message.intParam1 = object.intParam1 ?? 0;
    message.createdTime = object.createdTime ?? 0;
    message.completed = object.completed ?? 0;
    message.sequenceId = object.sequenceId ?? 0;
    message.challengeTier = object.challengeTier ?? 0;
    message.flags = object.flags ?? 0;
    message.attempts = object.attempts ?? 0;
    message.completeLimit = object.completeLimit ?? 0;
    message.questRank = object.questRank ?? 0;
    message.maxQuestRank = object.maxQuestRank ?? 0;
    message.instanceId = object.instanceId ?? 0;
    message.heroId = object.heroId ?? 0;
    message.templateId = object.templateId ?? 0;
    return message;
  },
};

function createBaseCMsgClientToGCRerollPlayerChallenge(): CMsgClientToGCRerollPlayerChallenge {
  return { eventId: 0, sequenceId: 0, heroId: 0 };
}

export const CMsgClientToGCRerollPlayerChallenge = {
  encode(message: CMsgClientToGCRerollPlayerChallenge, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.eventId !== undefined && message.eventId !== 0) {
      writer.uint32(8).int32(message.eventId);
    }
    if (message.sequenceId !== undefined && message.sequenceId !== 0) {
      writer.uint32(24).uint32(message.sequenceId);
    }
    if (message.heroId !== undefined && message.heroId !== 0) {
      writer.uint32(32).int32(message.heroId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCRerollPlayerChallenge {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCRerollPlayerChallenge();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.eventId = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.sequenceId = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.heroId = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCRerollPlayerChallenge {
    return {
      eventId: isSet(object.eventId) ? eEventFromJSON(object.eventId) : 0,
      sequenceId: isSet(object.sequenceId) ? globalThis.Number(object.sequenceId) : 0,
      heroId: isSet(object.heroId) ? globalThis.Number(object.heroId) : 0,
    };
  },

  toJSON(message: CMsgClientToGCRerollPlayerChallenge): unknown {
    const obj: any = {};
    if (message.eventId !== undefined && message.eventId !== 0) {
      obj.eventId = eEventToJSON(message.eventId);
    }
    if (message.sequenceId !== undefined && message.sequenceId !== 0) {
      obj.sequenceId = Math.round(message.sequenceId);
    }
    if (message.heroId !== undefined && message.heroId !== 0) {
      obj.heroId = Math.round(message.heroId);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgClientToGCRerollPlayerChallenge>): CMsgClientToGCRerollPlayerChallenge {
    return CMsgClientToGCRerollPlayerChallenge.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgClientToGCRerollPlayerChallenge>): CMsgClientToGCRerollPlayerChallenge {
    const message = createBaseCMsgClientToGCRerollPlayerChallenge();
    message.eventId = object.eventId ?? 0;
    message.sequenceId = object.sequenceId ?? 0;
    message.heroId = object.heroId ?? 0;
    return message;
  },
};

function createBaseCMsgGCRerollPlayerChallengeResponse(): CMsgGCRerollPlayerChallengeResponse {
  return { result: 0 };
}

export const CMsgGCRerollPlayerChallengeResponse = {
  encode(message: CMsgGCRerollPlayerChallengeResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result !== undefined && message.result !== 0) {
      writer.uint32(8).int32(message.result);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCRerollPlayerChallengeResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCRerollPlayerChallengeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.result = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCRerollPlayerChallengeResponse {
    return { result: isSet(object.result) ? cMsgGCRerollPlayerChallengeResponse_EResultFromJSON(object.result) : 0 };
  },

  toJSON(message: CMsgGCRerollPlayerChallengeResponse): unknown {
    const obj: any = {};
    if (message.result !== undefined && message.result !== 0) {
      obj.result = cMsgGCRerollPlayerChallengeResponse_EResultToJSON(message.result);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCRerollPlayerChallengeResponse>): CMsgGCRerollPlayerChallengeResponse {
    return CMsgGCRerollPlayerChallengeResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCRerollPlayerChallengeResponse>): CMsgGCRerollPlayerChallengeResponse {
    const message = createBaseCMsgGCRerollPlayerChallengeResponse();
    message.result = object.result ?? 0;
    return message;
  },
};

function createBaseCMsgGCTopCustomGamesList(): CMsgGCTopCustomGamesList {
  return { topCustomGames: [], gameOfTheDay: "0" };
}

export const CMsgGCTopCustomGamesList = {
  encode(message: CMsgGCTopCustomGamesList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.topCustomGames) {
      writer.uint64(v);
    }
    writer.ldelim();
    if (message.gameOfTheDay !== undefined && message.gameOfTheDay !== "0") {
      writer.uint32(16).uint64(message.gameOfTheDay);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCTopCustomGamesList {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCTopCustomGamesList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.topCustomGames.push(longToString(reader.uint64() as Long));

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.topCustomGames.push(longToString(reader.uint64() as Long));
            }

            continue;
          }

          break;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.gameOfTheDay = longToString(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCTopCustomGamesList {
    return {
      topCustomGames: globalThis.Array.isArray(object?.topCustomGames)
        ? object.topCustomGames.map((e: any) => globalThis.String(e))
        : [],
      gameOfTheDay: isSet(object.gameOfTheDay) ? globalThis.String(object.gameOfTheDay) : "0",
    };
  },

  toJSON(message: CMsgGCTopCustomGamesList): unknown {
    const obj: any = {};
    if (message.topCustomGames?.length) {
      obj.topCustomGames = message.topCustomGames;
    }
    if (message.gameOfTheDay !== undefined && message.gameOfTheDay !== "0") {
      obj.gameOfTheDay = message.gameOfTheDay;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCTopCustomGamesList>): CMsgGCTopCustomGamesList {
    return CMsgGCTopCustomGamesList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCTopCustomGamesList>): CMsgGCTopCustomGamesList {
    const message = createBaseCMsgGCTopCustomGamesList();
    message.topCustomGames = object.topCustomGames?.map((e) => e) || [];
    message.gameOfTheDay = object.gameOfTheDay ?? "0";
    return message;
  },
};

function createBaseCMsgDOTARealtimeGameStats(): CMsgDOTARealtimeGameStats {
  return { match: undefined, teams: [], buildings: [], graphData: undefined, deltaFrame: false };
}

export const CMsgDOTARealtimeGameStats = {
  encode(message: CMsgDOTARealtimeGameStats, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.match !== undefined) {
      CMsgDOTARealtimeGameStats_MatchDetails.encode(message.match, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.teams) {
      CMsgDOTARealtimeGameStats_TeamDetails.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.buildings) {
      CMsgDOTARealtimeGameStats_BuildingDetails.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    if (message.graphData !== undefined) {
      CMsgDOTARealtimeGameStats_GraphData.encode(message.graphData, writer.uint32(34).fork()).ldelim();
    }
    if (message.deltaFrame !== undefined && message.deltaFrame !== false) {
      writer.uint32(40).bool(message.deltaFrame);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTARealtimeGameStats {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTARealtimeGameStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.match = CMsgDOTARealtimeGameStats_MatchDetails.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.teams.push(CMsgDOTARealtimeGameStats_TeamDetails.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.buildings.push(CMsgDOTARealtimeGameStats_BuildingDetails.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.graphData = CMsgDOTARealtimeGameStats_GraphData.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.deltaFrame = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTARealtimeGameStats {
    return {
      match: isSet(object.match) ? CMsgDOTARealtimeGameStats_MatchDetails.fromJSON(object.match) : undefined,
      teams: globalThis.Array.isArray(object?.teams)
        ? object.teams.map((e: any) => CMsgDOTARealtimeGameStats_TeamDetails.fromJSON(e))
        : [],
      buildings: globalThis.Array.isArray(object?.buildings)
        ? object.buildings.map((e: any) => CMsgDOTARealtimeGameStats_BuildingDetails.fromJSON(e))
        : [],
      graphData: isSet(object.graphData) ? CMsgDOTARealtimeGameStats_GraphData.fromJSON(object.graphData) : undefined,
      deltaFrame: isSet(object.deltaFrame) ? globalThis.Boolean(object.deltaFrame) : false,
    };
  },

  toJSON(message: CMsgDOTARealtimeGameStats): unknown {
    const obj: any = {};
    if (message.match !== undefined) {
      obj.match = CMsgDOTARealtimeGameStats_MatchDetails.toJSON(message.match);
    }
    if (message.teams?.length) {
      obj.teams = message.teams.map((e) => CMsgDOTARealtimeGameStats_TeamDetails.toJSON(e));
    }
    if (message.buildings?.length) {
      obj.buildings = message.buildings.map((e) => CMsgDOTARealtimeGameStats_BuildingDetails.toJSON(e));
    }
    if (message.graphData !== undefined) {
      obj.graphData = CMsgDOTARealtimeGameStats_GraphData.toJSON(message.graphData);
    }
    if (message.deltaFrame !== undefined && message.deltaFrame !== false) {
      obj.deltaFrame = message.deltaFrame;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTARealtimeGameStats>): CMsgDOTARealtimeGameStats {
    return CMsgDOTARealtimeGameStats.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTARealtimeGameStats>): CMsgDOTARealtimeGameStats {
    const message = createBaseCMsgDOTARealtimeGameStats();
    message.match = (object.match !== undefined && object.match !== null)
      ? CMsgDOTARealtimeGameStats_MatchDetails.fromPartial(object.match)
      : undefined;
    message.teams = object.teams?.map((e) => CMsgDOTARealtimeGameStats_TeamDetails.fromPartial(e)) || [];
    message.buildings = object.buildings?.map((e) => CMsgDOTARealtimeGameStats_BuildingDetails.fromPartial(e)) || [];
    message.graphData = (object.graphData !== undefined && object.graphData !== null)
      ? CMsgDOTARealtimeGameStats_GraphData.fromPartial(object.graphData)
      : undefined;
    message.deltaFrame = object.deltaFrame ?? false;
    return message;
  },
};

function createBaseCMsgDOTARealtimeGameStats_TeamDetails(): CMsgDOTARealtimeGameStats_TeamDetails {
  return {
    teamNumber: 0,
    teamId: 0,
    teamName: "",
    teamLogo: "0",
    teamTag: "",
    score: 0,
    netWorth: 0,
    players: [],
    onlyTeam: false,
    cheers: 0,
    teamLogoUrl: "",
  };
}

export const CMsgDOTARealtimeGameStats_TeamDetails = {
  encode(message: CMsgDOTARealtimeGameStats_TeamDetails, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.teamNumber !== undefined && message.teamNumber !== 0) {
      writer.uint32(8).uint32(message.teamNumber);
    }
    if (message.teamId !== undefined && message.teamId !== 0) {
      writer.uint32(16).uint32(message.teamId);
    }
    if (message.teamName !== undefined && message.teamName !== "") {
      writer.uint32(26).string(message.teamName);
    }
    if (message.teamLogo !== undefined && message.teamLogo !== "0") {
      writer.uint32(33).fixed64(message.teamLogo);
    }
    if (message.teamTag !== undefined && message.teamTag !== "") {
      writer.uint32(82).string(message.teamTag);
    }
    if (message.score !== undefined && message.score !== 0) {
      writer.uint32(40).uint32(message.score);
    }
    if (message.netWorth !== undefined && message.netWorth !== 0) {
      writer.uint32(72).uint32(message.netWorth);
    }
    for (const v of message.players) {
      CMsgDOTARealtimeGameStats_PlayerDetails.encode(v!, writer.uint32(50).fork()).ldelim();
    }
    if (message.onlyTeam !== undefined && message.onlyTeam !== false) {
      writer.uint32(56).bool(message.onlyTeam);
    }
    if (message.cheers !== undefined && message.cheers !== 0) {
      writer.uint32(64).uint32(message.cheers);
    }
    if (message.teamLogoUrl !== undefined && message.teamLogoUrl !== "") {
      writer.uint32(90).string(message.teamLogoUrl);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTARealtimeGameStats_TeamDetails {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTARealtimeGameStats_TeamDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.teamNumber = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.teamId = reader.uint32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.teamName = reader.string();
          continue;
        case 4:
          if (tag !== 33) {
            break;
          }

          message.teamLogo = longToString(reader.fixed64() as Long);
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.teamTag = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.score = reader.uint32();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.netWorth = reader.uint32();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.players.push(CMsgDOTARealtimeGameStats_PlayerDetails.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.onlyTeam = reader.bool();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.cheers = reader.uint32();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.teamLogoUrl = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTARealtimeGameStats_TeamDetails {
    return {
      teamNumber: isSet(object.teamNumber) ? globalThis.Number(object.teamNumber) : 0,
      teamId: isSet(object.teamId) ? globalThis.Number(object.teamId) : 0,
      teamName: isSet(object.teamName) ? globalThis.String(object.teamName) : "",
      teamLogo: isSet(object.teamLogo) ? globalThis.String(object.teamLogo) : "0",
      teamTag: isSet(object.teamTag) ? globalThis.String(object.teamTag) : "",
      score: isSet(object.score) ? globalThis.Number(object.score) : 0,
      netWorth: isSet(object.netWorth) ? globalThis.Number(object.netWorth) : 0,
      players: globalThis.Array.isArray(object?.players)
        ? object.players.map((e: any) => CMsgDOTARealtimeGameStats_PlayerDetails.fromJSON(e))
        : [],
      onlyTeam: isSet(object.onlyTeam) ? globalThis.Boolean(object.onlyTeam) : false,
      cheers: isSet(object.cheers) ? globalThis.Number(object.cheers) : 0,
      teamLogoUrl: isSet(object.teamLogoUrl) ? globalThis.String(object.teamLogoUrl) : "",
    };
  },

  toJSON(message: CMsgDOTARealtimeGameStats_TeamDetails): unknown {
    const obj: any = {};
    if (message.teamNumber !== undefined && message.teamNumber !== 0) {
      obj.teamNumber = Math.round(message.teamNumber);
    }
    if (message.teamId !== undefined && message.teamId !== 0) {
      obj.teamId = Math.round(message.teamId);
    }
    if (message.teamName !== undefined && message.teamName !== "") {
      obj.teamName = message.teamName;
    }
    if (message.teamLogo !== undefined && message.teamLogo !== "0") {
      obj.teamLogo = message.teamLogo;
    }
    if (message.teamTag !== undefined && message.teamTag !== "") {
      obj.teamTag = message.teamTag;
    }
    if (message.score !== undefined && message.score !== 0) {
      obj.score = Math.round(message.score);
    }
    if (message.netWorth !== undefined && message.netWorth !== 0) {
      obj.netWorth = Math.round(message.netWorth);
    }
    if (message.players?.length) {
      obj.players = message.players.map((e) => CMsgDOTARealtimeGameStats_PlayerDetails.toJSON(e));
    }
    if (message.onlyTeam !== undefined && message.onlyTeam !== false) {
      obj.onlyTeam = message.onlyTeam;
    }
    if (message.cheers !== undefined && message.cheers !== 0) {
      obj.cheers = Math.round(message.cheers);
    }
    if (message.teamLogoUrl !== undefined && message.teamLogoUrl !== "") {
      obj.teamLogoUrl = message.teamLogoUrl;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTARealtimeGameStats_TeamDetails>): CMsgDOTARealtimeGameStats_TeamDetails {
    return CMsgDOTARealtimeGameStats_TeamDetails.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTARealtimeGameStats_TeamDetails>): CMsgDOTARealtimeGameStats_TeamDetails {
    const message = createBaseCMsgDOTARealtimeGameStats_TeamDetails();
    message.teamNumber = object.teamNumber ?? 0;
    message.teamId = object.teamId ?? 0;
    message.teamName = object.teamName ?? "";
    message.teamLogo = object.teamLogo ?? "0";
    message.teamTag = object.teamTag ?? "";
    message.score = object.score ?? 0;
    message.netWorth = object.netWorth ?? 0;
    message.players = object.players?.map((e) => CMsgDOTARealtimeGameStats_PlayerDetails.fromPartial(e)) || [];
    message.onlyTeam = object.onlyTeam ?? false;
    message.cheers = object.cheers ?? 0;
    message.teamLogoUrl = object.teamLogoUrl ?? "";
    return message;
  },
};

function createBaseCMsgDOTARealtimeGameStats_ItemDetails(): CMsgDOTARealtimeGameStats_ItemDetails {
  return { itemAbilityId: -1, name: "", time: 0, sold: false, stackcount: 0 };
}

export const CMsgDOTARealtimeGameStats_ItemDetails = {
  encode(message: CMsgDOTARealtimeGameStats_ItemDetails, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.itemAbilityId !== undefined && message.itemAbilityId !== -1) {
      writer.uint32(8).int32(message.itemAbilityId);
    }
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.time !== undefined && message.time !== 0) {
      writer.uint32(24).int32(message.time);
    }
    if (message.sold !== undefined && message.sold !== false) {
      writer.uint32(32).bool(message.sold);
    }
    if (message.stackcount !== undefined && message.stackcount !== 0) {
      writer.uint32(40).uint32(message.stackcount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTARealtimeGameStats_ItemDetails {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTARealtimeGameStats_ItemDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.itemAbilityId = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.time = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.sold = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.stackcount = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTARealtimeGameStats_ItemDetails {
    return {
      itemAbilityId: isSet(object.itemAbilityId) ? globalThis.Number(object.itemAbilityId) : -1,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      time: isSet(object.time) ? globalThis.Number(object.time) : 0,
      sold: isSet(object.sold) ? globalThis.Boolean(object.sold) : false,
      stackcount: isSet(object.stackcount) ? globalThis.Number(object.stackcount) : 0,
    };
  },

  toJSON(message: CMsgDOTARealtimeGameStats_ItemDetails): unknown {
    const obj: any = {};
    if (message.itemAbilityId !== undefined && message.itemAbilityId !== -1) {
      obj.itemAbilityId = Math.round(message.itemAbilityId);
    }
    if (message.name !== undefined && message.name !== "") {
      obj.name = message.name;
    }
    if (message.time !== undefined && message.time !== 0) {
      obj.time = Math.round(message.time);
    }
    if (message.sold !== undefined && message.sold !== false) {
      obj.sold = message.sold;
    }
    if (message.stackcount !== undefined && message.stackcount !== 0) {
      obj.stackcount = Math.round(message.stackcount);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTARealtimeGameStats_ItemDetails>): CMsgDOTARealtimeGameStats_ItemDetails {
    return CMsgDOTARealtimeGameStats_ItemDetails.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTARealtimeGameStats_ItemDetails>): CMsgDOTARealtimeGameStats_ItemDetails {
    const message = createBaseCMsgDOTARealtimeGameStats_ItemDetails();
    message.itemAbilityId = object.itemAbilityId ?? -1;
    message.name = object.name ?? "";
    message.time = object.time ?? 0;
    message.sold = object.sold ?? false;
    message.stackcount = object.stackcount ?? 0;
    return message;
  },
};

function createBaseCMsgDOTARealtimeGameStats_AbilityDetails(): CMsgDOTARealtimeGameStats_AbilityDetails {
  return { id: -1, name: "", level: 0, cooldown: 0, cooldownMax: 0 };
}

export const CMsgDOTARealtimeGameStats_AbilityDetails = {
  encode(message: CMsgDOTARealtimeGameStats_AbilityDetails, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== undefined && message.id !== -1) {
      writer.uint32(8).int32(message.id);
    }
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.level !== undefined && message.level !== 0) {
      writer.uint32(24).uint32(message.level);
    }
    if (message.cooldown !== undefined && message.cooldown !== 0) {
      writer.uint32(37).float(message.cooldown);
    }
    if (message.cooldownMax !== undefined && message.cooldownMax !== 0) {
      writer.uint32(45).float(message.cooldownMax);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTARealtimeGameStats_AbilityDetails {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTARealtimeGameStats_AbilityDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.level = reader.uint32();
          continue;
        case 4:
          if (tag !== 37) {
            break;
          }

          message.cooldown = reader.float();
          continue;
        case 5:
          if (tag !== 45) {
            break;
          }

          message.cooldownMax = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTARealtimeGameStats_AbilityDetails {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : -1,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      level: isSet(object.level) ? globalThis.Number(object.level) : 0,
      cooldown: isSet(object.cooldown) ? globalThis.Number(object.cooldown) : 0,
      cooldownMax: isSet(object.cooldownMax) ? globalThis.Number(object.cooldownMax) : 0,
    };
  },

  toJSON(message: CMsgDOTARealtimeGameStats_AbilityDetails): unknown {
    const obj: any = {};
    if (message.id !== undefined && message.id !== -1) {
      obj.id = Math.round(message.id);
    }
    if (message.name !== undefined && message.name !== "") {
      obj.name = message.name;
    }
    if (message.level !== undefined && message.level !== 0) {
      obj.level = Math.round(message.level);
    }
    if (message.cooldown !== undefined && message.cooldown !== 0) {
      obj.cooldown = message.cooldown;
    }
    if (message.cooldownMax !== undefined && message.cooldownMax !== 0) {
      obj.cooldownMax = message.cooldownMax;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTARealtimeGameStats_AbilityDetails>): CMsgDOTARealtimeGameStats_AbilityDetails {
    return CMsgDOTARealtimeGameStats_AbilityDetails.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTARealtimeGameStats_AbilityDetails>): CMsgDOTARealtimeGameStats_AbilityDetails {
    const message = createBaseCMsgDOTARealtimeGameStats_AbilityDetails();
    message.id = object.id ?? -1;
    message.name = object.name ?? "";
    message.level = object.level ?? 0;
    message.cooldown = object.cooldown ?? 0;
    message.cooldownMax = object.cooldownMax ?? 0;
    return message;
  },
};

function createBaseCMsgDOTARealtimeGameStats_HeroToHeroStats(): CMsgDOTARealtimeGameStats_HeroToHeroStats {
  return { victimid: -1, kills: 0, assists: 0 };
}

export const CMsgDOTARealtimeGameStats_HeroToHeroStats = {
  encode(message: CMsgDOTARealtimeGameStats_HeroToHeroStats, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.victimid !== undefined && message.victimid !== -1) {
      writer.uint32(8).int32(message.victimid);
    }
    if (message.kills !== undefined && message.kills !== 0) {
      writer.uint32(16).uint32(message.kills);
    }
    if (message.assists !== undefined && message.assists !== 0) {
      writer.uint32(24).uint32(message.assists);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTARealtimeGameStats_HeroToHeroStats {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTARealtimeGameStats_HeroToHeroStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.victimid = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.kills = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.assists = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTARealtimeGameStats_HeroToHeroStats {
    return {
      victimid: isSet(object.victimid) ? globalThis.Number(object.victimid) : -1,
      kills: isSet(object.kills) ? globalThis.Number(object.kills) : 0,
      assists: isSet(object.assists) ? globalThis.Number(object.assists) : 0,
    };
  },

  toJSON(message: CMsgDOTARealtimeGameStats_HeroToHeroStats): unknown {
    const obj: any = {};
    if (message.victimid !== undefined && message.victimid !== -1) {
      obj.victimid = Math.round(message.victimid);
    }
    if (message.kills !== undefined && message.kills !== 0) {
      obj.kills = Math.round(message.kills);
    }
    if (message.assists !== undefined && message.assists !== 0) {
      obj.assists = Math.round(message.assists);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTARealtimeGameStats_HeroToHeroStats>): CMsgDOTARealtimeGameStats_HeroToHeroStats {
    return CMsgDOTARealtimeGameStats_HeroToHeroStats.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgDOTARealtimeGameStats_HeroToHeroStats>,
  ): CMsgDOTARealtimeGameStats_HeroToHeroStats {
    const message = createBaseCMsgDOTARealtimeGameStats_HeroToHeroStats();
    message.victimid = object.victimid ?? -1;
    message.kills = object.kills ?? 0;
    message.assists = object.assists ?? 0;
    return message;
  },
};

function createBaseCMsgDOTARealtimeGameStats_AbilityList(): CMsgDOTARealtimeGameStats_AbilityList {
  return { id: [] };
}

export const CMsgDOTARealtimeGameStats_AbilityList = {
  encode(message: CMsgDOTARealtimeGameStats_AbilityList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.id) {
      writer.int32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTARealtimeGameStats_AbilityList {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTARealtimeGameStats_AbilityList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.id.push(reader.int32());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.id.push(reader.int32());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTARealtimeGameStats_AbilityList {
    return { id: globalThis.Array.isArray(object?.id) ? object.id.map((e: any) => globalThis.Number(e)) : [] };
  },

  toJSON(message: CMsgDOTARealtimeGameStats_AbilityList): unknown {
    const obj: any = {};
    if (message.id?.length) {
      obj.id = message.id.map((e) => Math.round(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTARealtimeGameStats_AbilityList>): CMsgDOTARealtimeGameStats_AbilityList {
    return CMsgDOTARealtimeGameStats_AbilityList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTARealtimeGameStats_AbilityList>): CMsgDOTARealtimeGameStats_AbilityList {
    const message = createBaseCMsgDOTARealtimeGameStats_AbilityList();
    message.id = object.id?.map((e) => e) || [];
    return message;
  },
};

function createBaseCMsgDOTARealtimeGameStats_PlayerDetails(): CMsgDOTARealtimeGameStats_PlayerDetails {
  return {
    accountid: 0,
    playerid: -1,
    name: "",
    team: 0,
    heroid: 0,
    healthpoints: 0,
    maxhealthpoints: 0,
    healthregenrate: 0,
    manapoints: 0,
    maxmanapoints: 0,
    manaregenrate: 0,
    baseStrength: 0,
    baseAgility: 0,
    baseIntelligence: 0,
    baseArmor: 0,
    baseMovespeed: 0,
    baseDamage: 0,
    strength: 0,
    agility: 0,
    intelligence: 0,
    armor: 0,
    movespeed: 0,
    damage: 0,
    heroDamage: 0,
    towerDamage: 0,
    abilities: [],
    level: 0,
    killCount: 0,
    deathCount: 0,
    assistsCount: 0,
    deniesCount: 0,
    lhCount: 0,
    heroHealing: 0,
    goldPerMin: 0,
    xpPerMin: 0,
    netGold: 0,
    gold: 0,
    x: 0,
    y: 0,
    respawnTime: 0,
    ultimateCooldown: 0,
    hasBuyback: false,
    items: [],
    stashitems: [],
    itemshoppinglist: [],
    levelpoints: [],
    heroToHeroStats: [],
    hasUltimate: false,
    hasUltimateMana: false,
    teamSlot: 0,
  };
}

export const CMsgDOTARealtimeGameStats_PlayerDetails = {
  encode(message: CMsgDOTARealtimeGameStats_PlayerDetails, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.accountid !== undefined && message.accountid !== 0) {
      writer.uint32(8).uint32(message.accountid);
    }
    if (message.playerid !== undefined && message.playerid !== -1) {
      writer.uint32(16).int32(message.playerid);
    }
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.team !== undefined && message.team !== 0) {
      writer.uint32(32).uint32(message.team);
    }
    if (message.heroid !== undefined && message.heroid !== 0) {
      writer.uint32(40).int32(message.heroid);
    }
    if (message.healthpoints !== undefined && message.healthpoints !== 0) {
      writer.uint32(48).uint32(message.healthpoints);
    }
    if (message.maxhealthpoints !== undefined && message.maxhealthpoints !== 0) {
      writer.uint32(56).uint32(message.maxhealthpoints);
    }
    if (message.healthregenrate !== undefined && message.healthregenrate !== 0) {
      writer.uint32(69).float(message.healthregenrate);
    }
    if (message.manapoints !== undefined && message.manapoints !== 0) {
      writer.uint32(72).uint32(message.manapoints);
    }
    if (message.maxmanapoints !== undefined && message.maxmanapoints !== 0) {
      writer.uint32(80).uint32(message.maxmanapoints);
    }
    if (message.manaregenrate !== undefined && message.manaregenrate !== 0) {
      writer.uint32(93).float(message.manaregenrate);
    }
    if (message.baseStrength !== undefined && message.baseStrength !== 0) {
      writer.uint32(96).uint32(message.baseStrength);
    }
    if (message.baseAgility !== undefined && message.baseAgility !== 0) {
      writer.uint32(104).uint32(message.baseAgility);
    }
    if (message.baseIntelligence !== undefined && message.baseIntelligence !== 0) {
      writer.uint32(112).uint32(message.baseIntelligence);
    }
    if (message.baseArmor !== undefined && message.baseArmor !== 0) {
      writer.uint32(120).int32(message.baseArmor);
    }
    if (message.baseMovespeed !== undefined && message.baseMovespeed !== 0) {
      writer.uint32(128).uint32(message.baseMovespeed);
    }
    if (message.baseDamage !== undefined && message.baseDamage !== 0) {
      writer.uint32(136).uint32(message.baseDamage);
    }
    if (message.strength !== undefined && message.strength !== 0) {
      writer.uint32(144).uint32(message.strength);
    }
    if (message.agility !== undefined && message.agility !== 0) {
      writer.uint32(152).uint32(message.agility);
    }
    if (message.intelligence !== undefined && message.intelligence !== 0) {
      writer.uint32(160).uint32(message.intelligence);
    }
    if (message.armor !== undefined && message.armor !== 0) {
      writer.uint32(168).int32(message.armor);
    }
    if (message.movespeed !== undefined && message.movespeed !== 0) {
      writer.uint32(176).uint32(message.movespeed);
    }
    if (message.damage !== undefined && message.damage !== 0) {
      writer.uint32(184).uint32(message.damage);
    }
    if (message.heroDamage !== undefined && message.heroDamage !== 0) {
      writer.uint32(192).uint32(message.heroDamage);
    }
    if (message.towerDamage !== undefined && message.towerDamage !== 0) {
      writer.uint32(200).uint32(message.towerDamage);
    }
    for (const v of message.abilities) {
      CMsgDOTARealtimeGameStats_AbilityDetails.encode(v!, writer.uint32(210).fork()).ldelim();
    }
    if (message.level !== undefined && message.level !== 0) {
      writer.uint32(216).uint32(message.level);
    }
    if (message.killCount !== undefined && message.killCount !== 0) {
      writer.uint32(224).uint32(message.killCount);
    }
    if (message.deathCount !== undefined && message.deathCount !== 0) {
      writer.uint32(232).uint32(message.deathCount);
    }
    if (message.assistsCount !== undefined && message.assistsCount !== 0) {
      writer.uint32(240).uint32(message.assistsCount);
    }
    if (message.deniesCount !== undefined && message.deniesCount !== 0) {
      writer.uint32(248).uint32(message.deniesCount);
    }
    if (message.lhCount !== undefined && message.lhCount !== 0) {
      writer.uint32(256).uint32(message.lhCount);
    }
    if (message.heroHealing !== undefined && message.heroHealing !== 0) {
      writer.uint32(264).uint32(message.heroHealing);
    }
    if (message.goldPerMin !== undefined && message.goldPerMin !== 0) {
      writer.uint32(272).uint32(message.goldPerMin);
    }
    if (message.xpPerMin !== undefined && message.xpPerMin !== 0) {
      writer.uint32(280).uint32(message.xpPerMin);
    }
    if (message.netGold !== undefined && message.netGold !== 0) {
      writer.uint32(288).uint32(message.netGold);
    }
    if (message.gold !== undefined && message.gold !== 0) {
      writer.uint32(296).uint32(message.gold);
    }
    if (message.x !== undefined && message.x !== 0) {
      writer.uint32(309).float(message.x);
    }
    if (message.y !== undefined && message.y !== 0) {
      writer.uint32(317).float(message.y);
    }
    if (message.respawnTime !== undefined && message.respawnTime !== 0) {
      writer.uint32(320).int32(message.respawnTime);
    }
    if (message.ultimateCooldown !== undefined && message.ultimateCooldown !== 0) {
      writer.uint32(328).uint32(message.ultimateCooldown);
    }
    if (message.hasBuyback !== undefined && message.hasBuyback !== false) {
      writer.uint32(336).bool(message.hasBuyback);
    }
    for (const v of message.items) {
      CMsgDOTARealtimeGameStats_ItemDetails.encode(v!, writer.uint32(346).fork()).ldelim();
    }
    for (const v of message.stashitems) {
      CMsgDOTARealtimeGameStats_ItemDetails.encode(v!, writer.uint32(354).fork()).ldelim();
    }
    for (const v of message.itemshoppinglist) {
      CMsgDOTARealtimeGameStats_ItemDetails.encode(v!, writer.uint32(362).fork()).ldelim();
    }
    for (const v of message.levelpoints) {
      CMsgDOTARealtimeGameStats_AbilityList.encode(v!, writer.uint32(370).fork()).ldelim();
    }
    for (const v of message.heroToHeroStats) {
      CMsgDOTARealtimeGameStats_HeroToHeroStats.encode(v!, writer.uint32(378).fork()).ldelim();
    }
    if (message.hasUltimate !== undefined && message.hasUltimate !== false) {
      writer.uint32(384).bool(message.hasUltimate);
    }
    if (message.hasUltimateMana !== undefined && message.hasUltimateMana !== false) {
      writer.uint32(392).bool(message.hasUltimateMana);
    }
    if (message.teamSlot !== undefined && message.teamSlot !== 0) {
      writer.uint32(400).uint32(message.teamSlot);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTARealtimeGameStats_PlayerDetails {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTARealtimeGameStats_PlayerDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.accountid = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.playerid = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.team = reader.uint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.heroid = reader.int32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.healthpoints = reader.uint32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.maxhealthpoints = reader.uint32();
          continue;
        case 8:
          if (tag !== 69) {
            break;
          }

          message.healthregenrate = reader.float();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.manapoints = reader.uint32();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.maxmanapoints = reader.uint32();
          continue;
        case 11:
          if (tag !== 93) {
            break;
          }

          message.manaregenrate = reader.float();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.baseStrength = reader.uint32();
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.baseAgility = reader.uint32();
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.baseIntelligence = reader.uint32();
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.baseArmor = reader.int32();
          continue;
        case 16:
          if (tag !== 128) {
            break;
          }

          message.baseMovespeed = reader.uint32();
          continue;
        case 17:
          if (tag !== 136) {
            break;
          }

          message.baseDamage = reader.uint32();
          continue;
        case 18:
          if (tag !== 144) {
            break;
          }

          message.strength = reader.uint32();
          continue;
        case 19:
          if (tag !== 152) {
            break;
          }

          message.agility = reader.uint32();
          continue;
        case 20:
          if (tag !== 160) {
            break;
          }

          message.intelligence = reader.uint32();
          continue;
        case 21:
          if (tag !== 168) {
            break;
          }

          message.armor = reader.int32();
          continue;
        case 22:
          if (tag !== 176) {
            break;
          }

          message.movespeed = reader.uint32();
          continue;
        case 23:
          if (tag !== 184) {
            break;
          }

          message.damage = reader.uint32();
          continue;
        case 24:
          if (tag !== 192) {
            break;
          }

          message.heroDamage = reader.uint32();
          continue;
        case 25:
          if (tag !== 200) {
            break;
          }

          message.towerDamage = reader.uint32();
          continue;
        case 26:
          if (tag !== 210) {
            break;
          }

          message.abilities.push(CMsgDOTARealtimeGameStats_AbilityDetails.decode(reader, reader.uint32()));
          continue;
        case 27:
          if (tag !== 216) {
            break;
          }

          message.level = reader.uint32();
          continue;
        case 28:
          if (tag !== 224) {
            break;
          }

          message.killCount = reader.uint32();
          continue;
        case 29:
          if (tag !== 232) {
            break;
          }

          message.deathCount = reader.uint32();
          continue;
        case 30:
          if (tag !== 240) {
            break;
          }

          message.assistsCount = reader.uint32();
          continue;
        case 31:
          if (tag !== 248) {
            break;
          }

          message.deniesCount = reader.uint32();
          continue;
        case 32:
          if (tag !== 256) {
            break;
          }

          message.lhCount = reader.uint32();
          continue;
        case 33:
          if (tag !== 264) {
            break;
          }

          message.heroHealing = reader.uint32();
          continue;
        case 34:
          if (tag !== 272) {
            break;
          }

          message.goldPerMin = reader.uint32();
          continue;
        case 35:
          if (tag !== 280) {
            break;
          }

          message.xpPerMin = reader.uint32();
          continue;
        case 36:
          if (tag !== 288) {
            break;
          }

          message.netGold = reader.uint32();
          continue;
        case 37:
          if (tag !== 296) {
            break;
          }

          message.gold = reader.uint32();
          continue;
        case 38:
          if (tag !== 309) {
            break;
          }

          message.x = reader.float();
          continue;
        case 39:
          if (tag !== 317) {
            break;
          }

          message.y = reader.float();
          continue;
        case 40:
          if (tag !== 320) {
            break;
          }

          message.respawnTime = reader.int32();
          continue;
        case 41:
          if (tag !== 328) {
            break;
          }

          message.ultimateCooldown = reader.uint32();
          continue;
        case 42:
          if (tag !== 336) {
            break;
          }

          message.hasBuyback = reader.bool();
          continue;
        case 43:
          if (tag !== 346) {
            break;
          }

          message.items.push(CMsgDOTARealtimeGameStats_ItemDetails.decode(reader, reader.uint32()));
          continue;
        case 44:
          if (tag !== 354) {
            break;
          }

          message.stashitems.push(CMsgDOTARealtimeGameStats_ItemDetails.decode(reader, reader.uint32()));
          continue;
        case 45:
          if (tag !== 362) {
            break;
          }

          message.itemshoppinglist.push(CMsgDOTARealtimeGameStats_ItemDetails.decode(reader, reader.uint32()));
          continue;
        case 46:
          if (tag !== 370) {
            break;
          }

          message.levelpoints.push(CMsgDOTARealtimeGameStats_AbilityList.decode(reader, reader.uint32()));
          continue;
        case 47:
          if (tag !== 378) {
            break;
          }

          message.heroToHeroStats.push(CMsgDOTARealtimeGameStats_HeroToHeroStats.decode(reader, reader.uint32()));
          continue;
        case 48:
          if (tag !== 384) {
            break;
          }

          message.hasUltimate = reader.bool();
          continue;
        case 49:
          if (tag !== 392) {
            break;
          }

          message.hasUltimateMana = reader.bool();
          continue;
        case 50:
          if (tag !== 400) {
            break;
          }

          message.teamSlot = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTARealtimeGameStats_PlayerDetails {
    return {
      accountid: isSet(object.accountid) ? globalThis.Number(object.accountid) : 0,
      playerid: isSet(object.playerid) ? globalThis.Number(object.playerid) : -1,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      team: isSet(object.team) ? globalThis.Number(object.team) : 0,
      heroid: isSet(object.heroid) ? globalThis.Number(object.heroid) : 0,
      healthpoints: isSet(object.healthpoints) ? globalThis.Number(object.healthpoints) : 0,
      maxhealthpoints: isSet(object.maxhealthpoints) ? globalThis.Number(object.maxhealthpoints) : 0,
      healthregenrate: isSet(object.healthregenrate) ? globalThis.Number(object.healthregenrate) : 0,
      manapoints: isSet(object.manapoints) ? globalThis.Number(object.manapoints) : 0,
      maxmanapoints: isSet(object.maxmanapoints) ? globalThis.Number(object.maxmanapoints) : 0,
      manaregenrate: isSet(object.manaregenrate) ? globalThis.Number(object.manaregenrate) : 0,
      baseStrength: isSet(object.baseStrength) ? globalThis.Number(object.baseStrength) : 0,
      baseAgility: isSet(object.baseAgility) ? globalThis.Number(object.baseAgility) : 0,
      baseIntelligence: isSet(object.baseIntelligence) ? globalThis.Number(object.baseIntelligence) : 0,
      baseArmor: isSet(object.baseArmor) ? globalThis.Number(object.baseArmor) : 0,
      baseMovespeed: isSet(object.baseMovespeed) ? globalThis.Number(object.baseMovespeed) : 0,
      baseDamage: isSet(object.baseDamage) ? globalThis.Number(object.baseDamage) : 0,
      strength: isSet(object.strength) ? globalThis.Number(object.strength) : 0,
      agility: isSet(object.agility) ? globalThis.Number(object.agility) : 0,
      intelligence: isSet(object.intelligence) ? globalThis.Number(object.intelligence) : 0,
      armor: isSet(object.armor) ? globalThis.Number(object.armor) : 0,
      movespeed: isSet(object.movespeed) ? globalThis.Number(object.movespeed) : 0,
      damage: isSet(object.damage) ? globalThis.Number(object.damage) : 0,
      heroDamage: isSet(object.heroDamage) ? globalThis.Number(object.heroDamage) : 0,
      towerDamage: isSet(object.towerDamage) ? globalThis.Number(object.towerDamage) : 0,
      abilities: globalThis.Array.isArray(object?.abilities)
        ? object.abilities.map((e: any) => CMsgDOTARealtimeGameStats_AbilityDetails.fromJSON(e))
        : [],
      level: isSet(object.level) ? globalThis.Number(object.level) : 0,
      killCount: isSet(object.killCount) ? globalThis.Number(object.killCount) : 0,
      deathCount: isSet(object.deathCount) ? globalThis.Number(object.deathCount) : 0,
      assistsCount: isSet(object.assistsCount) ? globalThis.Number(object.assistsCount) : 0,
      deniesCount: isSet(object.deniesCount) ? globalThis.Number(object.deniesCount) : 0,
      lhCount: isSet(object.lhCount) ? globalThis.Number(object.lhCount) : 0,
      heroHealing: isSet(object.heroHealing) ? globalThis.Number(object.heroHealing) : 0,
      goldPerMin: isSet(object.goldPerMin) ? globalThis.Number(object.goldPerMin) : 0,
      xpPerMin: isSet(object.xpPerMin) ? globalThis.Number(object.xpPerMin) : 0,
      netGold: isSet(object.netGold) ? globalThis.Number(object.netGold) : 0,
      gold: isSet(object.gold) ? globalThis.Number(object.gold) : 0,
      x: isSet(object.x) ? globalThis.Number(object.x) : 0,
      y: isSet(object.y) ? globalThis.Number(object.y) : 0,
      respawnTime: isSet(object.respawnTime) ? globalThis.Number(object.respawnTime) : 0,
      ultimateCooldown: isSet(object.ultimateCooldown) ? globalThis.Number(object.ultimateCooldown) : 0,
      hasBuyback: isSet(object.hasBuyback) ? globalThis.Boolean(object.hasBuyback) : false,
      items: globalThis.Array.isArray(object?.items)
        ? object.items.map((e: any) => CMsgDOTARealtimeGameStats_ItemDetails.fromJSON(e))
        : [],
      stashitems: globalThis.Array.isArray(object?.stashitems)
        ? object.stashitems.map((e: any) => CMsgDOTARealtimeGameStats_ItemDetails.fromJSON(e))
        : [],
      itemshoppinglist: globalThis.Array.isArray(object?.itemshoppinglist)
        ? object.itemshoppinglist.map((e: any) => CMsgDOTARealtimeGameStats_ItemDetails.fromJSON(e))
        : [],
      levelpoints: globalThis.Array.isArray(object?.levelpoints)
        ? object.levelpoints.map((e: any) => CMsgDOTARealtimeGameStats_AbilityList.fromJSON(e))
        : [],
      heroToHeroStats: globalThis.Array.isArray(object?.heroToHeroStats)
        ? object.heroToHeroStats.map((e: any) => CMsgDOTARealtimeGameStats_HeroToHeroStats.fromJSON(e))
        : [],
      hasUltimate: isSet(object.hasUltimate) ? globalThis.Boolean(object.hasUltimate) : false,
      hasUltimateMana: isSet(object.hasUltimateMana) ? globalThis.Boolean(object.hasUltimateMana) : false,
      teamSlot: isSet(object.teamSlot) ? globalThis.Number(object.teamSlot) : 0,
    };
  },

  toJSON(message: CMsgDOTARealtimeGameStats_PlayerDetails): unknown {
    const obj: any = {};
    if (message.accountid !== undefined && message.accountid !== 0) {
      obj.accountid = Math.round(message.accountid);
    }
    if (message.playerid !== undefined && message.playerid !== -1) {
      obj.playerid = Math.round(message.playerid);
    }
    if (message.name !== undefined && message.name !== "") {
      obj.name = message.name;
    }
    if (message.team !== undefined && message.team !== 0) {
      obj.team = Math.round(message.team);
    }
    if (message.heroid !== undefined && message.heroid !== 0) {
      obj.heroid = Math.round(message.heroid);
    }
    if (message.healthpoints !== undefined && message.healthpoints !== 0) {
      obj.healthpoints = Math.round(message.healthpoints);
    }
    if (message.maxhealthpoints !== undefined && message.maxhealthpoints !== 0) {
      obj.maxhealthpoints = Math.round(message.maxhealthpoints);
    }
    if (message.healthregenrate !== undefined && message.healthregenrate !== 0) {
      obj.healthregenrate = message.healthregenrate;
    }
    if (message.manapoints !== undefined && message.manapoints !== 0) {
      obj.manapoints = Math.round(message.manapoints);
    }
    if (message.maxmanapoints !== undefined && message.maxmanapoints !== 0) {
      obj.maxmanapoints = Math.round(message.maxmanapoints);
    }
    if (message.manaregenrate !== undefined && message.manaregenrate !== 0) {
      obj.manaregenrate = message.manaregenrate;
    }
    if (message.baseStrength !== undefined && message.baseStrength !== 0) {
      obj.baseStrength = Math.round(message.baseStrength);
    }
    if (message.baseAgility !== undefined && message.baseAgility !== 0) {
      obj.baseAgility = Math.round(message.baseAgility);
    }
    if (message.baseIntelligence !== undefined && message.baseIntelligence !== 0) {
      obj.baseIntelligence = Math.round(message.baseIntelligence);
    }
    if (message.baseArmor !== undefined && message.baseArmor !== 0) {
      obj.baseArmor = Math.round(message.baseArmor);
    }
    if (message.baseMovespeed !== undefined && message.baseMovespeed !== 0) {
      obj.baseMovespeed = Math.round(message.baseMovespeed);
    }
    if (message.baseDamage !== undefined && message.baseDamage !== 0) {
      obj.baseDamage = Math.round(message.baseDamage);
    }
    if (message.strength !== undefined && message.strength !== 0) {
      obj.strength = Math.round(message.strength);
    }
    if (message.agility !== undefined && message.agility !== 0) {
      obj.agility = Math.round(message.agility);
    }
    if (message.intelligence !== undefined && message.intelligence !== 0) {
      obj.intelligence = Math.round(message.intelligence);
    }
    if (message.armor !== undefined && message.armor !== 0) {
      obj.armor = Math.round(message.armor);
    }
    if (message.movespeed !== undefined && message.movespeed !== 0) {
      obj.movespeed = Math.round(message.movespeed);
    }
    if (message.damage !== undefined && message.damage !== 0) {
      obj.damage = Math.round(message.damage);
    }
    if (message.heroDamage !== undefined && message.heroDamage !== 0) {
      obj.heroDamage = Math.round(message.heroDamage);
    }
    if (message.towerDamage !== undefined && message.towerDamage !== 0) {
      obj.towerDamage = Math.round(message.towerDamage);
    }
    if (message.abilities?.length) {
      obj.abilities = message.abilities.map((e) => CMsgDOTARealtimeGameStats_AbilityDetails.toJSON(e));
    }
    if (message.level !== undefined && message.level !== 0) {
      obj.level = Math.round(message.level);
    }
    if (message.killCount !== undefined && message.killCount !== 0) {
      obj.killCount = Math.round(message.killCount);
    }
    if (message.deathCount !== undefined && message.deathCount !== 0) {
      obj.deathCount = Math.round(message.deathCount);
    }
    if (message.assistsCount !== undefined && message.assistsCount !== 0) {
      obj.assistsCount = Math.round(message.assistsCount);
    }
    if (message.deniesCount !== undefined && message.deniesCount !== 0) {
      obj.deniesCount = Math.round(message.deniesCount);
    }
    if (message.lhCount !== undefined && message.lhCount !== 0) {
      obj.lhCount = Math.round(message.lhCount);
    }
    if (message.heroHealing !== undefined && message.heroHealing !== 0) {
      obj.heroHealing = Math.round(message.heroHealing);
    }
    if (message.goldPerMin !== undefined && message.goldPerMin !== 0) {
      obj.goldPerMin = Math.round(message.goldPerMin);
    }
    if (message.xpPerMin !== undefined && message.xpPerMin !== 0) {
      obj.xpPerMin = Math.round(message.xpPerMin);
    }
    if (message.netGold !== undefined && message.netGold !== 0) {
      obj.netGold = Math.round(message.netGold);
    }
    if (message.gold !== undefined && message.gold !== 0) {
      obj.gold = Math.round(message.gold);
    }
    if (message.x !== undefined && message.x !== 0) {
      obj.x = message.x;
    }
    if (message.y !== undefined && message.y !== 0) {
      obj.y = message.y;
    }
    if (message.respawnTime !== undefined && message.respawnTime !== 0) {
      obj.respawnTime = Math.round(message.respawnTime);
    }
    if (message.ultimateCooldown !== undefined && message.ultimateCooldown !== 0) {
      obj.ultimateCooldown = Math.round(message.ultimateCooldown);
    }
    if (message.hasBuyback !== undefined && message.hasBuyback !== false) {
      obj.hasBuyback = message.hasBuyback;
    }
    if (message.items?.length) {
      obj.items = message.items.map((e) => CMsgDOTARealtimeGameStats_ItemDetails.toJSON(e));
    }
    if (message.stashitems?.length) {
      obj.stashitems = message.stashitems.map((e) => CMsgDOTARealtimeGameStats_ItemDetails.toJSON(e));
    }
    if (message.itemshoppinglist?.length) {
      obj.itemshoppinglist = message.itemshoppinglist.map((e) => CMsgDOTARealtimeGameStats_ItemDetails.toJSON(e));
    }
    if (message.levelpoints?.length) {
      obj.levelpoints = message.levelpoints.map((e) => CMsgDOTARealtimeGameStats_AbilityList.toJSON(e));
    }
    if (message.heroToHeroStats?.length) {
      obj.heroToHeroStats = message.heroToHeroStats.map((e) => CMsgDOTARealtimeGameStats_HeroToHeroStats.toJSON(e));
    }
    if (message.hasUltimate !== undefined && message.hasUltimate !== false) {
      obj.hasUltimate = message.hasUltimate;
    }
    if (message.hasUltimateMana !== undefined && message.hasUltimateMana !== false) {
      obj.hasUltimateMana = message.hasUltimateMana;
    }
    if (message.teamSlot !== undefined && message.teamSlot !== 0) {
      obj.teamSlot = Math.round(message.teamSlot);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTARealtimeGameStats_PlayerDetails>): CMsgDOTARealtimeGameStats_PlayerDetails {
    return CMsgDOTARealtimeGameStats_PlayerDetails.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTARealtimeGameStats_PlayerDetails>): CMsgDOTARealtimeGameStats_PlayerDetails {
    const message = createBaseCMsgDOTARealtimeGameStats_PlayerDetails();
    message.accountid = object.accountid ?? 0;
    message.playerid = object.playerid ?? -1;
    message.name = object.name ?? "";
    message.team = object.team ?? 0;
    message.heroid = object.heroid ?? 0;
    message.healthpoints = object.healthpoints ?? 0;
    message.maxhealthpoints = object.maxhealthpoints ?? 0;
    message.healthregenrate = object.healthregenrate ?? 0;
    message.manapoints = object.manapoints ?? 0;
    message.maxmanapoints = object.maxmanapoints ?? 0;
    message.manaregenrate = object.manaregenrate ?? 0;
    message.baseStrength = object.baseStrength ?? 0;
    message.baseAgility = object.baseAgility ?? 0;
    message.baseIntelligence = object.baseIntelligence ?? 0;
    message.baseArmor = object.baseArmor ?? 0;
    message.baseMovespeed = object.baseMovespeed ?? 0;
    message.baseDamage = object.baseDamage ?? 0;
    message.strength = object.strength ?? 0;
    message.agility = object.agility ?? 0;
    message.intelligence = object.intelligence ?? 0;
    message.armor = object.armor ?? 0;
    message.movespeed = object.movespeed ?? 0;
    message.damage = object.damage ?? 0;
    message.heroDamage = object.heroDamage ?? 0;
    message.towerDamage = object.towerDamage ?? 0;
    message.abilities = object.abilities?.map((e) => CMsgDOTARealtimeGameStats_AbilityDetails.fromPartial(e)) || [];
    message.level = object.level ?? 0;
    message.killCount = object.killCount ?? 0;
    message.deathCount = object.deathCount ?? 0;
    message.assistsCount = object.assistsCount ?? 0;
    message.deniesCount = object.deniesCount ?? 0;
    message.lhCount = object.lhCount ?? 0;
    message.heroHealing = object.heroHealing ?? 0;
    message.goldPerMin = object.goldPerMin ?? 0;
    message.xpPerMin = object.xpPerMin ?? 0;
    message.netGold = object.netGold ?? 0;
    message.gold = object.gold ?? 0;
    message.x = object.x ?? 0;
    message.y = object.y ?? 0;
    message.respawnTime = object.respawnTime ?? 0;
    message.ultimateCooldown = object.ultimateCooldown ?? 0;
    message.hasBuyback = object.hasBuyback ?? false;
    message.items = object.items?.map((e) => CMsgDOTARealtimeGameStats_ItemDetails.fromPartial(e)) || [];
    message.stashitems = object.stashitems?.map((e) => CMsgDOTARealtimeGameStats_ItemDetails.fromPartial(e)) || [];
    message.itemshoppinglist =
      object.itemshoppinglist?.map((e) => CMsgDOTARealtimeGameStats_ItemDetails.fromPartial(e)) || [];
    message.levelpoints = object.levelpoints?.map((e) => CMsgDOTARealtimeGameStats_AbilityList.fromPartial(e)) || [];
    message.heroToHeroStats =
      object.heroToHeroStats?.map((e) => CMsgDOTARealtimeGameStats_HeroToHeroStats.fromPartial(e)) || [];
    message.hasUltimate = object.hasUltimate ?? false;
    message.hasUltimateMana = object.hasUltimateMana ?? false;
    message.teamSlot = object.teamSlot ?? 0;
    return message;
  },
};

function createBaseCMsgDOTARealtimeGameStats_BuildingDetails(): CMsgDOTARealtimeGameStats_BuildingDetails {
  return { team: 0, heading: 0, lane: 0, tier: 0, type: 0, x: 0, y: 0, destroyed: false };
}

export const CMsgDOTARealtimeGameStats_BuildingDetails = {
  encode(message: CMsgDOTARealtimeGameStats_BuildingDetails, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.team !== undefined && message.team !== 0) {
      writer.uint32(16).uint32(message.team);
    }
    if (message.heading !== undefined && message.heading !== 0) {
      writer.uint32(29).float(message.heading);
    }
    if (message.lane !== undefined && message.lane !== 0) {
      writer.uint32(32).uint32(message.lane);
    }
    if (message.tier !== undefined && message.tier !== 0) {
      writer.uint32(40).uint32(message.tier);
    }
    if (message.type !== undefined && message.type !== 0) {
      writer.uint32(48).uint32(message.type);
    }
    if (message.x !== undefined && message.x !== 0) {
      writer.uint32(61).float(message.x);
    }
    if (message.y !== undefined && message.y !== 0) {
      writer.uint32(69).float(message.y);
    }
    if (message.destroyed !== undefined && message.destroyed !== false) {
      writer.uint32(72).bool(message.destroyed);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTARealtimeGameStats_BuildingDetails {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTARealtimeGameStats_BuildingDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 16) {
            break;
          }

          message.team = reader.uint32();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.heading = reader.float();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.lane = reader.uint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.tier = reader.uint32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.type = reader.uint32();
          continue;
        case 7:
          if (tag !== 61) {
            break;
          }

          message.x = reader.float();
          continue;
        case 8:
          if (tag !== 69) {
            break;
          }

          message.y = reader.float();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.destroyed = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTARealtimeGameStats_BuildingDetails {
    return {
      team: isSet(object.team) ? globalThis.Number(object.team) : 0,
      heading: isSet(object.heading) ? globalThis.Number(object.heading) : 0,
      lane: isSet(object.lane) ? globalThis.Number(object.lane) : 0,
      tier: isSet(object.tier) ? globalThis.Number(object.tier) : 0,
      type: isSet(object.type) ? globalThis.Number(object.type) : 0,
      x: isSet(object.x) ? globalThis.Number(object.x) : 0,
      y: isSet(object.y) ? globalThis.Number(object.y) : 0,
      destroyed: isSet(object.destroyed) ? globalThis.Boolean(object.destroyed) : false,
    };
  },

  toJSON(message: CMsgDOTARealtimeGameStats_BuildingDetails): unknown {
    const obj: any = {};
    if (message.team !== undefined && message.team !== 0) {
      obj.team = Math.round(message.team);
    }
    if (message.heading !== undefined && message.heading !== 0) {
      obj.heading = message.heading;
    }
    if (message.lane !== undefined && message.lane !== 0) {
      obj.lane = Math.round(message.lane);
    }
    if (message.tier !== undefined && message.tier !== 0) {
      obj.tier = Math.round(message.tier);
    }
    if (message.type !== undefined && message.type !== 0) {
      obj.type = Math.round(message.type);
    }
    if (message.x !== undefined && message.x !== 0) {
      obj.x = message.x;
    }
    if (message.y !== undefined && message.y !== 0) {
      obj.y = message.y;
    }
    if (message.destroyed !== undefined && message.destroyed !== false) {
      obj.destroyed = message.destroyed;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTARealtimeGameStats_BuildingDetails>): CMsgDOTARealtimeGameStats_BuildingDetails {
    return CMsgDOTARealtimeGameStats_BuildingDetails.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgDOTARealtimeGameStats_BuildingDetails>,
  ): CMsgDOTARealtimeGameStats_BuildingDetails {
    const message = createBaseCMsgDOTARealtimeGameStats_BuildingDetails();
    message.team = object.team ?? 0;
    message.heading = object.heading ?? 0;
    message.lane = object.lane ?? 0;
    message.tier = object.tier ?? 0;
    message.type = object.type ?? 0;
    message.x = object.x ?? 0;
    message.y = object.y ?? 0;
    message.destroyed = object.destroyed ?? false;
    return message;
  },
};

function createBaseCMsgDOTARealtimeGameStats_KillDetails(): CMsgDOTARealtimeGameStats_KillDetails {
  return { playerId: -1, deathTime: 0, killerPlayerId: -1 };
}

export const CMsgDOTARealtimeGameStats_KillDetails = {
  encode(message: CMsgDOTARealtimeGameStats_KillDetails, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.playerId !== undefined && message.playerId !== -1) {
      writer.uint32(8).int32(message.playerId);
    }
    if (message.deathTime !== undefined && message.deathTime !== 0) {
      writer.uint32(16).int32(message.deathTime);
    }
    if (message.killerPlayerId !== undefined && message.killerPlayerId !== -1) {
      writer.uint32(24).int32(message.killerPlayerId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTARealtimeGameStats_KillDetails {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTARealtimeGameStats_KillDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.playerId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.deathTime = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.killerPlayerId = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTARealtimeGameStats_KillDetails {
    return {
      playerId: isSet(object.playerId) ? globalThis.Number(object.playerId) : -1,
      deathTime: isSet(object.deathTime) ? globalThis.Number(object.deathTime) : 0,
      killerPlayerId: isSet(object.killerPlayerId) ? globalThis.Number(object.killerPlayerId) : -1,
    };
  },

  toJSON(message: CMsgDOTARealtimeGameStats_KillDetails): unknown {
    const obj: any = {};
    if (message.playerId !== undefined && message.playerId !== -1) {
      obj.playerId = Math.round(message.playerId);
    }
    if (message.deathTime !== undefined && message.deathTime !== 0) {
      obj.deathTime = Math.round(message.deathTime);
    }
    if (message.killerPlayerId !== undefined && message.killerPlayerId !== -1) {
      obj.killerPlayerId = Math.round(message.killerPlayerId);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTARealtimeGameStats_KillDetails>): CMsgDOTARealtimeGameStats_KillDetails {
    return CMsgDOTARealtimeGameStats_KillDetails.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTARealtimeGameStats_KillDetails>): CMsgDOTARealtimeGameStats_KillDetails {
    const message = createBaseCMsgDOTARealtimeGameStats_KillDetails();
    message.playerId = object.playerId ?? -1;
    message.deathTime = object.deathTime ?? 0;
    message.killerPlayerId = object.killerPlayerId ?? -1;
    return message;
  },
};

function createBaseCMsgDOTARealtimeGameStats_BroadcasterDetails(): CMsgDOTARealtimeGameStats_BroadcasterDetails {
  return { playerId: -1 };
}

export const CMsgDOTARealtimeGameStats_BroadcasterDetails = {
  encode(message: CMsgDOTARealtimeGameStats_BroadcasterDetails, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.playerId !== undefined && message.playerId !== -1) {
      writer.uint32(8).int32(message.playerId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTARealtimeGameStats_BroadcasterDetails {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTARealtimeGameStats_BroadcasterDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.playerId = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTARealtimeGameStats_BroadcasterDetails {
    return { playerId: isSet(object.playerId) ? globalThis.Number(object.playerId) : -1 };
  },

  toJSON(message: CMsgDOTARealtimeGameStats_BroadcasterDetails): unknown {
    const obj: any = {};
    if (message.playerId !== undefined && message.playerId !== -1) {
      obj.playerId = Math.round(message.playerId);
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgDOTARealtimeGameStats_BroadcasterDetails>,
  ): CMsgDOTARealtimeGameStats_BroadcasterDetails {
    return CMsgDOTARealtimeGameStats_BroadcasterDetails.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgDOTARealtimeGameStats_BroadcasterDetails>,
  ): CMsgDOTARealtimeGameStats_BroadcasterDetails {
    const message = createBaseCMsgDOTARealtimeGameStats_BroadcasterDetails();
    message.playerId = object.playerId ?? -1;
    return message;
  },
};

function createBaseCMsgDOTARealtimeGameStats_PickBanDetails(): CMsgDOTARealtimeGameStats_PickBanDetails {
  return { hero: 0, team: 0 };
}

export const CMsgDOTARealtimeGameStats_PickBanDetails = {
  encode(message: CMsgDOTARealtimeGameStats_PickBanDetails, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.hero !== undefined && message.hero !== 0) {
      writer.uint32(8).int32(message.hero);
    }
    if (message.team !== undefined && message.team !== 0) {
      writer.uint32(16).uint32(message.team);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTARealtimeGameStats_PickBanDetails {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTARealtimeGameStats_PickBanDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.hero = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.team = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTARealtimeGameStats_PickBanDetails {
    return {
      hero: isSet(object.hero) ? globalThis.Number(object.hero) : 0,
      team: isSet(object.team) ? globalThis.Number(object.team) : 0,
    };
  },

  toJSON(message: CMsgDOTARealtimeGameStats_PickBanDetails): unknown {
    const obj: any = {};
    if (message.hero !== undefined && message.hero !== 0) {
      obj.hero = Math.round(message.hero);
    }
    if (message.team !== undefined && message.team !== 0) {
      obj.team = Math.round(message.team);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTARealtimeGameStats_PickBanDetails>): CMsgDOTARealtimeGameStats_PickBanDetails {
    return CMsgDOTARealtimeGameStats_PickBanDetails.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTARealtimeGameStats_PickBanDetails>): CMsgDOTARealtimeGameStats_PickBanDetails {
    const message = createBaseCMsgDOTARealtimeGameStats_PickBanDetails();
    message.hero = object.hero ?? 0;
    message.team = object.team ?? 0;
    return message;
  },
};

function createBaseCMsgDOTARealtimeGameStats_MatchDetails(): CMsgDOTARealtimeGameStats_MatchDetails {
  return {
    serverSteamId: "0",
    matchId: "0",
    timestamp: 0,
    timeOfDay: 0,
    isNightstalkerNight: false,
    gameTime: 0,
    gameState: 0,
    teamidRadiant: 0,
    teamidDire: 0,
    picks: [],
    bans: [],
    kills: [],
    broadcasters: [],
    gameMode: 0,
    leagueId: 0,
    leagueNodeId: 0,
    singleTeam: false,
    cheersPeak: 0,
    lobbyType: 0,
    startTimestamp: 0,
    isPlayerDraft: false,
  };
}

export const CMsgDOTARealtimeGameStats_MatchDetails = {
  encode(message: CMsgDOTARealtimeGameStats_MatchDetails, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.serverSteamId !== undefined && message.serverSteamId !== "0") {
      writer.uint32(9).fixed64(message.serverSteamId);
    }
    if (message.matchId !== undefined && message.matchId !== "0") {
      writer.uint32(16).uint64(message.matchId);
    }
    if (message.timestamp !== undefined && message.timestamp !== 0) {
      writer.uint32(24).uint32(message.timestamp);
    }
    if (message.timeOfDay !== undefined && message.timeOfDay !== 0) {
      writer.uint32(37).float(message.timeOfDay);
    }
    if (message.isNightstalkerNight !== undefined && message.isNightstalkerNight !== false) {
      writer.uint32(40).bool(message.isNightstalkerNight);
    }
    if (message.gameTime !== undefined && message.gameTime !== 0) {
      writer.uint32(48).int32(message.gameTime);
    }
    if (message.gameState !== undefined && message.gameState !== 0) {
      writer.uint32(152).uint32(message.gameState);
    }
    if (message.teamidRadiant !== undefined && message.teamidRadiant !== 0) {
      writer.uint32(64).uint32(message.teamidRadiant);
    }
    if (message.teamidDire !== undefined && message.teamidDire !== 0) {
      writer.uint32(72).uint32(message.teamidDire);
    }
    for (const v of message.picks) {
      CMsgDOTARealtimeGameStats_PickBanDetails.encode(v!, writer.uint32(82).fork()).ldelim();
    }
    for (const v of message.bans) {
      CMsgDOTARealtimeGameStats_PickBanDetails.encode(v!, writer.uint32(90).fork()).ldelim();
    }
    for (const v of message.kills) {
      CMsgDOTARealtimeGameStats_KillDetails.encode(v!, writer.uint32(98).fork()).ldelim();
    }
    for (const v of message.broadcasters) {
      CMsgDOTARealtimeGameStats_BroadcasterDetails.encode(v!, writer.uint32(106).fork()).ldelim();
    }
    if (message.gameMode !== undefined && message.gameMode !== 0) {
      writer.uint32(112).uint32(message.gameMode);
    }
    if (message.leagueId !== undefined && message.leagueId !== 0) {
      writer.uint32(120).uint32(message.leagueId);
    }
    if (message.leagueNodeId !== undefined && message.leagueNodeId !== 0) {
      writer.uint32(144).uint32(message.leagueNodeId);
    }
    if (message.singleTeam !== undefined && message.singleTeam !== false) {
      writer.uint32(128).bool(message.singleTeam);
    }
    if (message.cheersPeak !== undefined && message.cheersPeak !== 0) {
      writer.uint32(136).uint32(message.cheersPeak);
    }
    if (message.lobbyType !== undefined && message.lobbyType !== 0) {
      writer.uint32(160).uint32(message.lobbyType);
    }
    if (message.startTimestamp !== undefined && message.startTimestamp !== 0) {
      writer.uint32(168).uint32(message.startTimestamp);
    }
    if (message.isPlayerDraft !== undefined && message.isPlayerDraft !== false) {
      writer.uint32(176).bool(message.isPlayerDraft);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTARealtimeGameStats_MatchDetails {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTARealtimeGameStats_MatchDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.serverSteamId = longToString(reader.fixed64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.matchId = longToString(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.timestamp = reader.uint32();
          continue;
        case 4:
          if (tag !== 37) {
            break;
          }

          message.timeOfDay = reader.float();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.isNightstalkerNight = reader.bool();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.gameTime = reader.int32();
          continue;
        case 19:
          if (tag !== 152) {
            break;
          }

          message.gameState = reader.uint32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.teamidRadiant = reader.uint32();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.teamidDire = reader.uint32();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.picks.push(CMsgDOTARealtimeGameStats_PickBanDetails.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.bans.push(CMsgDOTARealtimeGameStats_PickBanDetails.decode(reader, reader.uint32()));
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.kills.push(CMsgDOTARealtimeGameStats_KillDetails.decode(reader, reader.uint32()));
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.broadcasters.push(CMsgDOTARealtimeGameStats_BroadcasterDetails.decode(reader, reader.uint32()));
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.gameMode = reader.uint32();
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.leagueId = reader.uint32();
          continue;
        case 18:
          if (tag !== 144) {
            break;
          }

          message.leagueNodeId = reader.uint32();
          continue;
        case 16:
          if (tag !== 128) {
            break;
          }

          message.singleTeam = reader.bool();
          continue;
        case 17:
          if (tag !== 136) {
            break;
          }

          message.cheersPeak = reader.uint32();
          continue;
        case 20:
          if (tag !== 160) {
            break;
          }

          message.lobbyType = reader.uint32();
          continue;
        case 21:
          if (tag !== 168) {
            break;
          }

          message.startTimestamp = reader.uint32();
          continue;
        case 22:
          if (tag !== 176) {
            break;
          }

          message.isPlayerDraft = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTARealtimeGameStats_MatchDetails {
    return {
      serverSteamId: isSet(object.serverSteamId) ? globalThis.String(object.serverSteamId) : "0",
      matchId: isSet(object.matchId) ? globalThis.String(object.matchId) : "0",
      timestamp: isSet(object.timestamp) ? globalThis.Number(object.timestamp) : 0,
      timeOfDay: isSet(object.timeOfDay) ? globalThis.Number(object.timeOfDay) : 0,
      isNightstalkerNight: isSet(object.isNightstalkerNight) ? globalThis.Boolean(object.isNightstalkerNight) : false,
      gameTime: isSet(object.gameTime) ? globalThis.Number(object.gameTime) : 0,
      gameState: isSet(object.gameState) ? globalThis.Number(object.gameState) : 0,
      teamidRadiant: isSet(object.teamidRadiant) ? globalThis.Number(object.teamidRadiant) : 0,
      teamidDire: isSet(object.teamidDire) ? globalThis.Number(object.teamidDire) : 0,
      picks: globalThis.Array.isArray(object?.picks)
        ? object.picks.map((e: any) => CMsgDOTARealtimeGameStats_PickBanDetails.fromJSON(e))
        : [],
      bans: globalThis.Array.isArray(object?.bans)
        ? object.bans.map((e: any) => CMsgDOTARealtimeGameStats_PickBanDetails.fromJSON(e))
        : [],
      kills: globalThis.Array.isArray(object?.kills)
        ? object.kills.map((e: any) => CMsgDOTARealtimeGameStats_KillDetails.fromJSON(e))
        : [],
      broadcasters: globalThis.Array.isArray(object?.broadcasters)
        ? object.broadcasters.map((e: any) => CMsgDOTARealtimeGameStats_BroadcasterDetails.fromJSON(e))
        : [],
      gameMode: isSet(object.gameMode) ? globalThis.Number(object.gameMode) : 0,
      leagueId: isSet(object.leagueId) ? globalThis.Number(object.leagueId) : 0,
      leagueNodeId: isSet(object.leagueNodeId) ? globalThis.Number(object.leagueNodeId) : 0,
      singleTeam: isSet(object.singleTeam) ? globalThis.Boolean(object.singleTeam) : false,
      cheersPeak: isSet(object.cheersPeak) ? globalThis.Number(object.cheersPeak) : 0,
      lobbyType: isSet(object.lobbyType) ? globalThis.Number(object.lobbyType) : 0,
      startTimestamp: isSet(object.startTimestamp) ? globalThis.Number(object.startTimestamp) : 0,
      isPlayerDraft: isSet(object.isPlayerDraft) ? globalThis.Boolean(object.isPlayerDraft) : false,
    };
  },

  toJSON(message: CMsgDOTARealtimeGameStats_MatchDetails): unknown {
    const obj: any = {};
    if (message.serverSteamId !== undefined && message.serverSteamId !== "0") {
      obj.serverSteamId = message.serverSteamId;
    }
    if (message.matchId !== undefined && message.matchId !== "0") {
      obj.matchId = message.matchId;
    }
    if (message.timestamp !== undefined && message.timestamp !== 0) {
      obj.timestamp = Math.round(message.timestamp);
    }
    if (message.timeOfDay !== undefined && message.timeOfDay !== 0) {
      obj.timeOfDay = message.timeOfDay;
    }
    if (message.isNightstalkerNight !== undefined && message.isNightstalkerNight !== false) {
      obj.isNightstalkerNight = message.isNightstalkerNight;
    }
    if (message.gameTime !== undefined && message.gameTime !== 0) {
      obj.gameTime = Math.round(message.gameTime);
    }
    if (message.gameState !== undefined && message.gameState !== 0) {
      obj.gameState = Math.round(message.gameState);
    }
    if (message.teamidRadiant !== undefined && message.teamidRadiant !== 0) {
      obj.teamidRadiant = Math.round(message.teamidRadiant);
    }
    if (message.teamidDire !== undefined && message.teamidDire !== 0) {
      obj.teamidDire = Math.round(message.teamidDire);
    }
    if (message.picks?.length) {
      obj.picks = message.picks.map((e) => CMsgDOTARealtimeGameStats_PickBanDetails.toJSON(e));
    }
    if (message.bans?.length) {
      obj.bans = message.bans.map((e) => CMsgDOTARealtimeGameStats_PickBanDetails.toJSON(e));
    }
    if (message.kills?.length) {
      obj.kills = message.kills.map((e) => CMsgDOTARealtimeGameStats_KillDetails.toJSON(e));
    }
    if (message.broadcasters?.length) {
      obj.broadcasters = message.broadcasters.map((e) => CMsgDOTARealtimeGameStats_BroadcasterDetails.toJSON(e));
    }
    if (message.gameMode !== undefined && message.gameMode !== 0) {
      obj.gameMode = Math.round(message.gameMode);
    }
    if (message.leagueId !== undefined && message.leagueId !== 0) {
      obj.leagueId = Math.round(message.leagueId);
    }
    if (message.leagueNodeId !== undefined && message.leagueNodeId !== 0) {
      obj.leagueNodeId = Math.round(message.leagueNodeId);
    }
    if (message.singleTeam !== undefined && message.singleTeam !== false) {
      obj.singleTeam = message.singleTeam;
    }
    if (message.cheersPeak !== undefined && message.cheersPeak !== 0) {
      obj.cheersPeak = Math.round(message.cheersPeak);
    }
    if (message.lobbyType !== undefined && message.lobbyType !== 0) {
      obj.lobbyType = Math.round(message.lobbyType);
    }
    if (message.startTimestamp !== undefined && message.startTimestamp !== 0) {
      obj.startTimestamp = Math.round(message.startTimestamp);
    }
    if (message.isPlayerDraft !== undefined && message.isPlayerDraft !== false) {
      obj.isPlayerDraft = message.isPlayerDraft;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTARealtimeGameStats_MatchDetails>): CMsgDOTARealtimeGameStats_MatchDetails {
    return CMsgDOTARealtimeGameStats_MatchDetails.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTARealtimeGameStats_MatchDetails>): CMsgDOTARealtimeGameStats_MatchDetails {
    const message = createBaseCMsgDOTARealtimeGameStats_MatchDetails();
    message.serverSteamId = object.serverSteamId ?? "0";
    message.matchId = object.matchId ?? "0";
    message.timestamp = object.timestamp ?? 0;
    message.timeOfDay = object.timeOfDay ?? 0;
    message.isNightstalkerNight = object.isNightstalkerNight ?? false;
    message.gameTime = object.gameTime ?? 0;
    message.gameState = object.gameState ?? 0;
    message.teamidRadiant = object.teamidRadiant ?? 0;
    message.teamidDire = object.teamidDire ?? 0;
    message.picks = object.picks?.map((e) => CMsgDOTARealtimeGameStats_PickBanDetails.fromPartial(e)) || [];
    message.bans = object.bans?.map((e) => CMsgDOTARealtimeGameStats_PickBanDetails.fromPartial(e)) || [];
    message.kills = object.kills?.map((e) => CMsgDOTARealtimeGameStats_KillDetails.fromPartial(e)) || [];
    message.broadcasters =
      object.broadcasters?.map((e) => CMsgDOTARealtimeGameStats_BroadcasterDetails.fromPartial(e)) || [];
    message.gameMode = object.gameMode ?? 0;
    message.leagueId = object.leagueId ?? 0;
    message.leagueNodeId = object.leagueNodeId ?? 0;
    message.singleTeam = object.singleTeam ?? false;
    message.cheersPeak = object.cheersPeak ?? 0;
    message.lobbyType = object.lobbyType ?? 0;
    message.startTimestamp = object.startTimestamp ?? 0;
    message.isPlayerDraft = object.isPlayerDraft ?? false;
    return message;
  },
};

function createBaseCMsgDOTARealtimeGameStats_GraphData(): CMsgDOTARealtimeGameStats_GraphData {
  return { graphGold: [], graphXp: [], graphKill: [], graphTower: [], graphRax: [], teamLocStats: [] };
}

export const CMsgDOTARealtimeGameStats_GraphData = {
  encode(message: CMsgDOTARealtimeGameStats_GraphData, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.graphGold) {
      writer.int32(v);
    }
    writer.ldelim();
    writer.uint32(18).fork();
    for (const v of message.graphXp) {
      writer.int32(v);
    }
    writer.ldelim();
    writer.uint32(26).fork();
    for (const v of message.graphKill) {
      writer.int32(v);
    }
    writer.ldelim();
    writer.uint32(34).fork();
    for (const v of message.graphTower) {
      writer.int32(v);
    }
    writer.ldelim();
    writer.uint32(42).fork();
    for (const v of message.graphRax) {
      writer.int32(v);
    }
    writer.ldelim();
    for (const v of message.teamLocStats) {
      CMsgDOTARealtimeGameStats_GraphData_TeamLocationStats.encode(v!, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTARealtimeGameStats_GraphData {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTARealtimeGameStats_GraphData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.graphGold.push(reader.int32());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.graphGold.push(reader.int32());
            }

            continue;
          }

          break;
        case 2:
          if (tag === 16) {
            message.graphXp.push(reader.int32());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.graphXp.push(reader.int32());
            }

            continue;
          }

          break;
        case 3:
          if (tag === 24) {
            message.graphKill.push(reader.int32());

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.graphKill.push(reader.int32());
            }

            continue;
          }

          break;
        case 4:
          if (tag === 32) {
            message.graphTower.push(reader.int32());

            continue;
          }

          if (tag === 34) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.graphTower.push(reader.int32());
            }

            continue;
          }

          break;
        case 5:
          if (tag === 40) {
            message.graphRax.push(reader.int32());

            continue;
          }

          if (tag === 42) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.graphRax.push(reader.int32());
            }

            continue;
          }

          break;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.teamLocStats.push(
            CMsgDOTARealtimeGameStats_GraphData_TeamLocationStats.decode(reader, reader.uint32()),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTARealtimeGameStats_GraphData {
    return {
      graphGold: globalThis.Array.isArray(object?.graphGold)
        ? object.graphGold.map((e: any) => globalThis.Number(e))
        : [],
      graphXp: globalThis.Array.isArray(object?.graphXp) ? object.graphXp.map((e: any) => globalThis.Number(e)) : [],
      graphKill: globalThis.Array.isArray(object?.graphKill)
        ? object.graphKill.map((e: any) => globalThis.Number(e))
        : [],
      graphTower: globalThis.Array.isArray(object?.graphTower)
        ? object.graphTower.map((e: any) => globalThis.Number(e))
        : [],
      graphRax: globalThis.Array.isArray(object?.graphRax) ? object.graphRax.map((e: any) => globalThis.Number(e)) : [],
      teamLocStats: globalThis.Array.isArray(object?.teamLocStats)
        ? object.teamLocStats.map((e: any) => CMsgDOTARealtimeGameStats_GraphData_TeamLocationStats.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgDOTARealtimeGameStats_GraphData): unknown {
    const obj: any = {};
    if (message.graphGold?.length) {
      obj.graphGold = message.graphGold.map((e) => Math.round(e));
    }
    if (message.graphXp?.length) {
      obj.graphXp = message.graphXp.map((e) => Math.round(e));
    }
    if (message.graphKill?.length) {
      obj.graphKill = message.graphKill.map((e) => Math.round(e));
    }
    if (message.graphTower?.length) {
      obj.graphTower = message.graphTower.map((e) => Math.round(e));
    }
    if (message.graphRax?.length) {
      obj.graphRax = message.graphRax.map((e) => Math.round(e));
    }
    if (message.teamLocStats?.length) {
      obj.teamLocStats = message.teamLocStats.map((e) =>
        CMsgDOTARealtimeGameStats_GraphData_TeamLocationStats.toJSON(e)
      );
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTARealtimeGameStats_GraphData>): CMsgDOTARealtimeGameStats_GraphData {
    return CMsgDOTARealtimeGameStats_GraphData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTARealtimeGameStats_GraphData>): CMsgDOTARealtimeGameStats_GraphData {
    const message = createBaseCMsgDOTARealtimeGameStats_GraphData();
    message.graphGold = object.graphGold?.map((e) => e) || [];
    message.graphXp = object.graphXp?.map((e) => e) || [];
    message.graphKill = object.graphKill?.map((e) => e) || [];
    message.graphTower = object.graphTower?.map((e) => e) || [];
    message.graphRax = object.graphRax?.map((e) => e) || [];
    message.teamLocStats =
      object.teamLocStats?.map((e) => CMsgDOTARealtimeGameStats_GraphData_TeamLocationStats.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgDOTARealtimeGameStats_GraphData_LocationStats(): CMsgDOTARealtimeGameStats_GraphData_LocationStats {
  return { stats: [] };
}

export const CMsgDOTARealtimeGameStats_GraphData_LocationStats = {
  encode(
    message: CMsgDOTARealtimeGameStats_GraphData_LocationStats,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.stats) {
      writer.int32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTARealtimeGameStats_GraphData_LocationStats {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTARealtimeGameStats_GraphData_LocationStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.stats.push(reader.int32());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.stats.push(reader.int32());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTARealtimeGameStats_GraphData_LocationStats {
    return { stats: globalThis.Array.isArray(object?.stats) ? object.stats.map((e: any) => globalThis.Number(e)) : [] };
  },

  toJSON(message: CMsgDOTARealtimeGameStats_GraphData_LocationStats): unknown {
    const obj: any = {};
    if (message.stats?.length) {
      obj.stats = message.stats.map((e) => Math.round(e));
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgDOTARealtimeGameStats_GraphData_LocationStats>,
  ): CMsgDOTARealtimeGameStats_GraphData_LocationStats {
    return CMsgDOTARealtimeGameStats_GraphData_LocationStats.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgDOTARealtimeGameStats_GraphData_LocationStats>,
  ): CMsgDOTARealtimeGameStats_GraphData_LocationStats {
    const message = createBaseCMsgDOTARealtimeGameStats_GraphData_LocationStats();
    message.stats = object.stats?.map((e) => e) || [];
    return message;
  },
};

function createBaseCMsgDOTARealtimeGameStats_GraphData_TeamLocationStats(): CMsgDOTARealtimeGameStats_GraphData_TeamLocationStats {
  return { locStats: [] };
}

export const CMsgDOTARealtimeGameStats_GraphData_TeamLocationStats = {
  encode(
    message: CMsgDOTARealtimeGameStats_GraphData_TeamLocationStats,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    for (const v of message.locStats) {
      CMsgDOTARealtimeGameStats_GraphData_LocationStats.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTARealtimeGameStats_GraphData_TeamLocationStats {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTARealtimeGameStats_GraphData_TeamLocationStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.locStats.push(CMsgDOTARealtimeGameStats_GraphData_LocationStats.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTARealtimeGameStats_GraphData_TeamLocationStats {
    return {
      locStats: globalThis.Array.isArray(object?.locStats)
        ? object.locStats.map((e: any) => CMsgDOTARealtimeGameStats_GraphData_LocationStats.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgDOTARealtimeGameStats_GraphData_TeamLocationStats): unknown {
    const obj: any = {};
    if (message.locStats?.length) {
      obj.locStats = message.locStats.map((e) => CMsgDOTARealtimeGameStats_GraphData_LocationStats.toJSON(e));
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgDOTARealtimeGameStats_GraphData_TeamLocationStats>,
  ): CMsgDOTARealtimeGameStats_GraphData_TeamLocationStats {
    return CMsgDOTARealtimeGameStats_GraphData_TeamLocationStats.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgDOTARealtimeGameStats_GraphData_TeamLocationStats>,
  ): CMsgDOTARealtimeGameStats_GraphData_TeamLocationStats {
    const message = createBaseCMsgDOTARealtimeGameStats_GraphData_TeamLocationStats();
    message.locStats = object.locStats?.map((e) => CMsgDOTARealtimeGameStats_GraphData_LocationStats.fromPartial(e)) ||
      [];
    return message;
  },
};

function createBaseCMsgDOTARealtimeGameStatsTerse(): CMsgDOTARealtimeGameStatsTerse {
  return { match: undefined, teams: [], buildings: [], graphData: undefined, deltaFrame: false };
}

export const CMsgDOTARealtimeGameStatsTerse = {
  encode(message: CMsgDOTARealtimeGameStatsTerse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.match !== undefined) {
      CMsgDOTARealtimeGameStatsTerse_MatchDetails.encode(message.match, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.teams) {
      CMsgDOTARealtimeGameStatsTerse_TeamDetails.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.buildings) {
      CMsgDOTARealtimeGameStatsTerse_BuildingDetails.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    if (message.graphData !== undefined) {
      CMsgDOTARealtimeGameStatsTerse_GraphData.encode(message.graphData, writer.uint32(34).fork()).ldelim();
    }
    if (message.deltaFrame !== undefined && message.deltaFrame !== false) {
      writer.uint32(40).bool(message.deltaFrame);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTARealtimeGameStatsTerse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTARealtimeGameStatsTerse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.match = CMsgDOTARealtimeGameStatsTerse_MatchDetails.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.teams.push(CMsgDOTARealtimeGameStatsTerse_TeamDetails.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.buildings.push(CMsgDOTARealtimeGameStatsTerse_BuildingDetails.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.graphData = CMsgDOTARealtimeGameStatsTerse_GraphData.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.deltaFrame = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTARealtimeGameStatsTerse {
    return {
      match: isSet(object.match) ? CMsgDOTARealtimeGameStatsTerse_MatchDetails.fromJSON(object.match) : undefined,
      teams: globalThis.Array.isArray(object?.teams)
        ? object.teams.map((e: any) => CMsgDOTARealtimeGameStatsTerse_TeamDetails.fromJSON(e))
        : [],
      buildings: globalThis.Array.isArray(object?.buildings)
        ? object.buildings.map((e: any) => CMsgDOTARealtimeGameStatsTerse_BuildingDetails.fromJSON(e))
        : [],
      graphData: isSet(object.graphData)
        ? CMsgDOTARealtimeGameStatsTerse_GraphData.fromJSON(object.graphData)
        : undefined,
      deltaFrame: isSet(object.deltaFrame) ? globalThis.Boolean(object.deltaFrame) : false,
    };
  },

  toJSON(message: CMsgDOTARealtimeGameStatsTerse): unknown {
    const obj: any = {};
    if (message.match !== undefined) {
      obj.match = CMsgDOTARealtimeGameStatsTerse_MatchDetails.toJSON(message.match);
    }
    if (message.teams?.length) {
      obj.teams = message.teams.map((e) => CMsgDOTARealtimeGameStatsTerse_TeamDetails.toJSON(e));
    }
    if (message.buildings?.length) {
      obj.buildings = message.buildings.map((e) => CMsgDOTARealtimeGameStatsTerse_BuildingDetails.toJSON(e));
    }
    if (message.graphData !== undefined) {
      obj.graphData = CMsgDOTARealtimeGameStatsTerse_GraphData.toJSON(message.graphData);
    }
    if (message.deltaFrame !== undefined && message.deltaFrame !== false) {
      obj.deltaFrame = message.deltaFrame;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTARealtimeGameStatsTerse>): CMsgDOTARealtimeGameStatsTerse {
    return CMsgDOTARealtimeGameStatsTerse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTARealtimeGameStatsTerse>): CMsgDOTARealtimeGameStatsTerse {
    const message = createBaseCMsgDOTARealtimeGameStatsTerse();
    message.match = (object.match !== undefined && object.match !== null)
      ? CMsgDOTARealtimeGameStatsTerse_MatchDetails.fromPartial(object.match)
      : undefined;
    message.teams = object.teams?.map((e) => CMsgDOTARealtimeGameStatsTerse_TeamDetails.fromPartial(e)) || [];
    message.buildings = object.buildings?.map((e) => CMsgDOTARealtimeGameStatsTerse_BuildingDetails.fromPartial(e)) ||
      [];
    message.graphData = (object.graphData !== undefined && object.graphData !== null)
      ? CMsgDOTARealtimeGameStatsTerse_GraphData.fromPartial(object.graphData)
      : undefined;
    message.deltaFrame = object.deltaFrame ?? false;
    return message;
  },
};

function createBaseCMsgDOTARealtimeGameStatsTerse_TeamDetails(): CMsgDOTARealtimeGameStatsTerse_TeamDetails {
  return {
    teamNumber: 0,
    teamId: 0,
    teamName: "",
    teamTag: "",
    teamLogo: "0",
    score: 0,
    netWorth: 0,
    teamLogoUrl: "",
    players: [],
  };
}

export const CMsgDOTARealtimeGameStatsTerse_TeamDetails = {
  encode(message: CMsgDOTARealtimeGameStatsTerse_TeamDetails, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.teamNumber !== undefined && message.teamNumber !== 0) {
      writer.uint32(8).uint32(message.teamNumber);
    }
    if (message.teamId !== undefined && message.teamId !== 0) {
      writer.uint32(16).uint32(message.teamId);
    }
    if (message.teamName !== undefined && message.teamName !== "") {
      writer.uint32(26).string(message.teamName);
    }
    if (message.teamTag !== undefined && message.teamTag !== "") {
      writer.uint32(66).string(message.teamTag);
    }
    if (message.teamLogo !== undefined && message.teamLogo !== "0") {
      writer.uint32(33).fixed64(message.teamLogo);
    }
    if (message.score !== undefined && message.score !== 0) {
      writer.uint32(40).uint32(message.score);
    }
    if (message.netWorth !== undefined && message.netWorth !== 0) {
      writer.uint32(56).uint32(message.netWorth);
    }
    if (message.teamLogoUrl !== undefined && message.teamLogoUrl !== "") {
      writer.uint32(74).string(message.teamLogoUrl);
    }
    for (const v of message.players) {
      CMsgDOTARealtimeGameStatsTerse_PlayerDetails.encode(v!, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTARealtimeGameStatsTerse_TeamDetails {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTARealtimeGameStatsTerse_TeamDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.teamNumber = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.teamId = reader.uint32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.teamName = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.teamTag = reader.string();
          continue;
        case 4:
          if (tag !== 33) {
            break;
          }

          message.teamLogo = longToString(reader.fixed64() as Long);
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.score = reader.uint32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.netWorth = reader.uint32();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.teamLogoUrl = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.players.push(CMsgDOTARealtimeGameStatsTerse_PlayerDetails.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTARealtimeGameStatsTerse_TeamDetails {
    return {
      teamNumber: isSet(object.teamNumber) ? globalThis.Number(object.teamNumber) : 0,
      teamId: isSet(object.teamId) ? globalThis.Number(object.teamId) : 0,
      teamName: isSet(object.teamName) ? globalThis.String(object.teamName) : "",
      teamTag: isSet(object.teamTag) ? globalThis.String(object.teamTag) : "",
      teamLogo: isSet(object.teamLogo) ? globalThis.String(object.teamLogo) : "0",
      score: isSet(object.score) ? globalThis.Number(object.score) : 0,
      netWorth: isSet(object.netWorth) ? globalThis.Number(object.netWorth) : 0,
      teamLogoUrl: isSet(object.teamLogoUrl) ? globalThis.String(object.teamLogoUrl) : "",
      players: globalThis.Array.isArray(object?.players)
        ? object.players.map((e: any) => CMsgDOTARealtimeGameStatsTerse_PlayerDetails.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgDOTARealtimeGameStatsTerse_TeamDetails): unknown {
    const obj: any = {};
    if (message.teamNumber !== undefined && message.teamNumber !== 0) {
      obj.teamNumber = Math.round(message.teamNumber);
    }
    if (message.teamId !== undefined && message.teamId !== 0) {
      obj.teamId = Math.round(message.teamId);
    }
    if (message.teamName !== undefined && message.teamName !== "") {
      obj.teamName = message.teamName;
    }
    if (message.teamTag !== undefined && message.teamTag !== "") {
      obj.teamTag = message.teamTag;
    }
    if (message.teamLogo !== undefined && message.teamLogo !== "0") {
      obj.teamLogo = message.teamLogo;
    }
    if (message.score !== undefined && message.score !== 0) {
      obj.score = Math.round(message.score);
    }
    if (message.netWorth !== undefined && message.netWorth !== 0) {
      obj.netWorth = Math.round(message.netWorth);
    }
    if (message.teamLogoUrl !== undefined && message.teamLogoUrl !== "") {
      obj.teamLogoUrl = message.teamLogoUrl;
    }
    if (message.players?.length) {
      obj.players = message.players.map((e) => CMsgDOTARealtimeGameStatsTerse_PlayerDetails.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTARealtimeGameStatsTerse_TeamDetails>): CMsgDOTARealtimeGameStatsTerse_TeamDetails {
    return CMsgDOTARealtimeGameStatsTerse_TeamDetails.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgDOTARealtimeGameStatsTerse_TeamDetails>,
  ): CMsgDOTARealtimeGameStatsTerse_TeamDetails {
    const message = createBaseCMsgDOTARealtimeGameStatsTerse_TeamDetails();
    message.teamNumber = object.teamNumber ?? 0;
    message.teamId = object.teamId ?? 0;
    message.teamName = object.teamName ?? "";
    message.teamTag = object.teamTag ?? "";
    message.teamLogo = object.teamLogo ?? "0";
    message.score = object.score ?? 0;
    message.netWorth = object.netWorth ?? 0;
    message.teamLogoUrl = object.teamLogoUrl ?? "";
    message.players = object.players?.map((e) => CMsgDOTARealtimeGameStatsTerse_PlayerDetails.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgDOTARealtimeGameStatsTerse_PlayerDetails(): CMsgDOTARealtimeGameStatsTerse_PlayerDetails {
  return {
    accountid: 0,
    playerid: -1,
    name: "",
    team: 0,
    heroid: 0,
    level: 0,
    killCount: 0,
    deathCount: 0,
    assistsCount: 0,
    deniesCount: 0,
    lhCount: 0,
    gold: 0,
    x: 0,
    y: 0,
    netWorth: 0,
    abilities: [],
    items: [],
    teamSlot: 0,
  };
}

export const CMsgDOTARealtimeGameStatsTerse_PlayerDetails = {
  encode(message: CMsgDOTARealtimeGameStatsTerse_PlayerDetails, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.accountid !== undefined && message.accountid !== 0) {
      writer.uint32(8).uint32(message.accountid);
    }
    if (message.playerid !== undefined && message.playerid !== -1) {
      writer.uint32(16).int32(message.playerid);
    }
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.team !== undefined && message.team !== 0) {
      writer.uint32(32).uint32(message.team);
    }
    if (message.heroid !== undefined && message.heroid !== 0) {
      writer.uint32(40).int32(message.heroid);
    }
    if (message.level !== undefined && message.level !== 0) {
      writer.uint32(48).uint32(message.level);
    }
    if (message.killCount !== undefined && message.killCount !== 0) {
      writer.uint32(56).uint32(message.killCount);
    }
    if (message.deathCount !== undefined && message.deathCount !== 0) {
      writer.uint32(64).uint32(message.deathCount);
    }
    if (message.assistsCount !== undefined && message.assistsCount !== 0) {
      writer.uint32(72).uint32(message.assistsCount);
    }
    if (message.deniesCount !== undefined && message.deniesCount !== 0) {
      writer.uint32(80).uint32(message.deniesCount);
    }
    if (message.lhCount !== undefined && message.lhCount !== 0) {
      writer.uint32(88).uint32(message.lhCount);
    }
    if (message.gold !== undefined && message.gold !== 0) {
      writer.uint32(96).uint32(message.gold);
    }
    if (message.x !== undefined && message.x !== 0) {
      writer.uint32(109).float(message.x);
    }
    if (message.y !== undefined && message.y !== 0) {
      writer.uint32(117).float(message.y);
    }
    if (message.netWorth !== undefined && message.netWorth !== 0) {
      writer.uint32(120).uint32(message.netWorth);
    }
    writer.uint32(130).fork();
    for (const v of message.abilities) {
      writer.int32(v);
    }
    writer.ldelim();
    writer.uint32(138).fork();
    for (const v of message.items) {
      writer.int32(v);
    }
    writer.ldelim();
    if (message.teamSlot !== undefined && message.teamSlot !== 0) {
      writer.uint32(144).uint32(message.teamSlot);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTARealtimeGameStatsTerse_PlayerDetails {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTARealtimeGameStatsTerse_PlayerDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.accountid = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.playerid = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.team = reader.uint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.heroid = reader.int32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.level = reader.uint32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.killCount = reader.uint32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.deathCount = reader.uint32();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.assistsCount = reader.uint32();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.deniesCount = reader.uint32();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.lhCount = reader.uint32();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.gold = reader.uint32();
          continue;
        case 13:
          if (tag !== 109) {
            break;
          }

          message.x = reader.float();
          continue;
        case 14:
          if (tag !== 117) {
            break;
          }

          message.y = reader.float();
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.netWorth = reader.uint32();
          continue;
        case 16:
          if (tag === 128) {
            message.abilities.push(reader.int32());

            continue;
          }

          if (tag === 130) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.abilities.push(reader.int32());
            }

            continue;
          }

          break;
        case 17:
          if (tag === 136) {
            message.items.push(reader.int32());

            continue;
          }

          if (tag === 138) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.items.push(reader.int32());
            }

            continue;
          }

          break;
        case 18:
          if (tag !== 144) {
            break;
          }

          message.teamSlot = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTARealtimeGameStatsTerse_PlayerDetails {
    return {
      accountid: isSet(object.accountid) ? globalThis.Number(object.accountid) : 0,
      playerid: isSet(object.playerid) ? globalThis.Number(object.playerid) : -1,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      team: isSet(object.team) ? globalThis.Number(object.team) : 0,
      heroid: isSet(object.heroid) ? globalThis.Number(object.heroid) : 0,
      level: isSet(object.level) ? globalThis.Number(object.level) : 0,
      killCount: isSet(object.killCount) ? globalThis.Number(object.killCount) : 0,
      deathCount: isSet(object.deathCount) ? globalThis.Number(object.deathCount) : 0,
      assistsCount: isSet(object.assistsCount) ? globalThis.Number(object.assistsCount) : 0,
      deniesCount: isSet(object.deniesCount) ? globalThis.Number(object.deniesCount) : 0,
      lhCount: isSet(object.lhCount) ? globalThis.Number(object.lhCount) : 0,
      gold: isSet(object.gold) ? globalThis.Number(object.gold) : 0,
      x: isSet(object.x) ? globalThis.Number(object.x) : 0,
      y: isSet(object.y) ? globalThis.Number(object.y) : 0,
      netWorth: isSet(object.netWorth) ? globalThis.Number(object.netWorth) : 0,
      abilities: globalThis.Array.isArray(object?.abilities)
        ? object.abilities.map((e: any) => globalThis.Number(e))
        : [],
      items: globalThis.Array.isArray(object?.items) ? object.items.map((e: any) => globalThis.Number(e)) : [],
      teamSlot: isSet(object.teamSlot) ? globalThis.Number(object.teamSlot) : 0,
    };
  },

  toJSON(message: CMsgDOTARealtimeGameStatsTerse_PlayerDetails): unknown {
    const obj: any = {};
    if (message.accountid !== undefined && message.accountid !== 0) {
      obj.accountid = Math.round(message.accountid);
    }
    if (message.playerid !== undefined && message.playerid !== -1) {
      obj.playerid = Math.round(message.playerid);
    }
    if (message.name !== undefined && message.name !== "") {
      obj.name = message.name;
    }
    if (message.team !== undefined && message.team !== 0) {
      obj.team = Math.round(message.team);
    }
    if (message.heroid !== undefined && message.heroid !== 0) {
      obj.heroid = Math.round(message.heroid);
    }
    if (message.level !== undefined && message.level !== 0) {
      obj.level = Math.round(message.level);
    }
    if (message.killCount !== undefined && message.killCount !== 0) {
      obj.killCount = Math.round(message.killCount);
    }
    if (message.deathCount !== undefined && message.deathCount !== 0) {
      obj.deathCount = Math.round(message.deathCount);
    }
    if (message.assistsCount !== undefined && message.assistsCount !== 0) {
      obj.assistsCount = Math.round(message.assistsCount);
    }
    if (message.deniesCount !== undefined && message.deniesCount !== 0) {
      obj.deniesCount = Math.round(message.deniesCount);
    }
    if (message.lhCount !== undefined && message.lhCount !== 0) {
      obj.lhCount = Math.round(message.lhCount);
    }
    if (message.gold !== undefined && message.gold !== 0) {
      obj.gold = Math.round(message.gold);
    }
    if (message.x !== undefined && message.x !== 0) {
      obj.x = message.x;
    }
    if (message.y !== undefined && message.y !== 0) {
      obj.y = message.y;
    }
    if (message.netWorth !== undefined && message.netWorth !== 0) {
      obj.netWorth = Math.round(message.netWorth);
    }
    if (message.abilities?.length) {
      obj.abilities = message.abilities.map((e) => Math.round(e));
    }
    if (message.items?.length) {
      obj.items = message.items.map((e) => Math.round(e));
    }
    if (message.teamSlot !== undefined && message.teamSlot !== 0) {
      obj.teamSlot = Math.round(message.teamSlot);
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgDOTARealtimeGameStatsTerse_PlayerDetails>,
  ): CMsgDOTARealtimeGameStatsTerse_PlayerDetails {
    return CMsgDOTARealtimeGameStatsTerse_PlayerDetails.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgDOTARealtimeGameStatsTerse_PlayerDetails>,
  ): CMsgDOTARealtimeGameStatsTerse_PlayerDetails {
    const message = createBaseCMsgDOTARealtimeGameStatsTerse_PlayerDetails();
    message.accountid = object.accountid ?? 0;
    message.playerid = object.playerid ?? -1;
    message.name = object.name ?? "";
    message.team = object.team ?? 0;
    message.heroid = object.heroid ?? 0;
    message.level = object.level ?? 0;
    message.killCount = object.killCount ?? 0;
    message.deathCount = object.deathCount ?? 0;
    message.assistsCount = object.assistsCount ?? 0;
    message.deniesCount = object.deniesCount ?? 0;
    message.lhCount = object.lhCount ?? 0;
    message.gold = object.gold ?? 0;
    message.x = object.x ?? 0;
    message.y = object.y ?? 0;
    message.netWorth = object.netWorth ?? 0;
    message.abilities = object.abilities?.map((e) => e) || [];
    message.items = object.items?.map((e) => e) || [];
    message.teamSlot = object.teamSlot ?? 0;
    return message;
  },
};

function createBaseCMsgDOTARealtimeGameStatsTerse_BuildingDetails(): CMsgDOTARealtimeGameStatsTerse_BuildingDetails {
  return { team: 0, heading: 0, type: 0, lane: 0, tier: 0, x: 0, y: 0, destroyed: false };
}

export const CMsgDOTARealtimeGameStatsTerse_BuildingDetails = {
  encode(
    message: CMsgDOTARealtimeGameStatsTerse_BuildingDetails,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.team !== undefined && message.team !== 0) {
      writer.uint32(8).uint32(message.team);
    }
    if (message.heading !== undefined && message.heading !== 0) {
      writer.uint32(21).float(message.heading);
    }
    if (message.type !== undefined && message.type !== 0) {
      writer.uint32(24).uint32(message.type);
    }
    if (message.lane !== undefined && message.lane !== 0) {
      writer.uint32(32).uint32(message.lane);
    }
    if (message.tier !== undefined && message.tier !== 0) {
      writer.uint32(40).uint32(message.tier);
    }
    if (message.x !== undefined && message.x !== 0) {
      writer.uint32(53).float(message.x);
    }
    if (message.y !== undefined && message.y !== 0) {
      writer.uint32(61).float(message.y);
    }
    if (message.destroyed !== undefined && message.destroyed !== false) {
      writer.uint32(64).bool(message.destroyed);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTARealtimeGameStatsTerse_BuildingDetails {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTARealtimeGameStatsTerse_BuildingDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.team = reader.uint32();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.heading = reader.float();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.type = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.lane = reader.uint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.tier = reader.uint32();
          continue;
        case 6:
          if (tag !== 53) {
            break;
          }

          message.x = reader.float();
          continue;
        case 7:
          if (tag !== 61) {
            break;
          }

          message.y = reader.float();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.destroyed = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTARealtimeGameStatsTerse_BuildingDetails {
    return {
      team: isSet(object.team) ? globalThis.Number(object.team) : 0,
      heading: isSet(object.heading) ? globalThis.Number(object.heading) : 0,
      type: isSet(object.type) ? globalThis.Number(object.type) : 0,
      lane: isSet(object.lane) ? globalThis.Number(object.lane) : 0,
      tier: isSet(object.tier) ? globalThis.Number(object.tier) : 0,
      x: isSet(object.x) ? globalThis.Number(object.x) : 0,
      y: isSet(object.y) ? globalThis.Number(object.y) : 0,
      destroyed: isSet(object.destroyed) ? globalThis.Boolean(object.destroyed) : false,
    };
  },

  toJSON(message: CMsgDOTARealtimeGameStatsTerse_BuildingDetails): unknown {
    const obj: any = {};
    if (message.team !== undefined && message.team !== 0) {
      obj.team = Math.round(message.team);
    }
    if (message.heading !== undefined && message.heading !== 0) {
      obj.heading = message.heading;
    }
    if (message.type !== undefined && message.type !== 0) {
      obj.type = Math.round(message.type);
    }
    if (message.lane !== undefined && message.lane !== 0) {
      obj.lane = Math.round(message.lane);
    }
    if (message.tier !== undefined && message.tier !== 0) {
      obj.tier = Math.round(message.tier);
    }
    if (message.x !== undefined && message.x !== 0) {
      obj.x = message.x;
    }
    if (message.y !== undefined && message.y !== 0) {
      obj.y = message.y;
    }
    if (message.destroyed !== undefined && message.destroyed !== false) {
      obj.destroyed = message.destroyed;
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgDOTARealtimeGameStatsTerse_BuildingDetails>,
  ): CMsgDOTARealtimeGameStatsTerse_BuildingDetails {
    return CMsgDOTARealtimeGameStatsTerse_BuildingDetails.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgDOTARealtimeGameStatsTerse_BuildingDetails>,
  ): CMsgDOTARealtimeGameStatsTerse_BuildingDetails {
    const message = createBaseCMsgDOTARealtimeGameStatsTerse_BuildingDetails();
    message.team = object.team ?? 0;
    message.heading = object.heading ?? 0;
    message.type = object.type ?? 0;
    message.lane = object.lane ?? 0;
    message.tier = object.tier ?? 0;
    message.x = object.x ?? 0;
    message.y = object.y ?? 0;
    message.destroyed = object.destroyed ?? false;
    return message;
  },
};

function createBaseCMsgDOTARealtimeGameStatsTerse_PickBanDetails(): CMsgDOTARealtimeGameStatsTerse_PickBanDetails {
  return { hero: 0, team: 0 };
}

export const CMsgDOTARealtimeGameStatsTerse_PickBanDetails = {
  encode(message: CMsgDOTARealtimeGameStatsTerse_PickBanDetails, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.hero !== undefined && message.hero !== 0) {
      writer.uint32(8).int32(message.hero);
    }
    if (message.team !== undefined && message.team !== 0) {
      writer.uint32(16).uint32(message.team);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTARealtimeGameStatsTerse_PickBanDetails {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTARealtimeGameStatsTerse_PickBanDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.hero = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.team = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTARealtimeGameStatsTerse_PickBanDetails {
    return {
      hero: isSet(object.hero) ? globalThis.Number(object.hero) : 0,
      team: isSet(object.team) ? globalThis.Number(object.team) : 0,
    };
  },

  toJSON(message: CMsgDOTARealtimeGameStatsTerse_PickBanDetails): unknown {
    const obj: any = {};
    if (message.hero !== undefined && message.hero !== 0) {
      obj.hero = Math.round(message.hero);
    }
    if (message.team !== undefined && message.team !== 0) {
      obj.team = Math.round(message.team);
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgDOTARealtimeGameStatsTerse_PickBanDetails>,
  ): CMsgDOTARealtimeGameStatsTerse_PickBanDetails {
    return CMsgDOTARealtimeGameStatsTerse_PickBanDetails.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgDOTARealtimeGameStatsTerse_PickBanDetails>,
  ): CMsgDOTARealtimeGameStatsTerse_PickBanDetails {
    const message = createBaseCMsgDOTARealtimeGameStatsTerse_PickBanDetails();
    message.hero = object.hero ?? 0;
    message.team = object.team ?? 0;
    return message;
  },
};

function createBaseCMsgDOTARealtimeGameStatsTerse_MatchDetails(): CMsgDOTARealtimeGameStatsTerse_MatchDetails {
  return {
    serverSteamId: "0",
    matchId: "0",
    timestamp: 0,
    gameTime: 0,
    steamBroadcasterAccountIds: [],
    gameMode: 0,
    leagueId: 0,
    leagueNodeId: 0,
    gameState: 0,
    picks: [],
    bans: [],
    lobbyType: 0,
    startTimestamp: 0,
    isPlayerDraft: false,
  };
}

export const CMsgDOTARealtimeGameStatsTerse_MatchDetails = {
  encode(message: CMsgDOTARealtimeGameStatsTerse_MatchDetails, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.serverSteamId !== undefined && message.serverSteamId !== "0") {
      writer.uint32(9).fixed64(message.serverSteamId);
    }
    if (message.matchId !== undefined && message.matchId !== "0") {
      writer.uint32(16).uint64(message.matchId);
    }
    if (message.timestamp !== undefined && message.timestamp !== 0) {
      writer.uint32(24).uint32(message.timestamp);
    }
    if (message.gameTime !== undefined && message.gameTime !== 0) {
      writer.uint32(32).int32(message.gameTime);
    }
    writer.uint32(50).fork();
    for (const v of message.steamBroadcasterAccountIds) {
      writer.uint32(v);
    }
    writer.ldelim();
    if (message.gameMode !== undefined && message.gameMode !== 0) {
      writer.uint32(56).uint32(message.gameMode);
    }
    if (message.leagueId !== undefined && message.leagueId !== 0) {
      writer.uint32(64).uint32(message.leagueId);
    }
    if (message.leagueNodeId !== undefined && message.leagueNodeId !== 0) {
      writer.uint32(72).uint32(message.leagueNodeId);
    }
    if (message.gameState !== undefined && message.gameState !== 0) {
      writer.uint32(80).uint32(message.gameState);
    }
    for (const v of message.picks) {
      CMsgDOTARealtimeGameStatsTerse_PickBanDetails.encode(v!, writer.uint32(90).fork()).ldelim();
    }
    for (const v of message.bans) {
      CMsgDOTARealtimeGameStatsTerse_PickBanDetails.encode(v!, writer.uint32(98).fork()).ldelim();
    }
    if (message.lobbyType !== undefined && message.lobbyType !== 0) {
      writer.uint32(104).uint32(message.lobbyType);
    }
    if (message.startTimestamp !== undefined && message.startTimestamp !== 0) {
      writer.uint32(112).uint32(message.startTimestamp);
    }
    if (message.isPlayerDraft !== undefined && message.isPlayerDraft !== false) {
      writer.uint32(120).bool(message.isPlayerDraft);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTARealtimeGameStatsTerse_MatchDetails {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTARealtimeGameStatsTerse_MatchDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.serverSteamId = longToString(reader.fixed64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.matchId = longToString(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.timestamp = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.gameTime = reader.int32();
          continue;
        case 6:
          if (tag === 48) {
            message.steamBroadcasterAccountIds.push(reader.uint32());

            continue;
          }

          if (tag === 50) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.steamBroadcasterAccountIds.push(reader.uint32());
            }

            continue;
          }

          break;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.gameMode = reader.uint32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.leagueId = reader.uint32();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.leagueNodeId = reader.uint32();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.gameState = reader.uint32();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.picks.push(CMsgDOTARealtimeGameStatsTerse_PickBanDetails.decode(reader, reader.uint32()));
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.bans.push(CMsgDOTARealtimeGameStatsTerse_PickBanDetails.decode(reader, reader.uint32()));
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.lobbyType = reader.uint32();
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.startTimestamp = reader.uint32();
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.isPlayerDraft = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTARealtimeGameStatsTerse_MatchDetails {
    return {
      serverSteamId: isSet(object.serverSteamId) ? globalThis.String(object.serverSteamId) : "0",
      matchId: isSet(object.matchId) ? globalThis.String(object.matchId) : "0",
      timestamp: isSet(object.timestamp) ? globalThis.Number(object.timestamp) : 0,
      gameTime: isSet(object.gameTime) ? globalThis.Number(object.gameTime) : 0,
      steamBroadcasterAccountIds: globalThis.Array.isArray(object?.steamBroadcasterAccountIds)
        ? object.steamBroadcasterAccountIds.map((e: any) => globalThis.Number(e))
        : [],
      gameMode: isSet(object.gameMode) ? globalThis.Number(object.gameMode) : 0,
      leagueId: isSet(object.leagueId) ? globalThis.Number(object.leagueId) : 0,
      leagueNodeId: isSet(object.leagueNodeId) ? globalThis.Number(object.leagueNodeId) : 0,
      gameState: isSet(object.gameState) ? globalThis.Number(object.gameState) : 0,
      picks: globalThis.Array.isArray(object?.picks)
        ? object.picks.map((e: any) => CMsgDOTARealtimeGameStatsTerse_PickBanDetails.fromJSON(e))
        : [],
      bans: globalThis.Array.isArray(object?.bans)
        ? object.bans.map((e: any) => CMsgDOTARealtimeGameStatsTerse_PickBanDetails.fromJSON(e))
        : [],
      lobbyType: isSet(object.lobbyType) ? globalThis.Number(object.lobbyType) : 0,
      startTimestamp: isSet(object.startTimestamp) ? globalThis.Number(object.startTimestamp) : 0,
      isPlayerDraft: isSet(object.isPlayerDraft) ? globalThis.Boolean(object.isPlayerDraft) : false,
    };
  },

  toJSON(message: CMsgDOTARealtimeGameStatsTerse_MatchDetails): unknown {
    const obj: any = {};
    if (message.serverSteamId !== undefined && message.serverSteamId !== "0") {
      obj.serverSteamId = message.serverSteamId;
    }
    if (message.matchId !== undefined && message.matchId !== "0") {
      obj.matchId = message.matchId;
    }
    if (message.timestamp !== undefined && message.timestamp !== 0) {
      obj.timestamp = Math.round(message.timestamp);
    }
    if (message.gameTime !== undefined && message.gameTime !== 0) {
      obj.gameTime = Math.round(message.gameTime);
    }
    if (message.steamBroadcasterAccountIds?.length) {
      obj.steamBroadcasterAccountIds = message.steamBroadcasterAccountIds.map((e) => Math.round(e));
    }
    if (message.gameMode !== undefined && message.gameMode !== 0) {
      obj.gameMode = Math.round(message.gameMode);
    }
    if (message.leagueId !== undefined && message.leagueId !== 0) {
      obj.leagueId = Math.round(message.leagueId);
    }
    if (message.leagueNodeId !== undefined && message.leagueNodeId !== 0) {
      obj.leagueNodeId = Math.round(message.leagueNodeId);
    }
    if (message.gameState !== undefined && message.gameState !== 0) {
      obj.gameState = Math.round(message.gameState);
    }
    if (message.picks?.length) {
      obj.picks = message.picks.map((e) => CMsgDOTARealtimeGameStatsTerse_PickBanDetails.toJSON(e));
    }
    if (message.bans?.length) {
      obj.bans = message.bans.map((e) => CMsgDOTARealtimeGameStatsTerse_PickBanDetails.toJSON(e));
    }
    if (message.lobbyType !== undefined && message.lobbyType !== 0) {
      obj.lobbyType = Math.round(message.lobbyType);
    }
    if (message.startTimestamp !== undefined && message.startTimestamp !== 0) {
      obj.startTimestamp = Math.round(message.startTimestamp);
    }
    if (message.isPlayerDraft !== undefined && message.isPlayerDraft !== false) {
      obj.isPlayerDraft = message.isPlayerDraft;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTARealtimeGameStatsTerse_MatchDetails>): CMsgDOTARealtimeGameStatsTerse_MatchDetails {
    return CMsgDOTARealtimeGameStatsTerse_MatchDetails.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgDOTARealtimeGameStatsTerse_MatchDetails>,
  ): CMsgDOTARealtimeGameStatsTerse_MatchDetails {
    const message = createBaseCMsgDOTARealtimeGameStatsTerse_MatchDetails();
    message.serverSteamId = object.serverSteamId ?? "0";
    message.matchId = object.matchId ?? "0";
    message.timestamp = object.timestamp ?? 0;
    message.gameTime = object.gameTime ?? 0;
    message.steamBroadcasterAccountIds = object.steamBroadcasterAccountIds?.map((e) => e) || [];
    message.gameMode = object.gameMode ?? 0;
    message.leagueId = object.leagueId ?? 0;
    message.leagueNodeId = object.leagueNodeId ?? 0;
    message.gameState = object.gameState ?? 0;
    message.picks = object.picks?.map((e) => CMsgDOTARealtimeGameStatsTerse_PickBanDetails.fromPartial(e)) || [];
    message.bans = object.bans?.map((e) => CMsgDOTARealtimeGameStatsTerse_PickBanDetails.fromPartial(e)) || [];
    message.lobbyType = object.lobbyType ?? 0;
    message.startTimestamp = object.startTimestamp ?? 0;
    message.isPlayerDraft = object.isPlayerDraft ?? false;
    return message;
  },
};

function createBaseCMsgDOTARealtimeGameStatsTerse_GraphData(): CMsgDOTARealtimeGameStatsTerse_GraphData {
  return { graphGold: [] };
}

export const CMsgDOTARealtimeGameStatsTerse_GraphData = {
  encode(message: CMsgDOTARealtimeGameStatsTerse_GraphData, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.graphGold) {
      writer.int32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTARealtimeGameStatsTerse_GraphData {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTARealtimeGameStatsTerse_GraphData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.graphGold.push(reader.int32());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.graphGold.push(reader.int32());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTARealtimeGameStatsTerse_GraphData {
    return {
      graphGold: globalThis.Array.isArray(object?.graphGold)
        ? object.graphGold.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: CMsgDOTARealtimeGameStatsTerse_GraphData): unknown {
    const obj: any = {};
    if (message.graphGold?.length) {
      obj.graphGold = message.graphGold.map((e) => Math.round(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTARealtimeGameStatsTerse_GraphData>): CMsgDOTARealtimeGameStatsTerse_GraphData {
    return CMsgDOTARealtimeGameStatsTerse_GraphData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTARealtimeGameStatsTerse_GraphData>): CMsgDOTARealtimeGameStatsTerse_GraphData {
    const message = createBaseCMsgDOTARealtimeGameStatsTerse_GraphData();
    message.graphGold = object.graphGold?.map((e) => e) || [];
    return message;
  },
};

function createBaseCMsgDOTABroadcastTimelineEvent(): CMsgDOTABroadcastTimelineEvent {
  return { event: 1, timestamp: 0, data: 0, stringData: "" };
}

export const CMsgDOTABroadcastTimelineEvent = {
  encode(message: CMsgDOTABroadcastTimelineEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.event !== undefined && message.event !== 1) {
      writer.uint32(8).int32(message.event);
    }
    if (message.timestamp !== undefined && message.timestamp !== 0) {
      writer.uint32(21).fixed32(message.timestamp);
    }
    if (message.data !== undefined && message.data !== 0) {
      writer.uint32(24).uint32(message.data);
    }
    if (message.stringData !== undefined && message.stringData !== "") {
      writer.uint32(34).string(message.stringData);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTABroadcastTimelineEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTABroadcastTimelineEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.event = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.timestamp = reader.fixed32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.data = reader.uint32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.stringData = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTABroadcastTimelineEvent {
    return {
      event: isSet(object.event) ? eBroadcastTimelineEventFromJSON(object.event) : 1,
      timestamp: isSet(object.timestamp) ? globalThis.Number(object.timestamp) : 0,
      data: isSet(object.data) ? globalThis.Number(object.data) : 0,
      stringData: isSet(object.stringData) ? globalThis.String(object.stringData) : "",
    };
  },

  toJSON(message: CMsgDOTABroadcastTimelineEvent): unknown {
    const obj: any = {};
    if (message.event !== undefined && message.event !== 1) {
      obj.event = eBroadcastTimelineEventToJSON(message.event);
    }
    if (message.timestamp !== undefined && message.timestamp !== 0) {
      obj.timestamp = Math.round(message.timestamp);
    }
    if (message.data !== undefined && message.data !== 0) {
      obj.data = Math.round(message.data);
    }
    if (message.stringData !== undefined && message.stringData !== "") {
      obj.stringData = message.stringData;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTABroadcastTimelineEvent>): CMsgDOTABroadcastTimelineEvent {
    return CMsgDOTABroadcastTimelineEvent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTABroadcastTimelineEvent>): CMsgDOTABroadcastTimelineEvent {
    const message = createBaseCMsgDOTABroadcastTimelineEvent();
    message.event = object.event ?? 1;
    message.timestamp = object.timestamp ?? 0;
    message.data = object.data ?? 0;
    message.stringData = object.stringData ?? "";
    return message;
  },
};

function createBaseCMsgGCToClientMatchGroupsVersion(): CMsgGCToClientMatchGroupsVersion {
  return { matchgroupsVersion: 0 };
}

export const CMsgGCToClientMatchGroupsVersion = {
  encode(message: CMsgGCToClientMatchGroupsVersion, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.matchgroupsVersion !== undefined && message.matchgroupsVersion !== 0) {
      writer.uint32(8).uint32(message.matchgroupsVersion);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToClientMatchGroupsVersion {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientMatchGroupsVersion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.matchgroupsVersion = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientMatchGroupsVersion {
    return { matchgroupsVersion: isSet(object.matchgroupsVersion) ? globalThis.Number(object.matchgroupsVersion) : 0 };
  },

  toJSON(message: CMsgGCToClientMatchGroupsVersion): unknown {
    const obj: any = {};
    if (message.matchgroupsVersion !== undefined && message.matchgroupsVersion !== 0) {
      obj.matchgroupsVersion = Math.round(message.matchgroupsVersion);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCToClientMatchGroupsVersion>): CMsgGCToClientMatchGroupsVersion {
    return CMsgGCToClientMatchGroupsVersion.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCToClientMatchGroupsVersion>): CMsgGCToClientMatchGroupsVersion {
    const message = createBaseCMsgGCToClientMatchGroupsVersion();
    message.matchgroupsVersion = object.matchgroupsVersion ?? 0;
    return message;
  },
};

function createBaseCMsgDOTASDOHeroStatsHistory(): CMsgDOTASDOHeroStatsHistory {
  return {
    matchId: "0",
    gameMode: 0,
    lobbyType: 0,
    startTime: 0,
    won: false,
    gpm: 0,
    xpm: 0,
    kills: 0,
    deaths: 0,
    assists: 0,
  };
}

export const CMsgDOTASDOHeroStatsHistory = {
  encode(message: CMsgDOTASDOHeroStatsHistory, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.matchId !== undefined && message.matchId !== "0") {
      writer.uint32(8).uint64(message.matchId);
    }
    if (message.gameMode !== undefined && message.gameMode !== 0) {
      writer.uint32(16).uint32(message.gameMode);
    }
    if (message.lobbyType !== undefined && message.lobbyType !== 0) {
      writer.uint32(24).uint32(message.lobbyType);
    }
    if (message.startTime !== undefined && message.startTime !== 0) {
      writer.uint32(32).uint32(message.startTime);
    }
    if (message.won !== undefined && message.won !== false) {
      writer.uint32(40).bool(message.won);
    }
    if (message.gpm !== undefined && message.gpm !== 0) {
      writer.uint32(48).uint32(message.gpm);
    }
    if (message.xpm !== undefined && message.xpm !== 0) {
      writer.uint32(56).uint32(message.xpm);
    }
    if (message.kills !== undefined && message.kills !== 0) {
      writer.uint32(64).uint32(message.kills);
    }
    if (message.deaths !== undefined && message.deaths !== 0) {
      writer.uint32(72).uint32(message.deaths);
    }
    if (message.assists !== undefined && message.assists !== 0) {
      writer.uint32(80).uint32(message.assists);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTASDOHeroStatsHistory {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTASDOHeroStatsHistory();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.matchId = longToString(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.gameMode = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.lobbyType = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.startTime = reader.uint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.won = reader.bool();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.gpm = reader.uint32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.xpm = reader.uint32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.kills = reader.uint32();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.deaths = reader.uint32();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.assists = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTASDOHeroStatsHistory {
    return {
      matchId: isSet(object.matchId) ? globalThis.String(object.matchId) : "0",
      gameMode: isSet(object.gameMode) ? globalThis.Number(object.gameMode) : 0,
      lobbyType: isSet(object.lobbyType) ? globalThis.Number(object.lobbyType) : 0,
      startTime: isSet(object.startTime) ? globalThis.Number(object.startTime) : 0,
      won: isSet(object.won) ? globalThis.Boolean(object.won) : false,
      gpm: isSet(object.gpm) ? globalThis.Number(object.gpm) : 0,
      xpm: isSet(object.xpm) ? globalThis.Number(object.xpm) : 0,
      kills: isSet(object.kills) ? globalThis.Number(object.kills) : 0,
      deaths: isSet(object.deaths) ? globalThis.Number(object.deaths) : 0,
      assists: isSet(object.assists) ? globalThis.Number(object.assists) : 0,
    };
  },

  toJSON(message: CMsgDOTASDOHeroStatsHistory): unknown {
    const obj: any = {};
    if (message.matchId !== undefined && message.matchId !== "0") {
      obj.matchId = message.matchId;
    }
    if (message.gameMode !== undefined && message.gameMode !== 0) {
      obj.gameMode = Math.round(message.gameMode);
    }
    if (message.lobbyType !== undefined && message.lobbyType !== 0) {
      obj.lobbyType = Math.round(message.lobbyType);
    }
    if (message.startTime !== undefined && message.startTime !== 0) {
      obj.startTime = Math.round(message.startTime);
    }
    if (message.won !== undefined && message.won !== false) {
      obj.won = message.won;
    }
    if (message.gpm !== undefined && message.gpm !== 0) {
      obj.gpm = Math.round(message.gpm);
    }
    if (message.xpm !== undefined && message.xpm !== 0) {
      obj.xpm = Math.round(message.xpm);
    }
    if (message.kills !== undefined && message.kills !== 0) {
      obj.kills = Math.round(message.kills);
    }
    if (message.deaths !== undefined && message.deaths !== 0) {
      obj.deaths = Math.round(message.deaths);
    }
    if (message.assists !== undefined && message.assists !== 0) {
      obj.assists = Math.round(message.assists);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTASDOHeroStatsHistory>): CMsgDOTASDOHeroStatsHistory {
    return CMsgDOTASDOHeroStatsHistory.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTASDOHeroStatsHistory>): CMsgDOTASDOHeroStatsHistory {
    const message = createBaseCMsgDOTASDOHeroStatsHistory();
    message.matchId = object.matchId ?? "0";
    message.gameMode = object.gameMode ?? 0;
    message.lobbyType = object.lobbyType ?? 0;
    message.startTime = object.startTime ?? 0;
    message.won = object.won ?? false;
    message.gpm = object.gpm ?? 0;
    message.xpm = object.xpm ?? 0;
    message.kills = object.kills ?? 0;
    message.deaths = object.deaths ?? 0;
    message.assists = object.assists ?? 0;
    return message;
  },
};

function createBaseCMsgPredictionChoice(): CMsgPredictionChoice {
  return { value: 0, name: "", minRawValue: 0, maxRawValue: 0 };
}

export const CMsgPredictionChoice = {
  encode(message: CMsgPredictionChoice, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.value !== undefined && message.value !== 0) {
      writer.uint32(8).uint32(message.value);
    }
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.minRawValue !== undefined && message.minRawValue !== 0) {
      writer.uint32(24).uint32(message.minRawValue);
    }
    if (message.maxRawValue !== undefined && message.maxRawValue !== 0) {
      writer.uint32(32).uint32(message.maxRawValue);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgPredictionChoice {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgPredictionChoice();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.value = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.minRawValue = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.maxRawValue = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgPredictionChoice {
    return {
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      minRawValue: isSet(object.minRawValue) ? globalThis.Number(object.minRawValue) : 0,
      maxRawValue: isSet(object.maxRawValue) ? globalThis.Number(object.maxRawValue) : 0,
    };
  },

  toJSON(message: CMsgPredictionChoice): unknown {
    const obj: any = {};
    if (message.value !== undefined && message.value !== 0) {
      obj.value = Math.round(message.value);
    }
    if (message.name !== undefined && message.name !== "") {
      obj.name = message.name;
    }
    if (message.minRawValue !== undefined && message.minRawValue !== 0) {
      obj.minRawValue = Math.round(message.minRawValue);
    }
    if (message.maxRawValue !== undefined && message.maxRawValue !== 0) {
      obj.maxRawValue = Math.round(message.maxRawValue);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgPredictionChoice>): CMsgPredictionChoice {
    return CMsgPredictionChoice.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgPredictionChoice>): CMsgPredictionChoice {
    const message = createBaseCMsgPredictionChoice();
    message.value = object.value ?? 0;
    message.name = object.name ?? "";
    message.minRawValue = object.minRawValue ?? 0;
    message.maxRawValue = object.maxRawValue ?? 0;
    return message;
  },
};

function createBaseCMsgInGamePrediction(): CMsgInGamePrediction {
  return {
    id: 0,
    name: "",
    type: 0,
    group: 0,
    question: "",
    choices: [],
    requiredHeroes: [],
    queryName: "",
    queryValues: [],
    answerResolutionType: 0,
    pointsToGrant: 0,
    rewardAction: 0,
    debugForceSelection: 0,
    rawValueType: 0,
  };
}

export const CMsgInGamePrediction = {
  encode(message: CMsgInGamePrediction, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== undefined && message.id !== 0) {
      writer.uint32(8).uint32(message.id);
    }
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.type !== undefined && message.type !== 0) {
      writer.uint32(24).int32(message.type);
    }
    if (message.group !== undefined && message.group !== 0) {
      writer.uint32(32).int32(message.group);
    }
    if (message.question !== undefined && message.question !== "") {
      writer.uint32(42).string(message.question);
    }
    for (const v of message.choices) {
      CMsgPredictionChoice.encode(v!, writer.uint32(50).fork()).ldelim();
    }
    for (const v of message.requiredHeroes) {
      writer.uint32(58).string(v!);
    }
    if (message.queryName !== undefined && message.queryName !== "") {
      writer.uint32(66).string(message.queryName);
    }
    for (const v of message.queryValues) {
      CMsgInGamePrediction_QueryKeyValues.encode(v!, writer.uint32(74).fork()).ldelim();
    }
    if (message.answerResolutionType !== undefined && message.answerResolutionType !== 0) {
      writer.uint32(80).int32(message.answerResolutionType);
    }
    if (message.pointsToGrant !== undefined && message.pointsToGrant !== 0) {
      writer.uint32(88).uint32(message.pointsToGrant);
    }
    if (message.rewardAction !== undefined && message.rewardAction !== 0) {
      writer.uint32(96).uint32(message.rewardAction);
    }
    if (message.debugForceSelection !== undefined && message.debugForceSelection !== 0) {
      writer.uint32(104).uint32(message.debugForceSelection);
    }
    if (message.rawValueType !== undefined && message.rawValueType !== 0) {
      writer.uint32(112).int32(message.rawValueType);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgInGamePrediction {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgInGamePrediction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.group = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.question = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.choices.push(CMsgPredictionChoice.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.requiredHeroes.push(reader.string());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.queryName = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.queryValues.push(CMsgInGamePrediction_QueryKeyValues.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.answerResolutionType = reader.int32() as any;
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.pointsToGrant = reader.uint32();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.rewardAction = reader.uint32();
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.debugForceSelection = reader.uint32();
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.rawValueType = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgInGamePrediction {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      type: isSet(object.type) ? cMsgInGamePrediction_EPredictionTypeFromJSON(object.type) : 0,
      group: isSet(object.group) ? cMsgInGamePrediction_ERandomSelectionGroupTFromJSON(object.group) : 0,
      question: isSet(object.question) ? globalThis.String(object.question) : "",
      choices: globalThis.Array.isArray(object?.choices)
        ? object.choices.map((e: any) => CMsgPredictionChoice.fromJSON(e))
        : [],
      requiredHeroes: globalThis.Array.isArray(object?.requiredHeroes)
        ? object.requiredHeroes.map((e: any) => globalThis.String(e))
        : [],
      queryName: isSet(object.queryName) ? globalThis.String(object.queryName) : "",
      queryValues: globalThis.Array.isArray(object?.queryValues)
        ? object.queryValues.map((e: any) => CMsgInGamePrediction_QueryKeyValues.fromJSON(e))
        : [],
      answerResolutionType: isSet(object.answerResolutionType)
        ? cMsgInGamePrediction_EResolutionTypeTFromJSON(object.answerResolutionType)
        : 0,
      pointsToGrant: isSet(object.pointsToGrant) ? globalThis.Number(object.pointsToGrant) : 0,
      rewardAction: isSet(object.rewardAction) ? globalThis.Number(object.rewardAction) : 0,
      debugForceSelection: isSet(object.debugForceSelection) ? globalThis.Number(object.debugForceSelection) : 0,
      rawValueType: isSet(object.rawValueType) ? cMsgInGamePrediction_ERawValueTypeTFromJSON(object.rawValueType) : 0,
    };
  },

  toJSON(message: CMsgInGamePrediction): unknown {
    const obj: any = {};
    if (message.id !== undefined && message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.name !== undefined && message.name !== "") {
      obj.name = message.name;
    }
    if (message.type !== undefined && message.type !== 0) {
      obj.type = cMsgInGamePrediction_EPredictionTypeToJSON(message.type);
    }
    if (message.group !== undefined && message.group !== 0) {
      obj.group = cMsgInGamePrediction_ERandomSelectionGroupTToJSON(message.group);
    }
    if (message.question !== undefined && message.question !== "") {
      obj.question = message.question;
    }
    if (message.choices?.length) {
      obj.choices = message.choices.map((e) => CMsgPredictionChoice.toJSON(e));
    }
    if (message.requiredHeroes?.length) {
      obj.requiredHeroes = message.requiredHeroes;
    }
    if (message.queryName !== undefined && message.queryName !== "") {
      obj.queryName = message.queryName;
    }
    if (message.queryValues?.length) {
      obj.queryValues = message.queryValues.map((e) => CMsgInGamePrediction_QueryKeyValues.toJSON(e));
    }
    if (message.answerResolutionType !== undefined && message.answerResolutionType !== 0) {
      obj.answerResolutionType = cMsgInGamePrediction_EResolutionTypeTToJSON(message.answerResolutionType);
    }
    if (message.pointsToGrant !== undefined && message.pointsToGrant !== 0) {
      obj.pointsToGrant = Math.round(message.pointsToGrant);
    }
    if (message.rewardAction !== undefined && message.rewardAction !== 0) {
      obj.rewardAction = Math.round(message.rewardAction);
    }
    if (message.debugForceSelection !== undefined && message.debugForceSelection !== 0) {
      obj.debugForceSelection = Math.round(message.debugForceSelection);
    }
    if (message.rawValueType !== undefined && message.rawValueType !== 0) {
      obj.rawValueType = cMsgInGamePrediction_ERawValueTypeTToJSON(message.rawValueType);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgInGamePrediction>): CMsgInGamePrediction {
    return CMsgInGamePrediction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgInGamePrediction>): CMsgInGamePrediction {
    const message = createBaseCMsgInGamePrediction();
    message.id = object.id ?? 0;
    message.name = object.name ?? "";
    message.type = object.type ?? 0;
    message.group = object.group ?? 0;
    message.question = object.question ?? "";
    message.choices = object.choices?.map((e) => CMsgPredictionChoice.fromPartial(e)) || [];
    message.requiredHeroes = object.requiredHeroes?.map((e) => e) || [];
    message.queryName = object.queryName ?? "";
    message.queryValues = object.queryValues?.map((e) => CMsgInGamePrediction_QueryKeyValues.fromPartial(e)) || [];
    message.answerResolutionType = object.answerResolutionType ?? 0;
    message.pointsToGrant = object.pointsToGrant ?? 0;
    message.rewardAction = object.rewardAction ?? 0;
    message.debugForceSelection = object.debugForceSelection ?? 0;
    message.rawValueType = object.rawValueType ?? 0;
    return message;
  },
};

function createBaseCMsgInGamePrediction_QueryKeyValues(): CMsgInGamePrediction_QueryKeyValues {
  return { name: "", value: "" };
}

export const CMsgInGamePrediction_QueryKeyValues = {
  encode(message: CMsgInGamePrediction_QueryKeyValues, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.value !== undefined && message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgInGamePrediction_QueryKeyValues {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgInGamePrediction_QueryKeyValues();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgInGamePrediction_QueryKeyValues {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: CMsgInGamePrediction_QueryKeyValues): unknown {
    const obj: any = {};
    if (message.name !== undefined && message.name !== "") {
      obj.name = message.name;
    }
    if (message.value !== undefined && message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgInGamePrediction_QueryKeyValues>): CMsgInGamePrediction_QueryKeyValues {
    return CMsgInGamePrediction_QueryKeyValues.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgInGamePrediction_QueryKeyValues>): CMsgInGamePrediction_QueryKeyValues {
    const message = createBaseCMsgInGamePrediction_QueryKeyValues();
    message.name = object.name ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseCMsgDOTASeasonPredictions(): CMsgDOTASeasonPredictions {
  return {
    predictions: [],
    inGamePredictions: [],
    inGamePredictionCountPerGame: 0,
    inGamePredictionVotingPeriodMinutes: 0,
  };
}

export const CMsgDOTASeasonPredictions = {
  encode(message: CMsgDOTASeasonPredictions, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.predictions) {
      CMsgDOTASeasonPredictions_Prediction.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.inGamePredictions) {
      CMsgInGamePrediction.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.inGamePredictionCountPerGame !== undefined && message.inGamePredictionCountPerGame !== 0) {
      writer.uint32(24).uint32(message.inGamePredictionCountPerGame);
    }
    if (
      message.inGamePredictionVotingPeriodMinutes !== undefined && message.inGamePredictionVotingPeriodMinutes !== 0
    ) {
      writer.uint32(32).uint32(message.inGamePredictionVotingPeriodMinutes);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTASeasonPredictions {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTASeasonPredictions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.predictions.push(CMsgDOTASeasonPredictions_Prediction.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.inGamePredictions.push(CMsgInGamePrediction.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.inGamePredictionCountPerGame = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.inGamePredictionVotingPeriodMinutes = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTASeasonPredictions {
    return {
      predictions: globalThis.Array.isArray(object?.predictions)
        ? object.predictions.map((e: any) => CMsgDOTASeasonPredictions_Prediction.fromJSON(e))
        : [],
      inGamePredictions: globalThis.Array.isArray(object?.inGamePredictions)
        ? object.inGamePredictions.map((e: any) => CMsgInGamePrediction.fromJSON(e))
        : [],
      inGamePredictionCountPerGame: isSet(object.inGamePredictionCountPerGame)
        ? globalThis.Number(object.inGamePredictionCountPerGame)
        : 0,
      inGamePredictionVotingPeriodMinutes: isSet(object.inGamePredictionVotingPeriodMinutes)
        ? globalThis.Number(object.inGamePredictionVotingPeriodMinutes)
        : 0,
    };
  },

  toJSON(message: CMsgDOTASeasonPredictions): unknown {
    const obj: any = {};
    if (message.predictions?.length) {
      obj.predictions = message.predictions.map((e) => CMsgDOTASeasonPredictions_Prediction.toJSON(e));
    }
    if (message.inGamePredictions?.length) {
      obj.inGamePredictions = message.inGamePredictions.map((e) => CMsgInGamePrediction.toJSON(e));
    }
    if (message.inGamePredictionCountPerGame !== undefined && message.inGamePredictionCountPerGame !== 0) {
      obj.inGamePredictionCountPerGame = Math.round(message.inGamePredictionCountPerGame);
    }
    if (
      message.inGamePredictionVotingPeriodMinutes !== undefined && message.inGamePredictionVotingPeriodMinutes !== 0
    ) {
      obj.inGamePredictionVotingPeriodMinutes = Math.round(message.inGamePredictionVotingPeriodMinutes);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTASeasonPredictions>): CMsgDOTASeasonPredictions {
    return CMsgDOTASeasonPredictions.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTASeasonPredictions>): CMsgDOTASeasonPredictions {
    const message = createBaseCMsgDOTASeasonPredictions();
    message.predictions = object.predictions?.map((e) => CMsgDOTASeasonPredictions_Prediction.fromPartial(e)) || [];
    message.inGamePredictions = object.inGamePredictions?.map((e) => CMsgInGamePrediction.fromPartial(e)) || [];
    message.inGamePredictionCountPerGame = object.inGamePredictionCountPerGame ?? 0;
    message.inGamePredictionVotingPeriodMinutes = object.inGamePredictionVotingPeriodMinutes ?? 0;
    return message;
  },
};

function createBaseCMsgDOTASeasonPredictions_Prediction(): CMsgDOTASeasonPredictions_Prediction {
  return {
    type: 0,
    question: "",
    choices: [],
    selectionId: 0,
    startDate: 0,
    lockDate: 0,
    reward: 0,
    answerType: 0,
    answerId: 0,
    answers: [],
    queryName: "",
    lockOnSelectionId: 0,
    lockOnSelectionValue: 0,
    lockOnSelectionSet: false,
    useAnswerValueRanges: false,
    region: 0,
    phases: [],
    rewardEvent: 0,
    leagueNodeId: 0,
  };
}

export const CMsgDOTASeasonPredictions_Prediction = {
  encode(message: CMsgDOTASeasonPredictions_Prediction, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.type !== undefined && message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.question !== undefined && message.question !== "") {
      writer.uint32(18).string(message.question);
    }
    for (const v of message.choices) {
      CMsgPredictionChoice.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    if (message.selectionId !== undefined && message.selectionId !== 0) {
      writer.uint32(32).uint32(message.selectionId);
    }
    if (message.startDate !== undefined && message.startDate !== 0) {
      writer.uint32(40).uint32(message.startDate);
    }
    if (message.lockDate !== undefined && message.lockDate !== 0) {
      writer.uint32(48).uint32(message.lockDate);
    }
    if (message.reward !== undefined && message.reward !== 0) {
      writer.uint32(56).uint32(message.reward);
    }
    if (message.answerType !== undefined && message.answerType !== 0) {
      writer.uint32(64).int32(message.answerType);
    }
    if (message.answerId !== undefined && message.answerId !== 0) {
      writer.uint32(72).uint32(message.answerId);
    }
    for (const v of message.answers) {
      CMsgDOTASeasonPredictions_Prediction_Answers.encode(v!, writer.uint32(82).fork()).ldelim();
    }
    if (message.queryName !== undefined && message.queryName !== "") {
      writer.uint32(90).string(message.queryName);
    }
    if (message.lockOnSelectionId !== undefined && message.lockOnSelectionId !== 0) {
      writer.uint32(104).uint32(message.lockOnSelectionId);
    }
    if (message.lockOnSelectionValue !== undefined && message.lockOnSelectionValue !== 0) {
      writer.uint32(112).uint32(message.lockOnSelectionValue);
    }
    if (message.lockOnSelectionSet !== undefined && message.lockOnSelectionSet !== false) {
      writer.uint32(120).bool(message.lockOnSelectionSet);
    }
    if (message.useAnswerValueRanges !== undefined && message.useAnswerValueRanges !== false) {
      writer.uint32(128).bool(message.useAnswerValueRanges);
    }
    if (message.region !== undefined && message.region !== 0) {
      writer.uint32(136).int32(message.region);
    }
    writer.uint32(146).fork();
    for (const v of message.phases) {
      writer.int32(v);
    }
    writer.ldelim();
    if (message.rewardEvent !== undefined && message.rewardEvent !== 0) {
      writer.uint32(152).int32(message.rewardEvent);
    }
    if (message.leagueNodeId !== undefined && message.leagueNodeId !== 0) {
      writer.uint32(160).uint32(message.leagueNodeId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTASeasonPredictions_Prediction {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTASeasonPredictions_Prediction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.question = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.choices.push(CMsgPredictionChoice.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.selectionId = reader.uint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.startDate = reader.uint32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.lockDate = reader.uint32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.reward = reader.uint32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.answerType = reader.int32() as any;
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.answerId = reader.uint32();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.answers.push(CMsgDOTASeasonPredictions_Prediction_Answers.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.queryName = reader.string();
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.lockOnSelectionId = reader.uint32();
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.lockOnSelectionValue = reader.uint32();
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.lockOnSelectionSet = reader.bool();
          continue;
        case 16:
          if (tag !== 128) {
            break;
          }

          message.useAnswerValueRanges = reader.bool();
          continue;
        case 17:
          if (tag !== 136) {
            break;
          }

          message.region = reader.int32() as any;
          continue;
        case 18:
          if (tag === 144) {
            message.phases.push(reader.int32() as any);

            continue;
          }

          if (tag === 146) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.phases.push(reader.int32() as any);
            }

            continue;
          }

          break;
        case 19:
          if (tag !== 152) {
            break;
          }

          message.rewardEvent = reader.int32() as any;
          continue;
        case 20:
          if (tag !== 160) {
            break;
          }

          message.leagueNodeId = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTASeasonPredictions_Prediction {
    return {
      type: isSet(object.type) ? cMsgDOTASeasonPredictions_Prediction_EPredictionTypeFromJSON(object.type) : 0,
      question: isSet(object.question) ? globalThis.String(object.question) : "",
      choices: globalThis.Array.isArray(object?.choices)
        ? object.choices.map((e: any) => CMsgPredictionChoice.fromJSON(e))
        : [],
      selectionId: isSet(object.selectionId) ? globalThis.Number(object.selectionId) : 0,
      startDate: isSet(object.startDate) ? globalThis.Number(object.startDate) : 0,
      lockDate: isSet(object.lockDate) ? globalThis.Number(object.lockDate) : 0,
      reward: isSet(object.reward) ? globalThis.Number(object.reward) : 0,
      answerType: isSet(object.answerType)
        ? cMsgDOTASeasonPredictions_Prediction_EAnswerTypeFromJSON(object.answerType)
        : 0,
      answerId: isSet(object.answerId) ? globalThis.Number(object.answerId) : 0,
      answers: globalThis.Array.isArray(object?.answers)
        ? object.answers.map((e: any) => CMsgDOTASeasonPredictions_Prediction_Answers.fromJSON(e))
        : [],
      queryName: isSet(object.queryName) ? globalThis.String(object.queryName) : "",
      lockOnSelectionId: isSet(object.lockOnSelectionId) ? globalThis.Number(object.lockOnSelectionId) : 0,
      lockOnSelectionValue: isSet(object.lockOnSelectionValue) ? globalThis.Number(object.lockOnSelectionValue) : 0,
      lockOnSelectionSet: isSet(object.lockOnSelectionSet) ? globalThis.Boolean(object.lockOnSelectionSet) : false,
      useAnswerValueRanges: isSet(object.useAnswerValueRanges)
        ? globalThis.Boolean(object.useAnswerValueRanges)
        : false,
      region: isSet(object.region) ? eLeagueRegionFromJSON(object.region) : 0,
      phases: globalThis.Array.isArray(object?.phases) ? object.phases.map((e: any) => eLeaguePhaseFromJSON(e)) : [],
      rewardEvent: isSet(object.rewardEvent) ? eEventFromJSON(object.rewardEvent) : 0,
      leagueNodeId: isSet(object.leagueNodeId) ? globalThis.Number(object.leagueNodeId) : 0,
    };
  },

  toJSON(message: CMsgDOTASeasonPredictions_Prediction): unknown {
    const obj: any = {};
    if (message.type !== undefined && message.type !== 0) {
      obj.type = cMsgDOTASeasonPredictions_Prediction_EPredictionTypeToJSON(message.type);
    }
    if (message.question !== undefined && message.question !== "") {
      obj.question = message.question;
    }
    if (message.choices?.length) {
      obj.choices = message.choices.map((e) => CMsgPredictionChoice.toJSON(e));
    }
    if (message.selectionId !== undefined && message.selectionId !== 0) {
      obj.selectionId = Math.round(message.selectionId);
    }
    if (message.startDate !== undefined && message.startDate !== 0) {
      obj.startDate = Math.round(message.startDate);
    }
    if (message.lockDate !== undefined && message.lockDate !== 0) {
      obj.lockDate = Math.round(message.lockDate);
    }
    if (message.reward !== undefined && message.reward !== 0) {
      obj.reward = Math.round(message.reward);
    }
    if (message.answerType !== undefined && message.answerType !== 0) {
      obj.answerType = cMsgDOTASeasonPredictions_Prediction_EAnswerTypeToJSON(message.answerType);
    }
    if (message.answerId !== undefined && message.answerId !== 0) {
      obj.answerId = Math.round(message.answerId);
    }
    if (message.answers?.length) {
      obj.answers = message.answers.map((e) => CMsgDOTASeasonPredictions_Prediction_Answers.toJSON(e));
    }
    if (message.queryName !== undefined && message.queryName !== "") {
      obj.queryName = message.queryName;
    }
    if (message.lockOnSelectionId !== undefined && message.lockOnSelectionId !== 0) {
      obj.lockOnSelectionId = Math.round(message.lockOnSelectionId);
    }
    if (message.lockOnSelectionValue !== undefined && message.lockOnSelectionValue !== 0) {
      obj.lockOnSelectionValue = Math.round(message.lockOnSelectionValue);
    }
    if (message.lockOnSelectionSet !== undefined && message.lockOnSelectionSet !== false) {
      obj.lockOnSelectionSet = message.lockOnSelectionSet;
    }
    if (message.useAnswerValueRanges !== undefined && message.useAnswerValueRanges !== false) {
      obj.useAnswerValueRanges = message.useAnswerValueRanges;
    }
    if (message.region !== undefined && message.region !== 0) {
      obj.region = eLeagueRegionToJSON(message.region);
    }
    if (message.phases?.length) {
      obj.phases = message.phases.map((e) => eLeaguePhaseToJSON(e));
    }
    if (message.rewardEvent !== undefined && message.rewardEvent !== 0) {
      obj.rewardEvent = eEventToJSON(message.rewardEvent);
    }
    if (message.leagueNodeId !== undefined && message.leagueNodeId !== 0) {
      obj.leagueNodeId = Math.round(message.leagueNodeId);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTASeasonPredictions_Prediction>): CMsgDOTASeasonPredictions_Prediction {
    return CMsgDOTASeasonPredictions_Prediction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTASeasonPredictions_Prediction>): CMsgDOTASeasonPredictions_Prediction {
    const message = createBaseCMsgDOTASeasonPredictions_Prediction();
    message.type = object.type ?? 0;
    message.question = object.question ?? "";
    message.choices = object.choices?.map((e) => CMsgPredictionChoice.fromPartial(e)) || [];
    message.selectionId = object.selectionId ?? 0;
    message.startDate = object.startDate ?? 0;
    message.lockDate = object.lockDate ?? 0;
    message.reward = object.reward ?? 0;
    message.answerType = object.answerType ?? 0;
    message.answerId = object.answerId ?? 0;
    message.answers = object.answers?.map((e) => CMsgDOTASeasonPredictions_Prediction_Answers.fromPartial(e)) || [];
    message.queryName = object.queryName ?? "";
    message.lockOnSelectionId = object.lockOnSelectionId ?? 0;
    message.lockOnSelectionValue = object.lockOnSelectionValue ?? 0;
    message.lockOnSelectionSet = object.lockOnSelectionSet ?? false;
    message.useAnswerValueRanges = object.useAnswerValueRanges ?? false;
    message.region = object.region ?? 0;
    message.phases = object.phases?.map((e) => e) || [];
    message.rewardEvent = object.rewardEvent ?? 0;
    message.leagueNodeId = object.leagueNodeId ?? 0;
    return message;
  },
};

function createBaseCMsgDOTASeasonPredictions_Prediction_Answers(): CMsgDOTASeasonPredictions_Prediction_Answers {
  return { answerId: 0 };
}

export const CMsgDOTASeasonPredictions_Prediction_Answers = {
  encode(message: CMsgDOTASeasonPredictions_Prediction_Answers, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.answerId !== undefined && message.answerId !== 0) {
      writer.uint32(8).uint32(message.answerId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTASeasonPredictions_Prediction_Answers {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTASeasonPredictions_Prediction_Answers();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.answerId = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTASeasonPredictions_Prediction_Answers {
    return { answerId: isSet(object.answerId) ? globalThis.Number(object.answerId) : 0 };
  },

  toJSON(message: CMsgDOTASeasonPredictions_Prediction_Answers): unknown {
    const obj: any = {};
    if (message.answerId !== undefined && message.answerId !== 0) {
      obj.answerId = Math.round(message.answerId);
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgDOTASeasonPredictions_Prediction_Answers>,
  ): CMsgDOTASeasonPredictions_Prediction_Answers {
    return CMsgDOTASeasonPredictions_Prediction_Answers.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgDOTASeasonPredictions_Prediction_Answers>,
  ): CMsgDOTASeasonPredictions_Prediction_Answers {
    const message = createBaseCMsgDOTASeasonPredictions_Prediction_Answers();
    message.answerId = object.answerId ?? 0;
    return message;
  },
};

function createBaseCMsgAvailablePredictions(): CMsgAvailablePredictions {
  return { matchPredictions: [] };
}

export const CMsgAvailablePredictions = {
  encode(message: CMsgAvailablePredictions, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.matchPredictions) {
      CMsgAvailablePredictions_MatchPrediction.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgAvailablePredictions {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgAvailablePredictions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.matchPredictions.push(CMsgAvailablePredictions_MatchPrediction.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgAvailablePredictions {
    return {
      matchPredictions: globalThis.Array.isArray(object?.matchPredictions)
        ? object.matchPredictions.map((e: any) => CMsgAvailablePredictions_MatchPrediction.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgAvailablePredictions): unknown {
    const obj: any = {};
    if (message.matchPredictions?.length) {
      obj.matchPredictions = message.matchPredictions.map((e) => CMsgAvailablePredictions_MatchPrediction.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgAvailablePredictions>): CMsgAvailablePredictions {
    return CMsgAvailablePredictions.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgAvailablePredictions>): CMsgAvailablePredictions {
    const message = createBaseCMsgAvailablePredictions();
    message.matchPredictions =
      object.matchPredictions?.map((e) => CMsgAvailablePredictions_MatchPrediction.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgAvailablePredictions_MatchPrediction(): CMsgAvailablePredictions_MatchPrediction {
  return { matchId: "0", predictions: [] };
}

export const CMsgAvailablePredictions_MatchPrediction = {
  encode(message: CMsgAvailablePredictions_MatchPrediction, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.matchId !== undefined && message.matchId !== "0") {
      writer.uint32(8).uint64(message.matchId);
    }
    for (const v of message.predictions) {
      CMsgInGamePrediction.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgAvailablePredictions_MatchPrediction {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgAvailablePredictions_MatchPrediction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.matchId = longToString(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.predictions.push(CMsgInGamePrediction.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgAvailablePredictions_MatchPrediction {
    return {
      matchId: isSet(object.matchId) ? globalThis.String(object.matchId) : "0",
      predictions: globalThis.Array.isArray(object?.predictions)
        ? object.predictions.map((e: any) => CMsgInGamePrediction.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgAvailablePredictions_MatchPrediction): unknown {
    const obj: any = {};
    if (message.matchId !== undefined && message.matchId !== "0") {
      obj.matchId = message.matchId;
    }
    if (message.predictions?.length) {
      obj.predictions = message.predictions.map((e) => CMsgInGamePrediction.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgAvailablePredictions_MatchPrediction>): CMsgAvailablePredictions_MatchPrediction {
    return CMsgAvailablePredictions_MatchPrediction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgAvailablePredictions_MatchPrediction>): CMsgAvailablePredictions_MatchPrediction {
    const message = createBaseCMsgAvailablePredictions_MatchPrediction();
    message.matchId = object.matchId ?? "0";
    message.predictions = object.predictions?.map((e) => CMsgInGamePrediction.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgLeagueWatchedGames(): CMsgLeagueWatchedGames {
  return { leagues: [] };
}

export const CMsgLeagueWatchedGames = {
  encode(message: CMsgLeagueWatchedGames, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.leagues) {
      CMsgLeagueWatchedGames_League.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgLeagueWatchedGames {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgLeagueWatchedGames();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.leagues.push(CMsgLeagueWatchedGames_League.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgLeagueWatchedGames {
    return {
      leagues: globalThis.Array.isArray(object?.leagues)
        ? object.leagues.map((e: any) => CMsgLeagueWatchedGames_League.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgLeagueWatchedGames): unknown {
    const obj: any = {};
    if (message.leagues?.length) {
      obj.leagues = message.leagues.map((e) => CMsgLeagueWatchedGames_League.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgLeagueWatchedGames>): CMsgLeagueWatchedGames {
    return CMsgLeagueWatchedGames.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgLeagueWatchedGames>): CMsgLeagueWatchedGames {
    const message = createBaseCMsgLeagueWatchedGames();
    message.leagues = object.leagues?.map((e) => CMsgLeagueWatchedGames_League.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgLeagueWatchedGames_Series(): CMsgLeagueWatchedGames_Series {
  return { nodeId: 0, game: [] };
}

export const CMsgLeagueWatchedGames_Series = {
  encode(message: CMsgLeagueWatchedGames_Series, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.nodeId !== undefined && message.nodeId !== 0) {
      writer.uint32(8).uint32(message.nodeId);
    }
    writer.uint32(18).fork();
    for (const v of message.game) {
      writer.uint32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgLeagueWatchedGames_Series {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgLeagueWatchedGames_Series();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.nodeId = reader.uint32();
          continue;
        case 2:
          if (tag === 16) {
            message.game.push(reader.uint32());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.game.push(reader.uint32());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgLeagueWatchedGames_Series {
    return {
      nodeId: isSet(object.nodeId) ? globalThis.Number(object.nodeId) : 0,
      game: globalThis.Array.isArray(object?.game) ? object.game.map((e: any) => globalThis.Number(e)) : [],
    };
  },

  toJSON(message: CMsgLeagueWatchedGames_Series): unknown {
    const obj: any = {};
    if (message.nodeId !== undefined && message.nodeId !== 0) {
      obj.nodeId = Math.round(message.nodeId);
    }
    if (message.game?.length) {
      obj.game = message.game.map((e) => Math.round(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgLeagueWatchedGames_Series>): CMsgLeagueWatchedGames_Series {
    return CMsgLeagueWatchedGames_Series.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgLeagueWatchedGames_Series>): CMsgLeagueWatchedGames_Series {
    const message = createBaseCMsgLeagueWatchedGames_Series();
    message.nodeId = object.nodeId ?? 0;
    message.game = object.game?.map((e) => e) || [];
    return message;
  },
};

function createBaseCMsgLeagueWatchedGames_League(): CMsgLeagueWatchedGames_League {
  return { leagueId: 0, series: [] };
}

export const CMsgLeagueWatchedGames_League = {
  encode(message: CMsgLeagueWatchedGames_League, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.leagueId !== undefined && message.leagueId !== 0) {
      writer.uint32(8).uint32(message.leagueId);
    }
    for (const v of message.series) {
      CMsgLeagueWatchedGames_Series.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgLeagueWatchedGames_League {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgLeagueWatchedGames_League();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.leagueId = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.series.push(CMsgLeagueWatchedGames_Series.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgLeagueWatchedGames_League {
    return {
      leagueId: isSet(object.leagueId) ? globalThis.Number(object.leagueId) : 0,
      series: globalThis.Array.isArray(object?.series)
        ? object.series.map((e: any) => CMsgLeagueWatchedGames_Series.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgLeagueWatchedGames_League): unknown {
    const obj: any = {};
    if (message.leagueId !== undefined && message.leagueId !== 0) {
      obj.leagueId = Math.round(message.leagueId);
    }
    if (message.series?.length) {
      obj.series = message.series.map((e) => CMsgLeagueWatchedGames_Series.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgLeagueWatchedGames_League>): CMsgLeagueWatchedGames_League {
    return CMsgLeagueWatchedGames_League.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgLeagueWatchedGames_League>): CMsgLeagueWatchedGames_League {
    const message = createBaseCMsgLeagueWatchedGames_League();
    message.leagueId = object.leagueId ?? 0;
    message.series = object.series?.map((e) => CMsgLeagueWatchedGames_Series.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgDOTAMatch(): CMsgDOTAMatch {
  return {
    duration: 0,
    starttime: 0,
    players: [],
    matchId: "0",
    towerStatus: [],
    barracksStatus: [],
    cluster: 0,
    firstBloodTime: 0,
    replaySalt: 0,
    serverIp: 0,
    serverPort: 0,
    lobbyType: 0,
    humanPlayers: 0,
    averageSkill: 0,
    gameBalance: 0,
    radiantTeamId: 0,
    direTeamId: 0,
    leagueid: 0,
    radiantTeamName: "",
    direTeamName: "",
    radiantTeamLogo: "0",
    direTeamLogo: "0",
    radiantTeamLogoUrl: "",
    direTeamLogoUrl: "",
    radiantTeamComplete: 0,
    direTeamComplete: 0,
    gameMode: 0,
    picksBans: [],
    matchSeqNum: "0",
    replayState: 0,
    radiantGuildId: 0,
    direGuildId: 0,
    radiantTeamTag: "",
    direTeamTag: "",
    seriesId: 0,
    seriesType: 0,
    broadcasterChannels: [],
    engine: 0,
    customGameData: undefined,
    matchFlags: 0,
    privateMetadataKey: 0,
    radiantTeamScore: 0,
    direTeamScore: 0,
    matchOutcome: 0,
    tournamentId: 0,
    tournamentRound: 0,
    preGameDuration: 0,
    coaches: [],
  };
}

export const CMsgDOTAMatch = {
  encode(message: CMsgDOTAMatch, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.duration !== undefined && message.duration !== 0) {
      writer.uint32(24).uint32(message.duration);
    }
    if (message.starttime !== undefined && message.starttime !== 0) {
      writer.uint32(37).fixed32(message.starttime);
    }
    for (const v of message.players) {
      CMsgDOTAMatch_Player.encode(v!, writer.uint32(42).fork()).ldelim();
    }
    if (message.matchId !== undefined && message.matchId !== "0") {
      writer.uint32(48).uint64(message.matchId);
    }
    writer.uint32(66).fork();
    for (const v of message.towerStatus) {
      writer.uint32(v);
    }
    writer.ldelim();
    writer.uint32(74).fork();
    for (const v of message.barracksStatus) {
      writer.uint32(v);
    }
    writer.ldelim();
    if (message.cluster !== undefined && message.cluster !== 0) {
      writer.uint32(80).uint32(message.cluster);
    }
    if (message.firstBloodTime !== undefined && message.firstBloodTime !== 0) {
      writer.uint32(96).uint32(message.firstBloodTime);
    }
    if (message.replaySalt !== undefined && message.replaySalt !== 0) {
      writer.uint32(109).fixed32(message.replaySalt);
    }
    if (message.serverIp !== undefined && message.serverIp !== 0) {
      writer.uint32(117).fixed32(message.serverIp);
    }
    if (message.serverPort !== undefined && message.serverPort !== 0) {
      writer.uint32(120).uint32(message.serverPort);
    }
    if (message.lobbyType !== undefined && message.lobbyType !== 0) {
      writer.uint32(128).uint32(message.lobbyType);
    }
    if (message.humanPlayers !== undefined && message.humanPlayers !== 0) {
      writer.uint32(136).uint32(message.humanPlayers);
    }
    if (message.averageSkill !== undefined && message.averageSkill !== 0) {
      writer.uint32(144).uint32(message.averageSkill);
    }
    if (message.gameBalance !== undefined && message.gameBalance !== 0) {
      writer.uint32(157).float(message.gameBalance);
    }
    if (message.radiantTeamId !== undefined && message.radiantTeamId !== 0) {
      writer.uint32(160).uint32(message.radiantTeamId);
    }
    if (message.direTeamId !== undefined && message.direTeamId !== 0) {
      writer.uint32(168).uint32(message.direTeamId);
    }
    if (message.leagueid !== undefined && message.leagueid !== 0) {
      writer.uint32(176).uint32(message.leagueid);
    }
    if (message.radiantTeamName !== undefined && message.radiantTeamName !== "") {
      writer.uint32(186).string(message.radiantTeamName);
    }
    if (message.direTeamName !== undefined && message.direTeamName !== "") {
      writer.uint32(194).string(message.direTeamName);
    }
    if (message.radiantTeamLogo !== undefined && message.radiantTeamLogo !== "0") {
      writer.uint32(200).uint64(message.radiantTeamLogo);
    }
    if (message.direTeamLogo !== undefined && message.direTeamLogo !== "0") {
      writer.uint32(208).uint64(message.direTeamLogo);
    }
    if (message.radiantTeamLogoUrl !== undefined && message.radiantTeamLogoUrl !== "") {
      writer.uint32(434).string(message.radiantTeamLogoUrl);
    }
    if (message.direTeamLogoUrl !== undefined && message.direTeamLogoUrl !== "") {
      writer.uint32(442).string(message.direTeamLogoUrl);
    }
    if (message.radiantTeamComplete !== undefined && message.radiantTeamComplete !== 0) {
      writer.uint32(216).uint32(message.radiantTeamComplete);
    }
    if (message.direTeamComplete !== undefined && message.direTeamComplete !== 0) {
      writer.uint32(224).uint32(message.direTeamComplete);
    }
    if (message.gameMode !== undefined && message.gameMode !== 0) {
      writer.uint32(248).int32(message.gameMode);
    }
    for (const v of message.picksBans) {
      CMatchHeroSelectEvent.encode(v!, writer.uint32(258).fork()).ldelim();
    }
    if (message.matchSeqNum !== undefined && message.matchSeqNum !== "0") {
      writer.uint32(264).uint64(message.matchSeqNum);
    }
    if (message.replayState !== undefined && message.replayState !== 0) {
      writer.uint32(272).int32(message.replayState);
    }
    if (message.radiantGuildId !== undefined && message.radiantGuildId !== 0) {
      writer.uint32(280).uint32(message.radiantGuildId);
    }
    if (message.direGuildId !== undefined && message.direGuildId !== 0) {
      writer.uint32(288).uint32(message.direGuildId);
    }
    if (message.radiantTeamTag !== undefined && message.radiantTeamTag !== "") {
      writer.uint32(298).string(message.radiantTeamTag);
    }
    if (message.direTeamTag !== undefined && message.direTeamTag !== "") {
      writer.uint32(306).string(message.direTeamTag);
    }
    if (message.seriesId !== undefined && message.seriesId !== 0) {
      writer.uint32(312).uint32(message.seriesId);
    }
    if (message.seriesType !== undefined && message.seriesType !== 0) {
      writer.uint32(320).uint32(message.seriesType);
    }
    for (const v of message.broadcasterChannels) {
      CMsgDOTAMatch_BroadcasterChannel.encode(v!, writer.uint32(346).fork()).ldelim();
    }
    if (message.engine !== undefined && message.engine !== 0) {
      writer.uint32(352).uint32(message.engine);
    }
    if (message.customGameData !== undefined) {
      CMsgDOTAMatch_CustomGameData.encode(message.customGameData, writer.uint32(362).fork()).ldelim();
    }
    if (message.matchFlags !== undefined && message.matchFlags !== 0) {
      writer.uint32(368).uint32(message.matchFlags);
    }
    if (message.privateMetadataKey !== undefined && message.privateMetadataKey !== 0) {
      writer.uint32(381).fixed32(message.privateMetadataKey);
    }
    if (message.radiantTeamScore !== undefined && message.radiantTeamScore !== 0) {
      writer.uint32(384).uint32(message.radiantTeamScore);
    }
    if (message.direTeamScore !== undefined && message.direTeamScore !== 0) {
      writer.uint32(392).uint32(message.direTeamScore);
    }
    if (message.matchOutcome !== undefined && message.matchOutcome !== 0) {
      writer.uint32(400).int32(message.matchOutcome);
    }
    if (message.tournamentId !== undefined && message.tournamentId !== 0) {
      writer.uint32(408).uint32(message.tournamentId);
    }
    if (message.tournamentRound !== undefined && message.tournamentRound !== 0) {
      writer.uint32(416).uint32(message.tournamentRound);
    }
    if (message.preGameDuration !== undefined && message.preGameDuration !== 0) {
      writer.uint32(424).uint32(message.preGameDuration);
    }
    for (const v of message.coaches) {
      CMsgDOTAMatch_Coach.encode(v!, writer.uint32(458).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTAMatch {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAMatch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 24) {
            break;
          }

          message.duration = reader.uint32();
          continue;
        case 4:
          if (tag !== 37) {
            break;
          }

          message.starttime = reader.fixed32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.players.push(CMsgDOTAMatch_Player.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.matchId = longToString(reader.uint64() as Long);
          continue;
        case 8:
          if (tag === 64) {
            message.towerStatus.push(reader.uint32());

            continue;
          }

          if (tag === 66) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.towerStatus.push(reader.uint32());
            }

            continue;
          }

          break;
        case 9:
          if (tag === 72) {
            message.barracksStatus.push(reader.uint32());

            continue;
          }

          if (tag === 74) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.barracksStatus.push(reader.uint32());
            }

            continue;
          }

          break;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.cluster = reader.uint32();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.firstBloodTime = reader.uint32();
          continue;
        case 13:
          if (tag !== 109) {
            break;
          }

          message.replaySalt = reader.fixed32();
          continue;
        case 14:
          if (tag !== 117) {
            break;
          }

          message.serverIp = reader.fixed32();
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.serverPort = reader.uint32();
          continue;
        case 16:
          if (tag !== 128) {
            break;
          }

          message.lobbyType = reader.uint32();
          continue;
        case 17:
          if (tag !== 136) {
            break;
          }

          message.humanPlayers = reader.uint32();
          continue;
        case 18:
          if (tag !== 144) {
            break;
          }

          message.averageSkill = reader.uint32();
          continue;
        case 19:
          if (tag !== 157) {
            break;
          }

          message.gameBalance = reader.float();
          continue;
        case 20:
          if (tag !== 160) {
            break;
          }

          message.radiantTeamId = reader.uint32();
          continue;
        case 21:
          if (tag !== 168) {
            break;
          }

          message.direTeamId = reader.uint32();
          continue;
        case 22:
          if (tag !== 176) {
            break;
          }

          message.leagueid = reader.uint32();
          continue;
        case 23:
          if (tag !== 186) {
            break;
          }

          message.radiantTeamName = reader.string();
          continue;
        case 24:
          if (tag !== 194) {
            break;
          }

          message.direTeamName = reader.string();
          continue;
        case 25:
          if (tag !== 200) {
            break;
          }

          message.radiantTeamLogo = longToString(reader.uint64() as Long);
          continue;
        case 26:
          if (tag !== 208) {
            break;
          }

          message.direTeamLogo = longToString(reader.uint64() as Long);
          continue;
        case 54:
          if (tag !== 434) {
            break;
          }

          message.radiantTeamLogoUrl = reader.string();
          continue;
        case 55:
          if (tag !== 442) {
            break;
          }

          message.direTeamLogoUrl = reader.string();
          continue;
        case 27:
          if (tag !== 216) {
            break;
          }

          message.radiantTeamComplete = reader.uint32();
          continue;
        case 28:
          if (tag !== 224) {
            break;
          }

          message.direTeamComplete = reader.uint32();
          continue;
        case 31:
          if (tag !== 248) {
            break;
          }

          message.gameMode = reader.int32() as any;
          continue;
        case 32:
          if (tag !== 258) {
            break;
          }

          message.picksBans.push(CMatchHeroSelectEvent.decode(reader, reader.uint32()));
          continue;
        case 33:
          if (tag !== 264) {
            break;
          }

          message.matchSeqNum = longToString(reader.uint64() as Long);
          continue;
        case 34:
          if (tag !== 272) {
            break;
          }

          message.replayState = reader.int32() as any;
          continue;
        case 35:
          if (tag !== 280) {
            break;
          }

          message.radiantGuildId = reader.uint32();
          continue;
        case 36:
          if (tag !== 288) {
            break;
          }

          message.direGuildId = reader.uint32();
          continue;
        case 37:
          if (tag !== 298) {
            break;
          }

          message.radiantTeamTag = reader.string();
          continue;
        case 38:
          if (tag !== 306) {
            break;
          }

          message.direTeamTag = reader.string();
          continue;
        case 39:
          if (tag !== 312) {
            break;
          }

          message.seriesId = reader.uint32();
          continue;
        case 40:
          if (tag !== 320) {
            break;
          }

          message.seriesType = reader.uint32();
          continue;
        case 43:
          if (tag !== 346) {
            break;
          }

          message.broadcasterChannels.push(CMsgDOTAMatch_BroadcasterChannel.decode(reader, reader.uint32()));
          continue;
        case 44:
          if (tag !== 352) {
            break;
          }

          message.engine = reader.uint32();
          continue;
        case 45:
          if (tag !== 362) {
            break;
          }

          message.customGameData = CMsgDOTAMatch_CustomGameData.decode(reader, reader.uint32());
          continue;
        case 46:
          if (tag !== 368) {
            break;
          }

          message.matchFlags = reader.uint32();
          continue;
        case 47:
          if (tag !== 381) {
            break;
          }

          message.privateMetadataKey = reader.fixed32();
          continue;
        case 48:
          if (tag !== 384) {
            break;
          }

          message.radiantTeamScore = reader.uint32();
          continue;
        case 49:
          if (tag !== 392) {
            break;
          }

          message.direTeamScore = reader.uint32();
          continue;
        case 50:
          if (tag !== 400) {
            break;
          }

          message.matchOutcome = reader.int32() as any;
          continue;
        case 51:
          if (tag !== 408) {
            break;
          }

          message.tournamentId = reader.uint32();
          continue;
        case 52:
          if (tag !== 416) {
            break;
          }

          message.tournamentRound = reader.uint32();
          continue;
        case 53:
          if (tag !== 424) {
            break;
          }

          message.preGameDuration = reader.uint32();
          continue;
        case 57:
          if (tag !== 458) {
            break;
          }

          message.coaches.push(CMsgDOTAMatch_Coach.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAMatch {
    return {
      duration: isSet(object.duration) ? globalThis.Number(object.duration) : 0,
      starttime: isSet(object.starttime) ? globalThis.Number(object.starttime) : 0,
      players: globalThis.Array.isArray(object?.players)
        ? object.players.map((e: any) => CMsgDOTAMatch_Player.fromJSON(e))
        : [],
      matchId: isSet(object.matchId) ? globalThis.String(object.matchId) : "0",
      towerStatus: globalThis.Array.isArray(object?.towerStatus)
        ? object.towerStatus.map((e: any) => globalThis.Number(e))
        : [],
      barracksStatus: globalThis.Array.isArray(object?.barracksStatus)
        ? object.barracksStatus.map((e: any) => globalThis.Number(e))
        : [],
      cluster: isSet(object.cluster) ? globalThis.Number(object.cluster) : 0,
      firstBloodTime: isSet(object.firstBloodTime) ? globalThis.Number(object.firstBloodTime) : 0,
      replaySalt: isSet(object.replaySalt) ? globalThis.Number(object.replaySalt) : 0,
      serverIp: isSet(object.serverIp) ? globalThis.Number(object.serverIp) : 0,
      serverPort: isSet(object.serverPort) ? globalThis.Number(object.serverPort) : 0,
      lobbyType: isSet(object.lobbyType) ? globalThis.Number(object.lobbyType) : 0,
      humanPlayers: isSet(object.humanPlayers) ? globalThis.Number(object.humanPlayers) : 0,
      averageSkill: isSet(object.averageSkill) ? globalThis.Number(object.averageSkill) : 0,
      gameBalance: isSet(object.gameBalance) ? globalThis.Number(object.gameBalance) : 0,
      radiantTeamId: isSet(object.radiantTeamId) ? globalThis.Number(object.radiantTeamId) : 0,
      direTeamId: isSet(object.direTeamId) ? globalThis.Number(object.direTeamId) : 0,
      leagueid: isSet(object.leagueid) ? globalThis.Number(object.leagueid) : 0,
      radiantTeamName: isSet(object.radiantTeamName) ? globalThis.String(object.radiantTeamName) : "",
      direTeamName: isSet(object.direTeamName) ? globalThis.String(object.direTeamName) : "",
      radiantTeamLogo: isSet(object.radiantTeamLogo) ? globalThis.String(object.radiantTeamLogo) : "0",
      direTeamLogo: isSet(object.direTeamLogo) ? globalThis.String(object.direTeamLogo) : "0",
      radiantTeamLogoUrl: isSet(object.radiantTeamLogoUrl) ? globalThis.String(object.radiantTeamLogoUrl) : "",
      direTeamLogoUrl: isSet(object.direTeamLogoUrl) ? globalThis.String(object.direTeamLogoUrl) : "",
      radiantTeamComplete: isSet(object.radiantTeamComplete) ? globalThis.Number(object.radiantTeamComplete) : 0,
      direTeamComplete: isSet(object.direTeamComplete) ? globalThis.Number(object.direTeamComplete) : 0,
      gameMode: isSet(object.gameMode) ? dOTAGameModeFromJSON(object.gameMode) : 0,
      picksBans: globalThis.Array.isArray(object?.picksBans)
        ? object.picksBans.map((e: any) => CMatchHeroSelectEvent.fromJSON(e))
        : [],
      matchSeqNum: isSet(object.matchSeqNum) ? globalThis.String(object.matchSeqNum) : "0",
      replayState: isSet(object.replayState) ? cMsgDOTAMatch_ReplayStateFromJSON(object.replayState) : 0,
      radiantGuildId: isSet(object.radiantGuildId) ? globalThis.Number(object.radiantGuildId) : 0,
      direGuildId: isSet(object.direGuildId) ? globalThis.Number(object.direGuildId) : 0,
      radiantTeamTag: isSet(object.radiantTeamTag) ? globalThis.String(object.radiantTeamTag) : "",
      direTeamTag: isSet(object.direTeamTag) ? globalThis.String(object.direTeamTag) : "",
      seriesId: isSet(object.seriesId) ? globalThis.Number(object.seriesId) : 0,
      seriesType: isSet(object.seriesType) ? globalThis.Number(object.seriesType) : 0,
      broadcasterChannels: globalThis.Array.isArray(object?.broadcasterChannels)
        ? object.broadcasterChannels.map((e: any) => CMsgDOTAMatch_BroadcasterChannel.fromJSON(e))
        : [],
      engine: isSet(object.engine) ? globalThis.Number(object.engine) : 0,
      customGameData: isSet(object.customGameData)
        ? CMsgDOTAMatch_CustomGameData.fromJSON(object.customGameData)
        : undefined,
      matchFlags: isSet(object.matchFlags) ? globalThis.Number(object.matchFlags) : 0,
      privateMetadataKey: isSet(object.privateMetadataKey) ? globalThis.Number(object.privateMetadataKey) : 0,
      radiantTeamScore: isSet(object.radiantTeamScore) ? globalThis.Number(object.radiantTeamScore) : 0,
      direTeamScore: isSet(object.direTeamScore) ? globalThis.Number(object.direTeamScore) : 0,
      matchOutcome: isSet(object.matchOutcome) ? eMatchOutcomeFromJSON(object.matchOutcome) : 0,
      tournamentId: isSet(object.tournamentId) ? globalThis.Number(object.tournamentId) : 0,
      tournamentRound: isSet(object.tournamentRound) ? globalThis.Number(object.tournamentRound) : 0,
      preGameDuration: isSet(object.preGameDuration) ? globalThis.Number(object.preGameDuration) : 0,
      coaches: globalThis.Array.isArray(object?.coaches)
        ? object.coaches.map((e: any) => CMsgDOTAMatch_Coach.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgDOTAMatch): unknown {
    const obj: any = {};
    if (message.duration !== undefined && message.duration !== 0) {
      obj.duration = Math.round(message.duration);
    }
    if (message.starttime !== undefined && message.starttime !== 0) {
      obj.starttime = Math.round(message.starttime);
    }
    if (message.players?.length) {
      obj.players = message.players.map((e) => CMsgDOTAMatch_Player.toJSON(e));
    }
    if (message.matchId !== undefined && message.matchId !== "0") {
      obj.matchId = message.matchId;
    }
    if (message.towerStatus?.length) {
      obj.towerStatus = message.towerStatus.map((e) => Math.round(e));
    }
    if (message.barracksStatus?.length) {
      obj.barracksStatus = message.barracksStatus.map((e) => Math.round(e));
    }
    if (message.cluster !== undefined && message.cluster !== 0) {
      obj.cluster = Math.round(message.cluster);
    }
    if (message.firstBloodTime !== undefined && message.firstBloodTime !== 0) {
      obj.firstBloodTime = Math.round(message.firstBloodTime);
    }
    if (message.replaySalt !== undefined && message.replaySalt !== 0) {
      obj.replaySalt = Math.round(message.replaySalt);
    }
    if (message.serverIp !== undefined && message.serverIp !== 0) {
      obj.serverIp = Math.round(message.serverIp);
    }
    if (message.serverPort !== undefined && message.serverPort !== 0) {
      obj.serverPort = Math.round(message.serverPort);
    }
    if (message.lobbyType !== undefined && message.lobbyType !== 0) {
      obj.lobbyType = Math.round(message.lobbyType);
    }
    if (message.humanPlayers !== undefined && message.humanPlayers !== 0) {
      obj.humanPlayers = Math.round(message.humanPlayers);
    }
    if (message.averageSkill !== undefined && message.averageSkill !== 0) {
      obj.averageSkill = Math.round(message.averageSkill);
    }
    if (message.gameBalance !== undefined && message.gameBalance !== 0) {
      obj.gameBalance = message.gameBalance;
    }
    if (message.radiantTeamId !== undefined && message.radiantTeamId !== 0) {
      obj.radiantTeamId = Math.round(message.radiantTeamId);
    }
    if (message.direTeamId !== undefined && message.direTeamId !== 0) {
      obj.direTeamId = Math.round(message.direTeamId);
    }
    if (message.leagueid !== undefined && message.leagueid !== 0) {
      obj.leagueid = Math.round(message.leagueid);
    }
    if (message.radiantTeamName !== undefined && message.radiantTeamName !== "") {
      obj.radiantTeamName = message.radiantTeamName;
    }
    if (message.direTeamName !== undefined && message.direTeamName !== "") {
      obj.direTeamName = message.direTeamName;
    }
    if (message.radiantTeamLogo !== undefined && message.radiantTeamLogo !== "0") {
      obj.radiantTeamLogo = message.radiantTeamLogo;
    }
    if (message.direTeamLogo !== undefined && message.direTeamLogo !== "0") {
      obj.direTeamLogo = message.direTeamLogo;
    }
    if (message.radiantTeamLogoUrl !== undefined && message.radiantTeamLogoUrl !== "") {
      obj.radiantTeamLogoUrl = message.radiantTeamLogoUrl;
    }
    if (message.direTeamLogoUrl !== undefined && message.direTeamLogoUrl !== "") {
      obj.direTeamLogoUrl = message.direTeamLogoUrl;
    }
    if (message.radiantTeamComplete !== undefined && message.radiantTeamComplete !== 0) {
      obj.radiantTeamComplete = Math.round(message.radiantTeamComplete);
    }
    if (message.direTeamComplete !== undefined && message.direTeamComplete !== 0) {
      obj.direTeamComplete = Math.round(message.direTeamComplete);
    }
    if (message.gameMode !== undefined && message.gameMode !== 0) {
      obj.gameMode = dOTAGameModeToJSON(message.gameMode);
    }
    if (message.picksBans?.length) {
      obj.picksBans = message.picksBans.map((e) => CMatchHeroSelectEvent.toJSON(e));
    }
    if (message.matchSeqNum !== undefined && message.matchSeqNum !== "0") {
      obj.matchSeqNum = message.matchSeqNum;
    }
    if (message.replayState !== undefined && message.replayState !== 0) {
      obj.replayState = cMsgDOTAMatch_ReplayStateToJSON(message.replayState);
    }
    if (message.radiantGuildId !== undefined && message.radiantGuildId !== 0) {
      obj.radiantGuildId = Math.round(message.radiantGuildId);
    }
    if (message.direGuildId !== undefined && message.direGuildId !== 0) {
      obj.direGuildId = Math.round(message.direGuildId);
    }
    if (message.radiantTeamTag !== undefined && message.radiantTeamTag !== "") {
      obj.radiantTeamTag = message.radiantTeamTag;
    }
    if (message.direTeamTag !== undefined && message.direTeamTag !== "") {
      obj.direTeamTag = message.direTeamTag;
    }
    if (message.seriesId !== undefined && message.seriesId !== 0) {
      obj.seriesId = Math.round(message.seriesId);
    }
    if (message.seriesType !== undefined && message.seriesType !== 0) {
      obj.seriesType = Math.round(message.seriesType);
    }
    if (message.broadcasterChannels?.length) {
      obj.broadcasterChannels = message.broadcasterChannels.map((e) => CMsgDOTAMatch_BroadcasterChannel.toJSON(e));
    }
    if (message.engine !== undefined && message.engine !== 0) {
      obj.engine = Math.round(message.engine);
    }
    if (message.customGameData !== undefined) {
      obj.customGameData = CMsgDOTAMatch_CustomGameData.toJSON(message.customGameData);
    }
    if (message.matchFlags !== undefined && message.matchFlags !== 0) {
      obj.matchFlags = Math.round(message.matchFlags);
    }
    if (message.privateMetadataKey !== undefined && message.privateMetadataKey !== 0) {
      obj.privateMetadataKey = Math.round(message.privateMetadataKey);
    }
    if (message.radiantTeamScore !== undefined && message.radiantTeamScore !== 0) {
      obj.radiantTeamScore = Math.round(message.radiantTeamScore);
    }
    if (message.direTeamScore !== undefined && message.direTeamScore !== 0) {
      obj.direTeamScore = Math.round(message.direTeamScore);
    }
    if (message.matchOutcome !== undefined && message.matchOutcome !== 0) {
      obj.matchOutcome = eMatchOutcomeToJSON(message.matchOutcome);
    }
    if (message.tournamentId !== undefined && message.tournamentId !== 0) {
      obj.tournamentId = Math.round(message.tournamentId);
    }
    if (message.tournamentRound !== undefined && message.tournamentRound !== 0) {
      obj.tournamentRound = Math.round(message.tournamentRound);
    }
    if (message.preGameDuration !== undefined && message.preGameDuration !== 0) {
      obj.preGameDuration = Math.round(message.preGameDuration);
    }
    if (message.coaches?.length) {
      obj.coaches = message.coaches.map((e) => CMsgDOTAMatch_Coach.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTAMatch>): CMsgDOTAMatch {
    return CMsgDOTAMatch.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTAMatch>): CMsgDOTAMatch {
    const message = createBaseCMsgDOTAMatch();
    message.duration = object.duration ?? 0;
    message.starttime = object.starttime ?? 0;
    message.players = object.players?.map((e) => CMsgDOTAMatch_Player.fromPartial(e)) || [];
    message.matchId = object.matchId ?? "0";
    message.towerStatus = object.towerStatus?.map((e) => e) || [];
    message.barracksStatus = object.barracksStatus?.map((e) => e) || [];
    message.cluster = object.cluster ?? 0;
    message.firstBloodTime = object.firstBloodTime ?? 0;
    message.replaySalt = object.replaySalt ?? 0;
    message.serverIp = object.serverIp ?? 0;
    message.serverPort = object.serverPort ?? 0;
    message.lobbyType = object.lobbyType ?? 0;
    message.humanPlayers = object.humanPlayers ?? 0;
    message.averageSkill = object.averageSkill ?? 0;
    message.gameBalance = object.gameBalance ?? 0;
    message.radiantTeamId = object.radiantTeamId ?? 0;
    message.direTeamId = object.direTeamId ?? 0;
    message.leagueid = object.leagueid ?? 0;
    message.radiantTeamName = object.radiantTeamName ?? "";
    message.direTeamName = object.direTeamName ?? "";
    message.radiantTeamLogo = object.radiantTeamLogo ?? "0";
    message.direTeamLogo = object.direTeamLogo ?? "0";
    message.radiantTeamLogoUrl = object.radiantTeamLogoUrl ?? "";
    message.direTeamLogoUrl = object.direTeamLogoUrl ?? "";
    message.radiantTeamComplete = object.radiantTeamComplete ?? 0;
    message.direTeamComplete = object.direTeamComplete ?? 0;
    message.gameMode = object.gameMode ?? 0;
    message.picksBans = object.picksBans?.map((e) => CMatchHeroSelectEvent.fromPartial(e)) || [];
    message.matchSeqNum = object.matchSeqNum ?? "0";
    message.replayState = object.replayState ?? 0;
    message.radiantGuildId = object.radiantGuildId ?? 0;
    message.direGuildId = object.direGuildId ?? 0;
    message.radiantTeamTag = object.radiantTeamTag ?? "";
    message.direTeamTag = object.direTeamTag ?? "";
    message.seriesId = object.seriesId ?? 0;
    message.seriesType = object.seriesType ?? 0;
    message.broadcasterChannels =
      object.broadcasterChannels?.map((e) => CMsgDOTAMatch_BroadcasterChannel.fromPartial(e)) || [];
    message.engine = object.engine ?? 0;
    message.customGameData = (object.customGameData !== undefined && object.customGameData !== null)
      ? CMsgDOTAMatch_CustomGameData.fromPartial(object.customGameData)
      : undefined;
    message.matchFlags = object.matchFlags ?? 0;
    message.privateMetadataKey = object.privateMetadataKey ?? 0;
    message.radiantTeamScore = object.radiantTeamScore ?? 0;
    message.direTeamScore = object.direTeamScore ?? 0;
    message.matchOutcome = object.matchOutcome ?? 0;
    message.tournamentId = object.tournamentId ?? 0;
    message.tournamentRound = object.tournamentRound ?? 0;
    message.preGameDuration = object.preGameDuration ?? 0;
    message.coaches = object.coaches?.map((e) => CMsgDOTAMatch_Coach.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgDOTAMatch_Player(): CMsgDOTAMatch_Player {
  return {
    accountId: 0,
    playerSlot: 0,
    heroId: 0,
    item0: -1,
    item1: -1,
    item2: -1,
    item3: -1,
    item4: -1,
    item5: -1,
    item6: -1,
    item7: -1,
    item8: -1,
    item9: -1,
    item10: -1,
    item10Lvl: 0,
    expectedTeamContribution: 0,
    scaledMetric: 0,
    previousRank: 0,
    rankChange: 0,
    mmrType: 0,
    kills: 0,
    deaths: 0,
    assists: 0,
    leaverStatus: 0,
    gold: 0,
    lastHits: 0,
    denies: 0,
    goldPerMin: 0,
    xpPerMin: 0,
    goldSpent: 0,
    heroDamage: 0,
    towerDamage: 0,
    heroHealing: 0,
    level: 0,
    timeLastSeen: 0,
    playerName: "",
    supportAbilityValue: 0,
    feedingDetected: false,
    searchRank: 0,
    searchRankUncertainty: 0,
    rankUncertaintyChange: 0,
    heroPlayCount: 0,
    partyId: "0",
    scaledHeroDamage: 0,
    scaledTowerDamage: 0,
    scaledHeroHealing: 0,
    scaledKills: 0,
    scaledDeaths: 0,
    scaledAssists: 0,
    claimedFarmGold: 0,
    supportGold: 0,
    claimedDenies: 0,
    claimedMisses: 0,
    misses: 0,
    abilityUpgrades: [],
    additionalUnitsInventory: [],
    permanentBuffs: [],
    proName: "",
    realName: "",
    customGameData: undefined,
    activePlusSubscription: false,
    netWorth: 0,
    botDifficulty: 0,
    heroPickOrder: 0,
    heroWasRandomed: false,
    heroWasDotaPlusSuggestion: false,
    heroDamageReceived: [],
    heroDamageDealt: [],
    secondsDead: 0,
    goldLostToDeath: 0,
    laneSelectionFlags: 0,
    bountyRunes: 0,
    outpostsCaptured: 0,
    teamNumber: 0,
    teamSlot: 0,
    selectedFacet: 0,
  };
}

export const CMsgDOTAMatch_Player = {
  encode(message: CMsgDOTAMatch_Player, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.accountId !== undefined && message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    if (message.playerSlot !== undefined && message.playerSlot !== 0) {
      writer.uint32(16).uint32(message.playerSlot);
    }
    if (message.heroId !== undefined && message.heroId !== 0) {
      writer.uint32(24).int32(message.heroId);
    }
    if (message.item0 !== undefined && message.item0 !== -1) {
      writer.uint32(32).int32(message.item0);
    }
    if (message.item1 !== undefined && message.item1 !== -1) {
      writer.uint32(40).int32(message.item1);
    }
    if (message.item2 !== undefined && message.item2 !== -1) {
      writer.uint32(48).int32(message.item2);
    }
    if (message.item3 !== undefined && message.item3 !== -1) {
      writer.uint32(56).int32(message.item3);
    }
    if (message.item4 !== undefined && message.item4 !== -1) {
      writer.uint32(64).int32(message.item4);
    }
    if (message.item5 !== undefined && message.item5 !== -1) {
      writer.uint32(72).int32(message.item5);
    }
    if (message.item6 !== undefined && message.item6 !== -1) {
      writer.uint32(472).int32(message.item6);
    }
    if (message.item7 !== undefined && message.item7 !== -1) {
      writer.uint32(480).int32(message.item7);
    }
    if (message.item8 !== undefined && message.item8 !== -1) {
      writer.uint32(488).int32(message.item8);
    }
    if (message.item9 !== undefined && message.item9 !== -1) {
      writer.uint32(608).int32(message.item9);
    }
    if (message.item10 !== undefined && message.item10 !== -1) {
      writer.uint32(664).int32(message.item10);
    }
    if (message.item10Lvl !== undefined && message.item10Lvl !== 0) {
      writer.uint32(672).int32(message.item10Lvl);
    }
    if (message.expectedTeamContribution !== undefined && message.expectedTeamContribution !== 0) {
      writer.uint32(85).float(message.expectedTeamContribution);
    }
    if (message.scaledMetric !== undefined && message.scaledMetric !== 0) {
      writer.uint32(93).float(message.scaledMetric);
    }
    if (message.previousRank !== undefined && message.previousRank !== 0) {
      writer.uint32(96).uint32(message.previousRank);
    }
    if (message.rankChange !== undefined && message.rankChange !== 0) {
      writer.uint32(104).sint32(message.rankChange);
    }
    if (message.mmrType !== undefined && message.mmrType !== 0) {
      writer.uint32(592).uint32(message.mmrType);
    }
    if (message.kills !== undefined && message.kills !== 0) {
      writer.uint32(112).uint32(message.kills);
    }
    if (message.deaths !== undefined && message.deaths !== 0) {
      writer.uint32(120).uint32(message.deaths);
    }
    if (message.assists !== undefined && message.assists !== 0) {
      writer.uint32(128).uint32(message.assists);
    }
    if (message.leaverStatus !== undefined && message.leaverStatus !== 0) {
      writer.uint32(136).uint32(message.leaverStatus);
    }
    if (message.gold !== undefined && message.gold !== 0) {
      writer.uint32(144).uint32(message.gold);
    }
    if (message.lastHits !== undefined && message.lastHits !== 0) {
      writer.uint32(152).uint32(message.lastHits);
    }
    if (message.denies !== undefined && message.denies !== 0) {
      writer.uint32(160).uint32(message.denies);
    }
    if (message.goldPerMin !== undefined && message.goldPerMin !== 0) {
      writer.uint32(168).uint32(message.goldPerMin);
    }
    if (message.xpPerMin !== undefined && message.xpPerMin !== 0) {
      writer.uint32(176).uint32(message.xpPerMin);
    }
    if (message.goldSpent !== undefined && message.goldSpent !== 0) {
      writer.uint32(184).uint32(message.goldSpent);
    }
    if (message.heroDamage !== undefined && message.heroDamage !== 0) {
      writer.uint32(192).uint32(message.heroDamage);
    }
    if (message.towerDamage !== undefined && message.towerDamage !== 0) {
      writer.uint32(200).uint32(message.towerDamage);
    }
    if (message.heroHealing !== undefined && message.heroHealing !== 0) {
      writer.uint32(208).uint32(message.heroHealing);
    }
    if (message.level !== undefined && message.level !== 0) {
      writer.uint32(216).uint32(message.level);
    }
    if (message.timeLastSeen !== undefined && message.timeLastSeen !== 0) {
      writer.uint32(224).uint32(message.timeLastSeen);
    }
    if (message.playerName !== undefined && message.playerName !== "") {
      writer.uint32(234).string(message.playerName);
    }
    if (message.supportAbilityValue !== undefined && message.supportAbilityValue !== 0) {
      writer.uint32(240).uint32(message.supportAbilityValue);
    }
    if (message.feedingDetected !== undefined && message.feedingDetected !== false) {
      writer.uint32(256).bool(message.feedingDetected);
    }
    if (message.searchRank !== undefined && message.searchRank !== 0) {
      writer.uint32(272).uint32(message.searchRank);
    }
    if (message.searchRankUncertainty !== undefined && message.searchRankUncertainty !== 0) {
      writer.uint32(280).uint32(message.searchRankUncertainty);
    }
    if (message.rankUncertaintyChange !== undefined && message.rankUncertaintyChange !== 0) {
      writer.uint32(288).int32(message.rankUncertaintyChange);
    }
    if (message.heroPlayCount !== undefined && message.heroPlayCount !== 0) {
      writer.uint32(296).uint32(message.heroPlayCount);
    }
    if (message.partyId !== undefined && message.partyId !== "0") {
      writer.uint32(305).fixed64(message.partyId);
    }
    if (message.scaledHeroDamage !== undefined && message.scaledHeroDamage !== 0) {
      writer.uint32(432).uint32(message.scaledHeroDamage);
    }
    if (message.scaledTowerDamage !== undefined && message.scaledTowerDamage !== 0) {
      writer.uint32(440).uint32(message.scaledTowerDamage);
    }
    if (message.scaledHeroHealing !== undefined && message.scaledHeroHealing !== 0) {
      writer.uint32(448).uint32(message.scaledHeroHealing);
    }
    if (message.scaledKills !== undefined && message.scaledKills !== 0) {
      writer.uint32(317).float(message.scaledKills);
    }
    if (message.scaledDeaths !== undefined && message.scaledDeaths !== 0) {
      writer.uint32(325).float(message.scaledDeaths);
    }
    if (message.scaledAssists !== undefined && message.scaledAssists !== 0) {
      writer.uint32(333).float(message.scaledAssists);
    }
    if (message.claimedFarmGold !== undefined && message.claimedFarmGold !== 0) {
      writer.uint32(336).uint32(message.claimedFarmGold);
    }
    if (message.supportGold !== undefined && message.supportGold !== 0) {
      writer.uint32(344).uint32(message.supportGold);
    }
    if (message.claimedDenies !== undefined && message.claimedDenies !== 0) {
      writer.uint32(352).uint32(message.claimedDenies);
    }
    if (message.claimedMisses !== undefined && message.claimedMisses !== 0) {
      writer.uint32(360).uint32(message.claimedMisses);
    }
    if (message.misses !== undefined && message.misses !== 0) {
      writer.uint32(368).uint32(message.misses);
    }
    for (const v of message.abilityUpgrades) {
      CMatchPlayerAbilityUpgrade.encode(v!, writer.uint32(378).fork()).ldelim();
    }
    for (const v of message.additionalUnitsInventory) {
      CMatchAdditionalUnitInventory.encode(v!, writer.uint32(386).fork()).ldelim();
    }
    for (const v of message.permanentBuffs) {
      CMatchPlayerPermanentBuff.encode(v!, writer.uint32(458).fork()).ldelim();
    }
    if (message.proName !== undefined && message.proName !== "") {
      writer.uint32(578).string(message.proName);
    }
    if (message.realName !== undefined && message.realName !== "") {
      writer.uint32(586).string(message.realName);
    }
    if (message.customGameData !== undefined) {
      CMsgDOTAMatch_Player_CustomGameData.encode(message.customGameData, writer.uint32(402).fork()).ldelim();
    }
    if (message.activePlusSubscription !== undefined && message.activePlusSubscription !== false) {
      writer.uint32(408).bool(message.activePlusSubscription);
    }
    if (message.netWorth !== undefined && message.netWorth !== 0) {
      writer.uint32(416).uint32(message.netWorth);
    }
    if (message.botDifficulty !== undefined && message.botDifficulty !== 0) {
      writer.uint32(464).uint32(message.botDifficulty);
    }
    if (message.heroPickOrder !== undefined && message.heroPickOrder !== 0) {
      writer.uint32(504).uint32(message.heroPickOrder);
    }
    if (message.heroWasRandomed !== undefined && message.heroWasRandomed !== false) {
      writer.uint32(512).bool(message.heroWasRandomed);
    }
    if (message.heroWasDotaPlusSuggestion !== undefined && message.heroWasDotaPlusSuggestion !== false) {
      writer.uint32(552).bool(message.heroWasDotaPlusSuggestion);
    }
    for (const v of message.heroDamageReceived) {
      CMsgDOTAMatch_Player_HeroDamageReceived.encode(v!, writer.uint32(538).fork()).ldelim();
    }
    for (const v of message.heroDamageDealt) {
      CMsgDOTAMatch_Player_HeroDamageReceived.encode(v!, writer.uint32(634).fork()).ldelim();
    }
    if (message.secondsDead !== undefined && message.secondsDead !== 0) {
      writer.uint32(560).uint32(message.secondsDead);
    }
    if (message.goldLostToDeath !== undefined && message.goldLostToDeath !== 0) {
      writer.uint32(568).uint32(message.goldLostToDeath);
    }
    if (message.laneSelectionFlags !== undefined && message.laneSelectionFlags !== 0) {
      writer.uint32(600).uint32(message.laneSelectionFlags);
    }
    if (message.bountyRunes !== undefined && message.bountyRunes !== 0) {
      writer.uint32(616).uint32(message.bountyRunes);
    }
    if (message.outpostsCaptured !== undefined && message.outpostsCaptured !== 0) {
      writer.uint32(624).uint32(message.outpostsCaptured);
    }
    if (message.teamNumber !== undefined && message.teamNumber !== 0) {
      writer.uint32(640).int32(message.teamNumber);
    }
    if (message.teamSlot !== undefined && message.teamSlot !== 0) {
      writer.uint32(648).uint32(message.teamSlot);
    }
    if (message.selectedFacet !== undefined && message.selectedFacet !== 0) {
      writer.uint32(656).uint32(message.selectedFacet);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTAMatch_Player {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAMatch_Player();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.playerSlot = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.heroId = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.item0 = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.item1 = reader.int32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.item2 = reader.int32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.item3 = reader.int32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.item4 = reader.int32();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.item5 = reader.int32();
          continue;
        case 59:
          if (tag !== 472) {
            break;
          }

          message.item6 = reader.int32();
          continue;
        case 60:
          if (tag !== 480) {
            break;
          }

          message.item7 = reader.int32();
          continue;
        case 61:
          if (tag !== 488) {
            break;
          }

          message.item8 = reader.int32();
          continue;
        case 76:
          if (tag !== 608) {
            break;
          }

          message.item9 = reader.int32();
          continue;
        case 83:
          if (tag !== 664) {
            break;
          }

          message.item10 = reader.int32();
          continue;
        case 84:
          if (tag !== 672) {
            break;
          }

          message.item10Lvl = reader.int32();
          continue;
        case 10:
          if (tag !== 85) {
            break;
          }

          message.expectedTeamContribution = reader.float();
          continue;
        case 11:
          if (tag !== 93) {
            break;
          }

          message.scaledMetric = reader.float();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.previousRank = reader.uint32();
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.rankChange = reader.sint32();
          continue;
        case 74:
          if (tag !== 592) {
            break;
          }

          message.mmrType = reader.uint32();
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.kills = reader.uint32();
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.deaths = reader.uint32();
          continue;
        case 16:
          if (tag !== 128) {
            break;
          }

          message.assists = reader.uint32();
          continue;
        case 17:
          if (tag !== 136) {
            break;
          }

          message.leaverStatus = reader.uint32();
          continue;
        case 18:
          if (tag !== 144) {
            break;
          }

          message.gold = reader.uint32();
          continue;
        case 19:
          if (tag !== 152) {
            break;
          }

          message.lastHits = reader.uint32();
          continue;
        case 20:
          if (tag !== 160) {
            break;
          }

          message.denies = reader.uint32();
          continue;
        case 21:
          if (tag !== 168) {
            break;
          }

          message.goldPerMin = reader.uint32();
          continue;
        case 22:
          if (tag !== 176) {
            break;
          }

          message.xpPerMin = reader.uint32();
          continue;
        case 23:
          if (tag !== 184) {
            break;
          }

          message.goldSpent = reader.uint32();
          continue;
        case 24:
          if (tag !== 192) {
            break;
          }

          message.heroDamage = reader.uint32();
          continue;
        case 25:
          if (tag !== 200) {
            break;
          }

          message.towerDamage = reader.uint32();
          continue;
        case 26:
          if (tag !== 208) {
            break;
          }

          message.heroHealing = reader.uint32();
          continue;
        case 27:
          if (tag !== 216) {
            break;
          }

          message.level = reader.uint32();
          continue;
        case 28:
          if (tag !== 224) {
            break;
          }

          message.timeLastSeen = reader.uint32();
          continue;
        case 29:
          if (tag !== 234) {
            break;
          }

          message.playerName = reader.string();
          continue;
        case 30:
          if (tag !== 240) {
            break;
          }

          message.supportAbilityValue = reader.uint32();
          continue;
        case 32:
          if (tag !== 256) {
            break;
          }

          message.feedingDetected = reader.bool();
          continue;
        case 34:
          if (tag !== 272) {
            break;
          }

          message.searchRank = reader.uint32();
          continue;
        case 35:
          if (tag !== 280) {
            break;
          }

          message.searchRankUncertainty = reader.uint32();
          continue;
        case 36:
          if (tag !== 288) {
            break;
          }

          message.rankUncertaintyChange = reader.int32();
          continue;
        case 37:
          if (tag !== 296) {
            break;
          }

          message.heroPlayCount = reader.uint32();
          continue;
        case 38:
          if (tag !== 305) {
            break;
          }

          message.partyId = longToString(reader.fixed64() as Long);
          continue;
        case 54:
          if (tag !== 432) {
            break;
          }

          message.scaledHeroDamage = reader.uint32();
          continue;
        case 55:
          if (tag !== 440) {
            break;
          }

          message.scaledTowerDamage = reader.uint32();
          continue;
        case 56:
          if (tag !== 448) {
            break;
          }

          message.scaledHeroHealing = reader.uint32();
          continue;
        case 39:
          if (tag !== 317) {
            break;
          }

          message.scaledKills = reader.float();
          continue;
        case 40:
          if (tag !== 325) {
            break;
          }

          message.scaledDeaths = reader.float();
          continue;
        case 41:
          if (tag !== 333) {
            break;
          }

          message.scaledAssists = reader.float();
          continue;
        case 42:
          if (tag !== 336) {
            break;
          }

          message.claimedFarmGold = reader.uint32();
          continue;
        case 43:
          if (tag !== 344) {
            break;
          }

          message.supportGold = reader.uint32();
          continue;
        case 44:
          if (tag !== 352) {
            break;
          }

          message.claimedDenies = reader.uint32();
          continue;
        case 45:
          if (tag !== 360) {
            break;
          }

          message.claimedMisses = reader.uint32();
          continue;
        case 46:
          if (tag !== 368) {
            break;
          }

          message.misses = reader.uint32();
          continue;
        case 47:
          if (tag !== 378) {
            break;
          }

          message.abilityUpgrades.push(CMatchPlayerAbilityUpgrade.decode(reader, reader.uint32()));
          continue;
        case 48:
          if (tag !== 386) {
            break;
          }

          message.additionalUnitsInventory.push(CMatchAdditionalUnitInventory.decode(reader, reader.uint32()));
          continue;
        case 57:
          if (tag !== 458) {
            break;
          }

          message.permanentBuffs.push(CMatchPlayerPermanentBuff.decode(reader, reader.uint32()));
          continue;
        case 72:
          if (tag !== 578) {
            break;
          }

          message.proName = reader.string();
          continue;
        case 73:
          if (tag !== 586) {
            break;
          }

          message.realName = reader.string();
          continue;
        case 50:
          if (tag !== 402) {
            break;
          }

          message.customGameData = CMsgDOTAMatch_Player_CustomGameData.decode(reader, reader.uint32());
          continue;
        case 51:
          if (tag !== 408) {
            break;
          }

          message.activePlusSubscription = reader.bool();
          continue;
        case 52:
          if (tag !== 416) {
            break;
          }

          message.netWorth = reader.uint32();
          continue;
        case 58:
          if (tag !== 464) {
            break;
          }

          message.botDifficulty = reader.uint32();
          continue;
        case 63:
          if (tag !== 504) {
            break;
          }

          message.heroPickOrder = reader.uint32();
          continue;
        case 64:
          if (tag !== 512) {
            break;
          }

          message.heroWasRandomed = reader.bool();
          continue;
        case 69:
          if (tag !== 552) {
            break;
          }

          message.heroWasDotaPlusSuggestion = reader.bool();
          continue;
        case 67:
          if (tag !== 538) {
            break;
          }

          message.heroDamageReceived.push(CMsgDOTAMatch_Player_HeroDamageReceived.decode(reader, reader.uint32()));
          continue;
        case 79:
          if (tag !== 634) {
            break;
          }

          message.heroDamageDealt.push(CMsgDOTAMatch_Player_HeroDamageReceived.decode(reader, reader.uint32()));
          continue;
        case 70:
          if (tag !== 560) {
            break;
          }

          message.secondsDead = reader.uint32();
          continue;
        case 71:
          if (tag !== 568) {
            break;
          }

          message.goldLostToDeath = reader.uint32();
          continue;
        case 75:
          if (tag !== 600) {
            break;
          }

          message.laneSelectionFlags = reader.uint32();
          continue;
        case 77:
          if (tag !== 616) {
            break;
          }

          message.bountyRunes = reader.uint32();
          continue;
        case 78:
          if (tag !== 624) {
            break;
          }

          message.outpostsCaptured = reader.uint32();
          continue;
        case 80:
          if (tag !== 640) {
            break;
          }

          message.teamNumber = reader.int32() as any;
          continue;
        case 81:
          if (tag !== 648) {
            break;
          }

          message.teamSlot = reader.uint32();
          continue;
        case 82:
          if (tag !== 656) {
            break;
          }

          message.selectedFacet = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAMatch_Player {
    return {
      accountId: isSet(object.accountId) ? globalThis.Number(object.accountId) : 0,
      playerSlot: isSet(object.playerSlot) ? globalThis.Number(object.playerSlot) : 0,
      heroId: isSet(object.heroId) ? globalThis.Number(object.heroId) : 0,
      item0: isSet(object.item0) ? globalThis.Number(object.item0) : -1,
      item1: isSet(object.item1) ? globalThis.Number(object.item1) : -1,
      item2: isSet(object.item2) ? globalThis.Number(object.item2) : -1,
      item3: isSet(object.item3) ? globalThis.Number(object.item3) : -1,
      item4: isSet(object.item4) ? globalThis.Number(object.item4) : -1,
      item5: isSet(object.item5) ? globalThis.Number(object.item5) : -1,
      item6: isSet(object.item6) ? globalThis.Number(object.item6) : -1,
      item7: isSet(object.item7) ? globalThis.Number(object.item7) : -1,
      item8: isSet(object.item8) ? globalThis.Number(object.item8) : -1,
      item9: isSet(object.item9) ? globalThis.Number(object.item9) : -1,
      item10: isSet(object.item10) ? globalThis.Number(object.item10) : -1,
      item10Lvl: isSet(object.item10Lvl) ? globalThis.Number(object.item10Lvl) : 0,
      expectedTeamContribution: isSet(object.expectedTeamContribution)
        ? globalThis.Number(object.expectedTeamContribution)
        : 0,
      scaledMetric: isSet(object.scaledMetric) ? globalThis.Number(object.scaledMetric) : 0,
      previousRank: isSet(object.previousRank) ? globalThis.Number(object.previousRank) : 0,
      rankChange: isSet(object.rankChange) ? globalThis.Number(object.rankChange) : 0,
      mmrType: isSet(object.mmrType) ? globalThis.Number(object.mmrType) : 0,
      kills: isSet(object.kills) ? globalThis.Number(object.kills) : 0,
      deaths: isSet(object.deaths) ? globalThis.Number(object.deaths) : 0,
      assists: isSet(object.assists) ? globalThis.Number(object.assists) : 0,
      leaverStatus: isSet(object.leaverStatus) ? globalThis.Number(object.leaverStatus) : 0,
      gold: isSet(object.gold) ? globalThis.Number(object.gold) : 0,
      lastHits: isSet(object.lastHits) ? globalThis.Number(object.lastHits) : 0,
      denies: isSet(object.denies) ? globalThis.Number(object.denies) : 0,
      goldPerMin: isSet(object.goldPerMin) ? globalThis.Number(object.goldPerMin) : 0,
      xpPerMin: isSet(object.xpPerMin) ? globalThis.Number(object.xpPerMin) : 0,
      goldSpent: isSet(object.goldSpent) ? globalThis.Number(object.goldSpent) : 0,
      heroDamage: isSet(object.heroDamage) ? globalThis.Number(object.heroDamage) : 0,
      towerDamage: isSet(object.towerDamage) ? globalThis.Number(object.towerDamage) : 0,
      heroHealing: isSet(object.heroHealing) ? globalThis.Number(object.heroHealing) : 0,
      level: isSet(object.level) ? globalThis.Number(object.level) : 0,
      timeLastSeen: isSet(object.timeLastSeen) ? globalThis.Number(object.timeLastSeen) : 0,
      playerName: isSet(object.playerName) ? globalThis.String(object.playerName) : "",
      supportAbilityValue: isSet(object.supportAbilityValue) ? globalThis.Number(object.supportAbilityValue) : 0,
      feedingDetected: isSet(object.feedingDetected) ? globalThis.Boolean(object.feedingDetected) : false,
      searchRank: isSet(object.searchRank) ? globalThis.Number(object.searchRank) : 0,
      searchRankUncertainty: isSet(object.searchRankUncertainty) ? globalThis.Number(object.searchRankUncertainty) : 0,
      rankUncertaintyChange: isSet(object.rankUncertaintyChange) ? globalThis.Number(object.rankUncertaintyChange) : 0,
      heroPlayCount: isSet(object.heroPlayCount) ? globalThis.Number(object.heroPlayCount) : 0,
      partyId: isSet(object.partyId) ? globalThis.String(object.partyId) : "0",
      scaledHeroDamage: isSet(object.scaledHeroDamage) ? globalThis.Number(object.scaledHeroDamage) : 0,
      scaledTowerDamage: isSet(object.scaledTowerDamage) ? globalThis.Number(object.scaledTowerDamage) : 0,
      scaledHeroHealing: isSet(object.scaledHeroHealing) ? globalThis.Number(object.scaledHeroHealing) : 0,
      scaledKills: isSet(object.scaledKills) ? globalThis.Number(object.scaledKills) : 0,
      scaledDeaths: isSet(object.scaledDeaths) ? globalThis.Number(object.scaledDeaths) : 0,
      scaledAssists: isSet(object.scaledAssists) ? globalThis.Number(object.scaledAssists) : 0,
      claimedFarmGold: isSet(object.claimedFarmGold) ? globalThis.Number(object.claimedFarmGold) : 0,
      supportGold: isSet(object.supportGold) ? globalThis.Number(object.supportGold) : 0,
      claimedDenies: isSet(object.claimedDenies) ? globalThis.Number(object.claimedDenies) : 0,
      claimedMisses: isSet(object.claimedMisses) ? globalThis.Number(object.claimedMisses) : 0,
      misses: isSet(object.misses) ? globalThis.Number(object.misses) : 0,
      abilityUpgrades: globalThis.Array.isArray(object?.abilityUpgrades)
        ? object.abilityUpgrades.map((e: any) => CMatchPlayerAbilityUpgrade.fromJSON(e))
        : [],
      additionalUnitsInventory: globalThis.Array.isArray(object?.additionalUnitsInventory)
        ? object.additionalUnitsInventory.map((e: any) => CMatchAdditionalUnitInventory.fromJSON(e))
        : [],
      permanentBuffs: globalThis.Array.isArray(object?.permanentBuffs)
        ? object.permanentBuffs.map((e: any) => CMatchPlayerPermanentBuff.fromJSON(e))
        : [],
      proName: isSet(object.proName) ? globalThis.String(object.proName) : "",
      realName: isSet(object.realName) ? globalThis.String(object.realName) : "",
      customGameData: isSet(object.customGameData)
        ? CMsgDOTAMatch_Player_CustomGameData.fromJSON(object.customGameData)
        : undefined,
      activePlusSubscription: isSet(object.activePlusSubscription)
        ? globalThis.Boolean(object.activePlusSubscription)
        : false,
      netWorth: isSet(object.netWorth) ? globalThis.Number(object.netWorth) : 0,
      botDifficulty: isSet(object.botDifficulty) ? globalThis.Number(object.botDifficulty) : 0,
      heroPickOrder: isSet(object.heroPickOrder) ? globalThis.Number(object.heroPickOrder) : 0,
      heroWasRandomed: isSet(object.heroWasRandomed) ? globalThis.Boolean(object.heroWasRandomed) : false,
      heroWasDotaPlusSuggestion: isSet(object.heroWasDotaPlusSuggestion)
        ? globalThis.Boolean(object.heroWasDotaPlusSuggestion)
        : false,
      heroDamageReceived: globalThis.Array.isArray(object?.heroDamageReceived)
        ? object.heroDamageReceived.map((e: any) => CMsgDOTAMatch_Player_HeroDamageReceived.fromJSON(e))
        : [],
      heroDamageDealt: globalThis.Array.isArray(object?.heroDamageDealt)
        ? object.heroDamageDealt.map((e: any) => CMsgDOTAMatch_Player_HeroDamageReceived.fromJSON(e))
        : [],
      secondsDead: isSet(object.secondsDead) ? globalThis.Number(object.secondsDead) : 0,
      goldLostToDeath: isSet(object.goldLostToDeath) ? globalThis.Number(object.goldLostToDeath) : 0,
      laneSelectionFlags: isSet(object.laneSelectionFlags) ? globalThis.Number(object.laneSelectionFlags) : 0,
      bountyRunes: isSet(object.bountyRunes) ? globalThis.Number(object.bountyRunes) : 0,
      outpostsCaptured: isSet(object.outpostsCaptured) ? globalThis.Number(object.outpostsCaptured) : 0,
      teamNumber: isSet(object.teamNumber) ? dotaGcTeamFromJSON(object.teamNumber) : 0,
      teamSlot: isSet(object.teamSlot) ? globalThis.Number(object.teamSlot) : 0,
      selectedFacet: isSet(object.selectedFacet) ? globalThis.Number(object.selectedFacet) : 0,
    };
  },

  toJSON(message: CMsgDOTAMatch_Player): unknown {
    const obj: any = {};
    if (message.accountId !== undefined && message.accountId !== 0) {
      obj.accountId = Math.round(message.accountId);
    }
    if (message.playerSlot !== undefined && message.playerSlot !== 0) {
      obj.playerSlot = Math.round(message.playerSlot);
    }
    if (message.heroId !== undefined && message.heroId !== 0) {
      obj.heroId = Math.round(message.heroId);
    }
    if (message.item0 !== undefined && message.item0 !== -1) {
      obj.item0 = Math.round(message.item0);
    }
    if (message.item1 !== undefined && message.item1 !== -1) {
      obj.item1 = Math.round(message.item1);
    }
    if (message.item2 !== undefined && message.item2 !== -1) {
      obj.item2 = Math.round(message.item2);
    }
    if (message.item3 !== undefined && message.item3 !== -1) {
      obj.item3 = Math.round(message.item3);
    }
    if (message.item4 !== undefined && message.item4 !== -1) {
      obj.item4 = Math.round(message.item4);
    }
    if (message.item5 !== undefined && message.item5 !== -1) {
      obj.item5 = Math.round(message.item5);
    }
    if (message.item6 !== undefined && message.item6 !== -1) {
      obj.item6 = Math.round(message.item6);
    }
    if (message.item7 !== undefined && message.item7 !== -1) {
      obj.item7 = Math.round(message.item7);
    }
    if (message.item8 !== undefined && message.item8 !== -1) {
      obj.item8 = Math.round(message.item8);
    }
    if (message.item9 !== undefined && message.item9 !== -1) {
      obj.item9 = Math.round(message.item9);
    }
    if (message.item10 !== undefined && message.item10 !== -1) {
      obj.item10 = Math.round(message.item10);
    }
    if (message.item10Lvl !== undefined && message.item10Lvl !== 0) {
      obj.item10Lvl = Math.round(message.item10Lvl);
    }
    if (message.expectedTeamContribution !== undefined && message.expectedTeamContribution !== 0) {
      obj.expectedTeamContribution = message.expectedTeamContribution;
    }
    if (message.scaledMetric !== undefined && message.scaledMetric !== 0) {
      obj.scaledMetric = message.scaledMetric;
    }
    if (message.previousRank !== undefined && message.previousRank !== 0) {
      obj.previousRank = Math.round(message.previousRank);
    }
    if (message.rankChange !== undefined && message.rankChange !== 0) {
      obj.rankChange = Math.round(message.rankChange);
    }
    if (message.mmrType !== undefined && message.mmrType !== 0) {
      obj.mmrType = Math.round(message.mmrType);
    }
    if (message.kills !== undefined && message.kills !== 0) {
      obj.kills = Math.round(message.kills);
    }
    if (message.deaths !== undefined && message.deaths !== 0) {
      obj.deaths = Math.round(message.deaths);
    }
    if (message.assists !== undefined && message.assists !== 0) {
      obj.assists = Math.round(message.assists);
    }
    if (message.leaverStatus !== undefined && message.leaverStatus !== 0) {
      obj.leaverStatus = Math.round(message.leaverStatus);
    }
    if (message.gold !== undefined && message.gold !== 0) {
      obj.gold = Math.round(message.gold);
    }
    if (message.lastHits !== undefined && message.lastHits !== 0) {
      obj.lastHits = Math.round(message.lastHits);
    }
    if (message.denies !== undefined && message.denies !== 0) {
      obj.denies = Math.round(message.denies);
    }
    if (message.goldPerMin !== undefined && message.goldPerMin !== 0) {
      obj.goldPerMin = Math.round(message.goldPerMin);
    }
    if (message.xpPerMin !== undefined && message.xpPerMin !== 0) {
      obj.xpPerMin = Math.round(message.xpPerMin);
    }
    if (message.goldSpent !== undefined && message.goldSpent !== 0) {
      obj.goldSpent = Math.round(message.goldSpent);
    }
    if (message.heroDamage !== undefined && message.heroDamage !== 0) {
      obj.heroDamage = Math.round(message.heroDamage);
    }
    if (message.towerDamage !== undefined && message.towerDamage !== 0) {
      obj.towerDamage = Math.round(message.towerDamage);
    }
    if (message.heroHealing !== undefined && message.heroHealing !== 0) {
      obj.heroHealing = Math.round(message.heroHealing);
    }
    if (message.level !== undefined && message.level !== 0) {
      obj.level = Math.round(message.level);
    }
    if (message.timeLastSeen !== undefined && message.timeLastSeen !== 0) {
      obj.timeLastSeen = Math.round(message.timeLastSeen);
    }
    if (message.playerName !== undefined && message.playerName !== "") {
      obj.playerName = message.playerName;
    }
    if (message.supportAbilityValue !== undefined && message.supportAbilityValue !== 0) {
      obj.supportAbilityValue = Math.round(message.supportAbilityValue);
    }
    if (message.feedingDetected !== undefined && message.feedingDetected !== false) {
      obj.feedingDetected = message.feedingDetected;
    }
    if (message.searchRank !== undefined && message.searchRank !== 0) {
      obj.searchRank = Math.round(message.searchRank);
    }
    if (message.searchRankUncertainty !== undefined && message.searchRankUncertainty !== 0) {
      obj.searchRankUncertainty = Math.round(message.searchRankUncertainty);
    }
    if (message.rankUncertaintyChange !== undefined && message.rankUncertaintyChange !== 0) {
      obj.rankUncertaintyChange = Math.round(message.rankUncertaintyChange);
    }
    if (message.heroPlayCount !== undefined && message.heroPlayCount !== 0) {
      obj.heroPlayCount = Math.round(message.heroPlayCount);
    }
    if (message.partyId !== undefined && message.partyId !== "0") {
      obj.partyId = message.partyId;
    }
    if (message.scaledHeroDamage !== undefined && message.scaledHeroDamage !== 0) {
      obj.scaledHeroDamage = Math.round(message.scaledHeroDamage);
    }
    if (message.scaledTowerDamage !== undefined && message.scaledTowerDamage !== 0) {
      obj.scaledTowerDamage = Math.round(message.scaledTowerDamage);
    }
    if (message.scaledHeroHealing !== undefined && message.scaledHeroHealing !== 0) {
      obj.scaledHeroHealing = Math.round(message.scaledHeroHealing);
    }
    if (message.scaledKills !== undefined && message.scaledKills !== 0) {
      obj.scaledKills = message.scaledKills;
    }
    if (message.scaledDeaths !== undefined && message.scaledDeaths !== 0) {
      obj.scaledDeaths = message.scaledDeaths;
    }
    if (message.scaledAssists !== undefined && message.scaledAssists !== 0) {
      obj.scaledAssists = message.scaledAssists;
    }
    if (message.claimedFarmGold !== undefined && message.claimedFarmGold !== 0) {
      obj.claimedFarmGold = Math.round(message.claimedFarmGold);
    }
    if (message.supportGold !== undefined && message.supportGold !== 0) {
      obj.supportGold = Math.round(message.supportGold);
    }
    if (message.claimedDenies !== undefined && message.claimedDenies !== 0) {
      obj.claimedDenies = Math.round(message.claimedDenies);
    }
    if (message.claimedMisses !== undefined && message.claimedMisses !== 0) {
      obj.claimedMisses = Math.round(message.claimedMisses);
    }
    if (message.misses !== undefined && message.misses !== 0) {
      obj.misses = Math.round(message.misses);
    }
    if (message.abilityUpgrades?.length) {
      obj.abilityUpgrades = message.abilityUpgrades.map((e) => CMatchPlayerAbilityUpgrade.toJSON(e));
    }
    if (message.additionalUnitsInventory?.length) {
      obj.additionalUnitsInventory = message.additionalUnitsInventory.map((e) =>
        CMatchAdditionalUnitInventory.toJSON(e)
      );
    }
    if (message.permanentBuffs?.length) {
      obj.permanentBuffs = message.permanentBuffs.map((e) => CMatchPlayerPermanentBuff.toJSON(e));
    }
    if (message.proName !== undefined && message.proName !== "") {
      obj.proName = message.proName;
    }
    if (message.realName !== undefined && message.realName !== "") {
      obj.realName = message.realName;
    }
    if (message.customGameData !== undefined) {
      obj.customGameData = CMsgDOTAMatch_Player_CustomGameData.toJSON(message.customGameData);
    }
    if (message.activePlusSubscription !== undefined && message.activePlusSubscription !== false) {
      obj.activePlusSubscription = message.activePlusSubscription;
    }
    if (message.netWorth !== undefined && message.netWorth !== 0) {
      obj.netWorth = Math.round(message.netWorth);
    }
    if (message.botDifficulty !== undefined && message.botDifficulty !== 0) {
      obj.botDifficulty = Math.round(message.botDifficulty);
    }
    if (message.heroPickOrder !== undefined && message.heroPickOrder !== 0) {
      obj.heroPickOrder = Math.round(message.heroPickOrder);
    }
    if (message.heroWasRandomed !== undefined && message.heroWasRandomed !== false) {
      obj.heroWasRandomed = message.heroWasRandomed;
    }
    if (message.heroWasDotaPlusSuggestion !== undefined && message.heroWasDotaPlusSuggestion !== false) {
      obj.heroWasDotaPlusSuggestion = message.heroWasDotaPlusSuggestion;
    }
    if (message.heroDamageReceived?.length) {
      obj.heroDamageReceived = message.heroDamageReceived.map((e) => CMsgDOTAMatch_Player_HeroDamageReceived.toJSON(e));
    }
    if (message.heroDamageDealt?.length) {
      obj.heroDamageDealt = message.heroDamageDealt.map((e) => CMsgDOTAMatch_Player_HeroDamageReceived.toJSON(e));
    }
    if (message.secondsDead !== undefined && message.secondsDead !== 0) {
      obj.secondsDead = Math.round(message.secondsDead);
    }
    if (message.goldLostToDeath !== undefined && message.goldLostToDeath !== 0) {
      obj.goldLostToDeath = Math.round(message.goldLostToDeath);
    }
    if (message.laneSelectionFlags !== undefined && message.laneSelectionFlags !== 0) {
      obj.laneSelectionFlags = Math.round(message.laneSelectionFlags);
    }
    if (message.bountyRunes !== undefined && message.bountyRunes !== 0) {
      obj.bountyRunes = Math.round(message.bountyRunes);
    }
    if (message.outpostsCaptured !== undefined && message.outpostsCaptured !== 0) {
      obj.outpostsCaptured = Math.round(message.outpostsCaptured);
    }
    if (message.teamNumber !== undefined && message.teamNumber !== 0) {
      obj.teamNumber = dotaGcTeamToJSON(message.teamNumber);
    }
    if (message.teamSlot !== undefined && message.teamSlot !== 0) {
      obj.teamSlot = Math.round(message.teamSlot);
    }
    if (message.selectedFacet !== undefined && message.selectedFacet !== 0) {
      obj.selectedFacet = Math.round(message.selectedFacet);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTAMatch_Player>): CMsgDOTAMatch_Player {
    return CMsgDOTAMatch_Player.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTAMatch_Player>): CMsgDOTAMatch_Player {
    const message = createBaseCMsgDOTAMatch_Player();
    message.accountId = object.accountId ?? 0;
    message.playerSlot = object.playerSlot ?? 0;
    message.heroId = object.heroId ?? 0;
    message.item0 = object.item0 ?? -1;
    message.item1 = object.item1 ?? -1;
    message.item2 = object.item2 ?? -1;
    message.item3 = object.item3 ?? -1;
    message.item4 = object.item4 ?? -1;
    message.item5 = object.item5 ?? -1;
    message.item6 = object.item6 ?? -1;
    message.item7 = object.item7 ?? -1;
    message.item8 = object.item8 ?? -1;
    message.item9 = object.item9 ?? -1;
    message.item10 = object.item10 ?? -1;
    message.item10Lvl = object.item10Lvl ?? 0;
    message.expectedTeamContribution = object.expectedTeamContribution ?? 0;
    message.scaledMetric = object.scaledMetric ?? 0;
    message.previousRank = object.previousRank ?? 0;
    message.rankChange = object.rankChange ?? 0;
    message.mmrType = object.mmrType ?? 0;
    message.kills = object.kills ?? 0;
    message.deaths = object.deaths ?? 0;
    message.assists = object.assists ?? 0;
    message.leaverStatus = object.leaverStatus ?? 0;
    message.gold = object.gold ?? 0;
    message.lastHits = object.lastHits ?? 0;
    message.denies = object.denies ?? 0;
    message.goldPerMin = object.goldPerMin ?? 0;
    message.xpPerMin = object.xpPerMin ?? 0;
    message.goldSpent = object.goldSpent ?? 0;
    message.heroDamage = object.heroDamage ?? 0;
    message.towerDamage = object.towerDamage ?? 0;
    message.heroHealing = object.heroHealing ?? 0;
    message.level = object.level ?? 0;
    message.timeLastSeen = object.timeLastSeen ?? 0;
    message.playerName = object.playerName ?? "";
    message.supportAbilityValue = object.supportAbilityValue ?? 0;
    message.feedingDetected = object.feedingDetected ?? false;
    message.searchRank = object.searchRank ?? 0;
    message.searchRankUncertainty = object.searchRankUncertainty ?? 0;
    message.rankUncertaintyChange = object.rankUncertaintyChange ?? 0;
    message.heroPlayCount = object.heroPlayCount ?? 0;
    message.partyId = object.partyId ?? "0";
    message.scaledHeroDamage = object.scaledHeroDamage ?? 0;
    message.scaledTowerDamage = object.scaledTowerDamage ?? 0;
    message.scaledHeroHealing = object.scaledHeroHealing ?? 0;
    message.scaledKills = object.scaledKills ?? 0;
    message.scaledDeaths = object.scaledDeaths ?? 0;
    message.scaledAssists = object.scaledAssists ?? 0;
    message.claimedFarmGold = object.claimedFarmGold ?? 0;
    message.supportGold = object.supportGold ?? 0;
    message.claimedDenies = object.claimedDenies ?? 0;
    message.claimedMisses = object.claimedMisses ?? 0;
    message.misses = object.misses ?? 0;
    message.abilityUpgrades = object.abilityUpgrades?.map((e) => CMatchPlayerAbilityUpgrade.fromPartial(e)) || [];
    message.additionalUnitsInventory =
      object.additionalUnitsInventory?.map((e) => CMatchAdditionalUnitInventory.fromPartial(e)) || [];
    message.permanentBuffs = object.permanentBuffs?.map((e) => CMatchPlayerPermanentBuff.fromPartial(e)) || [];
    message.proName = object.proName ?? "";
    message.realName = object.realName ?? "";
    message.customGameData = (object.customGameData !== undefined && object.customGameData !== null)
      ? CMsgDOTAMatch_Player_CustomGameData.fromPartial(object.customGameData)
      : undefined;
    message.activePlusSubscription = object.activePlusSubscription ?? false;
    message.netWorth = object.netWorth ?? 0;
    message.botDifficulty = object.botDifficulty ?? 0;
    message.heroPickOrder = object.heroPickOrder ?? 0;
    message.heroWasRandomed = object.heroWasRandomed ?? false;
    message.heroWasDotaPlusSuggestion = object.heroWasDotaPlusSuggestion ?? false;
    message.heroDamageReceived =
      object.heroDamageReceived?.map((e) => CMsgDOTAMatch_Player_HeroDamageReceived.fromPartial(e)) || [];
    message.heroDamageDealt =
      object.heroDamageDealt?.map((e) => CMsgDOTAMatch_Player_HeroDamageReceived.fromPartial(e)) || [];
    message.secondsDead = object.secondsDead ?? 0;
    message.goldLostToDeath = object.goldLostToDeath ?? 0;
    message.laneSelectionFlags = object.laneSelectionFlags ?? 0;
    message.bountyRunes = object.bountyRunes ?? 0;
    message.outpostsCaptured = object.outpostsCaptured ?? 0;
    message.teamNumber = object.teamNumber ?? 0;
    message.teamSlot = object.teamSlot ?? 0;
    message.selectedFacet = object.selectedFacet ?? 0;
    return message;
  },
};

function createBaseCMsgDOTAMatch_Player_CustomGameData(): CMsgDOTAMatch_Player_CustomGameData {
  return { dotaTeam: 0, winner: false };
}

export const CMsgDOTAMatch_Player_CustomGameData = {
  encode(message: CMsgDOTAMatch_Player_CustomGameData, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.dotaTeam !== undefined && message.dotaTeam !== 0) {
      writer.uint32(8).uint32(message.dotaTeam);
    }
    if (message.winner !== undefined && message.winner !== false) {
      writer.uint32(16).bool(message.winner);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTAMatch_Player_CustomGameData {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAMatch_Player_CustomGameData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.dotaTeam = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.winner = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAMatch_Player_CustomGameData {
    return {
      dotaTeam: isSet(object.dotaTeam) ? globalThis.Number(object.dotaTeam) : 0,
      winner: isSet(object.winner) ? globalThis.Boolean(object.winner) : false,
    };
  },

  toJSON(message: CMsgDOTAMatch_Player_CustomGameData): unknown {
    const obj: any = {};
    if (message.dotaTeam !== undefined && message.dotaTeam !== 0) {
      obj.dotaTeam = Math.round(message.dotaTeam);
    }
    if (message.winner !== undefined && message.winner !== false) {
      obj.winner = message.winner;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTAMatch_Player_CustomGameData>): CMsgDOTAMatch_Player_CustomGameData {
    return CMsgDOTAMatch_Player_CustomGameData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTAMatch_Player_CustomGameData>): CMsgDOTAMatch_Player_CustomGameData {
    const message = createBaseCMsgDOTAMatch_Player_CustomGameData();
    message.dotaTeam = object.dotaTeam ?? 0;
    message.winner = object.winner ?? false;
    return message;
  },
};

function createBaseCMsgDOTAMatch_Player_HeroDamageReceived(): CMsgDOTAMatch_Player_HeroDamageReceived {
  return { preReduction: 0, postReduction: 0, damageType: 0 };
}

export const CMsgDOTAMatch_Player_HeroDamageReceived = {
  encode(message: CMsgDOTAMatch_Player_HeroDamageReceived, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.preReduction !== undefined && message.preReduction !== 0) {
      writer.uint32(8).uint32(message.preReduction);
    }
    if (message.postReduction !== undefined && message.postReduction !== 0) {
      writer.uint32(16).uint32(message.postReduction);
    }
    if (message.damageType !== undefined && message.damageType !== 0) {
      writer.uint32(24).int32(message.damageType);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTAMatch_Player_HeroDamageReceived {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAMatch_Player_HeroDamageReceived();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.preReduction = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.postReduction = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.damageType = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAMatch_Player_HeroDamageReceived {
    return {
      preReduction: isSet(object.preReduction) ? globalThis.Number(object.preReduction) : 0,
      postReduction: isSet(object.postReduction) ? globalThis.Number(object.postReduction) : 0,
      damageType: isSet(object.damageType) ? cMsgDOTAMatch_Player_HeroDamageTypeFromJSON(object.damageType) : 0,
    };
  },

  toJSON(message: CMsgDOTAMatch_Player_HeroDamageReceived): unknown {
    const obj: any = {};
    if (message.preReduction !== undefined && message.preReduction !== 0) {
      obj.preReduction = Math.round(message.preReduction);
    }
    if (message.postReduction !== undefined && message.postReduction !== 0) {
      obj.postReduction = Math.round(message.postReduction);
    }
    if (message.damageType !== undefined && message.damageType !== 0) {
      obj.damageType = cMsgDOTAMatch_Player_HeroDamageTypeToJSON(message.damageType);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTAMatch_Player_HeroDamageReceived>): CMsgDOTAMatch_Player_HeroDamageReceived {
    return CMsgDOTAMatch_Player_HeroDamageReceived.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTAMatch_Player_HeroDamageReceived>): CMsgDOTAMatch_Player_HeroDamageReceived {
    const message = createBaseCMsgDOTAMatch_Player_HeroDamageReceived();
    message.preReduction = object.preReduction ?? 0;
    message.postReduction = object.postReduction ?? 0;
    message.damageType = object.damageType ?? 0;
    return message;
  },
};

function createBaseCMsgDOTAMatch_BroadcasterInfo(): CMsgDOTAMatch_BroadcasterInfo {
  return { accountId: 0, name: "" };
}

export const CMsgDOTAMatch_BroadcasterInfo = {
  encode(message: CMsgDOTAMatch_BroadcasterInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.accountId !== undefined && message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTAMatch_BroadcasterInfo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAMatch_BroadcasterInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAMatch_BroadcasterInfo {
    return {
      accountId: isSet(object.accountId) ? globalThis.Number(object.accountId) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: CMsgDOTAMatch_BroadcasterInfo): unknown {
    const obj: any = {};
    if (message.accountId !== undefined && message.accountId !== 0) {
      obj.accountId = Math.round(message.accountId);
    }
    if (message.name !== undefined && message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTAMatch_BroadcasterInfo>): CMsgDOTAMatch_BroadcasterInfo {
    return CMsgDOTAMatch_BroadcasterInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTAMatch_BroadcasterInfo>): CMsgDOTAMatch_BroadcasterInfo {
    const message = createBaseCMsgDOTAMatch_BroadcasterInfo();
    message.accountId = object.accountId ?? 0;
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseCMsgDOTAMatch_BroadcasterChannel(): CMsgDOTAMatch_BroadcasterChannel {
  return { countryCode: "", description: "", broadcasterInfos: [], languageCode: "" };
}

export const CMsgDOTAMatch_BroadcasterChannel = {
  encode(message: CMsgDOTAMatch_BroadcasterChannel, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.countryCode !== undefined && message.countryCode !== "") {
      writer.uint32(10).string(message.countryCode);
    }
    if (message.description !== undefined && message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    for (const v of message.broadcasterInfos) {
      CMsgDOTAMatch_BroadcasterInfo.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    if (message.languageCode !== undefined && message.languageCode !== "") {
      writer.uint32(34).string(message.languageCode);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTAMatch_BroadcasterChannel {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAMatch_BroadcasterChannel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.countryCode = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.broadcasterInfos.push(CMsgDOTAMatch_BroadcasterInfo.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.languageCode = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAMatch_BroadcasterChannel {
    return {
      countryCode: isSet(object.countryCode) ? globalThis.String(object.countryCode) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      broadcasterInfos: globalThis.Array.isArray(object?.broadcasterInfos)
        ? object.broadcasterInfos.map((e: any) => CMsgDOTAMatch_BroadcasterInfo.fromJSON(e))
        : [],
      languageCode: isSet(object.languageCode) ? globalThis.String(object.languageCode) : "",
    };
  },

  toJSON(message: CMsgDOTAMatch_BroadcasterChannel): unknown {
    const obj: any = {};
    if (message.countryCode !== undefined && message.countryCode !== "") {
      obj.countryCode = message.countryCode;
    }
    if (message.description !== undefined && message.description !== "") {
      obj.description = message.description;
    }
    if (message.broadcasterInfos?.length) {
      obj.broadcasterInfos = message.broadcasterInfos.map((e) => CMsgDOTAMatch_BroadcasterInfo.toJSON(e));
    }
    if (message.languageCode !== undefined && message.languageCode !== "") {
      obj.languageCode = message.languageCode;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTAMatch_BroadcasterChannel>): CMsgDOTAMatch_BroadcasterChannel {
    return CMsgDOTAMatch_BroadcasterChannel.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTAMatch_BroadcasterChannel>): CMsgDOTAMatch_BroadcasterChannel {
    const message = createBaseCMsgDOTAMatch_BroadcasterChannel();
    message.countryCode = object.countryCode ?? "";
    message.description = object.description ?? "";
    message.broadcasterInfos = object.broadcasterInfos?.map((e) => CMsgDOTAMatch_BroadcasterInfo.fromPartial(e)) || [];
    message.languageCode = object.languageCode ?? "";
    return message;
  },
};

function createBaseCMsgDOTAMatch_Coach(): CMsgDOTAMatch_Coach {
  return { accountId: 0, coachName: "", coachRating: 0, coachTeam: 0, coachPartyId: "0", isPrivateCoach: false };
}

export const CMsgDOTAMatch_Coach = {
  encode(message: CMsgDOTAMatch_Coach, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.accountId !== undefined && message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    if (message.coachName !== undefined && message.coachName !== "") {
      writer.uint32(18).string(message.coachName);
    }
    if (message.coachRating !== undefined && message.coachRating !== 0) {
      writer.uint32(24).uint32(message.coachRating);
    }
    if (message.coachTeam !== undefined && message.coachTeam !== 0) {
      writer.uint32(32).uint32(message.coachTeam);
    }
    if (message.coachPartyId !== undefined && message.coachPartyId !== "0") {
      writer.uint32(40).uint64(message.coachPartyId);
    }
    if (message.isPrivateCoach !== undefined && message.isPrivateCoach !== false) {
      writer.uint32(48).bool(message.isPrivateCoach);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTAMatch_Coach {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAMatch_Coach();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.coachName = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.coachRating = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.coachTeam = reader.uint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.coachPartyId = longToString(reader.uint64() as Long);
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.isPrivateCoach = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAMatch_Coach {
    return {
      accountId: isSet(object.accountId) ? globalThis.Number(object.accountId) : 0,
      coachName: isSet(object.coachName) ? globalThis.String(object.coachName) : "",
      coachRating: isSet(object.coachRating) ? globalThis.Number(object.coachRating) : 0,
      coachTeam: isSet(object.coachTeam) ? globalThis.Number(object.coachTeam) : 0,
      coachPartyId: isSet(object.coachPartyId) ? globalThis.String(object.coachPartyId) : "0",
      isPrivateCoach: isSet(object.isPrivateCoach) ? globalThis.Boolean(object.isPrivateCoach) : false,
    };
  },

  toJSON(message: CMsgDOTAMatch_Coach): unknown {
    const obj: any = {};
    if (message.accountId !== undefined && message.accountId !== 0) {
      obj.accountId = Math.round(message.accountId);
    }
    if (message.coachName !== undefined && message.coachName !== "") {
      obj.coachName = message.coachName;
    }
    if (message.coachRating !== undefined && message.coachRating !== 0) {
      obj.coachRating = Math.round(message.coachRating);
    }
    if (message.coachTeam !== undefined && message.coachTeam !== 0) {
      obj.coachTeam = Math.round(message.coachTeam);
    }
    if (message.coachPartyId !== undefined && message.coachPartyId !== "0") {
      obj.coachPartyId = message.coachPartyId;
    }
    if (message.isPrivateCoach !== undefined && message.isPrivateCoach !== false) {
      obj.isPrivateCoach = message.isPrivateCoach;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTAMatch_Coach>): CMsgDOTAMatch_Coach {
    return CMsgDOTAMatch_Coach.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTAMatch_Coach>): CMsgDOTAMatch_Coach {
    const message = createBaseCMsgDOTAMatch_Coach();
    message.accountId = object.accountId ?? 0;
    message.coachName = object.coachName ?? "";
    message.coachRating = object.coachRating ?? 0;
    message.coachTeam = object.coachTeam ?? 0;
    message.coachPartyId = object.coachPartyId ?? "0";
    message.isPrivateCoach = object.isPrivateCoach ?? false;
    return message;
  },
};

function createBaseCMsgDOTAMatch_CustomGameData(): CMsgDOTAMatch_CustomGameData {
  return { customGameId: "0", mapName: "" };
}

export const CMsgDOTAMatch_CustomGameData = {
  encode(message: CMsgDOTAMatch_CustomGameData, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.customGameId !== undefined && message.customGameId !== "0") {
      writer.uint32(8).uint64(message.customGameId);
    }
    if (message.mapName !== undefined && message.mapName !== "") {
      writer.uint32(18).string(message.mapName);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTAMatch_CustomGameData {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAMatch_CustomGameData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.customGameId = longToString(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.mapName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAMatch_CustomGameData {
    return {
      customGameId: isSet(object.customGameId) ? globalThis.String(object.customGameId) : "0",
      mapName: isSet(object.mapName) ? globalThis.String(object.mapName) : "",
    };
  },

  toJSON(message: CMsgDOTAMatch_CustomGameData): unknown {
    const obj: any = {};
    if (message.customGameId !== undefined && message.customGameId !== "0") {
      obj.customGameId = message.customGameId;
    }
    if (message.mapName !== undefined && message.mapName !== "") {
      obj.mapName = message.mapName;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTAMatch_CustomGameData>): CMsgDOTAMatch_CustomGameData {
    return CMsgDOTAMatch_CustomGameData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTAMatch_CustomGameData>): CMsgDOTAMatch_CustomGameData {
    const message = createBaseCMsgDOTAMatch_CustomGameData();
    message.customGameId = object.customGameId ?? "0";
    message.mapName = object.mapName ?? "";
    return message;
  },
};

function createBaseCMsgPlayerCard(): CMsgPlayerCard {
  return { accountId: 0, statModifier: [] };
}

export const CMsgPlayerCard = {
  encode(message: CMsgPlayerCard, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.accountId !== undefined && message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    for (const v of message.statModifier) {
      CMsgPlayerCard_StatModifier.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgPlayerCard {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgPlayerCard();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.statModifier.push(CMsgPlayerCard_StatModifier.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgPlayerCard {
    return {
      accountId: isSet(object.accountId) ? globalThis.Number(object.accountId) : 0,
      statModifier: globalThis.Array.isArray(object?.statModifier)
        ? object.statModifier.map((e: any) => CMsgPlayerCard_StatModifier.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgPlayerCard): unknown {
    const obj: any = {};
    if (message.accountId !== undefined && message.accountId !== 0) {
      obj.accountId = Math.round(message.accountId);
    }
    if (message.statModifier?.length) {
      obj.statModifier = message.statModifier.map((e) => CMsgPlayerCard_StatModifier.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgPlayerCard>): CMsgPlayerCard {
    return CMsgPlayerCard.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgPlayerCard>): CMsgPlayerCard {
    const message = createBaseCMsgPlayerCard();
    message.accountId = object.accountId ?? 0;
    message.statModifier = object.statModifier?.map((e) => CMsgPlayerCard_StatModifier.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgPlayerCard_StatModifier(): CMsgPlayerCard_StatModifier {
  return { stat: 0, value: 0 };
}

export const CMsgPlayerCard_StatModifier = {
  encode(message: CMsgPlayerCard_StatModifier, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.stat !== undefined && message.stat !== 0) {
      writer.uint32(8).uint32(message.stat);
    }
    if (message.value !== undefined && message.value !== 0) {
      writer.uint32(16).uint32(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgPlayerCard_StatModifier {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgPlayerCard_StatModifier();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.stat = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.value = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgPlayerCard_StatModifier {
    return {
      stat: isSet(object.stat) ? globalThis.Number(object.stat) : 0,
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
    };
  },

  toJSON(message: CMsgPlayerCard_StatModifier): unknown {
    const obj: any = {};
    if (message.stat !== undefined && message.stat !== 0) {
      obj.stat = Math.round(message.stat);
    }
    if (message.value !== undefined && message.value !== 0) {
      obj.value = Math.round(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgPlayerCard_StatModifier>): CMsgPlayerCard_StatModifier {
    return CMsgPlayerCard_StatModifier.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgPlayerCard_StatModifier>): CMsgPlayerCard_StatModifier {
    const message = createBaseCMsgPlayerCard_StatModifier();
    message.stat = object.stat ?? 0;
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseCMsgDOTAFantasyPlayerStats(): CMsgDOTAFantasyPlayerStats {
  return {
    playerAccountId: 0,
    matchId: "0",
    matchCompleted: false,
    teamId: 0,
    leagueId: 0,
    delay: 0,
    seriesId: 0,
    seriesType: 0,
    kills: 0,
    deaths: 0,
    cs: 0,
    gpm: 0,
    towerKills: 0,
    roshanKills: 0,
    teamfightParticipation: 0,
    wardsPlaced: 0,
    campsStacked: 0,
    runesGrabbed: 0,
    firstBlood: 0,
    stuns: 0,
    smokes: 0,
    neutralTokens: 0,
    watchers: 0,
    lotuses: 0,
    tormentors: 0,
    courierKills: 0,
    titleStats: "0",
  };
}

export const CMsgDOTAFantasyPlayerStats = {
  encode(message: CMsgDOTAFantasyPlayerStats, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.playerAccountId !== undefined && message.playerAccountId !== 0) {
      writer.uint32(8).uint32(message.playerAccountId);
    }
    if (message.matchId !== undefined && message.matchId !== "0") {
      writer.uint32(16).uint64(message.matchId);
    }
    if (message.matchCompleted !== undefined && message.matchCompleted !== false) {
      writer.uint32(24).bool(message.matchCompleted);
    }
    if (message.teamId !== undefined && message.teamId !== 0) {
      writer.uint32(32).uint32(message.teamId);
    }
    if (message.leagueId !== undefined && message.leagueId !== 0) {
      writer.uint32(40).uint32(message.leagueId);
    }
    if (message.delay !== undefined && message.delay !== 0) {
      writer.uint32(48).uint32(message.delay);
    }
    if (message.seriesId !== undefined && message.seriesId !== 0) {
      writer.uint32(56).uint32(message.seriesId);
    }
    if (message.seriesType !== undefined && message.seriesType !== 0) {
      writer.uint32(64).uint32(message.seriesType);
    }
    if (message.kills !== undefined && message.kills !== 0) {
      writer.uint32(80).uint32(message.kills);
    }
    if (message.deaths !== undefined && message.deaths !== 0) {
      writer.uint32(88).uint32(message.deaths);
    }
    if (message.cs !== undefined && message.cs !== 0) {
      writer.uint32(96).uint32(message.cs);
    }
    if (message.gpm !== undefined && message.gpm !== 0) {
      writer.uint32(109).float(message.gpm);
    }
    if (message.towerKills !== undefined && message.towerKills !== 0) {
      writer.uint32(112).uint32(message.towerKills);
    }
    if (message.roshanKills !== undefined && message.roshanKills !== 0) {
      writer.uint32(120).uint32(message.roshanKills);
    }
    if (message.teamfightParticipation !== undefined && message.teamfightParticipation !== 0) {
      writer.uint32(133).float(message.teamfightParticipation);
    }
    if (message.wardsPlaced !== undefined && message.wardsPlaced !== 0) {
      writer.uint32(136).uint32(message.wardsPlaced);
    }
    if (message.campsStacked !== undefined && message.campsStacked !== 0) {
      writer.uint32(144).uint32(message.campsStacked);
    }
    if (message.runesGrabbed !== undefined && message.runesGrabbed !== 0) {
      writer.uint32(152).uint32(message.runesGrabbed);
    }
    if (message.firstBlood !== undefined && message.firstBlood !== 0) {
      writer.uint32(160).uint32(message.firstBlood);
    }
    if (message.stuns !== undefined && message.stuns !== 0) {
      writer.uint32(173).float(message.stuns);
    }
    if (message.smokes !== undefined && message.smokes !== 0) {
      writer.uint32(176).uint32(message.smokes);
    }
    if (message.neutralTokens !== undefined && message.neutralTokens !== 0) {
      writer.uint32(184).uint32(message.neutralTokens);
    }
    if (message.watchers !== undefined && message.watchers !== 0) {
      writer.uint32(192).uint32(message.watchers);
    }
    if (message.lotuses !== undefined && message.lotuses !== 0) {
      writer.uint32(200).uint32(message.lotuses);
    }
    if (message.tormentors !== undefined && message.tormentors !== 0) {
      writer.uint32(208).uint32(message.tormentors);
    }
    if (message.courierKills !== undefined && message.courierKills !== 0) {
      writer.uint32(216).uint32(message.courierKills);
    }
    if (message.titleStats !== undefined && message.titleStats !== "0") {
      writer.uint32(225).fixed64(message.titleStats);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTAFantasyPlayerStats {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAFantasyPlayerStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.playerAccountId = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.matchId = longToString(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.matchCompleted = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.teamId = reader.uint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.leagueId = reader.uint32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.delay = reader.uint32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.seriesId = reader.uint32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.seriesType = reader.uint32();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.kills = reader.uint32();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.deaths = reader.uint32();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.cs = reader.uint32();
          continue;
        case 13:
          if (tag !== 109) {
            break;
          }

          message.gpm = reader.float();
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.towerKills = reader.uint32();
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.roshanKills = reader.uint32();
          continue;
        case 16:
          if (tag !== 133) {
            break;
          }

          message.teamfightParticipation = reader.float();
          continue;
        case 17:
          if (tag !== 136) {
            break;
          }

          message.wardsPlaced = reader.uint32();
          continue;
        case 18:
          if (tag !== 144) {
            break;
          }

          message.campsStacked = reader.uint32();
          continue;
        case 19:
          if (tag !== 152) {
            break;
          }

          message.runesGrabbed = reader.uint32();
          continue;
        case 20:
          if (tag !== 160) {
            break;
          }

          message.firstBlood = reader.uint32();
          continue;
        case 21:
          if (tag !== 173) {
            break;
          }

          message.stuns = reader.float();
          continue;
        case 22:
          if (tag !== 176) {
            break;
          }

          message.smokes = reader.uint32();
          continue;
        case 23:
          if (tag !== 184) {
            break;
          }

          message.neutralTokens = reader.uint32();
          continue;
        case 24:
          if (tag !== 192) {
            break;
          }

          message.watchers = reader.uint32();
          continue;
        case 25:
          if (tag !== 200) {
            break;
          }

          message.lotuses = reader.uint32();
          continue;
        case 26:
          if (tag !== 208) {
            break;
          }

          message.tormentors = reader.uint32();
          continue;
        case 27:
          if (tag !== 216) {
            break;
          }

          message.courierKills = reader.uint32();
          continue;
        case 28:
          if (tag !== 225) {
            break;
          }

          message.titleStats = longToString(reader.fixed64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAFantasyPlayerStats {
    return {
      playerAccountId: isSet(object.playerAccountId) ? globalThis.Number(object.playerAccountId) : 0,
      matchId: isSet(object.matchId) ? globalThis.String(object.matchId) : "0",
      matchCompleted: isSet(object.matchCompleted) ? globalThis.Boolean(object.matchCompleted) : false,
      teamId: isSet(object.teamId) ? globalThis.Number(object.teamId) : 0,
      leagueId: isSet(object.leagueId) ? globalThis.Number(object.leagueId) : 0,
      delay: isSet(object.delay) ? globalThis.Number(object.delay) : 0,
      seriesId: isSet(object.seriesId) ? globalThis.Number(object.seriesId) : 0,
      seriesType: isSet(object.seriesType) ? globalThis.Number(object.seriesType) : 0,
      kills: isSet(object.kills) ? globalThis.Number(object.kills) : 0,
      deaths: isSet(object.deaths) ? globalThis.Number(object.deaths) : 0,
      cs: isSet(object.cs) ? globalThis.Number(object.cs) : 0,
      gpm: isSet(object.gpm) ? globalThis.Number(object.gpm) : 0,
      towerKills: isSet(object.towerKills) ? globalThis.Number(object.towerKills) : 0,
      roshanKills: isSet(object.roshanKills) ? globalThis.Number(object.roshanKills) : 0,
      teamfightParticipation: isSet(object.teamfightParticipation)
        ? globalThis.Number(object.teamfightParticipation)
        : 0,
      wardsPlaced: isSet(object.wardsPlaced) ? globalThis.Number(object.wardsPlaced) : 0,
      campsStacked: isSet(object.campsStacked) ? globalThis.Number(object.campsStacked) : 0,
      runesGrabbed: isSet(object.runesGrabbed) ? globalThis.Number(object.runesGrabbed) : 0,
      firstBlood: isSet(object.firstBlood) ? globalThis.Number(object.firstBlood) : 0,
      stuns: isSet(object.stuns) ? globalThis.Number(object.stuns) : 0,
      smokes: isSet(object.smokes) ? globalThis.Number(object.smokes) : 0,
      neutralTokens: isSet(object.neutralTokens) ? globalThis.Number(object.neutralTokens) : 0,
      watchers: isSet(object.watchers) ? globalThis.Number(object.watchers) : 0,
      lotuses: isSet(object.lotuses) ? globalThis.Number(object.lotuses) : 0,
      tormentors: isSet(object.tormentors) ? globalThis.Number(object.tormentors) : 0,
      courierKills: isSet(object.courierKills) ? globalThis.Number(object.courierKills) : 0,
      titleStats: isSet(object.titleStats) ? globalThis.String(object.titleStats) : "0",
    };
  },

  toJSON(message: CMsgDOTAFantasyPlayerStats): unknown {
    const obj: any = {};
    if (message.playerAccountId !== undefined && message.playerAccountId !== 0) {
      obj.playerAccountId = Math.round(message.playerAccountId);
    }
    if (message.matchId !== undefined && message.matchId !== "0") {
      obj.matchId = message.matchId;
    }
    if (message.matchCompleted !== undefined && message.matchCompleted !== false) {
      obj.matchCompleted = message.matchCompleted;
    }
    if (message.teamId !== undefined && message.teamId !== 0) {
      obj.teamId = Math.round(message.teamId);
    }
    if (message.leagueId !== undefined && message.leagueId !== 0) {
      obj.leagueId = Math.round(message.leagueId);
    }
    if (message.delay !== undefined && message.delay !== 0) {
      obj.delay = Math.round(message.delay);
    }
    if (message.seriesId !== undefined && message.seriesId !== 0) {
      obj.seriesId = Math.round(message.seriesId);
    }
    if (message.seriesType !== undefined && message.seriesType !== 0) {
      obj.seriesType = Math.round(message.seriesType);
    }
    if (message.kills !== undefined && message.kills !== 0) {
      obj.kills = Math.round(message.kills);
    }
    if (message.deaths !== undefined && message.deaths !== 0) {
      obj.deaths = Math.round(message.deaths);
    }
    if (message.cs !== undefined && message.cs !== 0) {
      obj.cs = Math.round(message.cs);
    }
    if (message.gpm !== undefined && message.gpm !== 0) {
      obj.gpm = message.gpm;
    }
    if (message.towerKills !== undefined && message.towerKills !== 0) {
      obj.towerKills = Math.round(message.towerKills);
    }
    if (message.roshanKills !== undefined && message.roshanKills !== 0) {
      obj.roshanKills = Math.round(message.roshanKills);
    }
    if (message.teamfightParticipation !== undefined && message.teamfightParticipation !== 0) {
      obj.teamfightParticipation = message.teamfightParticipation;
    }
    if (message.wardsPlaced !== undefined && message.wardsPlaced !== 0) {
      obj.wardsPlaced = Math.round(message.wardsPlaced);
    }
    if (message.campsStacked !== undefined && message.campsStacked !== 0) {
      obj.campsStacked = Math.round(message.campsStacked);
    }
    if (message.runesGrabbed !== undefined && message.runesGrabbed !== 0) {
      obj.runesGrabbed = Math.round(message.runesGrabbed);
    }
    if (message.firstBlood !== undefined && message.firstBlood !== 0) {
      obj.firstBlood = Math.round(message.firstBlood);
    }
    if (message.stuns !== undefined && message.stuns !== 0) {
      obj.stuns = message.stuns;
    }
    if (message.smokes !== undefined && message.smokes !== 0) {
      obj.smokes = Math.round(message.smokes);
    }
    if (message.neutralTokens !== undefined && message.neutralTokens !== 0) {
      obj.neutralTokens = Math.round(message.neutralTokens);
    }
    if (message.watchers !== undefined && message.watchers !== 0) {
      obj.watchers = Math.round(message.watchers);
    }
    if (message.lotuses !== undefined && message.lotuses !== 0) {
      obj.lotuses = Math.round(message.lotuses);
    }
    if (message.tormentors !== undefined && message.tormentors !== 0) {
      obj.tormentors = Math.round(message.tormentors);
    }
    if (message.courierKills !== undefined && message.courierKills !== 0) {
      obj.courierKills = Math.round(message.courierKills);
    }
    if (message.titleStats !== undefined && message.titleStats !== "0") {
      obj.titleStats = message.titleStats;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTAFantasyPlayerStats>): CMsgDOTAFantasyPlayerStats {
    return CMsgDOTAFantasyPlayerStats.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTAFantasyPlayerStats>): CMsgDOTAFantasyPlayerStats {
    const message = createBaseCMsgDOTAFantasyPlayerStats();
    message.playerAccountId = object.playerAccountId ?? 0;
    message.matchId = object.matchId ?? "0";
    message.matchCompleted = object.matchCompleted ?? false;
    message.teamId = object.teamId ?? 0;
    message.leagueId = object.leagueId ?? 0;
    message.delay = object.delay ?? 0;
    message.seriesId = object.seriesId ?? 0;
    message.seriesType = object.seriesType ?? 0;
    message.kills = object.kills ?? 0;
    message.deaths = object.deaths ?? 0;
    message.cs = object.cs ?? 0;
    message.gpm = object.gpm ?? 0;
    message.towerKills = object.towerKills ?? 0;
    message.roshanKills = object.roshanKills ?? 0;
    message.teamfightParticipation = object.teamfightParticipation ?? 0;
    message.wardsPlaced = object.wardsPlaced ?? 0;
    message.campsStacked = object.campsStacked ?? 0;
    message.runesGrabbed = object.runesGrabbed ?? 0;
    message.firstBlood = object.firstBlood ?? 0;
    message.stuns = object.stuns ?? 0;
    message.smokes = object.smokes ?? 0;
    message.neutralTokens = object.neutralTokens ?? 0;
    message.watchers = object.watchers ?? 0;
    message.lotuses = object.lotuses ?? 0;
    message.tormentors = object.tormentors ?? 0;
    message.courierKills = object.courierKills ?? 0;
    message.titleStats = object.titleStats ?? "0";
    return message;
  },
};

function createBaseCMsgDOTAFantasyPlayerMatchStats(): CMsgDOTAFantasyPlayerMatchStats {
  return { matches: [] };
}

export const CMsgDOTAFantasyPlayerMatchStats = {
  encode(message: CMsgDOTAFantasyPlayerMatchStats, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.matches) {
      CMsgDOTAFantasyPlayerStats.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTAFantasyPlayerMatchStats {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAFantasyPlayerMatchStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.matches.push(CMsgDOTAFantasyPlayerStats.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAFantasyPlayerMatchStats {
    return {
      matches: globalThis.Array.isArray(object?.matches)
        ? object.matches.map((e: any) => CMsgDOTAFantasyPlayerStats.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgDOTAFantasyPlayerMatchStats): unknown {
    const obj: any = {};
    if (message.matches?.length) {
      obj.matches = message.matches.map((e) => CMsgDOTAFantasyPlayerStats.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTAFantasyPlayerMatchStats>): CMsgDOTAFantasyPlayerMatchStats {
    return CMsgDOTAFantasyPlayerMatchStats.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTAFantasyPlayerMatchStats>): CMsgDOTAFantasyPlayerMatchStats {
    const message = createBaseCMsgDOTAFantasyPlayerMatchStats();
    message.matches = object.matches?.map((e) => CMsgDOTAFantasyPlayerStats.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgDOTABotDebugInfo(): CMsgDOTABotDebugInfo {
  return {
    bots: [],
    desirePushLaneTop: 0,
    desirePushLaneMid: 0,
    desirePushLaneBot: 0,
    desireDefendLaneTop: 0,
    desireDefendLaneMid: 0,
    desireDefendLaneBot: 0,
    desireFarmLaneTop: 0,
    desireFarmLaneMid: 0,
    desireFarmLaneBot: 0,
    desireFarmRoshan: 0,
    executionTime: 0,
    runeStatus: [],
  };
}

export const CMsgDOTABotDebugInfo = {
  encode(message: CMsgDOTABotDebugInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.bots) {
      CMsgDOTABotDebugInfo_Bot.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.desirePushLaneTop !== undefined && message.desirePushLaneTop !== 0) {
      writer.uint32(21).float(message.desirePushLaneTop);
    }
    if (message.desirePushLaneMid !== undefined && message.desirePushLaneMid !== 0) {
      writer.uint32(29).float(message.desirePushLaneMid);
    }
    if (message.desirePushLaneBot !== undefined && message.desirePushLaneBot !== 0) {
      writer.uint32(37).float(message.desirePushLaneBot);
    }
    if (message.desireDefendLaneTop !== undefined && message.desireDefendLaneTop !== 0) {
      writer.uint32(45).float(message.desireDefendLaneTop);
    }
    if (message.desireDefendLaneMid !== undefined && message.desireDefendLaneMid !== 0) {
      writer.uint32(53).float(message.desireDefendLaneMid);
    }
    if (message.desireDefendLaneBot !== undefined && message.desireDefendLaneBot !== 0) {
      writer.uint32(61).float(message.desireDefendLaneBot);
    }
    if (message.desireFarmLaneTop !== undefined && message.desireFarmLaneTop !== 0) {
      writer.uint32(69).float(message.desireFarmLaneTop);
    }
    if (message.desireFarmLaneMid !== undefined && message.desireFarmLaneMid !== 0) {
      writer.uint32(77).float(message.desireFarmLaneMid);
    }
    if (message.desireFarmLaneBot !== undefined && message.desireFarmLaneBot !== 0) {
      writer.uint32(85).float(message.desireFarmLaneBot);
    }
    if (message.desireFarmRoshan !== undefined && message.desireFarmRoshan !== 0) {
      writer.uint32(93).float(message.desireFarmRoshan);
    }
    if (message.executionTime !== undefined && message.executionTime !== 0) {
      writer.uint32(101).float(message.executionTime);
    }
    writer.uint32(106).fork();
    for (const v of message.runeStatus) {
      writer.uint32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTABotDebugInfo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTABotDebugInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.bots.push(CMsgDOTABotDebugInfo_Bot.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.desirePushLaneTop = reader.float();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.desirePushLaneMid = reader.float();
          continue;
        case 4:
          if (tag !== 37) {
            break;
          }

          message.desirePushLaneBot = reader.float();
          continue;
        case 5:
          if (tag !== 45) {
            break;
          }

          message.desireDefendLaneTop = reader.float();
          continue;
        case 6:
          if (tag !== 53) {
            break;
          }

          message.desireDefendLaneMid = reader.float();
          continue;
        case 7:
          if (tag !== 61) {
            break;
          }

          message.desireDefendLaneBot = reader.float();
          continue;
        case 8:
          if (tag !== 69) {
            break;
          }

          message.desireFarmLaneTop = reader.float();
          continue;
        case 9:
          if (tag !== 77) {
            break;
          }

          message.desireFarmLaneMid = reader.float();
          continue;
        case 10:
          if (tag !== 85) {
            break;
          }

          message.desireFarmLaneBot = reader.float();
          continue;
        case 11:
          if (tag !== 93) {
            break;
          }

          message.desireFarmRoshan = reader.float();
          continue;
        case 12:
          if (tag !== 101) {
            break;
          }

          message.executionTime = reader.float();
          continue;
        case 13:
          if (tag === 104) {
            message.runeStatus.push(reader.uint32());

            continue;
          }

          if (tag === 106) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.runeStatus.push(reader.uint32());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTABotDebugInfo {
    return {
      bots: globalThis.Array.isArray(object?.bots)
        ? object.bots.map((e: any) => CMsgDOTABotDebugInfo_Bot.fromJSON(e))
        : [],
      desirePushLaneTop: isSet(object.desirePushLaneTop) ? globalThis.Number(object.desirePushLaneTop) : 0,
      desirePushLaneMid: isSet(object.desirePushLaneMid) ? globalThis.Number(object.desirePushLaneMid) : 0,
      desirePushLaneBot: isSet(object.desirePushLaneBot) ? globalThis.Number(object.desirePushLaneBot) : 0,
      desireDefendLaneTop: isSet(object.desireDefendLaneTop) ? globalThis.Number(object.desireDefendLaneTop) : 0,
      desireDefendLaneMid: isSet(object.desireDefendLaneMid) ? globalThis.Number(object.desireDefendLaneMid) : 0,
      desireDefendLaneBot: isSet(object.desireDefendLaneBot) ? globalThis.Number(object.desireDefendLaneBot) : 0,
      desireFarmLaneTop: isSet(object.desireFarmLaneTop) ? globalThis.Number(object.desireFarmLaneTop) : 0,
      desireFarmLaneMid: isSet(object.desireFarmLaneMid) ? globalThis.Number(object.desireFarmLaneMid) : 0,
      desireFarmLaneBot: isSet(object.desireFarmLaneBot) ? globalThis.Number(object.desireFarmLaneBot) : 0,
      desireFarmRoshan: isSet(object.desireFarmRoshan) ? globalThis.Number(object.desireFarmRoshan) : 0,
      executionTime: isSet(object.executionTime) ? globalThis.Number(object.executionTime) : 0,
      runeStatus: globalThis.Array.isArray(object?.runeStatus)
        ? object.runeStatus.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: CMsgDOTABotDebugInfo): unknown {
    const obj: any = {};
    if (message.bots?.length) {
      obj.bots = message.bots.map((e) => CMsgDOTABotDebugInfo_Bot.toJSON(e));
    }
    if (message.desirePushLaneTop !== undefined && message.desirePushLaneTop !== 0) {
      obj.desirePushLaneTop = message.desirePushLaneTop;
    }
    if (message.desirePushLaneMid !== undefined && message.desirePushLaneMid !== 0) {
      obj.desirePushLaneMid = message.desirePushLaneMid;
    }
    if (message.desirePushLaneBot !== undefined && message.desirePushLaneBot !== 0) {
      obj.desirePushLaneBot = message.desirePushLaneBot;
    }
    if (message.desireDefendLaneTop !== undefined && message.desireDefendLaneTop !== 0) {
      obj.desireDefendLaneTop = message.desireDefendLaneTop;
    }
    if (message.desireDefendLaneMid !== undefined && message.desireDefendLaneMid !== 0) {
      obj.desireDefendLaneMid = message.desireDefendLaneMid;
    }
    if (message.desireDefendLaneBot !== undefined && message.desireDefendLaneBot !== 0) {
      obj.desireDefendLaneBot = message.desireDefendLaneBot;
    }
    if (message.desireFarmLaneTop !== undefined && message.desireFarmLaneTop !== 0) {
      obj.desireFarmLaneTop = message.desireFarmLaneTop;
    }
    if (message.desireFarmLaneMid !== undefined && message.desireFarmLaneMid !== 0) {
      obj.desireFarmLaneMid = message.desireFarmLaneMid;
    }
    if (message.desireFarmLaneBot !== undefined && message.desireFarmLaneBot !== 0) {
      obj.desireFarmLaneBot = message.desireFarmLaneBot;
    }
    if (message.desireFarmRoshan !== undefined && message.desireFarmRoshan !== 0) {
      obj.desireFarmRoshan = message.desireFarmRoshan;
    }
    if (message.executionTime !== undefined && message.executionTime !== 0) {
      obj.executionTime = message.executionTime;
    }
    if (message.runeStatus?.length) {
      obj.runeStatus = message.runeStatus.map((e) => Math.round(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTABotDebugInfo>): CMsgDOTABotDebugInfo {
    return CMsgDOTABotDebugInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTABotDebugInfo>): CMsgDOTABotDebugInfo {
    const message = createBaseCMsgDOTABotDebugInfo();
    message.bots = object.bots?.map((e) => CMsgDOTABotDebugInfo_Bot.fromPartial(e)) || [];
    message.desirePushLaneTop = object.desirePushLaneTop ?? 0;
    message.desirePushLaneMid = object.desirePushLaneMid ?? 0;
    message.desirePushLaneBot = object.desirePushLaneBot ?? 0;
    message.desireDefendLaneTop = object.desireDefendLaneTop ?? 0;
    message.desireDefendLaneMid = object.desireDefendLaneMid ?? 0;
    message.desireDefendLaneBot = object.desireDefendLaneBot ?? 0;
    message.desireFarmLaneTop = object.desireFarmLaneTop ?? 0;
    message.desireFarmLaneMid = object.desireFarmLaneMid ?? 0;
    message.desireFarmLaneBot = object.desireFarmLaneBot ?? 0;
    message.desireFarmRoshan = object.desireFarmRoshan ?? 0;
    message.executionTime = object.executionTime ?? 0;
    message.runeStatus = object.runeStatus?.map((e) => e) || [];
    return message;
  },
};

function createBaseCMsgDOTABotDebugInfo_Bot(): CMsgDOTABotDebugInfo_Bot {
  return {
    playerOwnerId: -1,
    heroId: 0,
    difficulty: 0,
    powerCurrent: 0,
    powerMax: 0,
    moveTargetX: 0,
    moveTargetY: 0,
    moveTargetZ: 0,
    activeModeId: 0,
    executionTime: 0,
    modes: [],
    action: undefined,
  };
}

export const CMsgDOTABotDebugInfo_Bot = {
  encode(message: CMsgDOTABotDebugInfo_Bot, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.playerOwnerId !== undefined && message.playerOwnerId !== -1) {
      writer.uint32(8).int32(message.playerOwnerId);
    }
    if (message.heroId !== undefined && message.heroId !== 0) {
      writer.uint32(16).int32(message.heroId);
    }
    if (message.difficulty !== undefined && message.difficulty !== 0) {
      writer.uint32(24).uint32(message.difficulty);
    }
    if (message.powerCurrent !== undefined && message.powerCurrent !== 0) {
      writer.uint32(32).uint32(message.powerCurrent);
    }
    if (message.powerMax !== undefined && message.powerMax !== 0) {
      writer.uint32(40).uint32(message.powerMax);
    }
    if (message.moveTargetX !== undefined && message.moveTargetX !== 0) {
      writer.uint32(48).uint32(message.moveTargetX);
    }
    if (message.moveTargetY !== undefined && message.moveTargetY !== 0) {
      writer.uint32(56).uint32(message.moveTargetY);
    }
    if (message.moveTargetZ !== undefined && message.moveTargetZ !== 0) {
      writer.uint32(64).uint32(message.moveTargetZ);
    }
    if (message.activeModeId !== undefined && message.activeModeId !== 0) {
      writer.uint32(72).uint32(message.activeModeId);
    }
    if (message.executionTime !== undefined && message.executionTime !== 0) {
      writer.uint32(85).float(message.executionTime);
    }
    for (const v of message.modes) {
      CMsgDOTABotDebugInfo_Bot_Mode.encode(v!, writer.uint32(90).fork()).ldelim();
    }
    if (message.action !== undefined) {
      CMsgDOTABotDebugInfo_Bot_Action.encode(message.action, writer.uint32(98).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTABotDebugInfo_Bot {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTABotDebugInfo_Bot();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.playerOwnerId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.heroId = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.difficulty = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.powerCurrent = reader.uint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.powerMax = reader.uint32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.moveTargetX = reader.uint32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.moveTargetY = reader.uint32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.moveTargetZ = reader.uint32();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.activeModeId = reader.uint32();
          continue;
        case 10:
          if (tag !== 85) {
            break;
          }

          message.executionTime = reader.float();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.modes.push(CMsgDOTABotDebugInfo_Bot_Mode.decode(reader, reader.uint32()));
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.action = CMsgDOTABotDebugInfo_Bot_Action.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTABotDebugInfo_Bot {
    return {
      playerOwnerId: isSet(object.playerOwnerId) ? globalThis.Number(object.playerOwnerId) : -1,
      heroId: isSet(object.heroId) ? globalThis.Number(object.heroId) : 0,
      difficulty: isSet(object.difficulty) ? globalThis.Number(object.difficulty) : 0,
      powerCurrent: isSet(object.powerCurrent) ? globalThis.Number(object.powerCurrent) : 0,
      powerMax: isSet(object.powerMax) ? globalThis.Number(object.powerMax) : 0,
      moveTargetX: isSet(object.moveTargetX) ? globalThis.Number(object.moveTargetX) : 0,
      moveTargetY: isSet(object.moveTargetY) ? globalThis.Number(object.moveTargetY) : 0,
      moveTargetZ: isSet(object.moveTargetZ) ? globalThis.Number(object.moveTargetZ) : 0,
      activeModeId: isSet(object.activeModeId) ? globalThis.Number(object.activeModeId) : 0,
      executionTime: isSet(object.executionTime) ? globalThis.Number(object.executionTime) : 0,
      modes: globalThis.Array.isArray(object?.modes)
        ? object.modes.map((e: any) => CMsgDOTABotDebugInfo_Bot_Mode.fromJSON(e))
        : [],
      action: isSet(object.action) ? CMsgDOTABotDebugInfo_Bot_Action.fromJSON(object.action) : undefined,
    };
  },

  toJSON(message: CMsgDOTABotDebugInfo_Bot): unknown {
    const obj: any = {};
    if (message.playerOwnerId !== undefined && message.playerOwnerId !== -1) {
      obj.playerOwnerId = Math.round(message.playerOwnerId);
    }
    if (message.heroId !== undefined && message.heroId !== 0) {
      obj.heroId = Math.round(message.heroId);
    }
    if (message.difficulty !== undefined && message.difficulty !== 0) {
      obj.difficulty = Math.round(message.difficulty);
    }
    if (message.powerCurrent !== undefined && message.powerCurrent !== 0) {
      obj.powerCurrent = Math.round(message.powerCurrent);
    }
    if (message.powerMax !== undefined && message.powerMax !== 0) {
      obj.powerMax = Math.round(message.powerMax);
    }
    if (message.moveTargetX !== undefined && message.moveTargetX !== 0) {
      obj.moveTargetX = Math.round(message.moveTargetX);
    }
    if (message.moveTargetY !== undefined && message.moveTargetY !== 0) {
      obj.moveTargetY = Math.round(message.moveTargetY);
    }
    if (message.moveTargetZ !== undefined && message.moveTargetZ !== 0) {
      obj.moveTargetZ = Math.round(message.moveTargetZ);
    }
    if (message.activeModeId !== undefined && message.activeModeId !== 0) {
      obj.activeModeId = Math.round(message.activeModeId);
    }
    if (message.executionTime !== undefined && message.executionTime !== 0) {
      obj.executionTime = message.executionTime;
    }
    if (message.modes?.length) {
      obj.modes = message.modes.map((e) => CMsgDOTABotDebugInfo_Bot_Mode.toJSON(e));
    }
    if (message.action !== undefined) {
      obj.action = CMsgDOTABotDebugInfo_Bot_Action.toJSON(message.action);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTABotDebugInfo_Bot>): CMsgDOTABotDebugInfo_Bot {
    return CMsgDOTABotDebugInfo_Bot.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTABotDebugInfo_Bot>): CMsgDOTABotDebugInfo_Bot {
    const message = createBaseCMsgDOTABotDebugInfo_Bot();
    message.playerOwnerId = object.playerOwnerId ?? -1;
    message.heroId = object.heroId ?? 0;
    message.difficulty = object.difficulty ?? 0;
    message.powerCurrent = object.powerCurrent ?? 0;
    message.powerMax = object.powerMax ?? 0;
    message.moveTargetX = object.moveTargetX ?? 0;
    message.moveTargetY = object.moveTargetY ?? 0;
    message.moveTargetZ = object.moveTargetZ ?? 0;
    message.activeModeId = object.activeModeId ?? 0;
    message.executionTime = object.executionTime ?? 0;
    message.modes = object.modes?.map((e) => CMsgDOTABotDebugInfo_Bot_Mode.fromPartial(e)) || [];
    message.action = (object.action !== undefined && object.action !== null)
      ? CMsgDOTABotDebugInfo_Bot_Action.fromPartial(object.action)
      : undefined;
    return message;
  },
};

function createBaseCMsgDOTABotDebugInfo_Bot_Mode(): CMsgDOTABotDebugInfo_Bot_Mode {
  return { modeId: 0, desire: 0, targetEntity: -1, targetX: 0, targetY: 0, targetZ: 0 };
}

export const CMsgDOTABotDebugInfo_Bot_Mode = {
  encode(message: CMsgDOTABotDebugInfo_Bot_Mode, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.modeId !== undefined && message.modeId !== 0) {
      writer.uint32(8).uint32(message.modeId);
    }
    if (message.desire !== undefined && message.desire !== 0) {
      writer.uint32(21).float(message.desire);
    }
    if (message.targetEntity !== undefined && message.targetEntity !== -1) {
      writer.uint32(24).int32(message.targetEntity);
    }
    if (message.targetX !== undefined && message.targetX !== 0) {
      writer.uint32(32).uint32(message.targetX);
    }
    if (message.targetY !== undefined && message.targetY !== 0) {
      writer.uint32(40).uint32(message.targetY);
    }
    if (message.targetZ !== undefined && message.targetZ !== 0) {
      writer.uint32(48).uint32(message.targetZ);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTABotDebugInfo_Bot_Mode {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTABotDebugInfo_Bot_Mode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.modeId = reader.uint32();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.desire = reader.float();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.targetEntity = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.targetX = reader.uint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.targetY = reader.uint32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.targetZ = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTABotDebugInfo_Bot_Mode {
    return {
      modeId: isSet(object.modeId) ? globalThis.Number(object.modeId) : 0,
      desire: isSet(object.desire) ? globalThis.Number(object.desire) : 0,
      targetEntity: isSet(object.targetEntity) ? globalThis.Number(object.targetEntity) : -1,
      targetX: isSet(object.targetX) ? globalThis.Number(object.targetX) : 0,
      targetY: isSet(object.targetY) ? globalThis.Number(object.targetY) : 0,
      targetZ: isSet(object.targetZ) ? globalThis.Number(object.targetZ) : 0,
    };
  },

  toJSON(message: CMsgDOTABotDebugInfo_Bot_Mode): unknown {
    const obj: any = {};
    if (message.modeId !== undefined && message.modeId !== 0) {
      obj.modeId = Math.round(message.modeId);
    }
    if (message.desire !== undefined && message.desire !== 0) {
      obj.desire = message.desire;
    }
    if (message.targetEntity !== undefined && message.targetEntity !== -1) {
      obj.targetEntity = Math.round(message.targetEntity);
    }
    if (message.targetX !== undefined && message.targetX !== 0) {
      obj.targetX = Math.round(message.targetX);
    }
    if (message.targetY !== undefined && message.targetY !== 0) {
      obj.targetY = Math.round(message.targetY);
    }
    if (message.targetZ !== undefined && message.targetZ !== 0) {
      obj.targetZ = Math.round(message.targetZ);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTABotDebugInfo_Bot_Mode>): CMsgDOTABotDebugInfo_Bot_Mode {
    return CMsgDOTABotDebugInfo_Bot_Mode.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTABotDebugInfo_Bot_Mode>): CMsgDOTABotDebugInfo_Bot_Mode {
    const message = createBaseCMsgDOTABotDebugInfo_Bot_Mode();
    message.modeId = object.modeId ?? 0;
    message.desire = object.desire ?? 0;
    message.targetEntity = object.targetEntity ?? -1;
    message.targetX = object.targetX ?? 0;
    message.targetY = object.targetY ?? 0;
    message.targetZ = object.targetZ ?? 0;
    return message;
  },
};

function createBaseCMsgDOTABotDebugInfo_Bot_Action(): CMsgDOTABotDebugInfo_Bot_Action {
  return { actionId: 0, actionTarget: "" };
}

export const CMsgDOTABotDebugInfo_Bot_Action = {
  encode(message: CMsgDOTABotDebugInfo_Bot_Action, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.actionId !== undefined && message.actionId !== 0) {
      writer.uint32(8).uint32(message.actionId);
    }
    if (message.actionTarget !== undefined && message.actionTarget !== "") {
      writer.uint32(18).string(message.actionTarget);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTABotDebugInfo_Bot_Action {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTABotDebugInfo_Bot_Action();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.actionId = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.actionTarget = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTABotDebugInfo_Bot_Action {
    return {
      actionId: isSet(object.actionId) ? globalThis.Number(object.actionId) : 0,
      actionTarget: isSet(object.actionTarget) ? globalThis.String(object.actionTarget) : "",
    };
  },

  toJSON(message: CMsgDOTABotDebugInfo_Bot_Action): unknown {
    const obj: any = {};
    if (message.actionId !== undefined && message.actionId !== 0) {
      obj.actionId = Math.round(message.actionId);
    }
    if (message.actionTarget !== undefined && message.actionTarget !== "") {
      obj.actionTarget = message.actionTarget;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTABotDebugInfo_Bot_Action>): CMsgDOTABotDebugInfo_Bot_Action {
    return CMsgDOTABotDebugInfo_Bot_Action.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTABotDebugInfo_Bot_Action>): CMsgDOTABotDebugInfo_Bot_Action {
    const message = createBaseCMsgDOTABotDebugInfo_Bot_Action();
    message.actionId = object.actionId ?? 0;
    message.actionTarget = object.actionTarget ?? "";
    return message;
  },
};

function createBaseCMsgSuccessfulHero(): CMsgSuccessfulHero {
  return { heroId: 0, winPercent: 0, longestStreak: 0 };
}

export const CMsgSuccessfulHero = {
  encode(message: CMsgSuccessfulHero, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.heroId !== undefined && message.heroId !== 0) {
      writer.uint32(8).int32(message.heroId);
    }
    if (message.winPercent !== undefined && message.winPercent !== 0) {
      writer.uint32(21).float(message.winPercent);
    }
    if (message.longestStreak !== undefined && message.longestStreak !== 0) {
      writer.uint32(24).uint32(message.longestStreak);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSuccessfulHero {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSuccessfulHero();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.heroId = reader.int32();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.winPercent = reader.float();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.longestStreak = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSuccessfulHero {
    return {
      heroId: isSet(object.heroId) ? globalThis.Number(object.heroId) : 0,
      winPercent: isSet(object.winPercent) ? globalThis.Number(object.winPercent) : 0,
      longestStreak: isSet(object.longestStreak) ? globalThis.Number(object.longestStreak) : 0,
    };
  },

  toJSON(message: CMsgSuccessfulHero): unknown {
    const obj: any = {};
    if (message.heroId !== undefined && message.heroId !== 0) {
      obj.heroId = Math.round(message.heroId);
    }
    if (message.winPercent !== undefined && message.winPercent !== 0) {
      obj.winPercent = message.winPercent;
    }
    if (message.longestStreak !== undefined && message.longestStreak !== 0) {
      obj.longestStreak = Math.round(message.longestStreak);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSuccessfulHero>): CMsgSuccessfulHero {
    return CMsgSuccessfulHero.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSuccessfulHero>): CMsgSuccessfulHero {
    const message = createBaseCMsgSuccessfulHero();
    message.heroId = object.heroId ?? 0;
    message.winPercent = object.winPercent ?? 0;
    message.longestStreak = object.longestStreak ?? 0;
    return message;
  },
};

function createBaseCMsgRecentMatchInfo(): CMsgRecentMatchInfo {
  return {
    matchId: "0",
    gameMode: 0,
    kills: 0,
    deaths: 0,
    assists: 0,
    duration: 0,
    playerSlot: 0,
    matchOutcome: 0,
    timestamp: 0,
    lobbyType: 0,
    teamNumber: 0,
  };
}

export const CMsgRecentMatchInfo = {
  encode(message: CMsgRecentMatchInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.matchId !== undefined && message.matchId !== "0") {
      writer.uint32(8).uint64(message.matchId);
    }
    if (message.gameMode !== undefined && message.gameMode !== 0) {
      writer.uint32(16).int32(message.gameMode);
    }
    if (message.kills !== undefined && message.kills !== 0) {
      writer.uint32(24).uint32(message.kills);
    }
    if (message.deaths !== undefined && message.deaths !== 0) {
      writer.uint32(32).uint32(message.deaths);
    }
    if (message.assists !== undefined && message.assists !== 0) {
      writer.uint32(40).uint32(message.assists);
    }
    if (message.duration !== undefined && message.duration !== 0) {
      writer.uint32(48).uint32(message.duration);
    }
    if (message.playerSlot !== undefined && message.playerSlot !== 0) {
      writer.uint32(56).uint32(message.playerSlot);
    }
    if (message.matchOutcome !== undefined && message.matchOutcome !== 0) {
      writer.uint32(64).int32(message.matchOutcome);
    }
    if (message.timestamp !== undefined && message.timestamp !== 0) {
      writer.uint32(72).uint32(message.timestamp);
    }
    if (message.lobbyType !== undefined && message.lobbyType !== 0) {
      writer.uint32(80).uint32(message.lobbyType);
    }
    if (message.teamNumber !== undefined && message.teamNumber !== 0) {
      writer.uint32(88).uint32(message.teamNumber);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgRecentMatchInfo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgRecentMatchInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.matchId = longToString(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.gameMode = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.kills = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.deaths = reader.uint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.assists = reader.uint32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.duration = reader.uint32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.playerSlot = reader.uint32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.matchOutcome = reader.int32() as any;
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.timestamp = reader.uint32();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.lobbyType = reader.uint32();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.teamNumber = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgRecentMatchInfo {
    return {
      matchId: isSet(object.matchId) ? globalThis.String(object.matchId) : "0",
      gameMode: isSet(object.gameMode) ? dOTAGameModeFromJSON(object.gameMode) : 0,
      kills: isSet(object.kills) ? globalThis.Number(object.kills) : 0,
      deaths: isSet(object.deaths) ? globalThis.Number(object.deaths) : 0,
      assists: isSet(object.assists) ? globalThis.Number(object.assists) : 0,
      duration: isSet(object.duration) ? globalThis.Number(object.duration) : 0,
      playerSlot: isSet(object.playerSlot) ? globalThis.Number(object.playerSlot) : 0,
      matchOutcome: isSet(object.matchOutcome) ? eMatchOutcomeFromJSON(object.matchOutcome) : 0,
      timestamp: isSet(object.timestamp) ? globalThis.Number(object.timestamp) : 0,
      lobbyType: isSet(object.lobbyType) ? globalThis.Number(object.lobbyType) : 0,
      teamNumber: isSet(object.teamNumber) ? globalThis.Number(object.teamNumber) : 0,
    };
  },

  toJSON(message: CMsgRecentMatchInfo): unknown {
    const obj: any = {};
    if (message.matchId !== undefined && message.matchId !== "0") {
      obj.matchId = message.matchId;
    }
    if (message.gameMode !== undefined && message.gameMode !== 0) {
      obj.gameMode = dOTAGameModeToJSON(message.gameMode);
    }
    if (message.kills !== undefined && message.kills !== 0) {
      obj.kills = Math.round(message.kills);
    }
    if (message.deaths !== undefined && message.deaths !== 0) {
      obj.deaths = Math.round(message.deaths);
    }
    if (message.assists !== undefined && message.assists !== 0) {
      obj.assists = Math.round(message.assists);
    }
    if (message.duration !== undefined && message.duration !== 0) {
      obj.duration = Math.round(message.duration);
    }
    if (message.playerSlot !== undefined && message.playerSlot !== 0) {
      obj.playerSlot = Math.round(message.playerSlot);
    }
    if (message.matchOutcome !== undefined && message.matchOutcome !== 0) {
      obj.matchOutcome = eMatchOutcomeToJSON(message.matchOutcome);
    }
    if (message.timestamp !== undefined && message.timestamp !== 0) {
      obj.timestamp = Math.round(message.timestamp);
    }
    if (message.lobbyType !== undefined && message.lobbyType !== 0) {
      obj.lobbyType = Math.round(message.lobbyType);
    }
    if (message.teamNumber !== undefined && message.teamNumber !== 0) {
      obj.teamNumber = Math.round(message.teamNumber);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgRecentMatchInfo>): CMsgRecentMatchInfo {
    return CMsgRecentMatchInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgRecentMatchInfo>): CMsgRecentMatchInfo {
    const message = createBaseCMsgRecentMatchInfo();
    message.matchId = object.matchId ?? "0";
    message.gameMode = object.gameMode ?? 0;
    message.kills = object.kills ?? 0;
    message.deaths = object.deaths ?? 0;
    message.assists = object.assists ?? 0;
    message.duration = object.duration ?? 0;
    message.playerSlot = object.playerSlot ?? 0;
    message.matchOutcome = object.matchOutcome ?? 0;
    message.timestamp = object.timestamp ?? 0;
    message.lobbyType = object.lobbyType ?? 0;
    message.teamNumber = object.teamNumber ?? 0;
    return message;
  },
};

function createBaseCMsgMatchTips(): CMsgMatchTips {
  return { tips: [] };
}

export const CMsgMatchTips = {
  encode(message: CMsgMatchTips, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.tips) {
      CMsgMatchTips_SingleTip.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgMatchTips {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgMatchTips();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.tips.push(CMsgMatchTips_SingleTip.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgMatchTips {
    return {
      tips: globalThis.Array.isArray(object?.tips)
        ? object.tips.map((e: any) => CMsgMatchTips_SingleTip.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgMatchTips): unknown {
    const obj: any = {};
    if (message.tips?.length) {
      obj.tips = message.tips.map((e) => CMsgMatchTips_SingleTip.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgMatchTips>): CMsgMatchTips {
    return CMsgMatchTips.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgMatchTips>): CMsgMatchTips {
    const message = createBaseCMsgMatchTips();
    message.tips = object.tips?.map((e) => CMsgMatchTips_SingleTip.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgMatchTips_SingleTip(): CMsgMatchTips_SingleTip {
  return { sourceAccountId: 0, targetAccountId: 0, tipAmount: 0, eventId: 0 };
}

export const CMsgMatchTips_SingleTip = {
  encode(message: CMsgMatchTips_SingleTip, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sourceAccountId !== undefined && message.sourceAccountId !== 0) {
      writer.uint32(8).uint32(message.sourceAccountId);
    }
    if (message.targetAccountId !== undefined && message.targetAccountId !== 0) {
      writer.uint32(16).uint32(message.targetAccountId);
    }
    if (message.tipAmount !== undefined && message.tipAmount !== 0) {
      writer.uint32(24).uint32(message.tipAmount);
    }
    if (message.eventId !== undefined && message.eventId !== 0) {
      writer.uint32(32).int32(message.eventId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgMatchTips_SingleTip {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgMatchTips_SingleTip();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.sourceAccountId = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.targetAccountId = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.tipAmount = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.eventId = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgMatchTips_SingleTip {
    return {
      sourceAccountId: isSet(object.sourceAccountId) ? globalThis.Number(object.sourceAccountId) : 0,
      targetAccountId: isSet(object.targetAccountId) ? globalThis.Number(object.targetAccountId) : 0,
      tipAmount: isSet(object.tipAmount) ? globalThis.Number(object.tipAmount) : 0,
      eventId: isSet(object.eventId) ? eEventFromJSON(object.eventId) : 0,
    };
  },

  toJSON(message: CMsgMatchTips_SingleTip): unknown {
    const obj: any = {};
    if (message.sourceAccountId !== undefined && message.sourceAccountId !== 0) {
      obj.sourceAccountId = Math.round(message.sourceAccountId);
    }
    if (message.targetAccountId !== undefined && message.targetAccountId !== 0) {
      obj.targetAccountId = Math.round(message.targetAccountId);
    }
    if (message.tipAmount !== undefined && message.tipAmount !== 0) {
      obj.tipAmount = Math.round(message.tipAmount);
    }
    if (message.eventId !== undefined && message.eventId !== 0) {
      obj.eventId = eEventToJSON(message.eventId);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgMatchTips_SingleTip>): CMsgMatchTips_SingleTip {
    return CMsgMatchTips_SingleTip.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgMatchTips_SingleTip>): CMsgMatchTips_SingleTip {
    const message = createBaseCMsgMatchTips_SingleTip();
    message.sourceAccountId = object.sourceAccountId ?? 0;
    message.targetAccountId = object.targetAccountId ?? 0;
    message.tipAmount = object.tipAmount ?? 0;
    message.eventId = object.eventId ?? 0;
    return message;
  },
};

function createBaseCMsgDOTAMatchMinimal(): CMsgDOTAMatchMinimal {
  return {
    matchId: "0",
    startTime: 0,
    duration: 0,
    gameMode: 0,
    players: [],
    tourney: undefined,
    matchOutcome: 0,
    radiantScore: 0,
    direScore: 0,
    lobbyType: 0,
  };
}

export const CMsgDOTAMatchMinimal = {
  encode(message: CMsgDOTAMatchMinimal, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.matchId !== undefined && message.matchId !== "0") {
      writer.uint32(8).uint64(message.matchId);
    }
    if (message.startTime !== undefined && message.startTime !== 0) {
      writer.uint32(21).fixed32(message.startTime);
    }
    if (message.duration !== undefined && message.duration !== 0) {
      writer.uint32(24).uint32(message.duration);
    }
    if (message.gameMode !== undefined && message.gameMode !== 0) {
      writer.uint32(32).int32(message.gameMode);
    }
    for (const v of message.players) {
      CMsgDOTAMatchMinimal_Player.encode(v!, writer.uint32(50).fork()).ldelim();
    }
    if (message.tourney !== undefined) {
      CMsgDOTAMatchMinimal_Tourney.encode(message.tourney, writer.uint32(58).fork()).ldelim();
    }
    if (message.matchOutcome !== undefined && message.matchOutcome !== 0) {
      writer.uint32(64).int32(message.matchOutcome);
    }
    if (message.radiantScore !== undefined && message.radiantScore !== 0) {
      writer.uint32(72).uint32(message.radiantScore);
    }
    if (message.direScore !== undefined && message.direScore !== 0) {
      writer.uint32(80).uint32(message.direScore);
    }
    if (message.lobbyType !== undefined && message.lobbyType !== 0) {
      writer.uint32(88).uint32(message.lobbyType);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTAMatchMinimal {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAMatchMinimal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.matchId = longToString(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.startTime = reader.fixed32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.duration = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.gameMode = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.players.push(CMsgDOTAMatchMinimal_Player.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.tourney = CMsgDOTAMatchMinimal_Tourney.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.matchOutcome = reader.int32() as any;
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.radiantScore = reader.uint32();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.direScore = reader.uint32();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.lobbyType = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAMatchMinimal {
    return {
      matchId: isSet(object.matchId) ? globalThis.String(object.matchId) : "0",
      startTime: isSet(object.startTime) ? globalThis.Number(object.startTime) : 0,
      duration: isSet(object.duration) ? globalThis.Number(object.duration) : 0,
      gameMode: isSet(object.gameMode) ? dOTAGameModeFromJSON(object.gameMode) : 0,
      players: globalThis.Array.isArray(object?.players)
        ? object.players.map((e: any) => CMsgDOTAMatchMinimal_Player.fromJSON(e))
        : [],
      tourney: isSet(object.tourney) ? CMsgDOTAMatchMinimal_Tourney.fromJSON(object.tourney) : undefined,
      matchOutcome: isSet(object.matchOutcome) ? eMatchOutcomeFromJSON(object.matchOutcome) : 0,
      radiantScore: isSet(object.radiantScore) ? globalThis.Number(object.radiantScore) : 0,
      direScore: isSet(object.direScore) ? globalThis.Number(object.direScore) : 0,
      lobbyType: isSet(object.lobbyType) ? globalThis.Number(object.lobbyType) : 0,
    };
  },

  toJSON(message: CMsgDOTAMatchMinimal): unknown {
    const obj: any = {};
    if (message.matchId !== undefined && message.matchId !== "0") {
      obj.matchId = message.matchId;
    }
    if (message.startTime !== undefined && message.startTime !== 0) {
      obj.startTime = Math.round(message.startTime);
    }
    if (message.duration !== undefined && message.duration !== 0) {
      obj.duration = Math.round(message.duration);
    }
    if (message.gameMode !== undefined && message.gameMode !== 0) {
      obj.gameMode = dOTAGameModeToJSON(message.gameMode);
    }
    if (message.players?.length) {
      obj.players = message.players.map((e) => CMsgDOTAMatchMinimal_Player.toJSON(e));
    }
    if (message.tourney !== undefined) {
      obj.tourney = CMsgDOTAMatchMinimal_Tourney.toJSON(message.tourney);
    }
    if (message.matchOutcome !== undefined && message.matchOutcome !== 0) {
      obj.matchOutcome = eMatchOutcomeToJSON(message.matchOutcome);
    }
    if (message.radiantScore !== undefined && message.radiantScore !== 0) {
      obj.radiantScore = Math.round(message.radiantScore);
    }
    if (message.direScore !== undefined && message.direScore !== 0) {
      obj.direScore = Math.round(message.direScore);
    }
    if (message.lobbyType !== undefined && message.lobbyType !== 0) {
      obj.lobbyType = Math.round(message.lobbyType);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTAMatchMinimal>): CMsgDOTAMatchMinimal {
    return CMsgDOTAMatchMinimal.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTAMatchMinimal>): CMsgDOTAMatchMinimal {
    const message = createBaseCMsgDOTAMatchMinimal();
    message.matchId = object.matchId ?? "0";
    message.startTime = object.startTime ?? 0;
    message.duration = object.duration ?? 0;
    message.gameMode = object.gameMode ?? 0;
    message.players = object.players?.map((e) => CMsgDOTAMatchMinimal_Player.fromPartial(e)) || [];
    message.tourney = (object.tourney !== undefined && object.tourney !== null)
      ? CMsgDOTAMatchMinimal_Tourney.fromPartial(object.tourney)
      : undefined;
    message.matchOutcome = object.matchOutcome ?? 0;
    message.radiantScore = object.radiantScore ?? 0;
    message.direScore = object.direScore ?? 0;
    message.lobbyType = object.lobbyType ?? 0;
    return message;
  },
};

function createBaseCMsgDOTAMatchMinimal_Player(): CMsgDOTAMatchMinimal_Player {
  return {
    accountId: 0,
    heroId: 0,
    kills: 0,
    deaths: 0,
    assists: 0,
    items: [],
    playerSlot: 0,
    proName: "",
    level: 0,
    teamNumber: 0,
  };
}

export const CMsgDOTAMatchMinimal_Player = {
  encode(message: CMsgDOTAMatchMinimal_Player, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.accountId !== undefined && message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    if (message.heroId !== undefined && message.heroId !== 0) {
      writer.uint32(16).int32(message.heroId);
    }
    if (message.kills !== undefined && message.kills !== 0) {
      writer.uint32(24).uint32(message.kills);
    }
    if (message.deaths !== undefined && message.deaths !== 0) {
      writer.uint32(32).uint32(message.deaths);
    }
    if (message.assists !== undefined && message.assists !== 0) {
      writer.uint32(40).uint32(message.assists);
    }
    writer.uint32(50).fork();
    for (const v of message.items) {
      writer.int32(v);
    }
    writer.ldelim();
    if (message.playerSlot !== undefined && message.playerSlot !== 0) {
      writer.uint32(56).uint32(message.playerSlot);
    }
    if (message.proName !== undefined && message.proName !== "") {
      writer.uint32(66).string(message.proName);
    }
    if (message.level !== undefined && message.level !== 0) {
      writer.uint32(72).uint32(message.level);
    }
    if (message.teamNumber !== undefined && message.teamNumber !== 0) {
      writer.uint32(80).int32(message.teamNumber);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTAMatchMinimal_Player {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAMatchMinimal_Player();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.heroId = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.kills = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.deaths = reader.uint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.assists = reader.uint32();
          continue;
        case 6:
          if (tag === 48) {
            message.items.push(reader.int32());

            continue;
          }

          if (tag === 50) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.items.push(reader.int32());
            }

            continue;
          }

          break;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.playerSlot = reader.uint32();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.proName = reader.string();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.level = reader.uint32();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.teamNumber = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAMatchMinimal_Player {
    return {
      accountId: isSet(object.accountId) ? globalThis.Number(object.accountId) : 0,
      heroId: isSet(object.heroId) ? globalThis.Number(object.heroId) : 0,
      kills: isSet(object.kills) ? globalThis.Number(object.kills) : 0,
      deaths: isSet(object.deaths) ? globalThis.Number(object.deaths) : 0,
      assists: isSet(object.assists) ? globalThis.Number(object.assists) : 0,
      items: globalThis.Array.isArray(object?.items) ? object.items.map((e: any) => globalThis.Number(e)) : [],
      playerSlot: isSet(object.playerSlot) ? globalThis.Number(object.playerSlot) : 0,
      proName: isSet(object.proName) ? globalThis.String(object.proName) : "",
      level: isSet(object.level) ? globalThis.Number(object.level) : 0,
      teamNumber: isSet(object.teamNumber) ? dotaGcTeamFromJSON(object.teamNumber) : 0,
    };
  },

  toJSON(message: CMsgDOTAMatchMinimal_Player): unknown {
    const obj: any = {};
    if (message.accountId !== undefined && message.accountId !== 0) {
      obj.accountId = Math.round(message.accountId);
    }
    if (message.heroId !== undefined && message.heroId !== 0) {
      obj.heroId = Math.round(message.heroId);
    }
    if (message.kills !== undefined && message.kills !== 0) {
      obj.kills = Math.round(message.kills);
    }
    if (message.deaths !== undefined && message.deaths !== 0) {
      obj.deaths = Math.round(message.deaths);
    }
    if (message.assists !== undefined && message.assists !== 0) {
      obj.assists = Math.round(message.assists);
    }
    if (message.items?.length) {
      obj.items = message.items.map((e) => Math.round(e));
    }
    if (message.playerSlot !== undefined && message.playerSlot !== 0) {
      obj.playerSlot = Math.round(message.playerSlot);
    }
    if (message.proName !== undefined && message.proName !== "") {
      obj.proName = message.proName;
    }
    if (message.level !== undefined && message.level !== 0) {
      obj.level = Math.round(message.level);
    }
    if (message.teamNumber !== undefined && message.teamNumber !== 0) {
      obj.teamNumber = dotaGcTeamToJSON(message.teamNumber);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTAMatchMinimal_Player>): CMsgDOTAMatchMinimal_Player {
    return CMsgDOTAMatchMinimal_Player.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTAMatchMinimal_Player>): CMsgDOTAMatchMinimal_Player {
    const message = createBaseCMsgDOTAMatchMinimal_Player();
    message.accountId = object.accountId ?? 0;
    message.heroId = object.heroId ?? 0;
    message.kills = object.kills ?? 0;
    message.deaths = object.deaths ?? 0;
    message.assists = object.assists ?? 0;
    message.items = object.items?.map((e) => e) || [];
    message.playerSlot = object.playerSlot ?? 0;
    message.proName = object.proName ?? "";
    message.level = object.level ?? 0;
    message.teamNumber = object.teamNumber ?? 0;
    return message;
  },
};

function createBaseCMsgDOTAMatchMinimal_Tourney(): CMsgDOTAMatchMinimal_Tourney {
  return {
    leagueId: 0,
    seriesType: 0,
    seriesGame: 0,
    weekendTourneyTournamentId: 0,
    weekendTourneySeasonTrophyId: 0,
    weekendTourneyDivision: 0,
    weekendTourneySkillLevel: 0,
    radiantTeamId: 0,
    radiantTeamName: "",
    radiantTeamLogo: "0",
    radiantTeamLogoUrl: "",
    direTeamId: 0,
    direTeamName: "",
    direTeamLogo: "0",
    direTeamLogoUrl: "",
  };
}

export const CMsgDOTAMatchMinimal_Tourney = {
  encode(message: CMsgDOTAMatchMinimal_Tourney, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.leagueId !== undefined && message.leagueId !== 0) {
      writer.uint32(8).uint32(message.leagueId);
    }
    if (message.seriesType !== undefined && message.seriesType !== 0) {
      writer.uint32(64).uint32(message.seriesType);
    }
    if (message.seriesGame !== undefined && message.seriesGame !== 0) {
      writer.uint32(72).uint32(message.seriesGame);
    }
    if (message.weekendTourneyTournamentId !== undefined && message.weekendTourneyTournamentId !== 0) {
      writer.uint32(80).uint32(message.weekendTourneyTournamentId);
    }
    if (message.weekendTourneySeasonTrophyId !== undefined && message.weekendTourneySeasonTrophyId !== 0) {
      writer.uint32(88).uint32(message.weekendTourneySeasonTrophyId);
    }
    if (message.weekendTourneyDivision !== undefined && message.weekendTourneyDivision !== 0) {
      writer.uint32(96).uint32(message.weekendTourneyDivision);
    }
    if (message.weekendTourneySkillLevel !== undefined && message.weekendTourneySkillLevel !== 0) {
      writer.uint32(104).uint32(message.weekendTourneySkillLevel);
    }
    if (message.radiantTeamId !== undefined && message.radiantTeamId !== 0) {
      writer.uint32(16).uint32(message.radiantTeamId);
    }
    if (message.radiantTeamName !== undefined && message.radiantTeamName !== "") {
      writer.uint32(26).string(message.radiantTeamName);
    }
    if (message.radiantTeamLogo !== undefined && message.radiantTeamLogo !== "0") {
      writer.uint32(33).fixed64(message.radiantTeamLogo);
    }
    if (message.radiantTeamLogoUrl !== undefined && message.radiantTeamLogoUrl !== "") {
      writer.uint32(114).string(message.radiantTeamLogoUrl);
    }
    if (message.direTeamId !== undefined && message.direTeamId !== 0) {
      writer.uint32(40).uint32(message.direTeamId);
    }
    if (message.direTeamName !== undefined && message.direTeamName !== "") {
      writer.uint32(50).string(message.direTeamName);
    }
    if (message.direTeamLogo !== undefined && message.direTeamLogo !== "0") {
      writer.uint32(57).fixed64(message.direTeamLogo);
    }
    if (message.direTeamLogoUrl !== undefined && message.direTeamLogoUrl !== "") {
      writer.uint32(122).string(message.direTeamLogoUrl);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTAMatchMinimal_Tourney {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAMatchMinimal_Tourney();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.leagueId = reader.uint32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.seriesType = reader.uint32();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.seriesGame = reader.uint32();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.weekendTourneyTournamentId = reader.uint32();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.weekendTourneySeasonTrophyId = reader.uint32();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.weekendTourneyDivision = reader.uint32();
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.weekendTourneySkillLevel = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.radiantTeamId = reader.uint32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.radiantTeamName = reader.string();
          continue;
        case 4:
          if (tag !== 33) {
            break;
          }

          message.radiantTeamLogo = longToString(reader.fixed64() as Long);
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.radiantTeamLogoUrl = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.direTeamId = reader.uint32();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.direTeamName = reader.string();
          continue;
        case 7:
          if (tag !== 57) {
            break;
          }

          message.direTeamLogo = longToString(reader.fixed64() as Long);
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.direTeamLogoUrl = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAMatchMinimal_Tourney {
    return {
      leagueId: isSet(object.leagueId) ? globalThis.Number(object.leagueId) : 0,
      seriesType: isSet(object.seriesType) ? globalThis.Number(object.seriesType) : 0,
      seriesGame: isSet(object.seriesGame) ? globalThis.Number(object.seriesGame) : 0,
      weekendTourneyTournamentId: isSet(object.weekendTourneyTournamentId)
        ? globalThis.Number(object.weekendTourneyTournamentId)
        : 0,
      weekendTourneySeasonTrophyId: isSet(object.weekendTourneySeasonTrophyId)
        ? globalThis.Number(object.weekendTourneySeasonTrophyId)
        : 0,
      weekendTourneyDivision: isSet(object.weekendTourneyDivision)
        ? globalThis.Number(object.weekendTourneyDivision)
        : 0,
      weekendTourneySkillLevel: isSet(object.weekendTourneySkillLevel)
        ? globalThis.Number(object.weekendTourneySkillLevel)
        : 0,
      radiantTeamId: isSet(object.radiantTeamId) ? globalThis.Number(object.radiantTeamId) : 0,
      radiantTeamName: isSet(object.radiantTeamName) ? globalThis.String(object.radiantTeamName) : "",
      radiantTeamLogo: isSet(object.radiantTeamLogo) ? globalThis.String(object.radiantTeamLogo) : "0",
      radiantTeamLogoUrl: isSet(object.radiantTeamLogoUrl) ? globalThis.String(object.radiantTeamLogoUrl) : "",
      direTeamId: isSet(object.direTeamId) ? globalThis.Number(object.direTeamId) : 0,
      direTeamName: isSet(object.direTeamName) ? globalThis.String(object.direTeamName) : "",
      direTeamLogo: isSet(object.direTeamLogo) ? globalThis.String(object.direTeamLogo) : "0",
      direTeamLogoUrl: isSet(object.direTeamLogoUrl) ? globalThis.String(object.direTeamLogoUrl) : "",
    };
  },

  toJSON(message: CMsgDOTAMatchMinimal_Tourney): unknown {
    const obj: any = {};
    if (message.leagueId !== undefined && message.leagueId !== 0) {
      obj.leagueId = Math.round(message.leagueId);
    }
    if (message.seriesType !== undefined && message.seriesType !== 0) {
      obj.seriesType = Math.round(message.seriesType);
    }
    if (message.seriesGame !== undefined && message.seriesGame !== 0) {
      obj.seriesGame = Math.round(message.seriesGame);
    }
    if (message.weekendTourneyTournamentId !== undefined && message.weekendTourneyTournamentId !== 0) {
      obj.weekendTourneyTournamentId = Math.round(message.weekendTourneyTournamentId);
    }
    if (message.weekendTourneySeasonTrophyId !== undefined && message.weekendTourneySeasonTrophyId !== 0) {
      obj.weekendTourneySeasonTrophyId = Math.round(message.weekendTourneySeasonTrophyId);
    }
    if (message.weekendTourneyDivision !== undefined && message.weekendTourneyDivision !== 0) {
      obj.weekendTourneyDivision = Math.round(message.weekendTourneyDivision);
    }
    if (message.weekendTourneySkillLevel !== undefined && message.weekendTourneySkillLevel !== 0) {
      obj.weekendTourneySkillLevel = Math.round(message.weekendTourneySkillLevel);
    }
    if (message.radiantTeamId !== undefined && message.radiantTeamId !== 0) {
      obj.radiantTeamId = Math.round(message.radiantTeamId);
    }
    if (message.radiantTeamName !== undefined && message.radiantTeamName !== "") {
      obj.radiantTeamName = message.radiantTeamName;
    }
    if (message.radiantTeamLogo !== undefined && message.radiantTeamLogo !== "0") {
      obj.radiantTeamLogo = message.radiantTeamLogo;
    }
    if (message.radiantTeamLogoUrl !== undefined && message.radiantTeamLogoUrl !== "") {
      obj.radiantTeamLogoUrl = message.radiantTeamLogoUrl;
    }
    if (message.direTeamId !== undefined && message.direTeamId !== 0) {
      obj.direTeamId = Math.round(message.direTeamId);
    }
    if (message.direTeamName !== undefined && message.direTeamName !== "") {
      obj.direTeamName = message.direTeamName;
    }
    if (message.direTeamLogo !== undefined && message.direTeamLogo !== "0") {
      obj.direTeamLogo = message.direTeamLogo;
    }
    if (message.direTeamLogoUrl !== undefined && message.direTeamLogoUrl !== "") {
      obj.direTeamLogoUrl = message.direTeamLogoUrl;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTAMatchMinimal_Tourney>): CMsgDOTAMatchMinimal_Tourney {
    return CMsgDOTAMatchMinimal_Tourney.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTAMatchMinimal_Tourney>): CMsgDOTAMatchMinimal_Tourney {
    const message = createBaseCMsgDOTAMatchMinimal_Tourney();
    message.leagueId = object.leagueId ?? 0;
    message.seriesType = object.seriesType ?? 0;
    message.seriesGame = object.seriesGame ?? 0;
    message.weekendTourneyTournamentId = object.weekendTourneyTournamentId ?? 0;
    message.weekendTourneySeasonTrophyId = object.weekendTourneySeasonTrophyId ?? 0;
    message.weekendTourneyDivision = object.weekendTourneyDivision ?? 0;
    message.weekendTourneySkillLevel = object.weekendTourneySkillLevel ?? 0;
    message.radiantTeamId = object.radiantTeamId ?? 0;
    message.radiantTeamName = object.radiantTeamName ?? "";
    message.radiantTeamLogo = object.radiantTeamLogo ?? "0";
    message.radiantTeamLogoUrl = object.radiantTeamLogoUrl ?? "";
    message.direTeamId = object.direTeamId ?? 0;
    message.direTeamName = object.direTeamName ?? "";
    message.direTeamLogo = object.direTeamLogo ?? "0";
    message.direTeamLogoUrl = object.direTeamLogoUrl ?? "";
    return message;
  },
};

function createBaseCMsgConsumableUsage(): CMsgConsumableUsage {
  return { itemDef: 0, quantityChange: 0 };
}

export const CMsgConsumableUsage = {
  encode(message: CMsgConsumableUsage, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.itemDef !== undefined && message.itemDef !== 0) {
      writer.uint32(8).uint32(message.itemDef);
    }
    if (message.quantityChange !== undefined && message.quantityChange !== 0) {
      writer.uint32(16).int32(message.quantityChange);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgConsumableUsage {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgConsumableUsage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.itemDef = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.quantityChange = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgConsumableUsage {
    return {
      itemDef: isSet(object.itemDef) ? globalThis.Number(object.itemDef) : 0,
      quantityChange: isSet(object.quantityChange) ? globalThis.Number(object.quantityChange) : 0,
    };
  },

  toJSON(message: CMsgConsumableUsage): unknown {
    const obj: any = {};
    if (message.itemDef !== undefined && message.itemDef !== 0) {
      obj.itemDef = Math.round(message.itemDef);
    }
    if (message.quantityChange !== undefined && message.quantityChange !== 0) {
      obj.quantityChange = Math.round(message.quantityChange);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgConsumableUsage>): CMsgConsumableUsage {
    return CMsgConsumableUsage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgConsumableUsage>): CMsgConsumableUsage {
    const message = createBaseCMsgConsumableUsage();
    message.itemDef = object.itemDef ?? 0;
    message.quantityChange = object.quantityChange ?? 0;
    return message;
  },
};

function createBaseCMsgMatchConsumableUsage(): CMsgMatchConsumableUsage {
  return { playerConsumablesUsed: [] };
}

export const CMsgMatchConsumableUsage = {
  encode(message: CMsgMatchConsumableUsage, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.playerConsumablesUsed) {
      CMsgMatchConsumableUsage_PlayerUsage.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgMatchConsumableUsage {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgMatchConsumableUsage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.playerConsumablesUsed.push(CMsgMatchConsumableUsage_PlayerUsage.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgMatchConsumableUsage {
    return {
      playerConsumablesUsed: globalThis.Array.isArray(object?.playerConsumablesUsed)
        ? object.playerConsumablesUsed.map((e: any) => CMsgMatchConsumableUsage_PlayerUsage.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgMatchConsumableUsage): unknown {
    const obj: any = {};
    if (message.playerConsumablesUsed?.length) {
      obj.playerConsumablesUsed = message.playerConsumablesUsed.map((e) =>
        CMsgMatchConsumableUsage_PlayerUsage.toJSON(e)
      );
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgMatchConsumableUsage>): CMsgMatchConsumableUsage {
    return CMsgMatchConsumableUsage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgMatchConsumableUsage>): CMsgMatchConsumableUsage {
    const message = createBaseCMsgMatchConsumableUsage();
    message.playerConsumablesUsed =
      object.playerConsumablesUsed?.map((e) => CMsgMatchConsumableUsage_PlayerUsage.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgMatchConsumableUsage_PlayerUsage(): CMsgMatchConsumableUsage_PlayerUsage {
  return { accountId: 0, consumablesUsed: [] };
}

export const CMsgMatchConsumableUsage_PlayerUsage = {
  encode(message: CMsgMatchConsumableUsage_PlayerUsage, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.accountId !== undefined && message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    for (const v of message.consumablesUsed) {
      CMsgConsumableUsage.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgMatchConsumableUsage_PlayerUsage {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgMatchConsumableUsage_PlayerUsage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.consumablesUsed.push(CMsgConsumableUsage.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgMatchConsumableUsage_PlayerUsage {
    return {
      accountId: isSet(object.accountId) ? globalThis.Number(object.accountId) : 0,
      consumablesUsed: globalThis.Array.isArray(object?.consumablesUsed)
        ? object.consumablesUsed.map((e: any) => CMsgConsumableUsage.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgMatchConsumableUsage_PlayerUsage): unknown {
    const obj: any = {};
    if (message.accountId !== undefined && message.accountId !== 0) {
      obj.accountId = Math.round(message.accountId);
    }
    if (message.consumablesUsed?.length) {
      obj.consumablesUsed = message.consumablesUsed.map((e) => CMsgConsumableUsage.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgMatchConsumableUsage_PlayerUsage>): CMsgMatchConsumableUsage_PlayerUsage {
    return CMsgMatchConsumableUsage_PlayerUsage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgMatchConsumableUsage_PlayerUsage>): CMsgMatchConsumableUsage_PlayerUsage {
    const message = createBaseCMsgMatchConsumableUsage_PlayerUsage();
    message.accountId = object.accountId ?? 0;
    message.consumablesUsed = object.consumablesUsed?.map((e) => CMsgConsumableUsage.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgMatchEventActionGrants(): CMsgMatchEventActionGrants {
  return { playerGrants: [] };
}

export const CMsgMatchEventActionGrants = {
  encode(message: CMsgMatchEventActionGrants, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.playerGrants) {
      CMsgMatchEventActionGrants_PlayerGrants.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgMatchEventActionGrants {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgMatchEventActionGrants();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.playerGrants.push(CMsgMatchEventActionGrants_PlayerGrants.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgMatchEventActionGrants {
    return {
      playerGrants: globalThis.Array.isArray(object?.playerGrants)
        ? object.playerGrants.map((e: any) => CMsgMatchEventActionGrants_PlayerGrants.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgMatchEventActionGrants): unknown {
    const obj: any = {};
    if (message.playerGrants?.length) {
      obj.playerGrants = message.playerGrants.map((e) => CMsgMatchEventActionGrants_PlayerGrants.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgMatchEventActionGrants>): CMsgMatchEventActionGrants {
    return CMsgMatchEventActionGrants.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgMatchEventActionGrants>): CMsgMatchEventActionGrants {
    const message = createBaseCMsgMatchEventActionGrants();
    message.playerGrants = object.playerGrants?.map((e) => CMsgMatchEventActionGrants_PlayerGrants.fromPartial(e)) ||
      [];
    return message;
  },
};

function createBaseCMsgMatchEventActionGrants_PlayerGrants(): CMsgMatchEventActionGrants_PlayerGrants {
  return { accountId: 0, actionsGranted: [] };
}

export const CMsgMatchEventActionGrants_PlayerGrants = {
  encode(message: CMsgMatchEventActionGrants_PlayerGrants, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.accountId !== undefined && message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    for (const v of message.actionsGranted) {
      CMsgPendingEventAward.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgMatchEventActionGrants_PlayerGrants {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgMatchEventActionGrants_PlayerGrants();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.actionsGranted.push(CMsgPendingEventAward.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgMatchEventActionGrants_PlayerGrants {
    return {
      accountId: isSet(object.accountId) ? globalThis.Number(object.accountId) : 0,
      actionsGranted: globalThis.Array.isArray(object?.actionsGranted)
        ? object.actionsGranted.map((e: any) => CMsgPendingEventAward.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgMatchEventActionGrants_PlayerGrants): unknown {
    const obj: any = {};
    if (message.accountId !== undefined && message.accountId !== 0) {
      obj.accountId = Math.round(message.accountId);
    }
    if (message.actionsGranted?.length) {
      obj.actionsGranted = message.actionsGranted.map((e) => CMsgPendingEventAward.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgMatchEventActionGrants_PlayerGrants>): CMsgMatchEventActionGrants_PlayerGrants {
    return CMsgMatchEventActionGrants_PlayerGrants.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgMatchEventActionGrants_PlayerGrants>): CMsgMatchEventActionGrants_PlayerGrants {
    const message = createBaseCMsgMatchEventActionGrants_PlayerGrants();
    message.accountId = object.accountId ?? 0;
    message.actionsGranted = object.actionsGranted?.map((e) => CMsgPendingEventAward.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgCustomGameWhitelist(): CMsgCustomGameWhitelist {
  return { version: 0, customGamesWhitelist: [], disableWhitelist: false };
}

export const CMsgCustomGameWhitelist = {
  encode(message: CMsgCustomGameWhitelist, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.version !== undefined && message.version !== 0) {
      writer.uint32(8).uint32(message.version);
    }
    writer.uint32(18).fork();
    for (const v of message.customGamesWhitelist) {
      writer.uint64(v);
    }
    writer.ldelim();
    if (message.disableWhitelist !== undefined && message.disableWhitelist !== false) {
      writer.uint32(24).bool(message.disableWhitelist);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgCustomGameWhitelist {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgCustomGameWhitelist();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.version = reader.uint32();
          continue;
        case 2:
          if (tag === 16) {
            message.customGamesWhitelist.push(longToString(reader.uint64() as Long));

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.customGamesWhitelist.push(longToString(reader.uint64() as Long));
            }

            continue;
          }

          break;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.disableWhitelist = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgCustomGameWhitelist {
    return {
      version: isSet(object.version) ? globalThis.Number(object.version) : 0,
      customGamesWhitelist: globalThis.Array.isArray(object?.customGamesWhitelist)
        ? object.customGamesWhitelist.map((e: any) => globalThis.String(e))
        : [],
      disableWhitelist: isSet(object.disableWhitelist) ? globalThis.Boolean(object.disableWhitelist) : false,
    };
  },

  toJSON(message: CMsgCustomGameWhitelist): unknown {
    const obj: any = {};
    if (message.version !== undefined && message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    if (message.customGamesWhitelist?.length) {
      obj.customGamesWhitelist = message.customGamesWhitelist;
    }
    if (message.disableWhitelist !== undefined && message.disableWhitelist !== false) {
      obj.disableWhitelist = message.disableWhitelist;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgCustomGameWhitelist>): CMsgCustomGameWhitelist {
    return CMsgCustomGameWhitelist.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgCustomGameWhitelist>): CMsgCustomGameWhitelist {
    const message = createBaseCMsgCustomGameWhitelist();
    message.version = object.version ?? 0;
    message.customGamesWhitelist = object.customGamesWhitelist?.map((e) => e) || [];
    message.disableWhitelist = object.disableWhitelist ?? false;
    return message;
  },
};

function createBaseCMsgCustomGameWhitelistForEdit(): CMsgCustomGameWhitelistForEdit {
  return { whitelistEntries: [] };
}

export const CMsgCustomGameWhitelistForEdit = {
  encode(message: CMsgCustomGameWhitelistForEdit, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.whitelistEntries) {
      CMsgCustomGameWhitelistForEdit_WhitelistEntry.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgCustomGameWhitelistForEdit {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgCustomGameWhitelistForEdit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.whitelistEntries.push(CMsgCustomGameWhitelistForEdit_WhitelistEntry.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgCustomGameWhitelistForEdit {
    return {
      whitelistEntries: globalThis.Array.isArray(object?.whitelistEntries)
        ? object.whitelistEntries.map((e: any) => CMsgCustomGameWhitelistForEdit_WhitelistEntry.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgCustomGameWhitelistForEdit): unknown {
    const obj: any = {};
    if (message.whitelistEntries?.length) {
      obj.whitelistEntries = message.whitelistEntries.map((e) =>
        CMsgCustomGameWhitelistForEdit_WhitelistEntry.toJSON(e)
      );
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgCustomGameWhitelistForEdit>): CMsgCustomGameWhitelistForEdit {
    return CMsgCustomGameWhitelistForEdit.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgCustomGameWhitelistForEdit>): CMsgCustomGameWhitelistForEdit {
    const message = createBaseCMsgCustomGameWhitelistForEdit();
    message.whitelistEntries =
      object.whitelistEntries?.map((e) => CMsgCustomGameWhitelistForEdit_WhitelistEntry.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgCustomGameWhitelistForEdit_WhitelistEntry(): CMsgCustomGameWhitelistForEdit_WhitelistEntry {
  return { customGameId: "0", whitelistState: 0 };
}

export const CMsgCustomGameWhitelistForEdit_WhitelistEntry = {
  encode(message: CMsgCustomGameWhitelistForEdit_WhitelistEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.customGameId !== undefined && message.customGameId !== "0") {
      writer.uint32(8).uint64(message.customGameId);
    }
    if (message.whitelistState !== undefined && message.whitelistState !== 0) {
      writer.uint32(16).int32(message.whitelistState);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgCustomGameWhitelistForEdit_WhitelistEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgCustomGameWhitelistForEdit_WhitelistEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.customGameId = longToString(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.whitelistState = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgCustomGameWhitelistForEdit_WhitelistEntry {
    return {
      customGameId: isSet(object.customGameId) ? globalThis.String(object.customGameId) : "0",
      whitelistState: isSet(object.whitelistState) ? eCustomGameWhitelistStateFromJSON(object.whitelistState) : 0,
    };
  },

  toJSON(message: CMsgCustomGameWhitelistForEdit_WhitelistEntry): unknown {
    const obj: any = {};
    if (message.customGameId !== undefined && message.customGameId !== "0") {
      obj.customGameId = message.customGameId;
    }
    if (message.whitelistState !== undefined && message.whitelistState !== 0) {
      obj.whitelistState = eCustomGameWhitelistStateToJSON(message.whitelistState);
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgCustomGameWhitelistForEdit_WhitelistEntry>,
  ): CMsgCustomGameWhitelistForEdit_WhitelistEntry {
    return CMsgCustomGameWhitelistForEdit_WhitelistEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgCustomGameWhitelistForEdit_WhitelistEntry>,
  ): CMsgCustomGameWhitelistForEdit_WhitelistEntry {
    const message = createBaseCMsgCustomGameWhitelistForEdit_WhitelistEntry();
    message.customGameId = object.customGameId ?? "0";
    message.whitelistState = object.whitelistState ?? 0;
    return message;
  },
};

function createBaseCMsgPlayerRecentMatchInfo(): CMsgPlayerRecentMatchInfo {
  return { matchId: "0", timestamp: 0, duration: 0, win: false, heroId: 0, kills: 0, deaths: 0, assists: 0 };
}

export const CMsgPlayerRecentMatchInfo = {
  encode(message: CMsgPlayerRecentMatchInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.matchId !== undefined && message.matchId !== "0") {
      writer.uint32(8).uint64(message.matchId);
    }
    if (message.timestamp !== undefined && message.timestamp !== 0) {
      writer.uint32(16).uint32(message.timestamp);
    }
    if (message.duration !== undefined && message.duration !== 0) {
      writer.uint32(24).uint32(message.duration);
    }
    if (message.win !== undefined && message.win !== false) {
      writer.uint32(32).bool(message.win);
    }
    if (message.heroId !== undefined && message.heroId !== 0) {
      writer.uint32(40).int32(message.heroId);
    }
    if (message.kills !== undefined && message.kills !== 0) {
      writer.uint32(48).uint32(message.kills);
    }
    if (message.deaths !== undefined && message.deaths !== 0) {
      writer.uint32(56).uint32(message.deaths);
    }
    if (message.assists !== undefined && message.assists !== 0) {
      writer.uint32(64).uint32(message.assists);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgPlayerRecentMatchInfo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgPlayerRecentMatchInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.matchId = longToString(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.timestamp = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.duration = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.win = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.heroId = reader.int32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.kills = reader.uint32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.deaths = reader.uint32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.assists = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgPlayerRecentMatchInfo {
    return {
      matchId: isSet(object.matchId) ? globalThis.String(object.matchId) : "0",
      timestamp: isSet(object.timestamp) ? globalThis.Number(object.timestamp) : 0,
      duration: isSet(object.duration) ? globalThis.Number(object.duration) : 0,
      win: isSet(object.win) ? globalThis.Boolean(object.win) : false,
      heroId: isSet(object.heroId) ? globalThis.Number(object.heroId) : 0,
      kills: isSet(object.kills) ? globalThis.Number(object.kills) : 0,
      deaths: isSet(object.deaths) ? globalThis.Number(object.deaths) : 0,
      assists: isSet(object.assists) ? globalThis.Number(object.assists) : 0,
    };
  },

  toJSON(message: CMsgPlayerRecentMatchInfo): unknown {
    const obj: any = {};
    if (message.matchId !== undefined && message.matchId !== "0") {
      obj.matchId = message.matchId;
    }
    if (message.timestamp !== undefined && message.timestamp !== 0) {
      obj.timestamp = Math.round(message.timestamp);
    }
    if (message.duration !== undefined && message.duration !== 0) {
      obj.duration = Math.round(message.duration);
    }
    if (message.win !== undefined && message.win !== false) {
      obj.win = message.win;
    }
    if (message.heroId !== undefined && message.heroId !== 0) {
      obj.heroId = Math.round(message.heroId);
    }
    if (message.kills !== undefined && message.kills !== 0) {
      obj.kills = Math.round(message.kills);
    }
    if (message.deaths !== undefined && message.deaths !== 0) {
      obj.deaths = Math.round(message.deaths);
    }
    if (message.assists !== undefined && message.assists !== 0) {
      obj.assists = Math.round(message.assists);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgPlayerRecentMatchInfo>): CMsgPlayerRecentMatchInfo {
    return CMsgPlayerRecentMatchInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgPlayerRecentMatchInfo>): CMsgPlayerRecentMatchInfo {
    const message = createBaseCMsgPlayerRecentMatchInfo();
    message.matchId = object.matchId ?? "0";
    message.timestamp = object.timestamp ?? 0;
    message.duration = object.duration ?? 0;
    message.win = object.win ?? false;
    message.heroId = object.heroId ?? 0;
    message.kills = object.kills ?? 0;
    message.deaths = object.deaths ?? 0;
    message.assists = object.assists ?? 0;
    return message;
  },
};

function createBaseCMsgPlayerMatchRecord(): CMsgPlayerMatchRecord {
  return { wins: 0, losses: 0 };
}

export const CMsgPlayerMatchRecord = {
  encode(message: CMsgPlayerMatchRecord, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.wins !== undefined && message.wins !== 0) {
      writer.uint32(8).uint32(message.wins);
    }
    if (message.losses !== undefined && message.losses !== 0) {
      writer.uint32(16).uint32(message.losses);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgPlayerMatchRecord {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgPlayerMatchRecord();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.wins = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.losses = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgPlayerMatchRecord {
    return {
      wins: isSet(object.wins) ? globalThis.Number(object.wins) : 0,
      losses: isSet(object.losses) ? globalThis.Number(object.losses) : 0,
    };
  },

  toJSON(message: CMsgPlayerMatchRecord): unknown {
    const obj: any = {};
    if (message.wins !== undefined && message.wins !== 0) {
      obj.wins = Math.round(message.wins);
    }
    if (message.losses !== undefined && message.losses !== 0) {
      obj.losses = Math.round(message.losses);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgPlayerMatchRecord>): CMsgPlayerMatchRecord {
    return CMsgPlayerMatchRecord.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgPlayerMatchRecord>): CMsgPlayerMatchRecord {
    const message = createBaseCMsgPlayerMatchRecord();
    message.wins = object.wins ?? 0;
    message.losses = object.losses ?? 0;
    return message;
  },
};

function createBaseCMsgPlayerRecentMatchOutcomes(): CMsgPlayerRecentMatchOutcomes {
  return { outcomes: 0, matchCount: 0 };
}

export const CMsgPlayerRecentMatchOutcomes = {
  encode(message: CMsgPlayerRecentMatchOutcomes, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.outcomes !== undefined && message.outcomes !== 0) {
      writer.uint32(8).uint32(message.outcomes);
    }
    if (message.matchCount !== undefined && message.matchCount !== 0) {
      writer.uint32(16).uint32(message.matchCount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgPlayerRecentMatchOutcomes {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgPlayerRecentMatchOutcomes();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.outcomes = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.matchCount = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgPlayerRecentMatchOutcomes {
    return {
      outcomes: isSet(object.outcomes) ? globalThis.Number(object.outcomes) : 0,
      matchCount: isSet(object.matchCount) ? globalThis.Number(object.matchCount) : 0,
    };
  },

  toJSON(message: CMsgPlayerRecentMatchOutcomes): unknown {
    const obj: any = {};
    if (message.outcomes !== undefined && message.outcomes !== 0) {
      obj.outcomes = Math.round(message.outcomes);
    }
    if (message.matchCount !== undefined && message.matchCount !== 0) {
      obj.matchCount = Math.round(message.matchCount);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgPlayerRecentMatchOutcomes>): CMsgPlayerRecentMatchOutcomes {
    return CMsgPlayerRecentMatchOutcomes.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgPlayerRecentMatchOutcomes>): CMsgPlayerRecentMatchOutcomes {
    const message = createBaseCMsgPlayerRecentMatchOutcomes();
    message.outcomes = object.outcomes ?? 0;
    message.matchCount = object.matchCount ?? 0;
    return message;
  },
};

function createBaseCMsgPlayerRecentCommends(): CMsgPlayerRecentCommends {
  return { commends: 0, matchCount: 0 };
}

export const CMsgPlayerRecentCommends = {
  encode(message: CMsgPlayerRecentCommends, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.commends !== undefined && message.commends !== 0) {
      writer.uint32(8).uint32(message.commends);
    }
    if (message.matchCount !== undefined && message.matchCount !== 0) {
      writer.uint32(16).uint32(message.matchCount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgPlayerRecentCommends {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgPlayerRecentCommends();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.commends = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.matchCount = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgPlayerRecentCommends {
    return {
      commends: isSet(object.commends) ? globalThis.Number(object.commends) : 0,
      matchCount: isSet(object.matchCount) ? globalThis.Number(object.matchCount) : 0,
    };
  },

  toJSON(message: CMsgPlayerRecentCommends): unknown {
    const obj: any = {};
    if (message.commends !== undefined && message.commends !== 0) {
      obj.commends = Math.round(message.commends);
    }
    if (message.matchCount !== undefined && message.matchCount !== 0) {
      obj.matchCount = Math.round(message.matchCount);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgPlayerRecentCommends>): CMsgPlayerRecentCommends {
    return CMsgPlayerRecentCommends.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgPlayerRecentCommends>): CMsgPlayerRecentCommends {
    const message = createBaseCMsgPlayerRecentCommends();
    message.commends = object.commends ?? 0;
    message.matchCount = object.matchCount ?? 0;
    return message;
  },
};

function createBaseCMsgPlayerRecentAccomplishments(): CMsgPlayerRecentAccomplishments {
  return {
    recentOutcomes: undefined,
    totalRecord: undefined,
    predictionStreak: 0,
    plusPredictionStreak: 0,
    recentCommends: undefined,
    firstMatchTimestamp: 0,
    lastMatch: undefined,
    recentMvps: undefined,
  };
}

export const CMsgPlayerRecentAccomplishments = {
  encode(message: CMsgPlayerRecentAccomplishments, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.recentOutcomes !== undefined) {
      CMsgPlayerRecentMatchOutcomes.encode(message.recentOutcomes, writer.uint32(10).fork()).ldelim();
    }
    if (message.totalRecord !== undefined) {
      CMsgPlayerMatchRecord.encode(message.totalRecord, writer.uint32(18).fork()).ldelim();
    }
    if (message.predictionStreak !== undefined && message.predictionStreak !== 0) {
      writer.uint32(24).uint32(message.predictionStreak);
    }
    if (message.plusPredictionStreak !== undefined && message.plusPredictionStreak !== 0) {
      writer.uint32(32).uint32(message.plusPredictionStreak);
    }
    if (message.recentCommends !== undefined) {
      CMsgPlayerRecentCommends.encode(message.recentCommends, writer.uint32(42).fork()).ldelim();
    }
    if (message.firstMatchTimestamp !== undefined && message.firstMatchTimestamp !== 0) {
      writer.uint32(48).uint32(message.firstMatchTimestamp);
    }
    if (message.lastMatch !== undefined) {
      CMsgPlayerRecentMatchInfo.encode(message.lastMatch, writer.uint32(58).fork()).ldelim();
    }
    if (message.recentMvps !== undefined) {
      CMsgPlayerRecentMatchOutcomes.encode(message.recentMvps, writer.uint32(66).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgPlayerRecentAccomplishments {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgPlayerRecentAccomplishments();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.recentOutcomes = CMsgPlayerRecentMatchOutcomes.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.totalRecord = CMsgPlayerMatchRecord.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.predictionStreak = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.plusPredictionStreak = reader.uint32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.recentCommends = CMsgPlayerRecentCommends.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.firstMatchTimestamp = reader.uint32();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.lastMatch = CMsgPlayerRecentMatchInfo.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.recentMvps = CMsgPlayerRecentMatchOutcomes.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgPlayerRecentAccomplishments {
    return {
      recentOutcomes: isSet(object.recentOutcomes)
        ? CMsgPlayerRecentMatchOutcomes.fromJSON(object.recentOutcomes)
        : undefined,
      totalRecord: isSet(object.totalRecord) ? CMsgPlayerMatchRecord.fromJSON(object.totalRecord) : undefined,
      predictionStreak: isSet(object.predictionStreak) ? globalThis.Number(object.predictionStreak) : 0,
      plusPredictionStreak: isSet(object.plusPredictionStreak) ? globalThis.Number(object.plusPredictionStreak) : 0,
      recentCommends: isSet(object.recentCommends)
        ? CMsgPlayerRecentCommends.fromJSON(object.recentCommends)
        : undefined,
      firstMatchTimestamp: isSet(object.firstMatchTimestamp) ? globalThis.Number(object.firstMatchTimestamp) : 0,
      lastMatch: isSet(object.lastMatch) ? CMsgPlayerRecentMatchInfo.fromJSON(object.lastMatch) : undefined,
      recentMvps: isSet(object.recentMvps) ? CMsgPlayerRecentMatchOutcomes.fromJSON(object.recentMvps) : undefined,
    };
  },

  toJSON(message: CMsgPlayerRecentAccomplishments): unknown {
    const obj: any = {};
    if (message.recentOutcomes !== undefined) {
      obj.recentOutcomes = CMsgPlayerRecentMatchOutcomes.toJSON(message.recentOutcomes);
    }
    if (message.totalRecord !== undefined) {
      obj.totalRecord = CMsgPlayerMatchRecord.toJSON(message.totalRecord);
    }
    if (message.predictionStreak !== undefined && message.predictionStreak !== 0) {
      obj.predictionStreak = Math.round(message.predictionStreak);
    }
    if (message.plusPredictionStreak !== undefined && message.plusPredictionStreak !== 0) {
      obj.plusPredictionStreak = Math.round(message.plusPredictionStreak);
    }
    if (message.recentCommends !== undefined) {
      obj.recentCommends = CMsgPlayerRecentCommends.toJSON(message.recentCommends);
    }
    if (message.firstMatchTimestamp !== undefined && message.firstMatchTimestamp !== 0) {
      obj.firstMatchTimestamp = Math.round(message.firstMatchTimestamp);
    }
    if (message.lastMatch !== undefined) {
      obj.lastMatch = CMsgPlayerRecentMatchInfo.toJSON(message.lastMatch);
    }
    if (message.recentMvps !== undefined) {
      obj.recentMvps = CMsgPlayerRecentMatchOutcomes.toJSON(message.recentMvps);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgPlayerRecentAccomplishments>): CMsgPlayerRecentAccomplishments {
    return CMsgPlayerRecentAccomplishments.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgPlayerRecentAccomplishments>): CMsgPlayerRecentAccomplishments {
    const message = createBaseCMsgPlayerRecentAccomplishments();
    message.recentOutcomes = (object.recentOutcomes !== undefined && object.recentOutcomes !== null)
      ? CMsgPlayerRecentMatchOutcomes.fromPartial(object.recentOutcomes)
      : undefined;
    message.totalRecord = (object.totalRecord !== undefined && object.totalRecord !== null)
      ? CMsgPlayerMatchRecord.fromPartial(object.totalRecord)
      : undefined;
    message.predictionStreak = object.predictionStreak ?? 0;
    message.plusPredictionStreak = object.plusPredictionStreak ?? 0;
    message.recentCommends = (object.recentCommends !== undefined && object.recentCommends !== null)
      ? CMsgPlayerRecentCommends.fromPartial(object.recentCommends)
      : undefined;
    message.firstMatchTimestamp = object.firstMatchTimestamp ?? 0;
    message.lastMatch = (object.lastMatch !== undefined && object.lastMatch !== null)
      ? CMsgPlayerRecentMatchInfo.fromPartial(object.lastMatch)
      : undefined;
    message.recentMvps = (object.recentMvps !== undefined && object.recentMvps !== null)
      ? CMsgPlayerRecentMatchOutcomes.fromPartial(object.recentMvps)
      : undefined;
    return message;
  },
};

function createBaseCMsgPlayerHeroRecentAccomplishments(): CMsgPlayerHeroRecentAccomplishments {
  return { recentOutcomes: undefined, totalRecord: undefined, lastMatch: undefined };
}

export const CMsgPlayerHeroRecentAccomplishments = {
  encode(message: CMsgPlayerHeroRecentAccomplishments, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.recentOutcomes !== undefined) {
      CMsgPlayerRecentMatchOutcomes.encode(message.recentOutcomes, writer.uint32(10).fork()).ldelim();
    }
    if (message.totalRecord !== undefined) {
      CMsgPlayerMatchRecord.encode(message.totalRecord, writer.uint32(18).fork()).ldelim();
    }
    if (message.lastMatch !== undefined) {
      CMsgPlayerRecentMatchInfo.encode(message.lastMatch, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgPlayerHeroRecentAccomplishments {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgPlayerHeroRecentAccomplishments();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.recentOutcomes = CMsgPlayerRecentMatchOutcomes.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.totalRecord = CMsgPlayerMatchRecord.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.lastMatch = CMsgPlayerRecentMatchInfo.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgPlayerHeroRecentAccomplishments {
    return {
      recentOutcomes: isSet(object.recentOutcomes)
        ? CMsgPlayerRecentMatchOutcomes.fromJSON(object.recentOutcomes)
        : undefined,
      totalRecord: isSet(object.totalRecord) ? CMsgPlayerMatchRecord.fromJSON(object.totalRecord) : undefined,
      lastMatch: isSet(object.lastMatch) ? CMsgPlayerRecentMatchInfo.fromJSON(object.lastMatch) : undefined,
    };
  },

  toJSON(message: CMsgPlayerHeroRecentAccomplishments): unknown {
    const obj: any = {};
    if (message.recentOutcomes !== undefined) {
      obj.recentOutcomes = CMsgPlayerRecentMatchOutcomes.toJSON(message.recentOutcomes);
    }
    if (message.totalRecord !== undefined) {
      obj.totalRecord = CMsgPlayerMatchRecord.toJSON(message.totalRecord);
    }
    if (message.lastMatch !== undefined) {
      obj.lastMatch = CMsgPlayerRecentMatchInfo.toJSON(message.lastMatch);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgPlayerHeroRecentAccomplishments>): CMsgPlayerHeroRecentAccomplishments {
    return CMsgPlayerHeroRecentAccomplishments.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgPlayerHeroRecentAccomplishments>): CMsgPlayerHeroRecentAccomplishments {
    const message = createBaseCMsgPlayerHeroRecentAccomplishments();
    message.recentOutcomes = (object.recentOutcomes !== undefined && object.recentOutcomes !== null)
      ? CMsgPlayerRecentMatchOutcomes.fromPartial(object.recentOutcomes)
      : undefined;
    message.totalRecord = (object.totalRecord !== undefined && object.totalRecord !== null)
      ? CMsgPlayerMatchRecord.fromPartial(object.totalRecord)
      : undefined;
    message.lastMatch = (object.lastMatch !== undefined && object.lastMatch !== null)
      ? CMsgPlayerRecentMatchInfo.fromPartial(object.lastMatch)
      : undefined;
    return message;
  },
};

function createBaseCMsgRecentAccomplishments(): CMsgRecentAccomplishments {
  return { playerAccomplishments: undefined, heroAccomplishments: undefined };
}

export const CMsgRecentAccomplishments = {
  encode(message: CMsgRecentAccomplishments, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.playerAccomplishments !== undefined) {
      CMsgPlayerRecentAccomplishments.encode(message.playerAccomplishments, writer.uint32(10).fork()).ldelim();
    }
    if (message.heroAccomplishments !== undefined) {
      CMsgPlayerHeroRecentAccomplishments.encode(message.heroAccomplishments, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgRecentAccomplishments {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgRecentAccomplishments();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.playerAccomplishments = CMsgPlayerRecentAccomplishments.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.heroAccomplishments = CMsgPlayerHeroRecentAccomplishments.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgRecentAccomplishments {
    return {
      playerAccomplishments: isSet(object.playerAccomplishments)
        ? CMsgPlayerRecentAccomplishments.fromJSON(object.playerAccomplishments)
        : undefined,
      heroAccomplishments: isSet(object.heroAccomplishments)
        ? CMsgPlayerHeroRecentAccomplishments.fromJSON(object.heroAccomplishments)
        : undefined,
    };
  },

  toJSON(message: CMsgRecentAccomplishments): unknown {
    const obj: any = {};
    if (message.playerAccomplishments !== undefined) {
      obj.playerAccomplishments = CMsgPlayerRecentAccomplishments.toJSON(message.playerAccomplishments);
    }
    if (message.heroAccomplishments !== undefined) {
      obj.heroAccomplishments = CMsgPlayerHeroRecentAccomplishments.toJSON(message.heroAccomplishments);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgRecentAccomplishments>): CMsgRecentAccomplishments {
    return CMsgRecentAccomplishments.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgRecentAccomplishments>): CMsgRecentAccomplishments {
    const message = createBaseCMsgRecentAccomplishments();
    message.playerAccomplishments =
      (object.playerAccomplishments !== undefined && object.playerAccomplishments !== null)
        ? CMsgPlayerRecentAccomplishments.fromPartial(object.playerAccomplishments)
        : undefined;
    message.heroAccomplishments = (object.heroAccomplishments !== undefined && object.heroAccomplishments !== null)
      ? CMsgPlayerHeroRecentAccomplishments.fromPartial(object.heroAccomplishments)
      : undefined;
    return message;
  },
};

function createBaseCMsgServerToGCRequestPlayerRecentAccomplishments(): CMsgServerToGCRequestPlayerRecentAccomplishments {
  return { accountId: 0, heroId: 0 };
}

export const CMsgServerToGCRequestPlayerRecentAccomplishments = {
  encode(
    message: CMsgServerToGCRequestPlayerRecentAccomplishments,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.accountId !== undefined && message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    if (message.heroId !== undefined && message.heroId !== 0) {
      writer.uint32(16).int32(message.heroId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgServerToGCRequestPlayerRecentAccomplishments {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgServerToGCRequestPlayerRecentAccomplishments();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.heroId = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgServerToGCRequestPlayerRecentAccomplishments {
    return {
      accountId: isSet(object.accountId) ? globalThis.Number(object.accountId) : 0,
      heroId: isSet(object.heroId) ? globalThis.Number(object.heroId) : 0,
    };
  },

  toJSON(message: CMsgServerToGCRequestPlayerRecentAccomplishments): unknown {
    const obj: any = {};
    if (message.accountId !== undefined && message.accountId !== 0) {
      obj.accountId = Math.round(message.accountId);
    }
    if (message.heroId !== undefined && message.heroId !== 0) {
      obj.heroId = Math.round(message.heroId);
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgServerToGCRequestPlayerRecentAccomplishments>,
  ): CMsgServerToGCRequestPlayerRecentAccomplishments {
    return CMsgServerToGCRequestPlayerRecentAccomplishments.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgServerToGCRequestPlayerRecentAccomplishments>,
  ): CMsgServerToGCRequestPlayerRecentAccomplishments {
    const message = createBaseCMsgServerToGCRequestPlayerRecentAccomplishments();
    message.accountId = object.accountId ?? 0;
    message.heroId = object.heroId ?? 0;
    return message;
  },
};

function createBaseCMsgServerToGCRequestPlayerRecentAccomplishmentsResponse(): CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse {
  return { result: 0, playerAccomplishments: undefined };
}

export const CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse = {
  encode(
    message: CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.result !== undefined && message.result !== 0) {
      writer.uint32(8).int32(message.result);
    }
    if (message.playerAccomplishments !== undefined) {
      CMsgRecentAccomplishments.encode(message.playerAccomplishments, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgServerToGCRequestPlayerRecentAccomplishmentsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.result = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.playerAccomplishments = CMsgRecentAccomplishments.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse {
    return {
      result: isSet(object.result)
        ? cMsgServerToGCRequestPlayerRecentAccomplishmentsResponse_EResponseFromJSON(object.result)
        : 0,
      playerAccomplishments: isSet(object.playerAccomplishments)
        ? CMsgRecentAccomplishments.fromJSON(object.playerAccomplishments)
        : undefined,
    };
  },

  toJSON(message: CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse): unknown {
    const obj: any = {};
    if (message.result !== undefined && message.result !== 0) {
      obj.result = cMsgServerToGCRequestPlayerRecentAccomplishmentsResponse_EResponseToJSON(message.result);
    }
    if (message.playerAccomplishments !== undefined) {
      obj.playerAccomplishments = CMsgRecentAccomplishments.toJSON(message.playerAccomplishments);
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse>,
  ): CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse {
    return CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse>,
  ): CMsgServerToGCRequestPlayerRecentAccomplishmentsResponse {
    const message = createBaseCMsgServerToGCRequestPlayerRecentAccomplishmentsResponse();
    message.result = object.result ?? 0;
    message.playerAccomplishments =
      (object.playerAccomplishments !== undefined && object.playerAccomplishments !== null)
        ? CMsgRecentAccomplishments.fromPartial(object.playerAccomplishments)
        : undefined;
    return message;
  },
};

function createBaseCMsgArcanaVoteMatchVotes(): CMsgArcanaVoteMatchVotes {
  return { matchId: 0, heroId: 0, voteCount: 0 };
}

export const CMsgArcanaVoteMatchVotes = {
  encode(message: CMsgArcanaVoteMatchVotes, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.matchId !== undefined && message.matchId !== 0) {
      writer.uint32(8).uint32(message.matchId);
    }
    if (message.heroId !== undefined && message.heroId !== 0) {
      writer.uint32(16).int32(message.heroId);
    }
    if (message.voteCount !== undefined && message.voteCount !== 0) {
      writer.uint32(24).uint32(message.voteCount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgArcanaVoteMatchVotes {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgArcanaVoteMatchVotes();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.matchId = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.heroId = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.voteCount = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgArcanaVoteMatchVotes {
    return {
      matchId: isSet(object.matchId) ? globalThis.Number(object.matchId) : 0,
      heroId: isSet(object.heroId) ? globalThis.Number(object.heroId) : 0,
      voteCount: isSet(object.voteCount) ? globalThis.Number(object.voteCount) : 0,
    };
  },

  toJSON(message: CMsgArcanaVoteMatchVotes): unknown {
    const obj: any = {};
    if (message.matchId !== undefined && message.matchId !== 0) {
      obj.matchId = Math.round(message.matchId);
    }
    if (message.heroId !== undefined && message.heroId !== 0) {
      obj.heroId = Math.round(message.heroId);
    }
    if (message.voteCount !== undefined && message.voteCount !== 0) {
      obj.voteCount = Math.round(message.voteCount);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgArcanaVoteMatchVotes>): CMsgArcanaVoteMatchVotes {
    return CMsgArcanaVoteMatchVotes.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgArcanaVoteMatchVotes>): CMsgArcanaVoteMatchVotes {
    const message = createBaseCMsgArcanaVoteMatchVotes();
    message.matchId = object.matchId ?? 0;
    message.heroId = object.heroId ?? 0;
    message.voteCount = object.voteCount ?? 0;
    return message;
  },
};

function createBaseCMsgGCtoGCAssociatedExploiterAccountInfo(): CMsgGCtoGCAssociatedExploiterAccountInfo {
  return { accountId: 0, numMatchesToSearch: 0, minSharedMatchCount: 0, numAdditionalPlayers: 0 };
}

export const CMsgGCtoGCAssociatedExploiterAccountInfo = {
  encode(message: CMsgGCtoGCAssociatedExploiterAccountInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.accountId !== undefined && message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    if (message.numMatchesToSearch !== undefined && message.numMatchesToSearch !== 0) {
      writer.uint32(16).uint32(message.numMatchesToSearch);
    }
    if (message.minSharedMatchCount !== undefined && message.minSharedMatchCount !== 0) {
      writer.uint32(24).uint32(message.minSharedMatchCount);
    }
    if (message.numAdditionalPlayers !== undefined && message.numAdditionalPlayers !== 0) {
      writer.uint32(32).uint32(message.numAdditionalPlayers);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCtoGCAssociatedExploiterAccountInfo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCtoGCAssociatedExploiterAccountInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.numMatchesToSearch = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.minSharedMatchCount = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.numAdditionalPlayers = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCtoGCAssociatedExploiterAccountInfo {
    return {
      accountId: isSet(object.accountId) ? globalThis.Number(object.accountId) : 0,
      numMatchesToSearch: isSet(object.numMatchesToSearch) ? globalThis.Number(object.numMatchesToSearch) : 0,
      minSharedMatchCount: isSet(object.minSharedMatchCount) ? globalThis.Number(object.minSharedMatchCount) : 0,
      numAdditionalPlayers: isSet(object.numAdditionalPlayers) ? globalThis.Number(object.numAdditionalPlayers) : 0,
    };
  },

  toJSON(message: CMsgGCtoGCAssociatedExploiterAccountInfo): unknown {
    const obj: any = {};
    if (message.accountId !== undefined && message.accountId !== 0) {
      obj.accountId = Math.round(message.accountId);
    }
    if (message.numMatchesToSearch !== undefined && message.numMatchesToSearch !== 0) {
      obj.numMatchesToSearch = Math.round(message.numMatchesToSearch);
    }
    if (message.minSharedMatchCount !== undefined && message.minSharedMatchCount !== 0) {
      obj.minSharedMatchCount = Math.round(message.minSharedMatchCount);
    }
    if (message.numAdditionalPlayers !== undefined && message.numAdditionalPlayers !== 0) {
      obj.numAdditionalPlayers = Math.round(message.numAdditionalPlayers);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCtoGCAssociatedExploiterAccountInfo>): CMsgGCtoGCAssociatedExploiterAccountInfo {
    return CMsgGCtoGCAssociatedExploiterAccountInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCtoGCAssociatedExploiterAccountInfo>): CMsgGCtoGCAssociatedExploiterAccountInfo {
    const message = createBaseCMsgGCtoGCAssociatedExploiterAccountInfo();
    message.accountId = object.accountId ?? 0;
    message.numMatchesToSearch = object.numMatchesToSearch ?? 0;
    message.minSharedMatchCount = object.minSharedMatchCount ?? 0;
    message.numAdditionalPlayers = object.numAdditionalPlayers ?? 0;
    return message;
  },
};

function createBaseCMsgGCtoGCAssociatedExploiterAccountInfoResponse(): CMsgGCtoGCAssociatedExploiterAccountInfoResponse {
  return { accounts: [] };
}

export const CMsgGCtoGCAssociatedExploiterAccountInfoResponse = {
  encode(
    message: CMsgGCtoGCAssociatedExploiterAccountInfoResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    for (const v of message.accounts) {
      CMsgGCtoGCAssociatedExploiterAccountInfoResponse_Account.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCtoGCAssociatedExploiterAccountInfoResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCtoGCAssociatedExploiterAccountInfoResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.accounts.push(
            CMsgGCtoGCAssociatedExploiterAccountInfoResponse_Account.decode(reader, reader.uint32()),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCtoGCAssociatedExploiterAccountInfoResponse {
    return {
      accounts: globalThis.Array.isArray(object?.accounts)
        ? object.accounts.map((e: any) => CMsgGCtoGCAssociatedExploiterAccountInfoResponse_Account.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgGCtoGCAssociatedExploiterAccountInfoResponse): unknown {
    const obj: any = {};
    if (message.accounts?.length) {
      obj.accounts = message.accounts.map((e) => CMsgGCtoGCAssociatedExploiterAccountInfoResponse_Account.toJSON(e));
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgGCtoGCAssociatedExploiterAccountInfoResponse>,
  ): CMsgGCtoGCAssociatedExploiterAccountInfoResponse {
    return CMsgGCtoGCAssociatedExploiterAccountInfoResponse.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgGCtoGCAssociatedExploiterAccountInfoResponse>,
  ): CMsgGCtoGCAssociatedExploiterAccountInfoResponse {
    const message = createBaseCMsgGCtoGCAssociatedExploiterAccountInfoResponse();
    message.accounts =
      object.accounts?.map((e) => CMsgGCtoGCAssociatedExploiterAccountInfoResponse_Account.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgGCtoGCAssociatedExploiterAccountInfoResponse_Account(): CMsgGCtoGCAssociatedExploiterAccountInfoResponse_Account {
  return {
    accountId: 0,
    numCommonMatches: 0,
    earliestCommonMatch: 0,
    latestCommonMatch: 0,
    generation: 0,
    persona: "",
    alreadyBanned: false,
  };
}

export const CMsgGCtoGCAssociatedExploiterAccountInfoResponse_Account = {
  encode(
    message: CMsgGCtoGCAssociatedExploiterAccountInfoResponse_Account,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.accountId !== undefined && message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    if (message.numCommonMatches !== undefined && message.numCommonMatches !== 0) {
      writer.uint32(16).uint32(message.numCommonMatches);
    }
    if (message.earliestCommonMatch !== undefined && message.earliestCommonMatch !== 0) {
      writer.uint32(24).uint32(message.earliestCommonMatch);
    }
    if (message.latestCommonMatch !== undefined && message.latestCommonMatch !== 0) {
      writer.uint32(32).uint32(message.latestCommonMatch);
    }
    if (message.generation !== undefined && message.generation !== 0) {
      writer.uint32(40).uint32(message.generation);
    }
    if (message.persona !== undefined && message.persona !== "") {
      writer.uint32(50).string(message.persona);
    }
    if (message.alreadyBanned !== undefined && message.alreadyBanned !== false) {
      writer.uint32(56).bool(message.alreadyBanned);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCtoGCAssociatedExploiterAccountInfoResponse_Account {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCtoGCAssociatedExploiterAccountInfoResponse_Account();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.numCommonMatches = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.earliestCommonMatch = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.latestCommonMatch = reader.uint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.generation = reader.uint32();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.persona = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.alreadyBanned = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCtoGCAssociatedExploiterAccountInfoResponse_Account {
    return {
      accountId: isSet(object.accountId) ? globalThis.Number(object.accountId) : 0,
      numCommonMatches: isSet(object.numCommonMatches) ? globalThis.Number(object.numCommonMatches) : 0,
      earliestCommonMatch: isSet(object.earliestCommonMatch) ? globalThis.Number(object.earliestCommonMatch) : 0,
      latestCommonMatch: isSet(object.latestCommonMatch) ? globalThis.Number(object.latestCommonMatch) : 0,
      generation: isSet(object.generation) ? globalThis.Number(object.generation) : 0,
      persona: isSet(object.persona) ? globalThis.String(object.persona) : "",
      alreadyBanned: isSet(object.alreadyBanned) ? globalThis.Boolean(object.alreadyBanned) : false,
    };
  },

  toJSON(message: CMsgGCtoGCAssociatedExploiterAccountInfoResponse_Account): unknown {
    const obj: any = {};
    if (message.accountId !== undefined && message.accountId !== 0) {
      obj.accountId = Math.round(message.accountId);
    }
    if (message.numCommonMatches !== undefined && message.numCommonMatches !== 0) {
      obj.numCommonMatches = Math.round(message.numCommonMatches);
    }
    if (message.earliestCommonMatch !== undefined && message.earliestCommonMatch !== 0) {
      obj.earliestCommonMatch = Math.round(message.earliestCommonMatch);
    }
    if (message.latestCommonMatch !== undefined && message.latestCommonMatch !== 0) {
      obj.latestCommonMatch = Math.round(message.latestCommonMatch);
    }
    if (message.generation !== undefined && message.generation !== 0) {
      obj.generation = Math.round(message.generation);
    }
    if (message.persona !== undefined && message.persona !== "") {
      obj.persona = message.persona;
    }
    if (message.alreadyBanned !== undefined && message.alreadyBanned !== false) {
      obj.alreadyBanned = message.alreadyBanned;
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgGCtoGCAssociatedExploiterAccountInfoResponse_Account>,
  ): CMsgGCtoGCAssociatedExploiterAccountInfoResponse_Account {
    return CMsgGCtoGCAssociatedExploiterAccountInfoResponse_Account.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgGCtoGCAssociatedExploiterAccountInfoResponse_Account>,
  ): CMsgGCtoGCAssociatedExploiterAccountInfoResponse_Account {
    const message = createBaseCMsgGCtoGCAssociatedExploiterAccountInfoResponse_Account();
    message.accountId = object.accountId ?? 0;
    message.numCommonMatches = object.numCommonMatches ?? 0;
    message.earliestCommonMatch = object.earliestCommonMatch ?? 0;
    message.latestCommonMatch = object.latestCommonMatch ?? 0;
    message.generation = object.generation ?? 0;
    message.persona = object.persona ?? "";
    message.alreadyBanned = object.alreadyBanned ?? false;
    return message;
  },
};

function createBaseCMsgPullTabsData(): CMsgPullTabsData {
  return { slots: [], jackpots: [], lastBoard: 0 };
}

export const CMsgPullTabsData = {
  encode(message: CMsgPullTabsData, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.slots) {
      CMsgPullTabsData_Slot.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.jackpots) {
      CMsgPullTabsData_Jackpot.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.lastBoard !== undefined && message.lastBoard !== 0) {
      writer.uint32(24).uint32(message.lastBoard);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgPullTabsData {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgPullTabsData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.slots.push(CMsgPullTabsData_Slot.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.jackpots.push(CMsgPullTabsData_Jackpot.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.lastBoard = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgPullTabsData {
    return {
      slots: globalThis.Array.isArray(object?.slots)
        ? object.slots.map((e: any) => CMsgPullTabsData_Slot.fromJSON(e))
        : [],
      jackpots: globalThis.Array.isArray(object?.jackpots)
        ? object.jackpots.map((e: any) => CMsgPullTabsData_Jackpot.fromJSON(e))
        : [],
      lastBoard: isSet(object.lastBoard) ? globalThis.Number(object.lastBoard) : 0,
    };
  },

  toJSON(message: CMsgPullTabsData): unknown {
    const obj: any = {};
    if (message.slots?.length) {
      obj.slots = message.slots.map((e) => CMsgPullTabsData_Slot.toJSON(e));
    }
    if (message.jackpots?.length) {
      obj.jackpots = message.jackpots.map((e) => CMsgPullTabsData_Jackpot.toJSON(e));
    }
    if (message.lastBoard !== undefined && message.lastBoard !== 0) {
      obj.lastBoard = Math.round(message.lastBoard);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgPullTabsData>): CMsgPullTabsData {
    return CMsgPullTabsData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgPullTabsData>): CMsgPullTabsData {
    const message = createBaseCMsgPullTabsData();
    message.slots = object.slots?.map((e) => CMsgPullTabsData_Slot.fromPartial(e)) || [];
    message.jackpots = object.jackpots?.map((e) => CMsgPullTabsData_Jackpot.fromPartial(e)) || [];
    message.lastBoard = object.lastBoard ?? 0;
    return message;
  },
};

function createBaseCMsgPullTabsData_Slot(): CMsgPullTabsData_Slot {
  return { eventId: 0, boardId: 0, heroId: 0, actionId: 0, redeemed: false };
}

export const CMsgPullTabsData_Slot = {
  encode(message: CMsgPullTabsData_Slot, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.eventId !== undefined && message.eventId !== 0) {
      writer.uint32(8).uint32(message.eventId);
    }
    if (message.boardId !== undefined && message.boardId !== 0) {
      writer.uint32(16).uint32(message.boardId);
    }
    if (message.heroId !== undefined && message.heroId !== 0) {
      writer.uint32(24).int32(message.heroId);
    }
    if (message.actionId !== undefined && message.actionId !== 0) {
      writer.uint32(32).uint32(message.actionId);
    }
    if (message.redeemed !== undefined && message.redeemed !== false) {
      writer.uint32(40).bool(message.redeemed);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgPullTabsData_Slot {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgPullTabsData_Slot();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.eventId = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.boardId = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.heroId = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.actionId = reader.uint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.redeemed = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgPullTabsData_Slot {
    return {
      eventId: isSet(object.eventId) ? globalThis.Number(object.eventId) : 0,
      boardId: isSet(object.boardId) ? globalThis.Number(object.boardId) : 0,
      heroId: isSet(object.heroId) ? globalThis.Number(object.heroId) : 0,
      actionId: isSet(object.actionId) ? globalThis.Number(object.actionId) : 0,
      redeemed: isSet(object.redeemed) ? globalThis.Boolean(object.redeemed) : false,
    };
  },

  toJSON(message: CMsgPullTabsData_Slot): unknown {
    const obj: any = {};
    if (message.eventId !== undefined && message.eventId !== 0) {
      obj.eventId = Math.round(message.eventId);
    }
    if (message.boardId !== undefined && message.boardId !== 0) {
      obj.boardId = Math.round(message.boardId);
    }
    if (message.heroId !== undefined && message.heroId !== 0) {
      obj.heroId = Math.round(message.heroId);
    }
    if (message.actionId !== undefined && message.actionId !== 0) {
      obj.actionId = Math.round(message.actionId);
    }
    if (message.redeemed !== undefined && message.redeemed !== false) {
      obj.redeemed = message.redeemed;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgPullTabsData_Slot>): CMsgPullTabsData_Slot {
    return CMsgPullTabsData_Slot.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgPullTabsData_Slot>): CMsgPullTabsData_Slot {
    const message = createBaseCMsgPullTabsData_Slot();
    message.eventId = object.eventId ?? 0;
    message.boardId = object.boardId ?? 0;
    message.heroId = object.heroId ?? 0;
    message.actionId = object.actionId ?? 0;
    message.redeemed = object.redeemed ?? false;
    return message;
  },
};

function createBaseCMsgPullTabsData_Jackpot(): CMsgPullTabsData_Jackpot {
  return { boardId: 0, actionId: 0, heroId: 0 };
}

export const CMsgPullTabsData_Jackpot = {
  encode(message: CMsgPullTabsData_Jackpot, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.boardId !== undefined && message.boardId !== 0) {
      writer.uint32(8).uint32(message.boardId);
    }
    if (message.actionId !== undefined && message.actionId !== 0) {
      writer.uint32(16).uint32(message.actionId);
    }
    if (message.heroId !== undefined && message.heroId !== 0) {
      writer.uint32(24).int32(message.heroId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgPullTabsData_Jackpot {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgPullTabsData_Jackpot();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.boardId = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.actionId = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.heroId = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgPullTabsData_Jackpot {
    return {
      boardId: isSet(object.boardId) ? globalThis.Number(object.boardId) : 0,
      actionId: isSet(object.actionId) ? globalThis.Number(object.actionId) : 0,
      heroId: isSet(object.heroId) ? globalThis.Number(object.heroId) : 0,
    };
  },

  toJSON(message: CMsgPullTabsData_Jackpot): unknown {
    const obj: any = {};
    if (message.boardId !== undefined && message.boardId !== 0) {
      obj.boardId = Math.round(message.boardId);
    }
    if (message.actionId !== undefined && message.actionId !== 0) {
      obj.actionId = Math.round(message.actionId);
    }
    if (message.heroId !== undefined && message.heroId !== 0) {
      obj.heroId = Math.round(message.heroId);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgPullTabsData_Jackpot>): CMsgPullTabsData_Jackpot {
    return CMsgPullTabsData_Jackpot.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgPullTabsData_Jackpot>): CMsgPullTabsData_Jackpot {
    const message = createBaseCMsgPullTabsData_Jackpot();
    message.boardId = object.boardId ?? 0;
    message.actionId = object.actionId ?? 0;
    message.heroId = object.heroId ?? 0;
    return message;
  },
};

function createBaseCMsgUnderDraftData(): CMsgUnderDraftData {
  return { benchSlots: [], shopSlots: [], gold: 0, totalGold: 0, notRestorable: false };
}

export const CMsgUnderDraftData = {
  encode(message: CMsgUnderDraftData, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.benchSlots) {
      CMsgUnderDraftData_BenchSlot.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.shopSlots) {
      CMsgUnderDraftData_ShopSlot.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.gold !== undefined && message.gold !== 0) {
      writer.uint32(24).uint32(message.gold);
    }
    if (message.totalGold !== undefined && message.totalGold !== 0) {
      writer.uint32(32).uint32(message.totalGold);
    }
    if (message.notRestorable !== undefined && message.notRestorable !== false) {
      writer.uint32(40).bool(message.notRestorable);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgUnderDraftData {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgUnderDraftData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.benchSlots.push(CMsgUnderDraftData_BenchSlot.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.shopSlots.push(CMsgUnderDraftData_ShopSlot.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.gold = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.totalGold = reader.uint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.notRestorable = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgUnderDraftData {
    return {
      benchSlots: globalThis.Array.isArray(object?.benchSlots)
        ? object.benchSlots.map((e: any) => CMsgUnderDraftData_BenchSlot.fromJSON(e))
        : [],
      shopSlots: globalThis.Array.isArray(object?.shopSlots)
        ? object.shopSlots.map((e: any) => CMsgUnderDraftData_ShopSlot.fromJSON(e))
        : [],
      gold: isSet(object.gold) ? globalThis.Number(object.gold) : 0,
      totalGold: isSet(object.totalGold) ? globalThis.Number(object.totalGold) : 0,
      notRestorable: isSet(object.notRestorable) ? globalThis.Boolean(object.notRestorable) : false,
    };
  },

  toJSON(message: CMsgUnderDraftData): unknown {
    const obj: any = {};
    if (message.benchSlots?.length) {
      obj.benchSlots = message.benchSlots.map((e) => CMsgUnderDraftData_BenchSlot.toJSON(e));
    }
    if (message.shopSlots?.length) {
      obj.shopSlots = message.shopSlots.map((e) => CMsgUnderDraftData_ShopSlot.toJSON(e));
    }
    if (message.gold !== undefined && message.gold !== 0) {
      obj.gold = Math.round(message.gold);
    }
    if (message.totalGold !== undefined && message.totalGold !== 0) {
      obj.totalGold = Math.round(message.totalGold);
    }
    if (message.notRestorable !== undefined && message.notRestorable !== false) {
      obj.notRestorable = message.notRestorable;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgUnderDraftData>): CMsgUnderDraftData {
    return CMsgUnderDraftData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgUnderDraftData>): CMsgUnderDraftData {
    const message = createBaseCMsgUnderDraftData();
    message.benchSlots = object.benchSlots?.map((e) => CMsgUnderDraftData_BenchSlot.fromPartial(e)) || [];
    message.shopSlots = object.shopSlots?.map((e) => CMsgUnderDraftData_ShopSlot.fromPartial(e)) || [];
    message.gold = object.gold ?? 0;
    message.totalGold = object.totalGold ?? 0;
    message.notRestorable = object.notRestorable ?? false;
    return message;
  },
};

function createBaseCMsgUnderDraftData_BenchSlot(): CMsgUnderDraftData_BenchSlot {
  return { slotId: 0, heroId: 0, stars: 0 };
}

export const CMsgUnderDraftData_BenchSlot = {
  encode(message: CMsgUnderDraftData_BenchSlot, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.slotId !== undefined && message.slotId !== 0) {
      writer.uint32(8).uint32(message.slotId);
    }
    if (message.heroId !== undefined && message.heroId !== 0) {
      writer.uint32(16).int32(message.heroId);
    }
    if (message.stars !== undefined && message.stars !== 0) {
      writer.uint32(24).uint32(message.stars);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgUnderDraftData_BenchSlot {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgUnderDraftData_BenchSlot();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.slotId = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.heroId = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.stars = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgUnderDraftData_BenchSlot {
    return {
      slotId: isSet(object.slotId) ? globalThis.Number(object.slotId) : 0,
      heroId: isSet(object.heroId) ? globalThis.Number(object.heroId) : 0,
      stars: isSet(object.stars) ? globalThis.Number(object.stars) : 0,
    };
  },

  toJSON(message: CMsgUnderDraftData_BenchSlot): unknown {
    const obj: any = {};
    if (message.slotId !== undefined && message.slotId !== 0) {
      obj.slotId = Math.round(message.slotId);
    }
    if (message.heroId !== undefined && message.heroId !== 0) {
      obj.heroId = Math.round(message.heroId);
    }
    if (message.stars !== undefined && message.stars !== 0) {
      obj.stars = Math.round(message.stars);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgUnderDraftData_BenchSlot>): CMsgUnderDraftData_BenchSlot {
    return CMsgUnderDraftData_BenchSlot.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgUnderDraftData_BenchSlot>): CMsgUnderDraftData_BenchSlot {
    const message = createBaseCMsgUnderDraftData_BenchSlot();
    message.slotId = object.slotId ?? 0;
    message.heroId = object.heroId ?? 0;
    message.stars = object.stars ?? 0;
    return message;
  },
};

function createBaseCMsgUnderDraftData_ShopSlot(): CMsgUnderDraftData_ShopSlot {
  return { slotId: 0, heroId: 0, isSpecialReward: false };
}

export const CMsgUnderDraftData_ShopSlot = {
  encode(message: CMsgUnderDraftData_ShopSlot, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.slotId !== undefined && message.slotId !== 0) {
      writer.uint32(8).uint32(message.slotId);
    }
    if (message.heroId !== undefined && message.heroId !== 0) {
      writer.uint32(16).int32(message.heroId);
    }
    if (message.isSpecialReward !== undefined && message.isSpecialReward !== false) {
      writer.uint32(24).bool(message.isSpecialReward);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgUnderDraftData_ShopSlot {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgUnderDraftData_ShopSlot();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.slotId = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.heroId = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.isSpecialReward = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgUnderDraftData_ShopSlot {
    return {
      slotId: isSet(object.slotId) ? globalThis.Number(object.slotId) : 0,
      heroId: isSet(object.heroId) ? globalThis.Number(object.heroId) : 0,
      isSpecialReward: isSet(object.isSpecialReward) ? globalThis.Boolean(object.isSpecialReward) : false,
    };
  },

  toJSON(message: CMsgUnderDraftData_ShopSlot): unknown {
    const obj: any = {};
    if (message.slotId !== undefined && message.slotId !== 0) {
      obj.slotId = Math.round(message.slotId);
    }
    if (message.heroId !== undefined && message.heroId !== 0) {
      obj.heroId = Math.round(message.heroId);
    }
    if (message.isSpecialReward !== undefined && message.isSpecialReward !== false) {
      obj.isSpecialReward = message.isSpecialReward;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgUnderDraftData_ShopSlot>): CMsgUnderDraftData_ShopSlot {
    return CMsgUnderDraftData_ShopSlot.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgUnderDraftData_ShopSlot>): CMsgUnderDraftData_ShopSlot {
    const message = createBaseCMsgUnderDraftData_ShopSlot();
    message.slotId = object.slotId ?? 0;
    message.heroId = object.heroId ?? 0;
    message.isSpecialReward = object.isSpecialReward ?? false;
    return message;
  },
};

function createBaseCMsgPlayerTitleData(): CMsgPlayerTitleData {
  return { title: [], eventId: [], active: 0 };
}

export const CMsgPlayerTitleData = {
  encode(message: CMsgPlayerTitleData, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.title) {
      writer.uint32(v);
    }
    writer.ldelim();
    writer.uint32(18).fork();
    for (const v of message.eventId) {
      writer.uint32(v);
    }
    writer.ldelim();
    if (message.active !== undefined && message.active !== 0) {
      writer.uint32(24).uint32(message.active);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgPlayerTitleData {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgPlayerTitleData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.title.push(reader.uint32());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.title.push(reader.uint32());
            }

            continue;
          }

          break;
        case 2:
          if (tag === 16) {
            message.eventId.push(reader.uint32());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.eventId.push(reader.uint32());
            }

            continue;
          }

          break;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.active = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgPlayerTitleData {
    return {
      title: globalThis.Array.isArray(object?.title) ? object.title.map((e: any) => globalThis.Number(e)) : [],
      eventId: globalThis.Array.isArray(object?.eventId) ? object.eventId.map((e: any) => globalThis.Number(e)) : [],
      active: isSet(object.active) ? globalThis.Number(object.active) : 0,
    };
  },

  toJSON(message: CMsgPlayerTitleData): unknown {
    const obj: any = {};
    if (message.title?.length) {
      obj.title = message.title.map((e) => Math.round(e));
    }
    if (message.eventId?.length) {
      obj.eventId = message.eventId.map((e) => Math.round(e));
    }
    if (message.active !== undefined && message.active !== 0) {
      obj.active = Math.round(message.active);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgPlayerTitleData>): CMsgPlayerTitleData {
    return CMsgPlayerTitleData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgPlayerTitleData>): CMsgPlayerTitleData {
    const message = createBaseCMsgPlayerTitleData();
    message.title = object.title?.map((e) => e) || [];
    message.eventId = object.eventId?.map((e) => e) || [];
    message.active = object.active ?? 0;
    return message;
  },
};

function createBaseCMsgDOTATriviaQuestion(): CMsgDOTATriviaQuestion {
  return { questionId: 0, category: 0, timestamp: 0, questionValue: "", answerValues: [], correctAnswerIndex: 0 };
}

export const CMsgDOTATriviaQuestion = {
  encode(message: CMsgDOTATriviaQuestion, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.questionId !== undefined && message.questionId !== 0) {
      writer.uint32(8).uint32(message.questionId);
    }
    if (message.category !== undefined && message.category !== 0) {
      writer.uint32(16).int32(message.category);
    }
    if (message.timestamp !== undefined && message.timestamp !== 0) {
      writer.uint32(24).uint32(message.timestamp);
    }
    if (message.questionValue !== undefined && message.questionValue !== "") {
      writer.uint32(34).string(message.questionValue);
    }
    for (const v of message.answerValues) {
      writer.uint32(42).string(v!);
    }
    if (message.correctAnswerIndex !== undefined && message.correctAnswerIndex !== 0) {
      writer.uint32(48).uint32(message.correctAnswerIndex);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTATriviaQuestion {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTATriviaQuestion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.questionId = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.category = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.timestamp = reader.uint32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.questionValue = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.answerValues.push(reader.string());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.correctAnswerIndex = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTATriviaQuestion {
    return {
      questionId: isSet(object.questionId) ? globalThis.Number(object.questionId) : 0,
      category: isSet(object.category) ? eDOTATriviaQuestionCategoryFromJSON(object.category) : 0,
      timestamp: isSet(object.timestamp) ? globalThis.Number(object.timestamp) : 0,
      questionValue: isSet(object.questionValue) ? globalThis.String(object.questionValue) : "",
      answerValues: globalThis.Array.isArray(object?.answerValues)
        ? object.answerValues.map((e: any) => globalThis.String(e))
        : [],
      correctAnswerIndex: isSet(object.correctAnswerIndex) ? globalThis.Number(object.correctAnswerIndex) : 0,
    };
  },

  toJSON(message: CMsgDOTATriviaQuestion): unknown {
    const obj: any = {};
    if (message.questionId !== undefined && message.questionId !== 0) {
      obj.questionId = Math.round(message.questionId);
    }
    if (message.category !== undefined && message.category !== 0) {
      obj.category = eDOTATriviaQuestionCategoryToJSON(message.category);
    }
    if (message.timestamp !== undefined && message.timestamp !== 0) {
      obj.timestamp = Math.round(message.timestamp);
    }
    if (message.questionValue !== undefined && message.questionValue !== "") {
      obj.questionValue = message.questionValue;
    }
    if (message.answerValues?.length) {
      obj.answerValues = message.answerValues;
    }
    if (message.correctAnswerIndex !== undefined && message.correctAnswerIndex !== 0) {
      obj.correctAnswerIndex = Math.round(message.correctAnswerIndex);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTATriviaQuestion>): CMsgDOTATriviaQuestion {
    return CMsgDOTATriviaQuestion.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTATriviaQuestion>): CMsgDOTATriviaQuestion {
    const message = createBaseCMsgDOTATriviaQuestion();
    message.questionId = object.questionId ?? 0;
    message.category = object.category ?? 0;
    message.timestamp = object.timestamp ?? 0;
    message.questionValue = object.questionValue ?? "";
    message.answerValues = object.answerValues?.map((e) => e) || [];
    message.correctAnswerIndex = object.correctAnswerIndex ?? 0;
    return message;
  },
};

function createBaseCMsgDOTATriviaQuestionAnswersSummary(): CMsgDOTATriviaQuestionAnswersSummary {
  return { summaryAvailable: false, pickedCount: [] };
}

export const CMsgDOTATriviaQuestionAnswersSummary = {
  encode(message: CMsgDOTATriviaQuestionAnswersSummary, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.summaryAvailable !== undefined && message.summaryAvailable !== false) {
      writer.uint32(8).bool(message.summaryAvailable);
    }
    writer.uint32(18).fork();
    for (const v of message.pickedCount) {
      writer.uint32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTATriviaQuestionAnswersSummary {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTATriviaQuestionAnswersSummary();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.summaryAvailable = reader.bool();
          continue;
        case 2:
          if (tag === 16) {
            message.pickedCount.push(reader.uint32());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.pickedCount.push(reader.uint32());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTATriviaQuestionAnswersSummary {
    return {
      summaryAvailable: isSet(object.summaryAvailable) ? globalThis.Boolean(object.summaryAvailable) : false,
      pickedCount: globalThis.Array.isArray(object?.pickedCount)
        ? object.pickedCount.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: CMsgDOTATriviaQuestionAnswersSummary): unknown {
    const obj: any = {};
    if (message.summaryAvailable !== undefined && message.summaryAvailable !== false) {
      obj.summaryAvailable = message.summaryAvailable;
    }
    if (message.pickedCount?.length) {
      obj.pickedCount = message.pickedCount.map((e) => Math.round(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTATriviaQuestionAnswersSummary>): CMsgDOTATriviaQuestionAnswersSummary {
    return CMsgDOTATriviaQuestionAnswersSummary.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTATriviaQuestionAnswersSummary>): CMsgDOTATriviaQuestionAnswersSummary {
    const message = createBaseCMsgDOTATriviaQuestionAnswersSummary();
    message.summaryAvailable = object.summaryAvailable ?? false;
    message.pickedCount = object.pickedCount?.map((e) => e) || [];
    return message;
  },
};

function createBaseCMsgGameDataSpecialValueBonus(): CMsgGameDataSpecialValueBonus {
  return { name: "", value: 0, operation: 0 };
}

export const CMsgGameDataSpecialValueBonus = {
  encode(message: CMsgGameDataSpecialValueBonus, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.value !== undefined && message.value !== 0) {
      writer.uint32(21).float(message.value);
    }
    if (message.operation !== undefined && message.operation !== 0) {
      writer.uint32(24).uint32(message.operation);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGameDataSpecialValueBonus {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGameDataSpecialValueBonus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.value = reader.float();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.operation = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGameDataSpecialValueBonus {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
      operation: isSet(object.operation) ? globalThis.Number(object.operation) : 0,
    };
  },

  toJSON(message: CMsgGameDataSpecialValueBonus): unknown {
    const obj: any = {};
    if (message.name !== undefined && message.name !== "") {
      obj.name = message.name;
    }
    if (message.value !== undefined && message.value !== 0) {
      obj.value = message.value;
    }
    if (message.operation !== undefined && message.operation !== 0) {
      obj.operation = Math.round(message.operation);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGameDataSpecialValueBonus>): CMsgGameDataSpecialValueBonus {
    return CMsgGameDataSpecialValueBonus.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGameDataSpecialValueBonus>): CMsgGameDataSpecialValueBonus {
    const message = createBaseCMsgGameDataSpecialValueBonus();
    message.name = object.name ?? "";
    message.value = object.value ?? 0;
    message.operation = object.operation ?? 0;
    return message;
  },
};

function createBaseCMsgGameDataSpecialValues(): CMsgGameDataSpecialValues {
  return {
    name: "",
    valuesFloat: [],
    isPercentage: false,
    headingLoc: "",
    bonuses: [],
    valuesShard: [],
    valuesScepter: [],
    facetBonus: undefined,
    requiredFacet: "",
  };
}

export const CMsgGameDataSpecialValues = {
  encode(message: CMsgGameDataSpecialValues, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    writer.uint32(18).fork();
    for (const v of message.valuesFloat) {
      writer.float(v);
    }
    writer.ldelim();
    if (message.isPercentage !== undefined && message.isPercentage !== false) {
      writer.uint32(32).bool(message.isPercentage);
    }
    if (message.headingLoc !== undefined && message.headingLoc !== "") {
      writer.uint32(42).string(message.headingLoc);
    }
    for (const v of message.bonuses) {
      CMsgGameDataSpecialValueBonus.encode(v!, writer.uint32(50).fork()).ldelim();
    }
    writer.uint32(58).fork();
    for (const v of message.valuesShard) {
      writer.float(v);
    }
    writer.ldelim();
    writer.uint32(66).fork();
    for (const v of message.valuesScepter) {
      writer.float(v);
    }
    writer.ldelim();
    if (message.facetBonus !== undefined) {
      CMsgGameDataFacetAbilityBonus.encode(message.facetBonus, writer.uint32(74).fork()).ldelim();
    }
    if (message.requiredFacet !== undefined && message.requiredFacet !== "") {
      writer.uint32(82).string(message.requiredFacet);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGameDataSpecialValues {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGameDataSpecialValues();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag === 21) {
            message.valuesFloat.push(reader.float());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.valuesFloat.push(reader.float());
            }

            continue;
          }

          break;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.isPercentage = reader.bool();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.headingLoc = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.bonuses.push(CMsgGameDataSpecialValueBonus.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag === 61) {
            message.valuesShard.push(reader.float());

            continue;
          }

          if (tag === 58) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.valuesShard.push(reader.float());
            }

            continue;
          }

          break;
        case 8:
          if (tag === 69) {
            message.valuesScepter.push(reader.float());

            continue;
          }

          if (tag === 66) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.valuesScepter.push(reader.float());
            }

            continue;
          }

          break;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.facetBonus = CMsgGameDataFacetAbilityBonus.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.requiredFacet = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGameDataSpecialValues {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      valuesFloat: globalThis.Array.isArray(object?.valuesFloat)
        ? object.valuesFloat.map((e: any) => globalThis.Number(e))
        : [],
      isPercentage: isSet(object.isPercentage) ? globalThis.Boolean(object.isPercentage) : false,
      headingLoc: isSet(object.headingLoc) ? globalThis.String(object.headingLoc) : "",
      bonuses: globalThis.Array.isArray(object?.bonuses)
        ? object.bonuses.map((e: any) => CMsgGameDataSpecialValueBonus.fromJSON(e))
        : [],
      valuesShard: globalThis.Array.isArray(object?.valuesShard)
        ? object.valuesShard.map((e: any) => globalThis.Number(e))
        : [],
      valuesScepter: globalThis.Array.isArray(object?.valuesScepter)
        ? object.valuesScepter.map((e: any) => globalThis.Number(e))
        : [],
      facetBonus: isSet(object.facetBonus) ? CMsgGameDataFacetAbilityBonus.fromJSON(object.facetBonus) : undefined,
      requiredFacet: isSet(object.requiredFacet) ? globalThis.String(object.requiredFacet) : "",
    };
  },

  toJSON(message: CMsgGameDataSpecialValues): unknown {
    const obj: any = {};
    if (message.name !== undefined && message.name !== "") {
      obj.name = message.name;
    }
    if (message.valuesFloat?.length) {
      obj.valuesFloat = message.valuesFloat;
    }
    if (message.isPercentage !== undefined && message.isPercentage !== false) {
      obj.isPercentage = message.isPercentage;
    }
    if (message.headingLoc !== undefined && message.headingLoc !== "") {
      obj.headingLoc = message.headingLoc;
    }
    if (message.bonuses?.length) {
      obj.bonuses = message.bonuses.map((e) => CMsgGameDataSpecialValueBonus.toJSON(e));
    }
    if (message.valuesShard?.length) {
      obj.valuesShard = message.valuesShard;
    }
    if (message.valuesScepter?.length) {
      obj.valuesScepter = message.valuesScepter;
    }
    if (message.facetBonus !== undefined) {
      obj.facetBonus = CMsgGameDataFacetAbilityBonus.toJSON(message.facetBonus);
    }
    if (message.requiredFacet !== undefined && message.requiredFacet !== "") {
      obj.requiredFacet = message.requiredFacet;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGameDataSpecialValues>): CMsgGameDataSpecialValues {
    return CMsgGameDataSpecialValues.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGameDataSpecialValues>): CMsgGameDataSpecialValues {
    const message = createBaseCMsgGameDataSpecialValues();
    message.name = object.name ?? "";
    message.valuesFloat = object.valuesFloat?.map((e) => e) || [];
    message.isPercentage = object.isPercentage ?? false;
    message.headingLoc = object.headingLoc ?? "";
    message.bonuses = object.bonuses?.map((e) => CMsgGameDataSpecialValueBonus.fromPartial(e)) || [];
    message.valuesShard = object.valuesShard?.map((e) => e) || [];
    message.valuesScepter = object.valuesScepter?.map((e) => e) || [];
    message.facetBonus = (object.facetBonus !== undefined && object.facetBonus !== null)
      ? CMsgGameDataFacetAbilityBonus.fromPartial(object.facetBonus)
      : undefined;
    message.requiredFacet = object.requiredFacet ?? "";
    return message;
  },
};

function createBaseCMsgGameDataFacetAbilityBonus(): CMsgGameDataFacetAbilityBonus {
  return { name: "", values: [], operation: 0 };
}

export const CMsgGameDataFacetAbilityBonus = {
  encode(message: CMsgGameDataFacetAbilityBonus, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    writer.uint32(18).fork();
    for (const v of message.values) {
      writer.float(v);
    }
    writer.ldelim();
    if (message.operation !== undefined && message.operation !== 0) {
      writer.uint32(24).uint32(message.operation);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGameDataFacetAbilityBonus {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGameDataFacetAbilityBonus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag === 21) {
            message.values.push(reader.float());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.values.push(reader.float());
            }

            continue;
          }

          break;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.operation = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGameDataFacetAbilityBonus {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      values: globalThis.Array.isArray(object?.values) ? object.values.map((e: any) => globalThis.Number(e)) : [],
      operation: isSet(object.operation) ? globalThis.Number(object.operation) : 0,
    };
  },

  toJSON(message: CMsgGameDataFacetAbilityBonus): unknown {
    const obj: any = {};
    if (message.name !== undefined && message.name !== "") {
      obj.name = message.name;
    }
    if (message.values?.length) {
      obj.values = message.values;
    }
    if (message.operation !== undefined && message.operation !== 0) {
      obj.operation = Math.round(message.operation);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGameDataFacetAbilityBonus>): CMsgGameDataFacetAbilityBonus {
    return CMsgGameDataFacetAbilityBonus.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGameDataFacetAbilityBonus>): CMsgGameDataFacetAbilityBonus {
    const message = createBaseCMsgGameDataFacetAbilityBonus();
    message.name = object.name ?? "";
    message.values = object.values?.map((e) => e) || [];
    message.operation = object.operation ?? 0;
    return message;
  },
};

function createBaseCMsgGameDataAbilityOrItem(): CMsgGameDataAbilityOrItem {
  return {
    id: -1,
    name: "",
    nameLoc: "",
    descLoc: "",
    loreLoc: "",
    notesLoc: [],
    shardLoc: "",
    scepterLoc: "",
    facetsLoc: [],
    type: 0,
    behavior: "0",
    targetTeam: 0,
    targetType: 0,
    flags: 0,
    damage: 0,
    immunity: 0,
    dispellable: 0,
    maxLevel: 0,
    castRanges: [],
    castPoints: [],
    channelTimes: [],
    cooldowns: [],
    durations: [],
    damages: [],
    manaCosts: [],
    goldCosts: [],
    healthCosts: [],
    specialValues: [],
    isItem: false,
    abilityHasScepter: false,
    abilityHasShard: false,
    abilityIsGrantedByScepter: false,
    abilityIsGrantedByShard: false,
    abilityIsInnate: false,
    itemCost: 0,
    itemInitialCharges: 0,
    itemNeutralTier: 0,
    itemStockMax: 0,
    itemStockTime: 0,
    itemQuality: 0,
  };
}

export const CMsgGameDataAbilityOrItem = {
  encode(message: CMsgGameDataAbilityOrItem, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== undefined && message.id !== -1) {
      writer.uint32(8).int32(message.id);
    }
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.nameLoc !== undefined && message.nameLoc !== "") {
      writer.uint32(42).string(message.nameLoc);
    }
    if (message.descLoc !== undefined && message.descLoc !== "") {
      writer.uint32(50).string(message.descLoc);
    }
    if (message.loreLoc !== undefined && message.loreLoc !== "") {
      writer.uint32(58).string(message.loreLoc);
    }
    for (const v of message.notesLoc) {
      writer.uint32(66).string(v!);
    }
    if (message.shardLoc !== undefined && message.shardLoc !== "") {
      writer.uint32(74).string(message.shardLoc);
    }
    if (message.scepterLoc !== undefined && message.scepterLoc !== "") {
      writer.uint32(82).string(message.scepterLoc);
    }
    for (const v of message.facetsLoc) {
      writer.uint32(90).string(v!);
    }
    if (message.type !== undefined && message.type !== 0) {
      writer.uint32(160).uint32(message.type);
    }
    if (message.behavior !== undefined && message.behavior !== "0") {
      writer.uint32(168).uint64(message.behavior);
    }
    if (message.targetTeam !== undefined && message.targetTeam !== 0) {
      writer.uint32(176).uint32(message.targetTeam);
    }
    if (message.targetType !== undefined && message.targetType !== 0) {
      writer.uint32(184).uint32(message.targetType);
    }
    if (message.flags !== undefined && message.flags !== 0) {
      writer.uint32(192).uint32(message.flags);
    }
    if (message.damage !== undefined && message.damage !== 0) {
      writer.uint32(200).uint32(message.damage);
    }
    if (message.immunity !== undefined && message.immunity !== 0) {
      writer.uint32(208).uint32(message.immunity);
    }
    if (message.dispellable !== undefined && message.dispellable !== 0) {
      writer.uint32(216).uint32(message.dispellable);
    }
    if (message.maxLevel !== undefined && message.maxLevel !== 0) {
      writer.uint32(224).uint32(message.maxLevel);
    }
    writer.uint32(242).fork();
    for (const v of message.castRanges) {
      writer.uint32(v);
    }
    writer.ldelim();
    writer.uint32(250).fork();
    for (const v of message.castPoints) {
      writer.float(v);
    }
    writer.ldelim();
    writer.uint32(258).fork();
    for (const v of message.channelTimes) {
      writer.float(v);
    }
    writer.ldelim();
    writer.uint32(266).fork();
    for (const v of message.cooldowns) {
      writer.float(v);
    }
    writer.ldelim();
    writer.uint32(274).fork();
    for (const v of message.durations) {
      writer.float(v);
    }
    writer.ldelim();
    writer.uint32(282).fork();
    for (const v of message.damages) {
      writer.uint32(v);
    }
    writer.ldelim();
    writer.uint32(290).fork();
    for (const v of message.manaCosts) {
      writer.uint32(v);
    }
    writer.ldelim();
    writer.uint32(298).fork();
    for (const v of message.goldCosts) {
      writer.uint32(v);
    }
    writer.ldelim();
    writer.uint32(306).fork();
    for (const v of message.healthCosts) {
      writer.uint32(v);
    }
    writer.ldelim();
    for (const v of message.specialValues) {
      CMsgGameDataSpecialValues.encode(v!, writer.uint32(322).fork()).ldelim();
    }
    if (message.isItem !== undefined && message.isItem !== false) {
      writer.uint32(400).bool(message.isItem);
    }
    if (message.abilityHasScepter !== undefined && message.abilityHasScepter !== false) {
      writer.uint32(480).bool(message.abilityHasScepter);
    }
    if (message.abilityHasShard !== undefined && message.abilityHasShard !== false) {
      writer.uint32(488).bool(message.abilityHasShard);
    }
    if (message.abilityIsGrantedByScepter !== undefined && message.abilityIsGrantedByScepter !== false) {
      writer.uint32(496).bool(message.abilityIsGrantedByScepter);
    }
    if (message.abilityIsGrantedByShard !== undefined && message.abilityIsGrantedByShard !== false) {
      writer.uint32(504).bool(message.abilityIsGrantedByShard);
    }
    if (message.abilityIsInnate !== undefined && message.abilityIsInnate !== false) {
      writer.uint32(512).bool(message.abilityIsInnate);
    }
    if (message.itemCost !== undefined && message.itemCost !== 0) {
      writer.uint32(560).uint32(message.itemCost);
    }
    if (message.itemInitialCharges !== undefined && message.itemInitialCharges !== 0) {
      writer.uint32(568).uint32(message.itemInitialCharges);
    }
    if (message.itemNeutralTier !== undefined && message.itemNeutralTier !== 0) {
      writer.uint32(576).uint32(message.itemNeutralTier);
    }
    if (message.itemStockMax !== undefined && message.itemStockMax !== 0) {
      writer.uint32(584).uint32(message.itemStockMax);
    }
    if (message.itemStockTime !== undefined && message.itemStockTime !== 0) {
      writer.uint32(597).float(message.itemStockTime);
    }
    if (message.itemQuality !== undefined && message.itemQuality !== 0) {
      writer.uint32(680).uint32(message.itemQuality);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGameDataAbilityOrItem {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGameDataAbilityOrItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.nameLoc = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.descLoc = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.loreLoc = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.notesLoc.push(reader.string());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.shardLoc = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.scepterLoc = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.facetsLoc.push(reader.string());
          continue;
        case 20:
          if (tag !== 160) {
            break;
          }

          message.type = reader.uint32();
          continue;
        case 21:
          if (tag !== 168) {
            break;
          }

          message.behavior = longToString(reader.uint64() as Long);
          continue;
        case 22:
          if (tag !== 176) {
            break;
          }

          message.targetTeam = reader.uint32();
          continue;
        case 23:
          if (tag !== 184) {
            break;
          }

          message.targetType = reader.uint32();
          continue;
        case 24:
          if (tag !== 192) {
            break;
          }

          message.flags = reader.uint32();
          continue;
        case 25:
          if (tag !== 200) {
            break;
          }

          message.damage = reader.uint32();
          continue;
        case 26:
          if (tag !== 208) {
            break;
          }

          message.immunity = reader.uint32();
          continue;
        case 27:
          if (tag !== 216) {
            break;
          }

          message.dispellable = reader.uint32();
          continue;
        case 28:
          if (tag !== 224) {
            break;
          }

          message.maxLevel = reader.uint32();
          continue;
        case 30:
          if (tag === 240) {
            message.castRanges.push(reader.uint32());

            continue;
          }

          if (tag === 242) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.castRanges.push(reader.uint32());
            }

            continue;
          }

          break;
        case 31:
          if (tag === 253) {
            message.castPoints.push(reader.float());

            continue;
          }

          if (tag === 250) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.castPoints.push(reader.float());
            }

            continue;
          }

          break;
        case 32:
          if (tag === 261) {
            message.channelTimes.push(reader.float());

            continue;
          }

          if (tag === 258) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.channelTimes.push(reader.float());
            }

            continue;
          }

          break;
        case 33:
          if (tag === 269) {
            message.cooldowns.push(reader.float());

            continue;
          }

          if (tag === 266) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.cooldowns.push(reader.float());
            }

            continue;
          }

          break;
        case 34:
          if (tag === 277) {
            message.durations.push(reader.float());

            continue;
          }

          if (tag === 274) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.durations.push(reader.float());
            }

            continue;
          }

          break;
        case 35:
          if (tag === 280) {
            message.damages.push(reader.uint32());

            continue;
          }

          if (tag === 282) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.damages.push(reader.uint32());
            }

            continue;
          }

          break;
        case 36:
          if (tag === 288) {
            message.manaCosts.push(reader.uint32());

            continue;
          }

          if (tag === 290) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.manaCosts.push(reader.uint32());
            }

            continue;
          }

          break;
        case 37:
          if (tag === 296) {
            message.goldCosts.push(reader.uint32());

            continue;
          }

          if (tag === 298) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.goldCosts.push(reader.uint32());
            }

            continue;
          }

          break;
        case 38:
          if (tag === 304) {
            message.healthCosts.push(reader.uint32());

            continue;
          }

          if (tag === 306) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.healthCosts.push(reader.uint32());
            }

            continue;
          }

          break;
        case 40:
          if (tag !== 322) {
            break;
          }

          message.specialValues.push(CMsgGameDataSpecialValues.decode(reader, reader.uint32()));
          continue;
        case 50:
          if (tag !== 400) {
            break;
          }

          message.isItem = reader.bool();
          continue;
        case 60:
          if (tag !== 480) {
            break;
          }

          message.abilityHasScepter = reader.bool();
          continue;
        case 61:
          if (tag !== 488) {
            break;
          }

          message.abilityHasShard = reader.bool();
          continue;
        case 62:
          if (tag !== 496) {
            break;
          }

          message.abilityIsGrantedByScepter = reader.bool();
          continue;
        case 63:
          if (tag !== 504) {
            break;
          }

          message.abilityIsGrantedByShard = reader.bool();
          continue;
        case 64:
          if (tag !== 512) {
            break;
          }

          message.abilityIsInnate = reader.bool();
          continue;
        case 70:
          if (tag !== 560) {
            break;
          }

          message.itemCost = reader.uint32();
          continue;
        case 71:
          if (tag !== 568) {
            break;
          }

          message.itemInitialCharges = reader.uint32();
          continue;
        case 72:
          if (tag !== 576) {
            break;
          }

          message.itemNeutralTier = reader.uint32();
          continue;
        case 73:
          if (tag !== 584) {
            break;
          }

          message.itemStockMax = reader.uint32();
          continue;
        case 74:
          if (tag !== 597) {
            break;
          }

          message.itemStockTime = reader.float();
          continue;
        case 85:
          if (tag !== 680) {
            break;
          }

          message.itemQuality = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGameDataAbilityOrItem {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : -1,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      nameLoc: isSet(object.nameLoc) ? globalThis.String(object.nameLoc) : "",
      descLoc: isSet(object.descLoc) ? globalThis.String(object.descLoc) : "",
      loreLoc: isSet(object.loreLoc) ? globalThis.String(object.loreLoc) : "",
      notesLoc: globalThis.Array.isArray(object?.notesLoc) ? object.notesLoc.map((e: any) => globalThis.String(e)) : [],
      shardLoc: isSet(object.shardLoc) ? globalThis.String(object.shardLoc) : "",
      scepterLoc: isSet(object.scepterLoc) ? globalThis.String(object.scepterLoc) : "",
      facetsLoc: globalThis.Array.isArray(object?.facetsLoc)
        ? object.facetsLoc.map((e: any) => globalThis.String(e))
        : [],
      type: isSet(object.type) ? globalThis.Number(object.type) : 0,
      behavior: isSet(object.behavior) ? globalThis.String(object.behavior) : "0",
      targetTeam: isSet(object.targetTeam) ? globalThis.Number(object.targetTeam) : 0,
      targetType: isSet(object.targetType) ? globalThis.Number(object.targetType) : 0,
      flags: isSet(object.flags) ? globalThis.Number(object.flags) : 0,
      damage: isSet(object.damage) ? globalThis.Number(object.damage) : 0,
      immunity: isSet(object.immunity) ? globalThis.Number(object.immunity) : 0,
      dispellable: isSet(object.dispellable) ? globalThis.Number(object.dispellable) : 0,
      maxLevel: isSet(object.maxLevel) ? globalThis.Number(object.maxLevel) : 0,
      castRanges: globalThis.Array.isArray(object?.castRanges)
        ? object.castRanges.map((e: any) => globalThis.Number(e))
        : [],
      castPoints: globalThis.Array.isArray(object?.castPoints)
        ? object.castPoints.map((e: any) => globalThis.Number(e))
        : [],
      channelTimes: globalThis.Array.isArray(object?.channelTimes)
        ? object.channelTimes.map((e: any) => globalThis.Number(e))
        : [],
      cooldowns: globalThis.Array.isArray(object?.cooldowns)
        ? object.cooldowns.map((e: any) => globalThis.Number(e))
        : [],
      durations: globalThis.Array.isArray(object?.durations)
        ? object.durations.map((e: any) => globalThis.Number(e))
        : [],
      damages: globalThis.Array.isArray(object?.damages)
        ? object.damages.map((e: any) => globalThis.Number(e))
        : [],
      manaCosts: globalThis.Array.isArray(object?.manaCosts)
        ? object.manaCosts.map((e: any) => globalThis.Number(e))
        : [],
      goldCosts: globalThis.Array.isArray(object?.goldCosts)
        ? object.goldCosts.map((e: any) => globalThis.Number(e))
        : [],
      healthCosts: globalThis.Array.isArray(object?.healthCosts)
        ? object.healthCosts.map((e: any) => globalThis.Number(e))
        : [],
      specialValues: globalThis.Array.isArray(object?.specialValues)
        ? object.specialValues.map((e: any) => CMsgGameDataSpecialValues.fromJSON(e))
        : [],
      isItem: isSet(object.isItem) ? globalThis.Boolean(object.isItem) : false,
      abilityHasScepter: isSet(object.abilityHasScepter) ? globalThis.Boolean(object.abilityHasScepter) : false,
      abilityHasShard: isSet(object.abilityHasShard) ? globalThis.Boolean(object.abilityHasShard) : false,
      abilityIsGrantedByScepter: isSet(object.abilityIsGrantedByScepter)
        ? globalThis.Boolean(object.abilityIsGrantedByScepter)
        : false,
      abilityIsGrantedByShard: isSet(object.abilityIsGrantedByShard)
        ? globalThis.Boolean(object.abilityIsGrantedByShard)
        : false,
      abilityIsInnate: isSet(object.abilityIsInnate) ? globalThis.Boolean(object.abilityIsInnate) : false,
      itemCost: isSet(object.itemCost) ? globalThis.Number(object.itemCost) : 0,
      itemInitialCharges: isSet(object.itemInitialCharges) ? globalThis.Number(object.itemInitialCharges) : 0,
      itemNeutralTier: isSet(object.itemNeutralTier) ? globalThis.Number(object.itemNeutralTier) : 0,
      itemStockMax: isSet(object.itemStockMax) ? globalThis.Number(object.itemStockMax) : 0,
      itemStockTime: isSet(object.itemStockTime) ? globalThis.Number(object.itemStockTime) : 0,
      itemQuality: isSet(object.itemQuality) ? globalThis.Number(object.itemQuality) : 0,
    };
  },

  toJSON(message: CMsgGameDataAbilityOrItem): unknown {
    const obj: any = {};
    if (message.id !== undefined && message.id !== -1) {
      obj.id = Math.round(message.id);
    }
    if (message.name !== undefined && message.name !== "") {
      obj.name = message.name;
    }
    if (message.nameLoc !== undefined && message.nameLoc !== "") {
      obj.nameLoc = message.nameLoc;
    }
    if (message.descLoc !== undefined && message.descLoc !== "") {
      obj.descLoc = message.descLoc;
    }
    if (message.loreLoc !== undefined && message.loreLoc !== "") {
      obj.loreLoc = message.loreLoc;
    }
    if (message.notesLoc?.length) {
      obj.notesLoc = message.notesLoc;
    }
    if (message.shardLoc !== undefined && message.shardLoc !== "") {
      obj.shardLoc = message.shardLoc;
    }
    if (message.scepterLoc !== undefined && message.scepterLoc !== "") {
      obj.scepterLoc = message.scepterLoc;
    }
    if (message.facetsLoc?.length) {
      obj.facetsLoc = message.facetsLoc;
    }
    if (message.type !== undefined && message.type !== 0) {
      obj.type = Math.round(message.type);
    }
    if (message.behavior !== undefined && message.behavior !== "0") {
      obj.behavior = message.behavior;
    }
    if (message.targetTeam !== undefined && message.targetTeam !== 0) {
      obj.targetTeam = Math.round(message.targetTeam);
    }
    if (message.targetType !== undefined && message.targetType !== 0) {
      obj.targetType = Math.round(message.targetType);
    }
    if (message.flags !== undefined && message.flags !== 0) {
      obj.flags = Math.round(message.flags);
    }
    if (message.damage !== undefined && message.damage !== 0) {
      obj.damage = Math.round(message.damage);
    }
    if (message.immunity !== undefined && message.immunity !== 0) {
      obj.immunity = Math.round(message.immunity);
    }
    if (message.dispellable !== undefined && message.dispellable !== 0) {
      obj.dispellable = Math.round(message.dispellable);
    }
    if (message.maxLevel !== undefined && message.maxLevel !== 0) {
      obj.maxLevel = Math.round(message.maxLevel);
    }
    if (message.castRanges?.length) {
      obj.castRanges = message.castRanges.map((e) => Math.round(e));
    }
    if (message.castPoints?.length) {
      obj.castPoints = message.castPoints;
    }
    if (message.channelTimes?.length) {
      obj.channelTimes = message.channelTimes;
    }
    if (message.cooldowns?.length) {
      obj.cooldowns = message.cooldowns;
    }
    if (message.durations?.length) {
      obj.durations = message.durations;
    }
    if (message.damages?.length) {
      obj.damages = message.damages.map((e) => Math.round(e));
    }
    if (message.manaCosts?.length) {
      obj.manaCosts = message.manaCosts.map((e) => Math.round(e));
    }
    if (message.goldCosts?.length) {
      obj.goldCosts = message.goldCosts.map((e) => Math.round(e));
    }
    if (message.healthCosts?.length) {
      obj.healthCosts = message.healthCosts.map((e) => Math.round(e));
    }
    if (message.specialValues?.length) {
      obj.specialValues = message.specialValues.map((e) => CMsgGameDataSpecialValues.toJSON(e));
    }
    if (message.isItem !== undefined && message.isItem !== false) {
      obj.isItem = message.isItem;
    }
    if (message.abilityHasScepter !== undefined && message.abilityHasScepter !== false) {
      obj.abilityHasScepter = message.abilityHasScepter;
    }
    if (message.abilityHasShard !== undefined && message.abilityHasShard !== false) {
      obj.abilityHasShard = message.abilityHasShard;
    }
    if (message.abilityIsGrantedByScepter !== undefined && message.abilityIsGrantedByScepter !== false) {
      obj.abilityIsGrantedByScepter = message.abilityIsGrantedByScepter;
    }
    if (message.abilityIsGrantedByShard !== undefined && message.abilityIsGrantedByShard !== false) {
      obj.abilityIsGrantedByShard = message.abilityIsGrantedByShard;
    }
    if (message.abilityIsInnate !== undefined && message.abilityIsInnate !== false) {
      obj.abilityIsInnate = message.abilityIsInnate;
    }
    if (message.itemCost !== undefined && message.itemCost !== 0) {
      obj.itemCost = Math.round(message.itemCost);
    }
    if (message.itemInitialCharges !== undefined && message.itemInitialCharges !== 0) {
      obj.itemInitialCharges = Math.round(message.itemInitialCharges);
    }
    if (message.itemNeutralTier !== undefined && message.itemNeutralTier !== 0) {
      obj.itemNeutralTier = Math.round(message.itemNeutralTier);
    }
    if (message.itemStockMax !== undefined && message.itemStockMax !== 0) {
      obj.itemStockMax = Math.round(message.itemStockMax);
    }
    if (message.itemStockTime !== undefined && message.itemStockTime !== 0) {
      obj.itemStockTime = message.itemStockTime;
    }
    if (message.itemQuality !== undefined && message.itemQuality !== 0) {
      obj.itemQuality = Math.round(message.itemQuality);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGameDataAbilityOrItem>): CMsgGameDataAbilityOrItem {
    return CMsgGameDataAbilityOrItem.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGameDataAbilityOrItem>): CMsgGameDataAbilityOrItem {
    const message = createBaseCMsgGameDataAbilityOrItem();
    message.id = object.id ?? -1;
    message.name = object.name ?? "";
    message.nameLoc = object.nameLoc ?? "";
    message.descLoc = object.descLoc ?? "";
    message.loreLoc = object.loreLoc ?? "";
    message.notesLoc = object.notesLoc?.map((e) => e) || [];
    message.shardLoc = object.shardLoc ?? "";
    message.scepterLoc = object.scepterLoc ?? "";
    message.facetsLoc = object.facetsLoc?.map((e) => e) || [];
    message.type = object.type ?? 0;
    message.behavior = object.behavior ?? "0";
    message.targetTeam = object.targetTeam ?? 0;
    message.targetType = object.targetType ?? 0;
    message.flags = object.flags ?? 0;
    message.damage = object.damage ?? 0;
    message.immunity = object.immunity ?? 0;
    message.dispellable = object.dispellable ?? 0;
    message.maxLevel = object.maxLevel ?? 0;
    message.castRanges = object.castRanges?.map((e) => e) || [];
    message.castPoints = object.castPoints?.map((e) => e) || [];
    message.channelTimes = object.channelTimes?.map((e) => e) || [];
    message.cooldowns = object.cooldowns?.map((e) => e) || [];
    message.durations = object.durations?.map((e) => e) || [];
    message.damages = object.damages?.map((e) => e) || [];
    message.manaCosts = object.manaCosts?.map((e) => e) || [];
    message.goldCosts = object.goldCosts?.map((e) => e) || [];
    message.healthCosts = object.healthCosts?.map((e) => e) || [];
    message.specialValues = object.specialValues?.map((e) => CMsgGameDataSpecialValues.fromPartial(e)) || [];
    message.isItem = object.isItem ?? false;
    message.abilityHasScepter = object.abilityHasScepter ?? false;
    message.abilityHasShard = object.abilityHasShard ?? false;
    message.abilityIsGrantedByScepter = object.abilityIsGrantedByScepter ?? false;
    message.abilityIsGrantedByShard = object.abilityIsGrantedByShard ?? false;
    message.abilityIsInnate = object.abilityIsInnate ?? false;
    message.itemCost = object.itemCost ?? 0;
    message.itemInitialCharges = object.itemInitialCharges ?? 0;
    message.itemNeutralTier = object.itemNeutralTier ?? 0;
    message.itemStockMax = object.itemStockMax ?? 0;
    message.itemStockTime = object.itemStockTime ?? 0;
    message.itemQuality = object.itemQuality ?? 0;
    return message;
  },
};

function createBaseCMsgGameDataAbilityOrItemList(): CMsgGameDataAbilityOrItemList {
  return { abilities: [] };
}

export const CMsgGameDataAbilityOrItemList = {
  encode(message: CMsgGameDataAbilityOrItemList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.abilities) {
      CMsgGameDataAbilityOrItem.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGameDataAbilityOrItemList {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGameDataAbilityOrItemList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.abilities.push(CMsgGameDataAbilityOrItem.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGameDataAbilityOrItemList {
    return {
      abilities: globalThis.Array.isArray(object?.abilities)
        ? object.abilities.map((e: any) => CMsgGameDataAbilityOrItem.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgGameDataAbilityOrItemList): unknown {
    const obj: any = {};
    if (message.abilities?.length) {
      obj.abilities = message.abilities.map((e) => CMsgGameDataAbilityOrItem.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGameDataAbilityOrItemList>): CMsgGameDataAbilityOrItemList {
    return CMsgGameDataAbilityOrItemList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGameDataAbilityOrItemList>): CMsgGameDataAbilityOrItemList {
    const message = createBaseCMsgGameDataAbilityOrItemList();
    message.abilities = object.abilities?.map((e) => CMsgGameDataAbilityOrItem.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgGameDataHero(): CMsgGameDataHero {
  return {
    id: 0,
    name: "",
    orderId: 0,
    nameLoc: "",
    bioLoc: "",
    hypeLoc: "",
    npeDescLoc: "",
    facets: [],
    strBase: 0,
    strGain: 0,
    agiBase: 0,
    agiGain: 0,
    intBase: 0,
    intGain: 0,
    primaryAttr: 0,
    complexity: 0,
    attackCapability: 0,
    roleLevels: [],
    damageMin: 0,
    damageMax: 0,
    attackRate: 0,
    attackRange: 0,
    projectileSpeed: 0,
    armor: 0,
    magicResistance: 0,
    movementSpeed: 0,
    turnRate: 0,
    sightRangeDay: 0,
    sightRangeNight: 0,
    maxHealth: 0,
    healthRegen: 0,
    maxMana: 0,
    manaRegen: 0,
    abilities: [],
    talents: [],
    facetAbilities: [],
  };
}

export const CMsgGameDataHero = {
  encode(message: CMsgGameDataHero, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== undefined && message.id !== 0) {
      writer.uint32(8).int32(message.id);
    }
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.orderId !== undefined && message.orderId !== 0) {
      writer.uint32(24).uint32(message.orderId);
    }
    if (message.nameLoc !== undefined && message.nameLoc !== "") {
      writer.uint32(42).string(message.nameLoc);
    }
    if (message.bioLoc !== undefined && message.bioLoc !== "") {
      writer.uint32(50).string(message.bioLoc);
    }
    if (message.hypeLoc !== undefined && message.hypeLoc !== "") {
      writer.uint32(58).string(message.hypeLoc);
    }
    if (message.npeDescLoc !== undefined && message.npeDescLoc !== "") {
      writer.uint32(66).string(message.npeDescLoc);
    }
    for (const v of message.facets) {
      CMsgGameDataHero_Facet.encode(v!, writer.uint32(346).fork()).ldelim();
    }
    if (message.strBase !== undefined && message.strBase !== 0) {
      writer.uint32(80).uint32(message.strBase);
    }
    if (message.strGain !== undefined && message.strGain !== 0) {
      writer.uint32(93).float(message.strGain);
    }
    if (message.agiBase !== undefined && message.agiBase !== 0) {
      writer.uint32(96).uint32(message.agiBase);
    }
    if (message.agiGain !== undefined && message.agiGain !== 0) {
      writer.uint32(109).float(message.agiGain);
    }
    if (message.intBase !== undefined && message.intBase !== 0) {
      writer.uint32(112).uint32(message.intBase);
    }
    if (message.intGain !== undefined && message.intGain !== 0) {
      writer.uint32(125).float(message.intGain);
    }
    if (message.primaryAttr !== undefined && message.primaryAttr !== 0) {
      writer.uint32(160).uint32(message.primaryAttr);
    }
    if (message.complexity !== undefined && message.complexity !== 0) {
      writer.uint32(168).uint32(message.complexity);
    }
    if (message.attackCapability !== undefined && message.attackCapability !== 0) {
      writer.uint32(176).uint32(message.attackCapability);
    }
    writer.uint32(186).fork();
    for (const v of message.roleLevels) {
      writer.uint32(v);
    }
    writer.ldelim();
    if (message.damageMin !== undefined && message.damageMin !== 0) {
      writer.uint32(192).int32(message.damageMin);
    }
    if (message.damageMax !== undefined && message.damageMax !== 0) {
      writer.uint32(200).int32(message.damageMax);
    }
    if (message.attackRate !== undefined && message.attackRate !== 0) {
      writer.uint32(213).float(message.attackRate);
    }
    if (message.attackRange !== undefined && message.attackRange !== 0) {
      writer.uint32(216).uint32(message.attackRange);
    }
    if (message.projectileSpeed !== undefined && message.projectileSpeed !== 0) {
      writer.uint32(224).uint32(message.projectileSpeed);
    }
    if (message.armor !== undefined && message.armor !== 0) {
      writer.uint32(237).float(message.armor);
    }
    if (message.magicResistance !== undefined && message.magicResistance !== 0) {
      writer.uint32(240).uint32(message.magicResistance);
    }
    if (message.movementSpeed !== undefined && message.movementSpeed !== 0) {
      writer.uint32(248).uint32(message.movementSpeed);
    }
    if (message.turnRate !== undefined && message.turnRate !== 0) {
      writer.uint32(261).float(message.turnRate);
    }
    if (message.sightRangeDay !== undefined && message.sightRangeDay !== 0) {
      writer.uint32(264).uint32(message.sightRangeDay);
    }
    if (message.sightRangeNight !== undefined && message.sightRangeNight !== 0) {
      writer.uint32(272).uint32(message.sightRangeNight);
    }
    if (message.maxHealth !== undefined && message.maxHealth !== 0) {
      writer.uint32(280).uint32(message.maxHealth);
    }
    if (message.healthRegen !== undefined && message.healthRegen !== 0) {
      writer.uint32(293).float(message.healthRegen);
    }
    if (message.maxMana !== undefined && message.maxMana !== 0) {
      writer.uint32(296).uint32(message.maxMana);
    }
    if (message.manaRegen !== undefined && message.manaRegen !== 0) {
      writer.uint32(309).float(message.manaRegen);
    }
    for (const v of message.abilities) {
      CMsgGameDataAbilityOrItem.encode(v!, writer.uint32(322).fork()).ldelim();
    }
    for (const v of message.talents) {
      CMsgGameDataAbilityOrItem.encode(v!, writer.uint32(330).fork()).ldelim();
    }
    for (const v of message.facetAbilities) {
      CMsgGameDataAbilityOrItemList.encode(v!, writer.uint32(338).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGameDataHero {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGameDataHero();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.orderId = reader.uint32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.nameLoc = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.bioLoc = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.hypeLoc = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.npeDescLoc = reader.string();
          continue;
        case 43:
          if (tag !== 346) {
            break;
          }

          message.facets.push(CMsgGameDataHero_Facet.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.strBase = reader.uint32();
          continue;
        case 11:
          if (tag !== 93) {
            break;
          }

          message.strGain = reader.float();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.agiBase = reader.uint32();
          continue;
        case 13:
          if (tag !== 109) {
            break;
          }

          message.agiGain = reader.float();
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.intBase = reader.uint32();
          continue;
        case 15:
          if (tag !== 125) {
            break;
          }

          message.intGain = reader.float();
          continue;
        case 20:
          if (tag !== 160) {
            break;
          }

          message.primaryAttr = reader.uint32();
          continue;
        case 21:
          if (tag !== 168) {
            break;
          }

          message.complexity = reader.uint32();
          continue;
        case 22:
          if (tag !== 176) {
            break;
          }

          message.attackCapability = reader.uint32();
          continue;
        case 23:
          if (tag === 184) {
            message.roleLevels.push(reader.uint32());

            continue;
          }

          if (tag === 186) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.roleLevels.push(reader.uint32());
            }

            continue;
          }

          break;
        case 24:
          if (tag !== 192) {
            break;
          }

          message.damageMin = reader.int32();
          continue;
        case 25:
          if (tag !== 200) {
            break;
          }

          message.damageMax = reader.int32();
          continue;
        case 26:
          if (tag !== 213) {
            break;
          }

          message.attackRate = reader.float();
          continue;
        case 27:
          if (tag !== 216) {
            break;
          }

          message.attackRange = reader.uint32();
          continue;
        case 28:
          if (tag !== 224) {
            break;
          }

          message.projectileSpeed = reader.uint32();
          continue;
        case 29:
          if (tag !== 237) {
            break;
          }

          message.armor = reader.float();
          continue;
        case 30:
          if (tag !== 240) {
            break;
          }

          message.magicResistance = reader.uint32();
          continue;
        case 31:
          if (tag !== 248) {
            break;
          }

          message.movementSpeed = reader.uint32();
          continue;
        case 32:
          if (tag !== 261) {
            break;
          }

          message.turnRate = reader.float();
          continue;
        case 33:
          if (tag !== 264) {
            break;
          }

          message.sightRangeDay = reader.uint32();
          continue;
        case 34:
          if (tag !== 272) {
            break;
          }

          message.sightRangeNight = reader.uint32();
          continue;
        case 35:
          if (tag !== 280) {
            break;
          }

          message.maxHealth = reader.uint32();
          continue;
        case 36:
          if (tag !== 293) {
            break;
          }

          message.healthRegen = reader.float();
          continue;
        case 37:
          if (tag !== 296) {
            break;
          }

          message.maxMana = reader.uint32();
          continue;
        case 38:
          if (tag !== 309) {
            break;
          }

          message.manaRegen = reader.float();
          continue;
        case 40:
          if (tag !== 322) {
            break;
          }

          message.abilities.push(CMsgGameDataAbilityOrItem.decode(reader, reader.uint32()));
          continue;
        case 41:
          if (tag !== 330) {
            break;
          }

          message.talents.push(CMsgGameDataAbilityOrItem.decode(reader, reader.uint32()));
          continue;
        case 42:
          if (tag !== 338) {
            break;
          }

          message.facetAbilities.push(CMsgGameDataAbilityOrItemList.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGameDataHero {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      orderId: isSet(object.orderId) ? globalThis.Number(object.orderId) : 0,
      nameLoc: isSet(object.nameLoc) ? globalThis.String(object.nameLoc) : "",
      bioLoc: isSet(object.bioLoc) ? globalThis.String(object.bioLoc) : "",
      hypeLoc: isSet(object.hypeLoc) ? globalThis.String(object.hypeLoc) : "",
      npeDescLoc: isSet(object.npeDescLoc) ? globalThis.String(object.npeDescLoc) : "",
      facets: globalThis.Array.isArray(object?.facets)
        ? object.facets.map((e: any) => CMsgGameDataHero_Facet.fromJSON(e))
        : [],
      strBase: isSet(object.strBase) ? globalThis.Number(object.strBase) : 0,
      strGain: isSet(object.strGain) ? globalThis.Number(object.strGain) : 0,
      agiBase: isSet(object.agiBase) ? globalThis.Number(object.agiBase) : 0,
      agiGain: isSet(object.agiGain) ? globalThis.Number(object.agiGain) : 0,
      intBase: isSet(object.intBase) ? globalThis.Number(object.intBase) : 0,
      intGain: isSet(object.intGain) ? globalThis.Number(object.intGain) : 0,
      primaryAttr: isSet(object.primaryAttr) ? globalThis.Number(object.primaryAttr) : 0,
      complexity: isSet(object.complexity) ? globalThis.Number(object.complexity) : 0,
      attackCapability: isSet(object.attackCapability) ? globalThis.Number(object.attackCapability) : 0,
      roleLevels: globalThis.Array.isArray(object?.roleLevels)
        ? object.roleLevels.map((e: any) => globalThis.Number(e))
        : [],
      damageMin: isSet(object.damageMin) ? globalThis.Number(object.damageMin) : 0,
      damageMax: isSet(object.damageMax) ? globalThis.Number(object.damageMax) : 0,
      attackRate: isSet(object.attackRate) ? globalThis.Number(object.attackRate) : 0,
      attackRange: isSet(object.attackRange) ? globalThis.Number(object.attackRange) : 0,
      projectileSpeed: isSet(object.projectileSpeed) ? globalThis.Number(object.projectileSpeed) : 0,
      armor: isSet(object.armor) ? globalThis.Number(object.armor) : 0,
      magicResistance: isSet(object.magicResistance) ? globalThis.Number(object.magicResistance) : 0,
      movementSpeed: isSet(object.movementSpeed) ? globalThis.Number(object.movementSpeed) : 0,
      turnRate: isSet(object.turnRate) ? globalThis.Number(object.turnRate) : 0,
      sightRangeDay: isSet(object.sightRangeDay) ? globalThis.Number(object.sightRangeDay) : 0,
      sightRangeNight: isSet(object.sightRangeNight) ? globalThis.Number(object.sightRangeNight) : 0,
      maxHealth: isSet(object.maxHealth) ? globalThis.Number(object.maxHealth) : 0,
      healthRegen: isSet(object.healthRegen) ? globalThis.Number(object.healthRegen) : 0,
      maxMana: isSet(object.maxMana) ? globalThis.Number(object.maxMana) : 0,
      manaRegen: isSet(object.manaRegen) ? globalThis.Number(object.manaRegen) : 0,
      abilities: globalThis.Array.isArray(object?.abilities)
        ? object.abilities.map((e: any) => CMsgGameDataAbilityOrItem.fromJSON(e))
        : [],
      talents: globalThis.Array.isArray(object?.talents)
        ? object.talents.map((e: any) => CMsgGameDataAbilityOrItem.fromJSON(e))
        : [],
      facetAbilities: globalThis.Array.isArray(object?.facetAbilities)
        ? object.facetAbilities.map((e: any) => CMsgGameDataAbilityOrItemList.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgGameDataHero): unknown {
    const obj: any = {};
    if (message.id !== undefined && message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.name !== undefined && message.name !== "") {
      obj.name = message.name;
    }
    if (message.orderId !== undefined && message.orderId !== 0) {
      obj.orderId = Math.round(message.orderId);
    }
    if (message.nameLoc !== undefined && message.nameLoc !== "") {
      obj.nameLoc = message.nameLoc;
    }
    if (message.bioLoc !== undefined && message.bioLoc !== "") {
      obj.bioLoc = message.bioLoc;
    }
    if (message.hypeLoc !== undefined && message.hypeLoc !== "") {
      obj.hypeLoc = message.hypeLoc;
    }
    if (message.npeDescLoc !== undefined && message.npeDescLoc !== "") {
      obj.npeDescLoc = message.npeDescLoc;
    }
    if (message.facets?.length) {
      obj.facets = message.facets.map((e) => CMsgGameDataHero_Facet.toJSON(e));
    }
    if (message.strBase !== undefined && message.strBase !== 0) {
      obj.strBase = Math.round(message.strBase);
    }
    if (message.strGain !== undefined && message.strGain !== 0) {
      obj.strGain = message.strGain;
    }
    if (message.agiBase !== undefined && message.agiBase !== 0) {
      obj.agiBase = Math.round(message.agiBase);
    }
    if (message.agiGain !== undefined && message.agiGain !== 0) {
      obj.agiGain = message.agiGain;
    }
    if (message.intBase !== undefined && message.intBase !== 0) {
      obj.intBase = Math.round(message.intBase);
    }
    if (message.intGain !== undefined && message.intGain !== 0) {
      obj.intGain = message.intGain;
    }
    if (message.primaryAttr !== undefined && message.primaryAttr !== 0) {
      obj.primaryAttr = Math.round(message.primaryAttr);
    }
    if (message.complexity !== undefined && message.complexity !== 0) {
      obj.complexity = Math.round(message.complexity);
    }
    if (message.attackCapability !== undefined && message.attackCapability !== 0) {
      obj.attackCapability = Math.round(message.attackCapability);
    }
    if (message.roleLevels?.length) {
      obj.roleLevels = message.roleLevels.map((e) => Math.round(e));
    }
    if (message.damageMin !== undefined && message.damageMin !== 0) {
      obj.damageMin = Math.round(message.damageMin);
    }
    if (message.damageMax !== undefined && message.damageMax !== 0) {
      obj.damageMax = Math.round(message.damageMax);
    }
    if (message.attackRate !== undefined && message.attackRate !== 0) {
      obj.attackRate = message.attackRate;
    }
    if (message.attackRange !== undefined && message.attackRange !== 0) {
      obj.attackRange = Math.round(message.attackRange);
    }
    if (message.projectileSpeed !== undefined && message.projectileSpeed !== 0) {
      obj.projectileSpeed = Math.round(message.projectileSpeed);
    }
    if (message.armor !== undefined && message.armor !== 0) {
      obj.armor = message.armor;
    }
    if (message.magicResistance !== undefined && message.magicResistance !== 0) {
      obj.magicResistance = Math.round(message.magicResistance);
    }
    if (message.movementSpeed !== undefined && message.movementSpeed !== 0) {
      obj.movementSpeed = Math.round(message.movementSpeed);
    }
    if (message.turnRate !== undefined && message.turnRate !== 0) {
      obj.turnRate = message.turnRate;
    }
    if (message.sightRangeDay !== undefined && message.sightRangeDay !== 0) {
      obj.sightRangeDay = Math.round(message.sightRangeDay);
    }
    if (message.sightRangeNight !== undefined && message.sightRangeNight !== 0) {
      obj.sightRangeNight = Math.round(message.sightRangeNight);
    }
    if (message.maxHealth !== undefined && message.maxHealth !== 0) {
      obj.maxHealth = Math.round(message.maxHealth);
    }
    if (message.healthRegen !== undefined && message.healthRegen !== 0) {
      obj.healthRegen = message.healthRegen;
    }
    if (message.maxMana !== undefined && message.maxMana !== 0) {
      obj.maxMana = Math.round(message.maxMana);
    }
    if (message.manaRegen !== undefined && message.manaRegen !== 0) {
      obj.manaRegen = message.manaRegen;
    }
    if (message.abilities?.length) {
      obj.abilities = message.abilities.map((e) => CMsgGameDataAbilityOrItem.toJSON(e));
    }
    if (message.talents?.length) {
      obj.talents = message.talents.map((e) => CMsgGameDataAbilityOrItem.toJSON(e));
    }
    if (message.facetAbilities?.length) {
      obj.facetAbilities = message.facetAbilities.map((e) => CMsgGameDataAbilityOrItemList.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGameDataHero>): CMsgGameDataHero {
    return CMsgGameDataHero.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGameDataHero>): CMsgGameDataHero {
    const message = createBaseCMsgGameDataHero();
    message.id = object.id ?? 0;
    message.name = object.name ?? "";
    message.orderId = object.orderId ?? 0;
    message.nameLoc = object.nameLoc ?? "";
    message.bioLoc = object.bioLoc ?? "";
    message.hypeLoc = object.hypeLoc ?? "";
    message.npeDescLoc = object.npeDescLoc ?? "";
    message.facets = object.facets?.map((e) => CMsgGameDataHero_Facet.fromPartial(e)) || [];
    message.strBase = object.strBase ?? 0;
    message.strGain = object.strGain ?? 0;
    message.agiBase = object.agiBase ?? 0;
    message.agiGain = object.agiGain ?? 0;
    message.intBase = object.intBase ?? 0;
    message.intGain = object.intGain ?? 0;
    message.primaryAttr = object.primaryAttr ?? 0;
    message.complexity = object.complexity ?? 0;
    message.attackCapability = object.attackCapability ?? 0;
    message.roleLevels = object.roleLevels?.map((e) => e) || [];
    message.damageMin = object.damageMin ?? 0;
    message.damageMax = object.damageMax ?? 0;
    message.attackRate = object.attackRate ?? 0;
    message.attackRange = object.attackRange ?? 0;
    message.projectileSpeed = object.projectileSpeed ?? 0;
    message.armor = object.armor ?? 0;
    message.magicResistance = object.magicResistance ?? 0;
    message.movementSpeed = object.movementSpeed ?? 0;
    message.turnRate = object.turnRate ?? 0;
    message.sightRangeDay = object.sightRangeDay ?? 0;
    message.sightRangeNight = object.sightRangeNight ?? 0;
    message.maxHealth = object.maxHealth ?? 0;
    message.healthRegen = object.healthRegen ?? 0;
    message.maxMana = object.maxMana ?? 0;
    message.manaRegen = object.manaRegen ?? 0;
    message.abilities = object.abilities?.map((e) => CMsgGameDataAbilityOrItem.fromPartial(e)) || [];
    message.talents = object.talents?.map((e) => CMsgGameDataAbilityOrItem.fromPartial(e)) || [];
    message.facetAbilities = object.facetAbilities?.map((e) => CMsgGameDataAbilityOrItemList.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgGameDataHero_Facet(): CMsgGameDataHero_Facet {
  return { color: 0, titleLoc: "", descriptionLoc: "", name: "", icon: "", gradientId: 0 };
}

export const CMsgGameDataHero_Facet = {
  encode(message: CMsgGameDataHero_Facet, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.color !== undefined && message.color !== 0) {
      writer.uint32(8).uint32(message.color);
    }
    if (message.titleLoc !== undefined && message.titleLoc !== "") {
      writer.uint32(18).string(message.titleLoc);
    }
    if (message.descriptionLoc !== undefined && message.descriptionLoc !== "") {
      writer.uint32(26).string(message.descriptionLoc);
    }
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(34).string(message.name);
    }
    if (message.icon !== undefined && message.icon !== "") {
      writer.uint32(42).string(message.icon);
    }
    if (message.gradientId !== undefined && message.gradientId !== 0) {
      writer.uint32(48).int32(message.gradientId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGameDataHero_Facet {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGameDataHero_Facet();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.color = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.titleLoc = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.descriptionLoc = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.name = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.icon = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.gradientId = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGameDataHero_Facet {
    return {
      color: isSet(object.color) ? globalThis.Number(object.color) : 0,
      titleLoc: isSet(object.titleLoc) ? globalThis.String(object.titleLoc) : "",
      descriptionLoc: isSet(object.descriptionLoc) ? globalThis.String(object.descriptionLoc) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      icon: isSet(object.icon) ? globalThis.String(object.icon) : "",
      gradientId: isSet(object.gradientId) ? globalThis.Number(object.gradientId) : 0,
    };
  },

  toJSON(message: CMsgGameDataHero_Facet): unknown {
    const obj: any = {};
    if (message.color !== undefined && message.color !== 0) {
      obj.color = Math.round(message.color);
    }
    if (message.titleLoc !== undefined && message.titleLoc !== "") {
      obj.titleLoc = message.titleLoc;
    }
    if (message.descriptionLoc !== undefined && message.descriptionLoc !== "") {
      obj.descriptionLoc = message.descriptionLoc;
    }
    if (message.name !== undefined && message.name !== "") {
      obj.name = message.name;
    }
    if (message.icon !== undefined && message.icon !== "") {
      obj.icon = message.icon;
    }
    if (message.gradientId !== undefined && message.gradientId !== 0) {
      obj.gradientId = Math.round(message.gradientId);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGameDataHero_Facet>): CMsgGameDataHero_Facet {
    return CMsgGameDataHero_Facet.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGameDataHero_Facet>): CMsgGameDataHero_Facet {
    const message = createBaseCMsgGameDataHero_Facet();
    message.color = object.color ?? 0;
    message.titleLoc = object.titleLoc ?? "";
    message.descriptionLoc = object.descriptionLoc ?? "";
    message.name = object.name ?? "";
    message.icon = object.icon ?? "";
    message.gradientId = object.gradientId ?? 0;
    return message;
  },
};

function createBaseCMsgGameDataAbilities(): CMsgGameDataAbilities {
  return { abilities: [] };
}

export const CMsgGameDataAbilities = {
  encode(message: CMsgGameDataAbilities, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.abilities) {
      CMsgGameDataAbilityOrItem.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGameDataAbilities {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGameDataAbilities();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.abilities.push(CMsgGameDataAbilityOrItem.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGameDataAbilities {
    return {
      abilities: globalThis.Array.isArray(object?.abilities)
        ? object.abilities.map((e: any) => CMsgGameDataAbilityOrItem.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgGameDataAbilities): unknown {
    const obj: any = {};
    if (message.abilities?.length) {
      obj.abilities = message.abilities.map((e) => CMsgGameDataAbilityOrItem.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGameDataAbilities>): CMsgGameDataAbilities {
    return CMsgGameDataAbilities.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGameDataAbilities>): CMsgGameDataAbilities {
    const message = createBaseCMsgGameDataAbilities();
    message.abilities = object.abilities?.map((e) => CMsgGameDataAbilityOrItem.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgGameDataItems(): CMsgGameDataItems {
  return { items: [] };
}

export const CMsgGameDataItems = {
  encode(message: CMsgGameDataItems, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.items) {
      CMsgGameDataAbilityOrItem.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGameDataItems {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGameDataItems();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.items.push(CMsgGameDataAbilityOrItem.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGameDataItems {
    return {
      items: globalThis.Array.isArray(object?.items)
        ? object.items.map((e: any) => CMsgGameDataAbilityOrItem.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgGameDataItems): unknown {
    const obj: any = {};
    if (message.items?.length) {
      obj.items = message.items.map((e) => CMsgGameDataAbilityOrItem.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGameDataItems>): CMsgGameDataItems {
    return CMsgGameDataItems.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGameDataItems>): CMsgGameDataItems {
    const message = createBaseCMsgGameDataItems();
    message.items = object.items?.map((e) => CMsgGameDataAbilityOrItem.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgGameDataHeroes(): CMsgGameDataHeroes {
  return { heroes: [] };
}

export const CMsgGameDataHeroes = {
  encode(message: CMsgGameDataHeroes, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.heroes) {
      CMsgGameDataHero.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGameDataHeroes {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGameDataHeroes();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.heroes.push(CMsgGameDataHero.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGameDataHeroes {
    return {
      heroes: globalThis.Array.isArray(object?.heroes)
        ? object.heroes.map((e: any) => CMsgGameDataHero.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgGameDataHeroes): unknown {
    const obj: any = {};
    if (message.heroes?.length) {
      obj.heroes = message.heroes.map((e) => CMsgGameDataHero.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGameDataHeroes>): CMsgGameDataHeroes {
    return CMsgGameDataHeroes.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGameDataHeroes>): CMsgGameDataHeroes {
    const message = createBaseCMsgGameDataHeroes();
    message.heroes = object.heroes?.map((e) => CMsgGameDataHero.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgGameDataHeroList(): CMsgGameDataHeroList {
  return { heroes: [] };
}

export const CMsgGameDataHeroList = {
  encode(message: CMsgGameDataHeroList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.heroes) {
      CMsgGameDataHeroList_HeroInfo.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGameDataHeroList {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGameDataHeroList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.heroes.push(CMsgGameDataHeroList_HeroInfo.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGameDataHeroList {
    return {
      heroes: globalThis.Array.isArray(object?.heroes)
        ? object.heroes.map((e: any) => CMsgGameDataHeroList_HeroInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgGameDataHeroList): unknown {
    const obj: any = {};
    if (message.heroes?.length) {
      obj.heroes = message.heroes.map((e) => CMsgGameDataHeroList_HeroInfo.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGameDataHeroList>): CMsgGameDataHeroList {
    return CMsgGameDataHeroList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGameDataHeroList>): CMsgGameDataHeroList {
    const message = createBaseCMsgGameDataHeroList();
    message.heroes = object.heroes?.map((e) => CMsgGameDataHeroList_HeroInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgGameDataHeroList_HeroInfo(): CMsgGameDataHeroList_HeroInfo {
  return { id: 0, name: "", nameLoc: "", nameEnglishLoc: "", primaryAttr: 0, complexity: 0 };
}

export const CMsgGameDataHeroList_HeroInfo = {
  encode(message: CMsgGameDataHeroList_HeroInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== undefined && message.id !== 0) {
      writer.uint32(8).int32(message.id);
    }
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.nameLoc !== undefined && message.nameLoc !== "") {
      writer.uint32(26).string(message.nameLoc);
    }
    if (message.nameEnglishLoc !== undefined && message.nameEnglishLoc !== "") {
      writer.uint32(34).string(message.nameEnglishLoc);
    }
    if (message.primaryAttr !== undefined && message.primaryAttr !== 0) {
      writer.uint32(40).uint32(message.primaryAttr);
    }
    if (message.complexity !== undefined && message.complexity !== 0) {
      writer.uint32(48).uint32(message.complexity);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGameDataHeroList_HeroInfo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGameDataHeroList_HeroInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.nameLoc = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.nameEnglishLoc = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.primaryAttr = reader.uint32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.complexity = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGameDataHeroList_HeroInfo {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      nameLoc: isSet(object.nameLoc) ? globalThis.String(object.nameLoc) : "",
      nameEnglishLoc: isSet(object.nameEnglishLoc) ? globalThis.String(object.nameEnglishLoc) : "",
      primaryAttr: isSet(object.primaryAttr) ? globalThis.Number(object.primaryAttr) : 0,
      complexity: isSet(object.complexity) ? globalThis.Number(object.complexity) : 0,
    };
  },

  toJSON(message: CMsgGameDataHeroList_HeroInfo): unknown {
    const obj: any = {};
    if (message.id !== undefined && message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.name !== undefined && message.name !== "") {
      obj.name = message.name;
    }
    if (message.nameLoc !== undefined && message.nameLoc !== "") {
      obj.nameLoc = message.nameLoc;
    }
    if (message.nameEnglishLoc !== undefined && message.nameEnglishLoc !== "") {
      obj.nameEnglishLoc = message.nameEnglishLoc;
    }
    if (message.primaryAttr !== undefined && message.primaryAttr !== 0) {
      obj.primaryAttr = Math.round(message.primaryAttr);
    }
    if (message.complexity !== undefined && message.complexity !== 0) {
      obj.complexity = Math.round(message.complexity);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGameDataHeroList_HeroInfo>): CMsgGameDataHeroList_HeroInfo {
    return CMsgGameDataHeroList_HeroInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGameDataHeroList_HeroInfo>): CMsgGameDataHeroList_HeroInfo {
    const message = createBaseCMsgGameDataHeroList_HeroInfo();
    message.id = object.id ?? 0;
    message.name = object.name ?? "";
    message.nameLoc = object.nameLoc ?? "";
    message.nameEnglishLoc = object.nameEnglishLoc ?? "";
    message.primaryAttr = object.primaryAttr ?? 0;
    message.complexity = object.complexity ?? 0;
    return message;
  },
};

function createBaseCMsgGameDataItemAbilityList(): CMsgGameDataItemAbilityList {
  return { itemabilities: [] };
}

export const CMsgGameDataItemAbilityList = {
  encode(message: CMsgGameDataItemAbilityList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.itemabilities) {
      CMsgGameDataItemAbilityList_ItemAbilityInfo.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGameDataItemAbilityList {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGameDataItemAbilityList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.itemabilities.push(CMsgGameDataItemAbilityList_ItemAbilityInfo.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGameDataItemAbilityList {
    return {
      itemabilities: globalThis.Array.isArray(object?.itemabilities)
        ? object.itemabilities.map((e: any) => CMsgGameDataItemAbilityList_ItemAbilityInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgGameDataItemAbilityList): unknown {
    const obj: any = {};
    if (message.itemabilities?.length) {
      obj.itemabilities = message.itemabilities.map((e) => CMsgGameDataItemAbilityList_ItemAbilityInfo.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGameDataItemAbilityList>): CMsgGameDataItemAbilityList {
    return CMsgGameDataItemAbilityList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGameDataItemAbilityList>): CMsgGameDataItemAbilityList {
    const message = createBaseCMsgGameDataItemAbilityList();
    message.itemabilities =
      object.itemabilities?.map((e) => CMsgGameDataItemAbilityList_ItemAbilityInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgGameDataItemAbilityList_ItemAbilityInfo(): CMsgGameDataItemAbilityList_ItemAbilityInfo {
  return {
    id: -1,
    name: "",
    nameLoc: "",
    nameEnglishLoc: "",
    neutralItemTier: 0,
    isPregameSuggested: false,
    isEarlygameSuggested: false,
    isLategameSuggested: false,
    recipes: [],
  };
}

export const CMsgGameDataItemAbilityList_ItemAbilityInfo = {
  encode(message: CMsgGameDataItemAbilityList_ItemAbilityInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== undefined && message.id !== -1) {
      writer.uint32(8).int32(message.id);
    }
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.nameLoc !== undefined && message.nameLoc !== "") {
      writer.uint32(26).string(message.nameLoc);
    }
    if (message.nameEnglishLoc !== undefined && message.nameEnglishLoc !== "") {
      writer.uint32(34).string(message.nameEnglishLoc);
    }
    if (message.neutralItemTier !== undefined && message.neutralItemTier !== 0) {
      writer.uint32(40).int32(message.neutralItemTier);
    }
    if (message.isPregameSuggested !== undefined && message.isPregameSuggested !== false) {
      writer.uint32(48).bool(message.isPregameSuggested);
    }
    if (message.isEarlygameSuggested !== undefined && message.isEarlygameSuggested !== false) {
      writer.uint32(56).bool(message.isEarlygameSuggested);
    }
    if (message.isLategameSuggested !== undefined && message.isLategameSuggested !== false) {
      writer.uint32(64).bool(message.isLategameSuggested);
    }
    for (const v of message.recipes) {
      CMsgGameDataItemAbilityList_ItemAbilityInfo_Recipe.encode(v!, writer.uint32(74).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGameDataItemAbilityList_ItemAbilityInfo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGameDataItemAbilityList_ItemAbilityInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.nameLoc = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.nameEnglishLoc = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.neutralItemTier = reader.int32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.isPregameSuggested = reader.bool();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.isEarlygameSuggested = reader.bool();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.isLategameSuggested = reader.bool();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.recipes.push(CMsgGameDataItemAbilityList_ItemAbilityInfo_Recipe.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGameDataItemAbilityList_ItemAbilityInfo {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : -1,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      nameLoc: isSet(object.nameLoc) ? globalThis.String(object.nameLoc) : "",
      nameEnglishLoc: isSet(object.nameEnglishLoc) ? globalThis.String(object.nameEnglishLoc) : "",
      neutralItemTier: isSet(object.neutralItemTier) ? globalThis.Number(object.neutralItemTier) : 0,
      isPregameSuggested: isSet(object.isPregameSuggested) ? globalThis.Boolean(object.isPregameSuggested) : false,
      isEarlygameSuggested: isSet(object.isEarlygameSuggested)
        ? globalThis.Boolean(object.isEarlygameSuggested)
        : false,
      isLategameSuggested: isSet(object.isLategameSuggested) ? globalThis.Boolean(object.isLategameSuggested) : false,
      recipes: globalThis.Array.isArray(object?.recipes)
        ? object.recipes.map((e: any) => CMsgGameDataItemAbilityList_ItemAbilityInfo_Recipe.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgGameDataItemAbilityList_ItemAbilityInfo): unknown {
    const obj: any = {};
    if (message.id !== undefined && message.id !== -1) {
      obj.id = Math.round(message.id);
    }
    if (message.name !== undefined && message.name !== "") {
      obj.name = message.name;
    }
    if (message.nameLoc !== undefined && message.nameLoc !== "") {
      obj.nameLoc = message.nameLoc;
    }
    if (message.nameEnglishLoc !== undefined && message.nameEnglishLoc !== "") {
      obj.nameEnglishLoc = message.nameEnglishLoc;
    }
    if (message.neutralItemTier !== undefined && message.neutralItemTier !== 0) {
      obj.neutralItemTier = Math.round(message.neutralItemTier);
    }
    if (message.isPregameSuggested !== undefined && message.isPregameSuggested !== false) {
      obj.isPregameSuggested = message.isPregameSuggested;
    }
    if (message.isEarlygameSuggested !== undefined && message.isEarlygameSuggested !== false) {
      obj.isEarlygameSuggested = message.isEarlygameSuggested;
    }
    if (message.isLategameSuggested !== undefined && message.isLategameSuggested !== false) {
      obj.isLategameSuggested = message.isLategameSuggested;
    }
    if (message.recipes?.length) {
      obj.recipes = message.recipes.map((e) => CMsgGameDataItemAbilityList_ItemAbilityInfo_Recipe.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGameDataItemAbilityList_ItemAbilityInfo>): CMsgGameDataItemAbilityList_ItemAbilityInfo {
    return CMsgGameDataItemAbilityList_ItemAbilityInfo.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgGameDataItemAbilityList_ItemAbilityInfo>,
  ): CMsgGameDataItemAbilityList_ItemAbilityInfo {
    const message = createBaseCMsgGameDataItemAbilityList_ItemAbilityInfo();
    message.id = object.id ?? -1;
    message.name = object.name ?? "";
    message.nameLoc = object.nameLoc ?? "";
    message.nameEnglishLoc = object.nameEnglishLoc ?? "";
    message.neutralItemTier = object.neutralItemTier ?? 0;
    message.isPregameSuggested = object.isPregameSuggested ?? false;
    message.isEarlygameSuggested = object.isEarlygameSuggested ?? false;
    message.isLategameSuggested = object.isLategameSuggested ?? false;
    message.recipes = object.recipes?.map((e) => CMsgGameDataItemAbilityList_ItemAbilityInfo_Recipe.fromPartial(e)) ||
      [];
    return message;
  },
};

function createBaseCMsgGameDataItemAbilityList_ItemAbilityInfo_Recipe(): CMsgGameDataItemAbilityList_ItemAbilityInfo_Recipe {
  return { items: [] };
}

export const CMsgGameDataItemAbilityList_ItemAbilityInfo_Recipe = {
  encode(
    message: CMsgGameDataItemAbilityList_ItemAbilityInfo_Recipe,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.items) {
      writer.int32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGameDataItemAbilityList_ItemAbilityInfo_Recipe {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGameDataItemAbilityList_ItemAbilityInfo_Recipe();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.items.push(reader.int32());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.items.push(reader.int32());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGameDataItemAbilityList_ItemAbilityInfo_Recipe {
    return { items: globalThis.Array.isArray(object?.items) ? object.items.map((e: any) => globalThis.Number(e)) : [] };
  },

  toJSON(message: CMsgGameDataItemAbilityList_ItemAbilityInfo_Recipe): unknown {
    const obj: any = {};
    if (message.items?.length) {
      obj.items = message.items.map((e) => Math.round(e));
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgGameDataItemAbilityList_ItemAbilityInfo_Recipe>,
  ): CMsgGameDataItemAbilityList_ItemAbilityInfo_Recipe {
    return CMsgGameDataItemAbilityList_ItemAbilityInfo_Recipe.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgGameDataItemAbilityList_ItemAbilityInfo_Recipe>,
  ): CMsgGameDataItemAbilityList_ItemAbilityInfo_Recipe {
    const message = createBaseCMsgGameDataItemAbilityList_ItemAbilityInfo_Recipe();
    message.items = object.items?.map((e) => e) || [];
    return message;
  },
};

function createBaseCMsgLobbyAbilityDraftData(): CMsgLobbyAbilityDraftData {
  return { shuffleDraftOrder: false };
}

export const CMsgLobbyAbilityDraftData = {
  encode(message: CMsgLobbyAbilityDraftData, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.shuffleDraftOrder !== undefined && message.shuffleDraftOrder !== false) {
      writer.uint32(8).bool(message.shuffleDraftOrder);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgLobbyAbilityDraftData {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgLobbyAbilityDraftData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.shuffleDraftOrder = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgLobbyAbilityDraftData {
    return {
      shuffleDraftOrder: isSet(object.shuffleDraftOrder) ? globalThis.Boolean(object.shuffleDraftOrder) : false,
    };
  },

  toJSON(message: CMsgLobbyAbilityDraftData): unknown {
    const obj: any = {};
    if (message.shuffleDraftOrder !== undefined && message.shuffleDraftOrder !== false) {
      obj.shuffleDraftOrder = message.shuffleDraftOrder;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgLobbyAbilityDraftData>): CMsgLobbyAbilityDraftData {
    return CMsgLobbyAbilityDraftData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgLobbyAbilityDraftData>): CMsgLobbyAbilityDraftData {
    const message = createBaseCMsgLobbyAbilityDraftData();
    message.shuffleDraftOrder = object.shuffleDraftOrder ?? false;
    return message;
  },
};

function createBaseCSOEconItemDropRateBonus(): CSOEconItemDropRateBonus {
  return {
    accountId: 0,
    expirationDate: 0,
    bonus: 0,
    bonusCount: 0,
    itemId: "0",
    defIndex: 0,
    secondsLeft: 0,
    boosterType: 0,
  };
}

export const CSOEconItemDropRateBonus = {
  encode(message: CSOEconItemDropRateBonus, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.accountId !== undefined && message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    if (message.expirationDate !== undefined && message.expirationDate !== 0) {
      writer.uint32(21).fixed32(message.expirationDate);
    }
    if (message.bonus !== undefined && message.bonus !== 0) {
      writer.uint32(29).float(message.bonus);
    }
    if (message.bonusCount !== undefined && message.bonusCount !== 0) {
      writer.uint32(32).uint32(message.bonusCount);
    }
    if (message.itemId !== undefined && message.itemId !== "0") {
      writer.uint32(40).uint64(message.itemId);
    }
    if (message.defIndex !== undefined && message.defIndex !== 0) {
      writer.uint32(48).uint32(message.defIndex);
    }
    if (message.secondsLeft !== undefined && message.secondsLeft !== 0) {
      writer.uint32(56).uint32(message.secondsLeft);
    }
    if (message.boosterType !== undefined && message.boosterType !== 0) {
      writer.uint32(64).uint32(message.boosterType);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CSOEconItemDropRateBonus {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCSOEconItemDropRateBonus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.expirationDate = reader.fixed32();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.bonus = reader.float();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.bonusCount = reader.uint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.itemId = longToString(reader.uint64() as Long);
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.defIndex = reader.uint32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.secondsLeft = reader.uint32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.boosterType = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CSOEconItemDropRateBonus {
    return {
      accountId: isSet(object.accountId) ? globalThis.Number(object.accountId) : 0,
      expirationDate: isSet(object.expirationDate) ? globalThis.Number(object.expirationDate) : 0,
      bonus: isSet(object.bonus) ? globalThis.Number(object.bonus) : 0,
      bonusCount: isSet(object.bonusCount) ? globalThis.Number(object.bonusCount) : 0,
      itemId: isSet(object.itemId) ? globalThis.String(object.itemId) : "0",
      defIndex: isSet(object.defIndex) ? globalThis.Number(object.defIndex) : 0,
      secondsLeft: isSet(object.secondsLeft) ? globalThis.Number(object.secondsLeft) : 0,
      boosterType: isSet(object.boosterType) ? globalThis.Number(object.boosterType) : 0,
    };
  },

  toJSON(message: CSOEconItemDropRateBonus): unknown {
    const obj: any = {};
    if (message.accountId !== undefined && message.accountId !== 0) {
      obj.accountId = Math.round(message.accountId);
    }
    if (message.expirationDate !== undefined && message.expirationDate !== 0) {
      obj.expirationDate = Math.round(message.expirationDate);
    }
    if (message.bonus !== undefined && message.bonus !== 0) {
      obj.bonus = message.bonus;
    }
    if (message.bonusCount !== undefined && message.bonusCount !== 0) {
      obj.bonusCount = Math.round(message.bonusCount);
    }
    if (message.itemId !== undefined && message.itemId !== "0") {
      obj.itemId = message.itemId;
    }
    if (message.defIndex !== undefined && message.defIndex !== 0) {
      obj.defIndex = Math.round(message.defIndex);
    }
    if (message.secondsLeft !== undefined && message.secondsLeft !== 0) {
      obj.secondsLeft = Math.round(message.secondsLeft);
    }
    if (message.boosterType !== undefined && message.boosterType !== 0) {
      obj.boosterType = Math.round(message.boosterType);
    }
    return obj;
  },

  create(base?: DeepPartial<CSOEconItemDropRateBonus>): CSOEconItemDropRateBonus {
    return CSOEconItemDropRateBonus.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CSOEconItemDropRateBonus>): CSOEconItemDropRateBonus {
    const message = createBaseCSOEconItemDropRateBonus();
    message.accountId = object.accountId ?? 0;
    message.expirationDate = object.expirationDate ?? 0;
    message.bonus = object.bonus ?? 0;
    message.bonusCount = object.bonusCount ?? 0;
    message.itemId = object.itemId ?? "0";
    message.defIndex = object.defIndex ?? 0;
    message.secondsLeft = object.secondsLeft ?? 0;
    message.boosterType = object.boosterType ?? 0;
    return message;
  },
};

function createBaseCSOEconItemTournamentPassport(): CSOEconItemTournamentPassport {
  return {
    accountId: 0,
    leagueId: 0,
    itemId: "0",
    originalPurchaserId: 0,
    passportsBought: 0,
    version: 0,
    defIndex: 0,
    rewardFlags: 0,
  };
}

export const CSOEconItemTournamentPassport = {
  encode(message: CSOEconItemTournamentPassport, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.accountId !== undefined && message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    if (message.leagueId !== undefined && message.leagueId !== 0) {
      writer.uint32(16).uint32(message.leagueId);
    }
    if (message.itemId !== undefined && message.itemId !== "0") {
      writer.uint32(24).uint64(message.itemId);
    }
    if (message.originalPurchaserId !== undefined && message.originalPurchaserId !== 0) {
      writer.uint32(32).uint32(message.originalPurchaserId);
    }
    if (message.passportsBought !== undefined && message.passportsBought !== 0) {
      writer.uint32(40).uint32(message.passportsBought);
    }
    if (message.version !== undefined && message.version !== 0) {
      writer.uint32(48).uint32(message.version);
    }
    if (message.defIndex !== undefined && message.defIndex !== 0) {
      writer.uint32(56).uint32(message.defIndex);
    }
    if (message.rewardFlags !== undefined && message.rewardFlags !== 0) {
      writer.uint32(64).uint32(message.rewardFlags);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CSOEconItemTournamentPassport {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCSOEconItemTournamentPassport();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.leagueId = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.itemId = longToString(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.originalPurchaserId = reader.uint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.passportsBought = reader.uint32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.version = reader.uint32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.defIndex = reader.uint32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.rewardFlags = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CSOEconItemTournamentPassport {
    return {
      accountId: isSet(object.accountId) ? globalThis.Number(object.accountId) : 0,
      leagueId: isSet(object.leagueId) ? globalThis.Number(object.leagueId) : 0,
      itemId: isSet(object.itemId) ? globalThis.String(object.itemId) : "0",
      originalPurchaserId: isSet(object.originalPurchaserId) ? globalThis.Number(object.originalPurchaserId) : 0,
      passportsBought: isSet(object.passportsBought) ? globalThis.Number(object.passportsBought) : 0,
      version: isSet(object.version) ? globalThis.Number(object.version) : 0,
      defIndex: isSet(object.defIndex) ? globalThis.Number(object.defIndex) : 0,
      rewardFlags: isSet(object.rewardFlags) ? globalThis.Number(object.rewardFlags) : 0,
    };
  },

  toJSON(message: CSOEconItemTournamentPassport): unknown {
    const obj: any = {};
    if (message.accountId !== undefined && message.accountId !== 0) {
      obj.accountId = Math.round(message.accountId);
    }
    if (message.leagueId !== undefined && message.leagueId !== 0) {
      obj.leagueId = Math.round(message.leagueId);
    }
    if (message.itemId !== undefined && message.itemId !== "0") {
      obj.itemId = message.itemId;
    }
    if (message.originalPurchaserId !== undefined && message.originalPurchaserId !== 0) {
      obj.originalPurchaserId = Math.round(message.originalPurchaserId);
    }
    if (message.passportsBought !== undefined && message.passportsBought !== 0) {
      obj.passportsBought = Math.round(message.passportsBought);
    }
    if (message.version !== undefined && message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    if (message.defIndex !== undefined && message.defIndex !== 0) {
      obj.defIndex = Math.round(message.defIndex);
    }
    if (message.rewardFlags !== undefined && message.rewardFlags !== 0) {
      obj.rewardFlags = Math.round(message.rewardFlags);
    }
    return obj;
  },

  create(base?: DeepPartial<CSOEconItemTournamentPassport>): CSOEconItemTournamentPassport {
    return CSOEconItemTournamentPassport.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CSOEconItemTournamentPassport>): CSOEconItemTournamentPassport {
    const message = createBaseCSOEconItemTournamentPassport();
    message.accountId = object.accountId ?? 0;
    message.leagueId = object.leagueId ?? 0;
    message.itemId = object.itemId ?? "0";
    message.originalPurchaserId = object.originalPurchaserId ?? 0;
    message.passportsBought = object.passportsBought ?? 0;
    message.version = object.version ?? 0;
    message.defIndex = object.defIndex ?? 0;
    message.rewardFlags = object.rewardFlags ?? 0;
    return message;
  },
};

function createBaseCMsgStickerbookSticker(): CMsgStickerbookSticker {
  return {
    itemDefId: 0,
    stickerNum: 0,
    quality: 0,
    positionX: 0,
    positionY: 0,
    positionZ: 0,
    rotation: 0,
    scale: 0,
    sourceItemId: "0",
    depthBias: 0,
  };
}

export const CMsgStickerbookSticker = {
  encode(message: CMsgStickerbookSticker, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.itemDefId !== undefined && message.itemDefId !== 0) {
      writer.uint32(8).uint32(message.itemDefId);
    }
    if (message.stickerNum !== undefined && message.stickerNum !== 0) {
      writer.uint32(16).uint32(message.stickerNum);
    }
    if (message.quality !== undefined && message.quality !== 0) {
      writer.uint32(24).uint32(message.quality);
    }
    if (message.positionX !== undefined && message.positionX !== 0) {
      writer.uint32(37).float(message.positionX);
    }
    if (message.positionY !== undefined && message.positionY !== 0) {
      writer.uint32(45).float(message.positionY);
    }
    if (message.positionZ !== undefined && message.positionZ !== 0) {
      writer.uint32(69).float(message.positionZ);
    }
    if (message.rotation !== undefined && message.rotation !== 0) {
      writer.uint32(53).float(message.rotation);
    }
    if (message.scale !== undefined && message.scale !== 0) {
      writer.uint32(61).float(message.scale);
    }
    if (message.sourceItemId !== undefined && message.sourceItemId !== "0") {
      writer.uint32(72).uint64(message.sourceItemId);
    }
    if (message.depthBias !== undefined && message.depthBias !== 0) {
      writer.uint32(80).uint32(message.depthBias);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgStickerbookSticker {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgStickerbookSticker();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.itemDefId = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.stickerNum = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.quality = reader.uint32();
          continue;
        case 4:
          if (tag !== 37) {
            break;
          }

          message.positionX = reader.float();
          continue;
        case 5:
          if (tag !== 45) {
            break;
          }

          message.positionY = reader.float();
          continue;
        case 8:
          if (tag !== 69) {
            break;
          }

          message.positionZ = reader.float();
          continue;
        case 6:
          if (tag !== 53) {
            break;
          }

          message.rotation = reader.float();
          continue;
        case 7:
          if (tag !== 61) {
            break;
          }

          message.scale = reader.float();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.sourceItemId = longToString(reader.uint64() as Long);
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.depthBias = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgStickerbookSticker {
    return {
      itemDefId: isSet(object.itemDefId) ? globalThis.Number(object.itemDefId) : 0,
      stickerNum: isSet(object.stickerNum) ? globalThis.Number(object.stickerNum) : 0,
      quality: isSet(object.quality) ? globalThis.Number(object.quality) : 0,
      positionX: isSet(object.positionX) ? globalThis.Number(object.positionX) : 0,
      positionY: isSet(object.positionY) ? globalThis.Number(object.positionY) : 0,
      positionZ: isSet(object.positionZ) ? globalThis.Number(object.positionZ) : 0,
      rotation: isSet(object.rotation) ? globalThis.Number(object.rotation) : 0,
      scale: isSet(object.scale) ? globalThis.Number(object.scale) : 0,
      sourceItemId: isSet(object.sourceItemId) ? globalThis.String(object.sourceItemId) : "0",
      depthBias: isSet(object.depthBias) ? globalThis.Number(object.depthBias) : 0,
    };
  },

  toJSON(message: CMsgStickerbookSticker): unknown {
    const obj: any = {};
    if (message.itemDefId !== undefined && message.itemDefId !== 0) {
      obj.itemDefId = Math.round(message.itemDefId);
    }
    if (message.stickerNum !== undefined && message.stickerNum !== 0) {
      obj.stickerNum = Math.round(message.stickerNum);
    }
    if (message.quality !== undefined && message.quality !== 0) {
      obj.quality = Math.round(message.quality);
    }
    if (message.positionX !== undefined && message.positionX !== 0) {
      obj.positionX = message.positionX;
    }
    if (message.positionY !== undefined && message.positionY !== 0) {
      obj.positionY = message.positionY;
    }
    if (message.positionZ !== undefined && message.positionZ !== 0) {
      obj.positionZ = message.positionZ;
    }
    if (message.rotation !== undefined && message.rotation !== 0) {
      obj.rotation = message.rotation;
    }
    if (message.scale !== undefined && message.scale !== 0) {
      obj.scale = message.scale;
    }
    if (message.sourceItemId !== undefined && message.sourceItemId !== "0") {
      obj.sourceItemId = message.sourceItemId;
    }
    if (message.depthBias !== undefined && message.depthBias !== 0) {
      obj.depthBias = Math.round(message.depthBias);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgStickerbookSticker>): CMsgStickerbookSticker {
    return CMsgStickerbookSticker.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgStickerbookSticker>): CMsgStickerbookSticker {
    const message = createBaseCMsgStickerbookSticker();
    message.itemDefId = object.itemDefId ?? 0;
    message.stickerNum = object.stickerNum ?? 0;
    message.quality = object.quality ?? 0;
    message.positionX = object.positionX ?? 0;
    message.positionY = object.positionY ?? 0;
    message.positionZ = object.positionZ ?? 0;
    message.rotation = object.rotation ?? 0;
    message.scale = object.scale ?? 0;
    message.sourceItemId = object.sourceItemId ?? "0";
    message.depthBias = object.depthBias ?? 0;
    return message;
  },
};

function createBaseCMsgStickerbookPage(): CMsgStickerbookPage {
  return { pageNum: 0, eventId: 0, teamId: 0, stickers: [], pageType: 0 };
}

export const CMsgStickerbookPage = {
  encode(message: CMsgStickerbookPage, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.pageNum !== undefined && message.pageNum !== 0) {
      writer.uint32(8).uint32(message.pageNum);
    }
    if (message.eventId !== undefined && message.eventId !== 0) {
      writer.uint32(16).int32(message.eventId);
    }
    if (message.teamId !== undefined && message.teamId !== 0) {
      writer.uint32(24).uint32(message.teamId);
    }
    for (const v of message.stickers) {
      CMsgStickerbookSticker.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    if (message.pageType !== undefined && message.pageType !== 0) {
      writer.uint32(40).int32(message.pageType);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgStickerbookPage {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgStickerbookPage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.pageNum = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.eventId = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.teamId = reader.uint32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.stickers.push(CMsgStickerbookSticker.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.pageType = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgStickerbookPage {
    return {
      pageNum: isSet(object.pageNum) ? globalThis.Number(object.pageNum) : 0,
      eventId: isSet(object.eventId) ? eEventFromJSON(object.eventId) : 0,
      teamId: isSet(object.teamId) ? globalThis.Number(object.teamId) : 0,
      stickers: globalThis.Array.isArray(object?.stickers)
        ? object.stickers.map((e: any) => CMsgStickerbookSticker.fromJSON(e))
        : [],
      pageType: isSet(object.pageType) ? eStickerbookPageTypeFromJSON(object.pageType) : 0,
    };
  },

  toJSON(message: CMsgStickerbookPage): unknown {
    const obj: any = {};
    if (message.pageNum !== undefined && message.pageNum !== 0) {
      obj.pageNum = Math.round(message.pageNum);
    }
    if (message.eventId !== undefined && message.eventId !== 0) {
      obj.eventId = eEventToJSON(message.eventId);
    }
    if (message.teamId !== undefined && message.teamId !== 0) {
      obj.teamId = Math.round(message.teamId);
    }
    if (message.stickers?.length) {
      obj.stickers = message.stickers.map((e) => CMsgStickerbookSticker.toJSON(e));
    }
    if (message.pageType !== undefined && message.pageType !== 0) {
      obj.pageType = eStickerbookPageTypeToJSON(message.pageType);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgStickerbookPage>): CMsgStickerbookPage {
    return CMsgStickerbookPage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgStickerbookPage>): CMsgStickerbookPage {
    const message = createBaseCMsgStickerbookPage();
    message.pageNum = object.pageNum ?? 0;
    message.eventId = object.eventId ?? 0;
    message.teamId = object.teamId ?? 0;
    message.stickers = object.stickers?.map((e) => CMsgStickerbookSticker.fromPartial(e)) || [];
    message.pageType = object.pageType ?? 0;
    return message;
  },
};

function createBaseCMsgStickerbookTeamPageOrderSequence(): CMsgStickerbookTeamPageOrderSequence {
  return { pageNumbers: [] };
}

export const CMsgStickerbookTeamPageOrderSequence = {
  encode(message: CMsgStickerbookTeamPageOrderSequence, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.pageNumbers) {
      writer.uint32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgStickerbookTeamPageOrderSequence {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgStickerbookTeamPageOrderSequence();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.pageNumbers.push(reader.uint32());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.pageNumbers.push(reader.uint32());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgStickerbookTeamPageOrderSequence {
    return {
      pageNumbers: globalThis.Array.isArray(object?.pageNumbers)
        ? object.pageNumbers.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: CMsgStickerbookTeamPageOrderSequence): unknown {
    const obj: any = {};
    if (message.pageNumbers?.length) {
      obj.pageNumbers = message.pageNumbers.map((e) => Math.round(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgStickerbookTeamPageOrderSequence>): CMsgStickerbookTeamPageOrderSequence {
    return CMsgStickerbookTeamPageOrderSequence.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgStickerbookTeamPageOrderSequence>): CMsgStickerbookTeamPageOrderSequence {
    const message = createBaseCMsgStickerbookTeamPageOrderSequence();
    message.pageNumbers = object.pageNumbers?.map((e) => e) || [];
    return message;
  },
};

function createBaseCMsgStickerbook(): CMsgStickerbook {
  return { pages: [], teamPageOrderSequence: undefined, favoritePageNum: 0 };
}

export const CMsgStickerbook = {
  encode(message: CMsgStickerbook, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.pages) {
      CMsgStickerbookPage.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.teamPageOrderSequence !== undefined) {
      CMsgStickerbookTeamPageOrderSequence.encode(message.teamPageOrderSequence, writer.uint32(18).fork()).ldelim();
    }
    if (message.favoritePageNum !== undefined && message.favoritePageNum !== 0) {
      writer.uint32(24).uint32(message.favoritePageNum);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgStickerbook {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgStickerbook();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.pages.push(CMsgStickerbookPage.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.teamPageOrderSequence = CMsgStickerbookTeamPageOrderSequence.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.favoritePageNum = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgStickerbook {
    return {
      pages: globalThis.Array.isArray(object?.pages)
        ? object.pages.map((e: any) => CMsgStickerbookPage.fromJSON(e))
        : [],
      teamPageOrderSequence: isSet(object.teamPageOrderSequence)
        ? CMsgStickerbookTeamPageOrderSequence.fromJSON(object.teamPageOrderSequence)
        : undefined,
      favoritePageNum: isSet(object.favoritePageNum) ? globalThis.Number(object.favoritePageNum) : 0,
    };
  },

  toJSON(message: CMsgStickerbook): unknown {
    const obj: any = {};
    if (message.pages?.length) {
      obj.pages = message.pages.map((e) => CMsgStickerbookPage.toJSON(e));
    }
    if (message.teamPageOrderSequence !== undefined) {
      obj.teamPageOrderSequence = CMsgStickerbookTeamPageOrderSequence.toJSON(message.teamPageOrderSequence);
    }
    if (message.favoritePageNum !== undefined && message.favoritePageNum !== 0) {
      obj.favoritePageNum = Math.round(message.favoritePageNum);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgStickerbook>): CMsgStickerbook {
    return CMsgStickerbook.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgStickerbook>): CMsgStickerbook {
    const message = createBaseCMsgStickerbook();
    message.pages = object.pages?.map((e) => CMsgStickerbookPage.fromPartial(e)) || [];
    message.teamPageOrderSequence =
      (object.teamPageOrderSequence !== undefined && object.teamPageOrderSequence !== null)
        ? CMsgStickerbookTeamPageOrderSequence.fromPartial(object.teamPageOrderSequence)
        : undefined;
    message.favoritePageNum = object.favoritePageNum ?? 0;
    return message;
  },
};

function createBaseCMsgStickerHero(): CMsgStickerHero {
  return { heroId: 0, itemDefId: 0, quality: 0, sourceItemId: "0" };
}

export const CMsgStickerHero = {
  encode(message: CMsgStickerHero, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.heroId !== undefined && message.heroId !== 0) {
      writer.uint32(8).int32(message.heroId);
    }
    if (message.itemDefId !== undefined && message.itemDefId !== 0) {
      writer.uint32(16).uint32(message.itemDefId);
    }
    if (message.quality !== undefined && message.quality !== 0) {
      writer.uint32(24).uint32(message.quality);
    }
    if (message.sourceItemId !== undefined && message.sourceItemId !== "0") {
      writer.uint32(32).uint64(message.sourceItemId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgStickerHero {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgStickerHero();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.heroId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.itemDefId = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.quality = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.sourceItemId = longToString(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgStickerHero {
    return {
      heroId: isSet(object.heroId) ? globalThis.Number(object.heroId) : 0,
      itemDefId: isSet(object.itemDefId) ? globalThis.Number(object.itemDefId) : 0,
      quality: isSet(object.quality) ? globalThis.Number(object.quality) : 0,
      sourceItemId: isSet(object.sourceItemId) ? globalThis.String(object.sourceItemId) : "0",
    };
  },

  toJSON(message: CMsgStickerHero): unknown {
    const obj: any = {};
    if (message.heroId !== undefined && message.heroId !== 0) {
      obj.heroId = Math.round(message.heroId);
    }
    if (message.itemDefId !== undefined && message.itemDefId !== 0) {
      obj.itemDefId = Math.round(message.itemDefId);
    }
    if (message.quality !== undefined && message.quality !== 0) {
      obj.quality = Math.round(message.quality);
    }
    if (message.sourceItemId !== undefined && message.sourceItemId !== "0") {
      obj.sourceItemId = message.sourceItemId;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgStickerHero>): CMsgStickerHero {
    return CMsgStickerHero.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgStickerHero>): CMsgStickerHero {
    const message = createBaseCMsgStickerHero();
    message.heroId = object.heroId ?? 0;
    message.itemDefId = object.itemDefId ?? 0;
    message.quality = object.quality ?? 0;
    message.sourceItemId = object.sourceItemId ?? "0";
    return message;
  },
};

function createBaseCMsgStickerHeroes(): CMsgStickerHeroes {
  return { heroes: [] };
}

export const CMsgStickerHeroes = {
  encode(message: CMsgStickerHeroes, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.heroes) {
      CMsgStickerHero.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgStickerHeroes {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgStickerHeroes();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.heroes.push(CMsgStickerHero.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgStickerHeroes {
    return {
      heroes: globalThis.Array.isArray(object?.heroes)
        ? object.heroes.map((e: any) => CMsgStickerHero.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgStickerHeroes): unknown {
    const obj: any = {};
    if (message.heroes?.length) {
      obj.heroes = message.heroes.map((e) => CMsgStickerHero.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgStickerHeroes>): CMsgStickerHeroes {
    return CMsgStickerHeroes.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgStickerHeroes>): CMsgStickerHeroes {
    const message = createBaseCMsgStickerHeroes();
    message.heroes = object.heroes?.map((e) => CMsgStickerHero.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgHeroRoleStats(): CMsgHeroRoleStats {
  return { laneSelectionFlags: 0, matchCount: 0, winCount: 0 };
}

export const CMsgHeroRoleStats = {
  encode(message: CMsgHeroRoleStats, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.laneSelectionFlags !== undefined && message.laneSelectionFlags !== 0) {
      writer.uint32(8).uint32(message.laneSelectionFlags);
    }
    if (message.matchCount !== undefined && message.matchCount !== 0) {
      writer.uint32(16).uint32(message.matchCount);
    }
    if (message.winCount !== undefined && message.winCount !== 0) {
      writer.uint32(24).uint32(message.winCount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgHeroRoleStats {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgHeroRoleStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.laneSelectionFlags = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.matchCount = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.winCount = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgHeroRoleStats {
    return {
      laneSelectionFlags: isSet(object.laneSelectionFlags) ? globalThis.Number(object.laneSelectionFlags) : 0,
      matchCount: isSet(object.matchCount) ? globalThis.Number(object.matchCount) : 0,
      winCount: isSet(object.winCount) ? globalThis.Number(object.winCount) : 0,
    };
  },

  toJSON(message: CMsgHeroRoleStats): unknown {
    const obj: any = {};
    if (message.laneSelectionFlags !== undefined && message.laneSelectionFlags !== 0) {
      obj.laneSelectionFlags = Math.round(message.laneSelectionFlags);
    }
    if (message.matchCount !== undefined && message.matchCount !== 0) {
      obj.matchCount = Math.round(message.matchCount);
    }
    if (message.winCount !== undefined && message.winCount !== 0) {
      obj.winCount = Math.round(message.winCount);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgHeroRoleStats>): CMsgHeroRoleStats {
    return CMsgHeroRoleStats.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgHeroRoleStats>): CMsgHeroRoleStats {
    const message = createBaseCMsgHeroRoleStats();
    message.laneSelectionFlags = object.laneSelectionFlags ?? 0;
    message.matchCount = object.matchCount ?? 0;
    message.winCount = object.winCount ?? 0;
    return message;
  },
};

function createBaseCMsgHeroRoleHeroStats(): CMsgHeroRoleHeroStats {
  return { heroId: 0, roleStats: [] };
}

export const CMsgHeroRoleHeroStats = {
  encode(message: CMsgHeroRoleHeroStats, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.heroId !== undefined && message.heroId !== 0) {
      writer.uint32(8).int32(message.heroId);
    }
    for (const v of message.roleStats) {
      CMsgHeroRoleStats.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgHeroRoleHeroStats {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgHeroRoleHeroStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.heroId = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.roleStats.push(CMsgHeroRoleStats.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgHeroRoleHeroStats {
    return {
      heroId: isSet(object.heroId) ? globalThis.Number(object.heroId) : 0,
      roleStats: globalThis.Array.isArray(object?.roleStats)
        ? object.roleStats.map((e: any) => CMsgHeroRoleStats.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgHeroRoleHeroStats): unknown {
    const obj: any = {};
    if (message.heroId !== undefined && message.heroId !== 0) {
      obj.heroId = Math.round(message.heroId);
    }
    if (message.roleStats?.length) {
      obj.roleStats = message.roleStats.map((e) => CMsgHeroRoleStats.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgHeroRoleHeroStats>): CMsgHeroRoleHeroStats {
    return CMsgHeroRoleHeroStats.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgHeroRoleHeroStats>): CMsgHeroRoleHeroStats {
    const message = createBaseCMsgHeroRoleHeroStats();
    message.heroId = object.heroId ?? 0;
    message.roleStats = object.roleStats?.map((e) => CMsgHeroRoleStats.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgHeroRoleRankStats(): CMsgHeroRoleRankStats {
  return { rankTier: 0, heroStats: [] };
}

export const CMsgHeroRoleRankStats = {
  encode(message: CMsgHeroRoleRankStats, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.rankTier !== undefined && message.rankTier !== 0) {
      writer.uint32(8).uint32(message.rankTier);
    }
    for (const v of message.heroStats) {
      CMsgHeroRoleHeroStats.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgHeroRoleRankStats {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgHeroRoleRankStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.rankTier = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.heroStats.push(CMsgHeroRoleHeroStats.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgHeroRoleRankStats {
    return {
      rankTier: isSet(object.rankTier) ? globalThis.Number(object.rankTier) : 0,
      heroStats: globalThis.Array.isArray(object?.heroStats)
        ? object.heroStats.map((e: any) => CMsgHeroRoleHeroStats.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgHeroRoleRankStats): unknown {
    const obj: any = {};
    if (message.rankTier !== undefined && message.rankTier !== 0) {
      obj.rankTier = Math.round(message.rankTier);
    }
    if (message.heroStats?.length) {
      obj.heroStats = message.heroStats.map((e) => CMsgHeroRoleHeroStats.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgHeroRoleRankStats>): CMsgHeroRoleRankStats {
    return CMsgHeroRoleRankStats.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgHeroRoleRankStats>): CMsgHeroRoleRankStats {
    const message = createBaseCMsgHeroRoleRankStats();
    message.rankTier = object.rankTier ?? 0;
    message.heroStats = object.heroStats?.map((e) => CMsgHeroRoleHeroStats.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgHeroRoleAllRanksStats(): CMsgHeroRoleAllRanksStats {
  return { startTimestamp: 0, endTimestamp: 0, rankStats: [] };
}

export const CMsgHeroRoleAllRanksStats = {
  encode(message: CMsgHeroRoleAllRanksStats, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.startTimestamp !== undefined && message.startTimestamp !== 0) {
      writer.uint32(8).uint32(message.startTimestamp);
    }
    if (message.endTimestamp !== undefined && message.endTimestamp !== 0) {
      writer.uint32(16).uint32(message.endTimestamp);
    }
    for (const v of message.rankStats) {
      CMsgHeroRoleRankStats.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgHeroRoleAllRanksStats {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgHeroRoleAllRanksStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.startTimestamp = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.endTimestamp = reader.uint32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.rankStats.push(CMsgHeroRoleRankStats.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgHeroRoleAllRanksStats {
    return {
      startTimestamp: isSet(object.startTimestamp) ? globalThis.Number(object.startTimestamp) : 0,
      endTimestamp: isSet(object.endTimestamp) ? globalThis.Number(object.endTimestamp) : 0,
      rankStats: globalThis.Array.isArray(object?.rankStats)
        ? object.rankStats.map((e: any) => CMsgHeroRoleRankStats.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgHeroRoleAllRanksStats): unknown {
    const obj: any = {};
    if (message.startTimestamp !== undefined && message.startTimestamp !== 0) {
      obj.startTimestamp = Math.round(message.startTimestamp);
    }
    if (message.endTimestamp !== undefined && message.endTimestamp !== 0) {
      obj.endTimestamp = Math.round(message.endTimestamp);
    }
    if (message.rankStats?.length) {
      obj.rankStats = message.rankStats.map((e) => CMsgHeroRoleRankStats.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgHeroRoleAllRanksStats>): CMsgHeroRoleAllRanksStats {
    return CMsgHeroRoleAllRanksStats.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgHeroRoleAllRanksStats>): CMsgHeroRoleAllRanksStats {
    const message = createBaseCMsgHeroRoleAllRanksStats();
    message.startTimestamp = object.startTimestamp ?? 0;
    message.endTimestamp = object.endTimestamp ?? 0;
    message.rankStats = object.rankStats?.map((e) => CMsgHeroRoleRankStats.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgMapStatsSnapshot(): CMsgMapStatsSnapshot {
  return {
    timestamp: 0,
    lotusesGained: "0",
    wisdomRunesGained: "0",
    roshanKillsDay: "0",
    roshanKillsNight: "0",
    portalsUsed: "0",
    watchersTaken: "0",
    tormentorKills: "0",
    outpostsCaptured: "0",
    shieldRunesGained: "0",
  };
}

export const CMsgMapStatsSnapshot = {
  encode(message: CMsgMapStatsSnapshot, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.timestamp !== undefined && message.timestamp !== 0) {
      writer.uint32(8).uint32(message.timestamp);
    }
    if (message.lotusesGained !== undefined && message.lotusesGained !== "0") {
      writer.uint32(16).uint64(message.lotusesGained);
    }
    if (message.wisdomRunesGained !== undefined && message.wisdomRunesGained !== "0") {
      writer.uint32(24).uint64(message.wisdomRunesGained);
    }
    if (message.roshanKillsDay !== undefined && message.roshanKillsDay !== "0") {
      writer.uint32(32).uint64(message.roshanKillsDay);
    }
    if (message.roshanKillsNight !== undefined && message.roshanKillsNight !== "0") {
      writer.uint32(40).uint64(message.roshanKillsNight);
    }
    if (message.portalsUsed !== undefined && message.portalsUsed !== "0") {
      writer.uint32(48).uint64(message.portalsUsed);
    }
    if (message.watchersTaken !== undefined && message.watchersTaken !== "0") {
      writer.uint32(56).uint64(message.watchersTaken);
    }
    if (message.tormentorKills !== undefined && message.tormentorKills !== "0") {
      writer.uint32(64).uint64(message.tormentorKills);
    }
    if (message.outpostsCaptured !== undefined && message.outpostsCaptured !== "0") {
      writer.uint32(72).uint64(message.outpostsCaptured);
    }
    if (message.shieldRunesGained !== undefined && message.shieldRunesGained !== "0") {
      writer.uint32(80).uint64(message.shieldRunesGained);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgMapStatsSnapshot {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgMapStatsSnapshot();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.timestamp = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.lotusesGained = longToString(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.wisdomRunesGained = longToString(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.roshanKillsDay = longToString(reader.uint64() as Long);
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.roshanKillsNight = longToString(reader.uint64() as Long);
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.portalsUsed = longToString(reader.uint64() as Long);
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.watchersTaken = longToString(reader.uint64() as Long);
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.tormentorKills = longToString(reader.uint64() as Long);
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.outpostsCaptured = longToString(reader.uint64() as Long);
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.shieldRunesGained = longToString(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgMapStatsSnapshot {
    return {
      timestamp: isSet(object.timestamp) ? globalThis.Number(object.timestamp) : 0,
      lotusesGained: isSet(object.lotusesGained) ? globalThis.String(object.lotusesGained) : "0",
      wisdomRunesGained: isSet(object.wisdomRunesGained) ? globalThis.String(object.wisdomRunesGained) : "0",
      roshanKillsDay: isSet(object.roshanKillsDay) ? globalThis.String(object.roshanKillsDay) : "0",
      roshanKillsNight: isSet(object.roshanKillsNight) ? globalThis.String(object.roshanKillsNight) : "0",
      portalsUsed: isSet(object.portalsUsed) ? globalThis.String(object.portalsUsed) : "0",
      watchersTaken: isSet(object.watchersTaken) ? globalThis.String(object.watchersTaken) : "0",
      tormentorKills: isSet(object.tormentorKills) ? globalThis.String(object.tormentorKills) : "0",
      outpostsCaptured: isSet(object.outpostsCaptured) ? globalThis.String(object.outpostsCaptured) : "0",
      shieldRunesGained: isSet(object.shieldRunesGained) ? globalThis.String(object.shieldRunesGained) : "0",
    };
  },

  toJSON(message: CMsgMapStatsSnapshot): unknown {
    const obj: any = {};
    if (message.timestamp !== undefined && message.timestamp !== 0) {
      obj.timestamp = Math.round(message.timestamp);
    }
    if (message.lotusesGained !== undefined && message.lotusesGained !== "0") {
      obj.lotusesGained = message.lotusesGained;
    }
    if (message.wisdomRunesGained !== undefined && message.wisdomRunesGained !== "0") {
      obj.wisdomRunesGained = message.wisdomRunesGained;
    }
    if (message.roshanKillsDay !== undefined && message.roshanKillsDay !== "0") {
      obj.roshanKillsDay = message.roshanKillsDay;
    }
    if (message.roshanKillsNight !== undefined && message.roshanKillsNight !== "0") {
      obj.roshanKillsNight = message.roshanKillsNight;
    }
    if (message.portalsUsed !== undefined && message.portalsUsed !== "0") {
      obj.portalsUsed = message.portalsUsed;
    }
    if (message.watchersTaken !== undefined && message.watchersTaken !== "0") {
      obj.watchersTaken = message.watchersTaken;
    }
    if (message.tormentorKills !== undefined && message.tormentorKills !== "0") {
      obj.tormentorKills = message.tormentorKills;
    }
    if (message.outpostsCaptured !== undefined && message.outpostsCaptured !== "0") {
      obj.outpostsCaptured = message.outpostsCaptured;
    }
    if (message.shieldRunesGained !== undefined && message.shieldRunesGained !== "0") {
      obj.shieldRunesGained = message.shieldRunesGained;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgMapStatsSnapshot>): CMsgMapStatsSnapshot {
    return CMsgMapStatsSnapshot.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgMapStatsSnapshot>): CMsgMapStatsSnapshot {
    const message = createBaseCMsgMapStatsSnapshot();
    message.timestamp = object.timestamp ?? 0;
    message.lotusesGained = object.lotusesGained ?? "0";
    message.wisdomRunesGained = object.wisdomRunesGained ?? "0";
    message.roshanKillsDay = object.roshanKillsDay ?? "0";
    message.roshanKillsNight = object.roshanKillsNight ?? "0";
    message.portalsUsed = object.portalsUsed ?? "0";
    message.watchersTaken = object.watchersTaken ?? "0";
    message.tormentorKills = object.tormentorKills ?? "0";
    message.outpostsCaptured = object.outpostsCaptured ?? "0";
    message.shieldRunesGained = object.shieldRunesGained ?? "0";
    return message;
  },
};

function createBaseCMsgGlobalMapStats(): CMsgGlobalMapStats {
  return { current: undefined, windowStart: undefined, windowEnd: undefined };
}

export const CMsgGlobalMapStats = {
  encode(message: CMsgGlobalMapStats, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.current !== undefined) {
      CMsgMapStatsSnapshot.encode(message.current, writer.uint32(10).fork()).ldelim();
    }
    if (message.windowStart !== undefined) {
      CMsgMapStatsSnapshot.encode(message.windowStart, writer.uint32(18).fork()).ldelim();
    }
    if (message.windowEnd !== undefined) {
      CMsgMapStatsSnapshot.encode(message.windowEnd, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGlobalMapStats {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGlobalMapStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.current = CMsgMapStatsSnapshot.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.windowStart = CMsgMapStatsSnapshot.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.windowEnd = CMsgMapStatsSnapshot.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGlobalMapStats {
    return {
      current: isSet(object.current) ? CMsgMapStatsSnapshot.fromJSON(object.current) : undefined,
      windowStart: isSet(object.windowStart) ? CMsgMapStatsSnapshot.fromJSON(object.windowStart) : undefined,
      windowEnd: isSet(object.windowEnd) ? CMsgMapStatsSnapshot.fromJSON(object.windowEnd) : undefined,
    };
  },

  toJSON(message: CMsgGlobalMapStats): unknown {
    const obj: any = {};
    if (message.current !== undefined) {
      obj.current = CMsgMapStatsSnapshot.toJSON(message.current);
    }
    if (message.windowStart !== undefined) {
      obj.windowStart = CMsgMapStatsSnapshot.toJSON(message.windowStart);
    }
    if (message.windowEnd !== undefined) {
      obj.windowEnd = CMsgMapStatsSnapshot.toJSON(message.windowEnd);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGlobalMapStats>): CMsgGlobalMapStats {
    return CMsgGlobalMapStats.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGlobalMapStats>): CMsgGlobalMapStats {
    const message = createBaseCMsgGlobalMapStats();
    message.current = (object.current !== undefined && object.current !== null)
      ? CMsgMapStatsSnapshot.fromPartial(object.current)
      : undefined;
    message.windowStart = (object.windowStart !== undefined && object.windowStart !== null)
      ? CMsgMapStatsSnapshot.fromPartial(object.windowStart)
      : undefined;
    message.windowEnd = (object.windowEnd !== undefined && object.windowEnd !== null)
      ? CMsgMapStatsSnapshot.fromPartial(object.windowEnd)
      : undefined;
    return message;
  },
};

function createBaseCMsgTrackedStat(): CMsgTrackedStat {
  return { trackedStatId: 0, trackedStatValue: 0 };
}

export const CMsgTrackedStat = {
  encode(message: CMsgTrackedStat, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.trackedStatId !== undefined && message.trackedStatId !== 0) {
      writer.uint32(8).uint32(message.trackedStatId);
    }
    if (message.trackedStatValue !== undefined && message.trackedStatValue !== 0) {
      writer.uint32(16).int32(message.trackedStatValue);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgTrackedStat {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgTrackedStat();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.trackedStatId = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.trackedStatValue = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgTrackedStat {
    return {
      trackedStatId: isSet(object.trackedStatId) ? globalThis.Number(object.trackedStatId) : 0,
      trackedStatValue: isSet(object.trackedStatValue) ? globalThis.Number(object.trackedStatValue) : 0,
    };
  },

  toJSON(message: CMsgTrackedStat): unknown {
    const obj: any = {};
    if (message.trackedStatId !== undefined && message.trackedStatId !== 0) {
      obj.trackedStatId = Math.round(message.trackedStatId);
    }
    if (message.trackedStatValue !== undefined && message.trackedStatValue !== 0) {
      obj.trackedStatValue = Math.round(message.trackedStatValue);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgTrackedStat>): CMsgTrackedStat {
    return CMsgTrackedStat.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgTrackedStat>): CMsgTrackedStat {
    const message = createBaseCMsgTrackedStat();
    message.trackedStatId = object.trackedStatId ?? 0;
    message.trackedStatValue = object.trackedStatValue ?? 0;
    return message;
  },
};

function createBaseCMsgDOTAClaimEventActionResponse(): CMsgDOTAClaimEventActionResponse {
  return { result: 0, rewardResults: [], actionId: 0 };
}

export const CMsgDOTAClaimEventActionResponse = {
  encode(message: CMsgDOTAClaimEventActionResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result !== undefined && message.result !== 0) {
      writer.uint32(8).int32(message.result);
    }
    for (const v of message.rewardResults) {
      CMsgDOTAClaimEventActionResponse_GrantedRewardData.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.actionId !== undefined && message.actionId !== 0) {
      writer.uint32(24).uint32(message.actionId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTAClaimEventActionResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAClaimEventActionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.result = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.rewardResults.push(
            CMsgDOTAClaimEventActionResponse_GrantedRewardData.decode(reader, reader.uint32()),
          );
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.actionId = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAClaimEventActionResponse {
    return {
      result: isSet(object.result) ? cMsgDOTAClaimEventActionResponse_ResultCodeFromJSON(object.result) : 0,
      rewardResults: globalThis.Array.isArray(object?.rewardResults)
        ? object.rewardResults.map((e: any) => CMsgDOTAClaimEventActionResponse_GrantedRewardData.fromJSON(e))
        : [],
      actionId: isSet(object.actionId) ? globalThis.Number(object.actionId) : 0,
    };
  },

  toJSON(message: CMsgDOTAClaimEventActionResponse): unknown {
    const obj: any = {};
    if (message.result !== undefined && message.result !== 0) {
      obj.result = cMsgDOTAClaimEventActionResponse_ResultCodeToJSON(message.result);
    }
    if (message.rewardResults?.length) {
      obj.rewardResults = message.rewardResults.map((e) =>
        CMsgDOTAClaimEventActionResponse_GrantedRewardData.toJSON(e)
      );
    }
    if (message.actionId !== undefined && message.actionId !== 0) {
      obj.actionId = Math.round(message.actionId);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTAClaimEventActionResponse>): CMsgDOTAClaimEventActionResponse {
    return CMsgDOTAClaimEventActionResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTAClaimEventActionResponse>): CMsgDOTAClaimEventActionResponse {
    const message = createBaseCMsgDOTAClaimEventActionResponse();
    message.result = object.result ?? 0;
    message.rewardResults =
      object.rewardResults?.map((e) => CMsgDOTAClaimEventActionResponse_GrantedRewardData.fromPartial(e)) || [];
    message.actionId = object.actionId ?? 0;
    return message;
  },
};

function createBaseCMsgDOTAClaimEventActionResponse_MysteryItemRewardData(): CMsgDOTAClaimEventActionResponse_MysteryItemRewardData {
  return { itemDef: 0, itemCategory: 0 };
}

export const CMsgDOTAClaimEventActionResponse_MysteryItemRewardData = {
  encode(
    message: CMsgDOTAClaimEventActionResponse_MysteryItemRewardData,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.itemDef !== undefined && message.itemDef !== 0) {
      writer.uint32(8).uint32(message.itemDef);
    }
    if (message.itemCategory !== undefined && message.itemCategory !== 0) {
      writer.uint32(16).uint32(message.itemCategory);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTAClaimEventActionResponse_MysteryItemRewardData {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAClaimEventActionResponse_MysteryItemRewardData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.itemDef = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.itemCategory = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAClaimEventActionResponse_MysteryItemRewardData {
    return {
      itemDef: isSet(object.itemDef) ? globalThis.Number(object.itemDef) : 0,
      itemCategory: isSet(object.itemCategory) ? globalThis.Number(object.itemCategory) : 0,
    };
  },

  toJSON(message: CMsgDOTAClaimEventActionResponse_MysteryItemRewardData): unknown {
    const obj: any = {};
    if (message.itemDef !== undefined && message.itemDef !== 0) {
      obj.itemDef = Math.round(message.itemDef);
    }
    if (message.itemCategory !== undefined && message.itemCategory !== 0) {
      obj.itemCategory = Math.round(message.itemCategory);
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgDOTAClaimEventActionResponse_MysteryItemRewardData>,
  ): CMsgDOTAClaimEventActionResponse_MysteryItemRewardData {
    return CMsgDOTAClaimEventActionResponse_MysteryItemRewardData.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgDOTAClaimEventActionResponse_MysteryItemRewardData>,
  ): CMsgDOTAClaimEventActionResponse_MysteryItemRewardData {
    const message = createBaseCMsgDOTAClaimEventActionResponse_MysteryItemRewardData();
    message.itemDef = object.itemDef ?? 0;
    message.itemCategory = object.itemCategory ?? 0;
    return message;
  },
};

function createBaseCMsgDOTAClaimEventActionResponse_LootListRewardData(): CMsgDOTAClaimEventActionResponse_LootListRewardData {
  return { itemDef: [] };
}

export const CMsgDOTAClaimEventActionResponse_LootListRewardData = {
  encode(
    message: CMsgDOTAClaimEventActionResponse_LootListRewardData,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.itemDef) {
      writer.uint32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTAClaimEventActionResponse_LootListRewardData {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAClaimEventActionResponse_LootListRewardData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.itemDef.push(reader.uint32());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.itemDef.push(reader.uint32());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAClaimEventActionResponse_LootListRewardData {
    return {
      itemDef: globalThis.Array.isArray(object?.itemDef) ? object.itemDef.map((e: any) => globalThis.Number(e)) : [],
    };
  },

  toJSON(message: CMsgDOTAClaimEventActionResponse_LootListRewardData): unknown {
    const obj: any = {};
    if (message.itemDef?.length) {
      obj.itemDef = message.itemDef.map((e) => Math.round(e));
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgDOTAClaimEventActionResponse_LootListRewardData>,
  ): CMsgDOTAClaimEventActionResponse_LootListRewardData {
    return CMsgDOTAClaimEventActionResponse_LootListRewardData.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgDOTAClaimEventActionResponse_LootListRewardData>,
  ): CMsgDOTAClaimEventActionResponse_LootListRewardData {
    const message = createBaseCMsgDOTAClaimEventActionResponse_LootListRewardData();
    message.itemDef = object.itemDef?.map((e) => e) || [];
    return message;
  },
};

function createBaseCMsgDOTAClaimEventActionResponse_ActionListRewardData(): CMsgDOTAClaimEventActionResponse_ActionListRewardData {
  return { actionId: 0, resultRewardData: Buffer.alloc(0) };
}

export const CMsgDOTAClaimEventActionResponse_ActionListRewardData = {
  encode(
    message: CMsgDOTAClaimEventActionResponse_ActionListRewardData,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.actionId !== undefined && message.actionId !== 0) {
      writer.uint32(8).uint32(message.actionId);
    }
    if (message.resultRewardData !== undefined && message.resultRewardData.length !== 0) {
      writer.uint32(18).bytes(message.resultRewardData);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTAClaimEventActionResponse_ActionListRewardData {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAClaimEventActionResponse_ActionListRewardData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.actionId = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.resultRewardData = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAClaimEventActionResponse_ActionListRewardData {
    return {
      actionId: isSet(object.actionId) ? globalThis.Number(object.actionId) : 0,
      resultRewardData: isSet(object.resultRewardData)
        ? Buffer.from(bytesFromBase64(object.resultRewardData))
        : Buffer.alloc(0),
    };
  },

  toJSON(message: CMsgDOTAClaimEventActionResponse_ActionListRewardData): unknown {
    const obj: any = {};
    if (message.actionId !== undefined && message.actionId !== 0) {
      obj.actionId = Math.round(message.actionId);
    }
    if (message.resultRewardData !== undefined && message.resultRewardData.length !== 0) {
      obj.resultRewardData = base64FromBytes(message.resultRewardData);
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgDOTAClaimEventActionResponse_ActionListRewardData>,
  ): CMsgDOTAClaimEventActionResponse_ActionListRewardData {
    return CMsgDOTAClaimEventActionResponse_ActionListRewardData.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgDOTAClaimEventActionResponse_ActionListRewardData>,
  ): CMsgDOTAClaimEventActionResponse_ActionListRewardData {
    const message = createBaseCMsgDOTAClaimEventActionResponse_ActionListRewardData();
    message.actionId = object.actionId ?? 0;
    message.resultRewardData = object.resultRewardData ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseCMsgDOTAClaimEventActionResponse_OverworldTokenRewardData(): CMsgDOTAClaimEventActionResponse_OverworldTokenRewardData {
  return { tokens: [] };
}

export const CMsgDOTAClaimEventActionResponse_OverworldTokenRewardData = {
  encode(
    message: CMsgDOTAClaimEventActionResponse_OverworldTokenRewardData,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    for (const v of message.tokens) {
      CMsgDOTAClaimEventActionResponse_OverworldTokenRewardData_TokenQuantity.encode(v!, writer.uint32(10).fork())
        .ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTAClaimEventActionResponse_OverworldTokenRewardData {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAClaimEventActionResponse_OverworldTokenRewardData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.tokens.push(
            CMsgDOTAClaimEventActionResponse_OverworldTokenRewardData_TokenQuantity.decode(reader, reader.uint32()),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAClaimEventActionResponse_OverworldTokenRewardData {
    return {
      tokens: globalThis.Array.isArray(object?.tokens)
        ? object.tokens.map((e: any) =>
          CMsgDOTAClaimEventActionResponse_OverworldTokenRewardData_TokenQuantity.fromJSON(e)
        )
        : [],
    };
  },

  toJSON(message: CMsgDOTAClaimEventActionResponse_OverworldTokenRewardData): unknown {
    const obj: any = {};
    if (message.tokens?.length) {
      obj.tokens = message.tokens.map((e) =>
        CMsgDOTAClaimEventActionResponse_OverworldTokenRewardData_TokenQuantity.toJSON(e)
      );
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgDOTAClaimEventActionResponse_OverworldTokenRewardData>,
  ): CMsgDOTAClaimEventActionResponse_OverworldTokenRewardData {
    return CMsgDOTAClaimEventActionResponse_OverworldTokenRewardData.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgDOTAClaimEventActionResponse_OverworldTokenRewardData>,
  ): CMsgDOTAClaimEventActionResponse_OverworldTokenRewardData {
    const message = createBaseCMsgDOTAClaimEventActionResponse_OverworldTokenRewardData();
    message.tokens =
      object.tokens?.map((e) =>
        CMsgDOTAClaimEventActionResponse_OverworldTokenRewardData_TokenQuantity.fromPartial(e)
      ) || [];
    return message;
  },
};

function createBaseCMsgDOTAClaimEventActionResponse_OverworldTokenRewardData_TokenQuantity(): CMsgDOTAClaimEventActionResponse_OverworldTokenRewardData_TokenQuantity {
  return { tokenId: 0, tokenCount: 0 };
}

export const CMsgDOTAClaimEventActionResponse_OverworldTokenRewardData_TokenQuantity = {
  encode(
    message: CMsgDOTAClaimEventActionResponse_OverworldTokenRewardData_TokenQuantity,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.tokenId !== undefined && message.tokenId !== 0) {
      writer.uint32(8).uint32(message.tokenId);
    }
    if (message.tokenCount !== undefined && message.tokenCount !== 0) {
      writer.uint32(16).uint32(message.tokenCount);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): CMsgDOTAClaimEventActionResponse_OverworldTokenRewardData_TokenQuantity {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAClaimEventActionResponse_OverworldTokenRewardData_TokenQuantity();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.tokenId = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.tokenCount = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAClaimEventActionResponse_OverworldTokenRewardData_TokenQuantity {
    return {
      tokenId: isSet(object.tokenId) ? globalThis.Number(object.tokenId) : 0,
      tokenCount: isSet(object.tokenCount) ? globalThis.Number(object.tokenCount) : 0,
    };
  },

  toJSON(message: CMsgDOTAClaimEventActionResponse_OverworldTokenRewardData_TokenQuantity): unknown {
    const obj: any = {};
    if (message.tokenId !== undefined && message.tokenId !== 0) {
      obj.tokenId = Math.round(message.tokenId);
    }
    if (message.tokenCount !== undefined && message.tokenCount !== 0) {
      obj.tokenCount = Math.round(message.tokenCount);
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgDOTAClaimEventActionResponse_OverworldTokenRewardData_TokenQuantity>,
  ): CMsgDOTAClaimEventActionResponse_OverworldTokenRewardData_TokenQuantity {
    return CMsgDOTAClaimEventActionResponse_OverworldTokenRewardData_TokenQuantity.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgDOTAClaimEventActionResponse_OverworldTokenRewardData_TokenQuantity>,
  ): CMsgDOTAClaimEventActionResponse_OverworldTokenRewardData_TokenQuantity {
    const message = createBaseCMsgDOTAClaimEventActionResponse_OverworldTokenRewardData_TokenQuantity();
    message.tokenId = object.tokenId ?? 0;
    message.tokenCount = object.tokenCount ?? 0;
    return message;
  },
};

function createBaseCMsgDOTAClaimEventActionResponse_GrantedRewardData(): CMsgDOTAClaimEventActionResponse_GrantedRewardData {
  return { grantIndex: 0, scoreIndex: 0, rewardIndex: 0, rewardData: Buffer.alloc(0), actionId: 0 };
}

export const CMsgDOTAClaimEventActionResponse_GrantedRewardData = {
  encode(
    message: CMsgDOTAClaimEventActionResponse_GrantedRewardData,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.grantIndex !== undefined && message.grantIndex !== 0) {
      writer.uint32(8).uint32(message.grantIndex);
    }
    if (message.scoreIndex !== undefined && message.scoreIndex !== 0) {
      writer.uint32(16).uint32(message.scoreIndex);
    }
    if (message.rewardIndex !== undefined && message.rewardIndex !== 0) {
      writer.uint32(24).uint32(message.rewardIndex);
    }
    if (message.rewardData !== undefined && message.rewardData.length !== 0) {
      writer.uint32(34).bytes(message.rewardData);
    }
    if (message.actionId !== undefined && message.actionId !== 0) {
      writer.uint32(40).uint32(message.actionId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTAClaimEventActionResponse_GrantedRewardData {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAClaimEventActionResponse_GrantedRewardData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.grantIndex = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.scoreIndex = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.rewardIndex = reader.uint32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.rewardData = reader.bytes() as Buffer;
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.actionId = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAClaimEventActionResponse_GrantedRewardData {
    return {
      grantIndex: isSet(object.grantIndex) ? globalThis.Number(object.grantIndex) : 0,
      scoreIndex: isSet(object.scoreIndex) ? globalThis.Number(object.scoreIndex) : 0,
      rewardIndex: isSet(object.rewardIndex) ? globalThis.Number(object.rewardIndex) : 0,
      rewardData: isSet(object.rewardData) ? Buffer.from(bytesFromBase64(object.rewardData)) : Buffer.alloc(0),
      actionId: isSet(object.actionId) ? globalThis.Number(object.actionId) : 0,
    };
  },

  toJSON(message: CMsgDOTAClaimEventActionResponse_GrantedRewardData): unknown {
    const obj: any = {};
    if (message.grantIndex !== undefined && message.grantIndex !== 0) {
      obj.grantIndex = Math.round(message.grantIndex);
    }
    if (message.scoreIndex !== undefined && message.scoreIndex !== 0) {
      obj.scoreIndex = Math.round(message.scoreIndex);
    }
    if (message.rewardIndex !== undefined && message.rewardIndex !== 0) {
      obj.rewardIndex = Math.round(message.rewardIndex);
    }
    if (message.rewardData !== undefined && message.rewardData.length !== 0) {
      obj.rewardData = base64FromBytes(message.rewardData);
    }
    if (message.actionId !== undefined && message.actionId !== 0) {
      obj.actionId = Math.round(message.actionId);
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgDOTAClaimEventActionResponse_GrantedRewardData>,
  ): CMsgDOTAClaimEventActionResponse_GrantedRewardData {
    return CMsgDOTAClaimEventActionResponse_GrantedRewardData.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgDOTAClaimEventActionResponse_GrantedRewardData>,
  ): CMsgDOTAClaimEventActionResponse_GrantedRewardData {
    const message = createBaseCMsgDOTAClaimEventActionResponse_GrantedRewardData();
    message.grantIndex = object.grantIndex ?? 0;
    message.scoreIndex = object.scoreIndex ?? 0;
    message.rewardIndex = object.rewardIndex ?? 0;
    message.rewardData = object.rewardData ?? Buffer.alloc(0);
    message.actionId = object.actionId ?? 0;
    return message;
  },
};

function createBaseCMsgClientToGCDotaLabsFeedback(): CMsgClientToGCDotaLabsFeedback {
  return { language: 0, feedbackItem: 0, feedback: "" };
}

export const CMsgClientToGCDotaLabsFeedback = {
  encode(message: CMsgClientToGCDotaLabsFeedback, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.language !== undefined && message.language !== 0) {
      writer.uint32(8).uint32(message.language);
    }
    if (message.feedbackItem !== undefined && message.feedbackItem !== 0) {
      writer.uint32(16).uint32(message.feedbackItem);
    }
    if (message.feedback !== undefined && message.feedback !== "") {
      writer.uint32(26).string(message.feedback);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCDotaLabsFeedback {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCDotaLabsFeedback();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.language = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.feedbackItem = reader.uint32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.feedback = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCDotaLabsFeedback {
    return {
      language: isSet(object.language) ? globalThis.Number(object.language) : 0,
      feedbackItem: isSet(object.feedbackItem) ? globalThis.Number(object.feedbackItem) : 0,
      feedback: isSet(object.feedback) ? globalThis.String(object.feedback) : "",
    };
  },

  toJSON(message: CMsgClientToGCDotaLabsFeedback): unknown {
    const obj: any = {};
    if (message.language !== undefined && message.language !== 0) {
      obj.language = Math.round(message.language);
    }
    if (message.feedbackItem !== undefined && message.feedbackItem !== 0) {
      obj.feedbackItem = Math.round(message.feedbackItem);
    }
    if (message.feedback !== undefined && message.feedback !== "") {
      obj.feedback = message.feedback;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgClientToGCDotaLabsFeedback>): CMsgClientToGCDotaLabsFeedback {
    return CMsgClientToGCDotaLabsFeedback.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgClientToGCDotaLabsFeedback>): CMsgClientToGCDotaLabsFeedback {
    const message = createBaseCMsgClientToGCDotaLabsFeedback();
    message.language = object.language ?? 0;
    message.feedbackItem = object.feedbackItem ?? 0;
    message.feedback = object.feedback ?? "";
    return message;
  },
};

function createBaseCMsgClientToGCDotaLabsFeedbackResponse(): CMsgClientToGCDotaLabsFeedbackResponse {
  return { response: 0 };
}

export const CMsgClientToGCDotaLabsFeedbackResponse = {
  encode(message: CMsgClientToGCDotaLabsFeedbackResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.response !== undefined && message.response !== 0) {
      writer.uint32(8).int32(message.response);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCDotaLabsFeedbackResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCDotaLabsFeedbackResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.response = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCDotaLabsFeedbackResponse {
    return {
      response: isSet(object.response) ? cMsgClientToGCDotaLabsFeedbackResponse_EResponseFromJSON(object.response) : 0,
    };
  },

  toJSON(message: CMsgClientToGCDotaLabsFeedbackResponse): unknown {
    const obj: any = {};
    if (message.response !== undefined && message.response !== 0) {
      obj.response = cMsgClientToGCDotaLabsFeedbackResponse_EResponseToJSON(message.response);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgClientToGCDotaLabsFeedbackResponse>): CMsgClientToGCDotaLabsFeedbackResponse {
    return CMsgClientToGCDotaLabsFeedbackResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgClientToGCDotaLabsFeedbackResponse>): CMsgClientToGCDotaLabsFeedbackResponse {
    const message = createBaseCMsgClientToGCDotaLabsFeedbackResponse();
    message.response = object.response ?? 0;
    return message;
  },
};

function createBaseCDotaMsgPredictionResult(): CDotaMsgPredictionResult {
  return { accountId: 0, matchId: "0", correct: false, predictions: [] };
}

export const CDotaMsgPredictionResult = {
  encode(message: CDotaMsgPredictionResult, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.accountId !== undefined && message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    if (message.matchId !== undefined && message.matchId !== "0") {
      writer.uint32(16).uint64(message.matchId);
    }
    if (message.correct !== undefined && message.correct !== false) {
      writer.uint32(24).bool(message.correct);
    }
    for (const v of message.predictions) {
      CDotaMsgPredictionResult_Prediction.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDotaMsgPredictionResult {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDotaMsgPredictionResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.matchId = longToString(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.correct = reader.bool();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.predictions.push(CDotaMsgPredictionResult_Prediction.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDotaMsgPredictionResult {
    return {
      accountId: isSet(object.accountId) ? globalThis.Number(object.accountId) : 0,
      matchId: isSet(object.matchId) ? globalThis.String(object.matchId) : "0",
      correct: isSet(object.correct) ? globalThis.Boolean(object.correct) : false,
      predictions: globalThis.Array.isArray(object?.predictions)
        ? object.predictions.map((e: any) => CDotaMsgPredictionResult_Prediction.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CDotaMsgPredictionResult): unknown {
    const obj: any = {};
    if (message.accountId !== undefined && message.accountId !== 0) {
      obj.accountId = Math.round(message.accountId);
    }
    if (message.matchId !== undefined && message.matchId !== "0") {
      obj.matchId = message.matchId;
    }
    if (message.correct !== undefined && message.correct !== false) {
      obj.correct = message.correct;
    }
    if (message.predictions?.length) {
      obj.predictions = message.predictions.map((e) => CDotaMsgPredictionResult_Prediction.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CDotaMsgPredictionResult>): CDotaMsgPredictionResult {
    return CDotaMsgPredictionResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDotaMsgPredictionResult>): CDotaMsgPredictionResult {
    const message = createBaseCDotaMsgPredictionResult();
    message.accountId = object.accountId ?? 0;
    message.matchId = object.matchId ?? "0";
    message.correct = object.correct ?? false;
    message.predictions = object.predictions?.map((e) => CDotaMsgPredictionResult_Prediction.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCDotaMsgPredictionResult_Prediction(): CDotaMsgPredictionResult_Prediction {
  return { itemDef: 0, numCorrect: 0, numFails: 0, result: 1, grantedItemDefs: [] };
}

export const CDotaMsgPredictionResult_Prediction = {
  encode(message: CDotaMsgPredictionResult_Prediction, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.itemDef !== undefined && message.itemDef !== 0) {
      writer.uint32(8).uint32(message.itemDef);
    }
    if (message.numCorrect !== undefined && message.numCorrect !== 0) {
      writer.uint32(16).uint32(message.numCorrect);
    }
    if (message.numFails !== undefined && message.numFails !== 0) {
      writer.uint32(24).uint32(message.numFails);
    }
    if (message.result !== undefined && message.result !== 1) {
      writer.uint32(32).int32(message.result);
    }
    writer.uint32(50).fork();
    for (const v of message.grantedItemDefs) {
      writer.uint32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDotaMsgPredictionResult_Prediction {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDotaMsgPredictionResult_Prediction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.itemDef = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.numCorrect = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.numFails = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.result = reader.int32() as any;
          continue;
        case 6:
          if (tag === 48) {
            message.grantedItemDefs.push(reader.uint32());

            continue;
          }

          if (tag === 50) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.grantedItemDefs.push(reader.uint32());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDotaMsgPredictionResult_Prediction {
    return {
      itemDef: isSet(object.itemDef) ? globalThis.Number(object.itemDef) : 0,
      numCorrect: isSet(object.numCorrect) ? globalThis.Number(object.numCorrect) : 0,
      numFails: isSet(object.numFails) ? globalThis.Number(object.numFails) : 0,
      result: isSet(object.result) ? cDotaMsgPredictionResult_Prediction_EResultFromJSON(object.result) : 1,
      grantedItemDefs: globalThis.Array.isArray(object?.grantedItemDefs)
        ? object.grantedItemDefs.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: CDotaMsgPredictionResult_Prediction): unknown {
    const obj: any = {};
    if (message.itemDef !== undefined && message.itemDef !== 0) {
      obj.itemDef = Math.round(message.itemDef);
    }
    if (message.numCorrect !== undefined && message.numCorrect !== 0) {
      obj.numCorrect = Math.round(message.numCorrect);
    }
    if (message.numFails !== undefined && message.numFails !== 0) {
      obj.numFails = Math.round(message.numFails);
    }
    if (message.result !== undefined && message.result !== 1) {
      obj.result = cDotaMsgPredictionResult_Prediction_EResultToJSON(message.result);
    }
    if (message.grantedItemDefs?.length) {
      obj.grantedItemDefs = message.grantedItemDefs.map((e) => Math.round(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CDotaMsgPredictionResult_Prediction>): CDotaMsgPredictionResult_Prediction {
    return CDotaMsgPredictionResult_Prediction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDotaMsgPredictionResult_Prediction>): CDotaMsgPredictionResult_Prediction {
    const message = createBaseCDotaMsgPredictionResult_Prediction();
    message.itemDef = object.itemDef ?? 0;
    message.numCorrect = object.numCorrect ?? 0;
    message.numFails = object.numFails ?? 0;
    message.result = object.result ?? 1;
    message.grantedItemDefs = object.grantedItemDefs?.map((e) => e) || [];
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function longToString(long: Long) {
  return long.toString();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

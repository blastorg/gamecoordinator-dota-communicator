// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.176.1
//   protoc               v5.26.1
// source: dota_gcmessages_client_match_management.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";
import { CMsgClientPingData } from "./base_gcmessages";
import { EDOTAGroupMergeResult, eDOTAGroupMergeResultFromJSON, eDOTAGroupMergeResultToJSON } from "./dota_client_enums";
import {
  CLobbyTeamDetails,
  LobbyDotaPauseSetting,
  lobbyDotaPauseSettingFromJSON,
  lobbyDotaPauseSettingToJSON,
  LobbyDotaTVDelay,
  lobbyDotaTVDelayFromJSON,
  lobbyDotaTVDelayToJSON,
} from "./dota_gcmessages_common_lobby";
import {
  CDOTAClientHardwareSpecs,
  DOTABotDifficulty,
  dOTABotDifficultyFromJSON,
  dOTABotDifficultyToJSON,
  dotaCmPick,
  dotaCmPickFromJSON,
  dotaCmPickToJSON,
  DOTAGameMode,
  dOTAGameModeFromJSON,
  dOTAGameModeToJSON,
  dotaGcTeam,
  dotaGcTeamFromJSON,
  dotaGcTeamToJSON,
  DOTAJoinLobbyResult,
  dOTAJoinLobbyResultFromJSON,
  dOTAJoinLobbyResultToJSON,
  DOTALobbyReadyState,
  dOTALobbyReadyStateFromJSON,
  dOTALobbyReadyStateToJSON,
  DOTALobbyVisibility,
  dOTALobbyVisibilityFromJSON,
  dOTALobbyVisibilityToJSON,
  DOTASelectionPriorityRules,
  dOTASelectionPriorityRulesFromJSON,
  dOTASelectionPriorityRulesToJSON,
  MatchLanguages,
  matchLanguagesFromJSON,
  matchLanguagesToJSON,
  MatchType,
  matchTypeFromJSON,
  matchTypeToJSON,
} from "./dota_shared_enums";

export enum EStartFindingMatchResult {
  k_EStartFindingMatchResult_Invalid = 0,
  k_EStartFindingMatchResult_OK = 1,
  k_EStartFindingMatchResult_AlreadySearching = 2,
  k_EStartFindingMatchResult_FailGeneric = 100,
  k_EStartFindingMatchResult_FailedIgnore = 101,
  k_EStartFindingMatchResult_MatchmakingDisabled = 102,
  k_EStartFindingMatchResult_RegionOffline = 103,
  k_EStartFindingMatchResult_MatchmakingCooldown = 104,
  k_EStartFindingMatchResult_ClientOutOfDate = 105,
  k_EStartFindingMatchResult_CompetitiveNoLowPriority = 106,
  k_EStartFindingMatchResult_CompetitiveNotUnlocked = 107,
  k_EStartFindingMatchResult_GameModeNotUnlocked = 108,
  k_EStartFindingMatchResult_CompetitiveNotEnoughPlayTime = 109,
  k_EStartFindingMatchResult_MissingInitialSkill = 110,
  k_EStartFindingMatchResult_CompetitiveRankSpreadTooLarge = 111,
  k_EStartFindingMatchResult_MemberAlreadyInLobby = 112,
  k_EStartFindingMatchResult_MemberNotVACVerified = 113,
  k_EStartFindingMatchResult_WeekendTourneyBadPartySize = 114,
  k_EStartFindingMatchResult_WeekendTourneyTeamBuyInTooSmall = 115,
  k_EStartFindingMatchResult_WeekendTourneyIndividualBuyInTooLarge = 116,
  k_EStartFindingMatchResult_WeekendTourneyTeamBuyInTooLarge = 117,
  k_EStartFindingMatchResult_MemberMissingEventOwnership = 118,
  k_EStartFindingMatchResult_WeekendTourneyNotUnlocked = 119,
  k_EStartFindingMatchResult_WeekendTourneyRecentParticipation = 120,
  k_EStartFindingMatchResult_MemberMissingAnchoredPhoneNumber = 121,
  k_EStartFindingMatchResult_NotMemberOfClan = 122,
  k_EStartFindingMatchResult_CoachesChallengeBadPartySize = 123,
  k_EStartFindingMatchResult_CoachesChallengeRequirementsNotMet = 124,
  k_EStartFindingMatchResult_InvalidRoleSelections = 125,
  k_EStartFindingMatchResult_PhoneNumberDiscrepancy = 126,
  k_EStartFindingMatchResult_NoQueuePoints = 127,
  k_EStartFindingMatchResult_MemberMissingGauntletFlag = 128,
  k_EStartFindingMatchResult_MemberGauntletTooRecent = 129,
  k_EStartFindingMatchResult_DifficultyNotUnlocked = 130,
  k_EStartFindingMatchResult_CoachesNotAllowedInParty = 131,
  k_EStartFindingMatchResult_MatchmakingBusy = 132,
  k_EStartFindingMatchResult_SteamChinaBanned = 133,
  k_EStartFindingMatchResult_SteamChinaInvalidMixedParty = 134,
  k_EStartFindingMatchResult_RestrictedFromRanked = 135,
  k_EStartFindingMatchResult_RankPreventsParties = 136,
  k_EStartFindingMatchResult_RegisteredNameRequired = 137,
}

export function eStartFindingMatchResultFromJSON(object: any): EStartFindingMatchResult {
  switch (object) {
    case 0:
    case "k_EStartFindingMatchResult_Invalid":
      return EStartFindingMatchResult.k_EStartFindingMatchResult_Invalid;
    case 1:
    case "k_EStartFindingMatchResult_OK":
      return EStartFindingMatchResult.k_EStartFindingMatchResult_OK;
    case 2:
    case "k_EStartFindingMatchResult_AlreadySearching":
      return EStartFindingMatchResult.k_EStartFindingMatchResult_AlreadySearching;
    case 100:
    case "k_EStartFindingMatchResult_FailGeneric":
      return EStartFindingMatchResult.k_EStartFindingMatchResult_FailGeneric;
    case 101:
    case "k_EStartFindingMatchResult_FailedIgnore":
      return EStartFindingMatchResult.k_EStartFindingMatchResult_FailedIgnore;
    case 102:
    case "k_EStartFindingMatchResult_MatchmakingDisabled":
      return EStartFindingMatchResult.k_EStartFindingMatchResult_MatchmakingDisabled;
    case 103:
    case "k_EStartFindingMatchResult_RegionOffline":
      return EStartFindingMatchResult.k_EStartFindingMatchResult_RegionOffline;
    case 104:
    case "k_EStartFindingMatchResult_MatchmakingCooldown":
      return EStartFindingMatchResult.k_EStartFindingMatchResult_MatchmakingCooldown;
    case 105:
    case "k_EStartFindingMatchResult_ClientOutOfDate":
      return EStartFindingMatchResult.k_EStartFindingMatchResult_ClientOutOfDate;
    case 106:
    case "k_EStartFindingMatchResult_CompetitiveNoLowPriority":
      return EStartFindingMatchResult.k_EStartFindingMatchResult_CompetitiveNoLowPriority;
    case 107:
    case "k_EStartFindingMatchResult_CompetitiveNotUnlocked":
      return EStartFindingMatchResult.k_EStartFindingMatchResult_CompetitiveNotUnlocked;
    case 108:
    case "k_EStartFindingMatchResult_GameModeNotUnlocked":
      return EStartFindingMatchResult.k_EStartFindingMatchResult_GameModeNotUnlocked;
    case 109:
    case "k_EStartFindingMatchResult_CompetitiveNotEnoughPlayTime":
      return EStartFindingMatchResult.k_EStartFindingMatchResult_CompetitiveNotEnoughPlayTime;
    case 110:
    case "k_EStartFindingMatchResult_MissingInitialSkill":
      return EStartFindingMatchResult.k_EStartFindingMatchResult_MissingInitialSkill;
    case 111:
    case "k_EStartFindingMatchResult_CompetitiveRankSpreadTooLarge":
      return EStartFindingMatchResult.k_EStartFindingMatchResult_CompetitiveRankSpreadTooLarge;
    case 112:
    case "k_EStartFindingMatchResult_MemberAlreadyInLobby":
      return EStartFindingMatchResult.k_EStartFindingMatchResult_MemberAlreadyInLobby;
    case 113:
    case "k_EStartFindingMatchResult_MemberNotVACVerified":
      return EStartFindingMatchResult.k_EStartFindingMatchResult_MemberNotVACVerified;
    case 114:
    case "k_EStartFindingMatchResult_WeekendTourneyBadPartySize":
      return EStartFindingMatchResult.k_EStartFindingMatchResult_WeekendTourneyBadPartySize;
    case 115:
    case "k_EStartFindingMatchResult_WeekendTourneyTeamBuyInTooSmall":
      return EStartFindingMatchResult.k_EStartFindingMatchResult_WeekendTourneyTeamBuyInTooSmall;
    case 116:
    case "k_EStartFindingMatchResult_WeekendTourneyIndividualBuyInTooLarge":
      return EStartFindingMatchResult.k_EStartFindingMatchResult_WeekendTourneyIndividualBuyInTooLarge;
    case 117:
    case "k_EStartFindingMatchResult_WeekendTourneyTeamBuyInTooLarge":
      return EStartFindingMatchResult.k_EStartFindingMatchResult_WeekendTourneyTeamBuyInTooLarge;
    case 118:
    case "k_EStartFindingMatchResult_MemberMissingEventOwnership":
      return EStartFindingMatchResult.k_EStartFindingMatchResult_MemberMissingEventOwnership;
    case 119:
    case "k_EStartFindingMatchResult_WeekendTourneyNotUnlocked":
      return EStartFindingMatchResult.k_EStartFindingMatchResult_WeekendTourneyNotUnlocked;
    case 120:
    case "k_EStartFindingMatchResult_WeekendTourneyRecentParticipation":
      return EStartFindingMatchResult.k_EStartFindingMatchResult_WeekendTourneyRecentParticipation;
    case 121:
    case "k_EStartFindingMatchResult_MemberMissingAnchoredPhoneNumber":
      return EStartFindingMatchResult.k_EStartFindingMatchResult_MemberMissingAnchoredPhoneNumber;
    case 122:
    case "k_EStartFindingMatchResult_NotMemberOfClan":
      return EStartFindingMatchResult.k_EStartFindingMatchResult_NotMemberOfClan;
    case 123:
    case "k_EStartFindingMatchResult_CoachesChallengeBadPartySize":
      return EStartFindingMatchResult.k_EStartFindingMatchResult_CoachesChallengeBadPartySize;
    case 124:
    case "k_EStartFindingMatchResult_CoachesChallengeRequirementsNotMet":
      return EStartFindingMatchResult.k_EStartFindingMatchResult_CoachesChallengeRequirementsNotMet;
    case 125:
    case "k_EStartFindingMatchResult_InvalidRoleSelections":
      return EStartFindingMatchResult.k_EStartFindingMatchResult_InvalidRoleSelections;
    case 126:
    case "k_EStartFindingMatchResult_PhoneNumberDiscrepancy":
      return EStartFindingMatchResult.k_EStartFindingMatchResult_PhoneNumberDiscrepancy;
    case 127:
    case "k_EStartFindingMatchResult_NoQueuePoints":
      return EStartFindingMatchResult.k_EStartFindingMatchResult_NoQueuePoints;
    case 128:
    case "k_EStartFindingMatchResult_MemberMissingGauntletFlag":
      return EStartFindingMatchResult.k_EStartFindingMatchResult_MemberMissingGauntletFlag;
    case 129:
    case "k_EStartFindingMatchResult_MemberGauntletTooRecent":
      return EStartFindingMatchResult.k_EStartFindingMatchResult_MemberGauntletTooRecent;
    case 130:
    case "k_EStartFindingMatchResult_DifficultyNotUnlocked":
      return EStartFindingMatchResult.k_EStartFindingMatchResult_DifficultyNotUnlocked;
    case 131:
    case "k_EStartFindingMatchResult_CoachesNotAllowedInParty":
      return EStartFindingMatchResult.k_EStartFindingMatchResult_CoachesNotAllowedInParty;
    case 132:
    case "k_EStartFindingMatchResult_MatchmakingBusy":
      return EStartFindingMatchResult.k_EStartFindingMatchResult_MatchmakingBusy;
    case 133:
    case "k_EStartFindingMatchResult_SteamChinaBanned":
      return EStartFindingMatchResult.k_EStartFindingMatchResult_SteamChinaBanned;
    case 134:
    case "k_EStartFindingMatchResult_SteamChinaInvalidMixedParty":
      return EStartFindingMatchResult.k_EStartFindingMatchResult_SteamChinaInvalidMixedParty;
    case 135:
    case "k_EStartFindingMatchResult_RestrictedFromRanked":
      return EStartFindingMatchResult.k_EStartFindingMatchResult_RestrictedFromRanked;
    case 136:
    case "k_EStartFindingMatchResult_RankPreventsParties":
      return EStartFindingMatchResult.k_EStartFindingMatchResult_RankPreventsParties;
    case 137:
    case "k_EStartFindingMatchResult_RegisteredNameRequired":
      return EStartFindingMatchResult.k_EStartFindingMatchResult_RegisteredNameRequired;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum EStartFindingMatchResult");
  }
}

export function eStartFindingMatchResultToJSON(object: EStartFindingMatchResult): string {
  switch (object) {
    case EStartFindingMatchResult.k_EStartFindingMatchResult_Invalid:
      return "k_EStartFindingMatchResult_Invalid";
    case EStartFindingMatchResult.k_EStartFindingMatchResult_OK:
      return "k_EStartFindingMatchResult_OK";
    case EStartFindingMatchResult.k_EStartFindingMatchResult_AlreadySearching:
      return "k_EStartFindingMatchResult_AlreadySearching";
    case EStartFindingMatchResult.k_EStartFindingMatchResult_FailGeneric:
      return "k_EStartFindingMatchResult_FailGeneric";
    case EStartFindingMatchResult.k_EStartFindingMatchResult_FailedIgnore:
      return "k_EStartFindingMatchResult_FailedIgnore";
    case EStartFindingMatchResult.k_EStartFindingMatchResult_MatchmakingDisabled:
      return "k_EStartFindingMatchResult_MatchmakingDisabled";
    case EStartFindingMatchResult.k_EStartFindingMatchResult_RegionOffline:
      return "k_EStartFindingMatchResult_RegionOffline";
    case EStartFindingMatchResult.k_EStartFindingMatchResult_MatchmakingCooldown:
      return "k_EStartFindingMatchResult_MatchmakingCooldown";
    case EStartFindingMatchResult.k_EStartFindingMatchResult_ClientOutOfDate:
      return "k_EStartFindingMatchResult_ClientOutOfDate";
    case EStartFindingMatchResult.k_EStartFindingMatchResult_CompetitiveNoLowPriority:
      return "k_EStartFindingMatchResult_CompetitiveNoLowPriority";
    case EStartFindingMatchResult.k_EStartFindingMatchResult_CompetitiveNotUnlocked:
      return "k_EStartFindingMatchResult_CompetitiveNotUnlocked";
    case EStartFindingMatchResult.k_EStartFindingMatchResult_GameModeNotUnlocked:
      return "k_EStartFindingMatchResult_GameModeNotUnlocked";
    case EStartFindingMatchResult.k_EStartFindingMatchResult_CompetitiveNotEnoughPlayTime:
      return "k_EStartFindingMatchResult_CompetitiveNotEnoughPlayTime";
    case EStartFindingMatchResult.k_EStartFindingMatchResult_MissingInitialSkill:
      return "k_EStartFindingMatchResult_MissingInitialSkill";
    case EStartFindingMatchResult.k_EStartFindingMatchResult_CompetitiveRankSpreadTooLarge:
      return "k_EStartFindingMatchResult_CompetitiveRankSpreadTooLarge";
    case EStartFindingMatchResult.k_EStartFindingMatchResult_MemberAlreadyInLobby:
      return "k_EStartFindingMatchResult_MemberAlreadyInLobby";
    case EStartFindingMatchResult.k_EStartFindingMatchResult_MemberNotVACVerified:
      return "k_EStartFindingMatchResult_MemberNotVACVerified";
    case EStartFindingMatchResult.k_EStartFindingMatchResult_WeekendTourneyBadPartySize:
      return "k_EStartFindingMatchResult_WeekendTourneyBadPartySize";
    case EStartFindingMatchResult.k_EStartFindingMatchResult_WeekendTourneyTeamBuyInTooSmall:
      return "k_EStartFindingMatchResult_WeekendTourneyTeamBuyInTooSmall";
    case EStartFindingMatchResult.k_EStartFindingMatchResult_WeekendTourneyIndividualBuyInTooLarge:
      return "k_EStartFindingMatchResult_WeekendTourneyIndividualBuyInTooLarge";
    case EStartFindingMatchResult.k_EStartFindingMatchResult_WeekendTourneyTeamBuyInTooLarge:
      return "k_EStartFindingMatchResult_WeekendTourneyTeamBuyInTooLarge";
    case EStartFindingMatchResult.k_EStartFindingMatchResult_MemberMissingEventOwnership:
      return "k_EStartFindingMatchResult_MemberMissingEventOwnership";
    case EStartFindingMatchResult.k_EStartFindingMatchResult_WeekendTourneyNotUnlocked:
      return "k_EStartFindingMatchResult_WeekendTourneyNotUnlocked";
    case EStartFindingMatchResult.k_EStartFindingMatchResult_WeekendTourneyRecentParticipation:
      return "k_EStartFindingMatchResult_WeekendTourneyRecentParticipation";
    case EStartFindingMatchResult.k_EStartFindingMatchResult_MemberMissingAnchoredPhoneNumber:
      return "k_EStartFindingMatchResult_MemberMissingAnchoredPhoneNumber";
    case EStartFindingMatchResult.k_EStartFindingMatchResult_NotMemberOfClan:
      return "k_EStartFindingMatchResult_NotMemberOfClan";
    case EStartFindingMatchResult.k_EStartFindingMatchResult_CoachesChallengeBadPartySize:
      return "k_EStartFindingMatchResult_CoachesChallengeBadPartySize";
    case EStartFindingMatchResult.k_EStartFindingMatchResult_CoachesChallengeRequirementsNotMet:
      return "k_EStartFindingMatchResult_CoachesChallengeRequirementsNotMet";
    case EStartFindingMatchResult.k_EStartFindingMatchResult_InvalidRoleSelections:
      return "k_EStartFindingMatchResult_InvalidRoleSelections";
    case EStartFindingMatchResult.k_EStartFindingMatchResult_PhoneNumberDiscrepancy:
      return "k_EStartFindingMatchResult_PhoneNumberDiscrepancy";
    case EStartFindingMatchResult.k_EStartFindingMatchResult_NoQueuePoints:
      return "k_EStartFindingMatchResult_NoQueuePoints";
    case EStartFindingMatchResult.k_EStartFindingMatchResult_MemberMissingGauntletFlag:
      return "k_EStartFindingMatchResult_MemberMissingGauntletFlag";
    case EStartFindingMatchResult.k_EStartFindingMatchResult_MemberGauntletTooRecent:
      return "k_EStartFindingMatchResult_MemberGauntletTooRecent";
    case EStartFindingMatchResult.k_EStartFindingMatchResult_DifficultyNotUnlocked:
      return "k_EStartFindingMatchResult_DifficultyNotUnlocked";
    case EStartFindingMatchResult.k_EStartFindingMatchResult_CoachesNotAllowedInParty:
      return "k_EStartFindingMatchResult_CoachesNotAllowedInParty";
    case EStartFindingMatchResult.k_EStartFindingMatchResult_MatchmakingBusy:
      return "k_EStartFindingMatchResult_MatchmakingBusy";
    case EStartFindingMatchResult.k_EStartFindingMatchResult_SteamChinaBanned:
      return "k_EStartFindingMatchResult_SteamChinaBanned";
    case EStartFindingMatchResult.k_EStartFindingMatchResult_SteamChinaInvalidMixedParty:
      return "k_EStartFindingMatchResult_SteamChinaInvalidMixedParty";
    case EStartFindingMatchResult.k_EStartFindingMatchResult_RestrictedFromRanked:
      return "k_EStartFindingMatchResult_RestrictedFromRanked";
    case EStartFindingMatchResult.k_EStartFindingMatchResult_RankPreventsParties:
      return "k_EStartFindingMatchResult_RankPreventsParties";
    case EStartFindingMatchResult.k_EStartFindingMatchResult_RegisteredNameRequired:
      return "k_EStartFindingMatchResult_RegisteredNameRequired";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum EStartFindingMatchResult");
  }
}

export interface CMsgStartFindingMatch {
  key?: string | undefined;
  matchgroups?: number | undefined;
  clientVersion?: number | undefined;
  gameModes?: number | undefined;
  matchType?: MatchType | undefined;
  matchlanguages?: number | undefined;
  teamId?: number | undefined;
  gameLanguageEnum?: MatchLanguages | undefined;
  gameLanguageName?: string | undefined;
  pingData?: CMsgClientPingData | undefined;
  regionSelectFlags?: number | undefined;
  soloQueue?: boolean | undefined;
  steamClanAccountId?: number | undefined;
  isChallengeMatch?: boolean | undefined;
  laneSelectionFlags?: number | undefined;
  highPriorityDisabled?: boolean | undefined;
  disableExperimentalGameplay?: boolean | undefined;
  customGameDifficultyMask?: number | undefined;
  botDifficultyMask?: number | undefined;
  botScriptIndexMask?: number | undefined;
}

export interface CMsgStartFindingMatchResult {
  legacyGenericEresult?: number | undefined;
  result?: EStartFindingMatchResult | undefined;
  errorToken?: string | undefined;
  debugMessage?: string | undefined;
  responsiblePartyMembers: string[];
  resultMetadata?: number | undefined;
}

export interface CMsgStopFindingMatch {
  acceptCooldown?: boolean | undefined;
}

export interface CMsgPartyBuilderOptions {
  additionalSlots?: number | undefined;
  matchType?: MatchType | undefined;
  matchgroups?: number | undefined;
  clientVersion?: number | undefined;
  language?: MatchLanguages | undefined;
}

export interface CMsgReadyUp {
  state?: DOTALobbyReadyState | undefined;
  readyUpKey?: string | undefined;
  hardwareSpecs?: CDOTAClientHardwareSpecs | undefined;
}

export interface CMsgReadyUpStatus {
  lobbyId?: string | undefined;
  acceptedIds: number[];
  declinedIds: number[];
  acceptedIndices: number[];
  declinedIndices: number[];
  localReadyState?: DOTALobbyReadyState | undefined;
}

export interface CMsgAbandonCurrentGame {
}

export interface CMsgLobbyScenarioSave {
  version?: number | undefined;
  data?: Buffer | undefined;
}

export interface CMsgPracticeLobbySetDetails {
  lobbyId?: string | undefined;
  gameName?: string | undefined;
  teamDetails: CLobbyTeamDetails[];
  serverRegion?: number | undefined;
  gameMode?: number | undefined;
  cmPick?: dotaCmPick | undefined;
  botDifficultyRadiant?: DOTABotDifficulty | undefined;
  allowCheats?: boolean | undefined;
  fillWithBots?: boolean | undefined;
  allowSpectating?: boolean | undefined;
  passKey?: string | undefined;
  leagueid?: number | undefined;
  penaltyLevelRadiant?: number | undefined;
  penaltyLevelDire?: number | undefined;
  seriesType?: number | undefined;
  radiantSeriesWins?: number | undefined;
  direSeriesWins?: number | undefined;
  allchat?: boolean | undefined;
  dotaTvDelay?: LobbyDotaTVDelay | undefined;
  lan?: boolean | undefined;
  customGameMode?: string | undefined;
  customMapName?: string | undefined;
  customDifficulty?: number | undefined;
  customGameId?: string | undefined;
  customMinPlayers?: number | undefined;
  customMaxPlayers?: number | undefined;
  visibility?: DOTALobbyVisibility | undefined;
  customGameCrc?: string | undefined;
  customGameTimestamp?: number | undefined;
  previousMatchOverride?: string | undefined;
  pauseSetting?: LobbyDotaPauseSetting | undefined;
  botDifficultyDire?: DOTABotDifficulty | undefined;
  botRadiant?: string | undefined;
  botDire?: string | undefined;
  selectionPriorityRules?: DOTASelectionPriorityRules | undefined;
  customGamePenalties?: boolean | undefined;
  lanHostPingLocation?: string | undefined;
  leagueNodeId?: number | undefined;
  requestedHeroIds: number[];
  scenarioSave?: CMsgLobbyScenarioSave | undefined;
  abilityDraftSpecificDetails?: CMsgPracticeLobbySetDetails_AbilityDraftSpecificDetails | undefined;
  doPlayerDraft?: boolean | undefined;
  requestedHeroTeams: number[];
}

export interface CMsgPracticeLobbySetDetails_AbilityDraftSpecificDetails {
  shuffleDraftOrder?: boolean | undefined;
}

export interface CMsgPracticeLobbyCreate {
  searchKey?: string | undefined;
  passKey?: string | undefined;
  clientVersion?: number | undefined;
  lobbyDetails?: CMsgPracticeLobbySetDetails | undefined;
}

export interface CMsgPracticeLobbySetTeamSlot {
  team?: dotaGcTeam | undefined;
  slot?: number | undefined;
  botDifficulty?: DOTABotDifficulty | undefined;
}

export interface CMsgPracticeLobbySetCoach {
  team?: dotaGcTeam | undefined;
}

export interface CMsgPracticeLobbyJoinBroadcastChannel {
  channel?: number | undefined;
  preferredDescription?: string | undefined;
  preferredCountryCode?: string | undefined;
  preferredLanguageCode?: string | undefined;
}

export interface CMsgPracticeLobbyCloseBroadcastChannel {
  channel?: number | undefined;
}

export interface CMsgPracticeLobbyToggleBroadcastChannelCameramanStatus {
}

export interface CMsgPracticeLobbyKick {
  accountId?: number | undefined;
}

export interface CMsgPracticeLobbyKickFromTeam {
  accountId?: number | undefined;
}

export interface CMsgPracticeLobbyLeave {
}

export interface CMsgPracticeLobbyLaunch {
  clientVersion?: number | undefined;
}

export interface CMsgApplyTeamToPracticeLobby {
  teamId?: number | undefined;
}

export interface CMsgPracticeLobbyList {
  passKey?: string | undefined;
  region?: number | undefined;
  gameMode?: DOTAGameMode | undefined;
}

export interface CMsgPracticeLobbyListResponseEntry {
  id?: string | undefined;
  members: CMsgPracticeLobbyListResponseEntry_CLobbyMember[];
  requiresPassKey?: boolean | undefined;
  leaderAccountId?: number | undefined;
  name?: string | undefined;
  customGameMode?: string | undefined;
  gameMode?: DOTAGameMode | undefined;
  friendPresent?: boolean | undefined;
  players?: number | undefined;
  customMapName?: string | undefined;
  maxPlayerCount?: number | undefined;
  serverRegion?: number | undefined;
  leagueId?: number | undefined;
  lanHostPingLocation?: string | undefined;
  minPlayerCount?: number | undefined;
  penaltiesEnabled?: boolean | undefined;
}

export interface CMsgPracticeLobbyListResponseEntry_CLobbyMember {
  accountId?: number | undefined;
  playerName?: string | undefined;
}

export interface CMsgPracticeLobbyListResponse {
  lobbies: CMsgPracticeLobbyListResponseEntry[];
}

export interface CMsgLobbyList {
  serverRegion?: number | undefined;
  gameMode?: DOTAGameMode | undefined;
}

export interface CMsgLobbyListResponse {
  lobbies: CMsgPracticeLobbyListResponseEntry[];
}

export interface CMsgPracticeLobbyJoin {
  lobbyId?: string | undefined;
  clientVersion?: number | undefined;
  passKey?: string | undefined;
  customGameCrc?: string | undefined;
  customGameTimestamp?: number | undefined;
}

export interface CMsgPracticeLobbyJoinResponse {
  result?: DOTAJoinLobbyResult | undefined;
}

export interface CMsgFriendPracticeLobbyListRequest {
  friends: number[];
}

export interface CMsgFriendPracticeLobbyListResponse {
  lobbies: CMsgPracticeLobbyListResponseEntry[];
}

export interface CMsgJoinableCustomGameModesRequest {
  serverRegion?: number | undefined;
}

export interface CMsgJoinableCustomGameModesResponseEntry {
  customGameId?: string | undefined;
  lobbyCount?: number | undefined;
  playerCount?: number | undefined;
}

export interface CMsgJoinableCustomGameModesResponse {
  gameModes: CMsgJoinableCustomGameModesResponseEntry[];
}

export interface CMsgJoinableCustomLobbiesRequest {
  serverRegion?: number | undefined;
  customGameId?: string | undefined;
}

export interface CMsgJoinableCustomLobbiesResponseEntry {
  lobbyId?: string | undefined;
  customGameId?: string | undefined;
  lobbyName?: string | undefined;
  memberCount?: number | undefined;
  leaderAccountId?: number | undefined;
  leaderName?: string | undefined;
  customMapName?: string | undefined;
  maxPlayerCount?: number | undefined;
  serverRegion?: number | undefined;
  hasPassKey?: boolean | undefined;
  lanHostPingLocation?: string | undefined;
  lobbyCreationTime?: number | undefined;
  customGameTimestamp?: number | undefined;
  customGameCrc?: string | undefined;
  minPlayerCount?: number | undefined;
  penaltiesEnabled?: boolean | undefined;
}

export interface CMsgJoinableCustomLobbiesResponse {
  lobbies: CMsgJoinableCustomLobbiesResponseEntry[];
}

export interface CMsgQuickJoinCustomLobby {
  legacyServerRegion?: number | undefined;
  customGameId?: string | undefined;
  clientVersion?: number | undefined;
  createLobbyDetails?: CMsgPracticeLobbySetDetails | undefined;
  allowAnyMap?: boolean | undefined;
  legacyRegionPings: CMsgQuickJoinCustomLobby_LegacyRegionPing[];
  pingData?: CMsgClientPingData | undefined;
}

export interface CMsgQuickJoinCustomLobby_LegacyRegionPing {
  serverRegion?: number | undefined;
  ping?: number | undefined;
  regionCode?: number | undefined;
}

export interface CMsgQuickJoinCustomLobbyResponse {
  result?: DOTAJoinLobbyResult | undefined;
}

export interface CMsgBotGameCreate {
  searchKey?: string | undefined;
  clientVersion?: number | undefined;
  difficultyRadiant?: DOTABotDifficulty | undefined;
  team?: dotaGcTeam | undefined;
  gameMode?: number | undefined;
  difficultyDire?: DOTABotDifficulty | undefined;
}

export interface CMsgDOTAPartyMemberSetCoach {
  wantsCoach?: boolean | undefined;
}

export interface CMsgDOTASetGroupLeader {
  newLeaderSteamid?: string | undefined;
}

export interface CMsgDOTACancelGroupInvites {
  invitedSteamids: string[];
  invitedGroupids: string[];
}

export interface CMsgDOTASetGroupOpenStatus {
  open?: boolean | undefined;
}

export interface CMsgDOTAGroupMergeInvite {
  otherGroupId?: string | undefined;
}

export interface CMsgDOTAGroupMergeResponse {
  initiatorGroupId?: string | undefined;
  accept?: boolean | undefined;
}

export interface CMsgDOTAGroupMergeReply {
  result?: EDOTAGroupMergeResult | undefined;
}

export interface CMsgSpectatorLobbyGameDetails {
  language?: number | undefined;
  matchId?: string | undefined;
  serverSteamId?: string | undefined;
  streamUrl?: string | undefined;
  streamName?: string | undefined;
  leagueId?: number | undefined;
  seriesType?: number | undefined;
  seriesGame?: number | undefined;
  radiantTeam?: CMsgSpectatorLobbyGameDetails_Team | undefined;
  direTeam?: CMsgSpectatorLobbyGameDetails_Team | undefined;
}

export interface CMsgSpectatorLobbyGameDetails_Team {
  teamId?: number | undefined;
  teamName?: string | undefined;
  teamLogo?: string | undefined;
}

export interface CMsgSetSpectatorLobbyDetails {
  lobbyId?: string | undefined;
  lobbyName?: string | undefined;
  passKey?: string | undefined;
  gameDetails?: CMsgSpectatorLobbyGameDetails | undefined;
}

export interface CMsgCreateSpectatorLobby {
  clientVersion?: number | undefined;
  details?: CMsgSetSpectatorLobbyDetails | undefined;
}

export interface CMsgSpectatorLobbyList {
}

export interface CMsgSpectatorLobbyListResponse {
  lobbies: CMsgSpectatorLobbyListResponse_SpectatorLobby[];
}

export interface CMsgSpectatorLobbyListResponse_SpectatorLobby {
  lobbyId?: string | undefined;
  gameName?: string | undefined;
  requiresPassKey?: boolean | undefined;
  leaderAccountId?: number | undefined;
  memberCount?: number | undefined;
  gameDetails?: CMsgSpectatorLobbyGameDetails | undefined;
}

export interface CMsgClientToGCRequestSteamDatagramTicket {
  serverSteamId?: string | undefined;
}

export interface CMsgClientToGCRequestSteamDatagramTicketResponse {
  serializedTicket?: Buffer | undefined;
  message?: string | undefined;
}

export interface CMsgGCToClientSteamDatagramTicket {
  legacyTimeExpiry?: number | undefined;
  legacyAuthorizedSteamId?: string | undefined;
  legacyAuthorizedPublicIp?: number | undefined;
  legacyGameserverSteamId?: string | undefined;
  legacyGameserverNetId?: string | undefined;
  legacySignature?: Buffer | undefined;
  legacyAppId?: number | undefined;
  legacyExtraFields: Buffer[];
  serializedTicket?: Buffer | undefined;
}

export interface CMsgGCToClientRequestLaneSelection {
}

export interface CMsgGCToClientRequestLaneSelectionResponse {
  laneSelectionFlags?: number | undefined;
  highPriorityDisabled?: boolean | undefined;
}

export interface CMsgGCToClientRequestMMInfo {
}

export interface CMsgClientToGCMMInfo {
  laneSelectionFlags?: number | undefined;
  highPriorityDisabled?: boolean | undefined;
}

function createBaseCMsgStartFindingMatch(): CMsgStartFindingMatch {
  return {
    key: "",
    matchgroups: 4294967295,
    clientVersion: 0,
    gameModes: 4294967295,
    matchType: 0,
    matchlanguages: 4294967295,
    teamId: 0,
    gameLanguageEnum: 0,
    gameLanguageName: "",
    pingData: undefined,
    regionSelectFlags: 0,
    soloQueue: false,
    steamClanAccountId: 0,
    isChallengeMatch: false,
    laneSelectionFlags: 0,
    highPriorityDisabled: false,
    disableExperimentalGameplay: false,
    customGameDifficultyMask: 0,
    botDifficultyMask: 0,
    botScriptIndexMask: 0,
  };
}

export const CMsgStartFindingMatch = {
  encode(message: CMsgStartFindingMatch, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== undefined && message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.matchgroups !== undefined && message.matchgroups !== 4294967295) {
      writer.uint32(16).uint32(message.matchgroups);
    }
    if (message.clientVersion !== undefined && message.clientVersion !== 0) {
      writer.uint32(24).uint32(message.clientVersion);
    }
    if (message.gameModes !== undefined && message.gameModes !== 4294967295) {
      writer.uint32(32).uint32(message.gameModes);
    }
    if (message.matchType !== undefined && message.matchType !== 0) {
      writer.uint32(48).int32(message.matchType);
    }
    if (message.matchlanguages !== undefined && message.matchlanguages !== 4294967295) {
      writer.uint32(56).uint32(message.matchlanguages);
    }
    if (message.teamId !== undefined && message.teamId !== 0) {
      writer.uint32(64).uint32(message.teamId);
    }
    if (message.gameLanguageEnum !== undefined && message.gameLanguageEnum !== 0) {
      writer.uint32(80).int32(message.gameLanguageEnum);
    }
    if (message.gameLanguageName !== undefined && message.gameLanguageName !== "") {
      writer.uint32(90).string(message.gameLanguageName);
    }
    if (message.pingData !== undefined) {
      CMsgClientPingData.encode(message.pingData, writer.uint32(98).fork()).ldelim();
    }
    if (message.regionSelectFlags !== undefined && message.regionSelectFlags !== 0) {
      writer.uint32(104).uint32(message.regionSelectFlags);
    }
    if (message.soloQueue !== undefined && message.soloQueue !== false) {
      writer.uint32(112).bool(message.soloQueue);
    }
    if (message.steamClanAccountId !== undefined && message.steamClanAccountId !== 0) {
      writer.uint32(128).uint32(message.steamClanAccountId);
    }
    if (message.isChallengeMatch !== undefined && message.isChallengeMatch !== false) {
      writer.uint32(136).bool(message.isChallengeMatch);
    }
    if (message.laneSelectionFlags !== undefined && message.laneSelectionFlags !== 0) {
      writer.uint32(144).uint32(message.laneSelectionFlags);
    }
    if (message.highPriorityDisabled !== undefined && message.highPriorityDisabled !== false) {
      writer.uint32(152).bool(message.highPriorityDisabled);
    }
    if (message.disableExperimentalGameplay !== undefined && message.disableExperimentalGameplay !== false) {
      writer.uint32(160).bool(message.disableExperimentalGameplay);
    }
    if (message.customGameDifficultyMask !== undefined && message.customGameDifficultyMask !== 0) {
      writer.uint32(168).uint32(message.customGameDifficultyMask);
    }
    if (message.botDifficultyMask !== undefined && message.botDifficultyMask !== 0) {
      writer.uint32(176).uint32(message.botDifficultyMask);
    }
    if (message.botScriptIndexMask !== undefined && message.botScriptIndexMask !== 0) {
      writer.uint32(184).uint32(message.botScriptIndexMask);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgStartFindingMatch {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgStartFindingMatch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.matchgroups = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.clientVersion = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.gameModes = reader.uint32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.matchType = reader.int32() as any;
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.matchlanguages = reader.uint32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.teamId = reader.uint32();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.gameLanguageEnum = reader.int32() as any;
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.gameLanguageName = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.pingData = CMsgClientPingData.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.regionSelectFlags = reader.uint32();
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.soloQueue = reader.bool();
          continue;
        case 16:
          if (tag !== 128) {
            break;
          }

          message.steamClanAccountId = reader.uint32();
          continue;
        case 17:
          if (tag !== 136) {
            break;
          }

          message.isChallengeMatch = reader.bool();
          continue;
        case 18:
          if (tag !== 144) {
            break;
          }

          message.laneSelectionFlags = reader.uint32();
          continue;
        case 19:
          if (tag !== 152) {
            break;
          }

          message.highPriorityDisabled = reader.bool();
          continue;
        case 20:
          if (tag !== 160) {
            break;
          }

          message.disableExperimentalGameplay = reader.bool();
          continue;
        case 21:
          if (tag !== 168) {
            break;
          }

          message.customGameDifficultyMask = reader.uint32();
          continue;
        case 22:
          if (tag !== 176) {
            break;
          }

          message.botDifficultyMask = reader.uint32();
          continue;
        case 23:
          if (tag !== 184) {
            break;
          }

          message.botScriptIndexMask = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgStartFindingMatch {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      matchgroups: isSet(object.matchgroups) ? globalThis.Number(object.matchgroups) : 4294967295,
      clientVersion: isSet(object.clientVersion) ? globalThis.Number(object.clientVersion) : 0,
      gameModes: isSet(object.gameModes) ? globalThis.Number(object.gameModes) : 4294967295,
      matchType: isSet(object.matchType) ? matchTypeFromJSON(object.matchType) : 0,
      matchlanguages: isSet(object.matchlanguages) ? globalThis.Number(object.matchlanguages) : 4294967295,
      teamId: isSet(object.teamId) ? globalThis.Number(object.teamId) : 0,
      gameLanguageEnum: isSet(object.gameLanguageEnum) ? matchLanguagesFromJSON(object.gameLanguageEnum) : 0,
      gameLanguageName: isSet(object.gameLanguageName) ? globalThis.String(object.gameLanguageName) : "",
      pingData: isSet(object.pingData) ? CMsgClientPingData.fromJSON(object.pingData) : undefined,
      regionSelectFlags: isSet(object.regionSelectFlags) ? globalThis.Number(object.regionSelectFlags) : 0,
      soloQueue: isSet(object.soloQueue) ? globalThis.Boolean(object.soloQueue) : false,
      steamClanAccountId: isSet(object.steamClanAccountId) ? globalThis.Number(object.steamClanAccountId) : 0,
      isChallengeMatch: isSet(object.isChallengeMatch) ? globalThis.Boolean(object.isChallengeMatch) : false,
      laneSelectionFlags: isSet(object.laneSelectionFlags) ? globalThis.Number(object.laneSelectionFlags) : 0,
      highPriorityDisabled: isSet(object.highPriorityDisabled)
        ? globalThis.Boolean(object.highPriorityDisabled)
        : false,
      disableExperimentalGameplay: isSet(object.disableExperimentalGameplay)
        ? globalThis.Boolean(object.disableExperimentalGameplay)
        : false,
      customGameDifficultyMask: isSet(object.customGameDifficultyMask)
        ? globalThis.Number(object.customGameDifficultyMask)
        : 0,
      botDifficultyMask: isSet(object.botDifficultyMask) ? globalThis.Number(object.botDifficultyMask) : 0,
      botScriptIndexMask: isSet(object.botScriptIndexMask) ? globalThis.Number(object.botScriptIndexMask) : 0,
    };
  },

  toJSON(message: CMsgStartFindingMatch): unknown {
    const obj: any = {};
    if (message.key !== undefined && message.key !== "") {
      obj.key = message.key;
    }
    if (message.matchgroups !== undefined && message.matchgroups !== 4294967295) {
      obj.matchgroups = Math.round(message.matchgroups);
    }
    if (message.clientVersion !== undefined && message.clientVersion !== 0) {
      obj.clientVersion = Math.round(message.clientVersion);
    }
    if (message.gameModes !== undefined && message.gameModes !== 4294967295) {
      obj.gameModes = Math.round(message.gameModes);
    }
    if (message.matchType !== undefined && message.matchType !== 0) {
      obj.matchType = matchTypeToJSON(message.matchType);
    }
    if (message.matchlanguages !== undefined && message.matchlanguages !== 4294967295) {
      obj.matchlanguages = Math.round(message.matchlanguages);
    }
    if (message.teamId !== undefined && message.teamId !== 0) {
      obj.teamId = Math.round(message.teamId);
    }
    if (message.gameLanguageEnum !== undefined && message.gameLanguageEnum !== 0) {
      obj.gameLanguageEnum = matchLanguagesToJSON(message.gameLanguageEnum);
    }
    if (message.gameLanguageName !== undefined && message.gameLanguageName !== "") {
      obj.gameLanguageName = message.gameLanguageName;
    }
    if (message.pingData !== undefined) {
      obj.pingData = CMsgClientPingData.toJSON(message.pingData);
    }
    if (message.regionSelectFlags !== undefined && message.regionSelectFlags !== 0) {
      obj.regionSelectFlags = Math.round(message.regionSelectFlags);
    }
    if (message.soloQueue !== undefined && message.soloQueue !== false) {
      obj.soloQueue = message.soloQueue;
    }
    if (message.steamClanAccountId !== undefined && message.steamClanAccountId !== 0) {
      obj.steamClanAccountId = Math.round(message.steamClanAccountId);
    }
    if (message.isChallengeMatch !== undefined && message.isChallengeMatch !== false) {
      obj.isChallengeMatch = message.isChallengeMatch;
    }
    if (message.laneSelectionFlags !== undefined && message.laneSelectionFlags !== 0) {
      obj.laneSelectionFlags = Math.round(message.laneSelectionFlags);
    }
    if (message.highPriorityDisabled !== undefined && message.highPriorityDisabled !== false) {
      obj.highPriorityDisabled = message.highPriorityDisabled;
    }
    if (message.disableExperimentalGameplay !== undefined && message.disableExperimentalGameplay !== false) {
      obj.disableExperimentalGameplay = message.disableExperimentalGameplay;
    }
    if (message.customGameDifficultyMask !== undefined && message.customGameDifficultyMask !== 0) {
      obj.customGameDifficultyMask = Math.round(message.customGameDifficultyMask);
    }
    if (message.botDifficultyMask !== undefined && message.botDifficultyMask !== 0) {
      obj.botDifficultyMask = Math.round(message.botDifficultyMask);
    }
    if (message.botScriptIndexMask !== undefined && message.botScriptIndexMask !== 0) {
      obj.botScriptIndexMask = Math.round(message.botScriptIndexMask);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgStartFindingMatch>): CMsgStartFindingMatch {
    return CMsgStartFindingMatch.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgStartFindingMatch>): CMsgStartFindingMatch {
    const message = createBaseCMsgStartFindingMatch();
    message.key = object.key ?? "";
    message.matchgroups = object.matchgroups ?? 4294967295;
    message.clientVersion = object.clientVersion ?? 0;
    message.gameModes = object.gameModes ?? 4294967295;
    message.matchType = object.matchType ?? 0;
    message.matchlanguages = object.matchlanguages ?? 4294967295;
    message.teamId = object.teamId ?? 0;
    message.gameLanguageEnum = object.gameLanguageEnum ?? 0;
    message.gameLanguageName = object.gameLanguageName ?? "";
    message.pingData = (object.pingData !== undefined && object.pingData !== null)
      ? CMsgClientPingData.fromPartial(object.pingData)
      : undefined;
    message.regionSelectFlags = object.regionSelectFlags ?? 0;
    message.soloQueue = object.soloQueue ?? false;
    message.steamClanAccountId = object.steamClanAccountId ?? 0;
    message.isChallengeMatch = object.isChallengeMatch ?? false;
    message.laneSelectionFlags = object.laneSelectionFlags ?? 0;
    message.highPriorityDisabled = object.highPriorityDisabled ?? false;
    message.disableExperimentalGameplay = object.disableExperimentalGameplay ?? false;
    message.customGameDifficultyMask = object.customGameDifficultyMask ?? 0;
    message.botDifficultyMask = object.botDifficultyMask ?? 0;
    message.botScriptIndexMask = object.botScriptIndexMask ?? 0;
    return message;
  },
};

function createBaseCMsgStartFindingMatchResult(): CMsgStartFindingMatchResult {
  return {
    legacyGenericEresult: 2,
    result: 0,
    errorToken: "",
    debugMessage: "",
    responsiblePartyMembers: [],
    resultMetadata: 0,
  };
}

export const CMsgStartFindingMatchResult = {
  encode(message: CMsgStartFindingMatchResult, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.legacyGenericEresult !== undefined && message.legacyGenericEresult !== 2) {
      writer.uint32(8).uint32(message.legacyGenericEresult);
    }
    if (message.result !== undefined && message.result !== 0) {
      writer.uint32(16).int32(message.result);
    }
    if (message.errorToken !== undefined && message.errorToken !== "") {
      writer.uint32(26).string(message.errorToken);
    }
    if (message.debugMessage !== undefined && message.debugMessage !== "") {
      writer.uint32(34).string(message.debugMessage);
    }
    writer.uint32(42).fork();
    for (const v of message.responsiblePartyMembers) {
      writer.fixed64(v);
    }
    writer.ldelim();
    if (message.resultMetadata !== undefined && message.resultMetadata !== 0) {
      writer.uint32(48).uint32(message.resultMetadata);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgStartFindingMatchResult {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgStartFindingMatchResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.legacyGenericEresult = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.result = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.errorToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.debugMessage = reader.string();
          continue;
        case 5:
          if (tag === 41) {
            message.responsiblePartyMembers.push(longToString(reader.fixed64() as Long));

            continue;
          }

          if (tag === 42) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.responsiblePartyMembers.push(longToString(reader.fixed64() as Long));
            }

            continue;
          }

          break;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.resultMetadata = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgStartFindingMatchResult {
    return {
      legacyGenericEresult: isSet(object.legacyGenericEresult) ? globalThis.Number(object.legacyGenericEresult) : 2,
      result: isSet(object.result) ? eStartFindingMatchResultFromJSON(object.result) : 0,
      errorToken: isSet(object.errorToken) ? globalThis.String(object.errorToken) : "",
      debugMessage: isSet(object.debugMessage) ? globalThis.String(object.debugMessage) : "",
      responsiblePartyMembers: globalThis.Array.isArray(object?.responsiblePartyMembers)
        ? object.responsiblePartyMembers.map((e: any) => globalThis.String(e))
        : [],
      resultMetadata: isSet(object.resultMetadata) ? globalThis.Number(object.resultMetadata) : 0,
    };
  },

  toJSON(message: CMsgStartFindingMatchResult): unknown {
    const obj: any = {};
    if (message.legacyGenericEresult !== undefined && message.legacyGenericEresult !== 2) {
      obj.legacyGenericEresult = Math.round(message.legacyGenericEresult);
    }
    if (message.result !== undefined && message.result !== 0) {
      obj.result = eStartFindingMatchResultToJSON(message.result);
    }
    if (message.errorToken !== undefined && message.errorToken !== "") {
      obj.errorToken = message.errorToken;
    }
    if (message.debugMessage !== undefined && message.debugMessage !== "") {
      obj.debugMessage = message.debugMessage;
    }
    if (message.responsiblePartyMembers?.length) {
      obj.responsiblePartyMembers = message.responsiblePartyMembers;
    }
    if (message.resultMetadata !== undefined && message.resultMetadata !== 0) {
      obj.resultMetadata = Math.round(message.resultMetadata);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgStartFindingMatchResult>): CMsgStartFindingMatchResult {
    return CMsgStartFindingMatchResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgStartFindingMatchResult>): CMsgStartFindingMatchResult {
    const message = createBaseCMsgStartFindingMatchResult();
    message.legacyGenericEresult = object.legacyGenericEresult ?? 2;
    message.result = object.result ?? 0;
    message.errorToken = object.errorToken ?? "";
    message.debugMessage = object.debugMessage ?? "";
    message.responsiblePartyMembers = object.responsiblePartyMembers?.map((e) => e) || [];
    message.resultMetadata = object.resultMetadata ?? 0;
    return message;
  },
};

function createBaseCMsgStopFindingMatch(): CMsgStopFindingMatch {
  return { acceptCooldown: false };
}

export const CMsgStopFindingMatch = {
  encode(message: CMsgStopFindingMatch, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.acceptCooldown !== undefined && message.acceptCooldown !== false) {
      writer.uint32(8).bool(message.acceptCooldown);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgStopFindingMatch {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgStopFindingMatch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.acceptCooldown = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgStopFindingMatch {
    return { acceptCooldown: isSet(object.acceptCooldown) ? globalThis.Boolean(object.acceptCooldown) : false };
  },

  toJSON(message: CMsgStopFindingMatch): unknown {
    const obj: any = {};
    if (message.acceptCooldown !== undefined && message.acceptCooldown !== false) {
      obj.acceptCooldown = message.acceptCooldown;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgStopFindingMatch>): CMsgStopFindingMatch {
    return CMsgStopFindingMatch.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgStopFindingMatch>): CMsgStopFindingMatch {
    const message = createBaseCMsgStopFindingMatch();
    message.acceptCooldown = object.acceptCooldown ?? false;
    return message;
  },
};

function createBaseCMsgPartyBuilderOptions(): CMsgPartyBuilderOptions {
  return { additionalSlots: 0, matchType: 0, matchgroups: 0, clientVersion: 0, language: 0 };
}

export const CMsgPartyBuilderOptions = {
  encode(message: CMsgPartyBuilderOptions, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.additionalSlots !== undefined && message.additionalSlots !== 0) {
      writer.uint32(8).uint32(message.additionalSlots);
    }
    if (message.matchType !== undefined && message.matchType !== 0) {
      writer.uint32(16).int32(message.matchType);
    }
    if (message.matchgroups !== undefined && message.matchgroups !== 0) {
      writer.uint32(24).uint32(message.matchgroups);
    }
    if (message.clientVersion !== undefined && message.clientVersion !== 0) {
      writer.uint32(32).uint32(message.clientVersion);
    }
    if (message.language !== undefined && message.language !== 0) {
      writer.uint32(40).int32(message.language);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgPartyBuilderOptions {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgPartyBuilderOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.additionalSlots = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.matchType = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.matchgroups = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.clientVersion = reader.uint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.language = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgPartyBuilderOptions {
    return {
      additionalSlots: isSet(object.additionalSlots) ? globalThis.Number(object.additionalSlots) : 0,
      matchType: isSet(object.matchType) ? matchTypeFromJSON(object.matchType) : 0,
      matchgroups: isSet(object.matchgroups) ? globalThis.Number(object.matchgroups) : 0,
      clientVersion: isSet(object.clientVersion) ? globalThis.Number(object.clientVersion) : 0,
      language: isSet(object.language) ? matchLanguagesFromJSON(object.language) : 0,
    };
  },

  toJSON(message: CMsgPartyBuilderOptions): unknown {
    const obj: any = {};
    if (message.additionalSlots !== undefined && message.additionalSlots !== 0) {
      obj.additionalSlots = Math.round(message.additionalSlots);
    }
    if (message.matchType !== undefined && message.matchType !== 0) {
      obj.matchType = matchTypeToJSON(message.matchType);
    }
    if (message.matchgroups !== undefined && message.matchgroups !== 0) {
      obj.matchgroups = Math.round(message.matchgroups);
    }
    if (message.clientVersion !== undefined && message.clientVersion !== 0) {
      obj.clientVersion = Math.round(message.clientVersion);
    }
    if (message.language !== undefined && message.language !== 0) {
      obj.language = matchLanguagesToJSON(message.language);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgPartyBuilderOptions>): CMsgPartyBuilderOptions {
    return CMsgPartyBuilderOptions.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgPartyBuilderOptions>): CMsgPartyBuilderOptions {
    const message = createBaseCMsgPartyBuilderOptions();
    message.additionalSlots = object.additionalSlots ?? 0;
    message.matchType = object.matchType ?? 0;
    message.matchgroups = object.matchgroups ?? 0;
    message.clientVersion = object.clientVersion ?? 0;
    message.language = object.language ?? 0;
    return message;
  },
};

function createBaseCMsgReadyUp(): CMsgReadyUp {
  return { state: 0, readyUpKey: "0", hardwareSpecs: undefined };
}

export const CMsgReadyUp = {
  encode(message: CMsgReadyUp, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.state !== undefined && message.state !== 0) {
      writer.uint32(8).int32(message.state);
    }
    if (message.readyUpKey !== undefined && message.readyUpKey !== "0") {
      writer.uint32(17).fixed64(message.readyUpKey);
    }
    if (message.hardwareSpecs !== undefined) {
      CDOTAClientHardwareSpecs.encode(message.hardwareSpecs, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgReadyUp {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgReadyUp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.readyUpKey = longToString(reader.fixed64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.hardwareSpecs = CDOTAClientHardwareSpecs.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgReadyUp {
    return {
      state: isSet(object.state) ? dOTALobbyReadyStateFromJSON(object.state) : 0,
      readyUpKey: isSet(object.readyUpKey) ? globalThis.String(object.readyUpKey) : "0",
      hardwareSpecs: isSet(object.hardwareSpecs) ? CDOTAClientHardwareSpecs.fromJSON(object.hardwareSpecs) : undefined,
    };
  },

  toJSON(message: CMsgReadyUp): unknown {
    const obj: any = {};
    if (message.state !== undefined && message.state !== 0) {
      obj.state = dOTALobbyReadyStateToJSON(message.state);
    }
    if (message.readyUpKey !== undefined && message.readyUpKey !== "0") {
      obj.readyUpKey = message.readyUpKey;
    }
    if (message.hardwareSpecs !== undefined) {
      obj.hardwareSpecs = CDOTAClientHardwareSpecs.toJSON(message.hardwareSpecs);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgReadyUp>): CMsgReadyUp {
    return CMsgReadyUp.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgReadyUp>): CMsgReadyUp {
    const message = createBaseCMsgReadyUp();
    message.state = object.state ?? 0;
    message.readyUpKey = object.readyUpKey ?? "0";
    message.hardwareSpecs = (object.hardwareSpecs !== undefined && object.hardwareSpecs !== null)
      ? CDOTAClientHardwareSpecs.fromPartial(object.hardwareSpecs)
      : undefined;
    return message;
  },
};

function createBaseCMsgReadyUpStatus(): CMsgReadyUpStatus {
  return {
    lobbyId: "0",
    acceptedIds: [],
    declinedIds: [],
    acceptedIndices: [],
    declinedIndices: [],
    localReadyState: 0,
  };
}

export const CMsgReadyUpStatus = {
  encode(message: CMsgReadyUpStatus, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.lobbyId !== undefined && message.lobbyId !== "0") {
      writer.uint32(9).fixed64(message.lobbyId);
    }
    writer.uint32(18).fork();
    for (const v of message.acceptedIds) {
      writer.uint32(v);
    }
    writer.ldelim();
    writer.uint32(26).fork();
    for (const v of message.declinedIds) {
      writer.uint32(v);
    }
    writer.ldelim();
    writer.uint32(34).fork();
    for (const v of message.acceptedIndices) {
      writer.uint32(v);
    }
    writer.ldelim();
    writer.uint32(42).fork();
    for (const v of message.declinedIndices) {
      writer.uint32(v);
    }
    writer.ldelim();
    if (message.localReadyState !== undefined && message.localReadyState !== 0) {
      writer.uint32(48).int32(message.localReadyState);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgReadyUpStatus {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgReadyUpStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.lobbyId = longToString(reader.fixed64() as Long);
          continue;
        case 2:
          if (tag === 16) {
            message.acceptedIds.push(reader.uint32());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.acceptedIds.push(reader.uint32());
            }

            continue;
          }

          break;
        case 3:
          if (tag === 24) {
            message.declinedIds.push(reader.uint32());

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.declinedIds.push(reader.uint32());
            }

            continue;
          }

          break;
        case 4:
          if (tag === 32) {
            message.acceptedIndices.push(reader.uint32());

            continue;
          }

          if (tag === 34) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.acceptedIndices.push(reader.uint32());
            }

            continue;
          }

          break;
        case 5:
          if (tag === 40) {
            message.declinedIndices.push(reader.uint32());

            continue;
          }

          if (tag === 42) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.declinedIndices.push(reader.uint32());
            }

            continue;
          }

          break;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.localReadyState = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgReadyUpStatus {
    return {
      lobbyId: isSet(object.lobbyId) ? globalThis.String(object.lobbyId) : "0",
      acceptedIds: globalThis.Array.isArray(object?.acceptedIds)
        ? object.acceptedIds.map((e: any) => globalThis.Number(e))
        : [],
      declinedIds: globalThis.Array.isArray(object?.declinedIds)
        ? object.declinedIds.map((e: any) => globalThis.Number(e))
        : [],
      acceptedIndices: globalThis.Array.isArray(object?.acceptedIndices)
        ? object.acceptedIndices.map((e: any) => globalThis.Number(e))
        : [],
      declinedIndices: globalThis.Array.isArray(object?.declinedIndices)
        ? object.declinedIndices.map((e: any) => globalThis.Number(e))
        : [],
      localReadyState: isSet(object.localReadyState) ? dOTALobbyReadyStateFromJSON(object.localReadyState) : 0,
    };
  },

  toJSON(message: CMsgReadyUpStatus): unknown {
    const obj: any = {};
    if (message.lobbyId !== undefined && message.lobbyId !== "0") {
      obj.lobbyId = message.lobbyId;
    }
    if (message.acceptedIds?.length) {
      obj.acceptedIds = message.acceptedIds.map((e) => Math.round(e));
    }
    if (message.declinedIds?.length) {
      obj.declinedIds = message.declinedIds.map((e) => Math.round(e));
    }
    if (message.acceptedIndices?.length) {
      obj.acceptedIndices = message.acceptedIndices.map((e) => Math.round(e));
    }
    if (message.declinedIndices?.length) {
      obj.declinedIndices = message.declinedIndices.map((e) => Math.round(e));
    }
    if (message.localReadyState !== undefined && message.localReadyState !== 0) {
      obj.localReadyState = dOTALobbyReadyStateToJSON(message.localReadyState);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgReadyUpStatus>): CMsgReadyUpStatus {
    return CMsgReadyUpStatus.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgReadyUpStatus>): CMsgReadyUpStatus {
    const message = createBaseCMsgReadyUpStatus();
    message.lobbyId = object.lobbyId ?? "0";
    message.acceptedIds = object.acceptedIds?.map((e) => e) || [];
    message.declinedIds = object.declinedIds?.map((e) => e) || [];
    message.acceptedIndices = object.acceptedIndices?.map((e) => e) || [];
    message.declinedIndices = object.declinedIndices?.map((e) => e) || [];
    message.localReadyState = object.localReadyState ?? 0;
    return message;
  },
};

function createBaseCMsgAbandonCurrentGame(): CMsgAbandonCurrentGame {
  return {};
}

export const CMsgAbandonCurrentGame = {
  encode(_: CMsgAbandonCurrentGame, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgAbandonCurrentGame {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgAbandonCurrentGame();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CMsgAbandonCurrentGame {
    return {};
  },

  toJSON(_: CMsgAbandonCurrentGame): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<CMsgAbandonCurrentGame>): CMsgAbandonCurrentGame {
    return CMsgAbandonCurrentGame.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<CMsgAbandonCurrentGame>): CMsgAbandonCurrentGame {
    const message = createBaseCMsgAbandonCurrentGame();
    return message;
  },
};

function createBaseCMsgLobbyScenarioSave(): CMsgLobbyScenarioSave {
  return { version: 0, data: Buffer.alloc(0) };
}

export const CMsgLobbyScenarioSave = {
  encode(message: CMsgLobbyScenarioSave, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.version !== undefined && message.version !== 0) {
      writer.uint32(8).int32(message.version);
    }
    if (message.data !== undefined && message.data.length !== 0) {
      writer.uint32(18).bytes(message.data);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgLobbyScenarioSave {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgLobbyScenarioSave();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.version = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.data = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgLobbyScenarioSave {
    return {
      version: isSet(object.version) ? globalThis.Number(object.version) : 0,
      data: isSet(object.data) ? Buffer.from(bytesFromBase64(object.data)) : Buffer.alloc(0),
    };
  },

  toJSON(message: CMsgLobbyScenarioSave): unknown {
    const obj: any = {};
    if (message.version !== undefined && message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    if (message.data !== undefined && message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgLobbyScenarioSave>): CMsgLobbyScenarioSave {
    return CMsgLobbyScenarioSave.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgLobbyScenarioSave>): CMsgLobbyScenarioSave {
    const message = createBaseCMsgLobbyScenarioSave();
    message.version = object.version ?? 0;
    message.data = object.data ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseCMsgPracticeLobbySetDetails(): CMsgPracticeLobbySetDetails {
  return {
    lobbyId: "0",
    gameName: "",
    teamDetails: [],
    serverRegion: 0,
    gameMode: 0,
    cmPick: 0,
    botDifficultyRadiant: 0,
    allowCheats: false,
    fillWithBots: false,
    allowSpectating: false,
    passKey: "",
    leagueid: 0,
    penaltyLevelRadiant: 0,
    penaltyLevelDire: 0,
    seriesType: 0,
    radiantSeriesWins: 0,
    direSeriesWins: 0,
    allchat: false,
    dotaTvDelay: 1,
    lan: false,
    customGameMode: "",
    customMapName: "",
    customDifficulty: 0,
    customGameId: "0",
    customMinPlayers: 0,
    customMaxPlayers: 0,
    visibility: 0,
    customGameCrc: "0",
    customGameTimestamp: 0,
    previousMatchOverride: "0",
    pauseSetting: 0,
    botDifficultyDire: 0,
    botRadiant: "0",
    botDire: "0",
    selectionPriorityRules: 0,
    customGamePenalties: false,
    lanHostPingLocation: "",
    leagueNodeId: 0,
    requestedHeroIds: [],
    scenarioSave: undefined,
    abilityDraftSpecificDetails: undefined,
    doPlayerDraft: false,
    requestedHeroTeams: [],
  };
}

export const CMsgPracticeLobbySetDetails = {
  encode(message: CMsgPracticeLobbySetDetails, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.lobbyId !== undefined && message.lobbyId !== "0") {
      writer.uint32(8).uint64(message.lobbyId);
    }
    if (message.gameName !== undefined && message.gameName !== "") {
      writer.uint32(18).string(message.gameName);
    }
    for (const v of message.teamDetails) {
      CLobbyTeamDetails.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    if (message.serverRegion !== undefined && message.serverRegion !== 0) {
      writer.uint32(32).uint32(message.serverRegion);
    }
    if (message.gameMode !== undefined && message.gameMode !== 0) {
      writer.uint32(40).uint32(message.gameMode);
    }
    if (message.cmPick !== undefined && message.cmPick !== 0) {
      writer.uint32(48).int32(message.cmPick);
    }
    if (message.botDifficultyRadiant !== undefined && message.botDifficultyRadiant !== 0) {
      writer.uint32(72).int32(message.botDifficultyRadiant);
    }
    if (message.allowCheats !== undefined && message.allowCheats !== false) {
      writer.uint32(80).bool(message.allowCheats);
    }
    if (message.fillWithBots !== undefined && message.fillWithBots !== false) {
      writer.uint32(88).bool(message.fillWithBots);
    }
    if (message.allowSpectating !== undefined && message.allowSpectating !== false) {
      writer.uint32(104).bool(message.allowSpectating);
    }
    if (message.passKey !== undefined && message.passKey !== "") {
      writer.uint32(122).string(message.passKey);
    }
    if (message.leagueid !== undefined && message.leagueid !== 0) {
      writer.uint32(128).uint32(message.leagueid);
    }
    if (message.penaltyLevelRadiant !== undefined && message.penaltyLevelRadiant !== 0) {
      writer.uint32(136).uint32(message.penaltyLevelRadiant);
    }
    if (message.penaltyLevelDire !== undefined && message.penaltyLevelDire !== 0) {
      writer.uint32(144).uint32(message.penaltyLevelDire);
    }
    if (message.seriesType !== undefined && message.seriesType !== 0) {
      writer.uint32(160).uint32(message.seriesType);
    }
    if (message.radiantSeriesWins !== undefined && message.radiantSeriesWins !== 0) {
      writer.uint32(168).uint32(message.radiantSeriesWins);
    }
    if (message.direSeriesWins !== undefined && message.direSeriesWins !== 0) {
      writer.uint32(176).uint32(message.direSeriesWins);
    }
    if (message.allchat !== undefined && message.allchat !== false) {
      writer.uint32(184).bool(message.allchat);
    }
    if (message.dotaTvDelay !== undefined && message.dotaTvDelay !== 1) {
      writer.uint32(192).int32(message.dotaTvDelay);
    }
    if (message.lan !== undefined && message.lan !== false) {
      writer.uint32(200).bool(message.lan);
    }
    if (message.customGameMode !== undefined && message.customGameMode !== "") {
      writer.uint32(210).string(message.customGameMode);
    }
    if (message.customMapName !== undefined && message.customMapName !== "") {
      writer.uint32(218).string(message.customMapName);
    }
    if (message.customDifficulty !== undefined && message.customDifficulty !== 0) {
      writer.uint32(224).uint32(message.customDifficulty);
    }
    if (message.customGameId !== undefined && message.customGameId !== "0") {
      writer.uint32(232).uint64(message.customGameId);
    }
    if (message.customMinPlayers !== undefined && message.customMinPlayers !== 0) {
      writer.uint32(240).uint32(message.customMinPlayers);
    }
    if (message.customMaxPlayers !== undefined && message.customMaxPlayers !== 0) {
      writer.uint32(248).uint32(message.customMaxPlayers);
    }
    if (message.visibility !== undefined && message.visibility !== 0) {
      writer.uint32(264).int32(message.visibility);
    }
    if (message.customGameCrc !== undefined && message.customGameCrc !== "0") {
      writer.uint32(273).fixed64(message.customGameCrc);
    }
    if (message.customGameTimestamp !== undefined && message.customGameTimestamp !== 0) {
      writer.uint32(301).fixed32(message.customGameTimestamp);
    }
    if (message.previousMatchOverride !== undefined && message.previousMatchOverride !== "0") {
      writer.uint32(304).uint64(message.previousMatchOverride);
    }
    if (message.pauseSetting !== undefined && message.pauseSetting !== 0) {
      writer.uint32(336).int32(message.pauseSetting);
    }
    if (message.botDifficultyDire !== undefined && message.botDifficultyDire !== 0) {
      writer.uint32(344).int32(message.botDifficultyDire);
    }
    if (message.botRadiant !== undefined && message.botRadiant !== "0") {
      writer.uint32(352).uint64(message.botRadiant);
    }
    if (message.botDire !== undefined && message.botDire !== "0") {
      writer.uint32(360).uint64(message.botDire);
    }
    if (message.selectionPriorityRules !== undefined && message.selectionPriorityRules !== 0) {
      writer.uint32(368).int32(message.selectionPriorityRules);
    }
    if (message.customGamePenalties !== undefined && message.customGamePenalties !== false) {
      writer.uint32(376).bool(message.customGamePenalties);
    }
    if (message.lanHostPingLocation !== undefined && message.lanHostPingLocation !== "") {
      writer.uint32(386).string(message.lanHostPingLocation);
    }
    if (message.leagueNodeId !== undefined && message.leagueNodeId !== 0) {
      writer.uint32(392).uint32(message.leagueNodeId);
    }
    writer.uint32(402).fork();
    for (const v of message.requestedHeroIds) {
      writer.int32(v);
    }
    writer.ldelim();
    if (message.scenarioSave !== undefined) {
      CMsgLobbyScenarioSave.encode(message.scenarioSave, writer.uint32(410).fork()).ldelim();
    }
    if (message.abilityDraftSpecificDetails !== undefined) {
      CMsgPracticeLobbySetDetails_AbilityDraftSpecificDetails.encode(
        message.abilityDraftSpecificDetails,
        writer.uint32(418).fork(),
      ).ldelim();
    }
    if (message.doPlayerDraft !== undefined && message.doPlayerDraft !== false) {
      writer.uint32(424).bool(message.doPlayerDraft);
    }
    writer.uint32(434).fork();
    for (const v of message.requestedHeroTeams) {
      writer.int32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgPracticeLobbySetDetails {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgPracticeLobbySetDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.lobbyId = longToString(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.gameName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.teamDetails.push(CLobbyTeamDetails.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.serverRegion = reader.uint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.gameMode = reader.uint32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.cmPick = reader.int32() as any;
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.botDifficultyRadiant = reader.int32() as any;
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.allowCheats = reader.bool();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.fillWithBots = reader.bool();
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.allowSpectating = reader.bool();
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.passKey = reader.string();
          continue;
        case 16:
          if (tag !== 128) {
            break;
          }

          message.leagueid = reader.uint32();
          continue;
        case 17:
          if (tag !== 136) {
            break;
          }

          message.penaltyLevelRadiant = reader.uint32();
          continue;
        case 18:
          if (tag !== 144) {
            break;
          }

          message.penaltyLevelDire = reader.uint32();
          continue;
        case 20:
          if (tag !== 160) {
            break;
          }

          message.seriesType = reader.uint32();
          continue;
        case 21:
          if (tag !== 168) {
            break;
          }

          message.radiantSeriesWins = reader.uint32();
          continue;
        case 22:
          if (tag !== 176) {
            break;
          }

          message.direSeriesWins = reader.uint32();
          continue;
        case 23:
          if (tag !== 184) {
            break;
          }

          message.allchat = reader.bool();
          continue;
        case 24:
          if (tag !== 192) {
            break;
          }

          message.dotaTvDelay = reader.int32() as any;
          continue;
        case 25:
          if (tag !== 200) {
            break;
          }

          message.lan = reader.bool();
          continue;
        case 26:
          if (tag !== 210) {
            break;
          }

          message.customGameMode = reader.string();
          continue;
        case 27:
          if (tag !== 218) {
            break;
          }

          message.customMapName = reader.string();
          continue;
        case 28:
          if (tag !== 224) {
            break;
          }

          message.customDifficulty = reader.uint32();
          continue;
        case 29:
          if (tag !== 232) {
            break;
          }

          message.customGameId = longToString(reader.uint64() as Long);
          continue;
        case 30:
          if (tag !== 240) {
            break;
          }

          message.customMinPlayers = reader.uint32();
          continue;
        case 31:
          if (tag !== 248) {
            break;
          }

          message.customMaxPlayers = reader.uint32();
          continue;
        case 33:
          if (tag !== 264) {
            break;
          }

          message.visibility = reader.int32() as any;
          continue;
        case 34:
          if (tag !== 273) {
            break;
          }

          message.customGameCrc = longToString(reader.fixed64() as Long);
          continue;
        case 37:
          if (tag !== 301) {
            break;
          }

          message.customGameTimestamp = reader.fixed32();
          continue;
        case 38:
          if (tag !== 304) {
            break;
          }

          message.previousMatchOverride = longToString(reader.uint64() as Long);
          continue;
        case 42:
          if (tag !== 336) {
            break;
          }

          message.pauseSetting = reader.int32() as any;
          continue;
        case 43:
          if (tag !== 344) {
            break;
          }

          message.botDifficultyDire = reader.int32() as any;
          continue;
        case 44:
          if (tag !== 352) {
            break;
          }

          message.botRadiant = longToString(reader.uint64() as Long);
          continue;
        case 45:
          if (tag !== 360) {
            break;
          }

          message.botDire = longToString(reader.uint64() as Long);
          continue;
        case 46:
          if (tag !== 368) {
            break;
          }

          message.selectionPriorityRules = reader.int32() as any;
          continue;
        case 47:
          if (tag !== 376) {
            break;
          }

          message.customGamePenalties = reader.bool();
          continue;
        case 48:
          if (tag !== 386) {
            break;
          }

          message.lanHostPingLocation = reader.string();
          continue;
        case 49:
          if (tag !== 392) {
            break;
          }

          message.leagueNodeId = reader.uint32();
          continue;
        case 50:
          if (tag === 400) {
            message.requestedHeroIds.push(reader.int32());

            continue;
          }

          if (tag === 402) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.requestedHeroIds.push(reader.int32());
            }

            continue;
          }

          break;
        case 51:
          if (tag !== 410) {
            break;
          }

          message.scenarioSave = CMsgLobbyScenarioSave.decode(reader, reader.uint32());
          continue;
        case 52:
          if (tag !== 418) {
            break;
          }

          message.abilityDraftSpecificDetails = CMsgPracticeLobbySetDetails_AbilityDraftSpecificDetails.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 53:
          if (tag !== 424) {
            break;
          }

          message.doPlayerDraft = reader.bool();
          continue;
        case 54:
          if (tag === 432) {
            message.requestedHeroTeams.push(reader.int32());

            continue;
          }

          if (tag === 434) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.requestedHeroTeams.push(reader.int32());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgPracticeLobbySetDetails {
    return {
      lobbyId: isSet(object.lobbyId) ? globalThis.String(object.lobbyId) : "0",
      gameName: isSet(object.gameName) ? globalThis.String(object.gameName) : "",
      teamDetails: globalThis.Array.isArray(object?.teamDetails)
        ? object.teamDetails.map((e: any) => CLobbyTeamDetails.fromJSON(e))
        : [],
      serverRegion: isSet(object.serverRegion) ? globalThis.Number(object.serverRegion) : 0,
      gameMode: isSet(object.gameMode) ? globalThis.Number(object.gameMode) : 0,
      cmPick: isSet(object.cmPick) ? dotaCmPickFromJSON(object.cmPick) : 0,
      botDifficultyRadiant: isSet(object.botDifficultyRadiant)
        ? dOTABotDifficultyFromJSON(object.botDifficultyRadiant)
        : 0,
      allowCheats: isSet(object.allowCheats) ? globalThis.Boolean(object.allowCheats) : false,
      fillWithBots: isSet(object.fillWithBots) ? globalThis.Boolean(object.fillWithBots) : false,
      allowSpectating: isSet(object.allowSpectating) ? globalThis.Boolean(object.allowSpectating) : false,
      passKey: isSet(object.passKey) ? globalThis.String(object.passKey) : "",
      leagueid: isSet(object.leagueid) ? globalThis.Number(object.leagueid) : 0,
      penaltyLevelRadiant: isSet(object.penaltyLevelRadiant) ? globalThis.Number(object.penaltyLevelRadiant) : 0,
      penaltyLevelDire: isSet(object.penaltyLevelDire) ? globalThis.Number(object.penaltyLevelDire) : 0,
      seriesType: isSet(object.seriesType) ? globalThis.Number(object.seriesType) : 0,
      radiantSeriesWins: isSet(object.radiantSeriesWins) ? globalThis.Number(object.radiantSeriesWins) : 0,
      direSeriesWins: isSet(object.direSeriesWins) ? globalThis.Number(object.direSeriesWins) : 0,
      allchat: isSet(object.allchat) ? globalThis.Boolean(object.allchat) : false,
      dotaTvDelay: isSet(object.dotaTvDelay) ? lobbyDotaTVDelayFromJSON(object.dotaTvDelay) : 1,
      lan: isSet(object.lan) ? globalThis.Boolean(object.lan) : false,
      customGameMode: isSet(object.customGameMode) ? globalThis.String(object.customGameMode) : "",
      customMapName: isSet(object.customMapName) ? globalThis.String(object.customMapName) : "",
      customDifficulty: isSet(object.customDifficulty) ? globalThis.Number(object.customDifficulty) : 0,
      customGameId: isSet(object.customGameId) ? globalThis.String(object.customGameId) : "0",
      customMinPlayers: isSet(object.customMinPlayers) ? globalThis.Number(object.customMinPlayers) : 0,
      customMaxPlayers: isSet(object.customMaxPlayers) ? globalThis.Number(object.customMaxPlayers) : 0,
      visibility: isSet(object.visibility) ? dOTALobbyVisibilityFromJSON(object.visibility) : 0,
      customGameCrc: isSet(object.customGameCrc) ? globalThis.String(object.customGameCrc) : "0",
      customGameTimestamp: isSet(object.customGameTimestamp) ? globalThis.Number(object.customGameTimestamp) : 0,
      previousMatchOverride: isSet(object.previousMatchOverride)
        ? globalThis.String(object.previousMatchOverride)
        : "0",
      pauseSetting: isSet(object.pauseSetting) ? lobbyDotaPauseSettingFromJSON(object.pauseSetting) : 0,
      botDifficultyDire: isSet(object.botDifficultyDire) ? dOTABotDifficultyFromJSON(object.botDifficultyDire) : 0,
      botRadiant: isSet(object.botRadiant) ? globalThis.String(object.botRadiant) : "0",
      botDire: isSet(object.botDire) ? globalThis.String(object.botDire) : "0",
      selectionPriorityRules: isSet(object.selectionPriorityRules)
        ? dOTASelectionPriorityRulesFromJSON(object.selectionPriorityRules)
        : 0,
      customGamePenalties: isSet(object.customGamePenalties) ? globalThis.Boolean(object.customGamePenalties) : false,
      lanHostPingLocation: isSet(object.lanHostPingLocation) ? globalThis.String(object.lanHostPingLocation) : "",
      leagueNodeId: isSet(object.leagueNodeId) ? globalThis.Number(object.leagueNodeId) : 0,
      requestedHeroIds: globalThis.Array.isArray(object?.requestedHeroIds)
        ? object.requestedHeroIds.map((e: any) => globalThis.Number(e))
        : [],
      scenarioSave: isSet(object.scenarioSave) ? CMsgLobbyScenarioSave.fromJSON(object.scenarioSave) : undefined,
      abilityDraftSpecificDetails: isSet(object.abilityDraftSpecificDetails)
        ? CMsgPracticeLobbySetDetails_AbilityDraftSpecificDetails.fromJSON(object.abilityDraftSpecificDetails)
        : undefined,
      doPlayerDraft: isSet(object.doPlayerDraft) ? globalThis.Boolean(object.doPlayerDraft) : false,
      requestedHeroTeams: globalThis.Array.isArray(object?.requestedHeroTeams)
        ? object.requestedHeroTeams.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: CMsgPracticeLobbySetDetails): unknown {
    const obj: any = {};
    if (message.lobbyId !== undefined && message.lobbyId !== "0") {
      obj.lobbyId = message.lobbyId;
    }
    if (message.gameName !== undefined && message.gameName !== "") {
      obj.gameName = message.gameName;
    }
    if (message.teamDetails?.length) {
      obj.teamDetails = message.teamDetails.map((e) => CLobbyTeamDetails.toJSON(e));
    }
    if (message.serverRegion !== undefined && message.serverRegion !== 0) {
      obj.serverRegion = Math.round(message.serverRegion);
    }
    if (message.gameMode !== undefined && message.gameMode !== 0) {
      obj.gameMode = Math.round(message.gameMode);
    }
    if (message.cmPick !== undefined && message.cmPick !== 0) {
      obj.cmPick = dotaCmPickToJSON(message.cmPick);
    }
    if (message.botDifficultyRadiant !== undefined && message.botDifficultyRadiant !== 0) {
      obj.botDifficultyRadiant = dOTABotDifficultyToJSON(message.botDifficultyRadiant);
    }
    if (message.allowCheats !== undefined && message.allowCheats !== false) {
      obj.allowCheats = message.allowCheats;
    }
    if (message.fillWithBots !== undefined && message.fillWithBots !== false) {
      obj.fillWithBots = message.fillWithBots;
    }
    if (message.allowSpectating !== undefined && message.allowSpectating !== false) {
      obj.allowSpectating = message.allowSpectating;
    }
    if (message.passKey !== undefined && message.passKey !== "") {
      obj.passKey = message.passKey;
    }
    if (message.leagueid !== undefined && message.leagueid !== 0) {
      obj.leagueid = Math.round(message.leagueid);
    }
    if (message.penaltyLevelRadiant !== undefined && message.penaltyLevelRadiant !== 0) {
      obj.penaltyLevelRadiant = Math.round(message.penaltyLevelRadiant);
    }
    if (message.penaltyLevelDire !== undefined && message.penaltyLevelDire !== 0) {
      obj.penaltyLevelDire = Math.round(message.penaltyLevelDire);
    }
    if (message.seriesType !== undefined && message.seriesType !== 0) {
      obj.seriesType = Math.round(message.seriesType);
    }
    if (message.radiantSeriesWins !== undefined && message.radiantSeriesWins !== 0) {
      obj.radiantSeriesWins = Math.round(message.radiantSeriesWins);
    }
    if (message.direSeriesWins !== undefined && message.direSeriesWins !== 0) {
      obj.direSeriesWins = Math.round(message.direSeriesWins);
    }
    if (message.allchat !== undefined && message.allchat !== false) {
      obj.allchat = message.allchat;
    }
    if (message.dotaTvDelay !== undefined && message.dotaTvDelay !== 1) {
      obj.dotaTvDelay = lobbyDotaTVDelayToJSON(message.dotaTvDelay);
    }
    if (message.lan !== undefined && message.lan !== false) {
      obj.lan = message.lan;
    }
    if (message.customGameMode !== undefined && message.customGameMode !== "") {
      obj.customGameMode = message.customGameMode;
    }
    if (message.customMapName !== undefined && message.customMapName !== "") {
      obj.customMapName = message.customMapName;
    }
    if (message.customDifficulty !== undefined && message.customDifficulty !== 0) {
      obj.customDifficulty = Math.round(message.customDifficulty);
    }
    if (message.customGameId !== undefined && message.customGameId !== "0") {
      obj.customGameId = message.customGameId;
    }
    if (message.customMinPlayers !== undefined && message.customMinPlayers !== 0) {
      obj.customMinPlayers = Math.round(message.customMinPlayers);
    }
    if (message.customMaxPlayers !== undefined && message.customMaxPlayers !== 0) {
      obj.customMaxPlayers = Math.round(message.customMaxPlayers);
    }
    if (message.visibility !== undefined && message.visibility !== 0) {
      obj.visibility = dOTALobbyVisibilityToJSON(message.visibility);
    }
    if (message.customGameCrc !== undefined && message.customGameCrc !== "0") {
      obj.customGameCrc = message.customGameCrc;
    }
    if (message.customGameTimestamp !== undefined && message.customGameTimestamp !== 0) {
      obj.customGameTimestamp = Math.round(message.customGameTimestamp);
    }
    if (message.previousMatchOverride !== undefined && message.previousMatchOverride !== "0") {
      obj.previousMatchOverride = message.previousMatchOverride;
    }
    if (message.pauseSetting !== undefined && message.pauseSetting !== 0) {
      obj.pauseSetting = lobbyDotaPauseSettingToJSON(message.pauseSetting);
    }
    if (message.botDifficultyDire !== undefined && message.botDifficultyDire !== 0) {
      obj.botDifficultyDire = dOTABotDifficultyToJSON(message.botDifficultyDire);
    }
    if (message.botRadiant !== undefined && message.botRadiant !== "0") {
      obj.botRadiant = message.botRadiant;
    }
    if (message.botDire !== undefined && message.botDire !== "0") {
      obj.botDire = message.botDire;
    }
    if (message.selectionPriorityRules !== undefined && message.selectionPriorityRules !== 0) {
      obj.selectionPriorityRules = dOTASelectionPriorityRulesToJSON(message.selectionPriorityRules);
    }
    if (message.customGamePenalties !== undefined && message.customGamePenalties !== false) {
      obj.customGamePenalties = message.customGamePenalties;
    }
    if (message.lanHostPingLocation !== undefined && message.lanHostPingLocation !== "") {
      obj.lanHostPingLocation = message.lanHostPingLocation;
    }
    if (message.leagueNodeId !== undefined && message.leagueNodeId !== 0) {
      obj.leagueNodeId = Math.round(message.leagueNodeId);
    }
    if (message.requestedHeroIds?.length) {
      obj.requestedHeroIds = message.requestedHeroIds.map((e) => Math.round(e));
    }
    if (message.scenarioSave !== undefined) {
      obj.scenarioSave = CMsgLobbyScenarioSave.toJSON(message.scenarioSave);
    }
    if (message.abilityDraftSpecificDetails !== undefined) {
      obj.abilityDraftSpecificDetails = CMsgPracticeLobbySetDetails_AbilityDraftSpecificDetails.toJSON(
        message.abilityDraftSpecificDetails,
      );
    }
    if (message.doPlayerDraft !== undefined && message.doPlayerDraft !== false) {
      obj.doPlayerDraft = message.doPlayerDraft;
    }
    if (message.requestedHeroTeams?.length) {
      obj.requestedHeroTeams = message.requestedHeroTeams.map((e) => Math.round(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgPracticeLobbySetDetails>): CMsgPracticeLobbySetDetails {
    return CMsgPracticeLobbySetDetails.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgPracticeLobbySetDetails>): CMsgPracticeLobbySetDetails {
    const message = createBaseCMsgPracticeLobbySetDetails();
    message.lobbyId = object.lobbyId ?? "0";
    message.gameName = object.gameName ?? "";
    message.teamDetails = object.teamDetails?.map((e) => CLobbyTeamDetails.fromPartial(e)) || [];
    message.serverRegion = object.serverRegion ?? 0;
    message.gameMode = object.gameMode ?? 0;
    message.cmPick = object.cmPick ?? 0;
    message.botDifficultyRadiant = object.botDifficultyRadiant ?? 0;
    message.allowCheats = object.allowCheats ?? false;
    message.fillWithBots = object.fillWithBots ?? false;
    message.allowSpectating = object.allowSpectating ?? false;
    message.passKey = object.passKey ?? "";
    message.leagueid = object.leagueid ?? 0;
    message.penaltyLevelRadiant = object.penaltyLevelRadiant ?? 0;
    message.penaltyLevelDire = object.penaltyLevelDire ?? 0;
    message.seriesType = object.seriesType ?? 0;
    message.radiantSeriesWins = object.radiantSeriesWins ?? 0;
    message.direSeriesWins = object.direSeriesWins ?? 0;
    message.allchat = object.allchat ?? false;
    message.dotaTvDelay = object.dotaTvDelay ?? 1;
    message.lan = object.lan ?? false;
    message.customGameMode = object.customGameMode ?? "";
    message.customMapName = object.customMapName ?? "";
    message.customDifficulty = object.customDifficulty ?? 0;
    message.customGameId = object.customGameId ?? "0";
    message.customMinPlayers = object.customMinPlayers ?? 0;
    message.customMaxPlayers = object.customMaxPlayers ?? 0;
    message.visibility = object.visibility ?? 0;
    message.customGameCrc = object.customGameCrc ?? "0";
    message.customGameTimestamp = object.customGameTimestamp ?? 0;
    message.previousMatchOverride = object.previousMatchOverride ?? "0";
    message.pauseSetting = object.pauseSetting ?? 0;
    message.botDifficultyDire = object.botDifficultyDire ?? 0;
    message.botRadiant = object.botRadiant ?? "0";
    message.botDire = object.botDire ?? "0";
    message.selectionPriorityRules = object.selectionPriorityRules ?? 0;
    message.customGamePenalties = object.customGamePenalties ?? false;
    message.lanHostPingLocation = object.lanHostPingLocation ?? "";
    message.leagueNodeId = object.leagueNodeId ?? 0;
    message.requestedHeroIds = object.requestedHeroIds?.map((e) => e) || [];
    message.scenarioSave = (object.scenarioSave !== undefined && object.scenarioSave !== null)
      ? CMsgLobbyScenarioSave.fromPartial(object.scenarioSave)
      : undefined;
    message.abilityDraftSpecificDetails =
      (object.abilityDraftSpecificDetails !== undefined && object.abilityDraftSpecificDetails !== null)
        ? CMsgPracticeLobbySetDetails_AbilityDraftSpecificDetails.fromPartial(object.abilityDraftSpecificDetails)
        : undefined;
    message.doPlayerDraft = object.doPlayerDraft ?? false;
    message.requestedHeroTeams = object.requestedHeroTeams?.map((e) => e) || [];
    return message;
  },
};

function createBaseCMsgPracticeLobbySetDetails_AbilityDraftSpecificDetails(): CMsgPracticeLobbySetDetails_AbilityDraftSpecificDetails {
  return { shuffleDraftOrder: false };
}

export const CMsgPracticeLobbySetDetails_AbilityDraftSpecificDetails = {
  encode(
    message: CMsgPracticeLobbySetDetails_AbilityDraftSpecificDetails,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.shuffleDraftOrder !== undefined && message.shuffleDraftOrder !== false) {
      writer.uint32(8).bool(message.shuffleDraftOrder);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgPracticeLobbySetDetails_AbilityDraftSpecificDetails {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgPracticeLobbySetDetails_AbilityDraftSpecificDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.shuffleDraftOrder = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgPracticeLobbySetDetails_AbilityDraftSpecificDetails {
    return {
      shuffleDraftOrder: isSet(object.shuffleDraftOrder) ? globalThis.Boolean(object.shuffleDraftOrder) : false,
    };
  },

  toJSON(message: CMsgPracticeLobbySetDetails_AbilityDraftSpecificDetails): unknown {
    const obj: any = {};
    if (message.shuffleDraftOrder !== undefined && message.shuffleDraftOrder !== false) {
      obj.shuffleDraftOrder = message.shuffleDraftOrder;
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgPracticeLobbySetDetails_AbilityDraftSpecificDetails>,
  ): CMsgPracticeLobbySetDetails_AbilityDraftSpecificDetails {
    return CMsgPracticeLobbySetDetails_AbilityDraftSpecificDetails.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgPracticeLobbySetDetails_AbilityDraftSpecificDetails>,
  ): CMsgPracticeLobbySetDetails_AbilityDraftSpecificDetails {
    const message = createBaseCMsgPracticeLobbySetDetails_AbilityDraftSpecificDetails();
    message.shuffleDraftOrder = object.shuffleDraftOrder ?? false;
    return message;
  },
};

function createBaseCMsgPracticeLobbyCreate(): CMsgPracticeLobbyCreate {
  return { searchKey: "", passKey: "", clientVersion: 0, lobbyDetails: undefined };
}

export const CMsgPracticeLobbyCreate = {
  encode(message: CMsgPracticeLobbyCreate, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.searchKey !== undefined && message.searchKey !== "") {
      writer.uint32(10).string(message.searchKey);
    }
    if (message.passKey !== undefined && message.passKey !== "") {
      writer.uint32(42).string(message.passKey);
    }
    if (message.clientVersion !== undefined && message.clientVersion !== 0) {
      writer.uint32(48).uint32(message.clientVersion);
    }
    if (message.lobbyDetails !== undefined) {
      CMsgPracticeLobbySetDetails.encode(message.lobbyDetails, writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgPracticeLobbyCreate {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgPracticeLobbyCreate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.searchKey = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.passKey = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.clientVersion = reader.uint32();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.lobbyDetails = CMsgPracticeLobbySetDetails.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgPracticeLobbyCreate {
    return {
      searchKey: isSet(object.searchKey) ? globalThis.String(object.searchKey) : "",
      passKey: isSet(object.passKey) ? globalThis.String(object.passKey) : "",
      clientVersion: isSet(object.clientVersion) ? globalThis.Number(object.clientVersion) : 0,
      lobbyDetails: isSet(object.lobbyDetails) ? CMsgPracticeLobbySetDetails.fromJSON(object.lobbyDetails) : undefined,
    };
  },

  toJSON(message: CMsgPracticeLobbyCreate): unknown {
    const obj: any = {};
    if (message.searchKey !== undefined && message.searchKey !== "") {
      obj.searchKey = message.searchKey;
    }
    if (message.passKey !== undefined && message.passKey !== "") {
      obj.passKey = message.passKey;
    }
    if (message.clientVersion !== undefined && message.clientVersion !== 0) {
      obj.clientVersion = Math.round(message.clientVersion);
    }
    if (message.lobbyDetails !== undefined) {
      obj.lobbyDetails = CMsgPracticeLobbySetDetails.toJSON(message.lobbyDetails);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgPracticeLobbyCreate>): CMsgPracticeLobbyCreate {
    return CMsgPracticeLobbyCreate.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgPracticeLobbyCreate>): CMsgPracticeLobbyCreate {
    const message = createBaseCMsgPracticeLobbyCreate();
    message.searchKey = object.searchKey ?? "";
    message.passKey = object.passKey ?? "";
    message.clientVersion = object.clientVersion ?? 0;
    message.lobbyDetails = (object.lobbyDetails !== undefined && object.lobbyDetails !== null)
      ? CMsgPracticeLobbySetDetails.fromPartial(object.lobbyDetails)
      : undefined;
    return message;
  },
};

function createBaseCMsgPracticeLobbySetTeamSlot(): CMsgPracticeLobbySetTeamSlot {
  return { team: 0, slot: 0, botDifficulty: 0 };
}

export const CMsgPracticeLobbySetTeamSlot = {
  encode(message: CMsgPracticeLobbySetTeamSlot, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.team !== undefined && message.team !== 0) {
      writer.uint32(8).int32(message.team);
    }
    if (message.slot !== undefined && message.slot !== 0) {
      writer.uint32(16).uint32(message.slot);
    }
    if (message.botDifficulty !== undefined && message.botDifficulty !== 0) {
      writer.uint32(24).int32(message.botDifficulty);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgPracticeLobbySetTeamSlot {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgPracticeLobbySetTeamSlot();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.team = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.slot = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.botDifficulty = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgPracticeLobbySetTeamSlot {
    return {
      team: isSet(object.team) ? dotaGcTeamFromJSON(object.team) : 0,
      slot: isSet(object.slot) ? globalThis.Number(object.slot) : 0,
      botDifficulty: isSet(object.botDifficulty) ? dOTABotDifficultyFromJSON(object.botDifficulty) : 0,
    };
  },

  toJSON(message: CMsgPracticeLobbySetTeamSlot): unknown {
    const obj: any = {};
    if (message.team !== undefined && message.team !== 0) {
      obj.team = dotaGcTeamToJSON(message.team);
    }
    if (message.slot !== undefined && message.slot !== 0) {
      obj.slot = Math.round(message.slot);
    }
    if (message.botDifficulty !== undefined && message.botDifficulty !== 0) {
      obj.botDifficulty = dOTABotDifficultyToJSON(message.botDifficulty);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgPracticeLobbySetTeamSlot>): CMsgPracticeLobbySetTeamSlot {
    return CMsgPracticeLobbySetTeamSlot.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgPracticeLobbySetTeamSlot>): CMsgPracticeLobbySetTeamSlot {
    const message = createBaseCMsgPracticeLobbySetTeamSlot();
    message.team = object.team ?? 0;
    message.slot = object.slot ?? 0;
    message.botDifficulty = object.botDifficulty ?? 0;
    return message;
  },
};

function createBaseCMsgPracticeLobbySetCoach(): CMsgPracticeLobbySetCoach {
  return { team: 0 };
}

export const CMsgPracticeLobbySetCoach = {
  encode(message: CMsgPracticeLobbySetCoach, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.team !== undefined && message.team !== 0) {
      writer.uint32(8).int32(message.team);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgPracticeLobbySetCoach {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgPracticeLobbySetCoach();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.team = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgPracticeLobbySetCoach {
    return { team: isSet(object.team) ? dotaGcTeamFromJSON(object.team) : 0 };
  },

  toJSON(message: CMsgPracticeLobbySetCoach): unknown {
    const obj: any = {};
    if (message.team !== undefined && message.team !== 0) {
      obj.team = dotaGcTeamToJSON(message.team);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgPracticeLobbySetCoach>): CMsgPracticeLobbySetCoach {
    return CMsgPracticeLobbySetCoach.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgPracticeLobbySetCoach>): CMsgPracticeLobbySetCoach {
    const message = createBaseCMsgPracticeLobbySetCoach();
    message.team = object.team ?? 0;
    return message;
  },
};

function createBaseCMsgPracticeLobbyJoinBroadcastChannel(): CMsgPracticeLobbyJoinBroadcastChannel {
  return { channel: 0, preferredDescription: "", preferredCountryCode: "", preferredLanguageCode: "" };
}

export const CMsgPracticeLobbyJoinBroadcastChannel = {
  encode(message: CMsgPracticeLobbyJoinBroadcastChannel, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.channel !== undefined && message.channel !== 0) {
      writer.uint32(8).uint32(message.channel);
    }
    if (message.preferredDescription !== undefined && message.preferredDescription !== "") {
      writer.uint32(18).string(message.preferredDescription);
    }
    if (message.preferredCountryCode !== undefined && message.preferredCountryCode !== "") {
      writer.uint32(26).string(message.preferredCountryCode);
    }
    if (message.preferredLanguageCode !== undefined && message.preferredLanguageCode !== "") {
      writer.uint32(34).string(message.preferredLanguageCode);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgPracticeLobbyJoinBroadcastChannel {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgPracticeLobbyJoinBroadcastChannel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.channel = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.preferredDescription = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.preferredCountryCode = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.preferredLanguageCode = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgPracticeLobbyJoinBroadcastChannel {
    return {
      channel: isSet(object.channel) ? globalThis.Number(object.channel) : 0,
      preferredDescription: isSet(object.preferredDescription) ? globalThis.String(object.preferredDescription) : "",
      preferredCountryCode: isSet(object.preferredCountryCode) ? globalThis.String(object.preferredCountryCode) : "",
      preferredLanguageCode: isSet(object.preferredLanguageCode) ? globalThis.String(object.preferredLanguageCode) : "",
    };
  },

  toJSON(message: CMsgPracticeLobbyJoinBroadcastChannel): unknown {
    const obj: any = {};
    if (message.channel !== undefined && message.channel !== 0) {
      obj.channel = Math.round(message.channel);
    }
    if (message.preferredDescription !== undefined && message.preferredDescription !== "") {
      obj.preferredDescription = message.preferredDescription;
    }
    if (message.preferredCountryCode !== undefined && message.preferredCountryCode !== "") {
      obj.preferredCountryCode = message.preferredCountryCode;
    }
    if (message.preferredLanguageCode !== undefined && message.preferredLanguageCode !== "") {
      obj.preferredLanguageCode = message.preferredLanguageCode;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgPracticeLobbyJoinBroadcastChannel>): CMsgPracticeLobbyJoinBroadcastChannel {
    return CMsgPracticeLobbyJoinBroadcastChannel.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgPracticeLobbyJoinBroadcastChannel>): CMsgPracticeLobbyJoinBroadcastChannel {
    const message = createBaseCMsgPracticeLobbyJoinBroadcastChannel();
    message.channel = object.channel ?? 0;
    message.preferredDescription = object.preferredDescription ?? "";
    message.preferredCountryCode = object.preferredCountryCode ?? "";
    message.preferredLanguageCode = object.preferredLanguageCode ?? "";
    return message;
  },
};

function createBaseCMsgPracticeLobbyCloseBroadcastChannel(): CMsgPracticeLobbyCloseBroadcastChannel {
  return { channel: 0 };
}

export const CMsgPracticeLobbyCloseBroadcastChannel = {
  encode(message: CMsgPracticeLobbyCloseBroadcastChannel, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.channel !== undefined && message.channel !== 0) {
      writer.uint32(8).uint32(message.channel);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgPracticeLobbyCloseBroadcastChannel {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgPracticeLobbyCloseBroadcastChannel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.channel = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgPracticeLobbyCloseBroadcastChannel {
    return { channel: isSet(object.channel) ? globalThis.Number(object.channel) : 0 };
  },

  toJSON(message: CMsgPracticeLobbyCloseBroadcastChannel): unknown {
    const obj: any = {};
    if (message.channel !== undefined && message.channel !== 0) {
      obj.channel = Math.round(message.channel);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgPracticeLobbyCloseBroadcastChannel>): CMsgPracticeLobbyCloseBroadcastChannel {
    return CMsgPracticeLobbyCloseBroadcastChannel.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgPracticeLobbyCloseBroadcastChannel>): CMsgPracticeLobbyCloseBroadcastChannel {
    const message = createBaseCMsgPracticeLobbyCloseBroadcastChannel();
    message.channel = object.channel ?? 0;
    return message;
  },
};

function createBaseCMsgPracticeLobbyToggleBroadcastChannelCameramanStatus(): CMsgPracticeLobbyToggleBroadcastChannelCameramanStatus {
  return {};
}

export const CMsgPracticeLobbyToggleBroadcastChannelCameramanStatus = {
  encode(
    _: CMsgPracticeLobbyToggleBroadcastChannelCameramanStatus,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgPracticeLobbyToggleBroadcastChannelCameramanStatus {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgPracticeLobbyToggleBroadcastChannelCameramanStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CMsgPracticeLobbyToggleBroadcastChannelCameramanStatus {
    return {};
  },

  toJSON(_: CMsgPracticeLobbyToggleBroadcastChannelCameramanStatus): unknown {
    const obj: any = {};
    return obj;
  },

  create(
    base?: DeepPartial<CMsgPracticeLobbyToggleBroadcastChannelCameramanStatus>,
  ): CMsgPracticeLobbyToggleBroadcastChannelCameramanStatus {
    return CMsgPracticeLobbyToggleBroadcastChannelCameramanStatus.fromPartial(base ?? {});
  },
  fromPartial(
    _: DeepPartial<CMsgPracticeLobbyToggleBroadcastChannelCameramanStatus>,
  ): CMsgPracticeLobbyToggleBroadcastChannelCameramanStatus {
    const message = createBaseCMsgPracticeLobbyToggleBroadcastChannelCameramanStatus();
    return message;
  },
};

function createBaseCMsgPracticeLobbyKick(): CMsgPracticeLobbyKick {
  return { accountId: 0 };
}

export const CMsgPracticeLobbyKick = {
  encode(message: CMsgPracticeLobbyKick, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.accountId !== undefined && message.accountId !== 0) {
      writer.uint32(24).uint32(message.accountId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgPracticeLobbyKick {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgPracticeLobbyKick();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 24) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgPracticeLobbyKick {
    return { accountId: isSet(object.accountId) ? globalThis.Number(object.accountId) : 0 };
  },

  toJSON(message: CMsgPracticeLobbyKick): unknown {
    const obj: any = {};
    if (message.accountId !== undefined && message.accountId !== 0) {
      obj.accountId = Math.round(message.accountId);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgPracticeLobbyKick>): CMsgPracticeLobbyKick {
    return CMsgPracticeLobbyKick.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgPracticeLobbyKick>): CMsgPracticeLobbyKick {
    const message = createBaseCMsgPracticeLobbyKick();
    message.accountId = object.accountId ?? 0;
    return message;
  },
};

function createBaseCMsgPracticeLobbyKickFromTeam(): CMsgPracticeLobbyKickFromTeam {
  return { accountId: 0 };
}

export const CMsgPracticeLobbyKickFromTeam = {
  encode(message: CMsgPracticeLobbyKickFromTeam, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.accountId !== undefined && message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgPracticeLobbyKickFromTeam {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgPracticeLobbyKickFromTeam();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgPracticeLobbyKickFromTeam {
    return { accountId: isSet(object.accountId) ? globalThis.Number(object.accountId) : 0 };
  },

  toJSON(message: CMsgPracticeLobbyKickFromTeam): unknown {
    const obj: any = {};
    if (message.accountId !== undefined && message.accountId !== 0) {
      obj.accountId = Math.round(message.accountId);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgPracticeLobbyKickFromTeam>): CMsgPracticeLobbyKickFromTeam {
    return CMsgPracticeLobbyKickFromTeam.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgPracticeLobbyKickFromTeam>): CMsgPracticeLobbyKickFromTeam {
    const message = createBaseCMsgPracticeLobbyKickFromTeam();
    message.accountId = object.accountId ?? 0;
    return message;
  },
};

function createBaseCMsgPracticeLobbyLeave(): CMsgPracticeLobbyLeave {
  return {};
}

export const CMsgPracticeLobbyLeave = {
  encode(_: CMsgPracticeLobbyLeave, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgPracticeLobbyLeave {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgPracticeLobbyLeave();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CMsgPracticeLobbyLeave {
    return {};
  },

  toJSON(_: CMsgPracticeLobbyLeave): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<CMsgPracticeLobbyLeave>): CMsgPracticeLobbyLeave {
    return CMsgPracticeLobbyLeave.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<CMsgPracticeLobbyLeave>): CMsgPracticeLobbyLeave {
    const message = createBaseCMsgPracticeLobbyLeave();
    return message;
  },
};

function createBaseCMsgPracticeLobbyLaunch(): CMsgPracticeLobbyLaunch {
  return { clientVersion: 0 };
}

export const CMsgPracticeLobbyLaunch = {
  encode(message: CMsgPracticeLobbyLaunch, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.clientVersion !== undefined && message.clientVersion !== 0) {
      writer.uint32(40).uint32(message.clientVersion);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgPracticeLobbyLaunch {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgPracticeLobbyLaunch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 5:
          if (tag !== 40) {
            break;
          }

          message.clientVersion = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgPracticeLobbyLaunch {
    return { clientVersion: isSet(object.clientVersion) ? globalThis.Number(object.clientVersion) : 0 };
  },

  toJSON(message: CMsgPracticeLobbyLaunch): unknown {
    const obj: any = {};
    if (message.clientVersion !== undefined && message.clientVersion !== 0) {
      obj.clientVersion = Math.round(message.clientVersion);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgPracticeLobbyLaunch>): CMsgPracticeLobbyLaunch {
    return CMsgPracticeLobbyLaunch.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgPracticeLobbyLaunch>): CMsgPracticeLobbyLaunch {
    const message = createBaseCMsgPracticeLobbyLaunch();
    message.clientVersion = object.clientVersion ?? 0;
    return message;
  },
};

function createBaseCMsgApplyTeamToPracticeLobby(): CMsgApplyTeamToPracticeLobby {
  return { teamId: 0 };
}

export const CMsgApplyTeamToPracticeLobby = {
  encode(message: CMsgApplyTeamToPracticeLobby, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.teamId !== undefined && message.teamId !== 0) {
      writer.uint32(8).uint32(message.teamId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgApplyTeamToPracticeLobby {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgApplyTeamToPracticeLobby();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.teamId = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgApplyTeamToPracticeLobby {
    return { teamId: isSet(object.teamId) ? globalThis.Number(object.teamId) : 0 };
  },

  toJSON(message: CMsgApplyTeamToPracticeLobby): unknown {
    const obj: any = {};
    if (message.teamId !== undefined && message.teamId !== 0) {
      obj.teamId = Math.round(message.teamId);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgApplyTeamToPracticeLobby>): CMsgApplyTeamToPracticeLobby {
    return CMsgApplyTeamToPracticeLobby.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgApplyTeamToPracticeLobby>): CMsgApplyTeamToPracticeLobby {
    const message = createBaseCMsgApplyTeamToPracticeLobby();
    message.teamId = object.teamId ?? 0;
    return message;
  },
};

function createBaseCMsgPracticeLobbyList(): CMsgPracticeLobbyList {
  return { passKey: "", region: 0, gameMode: 0 };
}

export const CMsgPracticeLobbyList = {
  encode(message: CMsgPracticeLobbyList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.passKey !== undefined && message.passKey !== "") {
      writer.uint32(18).string(message.passKey);
    }
    if (message.region !== undefined && message.region !== 0) {
      writer.uint32(24).uint32(message.region);
    }
    if (message.gameMode !== undefined && message.gameMode !== 0) {
      writer.uint32(32).int32(message.gameMode);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgPracticeLobbyList {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgPracticeLobbyList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.passKey = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.region = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.gameMode = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgPracticeLobbyList {
    return {
      passKey: isSet(object.passKey) ? globalThis.String(object.passKey) : "",
      region: isSet(object.region) ? globalThis.Number(object.region) : 0,
      gameMode: isSet(object.gameMode) ? dOTAGameModeFromJSON(object.gameMode) : 0,
    };
  },

  toJSON(message: CMsgPracticeLobbyList): unknown {
    const obj: any = {};
    if (message.passKey !== undefined && message.passKey !== "") {
      obj.passKey = message.passKey;
    }
    if (message.region !== undefined && message.region !== 0) {
      obj.region = Math.round(message.region);
    }
    if (message.gameMode !== undefined && message.gameMode !== 0) {
      obj.gameMode = dOTAGameModeToJSON(message.gameMode);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgPracticeLobbyList>): CMsgPracticeLobbyList {
    return CMsgPracticeLobbyList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgPracticeLobbyList>): CMsgPracticeLobbyList {
    const message = createBaseCMsgPracticeLobbyList();
    message.passKey = object.passKey ?? "";
    message.region = object.region ?? 0;
    message.gameMode = object.gameMode ?? 0;
    return message;
  },
};

function createBaseCMsgPracticeLobbyListResponseEntry(): CMsgPracticeLobbyListResponseEntry {
  return {
    id: "0",
    members: [],
    requiresPassKey: false,
    leaderAccountId: 0,
    name: "",
    customGameMode: "",
    gameMode: 0,
    friendPresent: false,
    players: 0,
    customMapName: "",
    maxPlayerCount: 0,
    serverRegion: 0,
    leagueId: 0,
    lanHostPingLocation: "",
    minPlayerCount: 0,
    penaltiesEnabled: false,
  };
}

export const CMsgPracticeLobbyListResponseEntry = {
  encode(message: CMsgPracticeLobbyListResponseEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== undefined && message.id !== "0") {
      writer.uint32(8).uint64(message.id);
    }
    for (const v of message.members) {
      CMsgPracticeLobbyListResponseEntry_CLobbyMember.encode(v!, writer.uint32(42).fork()).ldelim();
    }
    if (message.requiresPassKey !== undefined && message.requiresPassKey !== false) {
      writer.uint32(48).bool(message.requiresPassKey);
    }
    if (message.leaderAccountId !== undefined && message.leaderAccountId !== 0) {
      writer.uint32(56).uint32(message.leaderAccountId);
    }
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(82).string(message.name);
    }
    if (message.customGameMode !== undefined && message.customGameMode !== "") {
      writer.uint32(90).string(message.customGameMode);
    }
    if (message.gameMode !== undefined && message.gameMode !== 0) {
      writer.uint32(96).int32(message.gameMode);
    }
    if (message.friendPresent !== undefined && message.friendPresent !== false) {
      writer.uint32(104).bool(message.friendPresent);
    }
    if (message.players !== undefined && message.players !== 0) {
      writer.uint32(112).uint32(message.players);
    }
    if (message.customMapName !== undefined && message.customMapName !== "") {
      writer.uint32(122).string(message.customMapName);
    }
    if (message.maxPlayerCount !== undefined && message.maxPlayerCount !== 0) {
      writer.uint32(128).uint32(message.maxPlayerCount);
    }
    if (message.serverRegion !== undefined && message.serverRegion !== 0) {
      writer.uint32(136).uint32(message.serverRegion);
    }
    if (message.leagueId !== undefined && message.leagueId !== 0) {
      writer.uint32(152).uint32(message.leagueId);
    }
    if (message.lanHostPingLocation !== undefined && message.lanHostPingLocation !== "") {
      writer.uint32(162).string(message.lanHostPingLocation);
    }
    if (message.minPlayerCount !== undefined && message.minPlayerCount !== 0) {
      writer.uint32(168).uint32(message.minPlayerCount);
    }
    if (message.penaltiesEnabled !== undefined && message.penaltiesEnabled !== false) {
      writer.uint32(176).bool(message.penaltiesEnabled);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgPracticeLobbyListResponseEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgPracticeLobbyListResponseEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = longToString(reader.uint64() as Long);
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.members.push(CMsgPracticeLobbyListResponseEntry_CLobbyMember.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.requiresPassKey = reader.bool();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.leaderAccountId = reader.uint32();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.name = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.customGameMode = reader.string();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.gameMode = reader.int32() as any;
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.friendPresent = reader.bool();
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.players = reader.uint32();
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.customMapName = reader.string();
          continue;
        case 16:
          if (tag !== 128) {
            break;
          }

          message.maxPlayerCount = reader.uint32();
          continue;
        case 17:
          if (tag !== 136) {
            break;
          }

          message.serverRegion = reader.uint32();
          continue;
        case 19:
          if (tag !== 152) {
            break;
          }

          message.leagueId = reader.uint32();
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.lanHostPingLocation = reader.string();
          continue;
        case 21:
          if (tag !== 168) {
            break;
          }

          message.minPlayerCount = reader.uint32();
          continue;
        case 22:
          if (tag !== 176) {
            break;
          }

          message.penaltiesEnabled = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgPracticeLobbyListResponseEntry {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "0",
      members: globalThis.Array.isArray(object?.members)
        ? object.members.map((e: any) => CMsgPracticeLobbyListResponseEntry_CLobbyMember.fromJSON(e))
        : [],
      requiresPassKey: isSet(object.requiresPassKey) ? globalThis.Boolean(object.requiresPassKey) : false,
      leaderAccountId: isSet(object.leaderAccountId) ? globalThis.Number(object.leaderAccountId) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      customGameMode: isSet(object.customGameMode) ? globalThis.String(object.customGameMode) : "",
      gameMode: isSet(object.gameMode) ? dOTAGameModeFromJSON(object.gameMode) : 0,
      friendPresent: isSet(object.friendPresent) ? globalThis.Boolean(object.friendPresent) : false,
      players: isSet(object.players) ? globalThis.Number(object.players) : 0,
      customMapName: isSet(object.customMapName) ? globalThis.String(object.customMapName) : "",
      maxPlayerCount: isSet(object.maxPlayerCount) ? globalThis.Number(object.maxPlayerCount) : 0,
      serverRegion: isSet(object.serverRegion) ? globalThis.Number(object.serverRegion) : 0,
      leagueId: isSet(object.leagueId) ? globalThis.Number(object.leagueId) : 0,
      lanHostPingLocation: isSet(object.lanHostPingLocation) ? globalThis.String(object.lanHostPingLocation) : "",
      minPlayerCount: isSet(object.minPlayerCount) ? globalThis.Number(object.minPlayerCount) : 0,
      penaltiesEnabled: isSet(object.penaltiesEnabled) ? globalThis.Boolean(object.penaltiesEnabled) : false,
    };
  },

  toJSON(message: CMsgPracticeLobbyListResponseEntry): unknown {
    const obj: any = {};
    if (message.id !== undefined && message.id !== "0") {
      obj.id = message.id;
    }
    if (message.members?.length) {
      obj.members = message.members.map((e) => CMsgPracticeLobbyListResponseEntry_CLobbyMember.toJSON(e));
    }
    if (message.requiresPassKey !== undefined && message.requiresPassKey !== false) {
      obj.requiresPassKey = message.requiresPassKey;
    }
    if (message.leaderAccountId !== undefined && message.leaderAccountId !== 0) {
      obj.leaderAccountId = Math.round(message.leaderAccountId);
    }
    if (message.name !== undefined && message.name !== "") {
      obj.name = message.name;
    }
    if (message.customGameMode !== undefined && message.customGameMode !== "") {
      obj.customGameMode = message.customGameMode;
    }
    if (message.gameMode !== undefined && message.gameMode !== 0) {
      obj.gameMode = dOTAGameModeToJSON(message.gameMode);
    }
    if (message.friendPresent !== undefined && message.friendPresent !== false) {
      obj.friendPresent = message.friendPresent;
    }
    if (message.players !== undefined && message.players !== 0) {
      obj.players = Math.round(message.players);
    }
    if (message.customMapName !== undefined && message.customMapName !== "") {
      obj.customMapName = message.customMapName;
    }
    if (message.maxPlayerCount !== undefined && message.maxPlayerCount !== 0) {
      obj.maxPlayerCount = Math.round(message.maxPlayerCount);
    }
    if (message.serverRegion !== undefined && message.serverRegion !== 0) {
      obj.serverRegion = Math.round(message.serverRegion);
    }
    if (message.leagueId !== undefined && message.leagueId !== 0) {
      obj.leagueId = Math.round(message.leagueId);
    }
    if (message.lanHostPingLocation !== undefined && message.lanHostPingLocation !== "") {
      obj.lanHostPingLocation = message.lanHostPingLocation;
    }
    if (message.minPlayerCount !== undefined && message.minPlayerCount !== 0) {
      obj.minPlayerCount = Math.round(message.minPlayerCount);
    }
    if (message.penaltiesEnabled !== undefined && message.penaltiesEnabled !== false) {
      obj.penaltiesEnabled = message.penaltiesEnabled;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgPracticeLobbyListResponseEntry>): CMsgPracticeLobbyListResponseEntry {
    return CMsgPracticeLobbyListResponseEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgPracticeLobbyListResponseEntry>): CMsgPracticeLobbyListResponseEntry {
    const message = createBaseCMsgPracticeLobbyListResponseEntry();
    message.id = object.id ?? "0";
    message.members = object.members?.map((e) => CMsgPracticeLobbyListResponseEntry_CLobbyMember.fromPartial(e)) || [];
    message.requiresPassKey = object.requiresPassKey ?? false;
    message.leaderAccountId = object.leaderAccountId ?? 0;
    message.name = object.name ?? "";
    message.customGameMode = object.customGameMode ?? "";
    message.gameMode = object.gameMode ?? 0;
    message.friendPresent = object.friendPresent ?? false;
    message.players = object.players ?? 0;
    message.customMapName = object.customMapName ?? "";
    message.maxPlayerCount = object.maxPlayerCount ?? 0;
    message.serverRegion = object.serverRegion ?? 0;
    message.leagueId = object.leagueId ?? 0;
    message.lanHostPingLocation = object.lanHostPingLocation ?? "";
    message.minPlayerCount = object.minPlayerCount ?? 0;
    message.penaltiesEnabled = object.penaltiesEnabled ?? false;
    return message;
  },
};

function createBaseCMsgPracticeLobbyListResponseEntry_CLobbyMember(): CMsgPracticeLobbyListResponseEntry_CLobbyMember {
  return { accountId: 0, playerName: "" };
}

export const CMsgPracticeLobbyListResponseEntry_CLobbyMember = {
  encode(
    message: CMsgPracticeLobbyListResponseEntry_CLobbyMember,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.accountId !== undefined && message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    if (message.playerName !== undefined && message.playerName !== "") {
      writer.uint32(18).string(message.playerName);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgPracticeLobbyListResponseEntry_CLobbyMember {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgPracticeLobbyListResponseEntry_CLobbyMember();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.playerName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgPracticeLobbyListResponseEntry_CLobbyMember {
    return {
      accountId: isSet(object.accountId) ? globalThis.Number(object.accountId) : 0,
      playerName: isSet(object.playerName) ? globalThis.String(object.playerName) : "",
    };
  },

  toJSON(message: CMsgPracticeLobbyListResponseEntry_CLobbyMember): unknown {
    const obj: any = {};
    if (message.accountId !== undefined && message.accountId !== 0) {
      obj.accountId = Math.round(message.accountId);
    }
    if (message.playerName !== undefined && message.playerName !== "") {
      obj.playerName = message.playerName;
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgPracticeLobbyListResponseEntry_CLobbyMember>,
  ): CMsgPracticeLobbyListResponseEntry_CLobbyMember {
    return CMsgPracticeLobbyListResponseEntry_CLobbyMember.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgPracticeLobbyListResponseEntry_CLobbyMember>,
  ): CMsgPracticeLobbyListResponseEntry_CLobbyMember {
    const message = createBaseCMsgPracticeLobbyListResponseEntry_CLobbyMember();
    message.accountId = object.accountId ?? 0;
    message.playerName = object.playerName ?? "";
    return message;
  },
};

function createBaseCMsgPracticeLobbyListResponse(): CMsgPracticeLobbyListResponse {
  return { lobbies: [] };
}

export const CMsgPracticeLobbyListResponse = {
  encode(message: CMsgPracticeLobbyListResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.lobbies) {
      CMsgPracticeLobbyListResponseEntry.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgPracticeLobbyListResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgPracticeLobbyListResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.lobbies.push(CMsgPracticeLobbyListResponseEntry.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgPracticeLobbyListResponse {
    return {
      lobbies: globalThis.Array.isArray(object?.lobbies)
        ? object.lobbies.map((e: any) => CMsgPracticeLobbyListResponseEntry.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgPracticeLobbyListResponse): unknown {
    const obj: any = {};
    if (message.lobbies?.length) {
      obj.lobbies = message.lobbies.map((e) => CMsgPracticeLobbyListResponseEntry.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgPracticeLobbyListResponse>): CMsgPracticeLobbyListResponse {
    return CMsgPracticeLobbyListResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgPracticeLobbyListResponse>): CMsgPracticeLobbyListResponse {
    const message = createBaseCMsgPracticeLobbyListResponse();
    message.lobbies = object.lobbies?.map((e) => CMsgPracticeLobbyListResponseEntry.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgLobbyList(): CMsgLobbyList {
  return { serverRegion: 0, gameMode: 0 };
}

export const CMsgLobbyList = {
  encode(message: CMsgLobbyList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.serverRegion !== undefined && message.serverRegion !== 0) {
      writer.uint32(8).uint32(message.serverRegion);
    }
    if (message.gameMode !== undefined && message.gameMode !== 0) {
      writer.uint32(16).int32(message.gameMode);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgLobbyList {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgLobbyList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.serverRegion = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.gameMode = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgLobbyList {
    return {
      serverRegion: isSet(object.serverRegion) ? globalThis.Number(object.serverRegion) : 0,
      gameMode: isSet(object.gameMode) ? dOTAGameModeFromJSON(object.gameMode) : 0,
    };
  },

  toJSON(message: CMsgLobbyList): unknown {
    const obj: any = {};
    if (message.serverRegion !== undefined && message.serverRegion !== 0) {
      obj.serverRegion = Math.round(message.serverRegion);
    }
    if (message.gameMode !== undefined && message.gameMode !== 0) {
      obj.gameMode = dOTAGameModeToJSON(message.gameMode);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgLobbyList>): CMsgLobbyList {
    return CMsgLobbyList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgLobbyList>): CMsgLobbyList {
    const message = createBaseCMsgLobbyList();
    message.serverRegion = object.serverRegion ?? 0;
    message.gameMode = object.gameMode ?? 0;
    return message;
  },
};

function createBaseCMsgLobbyListResponse(): CMsgLobbyListResponse {
  return { lobbies: [] };
}

export const CMsgLobbyListResponse = {
  encode(message: CMsgLobbyListResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.lobbies) {
      CMsgPracticeLobbyListResponseEntry.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgLobbyListResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgLobbyListResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.lobbies.push(CMsgPracticeLobbyListResponseEntry.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgLobbyListResponse {
    return {
      lobbies: globalThis.Array.isArray(object?.lobbies)
        ? object.lobbies.map((e: any) => CMsgPracticeLobbyListResponseEntry.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgLobbyListResponse): unknown {
    const obj: any = {};
    if (message.lobbies?.length) {
      obj.lobbies = message.lobbies.map((e) => CMsgPracticeLobbyListResponseEntry.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgLobbyListResponse>): CMsgLobbyListResponse {
    return CMsgLobbyListResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgLobbyListResponse>): CMsgLobbyListResponse {
    const message = createBaseCMsgLobbyListResponse();
    message.lobbies = object.lobbies?.map((e) => CMsgPracticeLobbyListResponseEntry.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgPracticeLobbyJoin(): CMsgPracticeLobbyJoin {
  return { lobbyId: "0", clientVersion: 0, passKey: "", customGameCrc: "0", customGameTimestamp: 0 };
}

export const CMsgPracticeLobbyJoin = {
  encode(message: CMsgPracticeLobbyJoin, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.lobbyId !== undefined && message.lobbyId !== "0") {
      writer.uint32(8).uint64(message.lobbyId);
    }
    if (message.clientVersion !== undefined && message.clientVersion !== 0) {
      writer.uint32(16).uint32(message.clientVersion);
    }
    if (message.passKey !== undefined && message.passKey !== "") {
      writer.uint32(26).string(message.passKey);
    }
    if (message.customGameCrc !== undefined && message.customGameCrc !== "0") {
      writer.uint32(33).fixed64(message.customGameCrc);
    }
    if (message.customGameTimestamp !== undefined && message.customGameTimestamp !== 0) {
      writer.uint32(45).fixed32(message.customGameTimestamp);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgPracticeLobbyJoin {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgPracticeLobbyJoin();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.lobbyId = longToString(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.clientVersion = reader.uint32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.passKey = reader.string();
          continue;
        case 4:
          if (tag !== 33) {
            break;
          }

          message.customGameCrc = longToString(reader.fixed64() as Long);
          continue;
        case 5:
          if (tag !== 45) {
            break;
          }

          message.customGameTimestamp = reader.fixed32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgPracticeLobbyJoin {
    return {
      lobbyId: isSet(object.lobbyId) ? globalThis.String(object.lobbyId) : "0",
      clientVersion: isSet(object.clientVersion) ? globalThis.Number(object.clientVersion) : 0,
      passKey: isSet(object.passKey) ? globalThis.String(object.passKey) : "",
      customGameCrc: isSet(object.customGameCrc) ? globalThis.String(object.customGameCrc) : "0",
      customGameTimestamp: isSet(object.customGameTimestamp) ? globalThis.Number(object.customGameTimestamp) : 0,
    };
  },

  toJSON(message: CMsgPracticeLobbyJoin): unknown {
    const obj: any = {};
    if (message.lobbyId !== undefined && message.lobbyId !== "0") {
      obj.lobbyId = message.lobbyId;
    }
    if (message.clientVersion !== undefined && message.clientVersion !== 0) {
      obj.clientVersion = Math.round(message.clientVersion);
    }
    if (message.passKey !== undefined && message.passKey !== "") {
      obj.passKey = message.passKey;
    }
    if (message.customGameCrc !== undefined && message.customGameCrc !== "0") {
      obj.customGameCrc = message.customGameCrc;
    }
    if (message.customGameTimestamp !== undefined && message.customGameTimestamp !== 0) {
      obj.customGameTimestamp = Math.round(message.customGameTimestamp);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgPracticeLobbyJoin>): CMsgPracticeLobbyJoin {
    return CMsgPracticeLobbyJoin.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgPracticeLobbyJoin>): CMsgPracticeLobbyJoin {
    const message = createBaseCMsgPracticeLobbyJoin();
    message.lobbyId = object.lobbyId ?? "0";
    message.clientVersion = object.clientVersion ?? 0;
    message.passKey = object.passKey ?? "";
    message.customGameCrc = object.customGameCrc ?? "0";
    message.customGameTimestamp = object.customGameTimestamp ?? 0;
    return message;
  },
};

function createBaseCMsgPracticeLobbyJoinResponse(): CMsgPracticeLobbyJoinResponse {
  return { result: 0 };
}

export const CMsgPracticeLobbyJoinResponse = {
  encode(message: CMsgPracticeLobbyJoinResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result !== undefined && message.result !== 0) {
      writer.uint32(8).int32(message.result);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgPracticeLobbyJoinResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgPracticeLobbyJoinResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.result = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgPracticeLobbyJoinResponse {
    return { result: isSet(object.result) ? dOTAJoinLobbyResultFromJSON(object.result) : 0 };
  },

  toJSON(message: CMsgPracticeLobbyJoinResponse): unknown {
    const obj: any = {};
    if (message.result !== undefined && message.result !== 0) {
      obj.result = dOTAJoinLobbyResultToJSON(message.result);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgPracticeLobbyJoinResponse>): CMsgPracticeLobbyJoinResponse {
    return CMsgPracticeLobbyJoinResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgPracticeLobbyJoinResponse>): CMsgPracticeLobbyJoinResponse {
    const message = createBaseCMsgPracticeLobbyJoinResponse();
    message.result = object.result ?? 0;
    return message;
  },
};

function createBaseCMsgFriendPracticeLobbyListRequest(): CMsgFriendPracticeLobbyListRequest {
  return { friends: [] };
}

export const CMsgFriendPracticeLobbyListRequest = {
  encode(message: CMsgFriendPracticeLobbyListRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.friends) {
      writer.uint32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgFriendPracticeLobbyListRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgFriendPracticeLobbyListRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.friends.push(reader.uint32());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.friends.push(reader.uint32());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgFriendPracticeLobbyListRequest {
    return {
      friends: globalThis.Array.isArray(object?.friends) ? object.friends.map((e: any) => globalThis.Number(e)) : [],
    };
  },

  toJSON(message: CMsgFriendPracticeLobbyListRequest): unknown {
    const obj: any = {};
    if (message.friends?.length) {
      obj.friends = message.friends.map((e) => Math.round(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgFriendPracticeLobbyListRequest>): CMsgFriendPracticeLobbyListRequest {
    return CMsgFriendPracticeLobbyListRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgFriendPracticeLobbyListRequest>): CMsgFriendPracticeLobbyListRequest {
    const message = createBaseCMsgFriendPracticeLobbyListRequest();
    message.friends = object.friends?.map((e) => e) || [];
    return message;
  },
};

function createBaseCMsgFriendPracticeLobbyListResponse(): CMsgFriendPracticeLobbyListResponse {
  return { lobbies: [] };
}

export const CMsgFriendPracticeLobbyListResponse = {
  encode(message: CMsgFriendPracticeLobbyListResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.lobbies) {
      CMsgPracticeLobbyListResponseEntry.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgFriendPracticeLobbyListResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgFriendPracticeLobbyListResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.lobbies.push(CMsgPracticeLobbyListResponseEntry.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgFriendPracticeLobbyListResponse {
    return {
      lobbies: globalThis.Array.isArray(object?.lobbies)
        ? object.lobbies.map((e: any) => CMsgPracticeLobbyListResponseEntry.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgFriendPracticeLobbyListResponse): unknown {
    const obj: any = {};
    if (message.lobbies?.length) {
      obj.lobbies = message.lobbies.map((e) => CMsgPracticeLobbyListResponseEntry.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgFriendPracticeLobbyListResponse>): CMsgFriendPracticeLobbyListResponse {
    return CMsgFriendPracticeLobbyListResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgFriendPracticeLobbyListResponse>): CMsgFriendPracticeLobbyListResponse {
    const message = createBaseCMsgFriendPracticeLobbyListResponse();
    message.lobbies = object.lobbies?.map((e) => CMsgPracticeLobbyListResponseEntry.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgJoinableCustomGameModesRequest(): CMsgJoinableCustomGameModesRequest {
  return { serverRegion: 0 };
}

export const CMsgJoinableCustomGameModesRequest = {
  encode(message: CMsgJoinableCustomGameModesRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.serverRegion !== undefined && message.serverRegion !== 0) {
      writer.uint32(8).uint32(message.serverRegion);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgJoinableCustomGameModesRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgJoinableCustomGameModesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.serverRegion = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgJoinableCustomGameModesRequest {
    return { serverRegion: isSet(object.serverRegion) ? globalThis.Number(object.serverRegion) : 0 };
  },

  toJSON(message: CMsgJoinableCustomGameModesRequest): unknown {
    const obj: any = {};
    if (message.serverRegion !== undefined && message.serverRegion !== 0) {
      obj.serverRegion = Math.round(message.serverRegion);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgJoinableCustomGameModesRequest>): CMsgJoinableCustomGameModesRequest {
    return CMsgJoinableCustomGameModesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgJoinableCustomGameModesRequest>): CMsgJoinableCustomGameModesRequest {
    const message = createBaseCMsgJoinableCustomGameModesRequest();
    message.serverRegion = object.serverRegion ?? 0;
    return message;
  },
};

function createBaseCMsgJoinableCustomGameModesResponseEntry(): CMsgJoinableCustomGameModesResponseEntry {
  return { customGameId: "0", lobbyCount: 0, playerCount: 0 };
}

export const CMsgJoinableCustomGameModesResponseEntry = {
  encode(message: CMsgJoinableCustomGameModesResponseEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.customGameId !== undefined && message.customGameId !== "0") {
      writer.uint32(8).uint64(message.customGameId);
    }
    if (message.lobbyCount !== undefined && message.lobbyCount !== 0) {
      writer.uint32(16).uint32(message.lobbyCount);
    }
    if (message.playerCount !== undefined && message.playerCount !== 0) {
      writer.uint32(24).uint32(message.playerCount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgJoinableCustomGameModesResponseEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgJoinableCustomGameModesResponseEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.customGameId = longToString(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.lobbyCount = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.playerCount = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgJoinableCustomGameModesResponseEntry {
    return {
      customGameId: isSet(object.customGameId) ? globalThis.String(object.customGameId) : "0",
      lobbyCount: isSet(object.lobbyCount) ? globalThis.Number(object.lobbyCount) : 0,
      playerCount: isSet(object.playerCount) ? globalThis.Number(object.playerCount) : 0,
    };
  },

  toJSON(message: CMsgJoinableCustomGameModesResponseEntry): unknown {
    const obj: any = {};
    if (message.customGameId !== undefined && message.customGameId !== "0") {
      obj.customGameId = message.customGameId;
    }
    if (message.lobbyCount !== undefined && message.lobbyCount !== 0) {
      obj.lobbyCount = Math.round(message.lobbyCount);
    }
    if (message.playerCount !== undefined && message.playerCount !== 0) {
      obj.playerCount = Math.round(message.playerCount);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgJoinableCustomGameModesResponseEntry>): CMsgJoinableCustomGameModesResponseEntry {
    return CMsgJoinableCustomGameModesResponseEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgJoinableCustomGameModesResponseEntry>): CMsgJoinableCustomGameModesResponseEntry {
    const message = createBaseCMsgJoinableCustomGameModesResponseEntry();
    message.customGameId = object.customGameId ?? "0";
    message.lobbyCount = object.lobbyCount ?? 0;
    message.playerCount = object.playerCount ?? 0;
    return message;
  },
};

function createBaseCMsgJoinableCustomGameModesResponse(): CMsgJoinableCustomGameModesResponse {
  return { gameModes: [] };
}

export const CMsgJoinableCustomGameModesResponse = {
  encode(message: CMsgJoinableCustomGameModesResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.gameModes) {
      CMsgJoinableCustomGameModesResponseEntry.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgJoinableCustomGameModesResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgJoinableCustomGameModesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.gameModes.push(CMsgJoinableCustomGameModesResponseEntry.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgJoinableCustomGameModesResponse {
    return {
      gameModes: globalThis.Array.isArray(object?.gameModes)
        ? object.gameModes.map((e: any) => CMsgJoinableCustomGameModesResponseEntry.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgJoinableCustomGameModesResponse): unknown {
    const obj: any = {};
    if (message.gameModes?.length) {
      obj.gameModes = message.gameModes.map((e) => CMsgJoinableCustomGameModesResponseEntry.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgJoinableCustomGameModesResponse>): CMsgJoinableCustomGameModesResponse {
    return CMsgJoinableCustomGameModesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgJoinableCustomGameModesResponse>): CMsgJoinableCustomGameModesResponse {
    const message = createBaseCMsgJoinableCustomGameModesResponse();
    message.gameModes = object.gameModes?.map((e) => CMsgJoinableCustomGameModesResponseEntry.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgJoinableCustomLobbiesRequest(): CMsgJoinableCustomLobbiesRequest {
  return { serverRegion: 0, customGameId: "0" };
}

export const CMsgJoinableCustomLobbiesRequest = {
  encode(message: CMsgJoinableCustomLobbiesRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.serverRegion !== undefined && message.serverRegion !== 0) {
      writer.uint32(8).uint32(message.serverRegion);
    }
    if (message.customGameId !== undefined && message.customGameId !== "0") {
      writer.uint32(16).uint64(message.customGameId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgJoinableCustomLobbiesRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgJoinableCustomLobbiesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.serverRegion = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.customGameId = longToString(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgJoinableCustomLobbiesRequest {
    return {
      serverRegion: isSet(object.serverRegion) ? globalThis.Number(object.serverRegion) : 0,
      customGameId: isSet(object.customGameId) ? globalThis.String(object.customGameId) : "0",
    };
  },

  toJSON(message: CMsgJoinableCustomLobbiesRequest): unknown {
    const obj: any = {};
    if (message.serverRegion !== undefined && message.serverRegion !== 0) {
      obj.serverRegion = Math.round(message.serverRegion);
    }
    if (message.customGameId !== undefined && message.customGameId !== "0") {
      obj.customGameId = message.customGameId;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgJoinableCustomLobbiesRequest>): CMsgJoinableCustomLobbiesRequest {
    return CMsgJoinableCustomLobbiesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgJoinableCustomLobbiesRequest>): CMsgJoinableCustomLobbiesRequest {
    const message = createBaseCMsgJoinableCustomLobbiesRequest();
    message.serverRegion = object.serverRegion ?? 0;
    message.customGameId = object.customGameId ?? "0";
    return message;
  },
};

function createBaseCMsgJoinableCustomLobbiesResponseEntry(): CMsgJoinableCustomLobbiesResponseEntry {
  return {
    lobbyId: "0",
    customGameId: "0",
    lobbyName: "",
    memberCount: 0,
    leaderAccountId: 0,
    leaderName: "",
    customMapName: "",
    maxPlayerCount: 0,
    serverRegion: 0,
    hasPassKey: false,
    lanHostPingLocation: "",
    lobbyCreationTime: 0,
    customGameTimestamp: 0,
    customGameCrc: "0",
    minPlayerCount: 0,
    penaltiesEnabled: false,
  };
}

export const CMsgJoinableCustomLobbiesResponseEntry = {
  encode(message: CMsgJoinableCustomLobbiesResponseEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.lobbyId !== undefined && message.lobbyId !== "0") {
      writer.uint32(9).fixed64(message.lobbyId);
    }
    if (message.customGameId !== undefined && message.customGameId !== "0") {
      writer.uint32(16).uint64(message.customGameId);
    }
    if (message.lobbyName !== undefined && message.lobbyName !== "") {
      writer.uint32(26).string(message.lobbyName);
    }
    if (message.memberCount !== undefined && message.memberCount !== 0) {
      writer.uint32(32).uint32(message.memberCount);
    }
    if (message.leaderAccountId !== undefined && message.leaderAccountId !== 0) {
      writer.uint32(40).uint32(message.leaderAccountId);
    }
    if (message.leaderName !== undefined && message.leaderName !== "") {
      writer.uint32(50).string(message.leaderName);
    }
    if (message.customMapName !== undefined && message.customMapName !== "") {
      writer.uint32(58).string(message.customMapName);
    }
    if (message.maxPlayerCount !== undefined && message.maxPlayerCount !== 0) {
      writer.uint32(64).uint32(message.maxPlayerCount);
    }
    if (message.serverRegion !== undefined && message.serverRegion !== 0) {
      writer.uint32(72).uint32(message.serverRegion);
    }
    if (message.hasPassKey !== undefined && message.hasPassKey !== false) {
      writer.uint32(88).bool(message.hasPassKey);
    }
    if (message.lanHostPingLocation !== undefined && message.lanHostPingLocation !== "") {
      writer.uint32(98).string(message.lanHostPingLocation);
    }
    if (message.lobbyCreationTime !== undefined && message.lobbyCreationTime !== 0) {
      writer.uint32(104).uint32(message.lobbyCreationTime);
    }
    if (message.customGameTimestamp !== undefined && message.customGameTimestamp !== 0) {
      writer.uint32(112).uint32(message.customGameTimestamp);
    }
    if (message.customGameCrc !== undefined && message.customGameCrc !== "0") {
      writer.uint32(120).uint64(message.customGameCrc);
    }
    if (message.minPlayerCount !== undefined && message.minPlayerCount !== 0) {
      writer.uint32(128).uint32(message.minPlayerCount);
    }
    if (message.penaltiesEnabled !== undefined && message.penaltiesEnabled !== false) {
      writer.uint32(136).bool(message.penaltiesEnabled);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgJoinableCustomLobbiesResponseEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgJoinableCustomLobbiesResponseEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.lobbyId = longToString(reader.fixed64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.customGameId = longToString(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.lobbyName = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.memberCount = reader.uint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.leaderAccountId = reader.uint32();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.leaderName = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.customMapName = reader.string();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.maxPlayerCount = reader.uint32();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.serverRegion = reader.uint32();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.hasPassKey = reader.bool();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.lanHostPingLocation = reader.string();
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.lobbyCreationTime = reader.uint32();
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.customGameTimestamp = reader.uint32();
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.customGameCrc = longToString(reader.uint64() as Long);
          continue;
        case 16:
          if (tag !== 128) {
            break;
          }

          message.minPlayerCount = reader.uint32();
          continue;
        case 17:
          if (tag !== 136) {
            break;
          }

          message.penaltiesEnabled = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgJoinableCustomLobbiesResponseEntry {
    return {
      lobbyId: isSet(object.lobbyId) ? globalThis.String(object.lobbyId) : "0",
      customGameId: isSet(object.customGameId) ? globalThis.String(object.customGameId) : "0",
      lobbyName: isSet(object.lobbyName) ? globalThis.String(object.lobbyName) : "",
      memberCount: isSet(object.memberCount) ? globalThis.Number(object.memberCount) : 0,
      leaderAccountId: isSet(object.leaderAccountId) ? globalThis.Number(object.leaderAccountId) : 0,
      leaderName: isSet(object.leaderName) ? globalThis.String(object.leaderName) : "",
      customMapName: isSet(object.customMapName) ? globalThis.String(object.customMapName) : "",
      maxPlayerCount: isSet(object.maxPlayerCount) ? globalThis.Number(object.maxPlayerCount) : 0,
      serverRegion: isSet(object.serverRegion) ? globalThis.Number(object.serverRegion) : 0,
      hasPassKey: isSet(object.hasPassKey) ? globalThis.Boolean(object.hasPassKey) : false,
      lanHostPingLocation: isSet(object.lanHostPingLocation) ? globalThis.String(object.lanHostPingLocation) : "",
      lobbyCreationTime: isSet(object.lobbyCreationTime) ? globalThis.Number(object.lobbyCreationTime) : 0,
      customGameTimestamp: isSet(object.customGameTimestamp) ? globalThis.Number(object.customGameTimestamp) : 0,
      customGameCrc: isSet(object.customGameCrc) ? globalThis.String(object.customGameCrc) : "0",
      minPlayerCount: isSet(object.minPlayerCount) ? globalThis.Number(object.minPlayerCount) : 0,
      penaltiesEnabled: isSet(object.penaltiesEnabled) ? globalThis.Boolean(object.penaltiesEnabled) : false,
    };
  },

  toJSON(message: CMsgJoinableCustomLobbiesResponseEntry): unknown {
    const obj: any = {};
    if (message.lobbyId !== undefined && message.lobbyId !== "0") {
      obj.lobbyId = message.lobbyId;
    }
    if (message.customGameId !== undefined && message.customGameId !== "0") {
      obj.customGameId = message.customGameId;
    }
    if (message.lobbyName !== undefined && message.lobbyName !== "") {
      obj.lobbyName = message.lobbyName;
    }
    if (message.memberCount !== undefined && message.memberCount !== 0) {
      obj.memberCount = Math.round(message.memberCount);
    }
    if (message.leaderAccountId !== undefined && message.leaderAccountId !== 0) {
      obj.leaderAccountId = Math.round(message.leaderAccountId);
    }
    if (message.leaderName !== undefined && message.leaderName !== "") {
      obj.leaderName = message.leaderName;
    }
    if (message.customMapName !== undefined && message.customMapName !== "") {
      obj.customMapName = message.customMapName;
    }
    if (message.maxPlayerCount !== undefined && message.maxPlayerCount !== 0) {
      obj.maxPlayerCount = Math.round(message.maxPlayerCount);
    }
    if (message.serverRegion !== undefined && message.serverRegion !== 0) {
      obj.serverRegion = Math.round(message.serverRegion);
    }
    if (message.hasPassKey !== undefined && message.hasPassKey !== false) {
      obj.hasPassKey = message.hasPassKey;
    }
    if (message.lanHostPingLocation !== undefined && message.lanHostPingLocation !== "") {
      obj.lanHostPingLocation = message.lanHostPingLocation;
    }
    if (message.lobbyCreationTime !== undefined && message.lobbyCreationTime !== 0) {
      obj.lobbyCreationTime = Math.round(message.lobbyCreationTime);
    }
    if (message.customGameTimestamp !== undefined && message.customGameTimestamp !== 0) {
      obj.customGameTimestamp = Math.round(message.customGameTimestamp);
    }
    if (message.customGameCrc !== undefined && message.customGameCrc !== "0") {
      obj.customGameCrc = message.customGameCrc;
    }
    if (message.minPlayerCount !== undefined && message.minPlayerCount !== 0) {
      obj.minPlayerCount = Math.round(message.minPlayerCount);
    }
    if (message.penaltiesEnabled !== undefined && message.penaltiesEnabled !== false) {
      obj.penaltiesEnabled = message.penaltiesEnabled;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgJoinableCustomLobbiesResponseEntry>): CMsgJoinableCustomLobbiesResponseEntry {
    return CMsgJoinableCustomLobbiesResponseEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgJoinableCustomLobbiesResponseEntry>): CMsgJoinableCustomLobbiesResponseEntry {
    const message = createBaseCMsgJoinableCustomLobbiesResponseEntry();
    message.lobbyId = object.lobbyId ?? "0";
    message.customGameId = object.customGameId ?? "0";
    message.lobbyName = object.lobbyName ?? "";
    message.memberCount = object.memberCount ?? 0;
    message.leaderAccountId = object.leaderAccountId ?? 0;
    message.leaderName = object.leaderName ?? "";
    message.customMapName = object.customMapName ?? "";
    message.maxPlayerCount = object.maxPlayerCount ?? 0;
    message.serverRegion = object.serverRegion ?? 0;
    message.hasPassKey = object.hasPassKey ?? false;
    message.lanHostPingLocation = object.lanHostPingLocation ?? "";
    message.lobbyCreationTime = object.lobbyCreationTime ?? 0;
    message.customGameTimestamp = object.customGameTimestamp ?? 0;
    message.customGameCrc = object.customGameCrc ?? "0";
    message.minPlayerCount = object.minPlayerCount ?? 0;
    message.penaltiesEnabled = object.penaltiesEnabled ?? false;
    return message;
  },
};

function createBaseCMsgJoinableCustomLobbiesResponse(): CMsgJoinableCustomLobbiesResponse {
  return { lobbies: [] };
}

export const CMsgJoinableCustomLobbiesResponse = {
  encode(message: CMsgJoinableCustomLobbiesResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.lobbies) {
      CMsgJoinableCustomLobbiesResponseEntry.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgJoinableCustomLobbiesResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgJoinableCustomLobbiesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.lobbies.push(CMsgJoinableCustomLobbiesResponseEntry.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgJoinableCustomLobbiesResponse {
    return {
      lobbies: globalThis.Array.isArray(object?.lobbies)
        ? object.lobbies.map((e: any) => CMsgJoinableCustomLobbiesResponseEntry.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgJoinableCustomLobbiesResponse): unknown {
    const obj: any = {};
    if (message.lobbies?.length) {
      obj.lobbies = message.lobbies.map((e) => CMsgJoinableCustomLobbiesResponseEntry.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgJoinableCustomLobbiesResponse>): CMsgJoinableCustomLobbiesResponse {
    return CMsgJoinableCustomLobbiesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgJoinableCustomLobbiesResponse>): CMsgJoinableCustomLobbiesResponse {
    const message = createBaseCMsgJoinableCustomLobbiesResponse();
    message.lobbies = object.lobbies?.map((e) => CMsgJoinableCustomLobbiesResponseEntry.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgQuickJoinCustomLobby(): CMsgQuickJoinCustomLobby {
  return {
    legacyServerRegion: 0,
    customGameId: "0",
    clientVersion: 0,
    createLobbyDetails: undefined,
    allowAnyMap: false,
    legacyRegionPings: [],
    pingData: undefined,
  };
}

export const CMsgQuickJoinCustomLobby = {
  encode(message: CMsgQuickJoinCustomLobby, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.legacyServerRegion !== undefined && message.legacyServerRegion !== 0) {
      writer.uint32(8).uint32(message.legacyServerRegion);
    }
    if (message.customGameId !== undefined && message.customGameId !== "0") {
      writer.uint32(16).uint64(message.customGameId);
    }
    if (message.clientVersion !== undefined && message.clientVersion !== 0) {
      writer.uint32(24).uint32(message.clientVersion);
    }
    if (message.createLobbyDetails !== undefined) {
      CMsgPracticeLobbySetDetails.encode(message.createLobbyDetails, writer.uint32(34).fork()).ldelim();
    }
    if (message.allowAnyMap !== undefined && message.allowAnyMap !== false) {
      writer.uint32(40).bool(message.allowAnyMap);
    }
    for (const v of message.legacyRegionPings) {
      CMsgQuickJoinCustomLobby_LegacyRegionPing.encode(v!, writer.uint32(50).fork()).ldelim();
    }
    if (message.pingData !== undefined) {
      CMsgClientPingData.encode(message.pingData, writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgQuickJoinCustomLobby {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgQuickJoinCustomLobby();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.legacyServerRegion = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.customGameId = longToString(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.clientVersion = reader.uint32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.createLobbyDetails = CMsgPracticeLobbySetDetails.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.allowAnyMap = reader.bool();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.legacyRegionPings.push(CMsgQuickJoinCustomLobby_LegacyRegionPing.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.pingData = CMsgClientPingData.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgQuickJoinCustomLobby {
    return {
      legacyServerRegion: isSet(object.legacyServerRegion) ? globalThis.Number(object.legacyServerRegion) : 0,
      customGameId: isSet(object.customGameId) ? globalThis.String(object.customGameId) : "0",
      clientVersion: isSet(object.clientVersion) ? globalThis.Number(object.clientVersion) : 0,
      createLobbyDetails: isSet(object.createLobbyDetails)
        ? CMsgPracticeLobbySetDetails.fromJSON(object.createLobbyDetails)
        : undefined,
      allowAnyMap: isSet(object.allowAnyMap) ? globalThis.Boolean(object.allowAnyMap) : false,
      legacyRegionPings: globalThis.Array.isArray(object?.legacyRegionPings)
        ? object.legacyRegionPings.map((e: any) => CMsgQuickJoinCustomLobby_LegacyRegionPing.fromJSON(e))
        : [],
      pingData: isSet(object.pingData) ? CMsgClientPingData.fromJSON(object.pingData) : undefined,
    };
  },

  toJSON(message: CMsgQuickJoinCustomLobby): unknown {
    const obj: any = {};
    if (message.legacyServerRegion !== undefined && message.legacyServerRegion !== 0) {
      obj.legacyServerRegion = Math.round(message.legacyServerRegion);
    }
    if (message.customGameId !== undefined && message.customGameId !== "0") {
      obj.customGameId = message.customGameId;
    }
    if (message.clientVersion !== undefined && message.clientVersion !== 0) {
      obj.clientVersion = Math.round(message.clientVersion);
    }
    if (message.createLobbyDetails !== undefined) {
      obj.createLobbyDetails = CMsgPracticeLobbySetDetails.toJSON(message.createLobbyDetails);
    }
    if (message.allowAnyMap !== undefined && message.allowAnyMap !== false) {
      obj.allowAnyMap = message.allowAnyMap;
    }
    if (message.legacyRegionPings?.length) {
      obj.legacyRegionPings = message.legacyRegionPings.map((e) => CMsgQuickJoinCustomLobby_LegacyRegionPing.toJSON(e));
    }
    if (message.pingData !== undefined) {
      obj.pingData = CMsgClientPingData.toJSON(message.pingData);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgQuickJoinCustomLobby>): CMsgQuickJoinCustomLobby {
    return CMsgQuickJoinCustomLobby.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgQuickJoinCustomLobby>): CMsgQuickJoinCustomLobby {
    const message = createBaseCMsgQuickJoinCustomLobby();
    message.legacyServerRegion = object.legacyServerRegion ?? 0;
    message.customGameId = object.customGameId ?? "0";
    message.clientVersion = object.clientVersion ?? 0;
    message.createLobbyDetails = (object.createLobbyDetails !== undefined && object.createLobbyDetails !== null)
      ? CMsgPracticeLobbySetDetails.fromPartial(object.createLobbyDetails)
      : undefined;
    message.allowAnyMap = object.allowAnyMap ?? false;
    message.legacyRegionPings =
      object.legacyRegionPings?.map((e) => CMsgQuickJoinCustomLobby_LegacyRegionPing.fromPartial(e)) || [];
    message.pingData = (object.pingData !== undefined && object.pingData !== null)
      ? CMsgClientPingData.fromPartial(object.pingData)
      : undefined;
    return message;
  },
};

function createBaseCMsgQuickJoinCustomLobby_LegacyRegionPing(): CMsgQuickJoinCustomLobby_LegacyRegionPing {
  return { serverRegion: 0, ping: 0, regionCode: 0 };
}

export const CMsgQuickJoinCustomLobby_LegacyRegionPing = {
  encode(message: CMsgQuickJoinCustomLobby_LegacyRegionPing, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.serverRegion !== undefined && message.serverRegion !== 0) {
      writer.uint32(8).uint32(message.serverRegion);
    }
    if (message.ping !== undefined && message.ping !== 0) {
      writer.uint32(16).uint32(message.ping);
    }
    if (message.regionCode !== undefined && message.regionCode !== 0) {
      writer.uint32(29).fixed32(message.regionCode);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgQuickJoinCustomLobby_LegacyRegionPing {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgQuickJoinCustomLobby_LegacyRegionPing();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.serverRegion = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.ping = reader.uint32();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.regionCode = reader.fixed32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgQuickJoinCustomLobby_LegacyRegionPing {
    return {
      serverRegion: isSet(object.serverRegion) ? globalThis.Number(object.serverRegion) : 0,
      ping: isSet(object.ping) ? globalThis.Number(object.ping) : 0,
      regionCode: isSet(object.regionCode) ? globalThis.Number(object.regionCode) : 0,
    };
  },

  toJSON(message: CMsgQuickJoinCustomLobby_LegacyRegionPing): unknown {
    const obj: any = {};
    if (message.serverRegion !== undefined && message.serverRegion !== 0) {
      obj.serverRegion = Math.round(message.serverRegion);
    }
    if (message.ping !== undefined && message.ping !== 0) {
      obj.ping = Math.round(message.ping);
    }
    if (message.regionCode !== undefined && message.regionCode !== 0) {
      obj.regionCode = Math.round(message.regionCode);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgQuickJoinCustomLobby_LegacyRegionPing>): CMsgQuickJoinCustomLobby_LegacyRegionPing {
    return CMsgQuickJoinCustomLobby_LegacyRegionPing.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgQuickJoinCustomLobby_LegacyRegionPing>,
  ): CMsgQuickJoinCustomLobby_LegacyRegionPing {
    const message = createBaseCMsgQuickJoinCustomLobby_LegacyRegionPing();
    message.serverRegion = object.serverRegion ?? 0;
    message.ping = object.ping ?? 0;
    message.regionCode = object.regionCode ?? 0;
    return message;
  },
};

function createBaseCMsgQuickJoinCustomLobbyResponse(): CMsgQuickJoinCustomLobbyResponse {
  return { result: 0 };
}

export const CMsgQuickJoinCustomLobbyResponse = {
  encode(message: CMsgQuickJoinCustomLobbyResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result !== undefined && message.result !== 0) {
      writer.uint32(8).int32(message.result);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgQuickJoinCustomLobbyResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgQuickJoinCustomLobbyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.result = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgQuickJoinCustomLobbyResponse {
    return { result: isSet(object.result) ? dOTAJoinLobbyResultFromJSON(object.result) : 0 };
  },

  toJSON(message: CMsgQuickJoinCustomLobbyResponse): unknown {
    const obj: any = {};
    if (message.result !== undefined && message.result !== 0) {
      obj.result = dOTAJoinLobbyResultToJSON(message.result);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgQuickJoinCustomLobbyResponse>): CMsgQuickJoinCustomLobbyResponse {
    return CMsgQuickJoinCustomLobbyResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgQuickJoinCustomLobbyResponse>): CMsgQuickJoinCustomLobbyResponse {
    const message = createBaseCMsgQuickJoinCustomLobbyResponse();
    message.result = object.result ?? 0;
    return message;
  },
};

function createBaseCMsgBotGameCreate(): CMsgBotGameCreate {
  return { searchKey: "", clientVersion: 0, difficultyRadiant: 0, team: 0, gameMode: 0, difficultyDire: 0 };
}

export const CMsgBotGameCreate = {
  encode(message: CMsgBotGameCreate, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.searchKey !== undefined && message.searchKey !== "") {
      writer.uint32(10).string(message.searchKey);
    }
    if (message.clientVersion !== undefined && message.clientVersion !== 0) {
      writer.uint32(16).uint32(message.clientVersion);
    }
    if (message.difficultyRadiant !== undefined && message.difficultyRadiant !== 0) {
      writer.uint32(24).int32(message.difficultyRadiant);
    }
    if (message.team !== undefined && message.team !== 0) {
      writer.uint32(32).int32(message.team);
    }
    if (message.gameMode !== undefined && message.gameMode !== 0) {
      writer.uint32(40).uint32(message.gameMode);
    }
    if (message.difficultyDire !== undefined && message.difficultyDire !== 0) {
      writer.uint32(48).int32(message.difficultyDire);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgBotGameCreate {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgBotGameCreate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.searchKey = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.clientVersion = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.difficultyRadiant = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.team = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.gameMode = reader.uint32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.difficultyDire = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgBotGameCreate {
    return {
      searchKey: isSet(object.searchKey) ? globalThis.String(object.searchKey) : "",
      clientVersion: isSet(object.clientVersion) ? globalThis.Number(object.clientVersion) : 0,
      difficultyRadiant: isSet(object.difficultyRadiant) ? dOTABotDifficultyFromJSON(object.difficultyRadiant) : 0,
      team: isSet(object.team) ? dotaGcTeamFromJSON(object.team) : 0,
      gameMode: isSet(object.gameMode) ? globalThis.Number(object.gameMode) : 0,
      difficultyDire: isSet(object.difficultyDire) ? dOTABotDifficultyFromJSON(object.difficultyDire) : 0,
    };
  },

  toJSON(message: CMsgBotGameCreate): unknown {
    const obj: any = {};
    if (message.searchKey !== undefined && message.searchKey !== "") {
      obj.searchKey = message.searchKey;
    }
    if (message.clientVersion !== undefined && message.clientVersion !== 0) {
      obj.clientVersion = Math.round(message.clientVersion);
    }
    if (message.difficultyRadiant !== undefined && message.difficultyRadiant !== 0) {
      obj.difficultyRadiant = dOTABotDifficultyToJSON(message.difficultyRadiant);
    }
    if (message.team !== undefined && message.team !== 0) {
      obj.team = dotaGcTeamToJSON(message.team);
    }
    if (message.gameMode !== undefined && message.gameMode !== 0) {
      obj.gameMode = Math.round(message.gameMode);
    }
    if (message.difficultyDire !== undefined && message.difficultyDire !== 0) {
      obj.difficultyDire = dOTABotDifficultyToJSON(message.difficultyDire);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgBotGameCreate>): CMsgBotGameCreate {
    return CMsgBotGameCreate.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgBotGameCreate>): CMsgBotGameCreate {
    const message = createBaseCMsgBotGameCreate();
    message.searchKey = object.searchKey ?? "";
    message.clientVersion = object.clientVersion ?? 0;
    message.difficultyRadiant = object.difficultyRadiant ?? 0;
    message.team = object.team ?? 0;
    message.gameMode = object.gameMode ?? 0;
    message.difficultyDire = object.difficultyDire ?? 0;
    return message;
  },
};

function createBaseCMsgDOTAPartyMemberSetCoach(): CMsgDOTAPartyMemberSetCoach {
  return { wantsCoach: false };
}

export const CMsgDOTAPartyMemberSetCoach = {
  encode(message: CMsgDOTAPartyMemberSetCoach, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.wantsCoach !== undefined && message.wantsCoach !== false) {
      writer.uint32(8).bool(message.wantsCoach);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTAPartyMemberSetCoach {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAPartyMemberSetCoach();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.wantsCoach = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAPartyMemberSetCoach {
    return { wantsCoach: isSet(object.wantsCoach) ? globalThis.Boolean(object.wantsCoach) : false };
  },

  toJSON(message: CMsgDOTAPartyMemberSetCoach): unknown {
    const obj: any = {};
    if (message.wantsCoach !== undefined && message.wantsCoach !== false) {
      obj.wantsCoach = message.wantsCoach;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTAPartyMemberSetCoach>): CMsgDOTAPartyMemberSetCoach {
    return CMsgDOTAPartyMemberSetCoach.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTAPartyMemberSetCoach>): CMsgDOTAPartyMemberSetCoach {
    const message = createBaseCMsgDOTAPartyMemberSetCoach();
    message.wantsCoach = object.wantsCoach ?? false;
    return message;
  },
};

function createBaseCMsgDOTASetGroupLeader(): CMsgDOTASetGroupLeader {
  return { newLeaderSteamid: "0" };
}

export const CMsgDOTASetGroupLeader = {
  encode(message: CMsgDOTASetGroupLeader, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.newLeaderSteamid !== undefined && message.newLeaderSteamid !== "0") {
      writer.uint32(9).fixed64(message.newLeaderSteamid);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTASetGroupLeader {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTASetGroupLeader();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.newLeaderSteamid = longToString(reader.fixed64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTASetGroupLeader {
    return { newLeaderSteamid: isSet(object.newLeaderSteamid) ? globalThis.String(object.newLeaderSteamid) : "0" };
  },

  toJSON(message: CMsgDOTASetGroupLeader): unknown {
    const obj: any = {};
    if (message.newLeaderSteamid !== undefined && message.newLeaderSteamid !== "0") {
      obj.newLeaderSteamid = message.newLeaderSteamid;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTASetGroupLeader>): CMsgDOTASetGroupLeader {
    return CMsgDOTASetGroupLeader.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTASetGroupLeader>): CMsgDOTASetGroupLeader {
    const message = createBaseCMsgDOTASetGroupLeader();
    message.newLeaderSteamid = object.newLeaderSteamid ?? "0";
    return message;
  },
};

function createBaseCMsgDOTACancelGroupInvites(): CMsgDOTACancelGroupInvites {
  return { invitedSteamids: [], invitedGroupids: [] };
}

export const CMsgDOTACancelGroupInvites = {
  encode(message: CMsgDOTACancelGroupInvites, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.invitedSteamids) {
      writer.fixed64(v);
    }
    writer.ldelim();
    writer.uint32(18).fork();
    for (const v of message.invitedGroupids) {
      writer.fixed64(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTACancelGroupInvites {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTACancelGroupInvites();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 9) {
            message.invitedSteamids.push(longToString(reader.fixed64() as Long));

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.invitedSteamids.push(longToString(reader.fixed64() as Long));
            }

            continue;
          }

          break;
        case 2:
          if (tag === 17) {
            message.invitedGroupids.push(longToString(reader.fixed64() as Long));

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.invitedGroupids.push(longToString(reader.fixed64() as Long));
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTACancelGroupInvites {
    return {
      invitedSteamids: globalThis.Array.isArray(object?.invitedSteamids)
        ? object.invitedSteamids.map((e: any) => globalThis.String(e))
        : [],
      invitedGroupids: globalThis.Array.isArray(object?.invitedGroupids)
        ? object.invitedGroupids.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: CMsgDOTACancelGroupInvites): unknown {
    const obj: any = {};
    if (message.invitedSteamids?.length) {
      obj.invitedSteamids = message.invitedSteamids;
    }
    if (message.invitedGroupids?.length) {
      obj.invitedGroupids = message.invitedGroupids;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTACancelGroupInvites>): CMsgDOTACancelGroupInvites {
    return CMsgDOTACancelGroupInvites.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTACancelGroupInvites>): CMsgDOTACancelGroupInvites {
    const message = createBaseCMsgDOTACancelGroupInvites();
    message.invitedSteamids = object.invitedSteamids?.map((e) => e) || [];
    message.invitedGroupids = object.invitedGroupids?.map((e) => e) || [];
    return message;
  },
};

function createBaseCMsgDOTASetGroupOpenStatus(): CMsgDOTASetGroupOpenStatus {
  return { open: false };
}

export const CMsgDOTASetGroupOpenStatus = {
  encode(message: CMsgDOTASetGroupOpenStatus, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.open !== undefined && message.open !== false) {
      writer.uint32(8).bool(message.open);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTASetGroupOpenStatus {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTASetGroupOpenStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.open = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTASetGroupOpenStatus {
    return { open: isSet(object.open) ? globalThis.Boolean(object.open) : false };
  },

  toJSON(message: CMsgDOTASetGroupOpenStatus): unknown {
    const obj: any = {};
    if (message.open !== undefined && message.open !== false) {
      obj.open = message.open;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTASetGroupOpenStatus>): CMsgDOTASetGroupOpenStatus {
    return CMsgDOTASetGroupOpenStatus.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTASetGroupOpenStatus>): CMsgDOTASetGroupOpenStatus {
    const message = createBaseCMsgDOTASetGroupOpenStatus();
    message.open = object.open ?? false;
    return message;
  },
};

function createBaseCMsgDOTAGroupMergeInvite(): CMsgDOTAGroupMergeInvite {
  return { otherGroupId: "0" };
}

export const CMsgDOTAGroupMergeInvite = {
  encode(message: CMsgDOTAGroupMergeInvite, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.otherGroupId !== undefined && message.otherGroupId !== "0") {
      writer.uint32(9).fixed64(message.otherGroupId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTAGroupMergeInvite {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAGroupMergeInvite();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.otherGroupId = longToString(reader.fixed64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAGroupMergeInvite {
    return { otherGroupId: isSet(object.otherGroupId) ? globalThis.String(object.otherGroupId) : "0" };
  },

  toJSON(message: CMsgDOTAGroupMergeInvite): unknown {
    const obj: any = {};
    if (message.otherGroupId !== undefined && message.otherGroupId !== "0") {
      obj.otherGroupId = message.otherGroupId;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTAGroupMergeInvite>): CMsgDOTAGroupMergeInvite {
    return CMsgDOTAGroupMergeInvite.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTAGroupMergeInvite>): CMsgDOTAGroupMergeInvite {
    const message = createBaseCMsgDOTAGroupMergeInvite();
    message.otherGroupId = object.otherGroupId ?? "0";
    return message;
  },
};

function createBaseCMsgDOTAGroupMergeResponse(): CMsgDOTAGroupMergeResponse {
  return { initiatorGroupId: "0", accept: false };
}

export const CMsgDOTAGroupMergeResponse = {
  encode(message: CMsgDOTAGroupMergeResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.initiatorGroupId !== undefined && message.initiatorGroupId !== "0") {
      writer.uint32(9).fixed64(message.initiatorGroupId);
    }
    if (message.accept !== undefined && message.accept !== false) {
      writer.uint32(16).bool(message.accept);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTAGroupMergeResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAGroupMergeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.initiatorGroupId = longToString(reader.fixed64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.accept = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAGroupMergeResponse {
    return {
      initiatorGroupId: isSet(object.initiatorGroupId) ? globalThis.String(object.initiatorGroupId) : "0",
      accept: isSet(object.accept) ? globalThis.Boolean(object.accept) : false,
    };
  },

  toJSON(message: CMsgDOTAGroupMergeResponse): unknown {
    const obj: any = {};
    if (message.initiatorGroupId !== undefined && message.initiatorGroupId !== "0") {
      obj.initiatorGroupId = message.initiatorGroupId;
    }
    if (message.accept !== undefined && message.accept !== false) {
      obj.accept = message.accept;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTAGroupMergeResponse>): CMsgDOTAGroupMergeResponse {
    return CMsgDOTAGroupMergeResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTAGroupMergeResponse>): CMsgDOTAGroupMergeResponse {
    const message = createBaseCMsgDOTAGroupMergeResponse();
    message.initiatorGroupId = object.initiatorGroupId ?? "0";
    message.accept = object.accept ?? false;
    return message;
  },
};

function createBaseCMsgDOTAGroupMergeReply(): CMsgDOTAGroupMergeReply {
  return { result: 0 };
}

export const CMsgDOTAGroupMergeReply = {
  encode(message: CMsgDOTAGroupMergeReply, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result !== undefined && message.result !== 0) {
      writer.uint32(8).int32(message.result);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTAGroupMergeReply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAGroupMergeReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.result = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAGroupMergeReply {
    return { result: isSet(object.result) ? eDOTAGroupMergeResultFromJSON(object.result) : 0 };
  },

  toJSON(message: CMsgDOTAGroupMergeReply): unknown {
    const obj: any = {};
    if (message.result !== undefined && message.result !== 0) {
      obj.result = eDOTAGroupMergeResultToJSON(message.result);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTAGroupMergeReply>): CMsgDOTAGroupMergeReply {
    return CMsgDOTAGroupMergeReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTAGroupMergeReply>): CMsgDOTAGroupMergeReply {
    const message = createBaseCMsgDOTAGroupMergeReply();
    message.result = object.result ?? 0;
    return message;
  },
};

function createBaseCMsgSpectatorLobbyGameDetails(): CMsgSpectatorLobbyGameDetails {
  return {
    language: 0,
    matchId: "0",
    serverSteamId: "0",
    streamUrl: "",
    streamName: "",
    leagueId: 0,
    seriesType: 0,
    seriesGame: 0,
    radiantTeam: undefined,
    direTeam: undefined,
  };
}

export const CMsgSpectatorLobbyGameDetails = {
  encode(message: CMsgSpectatorLobbyGameDetails, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.language !== undefined && message.language !== 0) {
      writer.uint32(8).uint32(message.language);
    }
    if (message.matchId !== undefined && message.matchId !== "0") {
      writer.uint32(16).uint64(message.matchId);
    }
    if (message.serverSteamId !== undefined && message.serverSteamId !== "0") {
      writer.uint32(25).fixed64(message.serverSteamId);
    }
    if (message.streamUrl !== undefined && message.streamUrl !== "") {
      writer.uint32(34).string(message.streamUrl);
    }
    if (message.streamName !== undefined && message.streamName !== "") {
      writer.uint32(42).string(message.streamName);
    }
    if (message.leagueId !== undefined && message.leagueId !== 0) {
      writer.uint32(48).uint32(message.leagueId);
    }
    if (message.seriesType !== undefined && message.seriesType !== 0) {
      writer.uint32(56).uint32(message.seriesType);
    }
    if (message.seriesGame !== undefined && message.seriesGame !== 0) {
      writer.uint32(64).uint32(message.seriesGame);
    }
    if (message.radiantTeam !== undefined) {
      CMsgSpectatorLobbyGameDetails_Team.encode(message.radiantTeam, writer.uint32(74).fork()).ldelim();
    }
    if (message.direTeam !== undefined) {
      CMsgSpectatorLobbyGameDetails_Team.encode(message.direTeam, writer.uint32(82).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSpectatorLobbyGameDetails {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSpectatorLobbyGameDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.language = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.matchId = longToString(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.serverSteamId = longToString(reader.fixed64() as Long);
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.streamUrl = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.streamName = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.leagueId = reader.uint32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.seriesType = reader.uint32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.seriesGame = reader.uint32();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.radiantTeam = CMsgSpectatorLobbyGameDetails_Team.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.direTeam = CMsgSpectatorLobbyGameDetails_Team.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSpectatorLobbyGameDetails {
    return {
      language: isSet(object.language) ? globalThis.Number(object.language) : 0,
      matchId: isSet(object.matchId) ? globalThis.String(object.matchId) : "0",
      serverSteamId: isSet(object.serverSteamId) ? globalThis.String(object.serverSteamId) : "0",
      streamUrl: isSet(object.streamUrl) ? globalThis.String(object.streamUrl) : "",
      streamName: isSet(object.streamName) ? globalThis.String(object.streamName) : "",
      leagueId: isSet(object.leagueId) ? globalThis.Number(object.leagueId) : 0,
      seriesType: isSet(object.seriesType) ? globalThis.Number(object.seriesType) : 0,
      seriesGame: isSet(object.seriesGame) ? globalThis.Number(object.seriesGame) : 0,
      radiantTeam: isSet(object.radiantTeam)
        ? CMsgSpectatorLobbyGameDetails_Team.fromJSON(object.radiantTeam)
        : undefined,
      direTeam: isSet(object.direTeam) ? CMsgSpectatorLobbyGameDetails_Team.fromJSON(object.direTeam) : undefined,
    };
  },

  toJSON(message: CMsgSpectatorLobbyGameDetails): unknown {
    const obj: any = {};
    if (message.language !== undefined && message.language !== 0) {
      obj.language = Math.round(message.language);
    }
    if (message.matchId !== undefined && message.matchId !== "0") {
      obj.matchId = message.matchId;
    }
    if (message.serverSteamId !== undefined && message.serverSteamId !== "0") {
      obj.serverSteamId = message.serverSteamId;
    }
    if (message.streamUrl !== undefined && message.streamUrl !== "") {
      obj.streamUrl = message.streamUrl;
    }
    if (message.streamName !== undefined && message.streamName !== "") {
      obj.streamName = message.streamName;
    }
    if (message.leagueId !== undefined && message.leagueId !== 0) {
      obj.leagueId = Math.round(message.leagueId);
    }
    if (message.seriesType !== undefined && message.seriesType !== 0) {
      obj.seriesType = Math.round(message.seriesType);
    }
    if (message.seriesGame !== undefined && message.seriesGame !== 0) {
      obj.seriesGame = Math.round(message.seriesGame);
    }
    if (message.radiantTeam !== undefined) {
      obj.radiantTeam = CMsgSpectatorLobbyGameDetails_Team.toJSON(message.radiantTeam);
    }
    if (message.direTeam !== undefined) {
      obj.direTeam = CMsgSpectatorLobbyGameDetails_Team.toJSON(message.direTeam);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSpectatorLobbyGameDetails>): CMsgSpectatorLobbyGameDetails {
    return CMsgSpectatorLobbyGameDetails.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSpectatorLobbyGameDetails>): CMsgSpectatorLobbyGameDetails {
    const message = createBaseCMsgSpectatorLobbyGameDetails();
    message.language = object.language ?? 0;
    message.matchId = object.matchId ?? "0";
    message.serverSteamId = object.serverSteamId ?? "0";
    message.streamUrl = object.streamUrl ?? "";
    message.streamName = object.streamName ?? "";
    message.leagueId = object.leagueId ?? 0;
    message.seriesType = object.seriesType ?? 0;
    message.seriesGame = object.seriesGame ?? 0;
    message.radiantTeam = (object.radiantTeam !== undefined && object.radiantTeam !== null)
      ? CMsgSpectatorLobbyGameDetails_Team.fromPartial(object.radiantTeam)
      : undefined;
    message.direTeam = (object.direTeam !== undefined && object.direTeam !== null)
      ? CMsgSpectatorLobbyGameDetails_Team.fromPartial(object.direTeam)
      : undefined;
    return message;
  },
};

function createBaseCMsgSpectatorLobbyGameDetails_Team(): CMsgSpectatorLobbyGameDetails_Team {
  return { teamId: 0, teamName: "", teamLogo: "0" };
}

export const CMsgSpectatorLobbyGameDetails_Team = {
  encode(message: CMsgSpectatorLobbyGameDetails_Team, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.teamId !== undefined && message.teamId !== 0) {
      writer.uint32(8).uint32(message.teamId);
    }
    if (message.teamName !== undefined && message.teamName !== "") {
      writer.uint32(18).string(message.teamName);
    }
    if (message.teamLogo !== undefined && message.teamLogo !== "0") {
      writer.uint32(25).fixed64(message.teamLogo);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSpectatorLobbyGameDetails_Team {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSpectatorLobbyGameDetails_Team();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.teamId = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.teamName = reader.string();
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.teamLogo = longToString(reader.fixed64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSpectatorLobbyGameDetails_Team {
    return {
      teamId: isSet(object.teamId) ? globalThis.Number(object.teamId) : 0,
      teamName: isSet(object.teamName) ? globalThis.String(object.teamName) : "",
      teamLogo: isSet(object.teamLogo) ? globalThis.String(object.teamLogo) : "0",
    };
  },

  toJSON(message: CMsgSpectatorLobbyGameDetails_Team): unknown {
    const obj: any = {};
    if (message.teamId !== undefined && message.teamId !== 0) {
      obj.teamId = Math.round(message.teamId);
    }
    if (message.teamName !== undefined && message.teamName !== "") {
      obj.teamName = message.teamName;
    }
    if (message.teamLogo !== undefined && message.teamLogo !== "0") {
      obj.teamLogo = message.teamLogo;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSpectatorLobbyGameDetails_Team>): CMsgSpectatorLobbyGameDetails_Team {
    return CMsgSpectatorLobbyGameDetails_Team.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSpectatorLobbyGameDetails_Team>): CMsgSpectatorLobbyGameDetails_Team {
    const message = createBaseCMsgSpectatorLobbyGameDetails_Team();
    message.teamId = object.teamId ?? 0;
    message.teamName = object.teamName ?? "";
    message.teamLogo = object.teamLogo ?? "0";
    return message;
  },
};

function createBaseCMsgSetSpectatorLobbyDetails(): CMsgSetSpectatorLobbyDetails {
  return { lobbyId: "0", lobbyName: "", passKey: "", gameDetails: undefined };
}

export const CMsgSetSpectatorLobbyDetails = {
  encode(message: CMsgSetSpectatorLobbyDetails, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.lobbyId !== undefined && message.lobbyId !== "0") {
      writer.uint32(8).uint64(message.lobbyId);
    }
    if (message.lobbyName !== undefined && message.lobbyName !== "") {
      writer.uint32(18).string(message.lobbyName);
    }
    if (message.passKey !== undefined && message.passKey !== "") {
      writer.uint32(26).string(message.passKey);
    }
    if (message.gameDetails !== undefined) {
      CMsgSpectatorLobbyGameDetails.encode(message.gameDetails, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSetSpectatorLobbyDetails {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSetSpectatorLobbyDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.lobbyId = longToString(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.lobbyName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.passKey = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.gameDetails = CMsgSpectatorLobbyGameDetails.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSetSpectatorLobbyDetails {
    return {
      lobbyId: isSet(object.lobbyId) ? globalThis.String(object.lobbyId) : "0",
      lobbyName: isSet(object.lobbyName) ? globalThis.String(object.lobbyName) : "",
      passKey: isSet(object.passKey) ? globalThis.String(object.passKey) : "",
      gameDetails: isSet(object.gameDetails) ? CMsgSpectatorLobbyGameDetails.fromJSON(object.gameDetails) : undefined,
    };
  },

  toJSON(message: CMsgSetSpectatorLobbyDetails): unknown {
    const obj: any = {};
    if (message.lobbyId !== undefined && message.lobbyId !== "0") {
      obj.lobbyId = message.lobbyId;
    }
    if (message.lobbyName !== undefined && message.lobbyName !== "") {
      obj.lobbyName = message.lobbyName;
    }
    if (message.passKey !== undefined && message.passKey !== "") {
      obj.passKey = message.passKey;
    }
    if (message.gameDetails !== undefined) {
      obj.gameDetails = CMsgSpectatorLobbyGameDetails.toJSON(message.gameDetails);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSetSpectatorLobbyDetails>): CMsgSetSpectatorLobbyDetails {
    return CMsgSetSpectatorLobbyDetails.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSetSpectatorLobbyDetails>): CMsgSetSpectatorLobbyDetails {
    const message = createBaseCMsgSetSpectatorLobbyDetails();
    message.lobbyId = object.lobbyId ?? "0";
    message.lobbyName = object.lobbyName ?? "";
    message.passKey = object.passKey ?? "";
    message.gameDetails = (object.gameDetails !== undefined && object.gameDetails !== null)
      ? CMsgSpectatorLobbyGameDetails.fromPartial(object.gameDetails)
      : undefined;
    return message;
  },
};

function createBaseCMsgCreateSpectatorLobby(): CMsgCreateSpectatorLobby {
  return { clientVersion: 0, details: undefined };
}

export const CMsgCreateSpectatorLobby = {
  encode(message: CMsgCreateSpectatorLobby, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.clientVersion !== undefined && message.clientVersion !== 0) {
      writer.uint32(8).uint32(message.clientVersion);
    }
    if (message.details !== undefined) {
      CMsgSetSpectatorLobbyDetails.encode(message.details, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgCreateSpectatorLobby {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgCreateSpectatorLobby();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.clientVersion = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.details = CMsgSetSpectatorLobbyDetails.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgCreateSpectatorLobby {
    return {
      clientVersion: isSet(object.clientVersion) ? globalThis.Number(object.clientVersion) : 0,
      details: isSet(object.details) ? CMsgSetSpectatorLobbyDetails.fromJSON(object.details) : undefined,
    };
  },

  toJSON(message: CMsgCreateSpectatorLobby): unknown {
    const obj: any = {};
    if (message.clientVersion !== undefined && message.clientVersion !== 0) {
      obj.clientVersion = Math.round(message.clientVersion);
    }
    if (message.details !== undefined) {
      obj.details = CMsgSetSpectatorLobbyDetails.toJSON(message.details);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgCreateSpectatorLobby>): CMsgCreateSpectatorLobby {
    return CMsgCreateSpectatorLobby.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgCreateSpectatorLobby>): CMsgCreateSpectatorLobby {
    const message = createBaseCMsgCreateSpectatorLobby();
    message.clientVersion = object.clientVersion ?? 0;
    message.details = (object.details !== undefined && object.details !== null)
      ? CMsgSetSpectatorLobbyDetails.fromPartial(object.details)
      : undefined;
    return message;
  },
};

function createBaseCMsgSpectatorLobbyList(): CMsgSpectatorLobbyList {
  return {};
}

export const CMsgSpectatorLobbyList = {
  encode(_: CMsgSpectatorLobbyList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSpectatorLobbyList {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSpectatorLobbyList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CMsgSpectatorLobbyList {
    return {};
  },

  toJSON(_: CMsgSpectatorLobbyList): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<CMsgSpectatorLobbyList>): CMsgSpectatorLobbyList {
    return CMsgSpectatorLobbyList.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<CMsgSpectatorLobbyList>): CMsgSpectatorLobbyList {
    const message = createBaseCMsgSpectatorLobbyList();
    return message;
  },
};

function createBaseCMsgSpectatorLobbyListResponse(): CMsgSpectatorLobbyListResponse {
  return { lobbies: [] };
}

export const CMsgSpectatorLobbyListResponse = {
  encode(message: CMsgSpectatorLobbyListResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.lobbies) {
      CMsgSpectatorLobbyListResponse_SpectatorLobby.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSpectatorLobbyListResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSpectatorLobbyListResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.lobbies.push(CMsgSpectatorLobbyListResponse_SpectatorLobby.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSpectatorLobbyListResponse {
    return {
      lobbies: globalThis.Array.isArray(object?.lobbies)
        ? object.lobbies.map((e: any) => CMsgSpectatorLobbyListResponse_SpectatorLobby.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgSpectatorLobbyListResponse): unknown {
    const obj: any = {};
    if (message.lobbies?.length) {
      obj.lobbies = message.lobbies.map((e) => CMsgSpectatorLobbyListResponse_SpectatorLobby.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSpectatorLobbyListResponse>): CMsgSpectatorLobbyListResponse {
    return CMsgSpectatorLobbyListResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSpectatorLobbyListResponse>): CMsgSpectatorLobbyListResponse {
    const message = createBaseCMsgSpectatorLobbyListResponse();
    message.lobbies = object.lobbies?.map((e) => CMsgSpectatorLobbyListResponse_SpectatorLobby.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgSpectatorLobbyListResponse_SpectatorLobby(): CMsgSpectatorLobbyListResponse_SpectatorLobby {
  return {
    lobbyId: "0",
    gameName: "",
    requiresPassKey: false,
    leaderAccountId: 0,
    memberCount: 0,
    gameDetails: undefined,
  };
}

export const CMsgSpectatorLobbyListResponse_SpectatorLobby = {
  encode(message: CMsgSpectatorLobbyListResponse_SpectatorLobby, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.lobbyId !== undefined && message.lobbyId !== "0") {
      writer.uint32(8).uint64(message.lobbyId);
    }
    if (message.gameName !== undefined && message.gameName !== "") {
      writer.uint32(18).string(message.gameName);
    }
    if (message.requiresPassKey !== undefined && message.requiresPassKey !== false) {
      writer.uint32(24).bool(message.requiresPassKey);
    }
    if (message.leaderAccountId !== undefined && message.leaderAccountId !== 0) {
      writer.uint32(32).uint32(message.leaderAccountId);
    }
    if (message.memberCount !== undefined && message.memberCount !== 0) {
      writer.uint32(40).uint32(message.memberCount);
    }
    if (message.gameDetails !== undefined) {
      CMsgSpectatorLobbyGameDetails.encode(message.gameDetails, writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSpectatorLobbyListResponse_SpectatorLobby {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSpectatorLobbyListResponse_SpectatorLobby();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.lobbyId = longToString(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.gameName = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.requiresPassKey = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.leaderAccountId = reader.uint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.memberCount = reader.uint32();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.gameDetails = CMsgSpectatorLobbyGameDetails.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSpectatorLobbyListResponse_SpectatorLobby {
    return {
      lobbyId: isSet(object.lobbyId) ? globalThis.String(object.lobbyId) : "0",
      gameName: isSet(object.gameName) ? globalThis.String(object.gameName) : "",
      requiresPassKey: isSet(object.requiresPassKey) ? globalThis.Boolean(object.requiresPassKey) : false,
      leaderAccountId: isSet(object.leaderAccountId) ? globalThis.Number(object.leaderAccountId) : 0,
      memberCount: isSet(object.memberCount) ? globalThis.Number(object.memberCount) : 0,
      gameDetails: isSet(object.gameDetails) ? CMsgSpectatorLobbyGameDetails.fromJSON(object.gameDetails) : undefined,
    };
  },

  toJSON(message: CMsgSpectatorLobbyListResponse_SpectatorLobby): unknown {
    const obj: any = {};
    if (message.lobbyId !== undefined && message.lobbyId !== "0") {
      obj.lobbyId = message.lobbyId;
    }
    if (message.gameName !== undefined && message.gameName !== "") {
      obj.gameName = message.gameName;
    }
    if (message.requiresPassKey !== undefined && message.requiresPassKey !== false) {
      obj.requiresPassKey = message.requiresPassKey;
    }
    if (message.leaderAccountId !== undefined && message.leaderAccountId !== 0) {
      obj.leaderAccountId = Math.round(message.leaderAccountId);
    }
    if (message.memberCount !== undefined && message.memberCount !== 0) {
      obj.memberCount = Math.round(message.memberCount);
    }
    if (message.gameDetails !== undefined) {
      obj.gameDetails = CMsgSpectatorLobbyGameDetails.toJSON(message.gameDetails);
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgSpectatorLobbyListResponse_SpectatorLobby>,
  ): CMsgSpectatorLobbyListResponse_SpectatorLobby {
    return CMsgSpectatorLobbyListResponse_SpectatorLobby.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgSpectatorLobbyListResponse_SpectatorLobby>,
  ): CMsgSpectatorLobbyListResponse_SpectatorLobby {
    const message = createBaseCMsgSpectatorLobbyListResponse_SpectatorLobby();
    message.lobbyId = object.lobbyId ?? "0";
    message.gameName = object.gameName ?? "";
    message.requiresPassKey = object.requiresPassKey ?? false;
    message.leaderAccountId = object.leaderAccountId ?? 0;
    message.memberCount = object.memberCount ?? 0;
    message.gameDetails = (object.gameDetails !== undefined && object.gameDetails !== null)
      ? CMsgSpectatorLobbyGameDetails.fromPartial(object.gameDetails)
      : undefined;
    return message;
  },
};

function createBaseCMsgClientToGCRequestSteamDatagramTicket(): CMsgClientToGCRequestSteamDatagramTicket {
  return { serverSteamId: "0" };
}

export const CMsgClientToGCRequestSteamDatagramTicket = {
  encode(message: CMsgClientToGCRequestSteamDatagramTicket, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.serverSteamId !== undefined && message.serverSteamId !== "0") {
      writer.uint32(9).fixed64(message.serverSteamId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCRequestSteamDatagramTicket {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCRequestSteamDatagramTicket();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.serverSteamId = longToString(reader.fixed64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCRequestSteamDatagramTicket {
    return { serverSteamId: isSet(object.serverSteamId) ? globalThis.String(object.serverSteamId) : "0" };
  },

  toJSON(message: CMsgClientToGCRequestSteamDatagramTicket): unknown {
    const obj: any = {};
    if (message.serverSteamId !== undefined && message.serverSteamId !== "0") {
      obj.serverSteamId = message.serverSteamId;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgClientToGCRequestSteamDatagramTicket>): CMsgClientToGCRequestSteamDatagramTicket {
    return CMsgClientToGCRequestSteamDatagramTicket.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgClientToGCRequestSteamDatagramTicket>): CMsgClientToGCRequestSteamDatagramTicket {
    const message = createBaseCMsgClientToGCRequestSteamDatagramTicket();
    message.serverSteamId = object.serverSteamId ?? "0";
    return message;
  },
};

function createBaseCMsgClientToGCRequestSteamDatagramTicketResponse(): CMsgClientToGCRequestSteamDatagramTicketResponse {
  return { serializedTicket: Buffer.alloc(0), message: "" };
}

export const CMsgClientToGCRequestSteamDatagramTicketResponse = {
  encode(
    message: CMsgClientToGCRequestSteamDatagramTicketResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.serializedTicket !== undefined && message.serializedTicket.length !== 0) {
      writer.uint32(10).bytes(message.serializedTicket);
    }
    if (message.message !== undefined && message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCRequestSteamDatagramTicketResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCRequestSteamDatagramTicketResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.serializedTicket = reader.bytes() as Buffer;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCRequestSteamDatagramTicketResponse {
    return {
      serializedTicket: isSet(object.serializedTicket)
        ? Buffer.from(bytesFromBase64(object.serializedTicket))
        : Buffer.alloc(0),
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: CMsgClientToGCRequestSteamDatagramTicketResponse): unknown {
    const obj: any = {};
    if (message.serializedTicket !== undefined && message.serializedTicket.length !== 0) {
      obj.serializedTicket = base64FromBytes(message.serializedTicket);
    }
    if (message.message !== undefined && message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgClientToGCRequestSteamDatagramTicketResponse>,
  ): CMsgClientToGCRequestSteamDatagramTicketResponse {
    return CMsgClientToGCRequestSteamDatagramTicketResponse.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgClientToGCRequestSteamDatagramTicketResponse>,
  ): CMsgClientToGCRequestSteamDatagramTicketResponse {
    const message = createBaseCMsgClientToGCRequestSteamDatagramTicketResponse();
    message.serializedTicket = object.serializedTicket ?? Buffer.alloc(0);
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseCMsgGCToClientSteamDatagramTicket(): CMsgGCToClientSteamDatagramTicket {
  return {
    legacyTimeExpiry: 0,
    legacyAuthorizedSteamId: "0",
    legacyAuthorizedPublicIp: 0,
    legacyGameserverSteamId: "0",
    legacyGameserverNetId: "0",
    legacySignature: Buffer.alloc(0),
    legacyAppId: 0,
    legacyExtraFields: [],
    serializedTicket: Buffer.alloc(0),
  };
}

export const CMsgGCToClientSteamDatagramTicket = {
  encode(message: CMsgGCToClientSteamDatagramTicket, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.legacyTimeExpiry !== undefined && message.legacyTimeExpiry !== 0) {
      writer.uint32(13).fixed32(message.legacyTimeExpiry);
    }
    if (message.legacyAuthorizedSteamId !== undefined && message.legacyAuthorizedSteamId !== "0") {
      writer.uint32(17).fixed64(message.legacyAuthorizedSteamId);
    }
    if (message.legacyAuthorizedPublicIp !== undefined && message.legacyAuthorizedPublicIp !== 0) {
      writer.uint32(29).fixed32(message.legacyAuthorizedPublicIp);
    }
    if (message.legacyGameserverSteamId !== undefined && message.legacyGameserverSteamId !== "0") {
      writer.uint32(33).fixed64(message.legacyGameserverSteamId);
    }
    if (message.legacyGameserverNetId !== undefined && message.legacyGameserverNetId !== "0") {
      writer.uint32(41).fixed64(message.legacyGameserverNetId);
    }
    if (message.legacySignature !== undefined && message.legacySignature.length !== 0) {
      writer.uint32(50).bytes(message.legacySignature);
    }
    if (message.legacyAppId !== undefined && message.legacyAppId !== 0) {
      writer.uint32(56).uint32(message.legacyAppId);
    }
    for (const v of message.legacyExtraFields) {
      writer.uint32(66).bytes(v!);
    }
    if (message.serializedTicket !== undefined && message.serializedTicket.length !== 0) {
      writer.uint32(130).bytes(message.serializedTicket);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToClientSteamDatagramTicket {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientSteamDatagramTicket();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.legacyTimeExpiry = reader.fixed32();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.legacyAuthorizedSteamId = longToString(reader.fixed64() as Long);
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.legacyAuthorizedPublicIp = reader.fixed32();
          continue;
        case 4:
          if (tag !== 33) {
            break;
          }

          message.legacyGameserverSteamId = longToString(reader.fixed64() as Long);
          continue;
        case 5:
          if (tag !== 41) {
            break;
          }

          message.legacyGameserverNetId = longToString(reader.fixed64() as Long);
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.legacySignature = reader.bytes() as Buffer;
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.legacyAppId = reader.uint32();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.legacyExtraFields.push(reader.bytes() as Buffer);
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.serializedTicket = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientSteamDatagramTicket {
    return {
      legacyTimeExpiry: isSet(object.legacyTimeExpiry) ? globalThis.Number(object.legacyTimeExpiry) : 0,
      legacyAuthorizedSteamId: isSet(object.legacyAuthorizedSteamId)
        ? globalThis.String(object.legacyAuthorizedSteamId)
        : "0",
      legacyAuthorizedPublicIp: isSet(object.legacyAuthorizedPublicIp)
        ? globalThis.Number(object.legacyAuthorizedPublicIp)
        : 0,
      legacyGameserverSteamId: isSet(object.legacyGameserverSteamId)
        ? globalThis.String(object.legacyGameserverSteamId)
        : "0",
      legacyGameserverNetId: isSet(object.legacyGameserverNetId)
        ? globalThis.String(object.legacyGameserverNetId)
        : "0",
      legacySignature: isSet(object.legacySignature)
        ? Buffer.from(bytesFromBase64(object.legacySignature))
        : Buffer.alloc(0),
      legacyAppId: isSet(object.legacyAppId) ? globalThis.Number(object.legacyAppId) : 0,
      legacyExtraFields: globalThis.Array.isArray(object?.legacyExtraFields)
        ? object.legacyExtraFields.map((e: any) => Buffer.from(bytesFromBase64(e)))
        : [],
      serializedTicket: isSet(object.serializedTicket)
        ? Buffer.from(bytesFromBase64(object.serializedTicket))
        : Buffer.alloc(0),
    };
  },

  toJSON(message: CMsgGCToClientSteamDatagramTicket): unknown {
    const obj: any = {};
    if (message.legacyTimeExpiry !== undefined && message.legacyTimeExpiry !== 0) {
      obj.legacyTimeExpiry = Math.round(message.legacyTimeExpiry);
    }
    if (message.legacyAuthorizedSteamId !== undefined && message.legacyAuthorizedSteamId !== "0") {
      obj.legacyAuthorizedSteamId = message.legacyAuthorizedSteamId;
    }
    if (message.legacyAuthorizedPublicIp !== undefined && message.legacyAuthorizedPublicIp !== 0) {
      obj.legacyAuthorizedPublicIp = Math.round(message.legacyAuthorizedPublicIp);
    }
    if (message.legacyGameserverSteamId !== undefined && message.legacyGameserverSteamId !== "0") {
      obj.legacyGameserverSteamId = message.legacyGameserverSteamId;
    }
    if (message.legacyGameserverNetId !== undefined && message.legacyGameserverNetId !== "0") {
      obj.legacyGameserverNetId = message.legacyGameserverNetId;
    }
    if (message.legacySignature !== undefined && message.legacySignature.length !== 0) {
      obj.legacySignature = base64FromBytes(message.legacySignature);
    }
    if (message.legacyAppId !== undefined && message.legacyAppId !== 0) {
      obj.legacyAppId = Math.round(message.legacyAppId);
    }
    if (message.legacyExtraFields?.length) {
      obj.legacyExtraFields = message.legacyExtraFields.map((e) => base64FromBytes(e));
    }
    if (message.serializedTicket !== undefined && message.serializedTicket.length !== 0) {
      obj.serializedTicket = base64FromBytes(message.serializedTicket);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCToClientSteamDatagramTicket>): CMsgGCToClientSteamDatagramTicket {
    return CMsgGCToClientSteamDatagramTicket.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCToClientSteamDatagramTicket>): CMsgGCToClientSteamDatagramTicket {
    const message = createBaseCMsgGCToClientSteamDatagramTicket();
    message.legacyTimeExpiry = object.legacyTimeExpiry ?? 0;
    message.legacyAuthorizedSteamId = object.legacyAuthorizedSteamId ?? "0";
    message.legacyAuthorizedPublicIp = object.legacyAuthorizedPublicIp ?? 0;
    message.legacyGameserverSteamId = object.legacyGameserverSteamId ?? "0";
    message.legacyGameserverNetId = object.legacyGameserverNetId ?? "0";
    message.legacySignature = object.legacySignature ?? Buffer.alloc(0);
    message.legacyAppId = object.legacyAppId ?? 0;
    message.legacyExtraFields = object.legacyExtraFields?.map((e) => e) || [];
    message.serializedTicket = object.serializedTicket ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseCMsgGCToClientRequestLaneSelection(): CMsgGCToClientRequestLaneSelection {
  return {};
}

export const CMsgGCToClientRequestLaneSelection = {
  encode(_: CMsgGCToClientRequestLaneSelection, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToClientRequestLaneSelection {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientRequestLaneSelection();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CMsgGCToClientRequestLaneSelection {
    return {};
  },

  toJSON(_: CMsgGCToClientRequestLaneSelection): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<CMsgGCToClientRequestLaneSelection>): CMsgGCToClientRequestLaneSelection {
    return CMsgGCToClientRequestLaneSelection.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<CMsgGCToClientRequestLaneSelection>): CMsgGCToClientRequestLaneSelection {
    const message = createBaseCMsgGCToClientRequestLaneSelection();
    return message;
  },
};

function createBaseCMsgGCToClientRequestLaneSelectionResponse(): CMsgGCToClientRequestLaneSelectionResponse {
  return { laneSelectionFlags: 0, highPriorityDisabled: false };
}

export const CMsgGCToClientRequestLaneSelectionResponse = {
  encode(message: CMsgGCToClientRequestLaneSelectionResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.laneSelectionFlags !== undefined && message.laneSelectionFlags !== 0) {
      writer.uint32(8).uint32(message.laneSelectionFlags);
    }
    if (message.highPriorityDisabled !== undefined && message.highPriorityDisabled !== false) {
      writer.uint32(16).bool(message.highPriorityDisabled);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToClientRequestLaneSelectionResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientRequestLaneSelectionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.laneSelectionFlags = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.highPriorityDisabled = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCToClientRequestLaneSelectionResponse {
    return {
      laneSelectionFlags: isSet(object.laneSelectionFlags) ? globalThis.Number(object.laneSelectionFlags) : 0,
      highPriorityDisabled: isSet(object.highPriorityDisabled)
        ? globalThis.Boolean(object.highPriorityDisabled)
        : false,
    };
  },

  toJSON(message: CMsgGCToClientRequestLaneSelectionResponse): unknown {
    const obj: any = {};
    if (message.laneSelectionFlags !== undefined && message.laneSelectionFlags !== 0) {
      obj.laneSelectionFlags = Math.round(message.laneSelectionFlags);
    }
    if (message.highPriorityDisabled !== undefined && message.highPriorityDisabled !== false) {
      obj.highPriorityDisabled = message.highPriorityDisabled;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCToClientRequestLaneSelectionResponse>): CMsgGCToClientRequestLaneSelectionResponse {
    return CMsgGCToClientRequestLaneSelectionResponse.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgGCToClientRequestLaneSelectionResponse>,
  ): CMsgGCToClientRequestLaneSelectionResponse {
    const message = createBaseCMsgGCToClientRequestLaneSelectionResponse();
    message.laneSelectionFlags = object.laneSelectionFlags ?? 0;
    message.highPriorityDisabled = object.highPriorityDisabled ?? false;
    return message;
  },
};

function createBaseCMsgGCToClientRequestMMInfo(): CMsgGCToClientRequestMMInfo {
  return {};
}

export const CMsgGCToClientRequestMMInfo = {
  encode(_: CMsgGCToClientRequestMMInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCToClientRequestMMInfo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCToClientRequestMMInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CMsgGCToClientRequestMMInfo {
    return {};
  },

  toJSON(_: CMsgGCToClientRequestMMInfo): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<CMsgGCToClientRequestMMInfo>): CMsgGCToClientRequestMMInfo {
    return CMsgGCToClientRequestMMInfo.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<CMsgGCToClientRequestMMInfo>): CMsgGCToClientRequestMMInfo {
    const message = createBaseCMsgGCToClientRequestMMInfo();
    return message;
  },
};

function createBaseCMsgClientToGCMMInfo(): CMsgClientToGCMMInfo {
  return { laneSelectionFlags: 0, highPriorityDisabled: false };
}

export const CMsgClientToGCMMInfo = {
  encode(message: CMsgClientToGCMMInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.laneSelectionFlags !== undefined && message.laneSelectionFlags !== 0) {
      writer.uint32(8).uint32(message.laneSelectionFlags);
    }
    if (message.highPriorityDisabled !== undefined && message.highPriorityDisabled !== false) {
      writer.uint32(16).bool(message.highPriorityDisabled);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientToGCMMInfo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientToGCMMInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.laneSelectionFlags = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.highPriorityDisabled = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientToGCMMInfo {
    return {
      laneSelectionFlags: isSet(object.laneSelectionFlags) ? globalThis.Number(object.laneSelectionFlags) : 0,
      highPriorityDisabled: isSet(object.highPriorityDisabled)
        ? globalThis.Boolean(object.highPriorityDisabled)
        : false,
    };
  },

  toJSON(message: CMsgClientToGCMMInfo): unknown {
    const obj: any = {};
    if (message.laneSelectionFlags !== undefined && message.laneSelectionFlags !== 0) {
      obj.laneSelectionFlags = Math.round(message.laneSelectionFlags);
    }
    if (message.highPriorityDisabled !== undefined && message.highPriorityDisabled !== false) {
      obj.highPriorityDisabled = message.highPriorityDisabled;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgClientToGCMMInfo>): CMsgClientToGCMMInfo {
    return CMsgClientToGCMMInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgClientToGCMMInfo>): CMsgClientToGCMMInfo {
    const message = createBaseCMsgClientToGCMMInfo();
    message.laneSelectionFlags = object.laneSelectionFlags ?? 0;
    message.highPriorityDisabled = object.highPriorityDisabled ?? false;
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function longToString(long: Long) {
  return long.toString();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

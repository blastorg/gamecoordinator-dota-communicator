// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.176.1
//   protoc               v5.26.1
// source: usermessages.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";
import { CEntityMsg, CMsgQAngle, CMsgQuaternion, CMsgVector } from "./networkbasetypes";

export enum EBaseUserMessages {
  UM_AchievementEvent = 101,
  UM_CloseCaption = 102,
  UM_CloseCaptionDirect = 103,
  UM_CurrentTimescale = 104,
  UM_DesiredTimescale = 105,
  UM_Fade = 106,
  UM_GameTitle = 107,
  UM_HudMsg = 110,
  UM_HudText = 111,
  UM_ColoredText = 113,
  UM_RequestState = 114,
  UM_ResetHUD = 115,
  UM_Rumble = 116,
  UM_SayText = 117,
  UM_SayText2 = 118,
  UM_SayTextChannel = 119,
  UM_Shake = 120,
  UM_ShakeDir = 121,
  UM_WaterShake = 122,
  UM_TextMsg = 124,
  UM_ScreenTilt = 125,
  UM_VoiceMask = 128,
  UM_SendAudio = 130,
  UM_ItemPickup = 131,
  UM_AmmoDenied = 132,
  UM_ShowMenu = 134,
  UM_CreditsMsg = 135,
  UM_CloseCaptionPlaceholder = 142,
  UM_CameraTransition = 143,
  UM_AudioParameter = 144,
  UM_ParticleManager = 145,
  UM_HudError = 146,
  UM_CustomGameEvent = 148,
  UM_AnimGraphUpdate = 149,
  UM_HapticsManagerPulse = 150,
  UM_HapticsManagerEffect = 151,
  UM_CommandQueueState = 152,
  UM_UpdateCssClasses = 153,
  UM_ServerFrameTime = 154,
  UM_LagCompensationError = 155,
  UM_RequestDllStatus = 156,
  UM_RequestUtilAction = 157,
  UM_UtilActionResponse = 158,
  UM_DllStatusResponse = 159,
  UM_RequestInventory = 160,
  UM_InventoryResponse = 161,
  UM_RequestDiagnostic = 162,
  UM_DiagnosticResponse = 163,
  UM_ExtraUserData = 164,
  UM_NotifyResponseFound = 165,
  UM_PlayResponseConditional = 166,
  UM_MAX_BASE = 200,
}

export function eBaseUserMessagesFromJSON(object: any): EBaseUserMessages {
  switch (object) {
    case 101:
    case "UM_AchievementEvent":
      return EBaseUserMessages.UM_AchievementEvent;
    case 102:
    case "UM_CloseCaption":
      return EBaseUserMessages.UM_CloseCaption;
    case 103:
    case "UM_CloseCaptionDirect":
      return EBaseUserMessages.UM_CloseCaptionDirect;
    case 104:
    case "UM_CurrentTimescale":
      return EBaseUserMessages.UM_CurrentTimescale;
    case 105:
    case "UM_DesiredTimescale":
      return EBaseUserMessages.UM_DesiredTimescale;
    case 106:
    case "UM_Fade":
      return EBaseUserMessages.UM_Fade;
    case 107:
    case "UM_GameTitle":
      return EBaseUserMessages.UM_GameTitle;
    case 110:
    case "UM_HudMsg":
      return EBaseUserMessages.UM_HudMsg;
    case 111:
    case "UM_HudText":
      return EBaseUserMessages.UM_HudText;
    case 113:
    case "UM_ColoredText":
      return EBaseUserMessages.UM_ColoredText;
    case 114:
    case "UM_RequestState":
      return EBaseUserMessages.UM_RequestState;
    case 115:
    case "UM_ResetHUD":
      return EBaseUserMessages.UM_ResetHUD;
    case 116:
    case "UM_Rumble":
      return EBaseUserMessages.UM_Rumble;
    case 117:
    case "UM_SayText":
      return EBaseUserMessages.UM_SayText;
    case 118:
    case "UM_SayText2":
      return EBaseUserMessages.UM_SayText2;
    case 119:
    case "UM_SayTextChannel":
      return EBaseUserMessages.UM_SayTextChannel;
    case 120:
    case "UM_Shake":
      return EBaseUserMessages.UM_Shake;
    case 121:
    case "UM_ShakeDir":
      return EBaseUserMessages.UM_ShakeDir;
    case 122:
    case "UM_WaterShake":
      return EBaseUserMessages.UM_WaterShake;
    case 124:
    case "UM_TextMsg":
      return EBaseUserMessages.UM_TextMsg;
    case 125:
    case "UM_ScreenTilt":
      return EBaseUserMessages.UM_ScreenTilt;
    case 128:
    case "UM_VoiceMask":
      return EBaseUserMessages.UM_VoiceMask;
    case 130:
    case "UM_SendAudio":
      return EBaseUserMessages.UM_SendAudio;
    case 131:
    case "UM_ItemPickup":
      return EBaseUserMessages.UM_ItemPickup;
    case 132:
    case "UM_AmmoDenied":
      return EBaseUserMessages.UM_AmmoDenied;
    case 134:
    case "UM_ShowMenu":
      return EBaseUserMessages.UM_ShowMenu;
    case 135:
    case "UM_CreditsMsg":
      return EBaseUserMessages.UM_CreditsMsg;
    case 142:
    case "UM_CloseCaptionPlaceholder":
      return EBaseUserMessages.UM_CloseCaptionPlaceholder;
    case 143:
    case "UM_CameraTransition":
      return EBaseUserMessages.UM_CameraTransition;
    case 144:
    case "UM_AudioParameter":
      return EBaseUserMessages.UM_AudioParameter;
    case 145:
    case "UM_ParticleManager":
      return EBaseUserMessages.UM_ParticleManager;
    case 146:
    case "UM_HudError":
      return EBaseUserMessages.UM_HudError;
    case 148:
    case "UM_CustomGameEvent":
      return EBaseUserMessages.UM_CustomGameEvent;
    case 149:
    case "UM_AnimGraphUpdate":
      return EBaseUserMessages.UM_AnimGraphUpdate;
    case 150:
    case "UM_HapticsManagerPulse":
      return EBaseUserMessages.UM_HapticsManagerPulse;
    case 151:
    case "UM_HapticsManagerEffect":
      return EBaseUserMessages.UM_HapticsManagerEffect;
    case 152:
    case "UM_CommandQueueState":
      return EBaseUserMessages.UM_CommandQueueState;
    case 153:
    case "UM_UpdateCssClasses":
      return EBaseUserMessages.UM_UpdateCssClasses;
    case 154:
    case "UM_ServerFrameTime":
      return EBaseUserMessages.UM_ServerFrameTime;
    case 155:
    case "UM_LagCompensationError":
      return EBaseUserMessages.UM_LagCompensationError;
    case 156:
    case "UM_RequestDllStatus":
      return EBaseUserMessages.UM_RequestDllStatus;
    case 157:
    case "UM_RequestUtilAction":
      return EBaseUserMessages.UM_RequestUtilAction;
    case 158:
    case "UM_UtilActionResponse":
      return EBaseUserMessages.UM_UtilActionResponse;
    case 159:
    case "UM_DllStatusResponse":
      return EBaseUserMessages.UM_DllStatusResponse;
    case 160:
    case "UM_RequestInventory":
      return EBaseUserMessages.UM_RequestInventory;
    case 161:
    case "UM_InventoryResponse":
      return EBaseUserMessages.UM_InventoryResponse;
    case 162:
    case "UM_RequestDiagnostic":
      return EBaseUserMessages.UM_RequestDiagnostic;
    case 163:
    case "UM_DiagnosticResponse":
      return EBaseUserMessages.UM_DiagnosticResponse;
    case 164:
    case "UM_ExtraUserData":
      return EBaseUserMessages.UM_ExtraUserData;
    case 165:
    case "UM_NotifyResponseFound":
      return EBaseUserMessages.UM_NotifyResponseFound;
    case 166:
    case "UM_PlayResponseConditional":
      return EBaseUserMessages.UM_PlayResponseConditional;
    case 200:
    case "UM_MAX_BASE":
      return EBaseUserMessages.UM_MAX_BASE;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum EBaseUserMessages");
  }
}

export function eBaseUserMessagesToJSON(object: EBaseUserMessages): string {
  switch (object) {
    case EBaseUserMessages.UM_AchievementEvent:
      return "UM_AchievementEvent";
    case EBaseUserMessages.UM_CloseCaption:
      return "UM_CloseCaption";
    case EBaseUserMessages.UM_CloseCaptionDirect:
      return "UM_CloseCaptionDirect";
    case EBaseUserMessages.UM_CurrentTimescale:
      return "UM_CurrentTimescale";
    case EBaseUserMessages.UM_DesiredTimescale:
      return "UM_DesiredTimescale";
    case EBaseUserMessages.UM_Fade:
      return "UM_Fade";
    case EBaseUserMessages.UM_GameTitle:
      return "UM_GameTitle";
    case EBaseUserMessages.UM_HudMsg:
      return "UM_HudMsg";
    case EBaseUserMessages.UM_HudText:
      return "UM_HudText";
    case EBaseUserMessages.UM_ColoredText:
      return "UM_ColoredText";
    case EBaseUserMessages.UM_RequestState:
      return "UM_RequestState";
    case EBaseUserMessages.UM_ResetHUD:
      return "UM_ResetHUD";
    case EBaseUserMessages.UM_Rumble:
      return "UM_Rumble";
    case EBaseUserMessages.UM_SayText:
      return "UM_SayText";
    case EBaseUserMessages.UM_SayText2:
      return "UM_SayText2";
    case EBaseUserMessages.UM_SayTextChannel:
      return "UM_SayTextChannel";
    case EBaseUserMessages.UM_Shake:
      return "UM_Shake";
    case EBaseUserMessages.UM_ShakeDir:
      return "UM_ShakeDir";
    case EBaseUserMessages.UM_WaterShake:
      return "UM_WaterShake";
    case EBaseUserMessages.UM_TextMsg:
      return "UM_TextMsg";
    case EBaseUserMessages.UM_ScreenTilt:
      return "UM_ScreenTilt";
    case EBaseUserMessages.UM_VoiceMask:
      return "UM_VoiceMask";
    case EBaseUserMessages.UM_SendAudio:
      return "UM_SendAudio";
    case EBaseUserMessages.UM_ItemPickup:
      return "UM_ItemPickup";
    case EBaseUserMessages.UM_AmmoDenied:
      return "UM_AmmoDenied";
    case EBaseUserMessages.UM_ShowMenu:
      return "UM_ShowMenu";
    case EBaseUserMessages.UM_CreditsMsg:
      return "UM_CreditsMsg";
    case EBaseUserMessages.UM_CloseCaptionPlaceholder:
      return "UM_CloseCaptionPlaceholder";
    case EBaseUserMessages.UM_CameraTransition:
      return "UM_CameraTransition";
    case EBaseUserMessages.UM_AudioParameter:
      return "UM_AudioParameter";
    case EBaseUserMessages.UM_ParticleManager:
      return "UM_ParticleManager";
    case EBaseUserMessages.UM_HudError:
      return "UM_HudError";
    case EBaseUserMessages.UM_CustomGameEvent:
      return "UM_CustomGameEvent";
    case EBaseUserMessages.UM_AnimGraphUpdate:
      return "UM_AnimGraphUpdate";
    case EBaseUserMessages.UM_HapticsManagerPulse:
      return "UM_HapticsManagerPulse";
    case EBaseUserMessages.UM_HapticsManagerEffect:
      return "UM_HapticsManagerEffect";
    case EBaseUserMessages.UM_CommandQueueState:
      return "UM_CommandQueueState";
    case EBaseUserMessages.UM_UpdateCssClasses:
      return "UM_UpdateCssClasses";
    case EBaseUserMessages.UM_ServerFrameTime:
      return "UM_ServerFrameTime";
    case EBaseUserMessages.UM_LagCompensationError:
      return "UM_LagCompensationError";
    case EBaseUserMessages.UM_RequestDllStatus:
      return "UM_RequestDllStatus";
    case EBaseUserMessages.UM_RequestUtilAction:
      return "UM_RequestUtilAction";
    case EBaseUserMessages.UM_UtilActionResponse:
      return "UM_UtilActionResponse";
    case EBaseUserMessages.UM_DllStatusResponse:
      return "UM_DllStatusResponse";
    case EBaseUserMessages.UM_RequestInventory:
      return "UM_RequestInventory";
    case EBaseUserMessages.UM_InventoryResponse:
      return "UM_InventoryResponse";
    case EBaseUserMessages.UM_RequestDiagnostic:
      return "UM_RequestDiagnostic";
    case EBaseUserMessages.UM_DiagnosticResponse:
      return "UM_DiagnosticResponse";
    case EBaseUserMessages.UM_ExtraUserData:
      return "UM_ExtraUserData";
    case EBaseUserMessages.UM_NotifyResponseFound:
      return "UM_NotifyResponseFound";
    case EBaseUserMessages.UM_PlayResponseConditional:
      return "UM_PlayResponseConditional";
    case EBaseUserMessages.UM_MAX_BASE:
      return "UM_MAX_BASE";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum EBaseUserMessages");
  }
}

export enum EBaseEntityMessages {
  EM_PlayJingle = 136,
  EM_ScreenOverlay = 137,
  EM_RemoveAllDecals = 138,
  EM_PropagateForce = 139,
  EM_DoSpark = 140,
  EM_FixAngle = 141,
}

export function eBaseEntityMessagesFromJSON(object: any): EBaseEntityMessages {
  switch (object) {
    case 136:
    case "EM_PlayJingle":
      return EBaseEntityMessages.EM_PlayJingle;
    case 137:
    case "EM_ScreenOverlay":
      return EBaseEntityMessages.EM_ScreenOverlay;
    case 138:
    case "EM_RemoveAllDecals":
      return EBaseEntityMessages.EM_RemoveAllDecals;
    case 139:
    case "EM_PropagateForce":
      return EBaseEntityMessages.EM_PropagateForce;
    case 140:
    case "EM_DoSpark":
      return EBaseEntityMessages.EM_DoSpark;
    case 141:
    case "EM_FixAngle":
      return EBaseEntityMessages.EM_FixAngle;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum EBaseEntityMessages");
  }
}

export function eBaseEntityMessagesToJSON(object: EBaseEntityMessages): string {
  switch (object) {
    case EBaseEntityMessages.EM_PlayJingle:
      return "EM_PlayJingle";
    case EBaseEntityMessages.EM_ScreenOverlay:
      return "EM_ScreenOverlay";
    case EBaseEntityMessages.EM_RemoveAllDecals:
      return "EM_RemoveAllDecals";
    case EBaseEntityMessages.EM_PropagateForce:
      return "EM_PropagateForce";
    case EBaseEntityMessages.EM_DoSpark:
      return "EM_DoSpark";
    case EBaseEntityMessages.EM_FixAngle:
      return "EM_FixAngle";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum EBaseEntityMessages");
  }
}

export enum eRollType {
  ROLL_NONE = -1,
  ROLL_STATS = 0,
  ROLL_CREDITS = 1,
  ROLL_LATE_JOIN_LOGO = 2,
  ROLL_OUTTRO = 3,
}

export function eRollTypeFromJSON(object: any): eRollType {
  switch (object) {
    case -1:
    case "ROLL_NONE":
      return eRollType.ROLL_NONE;
    case 0:
    case "ROLL_STATS":
      return eRollType.ROLL_STATS;
    case 1:
    case "ROLL_CREDITS":
      return eRollType.ROLL_CREDITS;
    case 2:
    case "ROLL_LATE_JOIN_LOGO":
      return eRollType.ROLL_LATE_JOIN_LOGO;
    case 3:
    case "ROLL_OUTTRO":
      return eRollType.ROLL_OUTTRO;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum eRollType");
  }
}

export function eRollTypeToJSON(object: eRollType): string {
  switch (object) {
    case eRollType.ROLL_NONE:
      return "ROLL_NONE";
    case eRollType.ROLL_STATS:
      return "ROLL_STATS";
    case eRollType.ROLL_CREDITS:
      return "ROLL_CREDITS";
    case eRollType.ROLL_LATE_JOIN_LOGO:
      return "ROLL_LATE_JOIN_LOGO";
    case eRollType.ROLL_OUTTRO:
      return "ROLL_OUTTRO";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum eRollType");
  }
}

export enum particleMessage {
  GAME_PARTICLE_MANAGER_EVENT_CREATE = 0,
  GAME_PARTICLE_MANAGER_EVENT_UPDATE = 1,
  GAME_PARTICLE_MANAGER_EVENT_UPDATE_FORWARD = 2,
  GAME_PARTICLE_MANAGER_EVENT_UPDATE_ORIENTATION = 3,
  GAME_PARTICLE_MANAGER_EVENT_UPDATE_FALLBACK = 4,
  GAME_PARTICLE_MANAGER_EVENT_UPDATE_ENT = 5,
  GAME_PARTICLE_MANAGER_EVENT_UPDATE_OFFSET = 6,
  GAME_PARTICLE_MANAGER_EVENT_DESTROY = 7,
  GAME_PARTICLE_MANAGER_EVENT_DESTROY_INVOLVING = 8,
  GAME_PARTICLE_MANAGER_EVENT_RELEASE = 9,
  GAME_PARTICLE_MANAGER_EVENT_LATENCY = 10,
  GAME_PARTICLE_MANAGER_EVENT_SHOULD_DRAW = 11,
  GAME_PARTICLE_MANAGER_EVENT_FROZEN = 12,
  GAME_PARTICLE_MANAGER_EVENT_CHANGE_CONTROL_POINT_ATTACHMENT = 13,
  GAME_PARTICLE_MANAGER_EVENT_UPDATE_ENTITY_POSITION = 14,
  GAME_PARTICLE_MANAGER_EVENT_SET_FOW_PROPERTIES = 15,
  GAME_PARTICLE_MANAGER_EVENT_SET_TEXT = 16,
  GAME_PARTICLE_MANAGER_EVENT_SET_SHOULD_CHECK_FOW = 17,
  GAME_PARTICLE_MANAGER_EVENT_SET_CONTROL_POINT_MODEL = 18,
  GAME_PARTICLE_MANAGER_EVENT_SET_CONTROL_POINT_SNAPSHOT = 19,
  GAME_PARTICLE_MANAGER_EVENT_SET_TEXTURE_ATTRIBUTE = 20,
  GAME_PARTICLE_MANAGER_EVENT_SET_SCENE_OBJECT_GENERIC_FLAG = 21,
  GAME_PARTICLE_MANAGER_EVENT_SET_SCENE_OBJECT_TINT_AND_DESAT = 22,
  GAME_PARTICLE_MANAGER_EVENT_DESTROY_NAMED = 23,
  GAME_PARTICLE_MANAGER_EVENT_SKIP_TO_TIME = 24,
  GAME_PARTICLE_MANAGER_EVENT_CAN_FREEZE = 25,
  GAME_PARTICLE_MANAGER_EVENT_SET_NAMED_VALUE_CONTEXT = 26,
  GAME_PARTICLE_MANAGER_EVENT_UPDATE_TRANSFORM = 27,
  GAME_PARTICLE_MANAGER_EVENT_FREEZE_TRANSITION_OVERRIDE = 28,
  GAME_PARTICLE_MANAGER_EVENT_FREEZE_INVOLVING = 29,
  GAME_PARTICLE_MANAGER_EVENT_ADD_MODELLIST_OVERRIDE_ELEMENT = 30,
  GAME_PARTICLE_MANAGER_EVENT_CLEAR_MODELLIST_OVERRIDE = 31,
  GAME_PARTICLE_MANAGER_EVENT_CREATE_PHYSICS_SIM = 32,
  GAME_PARTICLE_MANAGER_EVENT_DESTROY_PHYSICS_SIM = 33,
}

export function particleMessageFromJSON(object: any): particleMessage {
  switch (object) {
    case 0:
    case "GAME_PARTICLE_MANAGER_EVENT_CREATE":
      return particleMessage.GAME_PARTICLE_MANAGER_EVENT_CREATE;
    case 1:
    case "GAME_PARTICLE_MANAGER_EVENT_UPDATE":
      return particleMessage.GAME_PARTICLE_MANAGER_EVENT_UPDATE;
    case 2:
    case "GAME_PARTICLE_MANAGER_EVENT_UPDATE_FORWARD":
      return particleMessage.GAME_PARTICLE_MANAGER_EVENT_UPDATE_FORWARD;
    case 3:
    case "GAME_PARTICLE_MANAGER_EVENT_UPDATE_ORIENTATION":
      return particleMessage.GAME_PARTICLE_MANAGER_EVENT_UPDATE_ORIENTATION;
    case 4:
    case "GAME_PARTICLE_MANAGER_EVENT_UPDATE_FALLBACK":
      return particleMessage.GAME_PARTICLE_MANAGER_EVENT_UPDATE_FALLBACK;
    case 5:
    case "GAME_PARTICLE_MANAGER_EVENT_UPDATE_ENT":
      return particleMessage.GAME_PARTICLE_MANAGER_EVENT_UPDATE_ENT;
    case 6:
    case "GAME_PARTICLE_MANAGER_EVENT_UPDATE_OFFSET":
      return particleMessage.GAME_PARTICLE_MANAGER_EVENT_UPDATE_OFFSET;
    case 7:
    case "GAME_PARTICLE_MANAGER_EVENT_DESTROY":
      return particleMessage.GAME_PARTICLE_MANAGER_EVENT_DESTROY;
    case 8:
    case "GAME_PARTICLE_MANAGER_EVENT_DESTROY_INVOLVING":
      return particleMessage.GAME_PARTICLE_MANAGER_EVENT_DESTROY_INVOLVING;
    case 9:
    case "GAME_PARTICLE_MANAGER_EVENT_RELEASE":
      return particleMessage.GAME_PARTICLE_MANAGER_EVENT_RELEASE;
    case 10:
    case "GAME_PARTICLE_MANAGER_EVENT_LATENCY":
      return particleMessage.GAME_PARTICLE_MANAGER_EVENT_LATENCY;
    case 11:
    case "GAME_PARTICLE_MANAGER_EVENT_SHOULD_DRAW":
      return particleMessage.GAME_PARTICLE_MANAGER_EVENT_SHOULD_DRAW;
    case 12:
    case "GAME_PARTICLE_MANAGER_EVENT_FROZEN":
      return particleMessage.GAME_PARTICLE_MANAGER_EVENT_FROZEN;
    case 13:
    case "GAME_PARTICLE_MANAGER_EVENT_CHANGE_CONTROL_POINT_ATTACHMENT":
      return particleMessage.GAME_PARTICLE_MANAGER_EVENT_CHANGE_CONTROL_POINT_ATTACHMENT;
    case 14:
    case "GAME_PARTICLE_MANAGER_EVENT_UPDATE_ENTITY_POSITION":
      return particleMessage.GAME_PARTICLE_MANAGER_EVENT_UPDATE_ENTITY_POSITION;
    case 15:
    case "GAME_PARTICLE_MANAGER_EVENT_SET_FOW_PROPERTIES":
      return particleMessage.GAME_PARTICLE_MANAGER_EVENT_SET_FOW_PROPERTIES;
    case 16:
    case "GAME_PARTICLE_MANAGER_EVENT_SET_TEXT":
      return particleMessage.GAME_PARTICLE_MANAGER_EVENT_SET_TEXT;
    case 17:
    case "GAME_PARTICLE_MANAGER_EVENT_SET_SHOULD_CHECK_FOW":
      return particleMessage.GAME_PARTICLE_MANAGER_EVENT_SET_SHOULD_CHECK_FOW;
    case 18:
    case "GAME_PARTICLE_MANAGER_EVENT_SET_CONTROL_POINT_MODEL":
      return particleMessage.GAME_PARTICLE_MANAGER_EVENT_SET_CONTROL_POINT_MODEL;
    case 19:
    case "GAME_PARTICLE_MANAGER_EVENT_SET_CONTROL_POINT_SNAPSHOT":
      return particleMessage.GAME_PARTICLE_MANAGER_EVENT_SET_CONTROL_POINT_SNAPSHOT;
    case 20:
    case "GAME_PARTICLE_MANAGER_EVENT_SET_TEXTURE_ATTRIBUTE":
      return particleMessage.GAME_PARTICLE_MANAGER_EVENT_SET_TEXTURE_ATTRIBUTE;
    case 21:
    case "GAME_PARTICLE_MANAGER_EVENT_SET_SCENE_OBJECT_GENERIC_FLAG":
      return particleMessage.GAME_PARTICLE_MANAGER_EVENT_SET_SCENE_OBJECT_GENERIC_FLAG;
    case 22:
    case "GAME_PARTICLE_MANAGER_EVENT_SET_SCENE_OBJECT_TINT_AND_DESAT":
      return particleMessage.GAME_PARTICLE_MANAGER_EVENT_SET_SCENE_OBJECT_TINT_AND_DESAT;
    case 23:
    case "GAME_PARTICLE_MANAGER_EVENT_DESTROY_NAMED":
      return particleMessage.GAME_PARTICLE_MANAGER_EVENT_DESTROY_NAMED;
    case 24:
    case "GAME_PARTICLE_MANAGER_EVENT_SKIP_TO_TIME":
      return particleMessage.GAME_PARTICLE_MANAGER_EVENT_SKIP_TO_TIME;
    case 25:
    case "GAME_PARTICLE_MANAGER_EVENT_CAN_FREEZE":
      return particleMessage.GAME_PARTICLE_MANAGER_EVENT_CAN_FREEZE;
    case 26:
    case "GAME_PARTICLE_MANAGER_EVENT_SET_NAMED_VALUE_CONTEXT":
      return particleMessage.GAME_PARTICLE_MANAGER_EVENT_SET_NAMED_VALUE_CONTEXT;
    case 27:
    case "GAME_PARTICLE_MANAGER_EVENT_UPDATE_TRANSFORM":
      return particleMessage.GAME_PARTICLE_MANAGER_EVENT_UPDATE_TRANSFORM;
    case 28:
    case "GAME_PARTICLE_MANAGER_EVENT_FREEZE_TRANSITION_OVERRIDE":
      return particleMessage.GAME_PARTICLE_MANAGER_EVENT_FREEZE_TRANSITION_OVERRIDE;
    case 29:
    case "GAME_PARTICLE_MANAGER_EVENT_FREEZE_INVOLVING":
      return particleMessage.GAME_PARTICLE_MANAGER_EVENT_FREEZE_INVOLVING;
    case 30:
    case "GAME_PARTICLE_MANAGER_EVENT_ADD_MODELLIST_OVERRIDE_ELEMENT":
      return particleMessage.GAME_PARTICLE_MANAGER_EVENT_ADD_MODELLIST_OVERRIDE_ELEMENT;
    case 31:
    case "GAME_PARTICLE_MANAGER_EVENT_CLEAR_MODELLIST_OVERRIDE":
      return particleMessage.GAME_PARTICLE_MANAGER_EVENT_CLEAR_MODELLIST_OVERRIDE;
    case 32:
    case "GAME_PARTICLE_MANAGER_EVENT_CREATE_PHYSICS_SIM":
      return particleMessage.GAME_PARTICLE_MANAGER_EVENT_CREATE_PHYSICS_SIM;
    case 33:
    case "GAME_PARTICLE_MANAGER_EVENT_DESTROY_PHYSICS_SIM":
      return particleMessage.GAME_PARTICLE_MANAGER_EVENT_DESTROY_PHYSICS_SIM;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum particleMessage");
  }
}

export function particleMessageToJSON(object: particleMessage): string {
  switch (object) {
    case particleMessage.GAME_PARTICLE_MANAGER_EVENT_CREATE:
      return "GAME_PARTICLE_MANAGER_EVENT_CREATE";
    case particleMessage.GAME_PARTICLE_MANAGER_EVENT_UPDATE:
      return "GAME_PARTICLE_MANAGER_EVENT_UPDATE";
    case particleMessage.GAME_PARTICLE_MANAGER_EVENT_UPDATE_FORWARD:
      return "GAME_PARTICLE_MANAGER_EVENT_UPDATE_FORWARD";
    case particleMessage.GAME_PARTICLE_MANAGER_EVENT_UPDATE_ORIENTATION:
      return "GAME_PARTICLE_MANAGER_EVENT_UPDATE_ORIENTATION";
    case particleMessage.GAME_PARTICLE_MANAGER_EVENT_UPDATE_FALLBACK:
      return "GAME_PARTICLE_MANAGER_EVENT_UPDATE_FALLBACK";
    case particleMessage.GAME_PARTICLE_MANAGER_EVENT_UPDATE_ENT:
      return "GAME_PARTICLE_MANAGER_EVENT_UPDATE_ENT";
    case particleMessage.GAME_PARTICLE_MANAGER_EVENT_UPDATE_OFFSET:
      return "GAME_PARTICLE_MANAGER_EVENT_UPDATE_OFFSET";
    case particleMessage.GAME_PARTICLE_MANAGER_EVENT_DESTROY:
      return "GAME_PARTICLE_MANAGER_EVENT_DESTROY";
    case particleMessage.GAME_PARTICLE_MANAGER_EVENT_DESTROY_INVOLVING:
      return "GAME_PARTICLE_MANAGER_EVENT_DESTROY_INVOLVING";
    case particleMessage.GAME_PARTICLE_MANAGER_EVENT_RELEASE:
      return "GAME_PARTICLE_MANAGER_EVENT_RELEASE";
    case particleMessage.GAME_PARTICLE_MANAGER_EVENT_LATENCY:
      return "GAME_PARTICLE_MANAGER_EVENT_LATENCY";
    case particleMessage.GAME_PARTICLE_MANAGER_EVENT_SHOULD_DRAW:
      return "GAME_PARTICLE_MANAGER_EVENT_SHOULD_DRAW";
    case particleMessage.GAME_PARTICLE_MANAGER_EVENT_FROZEN:
      return "GAME_PARTICLE_MANAGER_EVENT_FROZEN";
    case particleMessage.GAME_PARTICLE_MANAGER_EVENT_CHANGE_CONTROL_POINT_ATTACHMENT:
      return "GAME_PARTICLE_MANAGER_EVENT_CHANGE_CONTROL_POINT_ATTACHMENT";
    case particleMessage.GAME_PARTICLE_MANAGER_EVENT_UPDATE_ENTITY_POSITION:
      return "GAME_PARTICLE_MANAGER_EVENT_UPDATE_ENTITY_POSITION";
    case particleMessage.GAME_PARTICLE_MANAGER_EVENT_SET_FOW_PROPERTIES:
      return "GAME_PARTICLE_MANAGER_EVENT_SET_FOW_PROPERTIES";
    case particleMessage.GAME_PARTICLE_MANAGER_EVENT_SET_TEXT:
      return "GAME_PARTICLE_MANAGER_EVENT_SET_TEXT";
    case particleMessage.GAME_PARTICLE_MANAGER_EVENT_SET_SHOULD_CHECK_FOW:
      return "GAME_PARTICLE_MANAGER_EVENT_SET_SHOULD_CHECK_FOW";
    case particleMessage.GAME_PARTICLE_MANAGER_EVENT_SET_CONTROL_POINT_MODEL:
      return "GAME_PARTICLE_MANAGER_EVENT_SET_CONTROL_POINT_MODEL";
    case particleMessage.GAME_PARTICLE_MANAGER_EVENT_SET_CONTROL_POINT_SNAPSHOT:
      return "GAME_PARTICLE_MANAGER_EVENT_SET_CONTROL_POINT_SNAPSHOT";
    case particleMessage.GAME_PARTICLE_MANAGER_EVENT_SET_TEXTURE_ATTRIBUTE:
      return "GAME_PARTICLE_MANAGER_EVENT_SET_TEXTURE_ATTRIBUTE";
    case particleMessage.GAME_PARTICLE_MANAGER_EVENT_SET_SCENE_OBJECT_GENERIC_FLAG:
      return "GAME_PARTICLE_MANAGER_EVENT_SET_SCENE_OBJECT_GENERIC_FLAG";
    case particleMessage.GAME_PARTICLE_MANAGER_EVENT_SET_SCENE_OBJECT_TINT_AND_DESAT:
      return "GAME_PARTICLE_MANAGER_EVENT_SET_SCENE_OBJECT_TINT_AND_DESAT";
    case particleMessage.GAME_PARTICLE_MANAGER_EVENT_DESTROY_NAMED:
      return "GAME_PARTICLE_MANAGER_EVENT_DESTROY_NAMED";
    case particleMessage.GAME_PARTICLE_MANAGER_EVENT_SKIP_TO_TIME:
      return "GAME_PARTICLE_MANAGER_EVENT_SKIP_TO_TIME";
    case particleMessage.GAME_PARTICLE_MANAGER_EVENT_CAN_FREEZE:
      return "GAME_PARTICLE_MANAGER_EVENT_CAN_FREEZE";
    case particleMessage.GAME_PARTICLE_MANAGER_EVENT_SET_NAMED_VALUE_CONTEXT:
      return "GAME_PARTICLE_MANAGER_EVENT_SET_NAMED_VALUE_CONTEXT";
    case particleMessage.GAME_PARTICLE_MANAGER_EVENT_UPDATE_TRANSFORM:
      return "GAME_PARTICLE_MANAGER_EVENT_UPDATE_TRANSFORM";
    case particleMessage.GAME_PARTICLE_MANAGER_EVENT_FREEZE_TRANSITION_OVERRIDE:
      return "GAME_PARTICLE_MANAGER_EVENT_FREEZE_TRANSITION_OVERRIDE";
    case particleMessage.GAME_PARTICLE_MANAGER_EVENT_FREEZE_INVOLVING:
      return "GAME_PARTICLE_MANAGER_EVENT_FREEZE_INVOLVING";
    case particleMessage.GAME_PARTICLE_MANAGER_EVENT_ADD_MODELLIST_OVERRIDE_ELEMENT:
      return "GAME_PARTICLE_MANAGER_EVENT_ADD_MODELLIST_OVERRIDE_ELEMENT";
    case particleMessage.GAME_PARTICLE_MANAGER_EVENT_CLEAR_MODELLIST_OVERRIDE:
      return "GAME_PARTICLE_MANAGER_EVENT_CLEAR_MODELLIST_OVERRIDE";
    case particleMessage.GAME_PARTICLE_MANAGER_EVENT_CREATE_PHYSICS_SIM:
      return "GAME_PARTICLE_MANAGER_EVENT_CREATE_PHYSICS_SIM";
    case particleMessage.GAME_PARTICLE_MANAGER_EVENT_DESTROY_PHYSICS_SIM:
      return "GAME_PARTICLE_MANAGER_EVENT_DESTROY_PHYSICS_SIM";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum particleMessage");
  }
}

export enum EHapticPulseType {
  VR_HAND_HAPTIC_PULSE_LIGHT = 0,
  VR_HAND_HAPTIC_PULSE_MEDIUM = 1,
  VR_HAND_HAPTIC_PULSE_STRONG = 2,
}

export function eHapticPulseTypeFromJSON(object: any): EHapticPulseType {
  switch (object) {
    case 0:
    case "VR_HAND_HAPTIC_PULSE_LIGHT":
      return EHapticPulseType.VR_HAND_HAPTIC_PULSE_LIGHT;
    case 1:
    case "VR_HAND_HAPTIC_PULSE_MEDIUM":
      return EHapticPulseType.VR_HAND_HAPTIC_PULSE_MEDIUM;
    case 2:
    case "VR_HAND_HAPTIC_PULSE_STRONG":
      return EHapticPulseType.VR_HAND_HAPTIC_PULSE_STRONG;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum EHapticPulseType");
  }
}

export function eHapticPulseTypeToJSON(object: EHapticPulseType): string {
  switch (object) {
    case EHapticPulseType.VR_HAND_HAPTIC_PULSE_LIGHT:
      return "VR_HAND_HAPTIC_PULSE_LIGHT";
    case EHapticPulseType.VR_HAND_HAPTIC_PULSE_MEDIUM:
      return "VR_HAND_HAPTIC_PULSE_MEDIUM";
    case EHapticPulseType.VR_HAND_HAPTIC_PULSE_STRONG:
      return "VR_HAND_HAPTIC_PULSE_STRONG";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum EHapticPulseType");
  }
}

export interface CUserMessageAchievementEvent {
  achievement?: number | undefined;
}

export interface CUserMessageCloseCaption {
  hash?: number | undefined;
  duration?: number | undefined;
  fromPlayer?: boolean | undefined;
  entIndex?: number | undefined;
}

export interface CUserMessageCloseCaptionDirect {
  hash?: number | undefined;
  duration?: number | undefined;
  fromPlayer?: boolean | undefined;
  entIndex?: number | undefined;
}

export interface CUserMessageCloseCaptionPlaceholder {
  string?: string | undefined;
  duration?: number | undefined;
  fromPlayer?: boolean | undefined;
  entIndex?: number | undefined;
}

export interface CUserMessageCurrentTimescale {
  current?: number | undefined;
}

export interface CUserMessageDesiredTimescale {
  desired?: number | undefined;
  acceleration?: number | undefined;
  minblendrate?: number | undefined;
  blenddeltamultiplier?: number | undefined;
}

export interface CUserMessageFade {
  duration?: number | undefined;
  holdTime?: number | undefined;
  flags?: number | undefined;
  color?: number | undefined;
}

export interface CUserMessageShake {
  command?: number | undefined;
  amplitude?: number | undefined;
  frequency?: number | undefined;
  duration?: number | undefined;
}

export interface CUserMessageShakeDir {
  shake?: CUserMessageShake | undefined;
  direction?: CMsgVector | undefined;
}

export interface CUserMessageWaterShake {
  command?: number | undefined;
  amplitude?: number | undefined;
  frequency?: number | undefined;
  duration?: number | undefined;
}

export interface CUserMessageScreenTilt {
  command?: number | undefined;
  easeInOut?: boolean | undefined;
  angle?: CMsgVector | undefined;
  duration?: number | undefined;
  time?: number | undefined;
}

export interface CUserMessageSayText {
  playerindex?: number | undefined;
  text?: string | undefined;
  chat?: boolean | undefined;
}

export interface CUserMessageSayText2 {
  entityindex?: number | undefined;
  chat?: boolean | undefined;
  messagename?: string | undefined;
  param1?: string | undefined;
  param2?: string | undefined;
  param3?: string | undefined;
  param4?: string | undefined;
}

export interface CUserMessageHudMsg {
  channel?: number | undefined;
  x?: number | undefined;
  y?: number | undefined;
  color1?: number | undefined;
  color2?: number | undefined;
  effect?: number | undefined;
  message?: string | undefined;
}

export interface CUserMessageHudText {
  message?: string | undefined;
}

export interface CUserMessageTextMsg {
  dest?: number | undefined;
  param: string[];
}

export interface CUserMessageGameTitle {}

export interface CUserMessageResetHUD {}

export interface CUserMessageSendAudio {
  soundname?: string | undefined;
  stop?: boolean | undefined;
}

export interface CUserMessageAudioParameter {
  parameterType?: number | undefined;
  nameHashCode?: number | undefined;
  value?: number | undefined;
  intValue?: number | undefined;
}

export interface CUserMessageVoiceMask {
  gamerulesMasks: number[];
  banMasks: number[];
  modEnable?: boolean | undefined;
}

export interface CUserMessageRequestState {}

export interface CUserMessageRumble {
  index?: number | undefined;
  data?: number | undefined;
  flags?: number | undefined;
}

export interface CUserMessageSayTextChannel {
  player?: number | undefined;
  channel?: number | undefined;
  text?: string | undefined;
}

export interface CUserMessageColoredText {
  color?: number | undefined;
  text?: string | undefined;
  reset?: boolean | undefined;
  contextPlayerSlot?: number | undefined;
  contextValue?: number | undefined;
  contextTeamId?: number | undefined;
}

export interface CUserMessageItemPickup {
  itemname?: string | undefined;
}

export interface CUserMessageAmmoDenied {
  ammoId?: number | undefined;
}

export interface CUserMessageShowMenu {
  validslots?: number | undefined;
  displaytime?: number | undefined;
  needmore?: boolean | undefined;
  menustring?: string | undefined;
}

export interface CUserMessageCreditsMsg {
  rolltype?: eRollType | undefined;
  logoLength?: number | undefined;
}

export interface CEntityMessagePlayJingle {
  entityMsg?: CEntityMsg | undefined;
}

export interface CEntityMessageScreenOverlay {
  startEffect?: boolean | undefined;
  entityMsg?: CEntityMsg | undefined;
}

export interface CEntityMessageRemoveAllDecals {
  removeDecals?: boolean | undefined;
  entityMsg?: CEntityMsg | undefined;
}

export interface CEntityMessagePropagateForce {
  impulse?: CMsgVector | undefined;
  entityMsg?: CEntityMsg | undefined;
}

export interface CEntityMessageDoSpark {
  origin?: CMsgVector | undefined;
  entityindex?: number | undefined;
  radius?: number | undefined;
  color?: number | undefined;
  beams?: number | undefined;
  thick?: number | undefined;
  duration?: number | undefined;
  entityMsg?: CEntityMsg | undefined;
}

export interface CEntityMessageFixAngle {
  relative?: boolean | undefined;
  angle?: CMsgQAngle | undefined;
  entityMsg?: CEntityMsg | undefined;
}

export interface CUserMessageCameraTransition {
  cameraType?: number | undefined;
  duration?: number | undefined;
  paramsDataDriven?: CUserMessageCameraTransition_TransitionDataDriven | undefined;
}

export interface CUserMessageCameraTransition_TransitionDataDriven {
  filename?: string | undefined;
  attachEntIndex?: number | undefined;
  duration?: number | undefined;
}

export interface CUserMsgParticleManager {
  type: particleMessage;
  index: number;
  releaseParticleIndex?: CUserMsgParticleManager_ReleaseParticleIndex | undefined;
  createParticle?: CUserMsgParticleManager_CreateParticle | undefined;
  destroyParticle?: CUserMsgParticleManager_DestroyParticle | undefined;
  destroyParticleInvolving?: CUserMsgParticleManager_DestroyParticleInvolving | undefined;
  updateParticle?: CUserMsgParticleManager_UpdateParticleOBSOLETE | undefined;
  updateParticleFwd?: CUserMsgParticleManager_UpdateParticleFwdOBSOLETE | undefined;
  updateParticleOrient?: CUserMsgParticleManager_UpdateParticleOrientOBSOLETE | undefined;
  updateParticleFallback?: CUserMsgParticleManager_UpdateParticleFallback | undefined;
  updateParticleOffset?: CUserMsgParticleManager_UpdateParticleOffset | undefined;
  updateParticleEnt?: CUserMsgParticleManager_UpdateParticleEnt | undefined;
  updateParticleShouldDraw?: CUserMsgParticleManager_UpdateParticleShouldDraw | undefined;
  updateParticleSetFrozen?: CUserMsgParticleManager_UpdateParticleSetFrozen | undefined;
  changeControlPointAttachment?: CUserMsgParticleManager_ChangeControlPointAttachment | undefined;
  updateEntityPosition?: CUserMsgParticleManager_UpdateEntityPosition | undefined;
  setParticleFowProperties?: CUserMsgParticleManager_SetParticleFoWProperties | undefined;
  setParticleText?: CUserMsgParticleManager_SetParticleText | undefined;
  setParticleShouldCheckFow?: CUserMsgParticleManager_SetParticleShouldCheckFoW | undefined;
  setControlPointModel?: CUserMsgParticleManager_SetControlPointModel | undefined;
  setControlPointSnapshot?: CUserMsgParticleManager_SetControlPointSnapshot | undefined;
  setTextureAttribute?: CUserMsgParticleManager_SetTextureAttribute | undefined;
  setSceneObjectGenericFlag?: CUserMsgParticleManager_SetSceneObjectGenericFlag | undefined;
  setSceneObjectTintAndDesat?: CUserMsgParticleManager_SetSceneObjectTintAndDesat | undefined;
  destroyParticleNamed?: CUserMsgParticleManager_DestroyParticleNamed | undefined;
  particleSkipToTime?: CUserMsgParticleManager_ParticleSkipToTime | undefined;
  particleCanFreeze?: CUserMsgParticleManager_ParticleCanFreeze | undefined;
  setNamedValueContext?: CUserMsgParticleManager_SetParticleNamedValueContext | undefined;
  updateParticleTransform?: CUserMsgParticleManager_UpdateParticleTransform | undefined;
  particleFreezeTransitionOverride?: CUserMsgParticleManager_ParticleFreezeTransitionOverride | undefined;
  freezeParticleInvolving?: CUserMsgParticleManager_FreezeParticleInvolving | undefined;
  addModellistOverrideElement?: CUserMsgParticleManager_AddModellistOverrideElement | undefined;
  clearModellistOverride?: CUserMsgParticleManager_ClearModellistOverride | undefined;
  createPhysicsSim?: CUserMsgParticleManager_CreatePhysicsSim | undefined;
  destroyPhysicsSim?: CUserMsgParticleManager_DestroyPhysicsSim | undefined;
}

export interface CUserMsgParticleManager_ReleaseParticleIndex {}

export interface CUserMsgParticleManager_CreateParticle {
  particleNameIndex?: string | undefined;
  attachType?: number | undefined;
  entityHandle?: number | undefined;
  entityHandleForModifiers?: number | undefined;
  applyVoiceBanRules?: boolean | undefined;
  teamBehavior?: number | undefined;
  controlPointConfiguration?: string | undefined;
  cluster?: boolean | undefined;
  endcapTime?: number | undefined;
}

export interface CUserMsgParticleManager_DestroyParticle {
  destroyImmediately?: boolean | undefined;
}

export interface CUserMsgParticleManager_DestroyParticleInvolving {
  destroyImmediately?: boolean | undefined;
  entityHandle?: number | undefined;
}

export interface CUserMsgParticleManager_DestroyParticleNamed {
  particleNameIndex?: string | undefined;
  entityHandle?: number | undefined;
  destroyImmediately?: boolean | undefined;
  playEndcap?: boolean | undefined;
}

export interface CUserMsgParticleManager_UpdateParticleOBSOLETE {
  controlPoint?: number | undefined;
  position?: CMsgVector | undefined;
}

export interface CUserMsgParticleManager_UpdateParticleFwdOBSOLETE {
  controlPoint?: number | undefined;
  forward?: CMsgVector | undefined;
}

export interface CUserMsgParticleManager_UpdateParticleOrientOBSOLETE {
  controlPoint?: number | undefined;
  forward?: CMsgVector | undefined;
  deprecatedRight?: CMsgVector | undefined;
  up?: CMsgVector | undefined;
  left?: CMsgVector | undefined;
}

export interface CUserMsgParticleManager_UpdateParticleTransform {
  controlPoint?: number | undefined;
  position?: CMsgVector | undefined;
  orientation?: CMsgQuaternion | undefined;
  interpolationInterval?: number | undefined;
}

export interface CUserMsgParticleManager_UpdateParticleFallback {
  controlPoint?: number | undefined;
  position?: CMsgVector | undefined;
}

export interface CUserMsgParticleManager_UpdateParticleOffset {
  controlPoint?: number | undefined;
  originOffset?: CMsgVector | undefined;
  angleOffset?: CMsgQAngle | undefined;
}

export interface CUserMsgParticleManager_UpdateParticleEnt {
  controlPoint?: number | undefined;
  entityHandle?: number | undefined;
  attachType?: number | undefined;
  attachment?: number | undefined;
  fallbackPosition?: CMsgVector | undefined;
  includeWearables?: boolean | undefined;
  offsetPosition?: CMsgVector | undefined;
  offsetAngles?: CMsgQAngle | undefined;
}

export interface CUserMsgParticleManager_UpdateParticleSetFrozen {
  setFrozen?: boolean | undefined;
  transitionDuration?: number | undefined;
}

export interface CUserMsgParticleManager_UpdateParticleShouldDraw {
  shouldDraw?: boolean | undefined;
}

export interface CUserMsgParticleManager_ChangeControlPointAttachment {
  attachmentOld?: number | undefined;
  attachmentNew?: number | undefined;
  entityHandle?: number | undefined;
}

export interface CUserMsgParticleManager_UpdateEntityPosition {
  entityHandle?: number | undefined;
  position?: CMsgVector | undefined;
}

export interface CUserMsgParticleManager_SetParticleFoWProperties {
  fowControlPoint?: number | undefined;
  fowControlPoint2?: number | undefined;
  fowRadius?: number | undefined;
}

export interface CUserMsgParticleManager_SetParticleShouldCheckFoW {
  checkFow?: boolean | undefined;
}

export interface CUserMsgParticleManager_SetControlPointModel {
  controlPoint?: number | undefined;
  modelName?: string | undefined;
}

export interface CUserMsgParticleManager_SetControlPointSnapshot {
  controlPoint?: number | undefined;
  snapshotName?: string | undefined;
}

export interface CUserMsgParticleManager_SetParticleText {
  text?: string | undefined;
}

export interface CUserMsgParticleManager_SetTextureAttribute {
  attributeName?: string | undefined;
  textureName?: string | undefined;
}

export interface CUserMsgParticleManager_SetSceneObjectGenericFlag {
  flagValue?: boolean | undefined;
}

export interface CUserMsgParticleManager_SetSceneObjectTintAndDesat {
  tint?: number | undefined;
  desat?: number | undefined;
}

export interface CUserMsgParticleManager_ParticleSkipToTime {
  skipToTime?: number | undefined;
}

export interface CUserMsgParticleManager_ParticleCanFreeze {
  canFreeze?: boolean | undefined;
}

export interface CUserMsgParticleManager_ParticleFreezeTransitionOverride {
  freezeTransitionOverride?: number | undefined;
}

export interface CUserMsgParticleManager_FreezeParticleInvolving {
  setFrozen?: boolean | undefined;
  transitionDuration?: number | undefined;
  entityHandle?: number | undefined;
}

export interface CUserMsgParticleManager_AddModellistOverrideElement {
  modelName?: string | undefined;
  spawnProbability?: number | undefined;
  groupid?: number | undefined;
}

export interface CUserMsgParticleManager_ClearModellistOverride {
  groupid?: number | undefined;
}

export interface CUserMsgParticleManager_SetParticleNamedValueContext {
  floatValues: CUserMsgParticleManager_SetParticleNamedValueContext_FloatContextValue[];
  vectorValues: CUserMsgParticleManager_SetParticleNamedValueContext_VectorContextValue[];
  transformValues: CUserMsgParticleManager_SetParticleNamedValueContext_TransformContextValue[];
  ehandleValues: CUserMsgParticleManager_SetParticleNamedValueContext_EHandleContext[];
}

export interface CUserMsgParticleManager_SetParticleNamedValueContext_FloatContextValue {
  valueNameHash?: number | undefined;
  value?: number | undefined;
}

export interface CUserMsgParticleManager_SetParticleNamedValueContext_VectorContextValue {
  valueNameHash?: number | undefined;
  value?: CMsgVector | undefined;
}

export interface CUserMsgParticleManager_SetParticleNamedValueContext_TransformContextValue {
  valueNameHash?: number | undefined;
  angles?: CMsgQAngle | undefined;
  translation?: CMsgVector | undefined;
}

export interface CUserMsgParticleManager_SetParticleNamedValueContext_EHandleContext {
  valueNameHash?: number | undefined;
  entIndex?: number | undefined;
}

export interface CUserMsgParticleManager_CreatePhysicsSim {
  propGroupName?: string | undefined;
}

export interface CUserMsgParticleManager_DestroyPhysicsSim {}

export interface CUserMsgHudError {
  orderId?: number | undefined;
}

export interface CUserMsgCustomGameEvent {
  eventName?: string | undefined;
  data?: Buffer | undefined;
}

export interface CUserMessageHapticsManagerPulse {
  handId?: number | undefined;
  effectAmplitude?: number | undefined;
  effectFrequency?: number | undefined;
  effectDuration?: number | undefined;
}

export interface CUserMessageHapticsManagerEffect {
  handId?: number | undefined;
  effectNameHashCode?: number | undefined;
  effectScale?: number | undefined;
}

export interface CUserMessageAnimStateGraphState {
  entityIndex?: number | undefined;
  data?: Buffer | undefined;
}

export interface CUserMessageUpdateCssClasses {
  targetWorldPanel?: number | undefined;
  cssClasses?: string | undefined;
  isAdd?: boolean | undefined;
}

export interface CUserMessageServerFrameTime {
  frameTime?: number | undefined;
}

export interface CUserMessageLagCompensationError {
  distance?: number | undefined;
}

export interface CUserMessageRequestDllStatus {
  dllAction?: string | undefined;
  fullReport?: boolean | undefined;
}

export interface CUserMessageRequestUtilAction {
  util1?: number | undefined;
  util2?: number | undefined;
  util3?: number | undefined;
  util4?: number | undefined;
  util5?: number | undefined;
}

export interface CUserMessageUtilMsgResponse {
  crc?: number | undefined;
  itemCount?: number | undefined;
  crc2?: number | undefined;
  itemCount2?: number | undefined;
  crcPart: number[];
  crcPart2: number[];
  clientTimestamp?: number | undefined;
  platform?: number | undefined;
  itemdetails: CUserMessageUtilMsgResponse_ItemDetail[];
  itemgroup?: number | undefined;
  totalCount?: number | undefined;
  totalCount2?: number | undefined;
}

export interface CUserMessageUtilMsgResponse_ItemDetail {
  index?: number | undefined;
  hash?: number | undefined;
  crc?: number | undefined;
  name?: string | undefined;
}

export interface CUserMessageDllStatus {
  fileReport?: string | undefined;
  commandLine?: string | undefined;
  totalFiles?: number | undefined;
  processId?: number | undefined;
  osversion?: number | undefined;
  clientTime?: string | undefined;
  diagnostics: CUserMessageDllStatus_CVDiagnostic[];
  modules: CUserMessageDllStatus_CModule[];
}

export interface CUserMessageDllStatus_CVDiagnostic {
  id?: number | undefined;
  extended?: number | undefined;
  value?: string | undefined;
  stringValue?: string | undefined;
}

export interface CUserMessageDllStatus_CModule {
  baseAddr?: string | undefined;
  name?: string | undefined;
  size?: number | undefined;
  timestamp?: number | undefined;
}

export interface CUserMessageRequestInventory {
  inventory?: number | undefined;
  offset?: number | undefined;
  options?: number | undefined;
}

export interface CUserMessageInventoryResponse {
  crc?: number | undefined;
  itemCount?: number | undefined;
  osversion?: number | undefined;
  perfTime?: number | undefined;
  clientTimestamp?: number | undefined;
  platform?: number | undefined;
  inventories: CUserMessageInventoryResponse_InventoryDetail[];
  inventories2: CUserMessageInventoryResponse_InventoryDetail[];
  inventories3: CUserMessageInventoryResponse_InventoryDetail[];
  invType?: number | undefined;
  buildVersion?: number | undefined;
  instance?: number | undefined;
  startTime?: string | undefined;
}

export interface CUserMessageInventoryResponse_InventoryDetail {
  index?: number | undefined;
  primary?: string | undefined;
  offset?: string | undefined;
  first?: string | undefined;
  base?: string | undefined;
  name?: string | undefined;
  baseName?: string | undefined;
  baseDetail?: number | undefined;
  baseTime?: number | undefined;
  baseHash?: number | undefined;
}

export interface CUserMessageRequestDiagnostic {
  diagnostics: CUserMessageRequestDiagnostic_Diagnostic[];
}

export interface CUserMessageRequestDiagnostic_Diagnostic {
  index?: number | undefined;
  offset?: string | undefined;
  param?: number | undefined;
  length?: number | undefined;
  type?: number | undefined;
  base?: string | undefined;
  range?: string | undefined;
  extent?: string | undefined;
  detail?: string | undefined;
  name?: string | undefined;
  alias?: string | undefined;
  vardetail?: Buffer | undefined;
  context?: number | undefined;
}

export interface CUserMessageDiagnosticResponse {
  diagnostics: CUserMessageDiagnosticResponse_Diagnostic[];
  buildVersion?: number | undefined;
  instance?: number | undefined;
  startTime?: string | undefined;
  osversion?: number | undefined;
  platform?: number | undefined;
}

export interface CUserMessageDiagnosticResponse_Diagnostic {
  index?: number | undefined;
  offset?: string | undefined;
  param?: number | undefined;
  length?: number | undefined;
  detail?: Buffer | undefined;
  base?: string | undefined;
  range?: string | undefined;
  type?: number | undefined;
  name?: string | undefined;
  alias?: string | undefined;
  backup?: Buffer | undefined;
  context?: number | undefined;
  control?: string | undefined;
  augment?: string | undefined;
  placebo?: string | undefined;
}

export interface CUserMessageExtraUserData {
  item?: number | undefined;
  value1?: string | undefined;
  value2?: string | undefined;
  detail1: Buffer[];
  detail2: Buffer[];
}

export interface CUserMessageNotifyResponseFound {
  entIndex?: number | undefined;
  ruleName?: string | undefined;
  responseValue?: string | undefined;
  responseConcept?: string | undefined;
  criteria: CUserMessageNotifyResponseFound_Criteria[];
}

export interface CUserMessageNotifyResponseFound_Criteria {
  nameSymbol?: number | undefined;
  value?: string | undefined;
}

export interface CUserMessagePlayResponseConditional {
  entIndex?: number | undefined;
  playerSlots: number[];
  response?: string | undefined;
  entOrigin?: CMsgVector | undefined;
}

function createBaseCUserMessageAchievementEvent(): CUserMessageAchievementEvent {
  return { achievement: 0 };
}

export const CUserMessageAchievementEvent = {
  encode(message: CUserMessageAchievementEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.achievement !== undefined && message.achievement !== 0) {
      writer.uint32(8).uint32(message.achievement);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CUserMessageAchievementEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCUserMessageAchievementEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.achievement = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CUserMessageAchievementEvent {
    return { achievement: isSet(object.achievement) ? globalThis.Number(object.achievement) : 0 };
  },

  toJSON(message: CUserMessageAchievementEvent): unknown {
    const obj: any = {};
    if (message.achievement !== undefined && message.achievement !== 0) {
      obj.achievement = Math.round(message.achievement);
    }
    return obj;
  },

  create(base?: DeepPartial<CUserMessageAchievementEvent>): CUserMessageAchievementEvent {
    return CUserMessageAchievementEvent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CUserMessageAchievementEvent>): CUserMessageAchievementEvent {
    const message = createBaseCUserMessageAchievementEvent();
    message.achievement = object.achievement ?? 0;
    return message;
  },
};

function createBaseCUserMessageCloseCaption(): CUserMessageCloseCaption {
  return { hash: 0, duration: 0, fromPlayer: false, entIndex: -1 };
}

export const CUserMessageCloseCaption = {
  encode(message: CUserMessageCloseCaption, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.hash !== undefined && message.hash !== 0) {
      writer.uint32(13).fixed32(message.hash);
    }
    if (message.duration !== undefined && message.duration !== 0) {
      writer.uint32(21).float(message.duration);
    }
    if (message.fromPlayer !== undefined && message.fromPlayer !== false) {
      writer.uint32(24).bool(message.fromPlayer);
    }
    if (message.entIndex !== undefined && message.entIndex !== -1) {
      writer.uint32(32).int32(message.entIndex);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CUserMessageCloseCaption {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCUserMessageCloseCaption();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.hash = reader.fixed32();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.duration = reader.float();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.fromPlayer = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.entIndex = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CUserMessageCloseCaption {
    return {
      hash: isSet(object.hash) ? globalThis.Number(object.hash) : 0,
      duration: isSet(object.duration) ? globalThis.Number(object.duration) : 0,
      fromPlayer: isSet(object.fromPlayer) ? globalThis.Boolean(object.fromPlayer) : false,
      entIndex: isSet(object.entIndex) ? globalThis.Number(object.entIndex) : -1,
    };
  },

  toJSON(message: CUserMessageCloseCaption): unknown {
    const obj: any = {};
    if (message.hash !== undefined && message.hash !== 0) {
      obj.hash = Math.round(message.hash);
    }
    if (message.duration !== undefined && message.duration !== 0) {
      obj.duration = message.duration;
    }
    if (message.fromPlayer !== undefined && message.fromPlayer !== false) {
      obj.fromPlayer = message.fromPlayer;
    }
    if (message.entIndex !== undefined && message.entIndex !== -1) {
      obj.entIndex = Math.round(message.entIndex);
    }
    return obj;
  },

  create(base?: DeepPartial<CUserMessageCloseCaption>): CUserMessageCloseCaption {
    return CUserMessageCloseCaption.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CUserMessageCloseCaption>): CUserMessageCloseCaption {
    const message = createBaseCUserMessageCloseCaption();
    message.hash = object.hash ?? 0;
    message.duration = object.duration ?? 0;
    message.fromPlayer = object.fromPlayer ?? false;
    message.entIndex = object.entIndex ?? -1;
    return message;
  },
};

function createBaseCUserMessageCloseCaptionDirect(): CUserMessageCloseCaptionDirect {
  return { hash: 0, duration: 0, fromPlayer: false, entIndex: -1 };
}

export const CUserMessageCloseCaptionDirect = {
  encode(message: CUserMessageCloseCaptionDirect, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.hash !== undefined && message.hash !== 0) {
      writer.uint32(13).fixed32(message.hash);
    }
    if (message.duration !== undefined && message.duration !== 0) {
      writer.uint32(21).float(message.duration);
    }
    if (message.fromPlayer !== undefined && message.fromPlayer !== false) {
      writer.uint32(24).bool(message.fromPlayer);
    }
    if (message.entIndex !== undefined && message.entIndex !== -1) {
      writer.uint32(32).int32(message.entIndex);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CUserMessageCloseCaptionDirect {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCUserMessageCloseCaptionDirect();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.hash = reader.fixed32();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.duration = reader.float();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.fromPlayer = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.entIndex = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CUserMessageCloseCaptionDirect {
    return {
      hash: isSet(object.hash) ? globalThis.Number(object.hash) : 0,
      duration: isSet(object.duration) ? globalThis.Number(object.duration) : 0,
      fromPlayer: isSet(object.fromPlayer) ? globalThis.Boolean(object.fromPlayer) : false,
      entIndex: isSet(object.entIndex) ? globalThis.Number(object.entIndex) : -1,
    };
  },

  toJSON(message: CUserMessageCloseCaptionDirect): unknown {
    const obj: any = {};
    if (message.hash !== undefined && message.hash !== 0) {
      obj.hash = Math.round(message.hash);
    }
    if (message.duration !== undefined && message.duration !== 0) {
      obj.duration = message.duration;
    }
    if (message.fromPlayer !== undefined && message.fromPlayer !== false) {
      obj.fromPlayer = message.fromPlayer;
    }
    if (message.entIndex !== undefined && message.entIndex !== -1) {
      obj.entIndex = Math.round(message.entIndex);
    }
    return obj;
  },

  create(base?: DeepPartial<CUserMessageCloseCaptionDirect>): CUserMessageCloseCaptionDirect {
    return CUserMessageCloseCaptionDirect.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CUserMessageCloseCaptionDirect>): CUserMessageCloseCaptionDirect {
    const message = createBaseCUserMessageCloseCaptionDirect();
    message.hash = object.hash ?? 0;
    message.duration = object.duration ?? 0;
    message.fromPlayer = object.fromPlayer ?? false;
    message.entIndex = object.entIndex ?? -1;
    return message;
  },
};

function createBaseCUserMessageCloseCaptionPlaceholder(): CUserMessageCloseCaptionPlaceholder {
  return { string: "", duration: 0, fromPlayer: false, entIndex: -1 };
}

export const CUserMessageCloseCaptionPlaceholder = {
  encode(message: CUserMessageCloseCaptionPlaceholder, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.string !== undefined && message.string !== "") {
      writer.uint32(10).string(message.string);
    }
    if (message.duration !== undefined && message.duration !== 0) {
      writer.uint32(21).float(message.duration);
    }
    if (message.fromPlayer !== undefined && message.fromPlayer !== false) {
      writer.uint32(24).bool(message.fromPlayer);
    }
    if (message.entIndex !== undefined && message.entIndex !== -1) {
      writer.uint32(32).int32(message.entIndex);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CUserMessageCloseCaptionPlaceholder {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCUserMessageCloseCaptionPlaceholder();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.string = reader.string();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.duration = reader.float();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.fromPlayer = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.entIndex = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CUserMessageCloseCaptionPlaceholder {
    return {
      string: isSet(object.string) ? globalThis.String(object.string) : "",
      duration: isSet(object.duration) ? globalThis.Number(object.duration) : 0,
      fromPlayer: isSet(object.fromPlayer) ? globalThis.Boolean(object.fromPlayer) : false,
      entIndex: isSet(object.entIndex) ? globalThis.Number(object.entIndex) : -1,
    };
  },

  toJSON(message: CUserMessageCloseCaptionPlaceholder): unknown {
    const obj: any = {};
    if (message.string !== undefined && message.string !== "") {
      obj.string = message.string;
    }
    if (message.duration !== undefined && message.duration !== 0) {
      obj.duration = message.duration;
    }
    if (message.fromPlayer !== undefined && message.fromPlayer !== false) {
      obj.fromPlayer = message.fromPlayer;
    }
    if (message.entIndex !== undefined && message.entIndex !== -1) {
      obj.entIndex = Math.round(message.entIndex);
    }
    return obj;
  },

  create(base?: DeepPartial<CUserMessageCloseCaptionPlaceholder>): CUserMessageCloseCaptionPlaceholder {
    return CUserMessageCloseCaptionPlaceholder.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CUserMessageCloseCaptionPlaceholder>): CUserMessageCloseCaptionPlaceholder {
    const message = createBaseCUserMessageCloseCaptionPlaceholder();
    message.string = object.string ?? "";
    message.duration = object.duration ?? 0;
    message.fromPlayer = object.fromPlayer ?? false;
    message.entIndex = object.entIndex ?? -1;
    return message;
  },
};

function createBaseCUserMessageCurrentTimescale(): CUserMessageCurrentTimescale {
  return { current: 0 };
}

export const CUserMessageCurrentTimescale = {
  encode(message: CUserMessageCurrentTimescale, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.current !== undefined && message.current !== 0) {
      writer.uint32(13).float(message.current);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CUserMessageCurrentTimescale {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCUserMessageCurrentTimescale();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.current = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CUserMessageCurrentTimescale {
    return { current: isSet(object.current) ? globalThis.Number(object.current) : 0 };
  },

  toJSON(message: CUserMessageCurrentTimescale): unknown {
    const obj: any = {};
    if (message.current !== undefined && message.current !== 0) {
      obj.current = message.current;
    }
    return obj;
  },

  create(base?: DeepPartial<CUserMessageCurrentTimescale>): CUserMessageCurrentTimescale {
    return CUserMessageCurrentTimescale.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CUserMessageCurrentTimescale>): CUserMessageCurrentTimescale {
    const message = createBaseCUserMessageCurrentTimescale();
    message.current = object.current ?? 0;
    return message;
  },
};

function createBaseCUserMessageDesiredTimescale(): CUserMessageDesiredTimescale {
  return { desired: 0, acceleration: 0, minblendrate: 0, blenddeltamultiplier: 0 };
}

export const CUserMessageDesiredTimescale = {
  encode(message: CUserMessageDesiredTimescale, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.desired !== undefined && message.desired !== 0) {
      writer.uint32(13).float(message.desired);
    }
    if (message.acceleration !== undefined && message.acceleration !== 0) {
      writer.uint32(21).float(message.acceleration);
    }
    if (message.minblendrate !== undefined && message.minblendrate !== 0) {
      writer.uint32(29).float(message.minblendrate);
    }
    if (message.blenddeltamultiplier !== undefined && message.blenddeltamultiplier !== 0) {
      writer.uint32(37).float(message.blenddeltamultiplier);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CUserMessageDesiredTimescale {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCUserMessageDesiredTimescale();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.desired = reader.float();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.acceleration = reader.float();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.minblendrate = reader.float();
          continue;
        case 4:
          if (tag !== 37) {
            break;
          }

          message.blenddeltamultiplier = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CUserMessageDesiredTimescale {
    return {
      desired: isSet(object.desired) ? globalThis.Number(object.desired) : 0,
      acceleration: isSet(object.acceleration) ? globalThis.Number(object.acceleration) : 0,
      minblendrate: isSet(object.minblendrate) ? globalThis.Number(object.minblendrate) : 0,
      blenddeltamultiplier: isSet(object.blenddeltamultiplier) ? globalThis.Number(object.blenddeltamultiplier) : 0,
    };
  },

  toJSON(message: CUserMessageDesiredTimescale): unknown {
    const obj: any = {};
    if (message.desired !== undefined && message.desired !== 0) {
      obj.desired = message.desired;
    }
    if (message.acceleration !== undefined && message.acceleration !== 0) {
      obj.acceleration = message.acceleration;
    }
    if (message.minblendrate !== undefined && message.minblendrate !== 0) {
      obj.minblendrate = message.minblendrate;
    }
    if (message.blenddeltamultiplier !== undefined && message.blenddeltamultiplier !== 0) {
      obj.blenddeltamultiplier = message.blenddeltamultiplier;
    }
    return obj;
  },

  create(base?: DeepPartial<CUserMessageDesiredTimescale>): CUserMessageDesiredTimescale {
    return CUserMessageDesiredTimescale.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CUserMessageDesiredTimescale>): CUserMessageDesiredTimescale {
    const message = createBaseCUserMessageDesiredTimescale();
    message.desired = object.desired ?? 0;
    message.acceleration = object.acceleration ?? 0;
    message.minblendrate = object.minblendrate ?? 0;
    message.blenddeltamultiplier = object.blenddeltamultiplier ?? 0;
    return message;
  },
};

function createBaseCUserMessageFade(): CUserMessageFade {
  return { duration: 0, holdTime: 0, flags: 0, color: 0 };
}

export const CUserMessageFade = {
  encode(message: CUserMessageFade, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.duration !== undefined && message.duration !== 0) {
      writer.uint32(8).uint32(message.duration);
    }
    if (message.holdTime !== undefined && message.holdTime !== 0) {
      writer.uint32(16).uint32(message.holdTime);
    }
    if (message.flags !== undefined && message.flags !== 0) {
      writer.uint32(24).uint32(message.flags);
    }
    if (message.color !== undefined && message.color !== 0) {
      writer.uint32(37).fixed32(message.color);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CUserMessageFade {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCUserMessageFade();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.duration = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.holdTime = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.flags = reader.uint32();
          continue;
        case 4:
          if (tag !== 37) {
            break;
          }

          message.color = reader.fixed32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CUserMessageFade {
    return {
      duration: isSet(object.duration) ? globalThis.Number(object.duration) : 0,
      holdTime: isSet(object.holdTime) ? globalThis.Number(object.holdTime) : 0,
      flags: isSet(object.flags) ? globalThis.Number(object.flags) : 0,
      color: isSet(object.color) ? globalThis.Number(object.color) : 0,
    };
  },

  toJSON(message: CUserMessageFade): unknown {
    const obj: any = {};
    if (message.duration !== undefined && message.duration !== 0) {
      obj.duration = Math.round(message.duration);
    }
    if (message.holdTime !== undefined && message.holdTime !== 0) {
      obj.holdTime = Math.round(message.holdTime);
    }
    if (message.flags !== undefined && message.flags !== 0) {
      obj.flags = Math.round(message.flags);
    }
    if (message.color !== undefined && message.color !== 0) {
      obj.color = Math.round(message.color);
    }
    return obj;
  },

  create(base?: DeepPartial<CUserMessageFade>): CUserMessageFade {
    return CUserMessageFade.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CUserMessageFade>): CUserMessageFade {
    const message = createBaseCUserMessageFade();
    message.duration = object.duration ?? 0;
    message.holdTime = object.holdTime ?? 0;
    message.flags = object.flags ?? 0;
    message.color = object.color ?? 0;
    return message;
  },
};

function createBaseCUserMessageShake(): CUserMessageShake {
  return { command: 0, amplitude: 0, frequency: 0, duration: 0 };
}

export const CUserMessageShake = {
  encode(message: CUserMessageShake, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.command !== undefined && message.command !== 0) {
      writer.uint32(8).uint32(message.command);
    }
    if (message.amplitude !== undefined && message.amplitude !== 0) {
      writer.uint32(21).float(message.amplitude);
    }
    if (message.frequency !== undefined && message.frequency !== 0) {
      writer.uint32(29).float(message.frequency);
    }
    if (message.duration !== undefined && message.duration !== 0) {
      writer.uint32(37).float(message.duration);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CUserMessageShake {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCUserMessageShake();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.command = reader.uint32();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.amplitude = reader.float();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.frequency = reader.float();
          continue;
        case 4:
          if (tag !== 37) {
            break;
          }

          message.duration = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CUserMessageShake {
    return {
      command: isSet(object.command) ? globalThis.Number(object.command) : 0,
      amplitude: isSet(object.amplitude) ? globalThis.Number(object.amplitude) : 0,
      frequency: isSet(object.frequency) ? globalThis.Number(object.frequency) : 0,
      duration: isSet(object.duration) ? globalThis.Number(object.duration) : 0,
    };
  },

  toJSON(message: CUserMessageShake): unknown {
    const obj: any = {};
    if (message.command !== undefined && message.command !== 0) {
      obj.command = Math.round(message.command);
    }
    if (message.amplitude !== undefined && message.amplitude !== 0) {
      obj.amplitude = message.amplitude;
    }
    if (message.frequency !== undefined && message.frequency !== 0) {
      obj.frequency = message.frequency;
    }
    if (message.duration !== undefined && message.duration !== 0) {
      obj.duration = message.duration;
    }
    return obj;
  },

  create(base?: DeepPartial<CUserMessageShake>): CUserMessageShake {
    return CUserMessageShake.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CUserMessageShake>): CUserMessageShake {
    const message = createBaseCUserMessageShake();
    message.command = object.command ?? 0;
    message.amplitude = object.amplitude ?? 0;
    message.frequency = object.frequency ?? 0;
    message.duration = object.duration ?? 0;
    return message;
  },
};

function createBaseCUserMessageShakeDir(): CUserMessageShakeDir {
  return { shake: undefined, direction: undefined };
}

export const CUserMessageShakeDir = {
  encode(message: CUserMessageShakeDir, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.shake !== undefined) {
      CUserMessageShake.encode(message.shake, writer.uint32(10).fork()).ldelim();
    }
    if (message.direction !== undefined) {
      CMsgVector.encode(message.direction, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CUserMessageShakeDir {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCUserMessageShakeDir();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.shake = CUserMessageShake.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.direction = CMsgVector.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CUserMessageShakeDir {
    return {
      shake: isSet(object.shake) ? CUserMessageShake.fromJSON(object.shake) : undefined,
      direction: isSet(object.direction) ? CMsgVector.fromJSON(object.direction) : undefined,
    };
  },

  toJSON(message: CUserMessageShakeDir): unknown {
    const obj: any = {};
    if (message.shake !== undefined) {
      obj.shake = CUserMessageShake.toJSON(message.shake);
    }
    if (message.direction !== undefined) {
      obj.direction = CMsgVector.toJSON(message.direction);
    }
    return obj;
  },

  create(base?: DeepPartial<CUserMessageShakeDir>): CUserMessageShakeDir {
    return CUserMessageShakeDir.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CUserMessageShakeDir>): CUserMessageShakeDir {
    const message = createBaseCUserMessageShakeDir();
    message.shake =
      object.shake !== undefined && object.shake !== null ? CUserMessageShake.fromPartial(object.shake) : undefined;
    message.direction =
      object.direction !== undefined && object.direction !== null
        ? CMsgVector.fromPartial(object.direction)
        : undefined;
    return message;
  },
};

function createBaseCUserMessageWaterShake(): CUserMessageWaterShake {
  return { command: 0, amplitude: 0, frequency: 0, duration: 0 };
}

export const CUserMessageWaterShake = {
  encode(message: CUserMessageWaterShake, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.command !== undefined && message.command !== 0) {
      writer.uint32(8).uint32(message.command);
    }
    if (message.amplitude !== undefined && message.amplitude !== 0) {
      writer.uint32(21).float(message.amplitude);
    }
    if (message.frequency !== undefined && message.frequency !== 0) {
      writer.uint32(29).float(message.frequency);
    }
    if (message.duration !== undefined && message.duration !== 0) {
      writer.uint32(37).float(message.duration);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CUserMessageWaterShake {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCUserMessageWaterShake();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.command = reader.uint32();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.amplitude = reader.float();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.frequency = reader.float();
          continue;
        case 4:
          if (tag !== 37) {
            break;
          }

          message.duration = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CUserMessageWaterShake {
    return {
      command: isSet(object.command) ? globalThis.Number(object.command) : 0,
      amplitude: isSet(object.amplitude) ? globalThis.Number(object.amplitude) : 0,
      frequency: isSet(object.frequency) ? globalThis.Number(object.frequency) : 0,
      duration: isSet(object.duration) ? globalThis.Number(object.duration) : 0,
    };
  },

  toJSON(message: CUserMessageWaterShake): unknown {
    const obj: any = {};
    if (message.command !== undefined && message.command !== 0) {
      obj.command = Math.round(message.command);
    }
    if (message.amplitude !== undefined && message.amplitude !== 0) {
      obj.amplitude = message.amplitude;
    }
    if (message.frequency !== undefined && message.frequency !== 0) {
      obj.frequency = message.frequency;
    }
    if (message.duration !== undefined && message.duration !== 0) {
      obj.duration = message.duration;
    }
    return obj;
  },

  create(base?: DeepPartial<CUserMessageWaterShake>): CUserMessageWaterShake {
    return CUserMessageWaterShake.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CUserMessageWaterShake>): CUserMessageWaterShake {
    const message = createBaseCUserMessageWaterShake();
    message.command = object.command ?? 0;
    message.amplitude = object.amplitude ?? 0;
    message.frequency = object.frequency ?? 0;
    message.duration = object.duration ?? 0;
    return message;
  },
};

function createBaseCUserMessageScreenTilt(): CUserMessageScreenTilt {
  return { command: 0, easeInOut: false, angle: undefined, duration: 0, time: 0 };
}

export const CUserMessageScreenTilt = {
  encode(message: CUserMessageScreenTilt, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.command !== undefined && message.command !== 0) {
      writer.uint32(8).uint32(message.command);
    }
    if (message.easeInOut !== undefined && message.easeInOut !== false) {
      writer.uint32(16).bool(message.easeInOut);
    }
    if (message.angle !== undefined) {
      CMsgVector.encode(message.angle, writer.uint32(26).fork()).ldelim();
    }
    if (message.duration !== undefined && message.duration !== 0) {
      writer.uint32(37).float(message.duration);
    }
    if (message.time !== undefined && message.time !== 0) {
      writer.uint32(45).float(message.time);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CUserMessageScreenTilt {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCUserMessageScreenTilt();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.command = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.easeInOut = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.angle = CMsgVector.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 37) {
            break;
          }

          message.duration = reader.float();
          continue;
        case 5:
          if (tag !== 45) {
            break;
          }

          message.time = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CUserMessageScreenTilt {
    return {
      command: isSet(object.command) ? globalThis.Number(object.command) : 0,
      easeInOut: isSet(object.easeInOut) ? globalThis.Boolean(object.easeInOut) : false,
      angle: isSet(object.angle) ? CMsgVector.fromJSON(object.angle) : undefined,
      duration: isSet(object.duration) ? globalThis.Number(object.duration) : 0,
      time: isSet(object.time) ? globalThis.Number(object.time) : 0,
    };
  },

  toJSON(message: CUserMessageScreenTilt): unknown {
    const obj: any = {};
    if (message.command !== undefined && message.command !== 0) {
      obj.command = Math.round(message.command);
    }
    if (message.easeInOut !== undefined && message.easeInOut !== false) {
      obj.easeInOut = message.easeInOut;
    }
    if (message.angle !== undefined) {
      obj.angle = CMsgVector.toJSON(message.angle);
    }
    if (message.duration !== undefined && message.duration !== 0) {
      obj.duration = message.duration;
    }
    if (message.time !== undefined && message.time !== 0) {
      obj.time = message.time;
    }
    return obj;
  },

  create(base?: DeepPartial<CUserMessageScreenTilt>): CUserMessageScreenTilt {
    return CUserMessageScreenTilt.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CUserMessageScreenTilt>): CUserMessageScreenTilt {
    const message = createBaseCUserMessageScreenTilt();
    message.command = object.command ?? 0;
    message.easeInOut = object.easeInOut ?? false;
    message.angle =
      object.angle !== undefined && object.angle !== null ? CMsgVector.fromPartial(object.angle) : undefined;
    message.duration = object.duration ?? 0;
    message.time = object.time ?? 0;
    return message;
  },
};

function createBaseCUserMessageSayText(): CUserMessageSayText {
  return { playerindex: -1, text: "", chat: false };
}

export const CUserMessageSayText = {
  encode(message: CUserMessageSayText, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.playerindex !== undefined && message.playerindex !== -1) {
      writer.uint32(8).int32(message.playerindex);
    }
    if (message.text !== undefined && message.text !== "") {
      writer.uint32(18).string(message.text);
    }
    if (message.chat !== undefined && message.chat !== false) {
      writer.uint32(24).bool(message.chat);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CUserMessageSayText {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCUserMessageSayText();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.playerindex = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.text = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.chat = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CUserMessageSayText {
    return {
      playerindex: isSet(object.playerindex) ? globalThis.Number(object.playerindex) : -1,
      text: isSet(object.text) ? globalThis.String(object.text) : "",
      chat: isSet(object.chat) ? globalThis.Boolean(object.chat) : false,
    };
  },

  toJSON(message: CUserMessageSayText): unknown {
    const obj: any = {};
    if (message.playerindex !== undefined && message.playerindex !== -1) {
      obj.playerindex = Math.round(message.playerindex);
    }
    if (message.text !== undefined && message.text !== "") {
      obj.text = message.text;
    }
    if (message.chat !== undefined && message.chat !== false) {
      obj.chat = message.chat;
    }
    return obj;
  },

  create(base?: DeepPartial<CUserMessageSayText>): CUserMessageSayText {
    return CUserMessageSayText.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CUserMessageSayText>): CUserMessageSayText {
    const message = createBaseCUserMessageSayText();
    message.playerindex = object.playerindex ?? -1;
    message.text = object.text ?? "";
    message.chat = object.chat ?? false;
    return message;
  },
};

function createBaseCUserMessageSayText2(): CUserMessageSayText2 {
  return { entityindex: -1, chat: false, messagename: "", param1: "", param2: "", param3: "", param4: "" };
}

export const CUserMessageSayText2 = {
  encode(message: CUserMessageSayText2, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.entityindex !== undefined && message.entityindex !== -1) {
      writer.uint32(8).int32(message.entityindex);
    }
    if (message.chat !== undefined && message.chat !== false) {
      writer.uint32(16).bool(message.chat);
    }
    if (message.messagename !== undefined && message.messagename !== "") {
      writer.uint32(26).string(message.messagename);
    }
    if (message.param1 !== undefined && message.param1 !== "") {
      writer.uint32(34).string(message.param1);
    }
    if (message.param2 !== undefined && message.param2 !== "") {
      writer.uint32(42).string(message.param2);
    }
    if (message.param3 !== undefined && message.param3 !== "") {
      writer.uint32(50).string(message.param3);
    }
    if (message.param4 !== undefined && message.param4 !== "") {
      writer.uint32(58).string(message.param4);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CUserMessageSayText2 {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCUserMessageSayText2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.entityindex = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.chat = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.messagename = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.param1 = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.param2 = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.param3 = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.param4 = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CUserMessageSayText2 {
    return {
      entityindex: isSet(object.entityindex) ? globalThis.Number(object.entityindex) : -1,
      chat: isSet(object.chat) ? globalThis.Boolean(object.chat) : false,
      messagename: isSet(object.messagename) ? globalThis.String(object.messagename) : "",
      param1: isSet(object.param1) ? globalThis.String(object.param1) : "",
      param2: isSet(object.param2) ? globalThis.String(object.param2) : "",
      param3: isSet(object.param3) ? globalThis.String(object.param3) : "",
      param4: isSet(object.param4) ? globalThis.String(object.param4) : "",
    };
  },

  toJSON(message: CUserMessageSayText2): unknown {
    const obj: any = {};
    if (message.entityindex !== undefined && message.entityindex !== -1) {
      obj.entityindex = Math.round(message.entityindex);
    }
    if (message.chat !== undefined && message.chat !== false) {
      obj.chat = message.chat;
    }
    if (message.messagename !== undefined && message.messagename !== "") {
      obj.messagename = message.messagename;
    }
    if (message.param1 !== undefined && message.param1 !== "") {
      obj.param1 = message.param1;
    }
    if (message.param2 !== undefined && message.param2 !== "") {
      obj.param2 = message.param2;
    }
    if (message.param3 !== undefined && message.param3 !== "") {
      obj.param3 = message.param3;
    }
    if (message.param4 !== undefined && message.param4 !== "") {
      obj.param4 = message.param4;
    }
    return obj;
  },

  create(base?: DeepPartial<CUserMessageSayText2>): CUserMessageSayText2 {
    return CUserMessageSayText2.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CUserMessageSayText2>): CUserMessageSayText2 {
    const message = createBaseCUserMessageSayText2();
    message.entityindex = object.entityindex ?? -1;
    message.chat = object.chat ?? false;
    message.messagename = object.messagename ?? "";
    message.param1 = object.param1 ?? "";
    message.param2 = object.param2 ?? "";
    message.param3 = object.param3 ?? "";
    message.param4 = object.param4 ?? "";
    return message;
  },
};

function createBaseCUserMessageHudMsg(): CUserMessageHudMsg {
  return { channel: 0, x: 0, y: 0, color1: 0, color2: 0, effect: 0, message: "" };
}

export const CUserMessageHudMsg = {
  encode(message: CUserMessageHudMsg, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.channel !== undefined && message.channel !== 0) {
      writer.uint32(8).uint32(message.channel);
    }
    if (message.x !== undefined && message.x !== 0) {
      writer.uint32(21).float(message.x);
    }
    if (message.y !== undefined && message.y !== 0) {
      writer.uint32(29).float(message.y);
    }
    if (message.color1 !== undefined && message.color1 !== 0) {
      writer.uint32(37).fixed32(message.color1);
    }
    if (message.color2 !== undefined && message.color2 !== 0) {
      writer.uint32(45).fixed32(message.color2);
    }
    if (message.effect !== undefined && message.effect !== 0) {
      writer.uint32(48).uint32(message.effect);
    }
    if (message.message !== undefined && message.message !== "") {
      writer.uint32(90).string(message.message);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CUserMessageHudMsg {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCUserMessageHudMsg();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.channel = reader.uint32();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.x = reader.float();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.y = reader.float();
          continue;
        case 4:
          if (tag !== 37) {
            break;
          }

          message.color1 = reader.fixed32();
          continue;
        case 5:
          if (tag !== 45) {
            break;
          }

          message.color2 = reader.fixed32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.effect = reader.uint32();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.message = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CUserMessageHudMsg {
    return {
      channel: isSet(object.channel) ? globalThis.Number(object.channel) : 0,
      x: isSet(object.x) ? globalThis.Number(object.x) : 0,
      y: isSet(object.y) ? globalThis.Number(object.y) : 0,
      color1: isSet(object.color1) ? globalThis.Number(object.color1) : 0,
      color2: isSet(object.color2) ? globalThis.Number(object.color2) : 0,
      effect: isSet(object.effect) ? globalThis.Number(object.effect) : 0,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: CUserMessageHudMsg): unknown {
    const obj: any = {};
    if (message.channel !== undefined && message.channel !== 0) {
      obj.channel = Math.round(message.channel);
    }
    if (message.x !== undefined && message.x !== 0) {
      obj.x = message.x;
    }
    if (message.y !== undefined && message.y !== 0) {
      obj.y = message.y;
    }
    if (message.color1 !== undefined && message.color1 !== 0) {
      obj.color1 = Math.round(message.color1);
    }
    if (message.color2 !== undefined && message.color2 !== 0) {
      obj.color2 = Math.round(message.color2);
    }
    if (message.effect !== undefined && message.effect !== 0) {
      obj.effect = Math.round(message.effect);
    }
    if (message.message !== undefined && message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create(base?: DeepPartial<CUserMessageHudMsg>): CUserMessageHudMsg {
    return CUserMessageHudMsg.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CUserMessageHudMsg>): CUserMessageHudMsg {
    const message = createBaseCUserMessageHudMsg();
    message.channel = object.channel ?? 0;
    message.x = object.x ?? 0;
    message.y = object.y ?? 0;
    message.color1 = object.color1 ?? 0;
    message.color2 = object.color2 ?? 0;
    message.effect = object.effect ?? 0;
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseCUserMessageHudText(): CUserMessageHudText {
  return { message: "" };
}

export const CUserMessageHudText = {
  encode(message: CUserMessageHudText, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.message !== undefined && message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CUserMessageHudText {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCUserMessageHudText();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CUserMessageHudText {
    return { message: isSet(object.message) ? globalThis.String(object.message) : "" };
  },

  toJSON(message: CUserMessageHudText): unknown {
    const obj: any = {};
    if (message.message !== undefined && message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create(base?: DeepPartial<CUserMessageHudText>): CUserMessageHudText {
    return CUserMessageHudText.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CUserMessageHudText>): CUserMessageHudText {
    const message = createBaseCUserMessageHudText();
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseCUserMessageTextMsg(): CUserMessageTextMsg {
  return { dest: 0, param: [] };
}

export const CUserMessageTextMsg = {
  encode(message: CUserMessageTextMsg, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.dest !== undefined && message.dest !== 0) {
      writer.uint32(8).uint32(message.dest);
    }
    for (const v of message.param) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CUserMessageTextMsg {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCUserMessageTextMsg();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.dest = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.param.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CUserMessageTextMsg {
    return {
      dest: isSet(object.dest) ? globalThis.Number(object.dest) : 0,
      param: globalThis.Array.isArray(object?.param) ? object.param.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: CUserMessageTextMsg): unknown {
    const obj: any = {};
    if (message.dest !== undefined && message.dest !== 0) {
      obj.dest = Math.round(message.dest);
    }
    if (message.param?.length) {
      obj.param = message.param;
    }
    return obj;
  },

  create(base?: DeepPartial<CUserMessageTextMsg>): CUserMessageTextMsg {
    return CUserMessageTextMsg.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CUserMessageTextMsg>): CUserMessageTextMsg {
    const message = createBaseCUserMessageTextMsg();
    message.dest = object.dest ?? 0;
    message.param = object.param?.map((e) => e) || [];
    return message;
  },
};

function createBaseCUserMessageGameTitle(): CUserMessageGameTitle {
  return {};
}

export const CUserMessageGameTitle = {
  encode(_: CUserMessageGameTitle, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CUserMessageGameTitle {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCUserMessageGameTitle();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CUserMessageGameTitle {
    return {};
  },

  toJSON(_: CUserMessageGameTitle): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<CUserMessageGameTitle>): CUserMessageGameTitle {
    return CUserMessageGameTitle.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<CUserMessageGameTitle>): CUserMessageGameTitle {
    const message = createBaseCUserMessageGameTitle();
    return message;
  },
};

function createBaseCUserMessageResetHUD(): CUserMessageResetHUD {
  return {};
}

export const CUserMessageResetHUD = {
  encode(_: CUserMessageResetHUD, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CUserMessageResetHUD {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCUserMessageResetHUD();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CUserMessageResetHUD {
    return {};
  },

  toJSON(_: CUserMessageResetHUD): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<CUserMessageResetHUD>): CUserMessageResetHUD {
    return CUserMessageResetHUD.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<CUserMessageResetHUD>): CUserMessageResetHUD {
    const message = createBaseCUserMessageResetHUD();
    return message;
  },
};

function createBaseCUserMessageSendAudio(): CUserMessageSendAudio {
  return { soundname: "", stop: false };
}

export const CUserMessageSendAudio = {
  encode(message: CUserMessageSendAudio, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.soundname !== undefined && message.soundname !== "") {
      writer.uint32(10).string(message.soundname);
    }
    if (message.stop !== undefined && message.stop !== false) {
      writer.uint32(16).bool(message.stop);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CUserMessageSendAudio {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCUserMessageSendAudio();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.soundname = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.stop = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CUserMessageSendAudio {
    return {
      soundname: isSet(object.soundname) ? globalThis.String(object.soundname) : "",
      stop: isSet(object.stop) ? globalThis.Boolean(object.stop) : false,
    };
  },

  toJSON(message: CUserMessageSendAudio): unknown {
    const obj: any = {};
    if (message.soundname !== undefined && message.soundname !== "") {
      obj.soundname = message.soundname;
    }
    if (message.stop !== undefined && message.stop !== false) {
      obj.stop = message.stop;
    }
    return obj;
  },

  create(base?: DeepPartial<CUserMessageSendAudio>): CUserMessageSendAudio {
    return CUserMessageSendAudio.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CUserMessageSendAudio>): CUserMessageSendAudio {
    const message = createBaseCUserMessageSendAudio();
    message.soundname = object.soundname ?? "";
    message.stop = object.stop ?? false;
    return message;
  },
};

function createBaseCUserMessageAudioParameter(): CUserMessageAudioParameter {
  return { parameterType: 0, nameHashCode: 0, value: 0, intValue: 0 };
}

export const CUserMessageAudioParameter = {
  encode(message: CUserMessageAudioParameter, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.parameterType !== undefined && message.parameterType !== 0) {
      writer.uint32(8).uint32(message.parameterType);
    }
    if (message.nameHashCode !== undefined && message.nameHashCode !== 0) {
      writer.uint32(16).uint32(message.nameHashCode);
    }
    if (message.value !== undefined && message.value !== 0) {
      writer.uint32(29).float(message.value);
    }
    if (message.intValue !== undefined && message.intValue !== 0) {
      writer.uint32(32).uint32(message.intValue);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CUserMessageAudioParameter {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCUserMessageAudioParameter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.parameterType = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.nameHashCode = reader.uint32();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.value = reader.float();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.intValue = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CUserMessageAudioParameter {
    return {
      parameterType: isSet(object.parameterType) ? globalThis.Number(object.parameterType) : 0,
      nameHashCode: isSet(object.nameHashCode) ? globalThis.Number(object.nameHashCode) : 0,
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
      intValue: isSet(object.intValue) ? globalThis.Number(object.intValue) : 0,
    };
  },

  toJSON(message: CUserMessageAudioParameter): unknown {
    const obj: any = {};
    if (message.parameterType !== undefined && message.parameterType !== 0) {
      obj.parameterType = Math.round(message.parameterType);
    }
    if (message.nameHashCode !== undefined && message.nameHashCode !== 0) {
      obj.nameHashCode = Math.round(message.nameHashCode);
    }
    if (message.value !== undefined && message.value !== 0) {
      obj.value = message.value;
    }
    if (message.intValue !== undefined && message.intValue !== 0) {
      obj.intValue = Math.round(message.intValue);
    }
    return obj;
  },

  create(base?: DeepPartial<CUserMessageAudioParameter>): CUserMessageAudioParameter {
    return CUserMessageAudioParameter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CUserMessageAudioParameter>): CUserMessageAudioParameter {
    const message = createBaseCUserMessageAudioParameter();
    message.parameterType = object.parameterType ?? 0;
    message.nameHashCode = object.nameHashCode ?? 0;
    message.value = object.value ?? 0;
    message.intValue = object.intValue ?? 0;
    return message;
  },
};

function createBaseCUserMessageVoiceMask(): CUserMessageVoiceMask {
  return { gamerulesMasks: [], banMasks: [], modEnable: false };
}

export const CUserMessageVoiceMask = {
  encode(message: CUserMessageVoiceMask, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.gamerulesMasks) {
      writer.uint32(v);
    }
    writer.ldelim();
    writer.uint32(18).fork();
    for (const v of message.banMasks) {
      writer.uint32(v);
    }
    writer.ldelim();
    if (message.modEnable !== undefined && message.modEnable !== false) {
      writer.uint32(24).bool(message.modEnable);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CUserMessageVoiceMask {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCUserMessageVoiceMask();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.gamerulesMasks.push(reader.uint32());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.gamerulesMasks.push(reader.uint32());
            }

            continue;
          }

          break;
        case 2:
          if (tag === 16) {
            message.banMasks.push(reader.uint32());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.banMasks.push(reader.uint32());
            }

            continue;
          }

          break;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.modEnable = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CUserMessageVoiceMask {
    return {
      gamerulesMasks: globalThis.Array.isArray(object?.gamerulesMasks)
        ? object.gamerulesMasks.map((e: any) => globalThis.Number(e))
        : [],
      banMasks: globalThis.Array.isArray(object?.banMasks) ? object.banMasks.map((e: any) => globalThis.Number(e)) : [],
      modEnable: isSet(object.modEnable) ? globalThis.Boolean(object.modEnable) : false,
    };
  },

  toJSON(message: CUserMessageVoiceMask): unknown {
    const obj: any = {};
    if (message.gamerulesMasks?.length) {
      obj.gamerulesMasks = message.gamerulesMasks.map((e) => Math.round(e));
    }
    if (message.banMasks?.length) {
      obj.banMasks = message.banMasks.map((e) => Math.round(e));
    }
    if (message.modEnable !== undefined && message.modEnable !== false) {
      obj.modEnable = message.modEnable;
    }
    return obj;
  },

  create(base?: DeepPartial<CUserMessageVoiceMask>): CUserMessageVoiceMask {
    return CUserMessageVoiceMask.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CUserMessageVoiceMask>): CUserMessageVoiceMask {
    const message = createBaseCUserMessageVoiceMask();
    message.gamerulesMasks = object.gamerulesMasks?.map((e) => e) || [];
    message.banMasks = object.banMasks?.map((e) => e) || [];
    message.modEnable = object.modEnable ?? false;
    return message;
  },
};

function createBaseCUserMessageRequestState(): CUserMessageRequestState {
  return {};
}

export const CUserMessageRequestState = {
  encode(_: CUserMessageRequestState, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CUserMessageRequestState {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCUserMessageRequestState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CUserMessageRequestState {
    return {};
  },

  toJSON(_: CUserMessageRequestState): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<CUserMessageRequestState>): CUserMessageRequestState {
    return CUserMessageRequestState.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<CUserMessageRequestState>): CUserMessageRequestState {
    const message = createBaseCUserMessageRequestState();
    return message;
  },
};

function createBaseCUserMessageRumble(): CUserMessageRumble {
  return { index: 0, data: 0, flags: 0 };
}

export const CUserMessageRumble = {
  encode(message: CUserMessageRumble, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.index !== undefined && message.index !== 0) {
      writer.uint32(8).int32(message.index);
    }
    if (message.data !== undefined && message.data !== 0) {
      writer.uint32(16).int32(message.data);
    }
    if (message.flags !== undefined && message.flags !== 0) {
      writer.uint32(24).int32(message.flags);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CUserMessageRumble {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCUserMessageRumble();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.index = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.data = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.flags = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CUserMessageRumble {
    return {
      index: isSet(object.index) ? globalThis.Number(object.index) : 0,
      data: isSet(object.data) ? globalThis.Number(object.data) : 0,
      flags: isSet(object.flags) ? globalThis.Number(object.flags) : 0,
    };
  },

  toJSON(message: CUserMessageRumble): unknown {
    const obj: any = {};
    if (message.index !== undefined && message.index !== 0) {
      obj.index = Math.round(message.index);
    }
    if (message.data !== undefined && message.data !== 0) {
      obj.data = Math.round(message.data);
    }
    if (message.flags !== undefined && message.flags !== 0) {
      obj.flags = Math.round(message.flags);
    }
    return obj;
  },

  create(base?: DeepPartial<CUserMessageRumble>): CUserMessageRumble {
    return CUserMessageRumble.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CUserMessageRumble>): CUserMessageRumble {
    const message = createBaseCUserMessageRumble();
    message.index = object.index ?? 0;
    message.data = object.data ?? 0;
    message.flags = object.flags ?? 0;
    return message;
  },
};

function createBaseCUserMessageSayTextChannel(): CUserMessageSayTextChannel {
  return { player: 0, channel: 0, text: "" };
}

export const CUserMessageSayTextChannel = {
  encode(message: CUserMessageSayTextChannel, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.player !== undefined && message.player !== 0) {
      writer.uint32(8).int32(message.player);
    }
    if (message.channel !== undefined && message.channel !== 0) {
      writer.uint32(16).int32(message.channel);
    }
    if (message.text !== undefined && message.text !== "") {
      writer.uint32(26).string(message.text);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CUserMessageSayTextChannel {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCUserMessageSayTextChannel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.player = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.channel = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.text = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CUserMessageSayTextChannel {
    return {
      player: isSet(object.player) ? globalThis.Number(object.player) : 0,
      channel: isSet(object.channel) ? globalThis.Number(object.channel) : 0,
      text: isSet(object.text) ? globalThis.String(object.text) : "",
    };
  },

  toJSON(message: CUserMessageSayTextChannel): unknown {
    const obj: any = {};
    if (message.player !== undefined && message.player !== 0) {
      obj.player = Math.round(message.player);
    }
    if (message.channel !== undefined && message.channel !== 0) {
      obj.channel = Math.round(message.channel);
    }
    if (message.text !== undefined && message.text !== "") {
      obj.text = message.text;
    }
    return obj;
  },

  create(base?: DeepPartial<CUserMessageSayTextChannel>): CUserMessageSayTextChannel {
    return CUserMessageSayTextChannel.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CUserMessageSayTextChannel>): CUserMessageSayTextChannel {
    const message = createBaseCUserMessageSayTextChannel();
    message.player = object.player ?? 0;
    message.channel = object.channel ?? 0;
    message.text = object.text ?? "";
    return message;
  },
};

function createBaseCUserMessageColoredText(): CUserMessageColoredText {
  return { color: 0, text: "", reset: false, contextPlayerSlot: -1, contextValue: 0, contextTeamId: 0 };
}

export const CUserMessageColoredText = {
  encode(message: CUserMessageColoredText, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.color !== undefined && message.color !== 0) {
      writer.uint32(8).uint32(message.color);
    }
    if (message.text !== undefined && message.text !== "") {
      writer.uint32(18).string(message.text);
    }
    if (message.reset !== undefined && message.reset !== false) {
      writer.uint32(24).bool(message.reset);
    }
    if (message.contextPlayerSlot !== undefined && message.contextPlayerSlot !== -1) {
      writer.uint32(32).int32(message.contextPlayerSlot);
    }
    if (message.contextValue !== undefined && message.contextValue !== 0) {
      writer.uint32(40).int32(message.contextValue);
    }
    if (message.contextTeamId !== undefined && message.contextTeamId !== 0) {
      writer.uint32(48).int32(message.contextTeamId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CUserMessageColoredText {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCUserMessageColoredText();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.color = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.text = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.reset = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.contextPlayerSlot = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.contextValue = reader.int32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.contextTeamId = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CUserMessageColoredText {
    return {
      color: isSet(object.color) ? globalThis.Number(object.color) : 0,
      text: isSet(object.text) ? globalThis.String(object.text) : "",
      reset: isSet(object.reset) ? globalThis.Boolean(object.reset) : false,
      contextPlayerSlot: isSet(object.contextPlayerSlot) ? globalThis.Number(object.contextPlayerSlot) : -1,
      contextValue: isSet(object.contextValue) ? globalThis.Number(object.contextValue) : 0,
      contextTeamId: isSet(object.contextTeamId) ? globalThis.Number(object.contextTeamId) : 0,
    };
  },

  toJSON(message: CUserMessageColoredText): unknown {
    const obj: any = {};
    if (message.color !== undefined && message.color !== 0) {
      obj.color = Math.round(message.color);
    }
    if (message.text !== undefined && message.text !== "") {
      obj.text = message.text;
    }
    if (message.reset !== undefined && message.reset !== false) {
      obj.reset = message.reset;
    }
    if (message.contextPlayerSlot !== undefined && message.contextPlayerSlot !== -1) {
      obj.contextPlayerSlot = Math.round(message.contextPlayerSlot);
    }
    if (message.contextValue !== undefined && message.contextValue !== 0) {
      obj.contextValue = Math.round(message.contextValue);
    }
    if (message.contextTeamId !== undefined && message.contextTeamId !== 0) {
      obj.contextTeamId = Math.round(message.contextTeamId);
    }
    return obj;
  },

  create(base?: DeepPartial<CUserMessageColoredText>): CUserMessageColoredText {
    return CUserMessageColoredText.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CUserMessageColoredText>): CUserMessageColoredText {
    const message = createBaseCUserMessageColoredText();
    message.color = object.color ?? 0;
    message.text = object.text ?? "";
    message.reset = object.reset ?? false;
    message.contextPlayerSlot = object.contextPlayerSlot ?? -1;
    message.contextValue = object.contextValue ?? 0;
    message.contextTeamId = object.contextTeamId ?? 0;
    return message;
  },
};

function createBaseCUserMessageItemPickup(): CUserMessageItemPickup {
  return { itemname: "" };
}

export const CUserMessageItemPickup = {
  encode(message: CUserMessageItemPickup, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.itemname !== undefined && message.itemname !== "") {
      writer.uint32(10).string(message.itemname);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CUserMessageItemPickup {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCUserMessageItemPickup();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.itemname = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CUserMessageItemPickup {
    return { itemname: isSet(object.itemname) ? globalThis.String(object.itemname) : "" };
  },

  toJSON(message: CUserMessageItemPickup): unknown {
    const obj: any = {};
    if (message.itemname !== undefined && message.itemname !== "") {
      obj.itemname = message.itemname;
    }
    return obj;
  },

  create(base?: DeepPartial<CUserMessageItemPickup>): CUserMessageItemPickup {
    return CUserMessageItemPickup.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CUserMessageItemPickup>): CUserMessageItemPickup {
    const message = createBaseCUserMessageItemPickup();
    message.itemname = object.itemname ?? "";
    return message;
  },
};

function createBaseCUserMessageAmmoDenied(): CUserMessageAmmoDenied {
  return { ammoId: 0 };
}

export const CUserMessageAmmoDenied = {
  encode(message: CUserMessageAmmoDenied, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.ammoId !== undefined && message.ammoId !== 0) {
      writer.uint32(8).uint32(message.ammoId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CUserMessageAmmoDenied {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCUserMessageAmmoDenied();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.ammoId = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CUserMessageAmmoDenied {
    return { ammoId: isSet(object.ammoId) ? globalThis.Number(object.ammoId) : 0 };
  },

  toJSON(message: CUserMessageAmmoDenied): unknown {
    const obj: any = {};
    if (message.ammoId !== undefined && message.ammoId !== 0) {
      obj.ammoId = Math.round(message.ammoId);
    }
    return obj;
  },

  create(base?: DeepPartial<CUserMessageAmmoDenied>): CUserMessageAmmoDenied {
    return CUserMessageAmmoDenied.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CUserMessageAmmoDenied>): CUserMessageAmmoDenied {
    const message = createBaseCUserMessageAmmoDenied();
    message.ammoId = object.ammoId ?? 0;
    return message;
  },
};

function createBaseCUserMessageShowMenu(): CUserMessageShowMenu {
  return { validslots: 0, displaytime: 0, needmore: false, menustring: "" };
}

export const CUserMessageShowMenu = {
  encode(message: CUserMessageShowMenu, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.validslots !== undefined && message.validslots !== 0) {
      writer.uint32(8).uint32(message.validslots);
    }
    if (message.displaytime !== undefined && message.displaytime !== 0) {
      writer.uint32(16).uint32(message.displaytime);
    }
    if (message.needmore !== undefined && message.needmore !== false) {
      writer.uint32(24).bool(message.needmore);
    }
    if (message.menustring !== undefined && message.menustring !== "") {
      writer.uint32(34).string(message.menustring);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CUserMessageShowMenu {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCUserMessageShowMenu();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.validslots = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.displaytime = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.needmore = reader.bool();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.menustring = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CUserMessageShowMenu {
    return {
      validslots: isSet(object.validslots) ? globalThis.Number(object.validslots) : 0,
      displaytime: isSet(object.displaytime) ? globalThis.Number(object.displaytime) : 0,
      needmore: isSet(object.needmore) ? globalThis.Boolean(object.needmore) : false,
      menustring: isSet(object.menustring) ? globalThis.String(object.menustring) : "",
    };
  },

  toJSON(message: CUserMessageShowMenu): unknown {
    const obj: any = {};
    if (message.validslots !== undefined && message.validslots !== 0) {
      obj.validslots = Math.round(message.validslots);
    }
    if (message.displaytime !== undefined && message.displaytime !== 0) {
      obj.displaytime = Math.round(message.displaytime);
    }
    if (message.needmore !== undefined && message.needmore !== false) {
      obj.needmore = message.needmore;
    }
    if (message.menustring !== undefined && message.menustring !== "") {
      obj.menustring = message.menustring;
    }
    return obj;
  },

  create(base?: DeepPartial<CUserMessageShowMenu>): CUserMessageShowMenu {
    return CUserMessageShowMenu.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CUserMessageShowMenu>): CUserMessageShowMenu {
    const message = createBaseCUserMessageShowMenu();
    message.validslots = object.validslots ?? 0;
    message.displaytime = object.displaytime ?? 0;
    message.needmore = object.needmore ?? false;
    message.menustring = object.menustring ?? "";
    return message;
  },
};

function createBaseCUserMessageCreditsMsg(): CUserMessageCreditsMsg {
  return { rolltype: -1, logoLength: 0 };
}

export const CUserMessageCreditsMsg = {
  encode(message: CUserMessageCreditsMsg, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.rolltype !== undefined && message.rolltype !== -1) {
      writer.uint32(8).int32(message.rolltype);
    }
    if (message.logoLength !== undefined && message.logoLength !== 0) {
      writer.uint32(21).float(message.logoLength);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CUserMessageCreditsMsg {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCUserMessageCreditsMsg();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.rolltype = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.logoLength = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CUserMessageCreditsMsg {
    return {
      rolltype: isSet(object.rolltype) ? eRollTypeFromJSON(object.rolltype) : -1,
      logoLength: isSet(object.logoLength) ? globalThis.Number(object.logoLength) : 0,
    };
  },

  toJSON(message: CUserMessageCreditsMsg): unknown {
    const obj: any = {};
    if (message.rolltype !== undefined && message.rolltype !== -1) {
      obj.rolltype = eRollTypeToJSON(message.rolltype);
    }
    if (message.logoLength !== undefined && message.logoLength !== 0) {
      obj.logoLength = message.logoLength;
    }
    return obj;
  },

  create(base?: DeepPartial<CUserMessageCreditsMsg>): CUserMessageCreditsMsg {
    return CUserMessageCreditsMsg.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CUserMessageCreditsMsg>): CUserMessageCreditsMsg {
    const message = createBaseCUserMessageCreditsMsg();
    message.rolltype = object.rolltype ?? -1;
    message.logoLength = object.logoLength ?? 0;
    return message;
  },
};

function createBaseCEntityMessagePlayJingle(): CEntityMessagePlayJingle {
  return { entityMsg: undefined };
}

export const CEntityMessagePlayJingle = {
  encode(message: CEntityMessagePlayJingle, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.entityMsg !== undefined) {
      CEntityMsg.encode(message.entityMsg, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CEntityMessagePlayJingle {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCEntityMessagePlayJingle();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.entityMsg = CEntityMsg.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CEntityMessagePlayJingle {
    return { entityMsg: isSet(object.entityMsg) ? CEntityMsg.fromJSON(object.entityMsg) : undefined };
  },

  toJSON(message: CEntityMessagePlayJingle): unknown {
    const obj: any = {};
    if (message.entityMsg !== undefined) {
      obj.entityMsg = CEntityMsg.toJSON(message.entityMsg);
    }
    return obj;
  },

  create(base?: DeepPartial<CEntityMessagePlayJingle>): CEntityMessagePlayJingle {
    return CEntityMessagePlayJingle.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CEntityMessagePlayJingle>): CEntityMessagePlayJingle {
    const message = createBaseCEntityMessagePlayJingle();
    message.entityMsg =
      object.entityMsg !== undefined && object.entityMsg !== null
        ? CEntityMsg.fromPartial(object.entityMsg)
        : undefined;
    return message;
  },
};

function createBaseCEntityMessageScreenOverlay(): CEntityMessageScreenOverlay {
  return { startEffect: false, entityMsg: undefined };
}

export const CEntityMessageScreenOverlay = {
  encode(message: CEntityMessageScreenOverlay, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.startEffect !== undefined && message.startEffect !== false) {
      writer.uint32(8).bool(message.startEffect);
    }
    if (message.entityMsg !== undefined) {
      CEntityMsg.encode(message.entityMsg, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CEntityMessageScreenOverlay {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCEntityMessageScreenOverlay();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.startEffect = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.entityMsg = CEntityMsg.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CEntityMessageScreenOverlay {
    return {
      startEffect: isSet(object.startEffect) ? globalThis.Boolean(object.startEffect) : false,
      entityMsg: isSet(object.entityMsg) ? CEntityMsg.fromJSON(object.entityMsg) : undefined,
    };
  },

  toJSON(message: CEntityMessageScreenOverlay): unknown {
    const obj: any = {};
    if (message.startEffect !== undefined && message.startEffect !== false) {
      obj.startEffect = message.startEffect;
    }
    if (message.entityMsg !== undefined) {
      obj.entityMsg = CEntityMsg.toJSON(message.entityMsg);
    }
    return obj;
  },

  create(base?: DeepPartial<CEntityMessageScreenOverlay>): CEntityMessageScreenOverlay {
    return CEntityMessageScreenOverlay.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CEntityMessageScreenOverlay>): CEntityMessageScreenOverlay {
    const message = createBaseCEntityMessageScreenOverlay();
    message.startEffect = object.startEffect ?? false;
    message.entityMsg =
      object.entityMsg !== undefined && object.entityMsg !== null
        ? CEntityMsg.fromPartial(object.entityMsg)
        : undefined;
    return message;
  },
};

function createBaseCEntityMessageRemoveAllDecals(): CEntityMessageRemoveAllDecals {
  return { removeDecals: false, entityMsg: undefined };
}

export const CEntityMessageRemoveAllDecals = {
  encode(message: CEntityMessageRemoveAllDecals, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.removeDecals !== undefined && message.removeDecals !== false) {
      writer.uint32(8).bool(message.removeDecals);
    }
    if (message.entityMsg !== undefined) {
      CEntityMsg.encode(message.entityMsg, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CEntityMessageRemoveAllDecals {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCEntityMessageRemoveAllDecals();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.removeDecals = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.entityMsg = CEntityMsg.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CEntityMessageRemoveAllDecals {
    return {
      removeDecals: isSet(object.removeDecals) ? globalThis.Boolean(object.removeDecals) : false,
      entityMsg: isSet(object.entityMsg) ? CEntityMsg.fromJSON(object.entityMsg) : undefined,
    };
  },

  toJSON(message: CEntityMessageRemoveAllDecals): unknown {
    const obj: any = {};
    if (message.removeDecals !== undefined && message.removeDecals !== false) {
      obj.removeDecals = message.removeDecals;
    }
    if (message.entityMsg !== undefined) {
      obj.entityMsg = CEntityMsg.toJSON(message.entityMsg);
    }
    return obj;
  },

  create(base?: DeepPartial<CEntityMessageRemoveAllDecals>): CEntityMessageRemoveAllDecals {
    return CEntityMessageRemoveAllDecals.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CEntityMessageRemoveAllDecals>): CEntityMessageRemoveAllDecals {
    const message = createBaseCEntityMessageRemoveAllDecals();
    message.removeDecals = object.removeDecals ?? false;
    message.entityMsg =
      object.entityMsg !== undefined && object.entityMsg !== null
        ? CEntityMsg.fromPartial(object.entityMsg)
        : undefined;
    return message;
  },
};

function createBaseCEntityMessagePropagateForce(): CEntityMessagePropagateForce {
  return { impulse: undefined, entityMsg: undefined };
}

export const CEntityMessagePropagateForce = {
  encode(message: CEntityMessagePropagateForce, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.impulse !== undefined) {
      CMsgVector.encode(message.impulse, writer.uint32(10).fork()).ldelim();
    }
    if (message.entityMsg !== undefined) {
      CEntityMsg.encode(message.entityMsg, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CEntityMessagePropagateForce {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCEntityMessagePropagateForce();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.impulse = CMsgVector.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.entityMsg = CEntityMsg.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CEntityMessagePropagateForce {
    return {
      impulse: isSet(object.impulse) ? CMsgVector.fromJSON(object.impulse) : undefined,
      entityMsg: isSet(object.entityMsg) ? CEntityMsg.fromJSON(object.entityMsg) : undefined,
    };
  },

  toJSON(message: CEntityMessagePropagateForce): unknown {
    const obj: any = {};
    if (message.impulse !== undefined) {
      obj.impulse = CMsgVector.toJSON(message.impulse);
    }
    if (message.entityMsg !== undefined) {
      obj.entityMsg = CEntityMsg.toJSON(message.entityMsg);
    }
    return obj;
  },

  create(base?: DeepPartial<CEntityMessagePropagateForce>): CEntityMessagePropagateForce {
    return CEntityMessagePropagateForce.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CEntityMessagePropagateForce>): CEntityMessagePropagateForce {
    const message = createBaseCEntityMessagePropagateForce();
    message.impulse =
      object.impulse !== undefined && object.impulse !== null ? CMsgVector.fromPartial(object.impulse) : undefined;
    message.entityMsg =
      object.entityMsg !== undefined && object.entityMsg !== null
        ? CEntityMsg.fromPartial(object.entityMsg)
        : undefined;
    return message;
  },
};

function createBaseCEntityMessageDoSpark(): CEntityMessageDoSpark {
  return {
    origin: undefined,
    entityindex: -1,
    radius: 0,
    color: 0,
    beams: 0,
    thick: 0,
    duration: 0,
    entityMsg: undefined,
  };
}

export const CEntityMessageDoSpark = {
  encode(message: CEntityMessageDoSpark, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.origin !== undefined) {
      CMsgVector.encode(message.origin, writer.uint32(10).fork()).ldelim();
    }
    if (message.entityindex !== undefined && message.entityindex !== -1) {
      writer.uint32(16).int32(message.entityindex);
    }
    if (message.radius !== undefined && message.radius !== 0) {
      writer.uint32(29).float(message.radius);
    }
    if (message.color !== undefined && message.color !== 0) {
      writer.uint32(37).fixed32(message.color);
    }
    if (message.beams !== undefined && message.beams !== 0) {
      writer.uint32(40).uint32(message.beams);
    }
    if (message.thick !== undefined && message.thick !== 0) {
      writer.uint32(53).float(message.thick);
    }
    if (message.duration !== undefined && message.duration !== 0) {
      writer.uint32(61).float(message.duration);
    }
    if (message.entityMsg !== undefined) {
      CEntityMsg.encode(message.entityMsg, writer.uint32(66).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CEntityMessageDoSpark {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCEntityMessageDoSpark();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.origin = CMsgVector.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.entityindex = reader.int32();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.radius = reader.float();
          continue;
        case 4:
          if (tag !== 37) {
            break;
          }

          message.color = reader.fixed32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.beams = reader.uint32();
          continue;
        case 6:
          if (tag !== 53) {
            break;
          }

          message.thick = reader.float();
          continue;
        case 7:
          if (tag !== 61) {
            break;
          }

          message.duration = reader.float();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.entityMsg = CEntityMsg.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CEntityMessageDoSpark {
    return {
      origin: isSet(object.origin) ? CMsgVector.fromJSON(object.origin) : undefined,
      entityindex: isSet(object.entityindex) ? globalThis.Number(object.entityindex) : -1,
      radius: isSet(object.radius) ? globalThis.Number(object.radius) : 0,
      color: isSet(object.color) ? globalThis.Number(object.color) : 0,
      beams: isSet(object.beams) ? globalThis.Number(object.beams) : 0,
      thick: isSet(object.thick) ? globalThis.Number(object.thick) : 0,
      duration: isSet(object.duration) ? globalThis.Number(object.duration) : 0,
      entityMsg: isSet(object.entityMsg) ? CEntityMsg.fromJSON(object.entityMsg) : undefined,
    };
  },

  toJSON(message: CEntityMessageDoSpark): unknown {
    const obj: any = {};
    if (message.origin !== undefined) {
      obj.origin = CMsgVector.toJSON(message.origin);
    }
    if (message.entityindex !== undefined && message.entityindex !== -1) {
      obj.entityindex = Math.round(message.entityindex);
    }
    if (message.radius !== undefined && message.radius !== 0) {
      obj.radius = message.radius;
    }
    if (message.color !== undefined && message.color !== 0) {
      obj.color = Math.round(message.color);
    }
    if (message.beams !== undefined && message.beams !== 0) {
      obj.beams = Math.round(message.beams);
    }
    if (message.thick !== undefined && message.thick !== 0) {
      obj.thick = message.thick;
    }
    if (message.duration !== undefined && message.duration !== 0) {
      obj.duration = message.duration;
    }
    if (message.entityMsg !== undefined) {
      obj.entityMsg = CEntityMsg.toJSON(message.entityMsg);
    }
    return obj;
  },

  create(base?: DeepPartial<CEntityMessageDoSpark>): CEntityMessageDoSpark {
    return CEntityMessageDoSpark.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CEntityMessageDoSpark>): CEntityMessageDoSpark {
    const message = createBaseCEntityMessageDoSpark();
    message.origin =
      object.origin !== undefined && object.origin !== null ? CMsgVector.fromPartial(object.origin) : undefined;
    message.entityindex = object.entityindex ?? -1;
    message.radius = object.radius ?? 0;
    message.color = object.color ?? 0;
    message.beams = object.beams ?? 0;
    message.thick = object.thick ?? 0;
    message.duration = object.duration ?? 0;
    message.entityMsg =
      object.entityMsg !== undefined && object.entityMsg !== null
        ? CEntityMsg.fromPartial(object.entityMsg)
        : undefined;
    return message;
  },
};

function createBaseCEntityMessageFixAngle(): CEntityMessageFixAngle {
  return { relative: false, angle: undefined, entityMsg: undefined };
}

export const CEntityMessageFixAngle = {
  encode(message: CEntityMessageFixAngle, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.relative !== undefined && message.relative !== false) {
      writer.uint32(8).bool(message.relative);
    }
    if (message.angle !== undefined) {
      CMsgQAngle.encode(message.angle, writer.uint32(18).fork()).ldelim();
    }
    if (message.entityMsg !== undefined) {
      CEntityMsg.encode(message.entityMsg, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CEntityMessageFixAngle {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCEntityMessageFixAngle();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.relative = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.angle = CMsgQAngle.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.entityMsg = CEntityMsg.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CEntityMessageFixAngle {
    return {
      relative: isSet(object.relative) ? globalThis.Boolean(object.relative) : false,
      angle: isSet(object.angle) ? CMsgQAngle.fromJSON(object.angle) : undefined,
      entityMsg: isSet(object.entityMsg) ? CEntityMsg.fromJSON(object.entityMsg) : undefined,
    };
  },

  toJSON(message: CEntityMessageFixAngle): unknown {
    const obj: any = {};
    if (message.relative !== undefined && message.relative !== false) {
      obj.relative = message.relative;
    }
    if (message.angle !== undefined) {
      obj.angle = CMsgQAngle.toJSON(message.angle);
    }
    if (message.entityMsg !== undefined) {
      obj.entityMsg = CEntityMsg.toJSON(message.entityMsg);
    }
    return obj;
  },

  create(base?: DeepPartial<CEntityMessageFixAngle>): CEntityMessageFixAngle {
    return CEntityMessageFixAngle.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CEntityMessageFixAngle>): CEntityMessageFixAngle {
    const message = createBaseCEntityMessageFixAngle();
    message.relative = object.relative ?? false;
    message.angle =
      object.angle !== undefined && object.angle !== null ? CMsgQAngle.fromPartial(object.angle) : undefined;
    message.entityMsg =
      object.entityMsg !== undefined && object.entityMsg !== null
        ? CEntityMsg.fromPartial(object.entityMsg)
        : undefined;
    return message;
  },
};

function createBaseCUserMessageCameraTransition(): CUserMessageCameraTransition {
  return { cameraType: 0, duration: 0, paramsDataDriven: undefined };
}

export const CUserMessageCameraTransition = {
  encode(message: CUserMessageCameraTransition, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.cameraType !== undefined && message.cameraType !== 0) {
      writer.uint32(8).uint32(message.cameraType);
    }
    if (message.duration !== undefined && message.duration !== 0) {
      writer.uint32(21).float(message.duration);
    }
    if (message.paramsDataDriven !== undefined) {
      CUserMessageCameraTransition_TransitionDataDriven.encode(
        message.paramsDataDriven,
        writer.uint32(26).fork(),
      ).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CUserMessageCameraTransition {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCUserMessageCameraTransition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.cameraType = reader.uint32();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.duration = reader.float();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.paramsDataDriven = CUserMessageCameraTransition_TransitionDataDriven.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CUserMessageCameraTransition {
    return {
      cameraType: isSet(object.cameraType) ? globalThis.Number(object.cameraType) : 0,
      duration: isSet(object.duration) ? globalThis.Number(object.duration) : 0,
      paramsDataDriven: isSet(object.paramsDataDriven)
        ? CUserMessageCameraTransition_TransitionDataDriven.fromJSON(object.paramsDataDriven)
        : undefined,
    };
  },

  toJSON(message: CUserMessageCameraTransition): unknown {
    const obj: any = {};
    if (message.cameraType !== undefined && message.cameraType !== 0) {
      obj.cameraType = Math.round(message.cameraType);
    }
    if (message.duration !== undefined && message.duration !== 0) {
      obj.duration = message.duration;
    }
    if (message.paramsDataDriven !== undefined) {
      obj.paramsDataDriven = CUserMessageCameraTransition_TransitionDataDriven.toJSON(message.paramsDataDriven);
    }
    return obj;
  },

  create(base?: DeepPartial<CUserMessageCameraTransition>): CUserMessageCameraTransition {
    return CUserMessageCameraTransition.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CUserMessageCameraTransition>): CUserMessageCameraTransition {
    const message = createBaseCUserMessageCameraTransition();
    message.cameraType = object.cameraType ?? 0;
    message.duration = object.duration ?? 0;
    message.paramsDataDriven =
      object.paramsDataDriven !== undefined && object.paramsDataDriven !== null
        ? CUserMessageCameraTransition_TransitionDataDriven.fromPartial(object.paramsDataDriven)
        : undefined;
    return message;
  },
};

function createBaseCUserMessageCameraTransition_TransitionDataDriven(): CUserMessageCameraTransition_TransitionDataDriven {
  return { filename: "", attachEntIndex: -1, duration: 0 };
}

export const CUserMessageCameraTransition_TransitionDataDriven = {
  encode(
    message: CUserMessageCameraTransition_TransitionDataDriven,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.filename !== undefined && message.filename !== "") {
      writer.uint32(10).string(message.filename);
    }
    if (message.attachEntIndex !== undefined && message.attachEntIndex !== -1) {
      writer.uint32(16).int32(message.attachEntIndex);
    }
    if (message.duration !== undefined && message.duration !== 0) {
      writer.uint32(29).float(message.duration);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CUserMessageCameraTransition_TransitionDataDriven {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCUserMessageCameraTransition_TransitionDataDriven();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.filename = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.attachEntIndex = reader.int32();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.duration = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CUserMessageCameraTransition_TransitionDataDriven {
    return {
      filename: isSet(object.filename) ? globalThis.String(object.filename) : "",
      attachEntIndex: isSet(object.attachEntIndex) ? globalThis.Number(object.attachEntIndex) : -1,
      duration: isSet(object.duration) ? globalThis.Number(object.duration) : 0,
    };
  },

  toJSON(message: CUserMessageCameraTransition_TransitionDataDriven): unknown {
    const obj: any = {};
    if (message.filename !== undefined && message.filename !== "") {
      obj.filename = message.filename;
    }
    if (message.attachEntIndex !== undefined && message.attachEntIndex !== -1) {
      obj.attachEntIndex = Math.round(message.attachEntIndex);
    }
    if (message.duration !== undefined && message.duration !== 0) {
      obj.duration = message.duration;
    }
    return obj;
  },

  create(
    base?: DeepPartial<CUserMessageCameraTransition_TransitionDataDriven>,
  ): CUserMessageCameraTransition_TransitionDataDriven {
    return CUserMessageCameraTransition_TransitionDataDriven.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CUserMessageCameraTransition_TransitionDataDriven>,
  ): CUserMessageCameraTransition_TransitionDataDriven {
    const message = createBaseCUserMessageCameraTransition_TransitionDataDriven();
    message.filename = object.filename ?? "";
    message.attachEntIndex = object.attachEntIndex ?? -1;
    message.duration = object.duration ?? 0;
    return message;
  },
};

function createBaseCUserMsgParticleManager(): CUserMsgParticleManager {
  return {
    type: 0,
    index: 0,
    releaseParticleIndex: undefined,
    createParticle: undefined,
    destroyParticle: undefined,
    destroyParticleInvolving: undefined,
    updateParticle: undefined,
    updateParticleFwd: undefined,
    updateParticleOrient: undefined,
    updateParticleFallback: undefined,
    updateParticleOffset: undefined,
    updateParticleEnt: undefined,
    updateParticleShouldDraw: undefined,
    updateParticleSetFrozen: undefined,
    changeControlPointAttachment: undefined,
    updateEntityPosition: undefined,
    setParticleFowProperties: undefined,
    setParticleText: undefined,
    setParticleShouldCheckFow: undefined,
    setControlPointModel: undefined,
    setControlPointSnapshot: undefined,
    setTextureAttribute: undefined,
    setSceneObjectGenericFlag: undefined,
    setSceneObjectTintAndDesat: undefined,
    destroyParticleNamed: undefined,
    particleSkipToTime: undefined,
    particleCanFreeze: undefined,
    setNamedValueContext: undefined,
    updateParticleTransform: undefined,
    particleFreezeTransitionOverride: undefined,
    freezeParticleInvolving: undefined,
    addModellistOverrideElement: undefined,
    clearModellistOverride: undefined,
    createPhysicsSim: undefined,
    destroyPhysicsSim: undefined,
  };
}

export const CUserMsgParticleManager = {
  encode(message: CUserMsgParticleManager, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.index !== 0) {
      writer.uint32(16).uint32(message.index);
    }
    if (message.releaseParticleIndex !== undefined) {
      CUserMsgParticleManager_ReleaseParticleIndex.encode(
        message.releaseParticleIndex,
        writer.uint32(26).fork(),
      ).ldelim();
    }
    if (message.createParticle !== undefined) {
      CUserMsgParticleManager_CreateParticle.encode(message.createParticle, writer.uint32(34).fork()).ldelim();
    }
    if (message.destroyParticle !== undefined) {
      CUserMsgParticleManager_DestroyParticle.encode(message.destroyParticle, writer.uint32(42).fork()).ldelim();
    }
    if (message.destroyParticleInvolving !== undefined) {
      CUserMsgParticleManager_DestroyParticleInvolving.encode(
        message.destroyParticleInvolving,
        writer.uint32(50).fork(),
      ).ldelim();
    }
    if (message.updateParticle !== undefined) {
      CUserMsgParticleManager_UpdateParticleOBSOLETE.encode(message.updateParticle, writer.uint32(58).fork()).ldelim();
    }
    if (message.updateParticleFwd !== undefined) {
      CUserMsgParticleManager_UpdateParticleFwdOBSOLETE.encode(
        message.updateParticleFwd,
        writer.uint32(66).fork(),
      ).ldelim();
    }
    if (message.updateParticleOrient !== undefined) {
      CUserMsgParticleManager_UpdateParticleOrientOBSOLETE.encode(
        message.updateParticleOrient,
        writer.uint32(74).fork(),
      ).ldelim();
    }
    if (message.updateParticleFallback !== undefined) {
      CUserMsgParticleManager_UpdateParticleFallback.encode(
        message.updateParticleFallback,
        writer.uint32(82).fork(),
      ).ldelim();
    }
    if (message.updateParticleOffset !== undefined) {
      CUserMsgParticleManager_UpdateParticleOffset.encode(
        message.updateParticleOffset,
        writer.uint32(90).fork(),
      ).ldelim();
    }
    if (message.updateParticleEnt !== undefined) {
      CUserMsgParticleManager_UpdateParticleEnt.encode(message.updateParticleEnt, writer.uint32(98).fork()).ldelim();
    }
    if (message.updateParticleShouldDraw !== undefined) {
      CUserMsgParticleManager_UpdateParticleShouldDraw.encode(
        message.updateParticleShouldDraw,
        writer.uint32(114).fork(),
      ).ldelim();
    }
    if (message.updateParticleSetFrozen !== undefined) {
      CUserMsgParticleManager_UpdateParticleSetFrozen.encode(
        message.updateParticleSetFrozen,
        writer.uint32(122).fork(),
      ).ldelim();
    }
    if (message.changeControlPointAttachment !== undefined) {
      CUserMsgParticleManager_ChangeControlPointAttachment.encode(
        message.changeControlPointAttachment,
        writer.uint32(130).fork(),
      ).ldelim();
    }
    if (message.updateEntityPosition !== undefined) {
      CUserMsgParticleManager_UpdateEntityPosition.encode(
        message.updateEntityPosition,
        writer.uint32(138).fork(),
      ).ldelim();
    }
    if (message.setParticleFowProperties !== undefined) {
      CUserMsgParticleManager_SetParticleFoWProperties.encode(
        message.setParticleFowProperties,
        writer.uint32(146).fork(),
      ).ldelim();
    }
    if (message.setParticleText !== undefined) {
      CUserMsgParticleManager_SetParticleText.encode(message.setParticleText, writer.uint32(154).fork()).ldelim();
    }
    if (message.setParticleShouldCheckFow !== undefined) {
      CUserMsgParticleManager_SetParticleShouldCheckFoW.encode(
        message.setParticleShouldCheckFow,
        writer.uint32(162).fork(),
      ).ldelim();
    }
    if (message.setControlPointModel !== undefined) {
      CUserMsgParticleManager_SetControlPointModel.encode(
        message.setControlPointModel,
        writer.uint32(170).fork(),
      ).ldelim();
    }
    if (message.setControlPointSnapshot !== undefined) {
      CUserMsgParticleManager_SetControlPointSnapshot.encode(
        message.setControlPointSnapshot,
        writer.uint32(178).fork(),
      ).ldelim();
    }
    if (message.setTextureAttribute !== undefined) {
      CUserMsgParticleManager_SetTextureAttribute.encode(
        message.setTextureAttribute,
        writer.uint32(186).fork(),
      ).ldelim();
    }
    if (message.setSceneObjectGenericFlag !== undefined) {
      CUserMsgParticleManager_SetSceneObjectGenericFlag.encode(
        message.setSceneObjectGenericFlag,
        writer.uint32(194).fork(),
      ).ldelim();
    }
    if (message.setSceneObjectTintAndDesat !== undefined) {
      CUserMsgParticleManager_SetSceneObjectTintAndDesat.encode(
        message.setSceneObjectTintAndDesat,
        writer.uint32(202).fork(),
      ).ldelim();
    }
    if (message.destroyParticleNamed !== undefined) {
      CUserMsgParticleManager_DestroyParticleNamed.encode(
        message.destroyParticleNamed,
        writer.uint32(210).fork(),
      ).ldelim();
    }
    if (message.particleSkipToTime !== undefined) {
      CUserMsgParticleManager_ParticleSkipToTime.encode(message.particleSkipToTime, writer.uint32(218).fork()).ldelim();
    }
    if (message.particleCanFreeze !== undefined) {
      CUserMsgParticleManager_ParticleCanFreeze.encode(message.particleCanFreeze, writer.uint32(226).fork()).ldelim();
    }
    if (message.setNamedValueContext !== undefined) {
      CUserMsgParticleManager_SetParticleNamedValueContext.encode(
        message.setNamedValueContext,
        writer.uint32(234).fork(),
      ).ldelim();
    }
    if (message.updateParticleTransform !== undefined) {
      CUserMsgParticleManager_UpdateParticleTransform.encode(
        message.updateParticleTransform,
        writer.uint32(242).fork(),
      ).ldelim();
    }
    if (message.particleFreezeTransitionOverride !== undefined) {
      CUserMsgParticleManager_ParticleFreezeTransitionOverride.encode(
        message.particleFreezeTransitionOverride,
        writer.uint32(250).fork(),
      ).ldelim();
    }
    if (message.freezeParticleInvolving !== undefined) {
      CUserMsgParticleManager_FreezeParticleInvolving.encode(
        message.freezeParticleInvolving,
        writer.uint32(258).fork(),
      ).ldelim();
    }
    if (message.addModellistOverrideElement !== undefined) {
      CUserMsgParticleManager_AddModellistOverrideElement.encode(
        message.addModellistOverrideElement,
        writer.uint32(266).fork(),
      ).ldelim();
    }
    if (message.clearModellistOverride !== undefined) {
      CUserMsgParticleManager_ClearModellistOverride.encode(
        message.clearModellistOverride,
        writer.uint32(274).fork(),
      ).ldelim();
    }
    if (message.createPhysicsSim !== undefined) {
      CUserMsgParticleManager_CreatePhysicsSim.encode(message.createPhysicsSim, writer.uint32(282).fork()).ldelim();
    }
    if (message.destroyPhysicsSim !== undefined) {
      CUserMsgParticleManager_DestroyPhysicsSim.encode(message.destroyPhysicsSim, writer.uint32(290).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CUserMsgParticleManager {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCUserMsgParticleManager();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.index = reader.uint32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.releaseParticleIndex = CUserMsgParticleManager_ReleaseParticleIndex.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.createParticle = CUserMsgParticleManager_CreateParticle.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.destroyParticle = CUserMsgParticleManager_DestroyParticle.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.destroyParticleInvolving = CUserMsgParticleManager_DestroyParticleInvolving.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.updateParticle = CUserMsgParticleManager_UpdateParticleOBSOLETE.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.updateParticleFwd = CUserMsgParticleManager_UpdateParticleFwdOBSOLETE.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.updateParticleOrient = CUserMsgParticleManager_UpdateParticleOrientOBSOLETE.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.updateParticleFallback = CUserMsgParticleManager_UpdateParticleFallback.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.updateParticleOffset = CUserMsgParticleManager_UpdateParticleOffset.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.updateParticleEnt = CUserMsgParticleManager_UpdateParticleEnt.decode(reader, reader.uint32());
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.updateParticleShouldDraw = CUserMsgParticleManager_UpdateParticleShouldDraw.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.updateParticleSetFrozen = CUserMsgParticleManager_UpdateParticleSetFrozen.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.changeControlPointAttachment = CUserMsgParticleManager_ChangeControlPointAttachment.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.updateEntityPosition = CUserMsgParticleManager_UpdateEntityPosition.decode(reader, reader.uint32());
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.setParticleFowProperties = CUserMsgParticleManager_SetParticleFoWProperties.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.setParticleText = CUserMsgParticleManager_SetParticleText.decode(reader, reader.uint32());
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.setParticleShouldCheckFow = CUserMsgParticleManager_SetParticleShouldCheckFoW.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }

          message.setControlPointModel = CUserMsgParticleManager_SetControlPointModel.decode(reader, reader.uint32());
          continue;
        case 22:
          if (tag !== 178) {
            break;
          }

          message.setControlPointSnapshot = CUserMsgParticleManager_SetControlPointSnapshot.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 23:
          if (tag !== 186) {
            break;
          }

          message.setTextureAttribute = CUserMsgParticleManager_SetTextureAttribute.decode(reader, reader.uint32());
          continue;
        case 24:
          if (tag !== 194) {
            break;
          }

          message.setSceneObjectGenericFlag = CUserMsgParticleManager_SetSceneObjectGenericFlag.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 25:
          if (tag !== 202) {
            break;
          }

          message.setSceneObjectTintAndDesat = CUserMsgParticleManager_SetSceneObjectTintAndDesat.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 26:
          if (tag !== 210) {
            break;
          }

          message.destroyParticleNamed = CUserMsgParticleManager_DestroyParticleNamed.decode(reader, reader.uint32());
          continue;
        case 27:
          if (tag !== 218) {
            break;
          }

          message.particleSkipToTime = CUserMsgParticleManager_ParticleSkipToTime.decode(reader, reader.uint32());
          continue;
        case 28:
          if (tag !== 226) {
            break;
          }

          message.particleCanFreeze = CUserMsgParticleManager_ParticleCanFreeze.decode(reader, reader.uint32());
          continue;
        case 29:
          if (tag !== 234) {
            break;
          }

          message.setNamedValueContext = CUserMsgParticleManager_SetParticleNamedValueContext.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 30:
          if (tag !== 242) {
            break;
          }

          message.updateParticleTransform = CUserMsgParticleManager_UpdateParticleTransform.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 31:
          if (tag !== 250) {
            break;
          }

          message.particleFreezeTransitionOverride = CUserMsgParticleManager_ParticleFreezeTransitionOverride.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 32:
          if (tag !== 258) {
            break;
          }

          message.freezeParticleInvolving = CUserMsgParticleManager_FreezeParticleInvolving.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 33:
          if (tag !== 266) {
            break;
          }

          message.addModellistOverrideElement = CUserMsgParticleManager_AddModellistOverrideElement.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 34:
          if (tag !== 274) {
            break;
          }

          message.clearModellistOverride = CUserMsgParticleManager_ClearModellistOverride.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 35:
          if (tag !== 282) {
            break;
          }

          message.createPhysicsSim = CUserMsgParticleManager_CreatePhysicsSim.decode(reader, reader.uint32());
          continue;
        case 36:
          if (tag !== 290) {
            break;
          }

          message.destroyPhysicsSim = CUserMsgParticleManager_DestroyPhysicsSim.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CUserMsgParticleManager {
    return {
      type: isSet(object.type) ? particleMessageFromJSON(object.type) : 0,
      index: isSet(object.index) ? globalThis.Number(object.index) : 0,
      releaseParticleIndex: isSet(object.releaseParticleIndex)
        ? CUserMsgParticleManager_ReleaseParticleIndex.fromJSON(object.releaseParticleIndex)
        : undefined,
      createParticle: isSet(object.createParticle)
        ? CUserMsgParticleManager_CreateParticle.fromJSON(object.createParticle)
        : undefined,
      destroyParticle: isSet(object.destroyParticle)
        ? CUserMsgParticleManager_DestroyParticle.fromJSON(object.destroyParticle)
        : undefined,
      destroyParticleInvolving: isSet(object.destroyParticleInvolving)
        ? CUserMsgParticleManager_DestroyParticleInvolving.fromJSON(object.destroyParticleInvolving)
        : undefined,
      updateParticle: isSet(object.updateParticle)
        ? CUserMsgParticleManager_UpdateParticleOBSOLETE.fromJSON(object.updateParticle)
        : undefined,
      updateParticleFwd: isSet(object.updateParticleFwd)
        ? CUserMsgParticleManager_UpdateParticleFwdOBSOLETE.fromJSON(object.updateParticleFwd)
        : undefined,
      updateParticleOrient: isSet(object.updateParticleOrient)
        ? CUserMsgParticleManager_UpdateParticleOrientOBSOLETE.fromJSON(object.updateParticleOrient)
        : undefined,
      updateParticleFallback: isSet(object.updateParticleFallback)
        ? CUserMsgParticleManager_UpdateParticleFallback.fromJSON(object.updateParticleFallback)
        : undefined,
      updateParticleOffset: isSet(object.updateParticleOffset)
        ? CUserMsgParticleManager_UpdateParticleOffset.fromJSON(object.updateParticleOffset)
        : undefined,
      updateParticleEnt: isSet(object.updateParticleEnt)
        ? CUserMsgParticleManager_UpdateParticleEnt.fromJSON(object.updateParticleEnt)
        : undefined,
      updateParticleShouldDraw: isSet(object.updateParticleShouldDraw)
        ? CUserMsgParticleManager_UpdateParticleShouldDraw.fromJSON(object.updateParticleShouldDraw)
        : undefined,
      updateParticleSetFrozen: isSet(object.updateParticleSetFrozen)
        ? CUserMsgParticleManager_UpdateParticleSetFrozen.fromJSON(object.updateParticleSetFrozen)
        : undefined,
      changeControlPointAttachment: isSet(object.changeControlPointAttachment)
        ? CUserMsgParticleManager_ChangeControlPointAttachment.fromJSON(object.changeControlPointAttachment)
        : undefined,
      updateEntityPosition: isSet(object.updateEntityPosition)
        ? CUserMsgParticleManager_UpdateEntityPosition.fromJSON(object.updateEntityPosition)
        : undefined,
      setParticleFowProperties: isSet(object.setParticleFowProperties)
        ? CUserMsgParticleManager_SetParticleFoWProperties.fromJSON(object.setParticleFowProperties)
        : undefined,
      setParticleText: isSet(object.setParticleText)
        ? CUserMsgParticleManager_SetParticleText.fromJSON(object.setParticleText)
        : undefined,
      setParticleShouldCheckFow: isSet(object.setParticleShouldCheckFow)
        ? CUserMsgParticleManager_SetParticleShouldCheckFoW.fromJSON(object.setParticleShouldCheckFow)
        : undefined,
      setControlPointModel: isSet(object.setControlPointModel)
        ? CUserMsgParticleManager_SetControlPointModel.fromJSON(object.setControlPointModel)
        : undefined,
      setControlPointSnapshot: isSet(object.setControlPointSnapshot)
        ? CUserMsgParticleManager_SetControlPointSnapshot.fromJSON(object.setControlPointSnapshot)
        : undefined,
      setTextureAttribute: isSet(object.setTextureAttribute)
        ? CUserMsgParticleManager_SetTextureAttribute.fromJSON(object.setTextureAttribute)
        : undefined,
      setSceneObjectGenericFlag: isSet(object.setSceneObjectGenericFlag)
        ? CUserMsgParticleManager_SetSceneObjectGenericFlag.fromJSON(object.setSceneObjectGenericFlag)
        : undefined,
      setSceneObjectTintAndDesat: isSet(object.setSceneObjectTintAndDesat)
        ? CUserMsgParticleManager_SetSceneObjectTintAndDesat.fromJSON(object.setSceneObjectTintAndDesat)
        : undefined,
      destroyParticleNamed: isSet(object.destroyParticleNamed)
        ? CUserMsgParticleManager_DestroyParticleNamed.fromJSON(object.destroyParticleNamed)
        : undefined,
      particleSkipToTime: isSet(object.particleSkipToTime)
        ? CUserMsgParticleManager_ParticleSkipToTime.fromJSON(object.particleSkipToTime)
        : undefined,
      particleCanFreeze: isSet(object.particleCanFreeze)
        ? CUserMsgParticleManager_ParticleCanFreeze.fromJSON(object.particleCanFreeze)
        : undefined,
      setNamedValueContext: isSet(object.setNamedValueContext)
        ? CUserMsgParticleManager_SetParticleNamedValueContext.fromJSON(object.setNamedValueContext)
        : undefined,
      updateParticleTransform: isSet(object.updateParticleTransform)
        ? CUserMsgParticleManager_UpdateParticleTransform.fromJSON(object.updateParticleTransform)
        : undefined,
      particleFreezeTransitionOverride: isSet(object.particleFreezeTransitionOverride)
        ? CUserMsgParticleManager_ParticleFreezeTransitionOverride.fromJSON(object.particleFreezeTransitionOverride)
        : undefined,
      freezeParticleInvolving: isSet(object.freezeParticleInvolving)
        ? CUserMsgParticleManager_FreezeParticleInvolving.fromJSON(object.freezeParticleInvolving)
        : undefined,
      addModellistOverrideElement: isSet(object.addModellistOverrideElement)
        ? CUserMsgParticleManager_AddModellistOverrideElement.fromJSON(object.addModellistOverrideElement)
        : undefined,
      clearModellistOverride: isSet(object.clearModellistOverride)
        ? CUserMsgParticleManager_ClearModellistOverride.fromJSON(object.clearModellistOverride)
        : undefined,
      createPhysicsSim: isSet(object.createPhysicsSim)
        ? CUserMsgParticleManager_CreatePhysicsSim.fromJSON(object.createPhysicsSim)
        : undefined,
      destroyPhysicsSim: isSet(object.destroyPhysicsSim)
        ? CUserMsgParticleManager_DestroyPhysicsSim.fromJSON(object.destroyPhysicsSim)
        : undefined,
    };
  },

  toJSON(message: CUserMsgParticleManager): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = particleMessageToJSON(message.type);
    }
    if (message.index !== 0) {
      obj.index = Math.round(message.index);
    }
    if (message.releaseParticleIndex !== undefined) {
      obj.releaseParticleIndex = CUserMsgParticleManager_ReleaseParticleIndex.toJSON(message.releaseParticleIndex);
    }
    if (message.createParticle !== undefined) {
      obj.createParticle = CUserMsgParticleManager_CreateParticle.toJSON(message.createParticle);
    }
    if (message.destroyParticle !== undefined) {
      obj.destroyParticle = CUserMsgParticleManager_DestroyParticle.toJSON(message.destroyParticle);
    }
    if (message.destroyParticleInvolving !== undefined) {
      obj.destroyParticleInvolving = CUserMsgParticleManager_DestroyParticleInvolving.toJSON(
        message.destroyParticleInvolving,
      );
    }
    if (message.updateParticle !== undefined) {
      obj.updateParticle = CUserMsgParticleManager_UpdateParticleOBSOLETE.toJSON(message.updateParticle);
    }
    if (message.updateParticleFwd !== undefined) {
      obj.updateParticleFwd = CUserMsgParticleManager_UpdateParticleFwdOBSOLETE.toJSON(message.updateParticleFwd);
    }
    if (message.updateParticleOrient !== undefined) {
      obj.updateParticleOrient = CUserMsgParticleManager_UpdateParticleOrientOBSOLETE.toJSON(
        message.updateParticleOrient,
      );
    }
    if (message.updateParticleFallback !== undefined) {
      obj.updateParticleFallback = CUserMsgParticleManager_UpdateParticleFallback.toJSON(
        message.updateParticleFallback,
      );
    }
    if (message.updateParticleOffset !== undefined) {
      obj.updateParticleOffset = CUserMsgParticleManager_UpdateParticleOffset.toJSON(message.updateParticleOffset);
    }
    if (message.updateParticleEnt !== undefined) {
      obj.updateParticleEnt = CUserMsgParticleManager_UpdateParticleEnt.toJSON(message.updateParticleEnt);
    }
    if (message.updateParticleShouldDraw !== undefined) {
      obj.updateParticleShouldDraw = CUserMsgParticleManager_UpdateParticleShouldDraw.toJSON(
        message.updateParticleShouldDraw,
      );
    }
    if (message.updateParticleSetFrozen !== undefined) {
      obj.updateParticleSetFrozen = CUserMsgParticleManager_UpdateParticleSetFrozen.toJSON(
        message.updateParticleSetFrozen,
      );
    }
    if (message.changeControlPointAttachment !== undefined) {
      obj.changeControlPointAttachment = CUserMsgParticleManager_ChangeControlPointAttachment.toJSON(
        message.changeControlPointAttachment,
      );
    }
    if (message.updateEntityPosition !== undefined) {
      obj.updateEntityPosition = CUserMsgParticleManager_UpdateEntityPosition.toJSON(message.updateEntityPosition);
    }
    if (message.setParticleFowProperties !== undefined) {
      obj.setParticleFowProperties = CUserMsgParticleManager_SetParticleFoWProperties.toJSON(
        message.setParticleFowProperties,
      );
    }
    if (message.setParticleText !== undefined) {
      obj.setParticleText = CUserMsgParticleManager_SetParticleText.toJSON(message.setParticleText);
    }
    if (message.setParticleShouldCheckFow !== undefined) {
      obj.setParticleShouldCheckFow = CUserMsgParticleManager_SetParticleShouldCheckFoW.toJSON(
        message.setParticleShouldCheckFow,
      );
    }
    if (message.setControlPointModel !== undefined) {
      obj.setControlPointModel = CUserMsgParticleManager_SetControlPointModel.toJSON(message.setControlPointModel);
    }
    if (message.setControlPointSnapshot !== undefined) {
      obj.setControlPointSnapshot = CUserMsgParticleManager_SetControlPointSnapshot.toJSON(
        message.setControlPointSnapshot,
      );
    }
    if (message.setTextureAttribute !== undefined) {
      obj.setTextureAttribute = CUserMsgParticleManager_SetTextureAttribute.toJSON(message.setTextureAttribute);
    }
    if (message.setSceneObjectGenericFlag !== undefined) {
      obj.setSceneObjectGenericFlag = CUserMsgParticleManager_SetSceneObjectGenericFlag.toJSON(
        message.setSceneObjectGenericFlag,
      );
    }
    if (message.setSceneObjectTintAndDesat !== undefined) {
      obj.setSceneObjectTintAndDesat = CUserMsgParticleManager_SetSceneObjectTintAndDesat.toJSON(
        message.setSceneObjectTintAndDesat,
      );
    }
    if (message.destroyParticleNamed !== undefined) {
      obj.destroyParticleNamed = CUserMsgParticleManager_DestroyParticleNamed.toJSON(message.destroyParticleNamed);
    }
    if (message.particleSkipToTime !== undefined) {
      obj.particleSkipToTime = CUserMsgParticleManager_ParticleSkipToTime.toJSON(message.particleSkipToTime);
    }
    if (message.particleCanFreeze !== undefined) {
      obj.particleCanFreeze = CUserMsgParticleManager_ParticleCanFreeze.toJSON(message.particleCanFreeze);
    }
    if (message.setNamedValueContext !== undefined) {
      obj.setNamedValueContext = CUserMsgParticleManager_SetParticleNamedValueContext.toJSON(
        message.setNamedValueContext,
      );
    }
    if (message.updateParticleTransform !== undefined) {
      obj.updateParticleTransform = CUserMsgParticleManager_UpdateParticleTransform.toJSON(
        message.updateParticleTransform,
      );
    }
    if (message.particleFreezeTransitionOverride !== undefined) {
      obj.particleFreezeTransitionOverride = CUserMsgParticleManager_ParticleFreezeTransitionOverride.toJSON(
        message.particleFreezeTransitionOverride,
      );
    }
    if (message.freezeParticleInvolving !== undefined) {
      obj.freezeParticleInvolving = CUserMsgParticleManager_FreezeParticleInvolving.toJSON(
        message.freezeParticleInvolving,
      );
    }
    if (message.addModellistOverrideElement !== undefined) {
      obj.addModellistOverrideElement = CUserMsgParticleManager_AddModellistOverrideElement.toJSON(
        message.addModellistOverrideElement,
      );
    }
    if (message.clearModellistOverride !== undefined) {
      obj.clearModellistOverride = CUserMsgParticleManager_ClearModellistOverride.toJSON(
        message.clearModellistOverride,
      );
    }
    if (message.createPhysicsSim !== undefined) {
      obj.createPhysicsSim = CUserMsgParticleManager_CreatePhysicsSim.toJSON(message.createPhysicsSim);
    }
    if (message.destroyPhysicsSim !== undefined) {
      obj.destroyPhysicsSim = CUserMsgParticleManager_DestroyPhysicsSim.toJSON(message.destroyPhysicsSim);
    }
    return obj;
  },

  create(base?: DeepPartial<CUserMsgParticleManager>): CUserMsgParticleManager {
    return CUserMsgParticleManager.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CUserMsgParticleManager>): CUserMsgParticleManager {
    const message = createBaseCUserMsgParticleManager();
    message.type = object.type ?? 0;
    message.index = object.index ?? 0;
    message.releaseParticleIndex =
      object.releaseParticleIndex !== undefined && object.releaseParticleIndex !== null
        ? CUserMsgParticleManager_ReleaseParticleIndex.fromPartial(object.releaseParticleIndex)
        : undefined;
    message.createParticle =
      object.createParticle !== undefined && object.createParticle !== null
        ? CUserMsgParticleManager_CreateParticle.fromPartial(object.createParticle)
        : undefined;
    message.destroyParticle =
      object.destroyParticle !== undefined && object.destroyParticle !== null
        ? CUserMsgParticleManager_DestroyParticle.fromPartial(object.destroyParticle)
        : undefined;
    message.destroyParticleInvolving =
      object.destroyParticleInvolving !== undefined && object.destroyParticleInvolving !== null
        ? CUserMsgParticleManager_DestroyParticleInvolving.fromPartial(object.destroyParticleInvolving)
        : undefined;
    message.updateParticle =
      object.updateParticle !== undefined && object.updateParticle !== null
        ? CUserMsgParticleManager_UpdateParticleOBSOLETE.fromPartial(object.updateParticle)
        : undefined;
    message.updateParticleFwd =
      object.updateParticleFwd !== undefined && object.updateParticleFwd !== null
        ? CUserMsgParticleManager_UpdateParticleFwdOBSOLETE.fromPartial(object.updateParticleFwd)
        : undefined;
    message.updateParticleOrient =
      object.updateParticleOrient !== undefined && object.updateParticleOrient !== null
        ? CUserMsgParticleManager_UpdateParticleOrientOBSOLETE.fromPartial(object.updateParticleOrient)
        : undefined;
    message.updateParticleFallback =
      object.updateParticleFallback !== undefined && object.updateParticleFallback !== null
        ? CUserMsgParticleManager_UpdateParticleFallback.fromPartial(object.updateParticleFallback)
        : undefined;
    message.updateParticleOffset =
      object.updateParticleOffset !== undefined && object.updateParticleOffset !== null
        ? CUserMsgParticleManager_UpdateParticleOffset.fromPartial(object.updateParticleOffset)
        : undefined;
    message.updateParticleEnt =
      object.updateParticleEnt !== undefined && object.updateParticleEnt !== null
        ? CUserMsgParticleManager_UpdateParticleEnt.fromPartial(object.updateParticleEnt)
        : undefined;
    message.updateParticleShouldDraw =
      object.updateParticleShouldDraw !== undefined && object.updateParticleShouldDraw !== null
        ? CUserMsgParticleManager_UpdateParticleShouldDraw.fromPartial(object.updateParticleShouldDraw)
        : undefined;
    message.updateParticleSetFrozen =
      object.updateParticleSetFrozen !== undefined && object.updateParticleSetFrozen !== null
        ? CUserMsgParticleManager_UpdateParticleSetFrozen.fromPartial(object.updateParticleSetFrozen)
        : undefined;
    message.changeControlPointAttachment =
      object.changeControlPointAttachment !== undefined && object.changeControlPointAttachment !== null
        ? CUserMsgParticleManager_ChangeControlPointAttachment.fromPartial(object.changeControlPointAttachment)
        : undefined;
    message.updateEntityPosition =
      object.updateEntityPosition !== undefined && object.updateEntityPosition !== null
        ? CUserMsgParticleManager_UpdateEntityPosition.fromPartial(object.updateEntityPosition)
        : undefined;
    message.setParticleFowProperties =
      object.setParticleFowProperties !== undefined && object.setParticleFowProperties !== null
        ? CUserMsgParticleManager_SetParticleFoWProperties.fromPartial(object.setParticleFowProperties)
        : undefined;
    message.setParticleText =
      object.setParticleText !== undefined && object.setParticleText !== null
        ? CUserMsgParticleManager_SetParticleText.fromPartial(object.setParticleText)
        : undefined;
    message.setParticleShouldCheckFow =
      object.setParticleShouldCheckFow !== undefined && object.setParticleShouldCheckFow !== null
        ? CUserMsgParticleManager_SetParticleShouldCheckFoW.fromPartial(object.setParticleShouldCheckFow)
        : undefined;
    message.setControlPointModel =
      object.setControlPointModel !== undefined && object.setControlPointModel !== null
        ? CUserMsgParticleManager_SetControlPointModel.fromPartial(object.setControlPointModel)
        : undefined;
    message.setControlPointSnapshot =
      object.setControlPointSnapshot !== undefined && object.setControlPointSnapshot !== null
        ? CUserMsgParticleManager_SetControlPointSnapshot.fromPartial(object.setControlPointSnapshot)
        : undefined;
    message.setTextureAttribute =
      object.setTextureAttribute !== undefined && object.setTextureAttribute !== null
        ? CUserMsgParticleManager_SetTextureAttribute.fromPartial(object.setTextureAttribute)
        : undefined;
    message.setSceneObjectGenericFlag =
      object.setSceneObjectGenericFlag !== undefined && object.setSceneObjectGenericFlag !== null
        ? CUserMsgParticleManager_SetSceneObjectGenericFlag.fromPartial(object.setSceneObjectGenericFlag)
        : undefined;
    message.setSceneObjectTintAndDesat =
      object.setSceneObjectTintAndDesat !== undefined && object.setSceneObjectTintAndDesat !== null
        ? CUserMsgParticleManager_SetSceneObjectTintAndDesat.fromPartial(object.setSceneObjectTintAndDesat)
        : undefined;
    message.destroyParticleNamed =
      object.destroyParticleNamed !== undefined && object.destroyParticleNamed !== null
        ? CUserMsgParticleManager_DestroyParticleNamed.fromPartial(object.destroyParticleNamed)
        : undefined;
    message.particleSkipToTime =
      object.particleSkipToTime !== undefined && object.particleSkipToTime !== null
        ? CUserMsgParticleManager_ParticleSkipToTime.fromPartial(object.particleSkipToTime)
        : undefined;
    message.particleCanFreeze =
      object.particleCanFreeze !== undefined && object.particleCanFreeze !== null
        ? CUserMsgParticleManager_ParticleCanFreeze.fromPartial(object.particleCanFreeze)
        : undefined;
    message.setNamedValueContext =
      object.setNamedValueContext !== undefined && object.setNamedValueContext !== null
        ? CUserMsgParticleManager_SetParticleNamedValueContext.fromPartial(object.setNamedValueContext)
        : undefined;
    message.updateParticleTransform =
      object.updateParticleTransform !== undefined && object.updateParticleTransform !== null
        ? CUserMsgParticleManager_UpdateParticleTransform.fromPartial(object.updateParticleTransform)
        : undefined;
    message.particleFreezeTransitionOverride =
      object.particleFreezeTransitionOverride !== undefined && object.particleFreezeTransitionOverride !== null
        ? CUserMsgParticleManager_ParticleFreezeTransitionOverride.fromPartial(object.particleFreezeTransitionOverride)
        : undefined;
    message.freezeParticleInvolving =
      object.freezeParticleInvolving !== undefined && object.freezeParticleInvolving !== null
        ? CUserMsgParticleManager_FreezeParticleInvolving.fromPartial(object.freezeParticleInvolving)
        : undefined;
    message.addModellistOverrideElement =
      object.addModellistOverrideElement !== undefined && object.addModellistOverrideElement !== null
        ? CUserMsgParticleManager_AddModellistOverrideElement.fromPartial(object.addModellistOverrideElement)
        : undefined;
    message.clearModellistOverride =
      object.clearModellistOverride !== undefined && object.clearModellistOverride !== null
        ? CUserMsgParticleManager_ClearModellistOverride.fromPartial(object.clearModellistOverride)
        : undefined;
    message.createPhysicsSim =
      object.createPhysicsSim !== undefined && object.createPhysicsSim !== null
        ? CUserMsgParticleManager_CreatePhysicsSim.fromPartial(object.createPhysicsSim)
        : undefined;
    message.destroyPhysicsSim =
      object.destroyPhysicsSim !== undefined && object.destroyPhysicsSim !== null
        ? CUserMsgParticleManager_DestroyPhysicsSim.fromPartial(object.destroyPhysicsSim)
        : undefined;
    return message;
  },
};

function createBaseCUserMsgParticleManager_ReleaseParticleIndex(): CUserMsgParticleManager_ReleaseParticleIndex {
  return {};
}

export const CUserMsgParticleManager_ReleaseParticleIndex = {
  encode(_: CUserMsgParticleManager_ReleaseParticleIndex, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CUserMsgParticleManager_ReleaseParticleIndex {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCUserMsgParticleManager_ReleaseParticleIndex();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CUserMsgParticleManager_ReleaseParticleIndex {
    return {};
  },

  toJSON(_: CUserMsgParticleManager_ReleaseParticleIndex): unknown {
    const obj: any = {};
    return obj;
  },

  create(
    base?: DeepPartial<CUserMsgParticleManager_ReleaseParticleIndex>,
  ): CUserMsgParticleManager_ReleaseParticleIndex {
    return CUserMsgParticleManager_ReleaseParticleIndex.fromPartial(base ?? {});
  },
  fromPartial(
    _: DeepPartial<CUserMsgParticleManager_ReleaseParticleIndex>,
  ): CUserMsgParticleManager_ReleaseParticleIndex {
    const message = createBaseCUserMsgParticleManager_ReleaseParticleIndex();
    return message;
  },
};

function createBaseCUserMsgParticleManager_CreateParticle(): CUserMsgParticleManager_CreateParticle {
  return {
    particleNameIndex: "0",
    attachType: 0,
    entityHandle: 16777215,
    entityHandleForModifiers: 16777215,
    applyVoiceBanRules: false,
    teamBehavior: 0,
    controlPointConfiguration: "",
    cluster: false,
    endcapTime: 0,
  };
}

export const CUserMsgParticleManager_CreateParticle = {
  encode(message: CUserMsgParticleManager_CreateParticle, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.particleNameIndex !== undefined && message.particleNameIndex !== "0") {
      writer.uint32(9).fixed64(message.particleNameIndex);
    }
    if (message.attachType !== undefined && message.attachType !== 0) {
      writer.uint32(16).int32(message.attachType);
    }
    if (message.entityHandle !== undefined && message.entityHandle !== 16777215) {
      writer.uint32(24).uint32(message.entityHandle);
    }
    if (message.entityHandleForModifiers !== undefined && message.entityHandleForModifiers !== 16777215) {
      writer.uint32(32).uint32(message.entityHandleForModifiers);
    }
    if (message.applyVoiceBanRules !== undefined && message.applyVoiceBanRules !== false) {
      writer.uint32(40).bool(message.applyVoiceBanRules);
    }
    if (message.teamBehavior !== undefined && message.teamBehavior !== 0) {
      writer.uint32(48).int32(message.teamBehavior);
    }
    if (message.controlPointConfiguration !== undefined && message.controlPointConfiguration !== "") {
      writer.uint32(58).string(message.controlPointConfiguration);
    }
    if (message.cluster !== undefined && message.cluster !== false) {
      writer.uint32(64).bool(message.cluster);
    }
    if (message.endcapTime !== undefined && message.endcapTime !== 0) {
      writer.uint32(77).float(message.endcapTime);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CUserMsgParticleManager_CreateParticle {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCUserMsgParticleManager_CreateParticle();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.particleNameIndex = longToString(reader.fixed64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.attachType = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.entityHandle = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.entityHandleForModifiers = reader.uint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.applyVoiceBanRules = reader.bool();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.teamBehavior = reader.int32();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.controlPointConfiguration = reader.string();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.cluster = reader.bool();
          continue;
        case 9:
          if (tag !== 77) {
            break;
          }

          message.endcapTime = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CUserMsgParticleManager_CreateParticle {
    return {
      particleNameIndex: isSet(object.particleNameIndex) ? globalThis.String(object.particleNameIndex) : "0",
      attachType: isSet(object.attachType) ? globalThis.Number(object.attachType) : 0,
      entityHandle: isSet(object.entityHandle) ? globalThis.Number(object.entityHandle) : 16777215,
      entityHandleForModifiers: isSet(object.entityHandleForModifiers)
        ? globalThis.Number(object.entityHandleForModifiers)
        : 16777215,
      applyVoiceBanRules: isSet(object.applyVoiceBanRules) ? globalThis.Boolean(object.applyVoiceBanRules) : false,
      teamBehavior: isSet(object.teamBehavior) ? globalThis.Number(object.teamBehavior) : 0,
      controlPointConfiguration: isSet(object.controlPointConfiguration)
        ? globalThis.String(object.controlPointConfiguration)
        : "",
      cluster: isSet(object.cluster) ? globalThis.Boolean(object.cluster) : false,
      endcapTime: isSet(object.endcapTime) ? globalThis.Number(object.endcapTime) : 0,
    };
  },

  toJSON(message: CUserMsgParticleManager_CreateParticle): unknown {
    const obj: any = {};
    if (message.particleNameIndex !== undefined && message.particleNameIndex !== "0") {
      obj.particleNameIndex = message.particleNameIndex;
    }
    if (message.attachType !== undefined && message.attachType !== 0) {
      obj.attachType = Math.round(message.attachType);
    }
    if (message.entityHandle !== undefined && message.entityHandle !== 16777215) {
      obj.entityHandle = Math.round(message.entityHandle);
    }
    if (message.entityHandleForModifiers !== undefined && message.entityHandleForModifiers !== 16777215) {
      obj.entityHandleForModifiers = Math.round(message.entityHandleForModifiers);
    }
    if (message.applyVoiceBanRules !== undefined && message.applyVoiceBanRules !== false) {
      obj.applyVoiceBanRules = message.applyVoiceBanRules;
    }
    if (message.teamBehavior !== undefined && message.teamBehavior !== 0) {
      obj.teamBehavior = Math.round(message.teamBehavior);
    }
    if (message.controlPointConfiguration !== undefined && message.controlPointConfiguration !== "") {
      obj.controlPointConfiguration = message.controlPointConfiguration;
    }
    if (message.cluster !== undefined && message.cluster !== false) {
      obj.cluster = message.cluster;
    }
    if (message.endcapTime !== undefined && message.endcapTime !== 0) {
      obj.endcapTime = message.endcapTime;
    }
    return obj;
  },

  create(base?: DeepPartial<CUserMsgParticleManager_CreateParticle>): CUserMsgParticleManager_CreateParticle {
    return CUserMsgParticleManager_CreateParticle.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CUserMsgParticleManager_CreateParticle>): CUserMsgParticleManager_CreateParticle {
    const message = createBaseCUserMsgParticleManager_CreateParticle();
    message.particleNameIndex = object.particleNameIndex ?? "0";
    message.attachType = object.attachType ?? 0;
    message.entityHandle = object.entityHandle ?? 16777215;
    message.entityHandleForModifiers = object.entityHandleForModifiers ?? 16777215;
    message.applyVoiceBanRules = object.applyVoiceBanRules ?? false;
    message.teamBehavior = object.teamBehavior ?? 0;
    message.controlPointConfiguration = object.controlPointConfiguration ?? "";
    message.cluster = object.cluster ?? false;
    message.endcapTime = object.endcapTime ?? 0;
    return message;
  },
};

function createBaseCUserMsgParticleManager_DestroyParticle(): CUserMsgParticleManager_DestroyParticle {
  return { destroyImmediately: false };
}

export const CUserMsgParticleManager_DestroyParticle = {
  encode(message: CUserMsgParticleManager_DestroyParticle, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.destroyImmediately !== undefined && message.destroyImmediately !== false) {
      writer.uint32(8).bool(message.destroyImmediately);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CUserMsgParticleManager_DestroyParticle {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCUserMsgParticleManager_DestroyParticle();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.destroyImmediately = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CUserMsgParticleManager_DestroyParticle {
    return {
      destroyImmediately: isSet(object.destroyImmediately) ? globalThis.Boolean(object.destroyImmediately) : false,
    };
  },

  toJSON(message: CUserMsgParticleManager_DestroyParticle): unknown {
    const obj: any = {};
    if (message.destroyImmediately !== undefined && message.destroyImmediately !== false) {
      obj.destroyImmediately = message.destroyImmediately;
    }
    return obj;
  },

  create(base?: DeepPartial<CUserMsgParticleManager_DestroyParticle>): CUserMsgParticleManager_DestroyParticle {
    return CUserMsgParticleManager_DestroyParticle.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CUserMsgParticleManager_DestroyParticle>): CUserMsgParticleManager_DestroyParticle {
    const message = createBaseCUserMsgParticleManager_DestroyParticle();
    message.destroyImmediately = object.destroyImmediately ?? false;
    return message;
  },
};

function createBaseCUserMsgParticleManager_DestroyParticleInvolving(): CUserMsgParticleManager_DestroyParticleInvolving {
  return { destroyImmediately: false, entityHandle: 16777215 };
}

export const CUserMsgParticleManager_DestroyParticleInvolving = {
  encode(
    message: CUserMsgParticleManager_DestroyParticleInvolving,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.destroyImmediately !== undefined && message.destroyImmediately !== false) {
      writer.uint32(8).bool(message.destroyImmediately);
    }
    if (message.entityHandle !== undefined && message.entityHandle !== 16777215) {
      writer.uint32(24).uint32(message.entityHandle);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CUserMsgParticleManager_DestroyParticleInvolving {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCUserMsgParticleManager_DestroyParticleInvolving();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.destroyImmediately = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.entityHandle = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CUserMsgParticleManager_DestroyParticleInvolving {
    return {
      destroyImmediately: isSet(object.destroyImmediately) ? globalThis.Boolean(object.destroyImmediately) : false,
      entityHandle: isSet(object.entityHandle) ? globalThis.Number(object.entityHandle) : 16777215,
    };
  },

  toJSON(message: CUserMsgParticleManager_DestroyParticleInvolving): unknown {
    const obj: any = {};
    if (message.destroyImmediately !== undefined && message.destroyImmediately !== false) {
      obj.destroyImmediately = message.destroyImmediately;
    }
    if (message.entityHandle !== undefined && message.entityHandle !== 16777215) {
      obj.entityHandle = Math.round(message.entityHandle);
    }
    return obj;
  },

  create(
    base?: DeepPartial<CUserMsgParticleManager_DestroyParticleInvolving>,
  ): CUserMsgParticleManager_DestroyParticleInvolving {
    return CUserMsgParticleManager_DestroyParticleInvolving.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CUserMsgParticleManager_DestroyParticleInvolving>,
  ): CUserMsgParticleManager_DestroyParticleInvolving {
    const message = createBaseCUserMsgParticleManager_DestroyParticleInvolving();
    message.destroyImmediately = object.destroyImmediately ?? false;
    message.entityHandle = object.entityHandle ?? 16777215;
    return message;
  },
};

function createBaseCUserMsgParticleManager_DestroyParticleNamed(): CUserMsgParticleManager_DestroyParticleNamed {
  return { particleNameIndex: "0", entityHandle: 16777215, destroyImmediately: false, playEndcap: false };
}

export const CUserMsgParticleManager_DestroyParticleNamed = {
  encode(message: CUserMsgParticleManager_DestroyParticleNamed, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.particleNameIndex !== undefined && message.particleNameIndex !== "0") {
      writer.uint32(9).fixed64(message.particleNameIndex);
    }
    if (message.entityHandle !== undefined && message.entityHandle !== 16777215) {
      writer.uint32(16).uint32(message.entityHandle);
    }
    if (message.destroyImmediately !== undefined && message.destroyImmediately !== false) {
      writer.uint32(24).bool(message.destroyImmediately);
    }
    if (message.playEndcap !== undefined && message.playEndcap !== false) {
      writer.uint32(32).bool(message.playEndcap);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CUserMsgParticleManager_DestroyParticleNamed {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCUserMsgParticleManager_DestroyParticleNamed();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.particleNameIndex = longToString(reader.fixed64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.entityHandle = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.destroyImmediately = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.playEndcap = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CUserMsgParticleManager_DestroyParticleNamed {
    return {
      particleNameIndex: isSet(object.particleNameIndex) ? globalThis.String(object.particleNameIndex) : "0",
      entityHandle: isSet(object.entityHandle) ? globalThis.Number(object.entityHandle) : 16777215,
      destroyImmediately: isSet(object.destroyImmediately) ? globalThis.Boolean(object.destroyImmediately) : false,
      playEndcap: isSet(object.playEndcap) ? globalThis.Boolean(object.playEndcap) : false,
    };
  },

  toJSON(message: CUserMsgParticleManager_DestroyParticleNamed): unknown {
    const obj: any = {};
    if (message.particleNameIndex !== undefined && message.particleNameIndex !== "0") {
      obj.particleNameIndex = message.particleNameIndex;
    }
    if (message.entityHandle !== undefined && message.entityHandle !== 16777215) {
      obj.entityHandle = Math.round(message.entityHandle);
    }
    if (message.destroyImmediately !== undefined && message.destroyImmediately !== false) {
      obj.destroyImmediately = message.destroyImmediately;
    }
    if (message.playEndcap !== undefined && message.playEndcap !== false) {
      obj.playEndcap = message.playEndcap;
    }
    return obj;
  },

  create(
    base?: DeepPartial<CUserMsgParticleManager_DestroyParticleNamed>,
  ): CUserMsgParticleManager_DestroyParticleNamed {
    return CUserMsgParticleManager_DestroyParticleNamed.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CUserMsgParticleManager_DestroyParticleNamed>,
  ): CUserMsgParticleManager_DestroyParticleNamed {
    const message = createBaseCUserMsgParticleManager_DestroyParticleNamed();
    message.particleNameIndex = object.particleNameIndex ?? "0";
    message.entityHandle = object.entityHandle ?? 16777215;
    message.destroyImmediately = object.destroyImmediately ?? false;
    message.playEndcap = object.playEndcap ?? false;
    return message;
  },
};

function createBaseCUserMsgParticleManager_UpdateParticleOBSOLETE(): CUserMsgParticleManager_UpdateParticleOBSOLETE {
  return { controlPoint: 0, position: undefined };
}

export const CUserMsgParticleManager_UpdateParticleOBSOLETE = {
  encode(
    message: CUserMsgParticleManager_UpdateParticleOBSOLETE,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.controlPoint !== undefined && message.controlPoint !== 0) {
      writer.uint32(8).int32(message.controlPoint);
    }
    if (message.position !== undefined) {
      CMsgVector.encode(message.position, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CUserMsgParticleManager_UpdateParticleOBSOLETE {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCUserMsgParticleManager_UpdateParticleOBSOLETE();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.controlPoint = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.position = CMsgVector.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CUserMsgParticleManager_UpdateParticleOBSOLETE {
    return {
      controlPoint: isSet(object.controlPoint) ? globalThis.Number(object.controlPoint) : 0,
      position: isSet(object.position) ? CMsgVector.fromJSON(object.position) : undefined,
    };
  },

  toJSON(message: CUserMsgParticleManager_UpdateParticleOBSOLETE): unknown {
    const obj: any = {};
    if (message.controlPoint !== undefined && message.controlPoint !== 0) {
      obj.controlPoint = Math.round(message.controlPoint);
    }
    if (message.position !== undefined) {
      obj.position = CMsgVector.toJSON(message.position);
    }
    return obj;
  },

  create(
    base?: DeepPartial<CUserMsgParticleManager_UpdateParticleOBSOLETE>,
  ): CUserMsgParticleManager_UpdateParticleOBSOLETE {
    return CUserMsgParticleManager_UpdateParticleOBSOLETE.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CUserMsgParticleManager_UpdateParticleOBSOLETE>,
  ): CUserMsgParticleManager_UpdateParticleOBSOLETE {
    const message = createBaseCUserMsgParticleManager_UpdateParticleOBSOLETE();
    message.controlPoint = object.controlPoint ?? 0;
    message.position =
      object.position !== undefined && object.position !== null ? CMsgVector.fromPartial(object.position) : undefined;
    return message;
  },
};

function createBaseCUserMsgParticleManager_UpdateParticleFwdOBSOLETE(): CUserMsgParticleManager_UpdateParticleFwdOBSOLETE {
  return { controlPoint: 0, forward: undefined };
}

export const CUserMsgParticleManager_UpdateParticleFwdOBSOLETE = {
  encode(
    message: CUserMsgParticleManager_UpdateParticleFwdOBSOLETE,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.controlPoint !== undefined && message.controlPoint !== 0) {
      writer.uint32(8).int32(message.controlPoint);
    }
    if (message.forward !== undefined) {
      CMsgVector.encode(message.forward, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CUserMsgParticleManager_UpdateParticleFwdOBSOLETE {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCUserMsgParticleManager_UpdateParticleFwdOBSOLETE();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.controlPoint = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.forward = CMsgVector.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CUserMsgParticleManager_UpdateParticleFwdOBSOLETE {
    return {
      controlPoint: isSet(object.controlPoint) ? globalThis.Number(object.controlPoint) : 0,
      forward: isSet(object.forward) ? CMsgVector.fromJSON(object.forward) : undefined,
    };
  },

  toJSON(message: CUserMsgParticleManager_UpdateParticleFwdOBSOLETE): unknown {
    const obj: any = {};
    if (message.controlPoint !== undefined && message.controlPoint !== 0) {
      obj.controlPoint = Math.round(message.controlPoint);
    }
    if (message.forward !== undefined) {
      obj.forward = CMsgVector.toJSON(message.forward);
    }
    return obj;
  },

  create(
    base?: DeepPartial<CUserMsgParticleManager_UpdateParticleFwdOBSOLETE>,
  ): CUserMsgParticleManager_UpdateParticleFwdOBSOLETE {
    return CUserMsgParticleManager_UpdateParticleFwdOBSOLETE.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CUserMsgParticleManager_UpdateParticleFwdOBSOLETE>,
  ): CUserMsgParticleManager_UpdateParticleFwdOBSOLETE {
    const message = createBaseCUserMsgParticleManager_UpdateParticleFwdOBSOLETE();
    message.controlPoint = object.controlPoint ?? 0;
    message.forward =
      object.forward !== undefined && object.forward !== null ? CMsgVector.fromPartial(object.forward) : undefined;
    return message;
  },
};

function createBaseCUserMsgParticleManager_UpdateParticleOrientOBSOLETE(): CUserMsgParticleManager_UpdateParticleOrientOBSOLETE {
  return { controlPoint: 0, forward: undefined, deprecatedRight: undefined, up: undefined, left: undefined };
}

export const CUserMsgParticleManager_UpdateParticleOrientOBSOLETE = {
  encode(
    message: CUserMsgParticleManager_UpdateParticleOrientOBSOLETE,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.controlPoint !== undefined && message.controlPoint !== 0) {
      writer.uint32(8).int32(message.controlPoint);
    }
    if (message.forward !== undefined) {
      CMsgVector.encode(message.forward, writer.uint32(18).fork()).ldelim();
    }
    if (message.deprecatedRight !== undefined) {
      CMsgVector.encode(message.deprecatedRight, writer.uint32(26).fork()).ldelim();
    }
    if (message.up !== undefined) {
      CMsgVector.encode(message.up, writer.uint32(34).fork()).ldelim();
    }
    if (message.left !== undefined) {
      CMsgVector.encode(message.left, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CUserMsgParticleManager_UpdateParticleOrientOBSOLETE {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCUserMsgParticleManager_UpdateParticleOrientOBSOLETE();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.controlPoint = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.forward = CMsgVector.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.deprecatedRight = CMsgVector.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.up = CMsgVector.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.left = CMsgVector.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CUserMsgParticleManager_UpdateParticleOrientOBSOLETE {
    return {
      controlPoint: isSet(object.controlPoint) ? globalThis.Number(object.controlPoint) : 0,
      forward: isSet(object.forward) ? CMsgVector.fromJSON(object.forward) : undefined,
      deprecatedRight: isSet(object.deprecatedRight) ? CMsgVector.fromJSON(object.deprecatedRight) : undefined,
      up: isSet(object.up) ? CMsgVector.fromJSON(object.up) : undefined,
      left: isSet(object.left) ? CMsgVector.fromJSON(object.left) : undefined,
    };
  },

  toJSON(message: CUserMsgParticleManager_UpdateParticleOrientOBSOLETE): unknown {
    const obj: any = {};
    if (message.controlPoint !== undefined && message.controlPoint !== 0) {
      obj.controlPoint = Math.round(message.controlPoint);
    }
    if (message.forward !== undefined) {
      obj.forward = CMsgVector.toJSON(message.forward);
    }
    if (message.deprecatedRight !== undefined) {
      obj.deprecatedRight = CMsgVector.toJSON(message.deprecatedRight);
    }
    if (message.up !== undefined) {
      obj.up = CMsgVector.toJSON(message.up);
    }
    if (message.left !== undefined) {
      obj.left = CMsgVector.toJSON(message.left);
    }
    return obj;
  },

  create(
    base?: DeepPartial<CUserMsgParticleManager_UpdateParticleOrientOBSOLETE>,
  ): CUserMsgParticleManager_UpdateParticleOrientOBSOLETE {
    return CUserMsgParticleManager_UpdateParticleOrientOBSOLETE.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CUserMsgParticleManager_UpdateParticleOrientOBSOLETE>,
  ): CUserMsgParticleManager_UpdateParticleOrientOBSOLETE {
    const message = createBaseCUserMsgParticleManager_UpdateParticleOrientOBSOLETE();
    message.controlPoint = object.controlPoint ?? 0;
    message.forward =
      object.forward !== undefined && object.forward !== null ? CMsgVector.fromPartial(object.forward) : undefined;
    message.deprecatedRight =
      object.deprecatedRight !== undefined && object.deprecatedRight !== null
        ? CMsgVector.fromPartial(object.deprecatedRight)
        : undefined;
    message.up = object.up !== undefined && object.up !== null ? CMsgVector.fromPartial(object.up) : undefined;
    message.left = object.left !== undefined && object.left !== null ? CMsgVector.fromPartial(object.left) : undefined;
    return message;
  },
};

function createBaseCUserMsgParticleManager_UpdateParticleTransform(): CUserMsgParticleManager_UpdateParticleTransform {
  return { controlPoint: 0, position: undefined, orientation: undefined, interpolationInterval: 0 };
}

export const CUserMsgParticleManager_UpdateParticleTransform = {
  encode(
    message: CUserMsgParticleManager_UpdateParticleTransform,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.controlPoint !== undefined && message.controlPoint !== 0) {
      writer.uint32(8).int32(message.controlPoint);
    }
    if (message.position !== undefined) {
      CMsgVector.encode(message.position, writer.uint32(18).fork()).ldelim();
    }
    if (message.orientation !== undefined) {
      CMsgQuaternion.encode(message.orientation, writer.uint32(26).fork()).ldelim();
    }
    if (message.interpolationInterval !== undefined && message.interpolationInterval !== 0) {
      writer.uint32(37).float(message.interpolationInterval);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CUserMsgParticleManager_UpdateParticleTransform {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCUserMsgParticleManager_UpdateParticleTransform();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.controlPoint = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.position = CMsgVector.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.orientation = CMsgQuaternion.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 37) {
            break;
          }

          message.interpolationInterval = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CUserMsgParticleManager_UpdateParticleTransform {
    return {
      controlPoint: isSet(object.controlPoint) ? globalThis.Number(object.controlPoint) : 0,
      position: isSet(object.position) ? CMsgVector.fromJSON(object.position) : undefined,
      orientation: isSet(object.orientation) ? CMsgQuaternion.fromJSON(object.orientation) : undefined,
      interpolationInterval: isSet(object.interpolationInterval) ? globalThis.Number(object.interpolationInterval) : 0,
    };
  },

  toJSON(message: CUserMsgParticleManager_UpdateParticleTransform): unknown {
    const obj: any = {};
    if (message.controlPoint !== undefined && message.controlPoint !== 0) {
      obj.controlPoint = Math.round(message.controlPoint);
    }
    if (message.position !== undefined) {
      obj.position = CMsgVector.toJSON(message.position);
    }
    if (message.orientation !== undefined) {
      obj.orientation = CMsgQuaternion.toJSON(message.orientation);
    }
    if (message.interpolationInterval !== undefined && message.interpolationInterval !== 0) {
      obj.interpolationInterval = message.interpolationInterval;
    }
    return obj;
  },

  create(
    base?: DeepPartial<CUserMsgParticleManager_UpdateParticleTransform>,
  ): CUserMsgParticleManager_UpdateParticleTransform {
    return CUserMsgParticleManager_UpdateParticleTransform.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CUserMsgParticleManager_UpdateParticleTransform>,
  ): CUserMsgParticleManager_UpdateParticleTransform {
    const message = createBaseCUserMsgParticleManager_UpdateParticleTransform();
    message.controlPoint = object.controlPoint ?? 0;
    message.position =
      object.position !== undefined && object.position !== null ? CMsgVector.fromPartial(object.position) : undefined;
    message.orientation =
      object.orientation !== undefined && object.orientation !== null
        ? CMsgQuaternion.fromPartial(object.orientation)
        : undefined;
    message.interpolationInterval = object.interpolationInterval ?? 0;
    return message;
  },
};

function createBaseCUserMsgParticleManager_UpdateParticleFallback(): CUserMsgParticleManager_UpdateParticleFallback {
  return { controlPoint: 0, position: undefined };
}

export const CUserMsgParticleManager_UpdateParticleFallback = {
  encode(
    message: CUserMsgParticleManager_UpdateParticleFallback,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.controlPoint !== undefined && message.controlPoint !== 0) {
      writer.uint32(8).int32(message.controlPoint);
    }
    if (message.position !== undefined) {
      CMsgVector.encode(message.position, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CUserMsgParticleManager_UpdateParticleFallback {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCUserMsgParticleManager_UpdateParticleFallback();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.controlPoint = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.position = CMsgVector.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CUserMsgParticleManager_UpdateParticleFallback {
    return {
      controlPoint: isSet(object.controlPoint) ? globalThis.Number(object.controlPoint) : 0,
      position: isSet(object.position) ? CMsgVector.fromJSON(object.position) : undefined,
    };
  },

  toJSON(message: CUserMsgParticleManager_UpdateParticleFallback): unknown {
    const obj: any = {};
    if (message.controlPoint !== undefined && message.controlPoint !== 0) {
      obj.controlPoint = Math.round(message.controlPoint);
    }
    if (message.position !== undefined) {
      obj.position = CMsgVector.toJSON(message.position);
    }
    return obj;
  },

  create(
    base?: DeepPartial<CUserMsgParticleManager_UpdateParticleFallback>,
  ): CUserMsgParticleManager_UpdateParticleFallback {
    return CUserMsgParticleManager_UpdateParticleFallback.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CUserMsgParticleManager_UpdateParticleFallback>,
  ): CUserMsgParticleManager_UpdateParticleFallback {
    const message = createBaseCUserMsgParticleManager_UpdateParticleFallback();
    message.controlPoint = object.controlPoint ?? 0;
    message.position =
      object.position !== undefined && object.position !== null ? CMsgVector.fromPartial(object.position) : undefined;
    return message;
  },
};

function createBaseCUserMsgParticleManager_UpdateParticleOffset(): CUserMsgParticleManager_UpdateParticleOffset {
  return { controlPoint: 0, originOffset: undefined, angleOffset: undefined };
}

export const CUserMsgParticleManager_UpdateParticleOffset = {
  encode(message: CUserMsgParticleManager_UpdateParticleOffset, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.controlPoint !== undefined && message.controlPoint !== 0) {
      writer.uint32(8).int32(message.controlPoint);
    }
    if (message.originOffset !== undefined) {
      CMsgVector.encode(message.originOffset, writer.uint32(18).fork()).ldelim();
    }
    if (message.angleOffset !== undefined) {
      CMsgQAngle.encode(message.angleOffset, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CUserMsgParticleManager_UpdateParticleOffset {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCUserMsgParticleManager_UpdateParticleOffset();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.controlPoint = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.originOffset = CMsgVector.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.angleOffset = CMsgQAngle.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CUserMsgParticleManager_UpdateParticleOffset {
    return {
      controlPoint: isSet(object.controlPoint) ? globalThis.Number(object.controlPoint) : 0,
      originOffset: isSet(object.originOffset) ? CMsgVector.fromJSON(object.originOffset) : undefined,
      angleOffset: isSet(object.angleOffset) ? CMsgQAngle.fromJSON(object.angleOffset) : undefined,
    };
  },

  toJSON(message: CUserMsgParticleManager_UpdateParticleOffset): unknown {
    const obj: any = {};
    if (message.controlPoint !== undefined && message.controlPoint !== 0) {
      obj.controlPoint = Math.round(message.controlPoint);
    }
    if (message.originOffset !== undefined) {
      obj.originOffset = CMsgVector.toJSON(message.originOffset);
    }
    if (message.angleOffset !== undefined) {
      obj.angleOffset = CMsgQAngle.toJSON(message.angleOffset);
    }
    return obj;
  },

  create(
    base?: DeepPartial<CUserMsgParticleManager_UpdateParticleOffset>,
  ): CUserMsgParticleManager_UpdateParticleOffset {
    return CUserMsgParticleManager_UpdateParticleOffset.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CUserMsgParticleManager_UpdateParticleOffset>,
  ): CUserMsgParticleManager_UpdateParticleOffset {
    const message = createBaseCUserMsgParticleManager_UpdateParticleOffset();
    message.controlPoint = object.controlPoint ?? 0;
    message.originOffset =
      object.originOffset !== undefined && object.originOffset !== null
        ? CMsgVector.fromPartial(object.originOffset)
        : undefined;
    message.angleOffset =
      object.angleOffset !== undefined && object.angleOffset !== null
        ? CMsgQAngle.fromPartial(object.angleOffset)
        : undefined;
    return message;
  },
};

function createBaseCUserMsgParticleManager_UpdateParticleEnt(): CUserMsgParticleManager_UpdateParticleEnt {
  return {
    controlPoint: 0,
    entityHandle: 16777215,
    attachType: 0,
    attachment: 0,
    fallbackPosition: undefined,
    includeWearables: false,
    offsetPosition: undefined,
    offsetAngles: undefined,
  };
}

export const CUserMsgParticleManager_UpdateParticleEnt = {
  encode(message: CUserMsgParticleManager_UpdateParticleEnt, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.controlPoint !== undefined && message.controlPoint !== 0) {
      writer.uint32(8).int32(message.controlPoint);
    }
    if (message.entityHandle !== undefined && message.entityHandle !== 16777215) {
      writer.uint32(16).uint32(message.entityHandle);
    }
    if (message.attachType !== undefined && message.attachType !== 0) {
      writer.uint32(24).int32(message.attachType);
    }
    if (message.attachment !== undefined && message.attachment !== 0) {
      writer.uint32(32).int32(message.attachment);
    }
    if (message.fallbackPosition !== undefined) {
      CMsgVector.encode(message.fallbackPosition, writer.uint32(42).fork()).ldelim();
    }
    if (message.includeWearables !== undefined && message.includeWearables !== false) {
      writer.uint32(48).bool(message.includeWearables);
    }
    if (message.offsetPosition !== undefined) {
      CMsgVector.encode(message.offsetPosition, writer.uint32(58).fork()).ldelim();
    }
    if (message.offsetAngles !== undefined) {
      CMsgQAngle.encode(message.offsetAngles, writer.uint32(66).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CUserMsgParticleManager_UpdateParticleEnt {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCUserMsgParticleManager_UpdateParticleEnt();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.controlPoint = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.entityHandle = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.attachType = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.attachment = reader.int32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.fallbackPosition = CMsgVector.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.includeWearables = reader.bool();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.offsetPosition = CMsgVector.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.offsetAngles = CMsgQAngle.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CUserMsgParticleManager_UpdateParticleEnt {
    return {
      controlPoint: isSet(object.controlPoint) ? globalThis.Number(object.controlPoint) : 0,
      entityHandle: isSet(object.entityHandle) ? globalThis.Number(object.entityHandle) : 16777215,
      attachType: isSet(object.attachType) ? globalThis.Number(object.attachType) : 0,
      attachment: isSet(object.attachment) ? globalThis.Number(object.attachment) : 0,
      fallbackPosition: isSet(object.fallbackPosition) ? CMsgVector.fromJSON(object.fallbackPosition) : undefined,
      includeWearables: isSet(object.includeWearables) ? globalThis.Boolean(object.includeWearables) : false,
      offsetPosition: isSet(object.offsetPosition) ? CMsgVector.fromJSON(object.offsetPosition) : undefined,
      offsetAngles: isSet(object.offsetAngles) ? CMsgQAngle.fromJSON(object.offsetAngles) : undefined,
    };
  },

  toJSON(message: CUserMsgParticleManager_UpdateParticleEnt): unknown {
    const obj: any = {};
    if (message.controlPoint !== undefined && message.controlPoint !== 0) {
      obj.controlPoint = Math.round(message.controlPoint);
    }
    if (message.entityHandle !== undefined && message.entityHandle !== 16777215) {
      obj.entityHandle = Math.round(message.entityHandle);
    }
    if (message.attachType !== undefined && message.attachType !== 0) {
      obj.attachType = Math.round(message.attachType);
    }
    if (message.attachment !== undefined && message.attachment !== 0) {
      obj.attachment = Math.round(message.attachment);
    }
    if (message.fallbackPosition !== undefined) {
      obj.fallbackPosition = CMsgVector.toJSON(message.fallbackPosition);
    }
    if (message.includeWearables !== undefined && message.includeWearables !== false) {
      obj.includeWearables = message.includeWearables;
    }
    if (message.offsetPosition !== undefined) {
      obj.offsetPosition = CMsgVector.toJSON(message.offsetPosition);
    }
    if (message.offsetAngles !== undefined) {
      obj.offsetAngles = CMsgQAngle.toJSON(message.offsetAngles);
    }
    return obj;
  },

  create(base?: DeepPartial<CUserMsgParticleManager_UpdateParticleEnt>): CUserMsgParticleManager_UpdateParticleEnt {
    return CUserMsgParticleManager_UpdateParticleEnt.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CUserMsgParticleManager_UpdateParticleEnt>,
  ): CUserMsgParticleManager_UpdateParticleEnt {
    const message = createBaseCUserMsgParticleManager_UpdateParticleEnt();
    message.controlPoint = object.controlPoint ?? 0;
    message.entityHandle = object.entityHandle ?? 16777215;
    message.attachType = object.attachType ?? 0;
    message.attachment = object.attachment ?? 0;
    message.fallbackPosition =
      object.fallbackPosition !== undefined && object.fallbackPosition !== null
        ? CMsgVector.fromPartial(object.fallbackPosition)
        : undefined;
    message.includeWearables = object.includeWearables ?? false;
    message.offsetPosition =
      object.offsetPosition !== undefined && object.offsetPosition !== null
        ? CMsgVector.fromPartial(object.offsetPosition)
        : undefined;
    message.offsetAngles =
      object.offsetAngles !== undefined && object.offsetAngles !== null
        ? CMsgQAngle.fromPartial(object.offsetAngles)
        : undefined;
    return message;
  },
};

function createBaseCUserMsgParticleManager_UpdateParticleSetFrozen(): CUserMsgParticleManager_UpdateParticleSetFrozen {
  return { setFrozen: false, transitionDuration: 0 };
}

export const CUserMsgParticleManager_UpdateParticleSetFrozen = {
  encode(
    message: CUserMsgParticleManager_UpdateParticleSetFrozen,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.setFrozen !== undefined && message.setFrozen !== false) {
      writer.uint32(8).bool(message.setFrozen);
    }
    if (message.transitionDuration !== undefined && message.transitionDuration !== 0) {
      writer.uint32(21).float(message.transitionDuration);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CUserMsgParticleManager_UpdateParticleSetFrozen {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCUserMsgParticleManager_UpdateParticleSetFrozen();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.setFrozen = reader.bool();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.transitionDuration = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CUserMsgParticleManager_UpdateParticleSetFrozen {
    return {
      setFrozen: isSet(object.setFrozen) ? globalThis.Boolean(object.setFrozen) : false,
      transitionDuration: isSet(object.transitionDuration) ? globalThis.Number(object.transitionDuration) : 0,
    };
  },

  toJSON(message: CUserMsgParticleManager_UpdateParticleSetFrozen): unknown {
    const obj: any = {};
    if (message.setFrozen !== undefined && message.setFrozen !== false) {
      obj.setFrozen = message.setFrozen;
    }
    if (message.transitionDuration !== undefined && message.transitionDuration !== 0) {
      obj.transitionDuration = message.transitionDuration;
    }
    return obj;
  },

  create(
    base?: DeepPartial<CUserMsgParticleManager_UpdateParticleSetFrozen>,
  ): CUserMsgParticleManager_UpdateParticleSetFrozen {
    return CUserMsgParticleManager_UpdateParticleSetFrozen.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CUserMsgParticleManager_UpdateParticleSetFrozen>,
  ): CUserMsgParticleManager_UpdateParticleSetFrozen {
    const message = createBaseCUserMsgParticleManager_UpdateParticleSetFrozen();
    message.setFrozen = object.setFrozen ?? false;
    message.transitionDuration = object.transitionDuration ?? 0;
    return message;
  },
};

function createBaseCUserMsgParticleManager_UpdateParticleShouldDraw(): CUserMsgParticleManager_UpdateParticleShouldDraw {
  return { shouldDraw: false };
}

export const CUserMsgParticleManager_UpdateParticleShouldDraw = {
  encode(
    message: CUserMsgParticleManager_UpdateParticleShouldDraw,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.shouldDraw !== undefined && message.shouldDraw !== false) {
      writer.uint32(8).bool(message.shouldDraw);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CUserMsgParticleManager_UpdateParticleShouldDraw {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCUserMsgParticleManager_UpdateParticleShouldDraw();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.shouldDraw = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CUserMsgParticleManager_UpdateParticleShouldDraw {
    return { shouldDraw: isSet(object.shouldDraw) ? globalThis.Boolean(object.shouldDraw) : false };
  },

  toJSON(message: CUserMsgParticleManager_UpdateParticleShouldDraw): unknown {
    const obj: any = {};
    if (message.shouldDraw !== undefined && message.shouldDraw !== false) {
      obj.shouldDraw = message.shouldDraw;
    }
    return obj;
  },

  create(
    base?: DeepPartial<CUserMsgParticleManager_UpdateParticleShouldDraw>,
  ): CUserMsgParticleManager_UpdateParticleShouldDraw {
    return CUserMsgParticleManager_UpdateParticleShouldDraw.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CUserMsgParticleManager_UpdateParticleShouldDraw>,
  ): CUserMsgParticleManager_UpdateParticleShouldDraw {
    const message = createBaseCUserMsgParticleManager_UpdateParticleShouldDraw();
    message.shouldDraw = object.shouldDraw ?? false;
    return message;
  },
};

function createBaseCUserMsgParticleManager_ChangeControlPointAttachment(): CUserMsgParticleManager_ChangeControlPointAttachment {
  return { attachmentOld: 0, attachmentNew: 0, entityHandle: 16777215 };
}

export const CUserMsgParticleManager_ChangeControlPointAttachment = {
  encode(
    message: CUserMsgParticleManager_ChangeControlPointAttachment,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.attachmentOld !== undefined && message.attachmentOld !== 0) {
      writer.uint32(8).int32(message.attachmentOld);
    }
    if (message.attachmentNew !== undefined && message.attachmentNew !== 0) {
      writer.uint32(16).int32(message.attachmentNew);
    }
    if (message.entityHandle !== undefined && message.entityHandle !== 16777215) {
      writer.uint32(24).uint32(message.entityHandle);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CUserMsgParticleManager_ChangeControlPointAttachment {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCUserMsgParticleManager_ChangeControlPointAttachment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.attachmentOld = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.attachmentNew = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.entityHandle = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CUserMsgParticleManager_ChangeControlPointAttachment {
    return {
      attachmentOld: isSet(object.attachmentOld) ? globalThis.Number(object.attachmentOld) : 0,
      attachmentNew: isSet(object.attachmentNew) ? globalThis.Number(object.attachmentNew) : 0,
      entityHandle: isSet(object.entityHandle) ? globalThis.Number(object.entityHandle) : 16777215,
    };
  },

  toJSON(message: CUserMsgParticleManager_ChangeControlPointAttachment): unknown {
    const obj: any = {};
    if (message.attachmentOld !== undefined && message.attachmentOld !== 0) {
      obj.attachmentOld = Math.round(message.attachmentOld);
    }
    if (message.attachmentNew !== undefined && message.attachmentNew !== 0) {
      obj.attachmentNew = Math.round(message.attachmentNew);
    }
    if (message.entityHandle !== undefined && message.entityHandle !== 16777215) {
      obj.entityHandle = Math.round(message.entityHandle);
    }
    return obj;
  },

  create(
    base?: DeepPartial<CUserMsgParticleManager_ChangeControlPointAttachment>,
  ): CUserMsgParticleManager_ChangeControlPointAttachment {
    return CUserMsgParticleManager_ChangeControlPointAttachment.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CUserMsgParticleManager_ChangeControlPointAttachment>,
  ): CUserMsgParticleManager_ChangeControlPointAttachment {
    const message = createBaseCUserMsgParticleManager_ChangeControlPointAttachment();
    message.attachmentOld = object.attachmentOld ?? 0;
    message.attachmentNew = object.attachmentNew ?? 0;
    message.entityHandle = object.entityHandle ?? 16777215;
    return message;
  },
};

function createBaseCUserMsgParticleManager_UpdateEntityPosition(): CUserMsgParticleManager_UpdateEntityPosition {
  return { entityHandle: 16777215, position: undefined };
}

export const CUserMsgParticleManager_UpdateEntityPosition = {
  encode(message: CUserMsgParticleManager_UpdateEntityPosition, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.entityHandle !== undefined && message.entityHandle !== 16777215) {
      writer.uint32(8).uint32(message.entityHandle);
    }
    if (message.position !== undefined) {
      CMsgVector.encode(message.position, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CUserMsgParticleManager_UpdateEntityPosition {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCUserMsgParticleManager_UpdateEntityPosition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.entityHandle = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.position = CMsgVector.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CUserMsgParticleManager_UpdateEntityPosition {
    return {
      entityHandle: isSet(object.entityHandle) ? globalThis.Number(object.entityHandle) : 16777215,
      position: isSet(object.position) ? CMsgVector.fromJSON(object.position) : undefined,
    };
  },

  toJSON(message: CUserMsgParticleManager_UpdateEntityPosition): unknown {
    const obj: any = {};
    if (message.entityHandle !== undefined && message.entityHandle !== 16777215) {
      obj.entityHandle = Math.round(message.entityHandle);
    }
    if (message.position !== undefined) {
      obj.position = CMsgVector.toJSON(message.position);
    }
    return obj;
  },

  create(
    base?: DeepPartial<CUserMsgParticleManager_UpdateEntityPosition>,
  ): CUserMsgParticleManager_UpdateEntityPosition {
    return CUserMsgParticleManager_UpdateEntityPosition.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CUserMsgParticleManager_UpdateEntityPosition>,
  ): CUserMsgParticleManager_UpdateEntityPosition {
    const message = createBaseCUserMsgParticleManager_UpdateEntityPosition();
    message.entityHandle = object.entityHandle ?? 16777215;
    message.position =
      object.position !== undefined && object.position !== null ? CMsgVector.fromPartial(object.position) : undefined;
    return message;
  },
};

function createBaseCUserMsgParticleManager_SetParticleFoWProperties(): CUserMsgParticleManager_SetParticleFoWProperties {
  return { fowControlPoint: 0, fowControlPoint2: 0, fowRadius: 0 };
}

export const CUserMsgParticleManager_SetParticleFoWProperties = {
  encode(
    message: CUserMsgParticleManager_SetParticleFoWProperties,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.fowControlPoint !== undefined && message.fowControlPoint !== 0) {
      writer.uint32(8).int32(message.fowControlPoint);
    }
    if (message.fowControlPoint2 !== undefined && message.fowControlPoint2 !== 0) {
      writer.uint32(16).int32(message.fowControlPoint2);
    }
    if (message.fowRadius !== undefined && message.fowRadius !== 0) {
      writer.uint32(29).float(message.fowRadius);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CUserMsgParticleManager_SetParticleFoWProperties {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCUserMsgParticleManager_SetParticleFoWProperties();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.fowControlPoint = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.fowControlPoint2 = reader.int32();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.fowRadius = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CUserMsgParticleManager_SetParticleFoWProperties {
    return {
      fowControlPoint: isSet(object.fowControlPoint) ? globalThis.Number(object.fowControlPoint) : 0,
      fowControlPoint2: isSet(object.fowControlPoint2) ? globalThis.Number(object.fowControlPoint2) : 0,
      fowRadius: isSet(object.fowRadius) ? globalThis.Number(object.fowRadius) : 0,
    };
  },

  toJSON(message: CUserMsgParticleManager_SetParticleFoWProperties): unknown {
    const obj: any = {};
    if (message.fowControlPoint !== undefined && message.fowControlPoint !== 0) {
      obj.fowControlPoint = Math.round(message.fowControlPoint);
    }
    if (message.fowControlPoint2 !== undefined && message.fowControlPoint2 !== 0) {
      obj.fowControlPoint2 = Math.round(message.fowControlPoint2);
    }
    if (message.fowRadius !== undefined && message.fowRadius !== 0) {
      obj.fowRadius = message.fowRadius;
    }
    return obj;
  },

  create(
    base?: DeepPartial<CUserMsgParticleManager_SetParticleFoWProperties>,
  ): CUserMsgParticleManager_SetParticleFoWProperties {
    return CUserMsgParticleManager_SetParticleFoWProperties.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CUserMsgParticleManager_SetParticleFoWProperties>,
  ): CUserMsgParticleManager_SetParticleFoWProperties {
    const message = createBaseCUserMsgParticleManager_SetParticleFoWProperties();
    message.fowControlPoint = object.fowControlPoint ?? 0;
    message.fowControlPoint2 = object.fowControlPoint2 ?? 0;
    message.fowRadius = object.fowRadius ?? 0;
    return message;
  },
};

function createBaseCUserMsgParticleManager_SetParticleShouldCheckFoW(): CUserMsgParticleManager_SetParticleShouldCheckFoW {
  return { checkFow: false };
}

export const CUserMsgParticleManager_SetParticleShouldCheckFoW = {
  encode(
    message: CUserMsgParticleManager_SetParticleShouldCheckFoW,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.checkFow !== undefined && message.checkFow !== false) {
      writer.uint32(8).bool(message.checkFow);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CUserMsgParticleManager_SetParticleShouldCheckFoW {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCUserMsgParticleManager_SetParticleShouldCheckFoW();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.checkFow = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CUserMsgParticleManager_SetParticleShouldCheckFoW {
    return { checkFow: isSet(object.checkFow) ? globalThis.Boolean(object.checkFow) : false };
  },

  toJSON(message: CUserMsgParticleManager_SetParticleShouldCheckFoW): unknown {
    const obj: any = {};
    if (message.checkFow !== undefined && message.checkFow !== false) {
      obj.checkFow = message.checkFow;
    }
    return obj;
  },

  create(
    base?: DeepPartial<CUserMsgParticleManager_SetParticleShouldCheckFoW>,
  ): CUserMsgParticleManager_SetParticleShouldCheckFoW {
    return CUserMsgParticleManager_SetParticleShouldCheckFoW.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CUserMsgParticleManager_SetParticleShouldCheckFoW>,
  ): CUserMsgParticleManager_SetParticleShouldCheckFoW {
    const message = createBaseCUserMsgParticleManager_SetParticleShouldCheckFoW();
    message.checkFow = object.checkFow ?? false;
    return message;
  },
};

function createBaseCUserMsgParticleManager_SetControlPointModel(): CUserMsgParticleManager_SetControlPointModel {
  return { controlPoint: 0, modelName: "" };
}

export const CUserMsgParticleManager_SetControlPointModel = {
  encode(message: CUserMsgParticleManager_SetControlPointModel, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.controlPoint !== undefined && message.controlPoint !== 0) {
      writer.uint32(8).int32(message.controlPoint);
    }
    if (message.modelName !== undefined && message.modelName !== "") {
      writer.uint32(18).string(message.modelName);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CUserMsgParticleManager_SetControlPointModel {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCUserMsgParticleManager_SetControlPointModel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.controlPoint = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.modelName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CUserMsgParticleManager_SetControlPointModel {
    return {
      controlPoint: isSet(object.controlPoint) ? globalThis.Number(object.controlPoint) : 0,
      modelName: isSet(object.modelName) ? globalThis.String(object.modelName) : "",
    };
  },

  toJSON(message: CUserMsgParticleManager_SetControlPointModel): unknown {
    const obj: any = {};
    if (message.controlPoint !== undefined && message.controlPoint !== 0) {
      obj.controlPoint = Math.round(message.controlPoint);
    }
    if (message.modelName !== undefined && message.modelName !== "") {
      obj.modelName = message.modelName;
    }
    return obj;
  },

  create(
    base?: DeepPartial<CUserMsgParticleManager_SetControlPointModel>,
  ): CUserMsgParticleManager_SetControlPointModel {
    return CUserMsgParticleManager_SetControlPointModel.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CUserMsgParticleManager_SetControlPointModel>,
  ): CUserMsgParticleManager_SetControlPointModel {
    const message = createBaseCUserMsgParticleManager_SetControlPointModel();
    message.controlPoint = object.controlPoint ?? 0;
    message.modelName = object.modelName ?? "";
    return message;
  },
};

function createBaseCUserMsgParticleManager_SetControlPointSnapshot(): CUserMsgParticleManager_SetControlPointSnapshot {
  return { controlPoint: 0, snapshotName: "" };
}

export const CUserMsgParticleManager_SetControlPointSnapshot = {
  encode(
    message: CUserMsgParticleManager_SetControlPointSnapshot,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.controlPoint !== undefined && message.controlPoint !== 0) {
      writer.uint32(8).int32(message.controlPoint);
    }
    if (message.snapshotName !== undefined && message.snapshotName !== "") {
      writer.uint32(18).string(message.snapshotName);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CUserMsgParticleManager_SetControlPointSnapshot {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCUserMsgParticleManager_SetControlPointSnapshot();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.controlPoint = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.snapshotName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CUserMsgParticleManager_SetControlPointSnapshot {
    return {
      controlPoint: isSet(object.controlPoint) ? globalThis.Number(object.controlPoint) : 0,
      snapshotName: isSet(object.snapshotName) ? globalThis.String(object.snapshotName) : "",
    };
  },

  toJSON(message: CUserMsgParticleManager_SetControlPointSnapshot): unknown {
    const obj: any = {};
    if (message.controlPoint !== undefined && message.controlPoint !== 0) {
      obj.controlPoint = Math.round(message.controlPoint);
    }
    if (message.snapshotName !== undefined && message.snapshotName !== "") {
      obj.snapshotName = message.snapshotName;
    }
    return obj;
  },

  create(
    base?: DeepPartial<CUserMsgParticleManager_SetControlPointSnapshot>,
  ): CUserMsgParticleManager_SetControlPointSnapshot {
    return CUserMsgParticleManager_SetControlPointSnapshot.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CUserMsgParticleManager_SetControlPointSnapshot>,
  ): CUserMsgParticleManager_SetControlPointSnapshot {
    const message = createBaseCUserMsgParticleManager_SetControlPointSnapshot();
    message.controlPoint = object.controlPoint ?? 0;
    message.snapshotName = object.snapshotName ?? "";
    return message;
  },
};

function createBaseCUserMsgParticleManager_SetParticleText(): CUserMsgParticleManager_SetParticleText {
  return { text: "" };
}

export const CUserMsgParticleManager_SetParticleText = {
  encode(message: CUserMsgParticleManager_SetParticleText, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.text !== undefined && message.text !== "") {
      writer.uint32(10).string(message.text);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CUserMsgParticleManager_SetParticleText {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCUserMsgParticleManager_SetParticleText();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.text = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CUserMsgParticleManager_SetParticleText {
    return { text: isSet(object.text) ? globalThis.String(object.text) : "" };
  },

  toJSON(message: CUserMsgParticleManager_SetParticleText): unknown {
    const obj: any = {};
    if (message.text !== undefined && message.text !== "") {
      obj.text = message.text;
    }
    return obj;
  },

  create(base?: DeepPartial<CUserMsgParticleManager_SetParticleText>): CUserMsgParticleManager_SetParticleText {
    return CUserMsgParticleManager_SetParticleText.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CUserMsgParticleManager_SetParticleText>): CUserMsgParticleManager_SetParticleText {
    const message = createBaseCUserMsgParticleManager_SetParticleText();
    message.text = object.text ?? "";
    return message;
  },
};

function createBaseCUserMsgParticleManager_SetTextureAttribute(): CUserMsgParticleManager_SetTextureAttribute {
  return { attributeName: "", textureName: "" };
}

export const CUserMsgParticleManager_SetTextureAttribute = {
  encode(message: CUserMsgParticleManager_SetTextureAttribute, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.attributeName !== undefined && message.attributeName !== "") {
      writer.uint32(10).string(message.attributeName);
    }
    if (message.textureName !== undefined && message.textureName !== "") {
      writer.uint32(18).string(message.textureName);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CUserMsgParticleManager_SetTextureAttribute {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCUserMsgParticleManager_SetTextureAttribute();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.attributeName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.textureName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CUserMsgParticleManager_SetTextureAttribute {
    return {
      attributeName: isSet(object.attributeName) ? globalThis.String(object.attributeName) : "",
      textureName: isSet(object.textureName) ? globalThis.String(object.textureName) : "",
    };
  },

  toJSON(message: CUserMsgParticleManager_SetTextureAttribute): unknown {
    const obj: any = {};
    if (message.attributeName !== undefined && message.attributeName !== "") {
      obj.attributeName = message.attributeName;
    }
    if (message.textureName !== undefined && message.textureName !== "") {
      obj.textureName = message.textureName;
    }
    return obj;
  },

  create(base?: DeepPartial<CUserMsgParticleManager_SetTextureAttribute>): CUserMsgParticleManager_SetTextureAttribute {
    return CUserMsgParticleManager_SetTextureAttribute.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CUserMsgParticleManager_SetTextureAttribute>,
  ): CUserMsgParticleManager_SetTextureAttribute {
    const message = createBaseCUserMsgParticleManager_SetTextureAttribute();
    message.attributeName = object.attributeName ?? "";
    message.textureName = object.textureName ?? "";
    return message;
  },
};

function createBaseCUserMsgParticleManager_SetSceneObjectGenericFlag(): CUserMsgParticleManager_SetSceneObjectGenericFlag {
  return { flagValue: false };
}

export const CUserMsgParticleManager_SetSceneObjectGenericFlag = {
  encode(
    message: CUserMsgParticleManager_SetSceneObjectGenericFlag,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.flagValue !== undefined && message.flagValue !== false) {
      writer.uint32(8).bool(message.flagValue);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CUserMsgParticleManager_SetSceneObjectGenericFlag {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCUserMsgParticleManager_SetSceneObjectGenericFlag();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.flagValue = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CUserMsgParticleManager_SetSceneObjectGenericFlag {
    return { flagValue: isSet(object.flagValue) ? globalThis.Boolean(object.flagValue) : false };
  },

  toJSON(message: CUserMsgParticleManager_SetSceneObjectGenericFlag): unknown {
    const obj: any = {};
    if (message.flagValue !== undefined && message.flagValue !== false) {
      obj.flagValue = message.flagValue;
    }
    return obj;
  },

  create(
    base?: DeepPartial<CUserMsgParticleManager_SetSceneObjectGenericFlag>,
  ): CUserMsgParticleManager_SetSceneObjectGenericFlag {
    return CUserMsgParticleManager_SetSceneObjectGenericFlag.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CUserMsgParticleManager_SetSceneObjectGenericFlag>,
  ): CUserMsgParticleManager_SetSceneObjectGenericFlag {
    const message = createBaseCUserMsgParticleManager_SetSceneObjectGenericFlag();
    message.flagValue = object.flagValue ?? false;
    return message;
  },
};

function createBaseCUserMsgParticleManager_SetSceneObjectTintAndDesat(): CUserMsgParticleManager_SetSceneObjectTintAndDesat {
  return { tint: 0, desat: 0 };
}

export const CUserMsgParticleManager_SetSceneObjectTintAndDesat = {
  encode(
    message: CUserMsgParticleManager_SetSceneObjectTintAndDesat,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.tint !== undefined && message.tint !== 0) {
      writer.uint32(13).fixed32(message.tint);
    }
    if (message.desat !== undefined && message.desat !== 0) {
      writer.uint32(21).float(message.desat);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CUserMsgParticleManager_SetSceneObjectTintAndDesat {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCUserMsgParticleManager_SetSceneObjectTintAndDesat();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.tint = reader.fixed32();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.desat = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CUserMsgParticleManager_SetSceneObjectTintAndDesat {
    return {
      tint: isSet(object.tint) ? globalThis.Number(object.tint) : 0,
      desat: isSet(object.desat) ? globalThis.Number(object.desat) : 0,
    };
  },

  toJSON(message: CUserMsgParticleManager_SetSceneObjectTintAndDesat): unknown {
    const obj: any = {};
    if (message.tint !== undefined && message.tint !== 0) {
      obj.tint = Math.round(message.tint);
    }
    if (message.desat !== undefined && message.desat !== 0) {
      obj.desat = message.desat;
    }
    return obj;
  },

  create(
    base?: DeepPartial<CUserMsgParticleManager_SetSceneObjectTintAndDesat>,
  ): CUserMsgParticleManager_SetSceneObjectTintAndDesat {
    return CUserMsgParticleManager_SetSceneObjectTintAndDesat.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CUserMsgParticleManager_SetSceneObjectTintAndDesat>,
  ): CUserMsgParticleManager_SetSceneObjectTintAndDesat {
    const message = createBaseCUserMsgParticleManager_SetSceneObjectTintAndDesat();
    message.tint = object.tint ?? 0;
    message.desat = object.desat ?? 0;
    return message;
  },
};

function createBaseCUserMsgParticleManager_ParticleSkipToTime(): CUserMsgParticleManager_ParticleSkipToTime {
  return { skipToTime: 0 };
}

export const CUserMsgParticleManager_ParticleSkipToTime = {
  encode(message: CUserMsgParticleManager_ParticleSkipToTime, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.skipToTime !== undefined && message.skipToTime !== 0) {
      writer.uint32(13).float(message.skipToTime);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CUserMsgParticleManager_ParticleSkipToTime {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCUserMsgParticleManager_ParticleSkipToTime();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.skipToTime = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CUserMsgParticleManager_ParticleSkipToTime {
    return { skipToTime: isSet(object.skipToTime) ? globalThis.Number(object.skipToTime) : 0 };
  },

  toJSON(message: CUserMsgParticleManager_ParticleSkipToTime): unknown {
    const obj: any = {};
    if (message.skipToTime !== undefined && message.skipToTime !== 0) {
      obj.skipToTime = message.skipToTime;
    }
    return obj;
  },

  create(base?: DeepPartial<CUserMsgParticleManager_ParticleSkipToTime>): CUserMsgParticleManager_ParticleSkipToTime {
    return CUserMsgParticleManager_ParticleSkipToTime.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CUserMsgParticleManager_ParticleSkipToTime>,
  ): CUserMsgParticleManager_ParticleSkipToTime {
    const message = createBaseCUserMsgParticleManager_ParticleSkipToTime();
    message.skipToTime = object.skipToTime ?? 0;
    return message;
  },
};

function createBaseCUserMsgParticleManager_ParticleCanFreeze(): CUserMsgParticleManager_ParticleCanFreeze {
  return { canFreeze: false };
}

export const CUserMsgParticleManager_ParticleCanFreeze = {
  encode(message: CUserMsgParticleManager_ParticleCanFreeze, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.canFreeze !== undefined && message.canFreeze !== false) {
      writer.uint32(8).bool(message.canFreeze);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CUserMsgParticleManager_ParticleCanFreeze {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCUserMsgParticleManager_ParticleCanFreeze();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.canFreeze = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CUserMsgParticleManager_ParticleCanFreeze {
    return { canFreeze: isSet(object.canFreeze) ? globalThis.Boolean(object.canFreeze) : false };
  },

  toJSON(message: CUserMsgParticleManager_ParticleCanFreeze): unknown {
    const obj: any = {};
    if (message.canFreeze !== undefined && message.canFreeze !== false) {
      obj.canFreeze = message.canFreeze;
    }
    return obj;
  },

  create(base?: DeepPartial<CUserMsgParticleManager_ParticleCanFreeze>): CUserMsgParticleManager_ParticleCanFreeze {
    return CUserMsgParticleManager_ParticleCanFreeze.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CUserMsgParticleManager_ParticleCanFreeze>,
  ): CUserMsgParticleManager_ParticleCanFreeze {
    const message = createBaseCUserMsgParticleManager_ParticleCanFreeze();
    message.canFreeze = object.canFreeze ?? false;
    return message;
  },
};

function createBaseCUserMsgParticleManager_ParticleFreezeTransitionOverride(): CUserMsgParticleManager_ParticleFreezeTransitionOverride {
  return { freezeTransitionOverride: 0 };
}

export const CUserMsgParticleManager_ParticleFreezeTransitionOverride = {
  encode(
    message: CUserMsgParticleManager_ParticleFreezeTransitionOverride,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.freezeTransitionOverride !== undefined && message.freezeTransitionOverride !== 0) {
      writer.uint32(13).float(message.freezeTransitionOverride);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CUserMsgParticleManager_ParticleFreezeTransitionOverride {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCUserMsgParticleManager_ParticleFreezeTransitionOverride();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.freezeTransitionOverride = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CUserMsgParticleManager_ParticleFreezeTransitionOverride {
    return {
      freezeTransitionOverride: isSet(object.freezeTransitionOverride)
        ? globalThis.Number(object.freezeTransitionOverride)
        : 0,
    };
  },

  toJSON(message: CUserMsgParticleManager_ParticleFreezeTransitionOverride): unknown {
    const obj: any = {};
    if (message.freezeTransitionOverride !== undefined && message.freezeTransitionOverride !== 0) {
      obj.freezeTransitionOverride = message.freezeTransitionOverride;
    }
    return obj;
  },

  create(
    base?: DeepPartial<CUserMsgParticleManager_ParticleFreezeTransitionOverride>,
  ): CUserMsgParticleManager_ParticleFreezeTransitionOverride {
    return CUserMsgParticleManager_ParticleFreezeTransitionOverride.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CUserMsgParticleManager_ParticleFreezeTransitionOverride>,
  ): CUserMsgParticleManager_ParticleFreezeTransitionOverride {
    const message = createBaseCUserMsgParticleManager_ParticleFreezeTransitionOverride();
    message.freezeTransitionOverride = object.freezeTransitionOverride ?? 0;
    return message;
  },
};

function createBaseCUserMsgParticleManager_FreezeParticleInvolving(): CUserMsgParticleManager_FreezeParticleInvolving {
  return { setFrozen: false, transitionDuration: 0, entityHandle: 16777215 };
}

export const CUserMsgParticleManager_FreezeParticleInvolving = {
  encode(
    message: CUserMsgParticleManager_FreezeParticleInvolving,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.setFrozen !== undefined && message.setFrozen !== false) {
      writer.uint32(8).bool(message.setFrozen);
    }
    if (message.transitionDuration !== undefined && message.transitionDuration !== 0) {
      writer.uint32(21).float(message.transitionDuration);
    }
    if (message.entityHandle !== undefined && message.entityHandle !== 16777215) {
      writer.uint32(24).uint32(message.entityHandle);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CUserMsgParticleManager_FreezeParticleInvolving {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCUserMsgParticleManager_FreezeParticleInvolving();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.setFrozen = reader.bool();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.transitionDuration = reader.float();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.entityHandle = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CUserMsgParticleManager_FreezeParticleInvolving {
    return {
      setFrozen: isSet(object.setFrozen) ? globalThis.Boolean(object.setFrozen) : false,
      transitionDuration: isSet(object.transitionDuration) ? globalThis.Number(object.transitionDuration) : 0,
      entityHandle: isSet(object.entityHandle) ? globalThis.Number(object.entityHandle) : 16777215,
    };
  },

  toJSON(message: CUserMsgParticleManager_FreezeParticleInvolving): unknown {
    const obj: any = {};
    if (message.setFrozen !== undefined && message.setFrozen !== false) {
      obj.setFrozen = message.setFrozen;
    }
    if (message.transitionDuration !== undefined && message.transitionDuration !== 0) {
      obj.transitionDuration = message.transitionDuration;
    }
    if (message.entityHandle !== undefined && message.entityHandle !== 16777215) {
      obj.entityHandle = Math.round(message.entityHandle);
    }
    return obj;
  },

  create(
    base?: DeepPartial<CUserMsgParticleManager_FreezeParticleInvolving>,
  ): CUserMsgParticleManager_FreezeParticleInvolving {
    return CUserMsgParticleManager_FreezeParticleInvolving.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CUserMsgParticleManager_FreezeParticleInvolving>,
  ): CUserMsgParticleManager_FreezeParticleInvolving {
    const message = createBaseCUserMsgParticleManager_FreezeParticleInvolving();
    message.setFrozen = object.setFrozen ?? false;
    message.transitionDuration = object.transitionDuration ?? 0;
    message.entityHandle = object.entityHandle ?? 16777215;
    return message;
  },
};

function createBaseCUserMsgParticleManager_AddModellistOverrideElement(): CUserMsgParticleManager_AddModellistOverrideElement {
  return { modelName: "", spawnProbability: 0, groupid: 0 };
}

export const CUserMsgParticleManager_AddModellistOverrideElement = {
  encode(
    message: CUserMsgParticleManager_AddModellistOverrideElement,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.modelName !== undefined && message.modelName !== "") {
      writer.uint32(10).string(message.modelName);
    }
    if (message.spawnProbability !== undefined && message.spawnProbability !== 0) {
      writer.uint32(21).float(message.spawnProbability);
    }
    if (message.groupid !== undefined && message.groupid !== 0) {
      writer.uint32(24).uint32(message.groupid);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CUserMsgParticleManager_AddModellistOverrideElement {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCUserMsgParticleManager_AddModellistOverrideElement();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.modelName = reader.string();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.spawnProbability = reader.float();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.groupid = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CUserMsgParticleManager_AddModellistOverrideElement {
    return {
      modelName: isSet(object.modelName) ? globalThis.String(object.modelName) : "",
      spawnProbability: isSet(object.spawnProbability) ? globalThis.Number(object.spawnProbability) : 0,
      groupid: isSet(object.groupid) ? globalThis.Number(object.groupid) : 0,
    };
  },

  toJSON(message: CUserMsgParticleManager_AddModellistOverrideElement): unknown {
    const obj: any = {};
    if (message.modelName !== undefined && message.modelName !== "") {
      obj.modelName = message.modelName;
    }
    if (message.spawnProbability !== undefined && message.spawnProbability !== 0) {
      obj.spawnProbability = message.spawnProbability;
    }
    if (message.groupid !== undefined && message.groupid !== 0) {
      obj.groupid = Math.round(message.groupid);
    }
    return obj;
  },

  create(
    base?: DeepPartial<CUserMsgParticleManager_AddModellistOverrideElement>,
  ): CUserMsgParticleManager_AddModellistOverrideElement {
    return CUserMsgParticleManager_AddModellistOverrideElement.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CUserMsgParticleManager_AddModellistOverrideElement>,
  ): CUserMsgParticleManager_AddModellistOverrideElement {
    const message = createBaseCUserMsgParticleManager_AddModellistOverrideElement();
    message.modelName = object.modelName ?? "";
    message.spawnProbability = object.spawnProbability ?? 0;
    message.groupid = object.groupid ?? 0;
    return message;
  },
};

function createBaseCUserMsgParticleManager_ClearModellistOverride(): CUserMsgParticleManager_ClearModellistOverride {
  return { groupid: 0 };
}

export const CUserMsgParticleManager_ClearModellistOverride = {
  encode(
    message: CUserMsgParticleManager_ClearModellistOverride,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.groupid !== undefined && message.groupid !== 0) {
      writer.uint32(8).uint32(message.groupid);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CUserMsgParticleManager_ClearModellistOverride {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCUserMsgParticleManager_ClearModellistOverride();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.groupid = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CUserMsgParticleManager_ClearModellistOverride {
    return { groupid: isSet(object.groupid) ? globalThis.Number(object.groupid) : 0 };
  },

  toJSON(message: CUserMsgParticleManager_ClearModellistOverride): unknown {
    const obj: any = {};
    if (message.groupid !== undefined && message.groupid !== 0) {
      obj.groupid = Math.round(message.groupid);
    }
    return obj;
  },

  create(
    base?: DeepPartial<CUserMsgParticleManager_ClearModellistOverride>,
  ): CUserMsgParticleManager_ClearModellistOverride {
    return CUserMsgParticleManager_ClearModellistOverride.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CUserMsgParticleManager_ClearModellistOverride>,
  ): CUserMsgParticleManager_ClearModellistOverride {
    const message = createBaseCUserMsgParticleManager_ClearModellistOverride();
    message.groupid = object.groupid ?? 0;
    return message;
  },
};

function createBaseCUserMsgParticleManager_SetParticleNamedValueContext(): CUserMsgParticleManager_SetParticleNamedValueContext {
  return { floatValues: [], vectorValues: [], transformValues: [], ehandleValues: [] };
}

export const CUserMsgParticleManager_SetParticleNamedValueContext = {
  encode(
    message: CUserMsgParticleManager_SetParticleNamedValueContext,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    for (const v of message.floatValues) {
      CUserMsgParticleManager_SetParticleNamedValueContext_FloatContextValue.encode(
        v!,
        writer.uint32(10).fork(),
      ).ldelim();
    }
    for (const v of message.vectorValues) {
      CUserMsgParticleManager_SetParticleNamedValueContext_VectorContextValue.encode(
        v!,
        writer.uint32(18).fork(),
      ).ldelim();
    }
    for (const v of message.transformValues) {
      CUserMsgParticleManager_SetParticleNamedValueContext_TransformContextValue.encode(
        v!,
        writer.uint32(26).fork(),
      ).ldelim();
    }
    for (const v of message.ehandleValues) {
      CUserMsgParticleManager_SetParticleNamedValueContext_EHandleContext.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CUserMsgParticleManager_SetParticleNamedValueContext {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCUserMsgParticleManager_SetParticleNamedValueContext();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.floatValues.push(
            CUserMsgParticleManager_SetParticleNamedValueContext_FloatContextValue.decode(reader, reader.uint32()),
          );
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.vectorValues.push(
            CUserMsgParticleManager_SetParticleNamedValueContext_VectorContextValue.decode(reader, reader.uint32()),
          );
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.transformValues.push(
            CUserMsgParticleManager_SetParticleNamedValueContext_TransformContextValue.decode(reader, reader.uint32()),
          );
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.ehandleValues.push(
            CUserMsgParticleManager_SetParticleNamedValueContext_EHandleContext.decode(reader, reader.uint32()),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CUserMsgParticleManager_SetParticleNamedValueContext {
    return {
      floatValues: globalThis.Array.isArray(object?.floatValues)
        ? object.floatValues.map((e: any) =>
            CUserMsgParticleManager_SetParticleNamedValueContext_FloatContextValue.fromJSON(e),
          )
        : [],
      vectorValues: globalThis.Array.isArray(object?.vectorValues)
        ? object.vectorValues.map((e: any) =>
            CUserMsgParticleManager_SetParticleNamedValueContext_VectorContextValue.fromJSON(e),
          )
        : [],
      transformValues: globalThis.Array.isArray(object?.transformValues)
        ? object.transformValues.map((e: any) =>
            CUserMsgParticleManager_SetParticleNamedValueContext_TransformContextValue.fromJSON(e),
          )
        : [],
      ehandleValues: globalThis.Array.isArray(object?.ehandleValues)
        ? object.ehandleValues.map((e: any) =>
            CUserMsgParticleManager_SetParticleNamedValueContext_EHandleContext.fromJSON(e),
          )
        : [],
    };
  },

  toJSON(message: CUserMsgParticleManager_SetParticleNamedValueContext): unknown {
    const obj: any = {};
    if (message.floatValues?.length) {
      obj.floatValues = message.floatValues.map((e) =>
        CUserMsgParticleManager_SetParticleNamedValueContext_FloatContextValue.toJSON(e),
      );
    }
    if (message.vectorValues?.length) {
      obj.vectorValues = message.vectorValues.map((e) =>
        CUserMsgParticleManager_SetParticleNamedValueContext_VectorContextValue.toJSON(e),
      );
    }
    if (message.transformValues?.length) {
      obj.transformValues = message.transformValues.map((e) =>
        CUserMsgParticleManager_SetParticleNamedValueContext_TransformContextValue.toJSON(e),
      );
    }
    if (message.ehandleValues?.length) {
      obj.ehandleValues = message.ehandleValues.map((e) =>
        CUserMsgParticleManager_SetParticleNamedValueContext_EHandleContext.toJSON(e),
      );
    }
    return obj;
  },

  create(
    base?: DeepPartial<CUserMsgParticleManager_SetParticleNamedValueContext>,
  ): CUserMsgParticleManager_SetParticleNamedValueContext {
    return CUserMsgParticleManager_SetParticleNamedValueContext.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CUserMsgParticleManager_SetParticleNamedValueContext>,
  ): CUserMsgParticleManager_SetParticleNamedValueContext {
    const message = createBaseCUserMsgParticleManager_SetParticleNamedValueContext();
    message.floatValues =
      object.floatValues?.map((e) =>
        CUserMsgParticleManager_SetParticleNamedValueContext_FloatContextValue.fromPartial(e),
      ) || [];
    message.vectorValues =
      object.vectorValues?.map((e) =>
        CUserMsgParticleManager_SetParticleNamedValueContext_VectorContextValue.fromPartial(e),
      ) || [];
    message.transformValues =
      object.transformValues?.map((e) =>
        CUserMsgParticleManager_SetParticleNamedValueContext_TransformContextValue.fromPartial(e),
      ) || [];
    message.ehandleValues =
      object.ehandleValues?.map((e) =>
        CUserMsgParticleManager_SetParticleNamedValueContext_EHandleContext.fromPartial(e),
      ) || [];
    return message;
  },
};

function createBaseCUserMsgParticleManager_SetParticleNamedValueContext_FloatContextValue(): CUserMsgParticleManager_SetParticleNamedValueContext_FloatContextValue {
  return { valueNameHash: 0, value: 0 };
}

export const CUserMsgParticleManager_SetParticleNamedValueContext_FloatContextValue = {
  encode(
    message: CUserMsgParticleManager_SetParticleNamedValueContext_FloatContextValue,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.valueNameHash !== undefined && message.valueNameHash !== 0) {
      writer.uint32(8).uint32(message.valueNameHash);
    }
    if (message.value !== undefined && message.value !== 0) {
      writer.uint32(21).float(message.value);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): CUserMsgParticleManager_SetParticleNamedValueContext_FloatContextValue {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCUserMsgParticleManager_SetParticleNamedValueContext_FloatContextValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.valueNameHash = reader.uint32();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.value = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CUserMsgParticleManager_SetParticleNamedValueContext_FloatContextValue {
    return {
      valueNameHash: isSet(object.valueNameHash) ? globalThis.Number(object.valueNameHash) : 0,
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
    };
  },

  toJSON(message: CUserMsgParticleManager_SetParticleNamedValueContext_FloatContextValue): unknown {
    const obj: any = {};
    if (message.valueNameHash !== undefined && message.valueNameHash !== 0) {
      obj.valueNameHash = Math.round(message.valueNameHash);
    }
    if (message.value !== undefined && message.value !== 0) {
      obj.value = message.value;
    }
    return obj;
  },

  create(
    base?: DeepPartial<CUserMsgParticleManager_SetParticleNamedValueContext_FloatContextValue>,
  ): CUserMsgParticleManager_SetParticleNamedValueContext_FloatContextValue {
    return CUserMsgParticleManager_SetParticleNamedValueContext_FloatContextValue.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CUserMsgParticleManager_SetParticleNamedValueContext_FloatContextValue>,
  ): CUserMsgParticleManager_SetParticleNamedValueContext_FloatContextValue {
    const message = createBaseCUserMsgParticleManager_SetParticleNamedValueContext_FloatContextValue();
    message.valueNameHash = object.valueNameHash ?? 0;
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseCUserMsgParticleManager_SetParticleNamedValueContext_VectorContextValue(): CUserMsgParticleManager_SetParticleNamedValueContext_VectorContextValue {
  return { valueNameHash: 0, value: undefined };
}

export const CUserMsgParticleManager_SetParticleNamedValueContext_VectorContextValue = {
  encode(
    message: CUserMsgParticleManager_SetParticleNamedValueContext_VectorContextValue,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.valueNameHash !== undefined && message.valueNameHash !== 0) {
      writer.uint32(8).uint32(message.valueNameHash);
    }
    if (message.value !== undefined) {
      CMsgVector.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): CUserMsgParticleManager_SetParticleNamedValueContext_VectorContextValue {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCUserMsgParticleManager_SetParticleNamedValueContext_VectorContextValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.valueNameHash = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = CMsgVector.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CUserMsgParticleManager_SetParticleNamedValueContext_VectorContextValue {
    return {
      valueNameHash: isSet(object.valueNameHash) ? globalThis.Number(object.valueNameHash) : 0,
      value: isSet(object.value) ? CMsgVector.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: CUserMsgParticleManager_SetParticleNamedValueContext_VectorContextValue): unknown {
    const obj: any = {};
    if (message.valueNameHash !== undefined && message.valueNameHash !== 0) {
      obj.valueNameHash = Math.round(message.valueNameHash);
    }
    if (message.value !== undefined) {
      obj.value = CMsgVector.toJSON(message.value);
    }
    return obj;
  },

  create(
    base?: DeepPartial<CUserMsgParticleManager_SetParticleNamedValueContext_VectorContextValue>,
  ): CUserMsgParticleManager_SetParticleNamedValueContext_VectorContextValue {
    return CUserMsgParticleManager_SetParticleNamedValueContext_VectorContextValue.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CUserMsgParticleManager_SetParticleNamedValueContext_VectorContextValue>,
  ): CUserMsgParticleManager_SetParticleNamedValueContext_VectorContextValue {
    const message = createBaseCUserMsgParticleManager_SetParticleNamedValueContext_VectorContextValue();
    message.valueNameHash = object.valueNameHash ?? 0;
    message.value =
      object.value !== undefined && object.value !== null ? CMsgVector.fromPartial(object.value) : undefined;
    return message;
  },
};

function createBaseCUserMsgParticleManager_SetParticleNamedValueContext_TransformContextValue(): CUserMsgParticleManager_SetParticleNamedValueContext_TransformContextValue {
  return { valueNameHash: 0, angles: undefined, translation: undefined };
}

export const CUserMsgParticleManager_SetParticleNamedValueContext_TransformContextValue = {
  encode(
    message: CUserMsgParticleManager_SetParticleNamedValueContext_TransformContextValue,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.valueNameHash !== undefined && message.valueNameHash !== 0) {
      writer.uint32(8).uint32(message.valueNameHash);
    }
    if (message.angles !== undefined) {
      CMsgQAngle.encode(message.angles, writer.uint32(18).fork()).ldelim();
    }
    if (message.translation !== undefined) {
      CMsgVector.encode(message.translation, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): CUserMsgParticleManager_SetParticleNamedValueContext_TransformContextValue {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCUserMsgParticleManager_SetParticleNamedValueContext_TransformContextValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.valueNameHash = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.angles = CMsgQAngle.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.translation = CMsgVector.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CUserMsgParticleManager_SetParticleNamedValueContext_TransformContextValue {
    return {
      valueNameHash: isSet(object.valueNameHash) ? globalThis.Number(object.valueNameHash) : 0,
      angles: isSet(object.angles) ? CMsgQAngle.fromJSON(object.angles) : undefined,
      translation: isSet(object.translation) ? CMsgVector.fromJSON(object.translation) : undefined,
    };
  },

  toJSON(message: CUserMsgParticleManager_SetParticleNamedValueContext_TransformContextValue): unknown {
    const obj: any = {};
    if (message.valueNameHash !== undefined && message.valueNameHash !== 0) {
      obj.valueNameHash = Math.round(message.valueNameHash);
    }
    if (message.angles !== undefined) {
      obj.angles = CMsgQAngle.toJSON(message.angles);
    }
    if (message.translation !== undefined) {
      obj.translation = CMsgVector.toJSON(message.translation);
    }
    return obj;
  },

  create(
    base?: DeepPartial<CUserMsgParticleManager_SetParticleNamedValueContext_TransformContextValue>,
  ): CUserMsgParticleManager_SetParticleNamedValueContext_TransformContextValue {
    return CUserMsgParticleManager_SetParticleNamedValueContext_TransformContextValue.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CUserMsgParticleManager_SetParticleNamedValueContext_TransformContextValue>,
  ): CUserMsgParticleManager_SetParticleNamedValueContext_TransformContextValue {
    const message = createBaseCUserMsgParticleManager_SetParticleNamedValueContext_TransformContextValue();
    message.valueNameHash = object.valueNameHash ?? 0;
    message.angles =
      object.angles !== undefined && object.angles !== null ? CMsgQAngle.fromPartial(object.angles) : undefined;
    message.translation =
      object.translation !== undefined && object.translation !== null
        ? CMsgVector.fromPartial(object.translation)
        : undefined;
    return message;
  },
};

function createBaseCUserMsgParticleManager_SetParticleNamedValueContext_EHandleContext(): CUserMsgParticleManager_SetParticleNamedValueContext_EHandleContext {
  return { valueNameHash: 0, entIndex: 16777215 };
}

export const CUserMsgParticleManager_SetParticleNamedValueContext_EHandleContext = {
  encode(
    message: CUserMsgParticleManager_SetParticleNamedValueContext_EHandleContext,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.valueNameHash !== undefined && message.valueNameHash !== 0) {
      writer.uint32(8).uint32(message.valueNameHash);
    }
    if (message.entIndex !== undefined && message.entIndex !== 16777215) {
      writer.uint32(16).uint32(message.entIndex);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): CUserMsgParticleManager_SetParticleNamedValueContext_EHandleContext {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCUserMsgParticleManager_SetParticleNamedValueContext_EHandleContext();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.valueNameHash = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.entIndex = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CUserMsgParticleManager_SetParticleNamedValueContext_EHandleContext {
    return {
      valueNameHash: isSet(object.valueNameHash) ? globalThis.Number(object.valueNameHash) : 0,
      entIndex: isSet(object.entIndex) ? globalThis.Number(object.entIndex) : 16777215,
    };
  },

  toJSON(message: CUserMsgParticleManager_SetParticleNamedValueContext_EHandleContext): unknown {
    const obj: any = {};
    if (message.valueNameHash !== undefined && message.valueNameHash !== 0) {
      obj.valueNameHash = Math.round(message.valueNameHash);
    }
    if (message.entIndex !== undefined && message.entIndex !== 16777215) {
      obj.entIndex = Math.round(message.entIndex);
    }
    return obj;
  },

  create(
    base?: DeepPartial<CUserMsgParticleManager_SetParticleNamedValueContext_EHandleContext>,
  ): CUserMsgParticleManager_SetParticleNamedValueContext_EHandleContext {
    return CUserMsgParticleManager_SetParticleNamedValueContext_EHandleContext.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CUserMsgParticleManager_SetParticleNamedValueContext_EHandleContext>,
  ): CUserMsgParticleManager_SetParticleNamedValueContext_EHandleContext {
    const message = createBaseCUserMsgParticleManager_SetParticleNamedValueContext_EHandleContext();
    message.valueNameHash = object.valueNameHash ?? 0;
    message.entIndex = object.entIndex ?? 16777215;
    return message;
  },
};

function createBaseCUserMsgParticleManager_CreatePhysicsSim(): CUserMsgParticleManager_CreatePhysicsSim {
  return { propGroupName: "" };
}

export const CUserMsgParticleManager_CreatePhysicsSim = {
  encode(message: CUserMsgParticleManager_CreatePhysicsSim, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.propGroupName !== undefined && message.propGroupName !== "") {
      writer.uint32(10).string(message.propGroupName);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CUserMsgParticleManager_CreatePhysicsSim {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCUserMsgParticleManager_CreatePhysicsSim();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.propGroupName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CUserMsgParticleManager_CreatePhysicsSim {
    return { propGroupName: isSet(object.propGroupName) ? globalThis.String(object.propGroupName) : "" };
  },

  toJSON(message: CUserMsgParticleManager_CreatePhysicsSim): unknown {
    const obj: any = {};
    if (message.propGroupName !== undefined && message.propGroupName !== "") {
      obj.propGroupName = message.propGroupName;
    }
    return obj;
  },

  create(base?: DeepPartial<CUserMsgParticleManager_CreatePhysicsSim>): CUserMsgParticleManager_CreatePhysicsSim {
    return CUserMsgParticleManager_CreatePhysicsSim.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CUserMsgParticleManager_CreatePhysicsSim>): CUserMsgParticleManager_CreatePhysicsSim {
    const message = createBaseCUserMsgParticleManager_CreatePhysicsSim();
    message.propGroupName = object.propGroupName ?? "";
    return message;
  },
};

function createBaseCUserMsgParticleManager_DestroyPhysicsSim(): CUserMsgParticleManager_DestroyPhysicsSim {
  return {};
}

export const CUserMsgParticleManager_DestroyPhysicsSim = {
  encode(_: CUserMsgParticleManager_DestroyPhysicsSim, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CUserMsgParticleManager_DestroyPhysicsSim {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCUserMsgParticleManager_DestroyPhysicsSim();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CUserMsgParticleManager_DestroyPhysicsSim {
    return {};
  },

  toJSON(_: CUserMsgParticleManager_DestroyPhysicsSim): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<CUserMsgParticleManager_DestroyPhysicsSim>): CUserMsgParticleManager_DestroyPhysicsSim {
    return CUserMsgParticleManager_DestroyPhysicsSim.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<CUserMsgParticleManager_DestroyPhysicsSim>): CUserMsgParticleManager_DestroyPhysicsSim {
    const message = createBaseCUserMsgParticleManager_DestroyPhysicsSim();
    return message;
  },
};

function createBaseCUserMsgHudError(): CUserMsgHudError {
  return { orderId: 0 };
}

export const CUserMsgHudError = {
  encode(message: CUserMsgHudError, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.orderId !== undefined && message.orderId !== 0) {
      writer.uint32(8).int32(message.orderId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CUserMsgHudError {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCUserMsgHudError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.orderId = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CUserMsgHudError {
    return { orderId: isSet(object.orderId) ? globalThis.Number(object.orderId) : 0 };
  },

  toJSON(message: CUserMsgHudError): unknown {
    const obj: any = {};
    if (message.orderId !== undefined && message.orderId !== 0) {
      obj.orderId = Math.round(message.orderId);
    }
    return obj;
  },

  create(base?: DeepPartial<CUserMsgHudError>): CUserMsgHudError {
    return CUserMsgHudError.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CUserMsgHudError>): CUserMsgHudError {
    const message = createBaseCUserMsgHudError();
    message.orderId = object.orderId ?? 0;
    return message;
  },
};

function createBaseCUserMsgCustomGameEvent(): CUserMsgCustomGameEvent {
  return { eventName: "", data: Buffer.alloc(0) };
}

export const CUserMsgCustomGameEvent = {
  encode(message: CUserMsgCustomGameEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.eventName !== undefined && message.eventName !== "") {
      writer.uint32(10).string(message.eventName);
    }
    if (message.data !== undefined && message.data.length !== 0) {
      writer.uint32(18).bytes(message.data);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CUserMsgCustomGameEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCUserMsgCustomGameEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.eventName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.data = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CUserMsgCustomGameEvent {
    return {
      eventName: isSet(object.eventName) ? globalThis.String(object.eventName) : "",
      data: isSet(object.data) ? Buffer.from(bytesFromBase64(object.data)) : Buffer.alloc(0),
    };
  },

  toJSON(message: CUserMsgCustomGameEvent): unknown {
    const obj: any = {};
    if (message.eventName !== undefined && message.eventName !== "") {
      obj.eventName = message.eventName;
    }
    if (message.data !== undefined && message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    return obj;
  },

  create(base?: DeepPartial<CUserMsgCustomGameEvent>): CUserMsgCustomGameEvent {
    return CUserMsgCustomGameEvent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CUserMsgCustomGameEvent>): CUserMsgCustomGameEvent {
    const message = createBaseCUserMsgCustomGameEvent();
    message.eventName = object.eventName ?? "";
    message.data = object.data ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseCUserMessageHapticsManagerPulse(): CUserMessageHapticsManagerPulse {
  return { handId: 0, effectAmplitude: 0, effectFrequency: 0, effectDuration: 0 };
}

export const CUserMessageHapticsManagerPulse = {
  encode(message: CUserMessageHapticsManagerPulse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.handId !== undefined && message.handId !== 0) {
      writer.uint32(8).int32(message.handId);
    }
    if (message.effectAmplitude !== undefined && message.effectAmplitude !== 0) {
      writer.uint32(21).float(message.effectAmplitude);
    }
    if (message.effectFrequency !== undefined && message.effectFrequency !== 0) {
      writer.uint32(29).float(message.effectFrequency);
    }
    if (message.effectDuration !== undefined && message.effectDuration !== 0) {
      writer.uint32(37).float(message.effectDuration);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CUserMessageHapticsManagerPulse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCUserMessageHapticsManagerPulse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.handId = reader.int32();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.effectAmplitude = reader.float();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.effectFrequency = reader.float();
          continue;
        case 4:
          if (tag !== 37) {
            break;
          }

          message.effectDuration = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CUserMessageHapticsManagerPulse {
    return {
      handId: isSet(object.handId) ? globalThis.Number(object.handId) : 0,
      effectAmplitude: isSet(object.effectAmplitude) ? globalThis.Number(object.effectAmplitude) : 0,
      effectFrequency: isSet(object.effectFrequency) ? globalThis.Number(object.effectFrequency) : 0,
      effectDuration: isSet(object.effectDuration) ? globalThis.Number(object.effectDuration) : 0,
    };
  },

  toJSON(message: CUserMessageHapticsManagerPulse): unknown {
    const obj: any = {};
    if (message.handId !== undefined && message.handId !== 0) {
      obj.handId = Math.round(message.handId);
    }
    if (message.effectAmplitude !== undefined && message.effectAmplitude !== 0) {
      obj.effectAmplitude = message.effectAmplitude;
    }
    if (message.effectFrequency !== undefined && message.effectFrequency !== 0) {
      obj.effectFrequency = message.effectFrequency;
    }
    if (message.effectDuration !== undefined && message.effectDuration !== 0) {
      obj.effectDuration = message.effectDuration;
    }
    return obj;
  },

  create(base?: DeepPartial<CUserMessageHapticsManagerPulse>): CUserMessageHapticsManagerPulse {
    return CUserMessageHapticsManagerPulse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CUserMessageHapticsManagerPulse>): CUserMessageHapticsManagerPulse {
    const message = createBaseCUserMessageHapticsManagerPulse();
    message.handId = object.handId ?? 0;
    message.effectAmplitude = object.effectAmplitude ?? 0;
    message.effectFrequency = object.effectFrequency ?? 0;
    message.effectDuration = object.effectDuration ?? 0;
    return message;
  },
};

function createBaseCUserMessageHapticsManagerEffect(): CUserMessageHapticsManagerEffect {
  return { handId: 0, effectNameHashCode: 0, effectScale: 0 };
}

export const CUserMessageHapticsManagerEffect = {
  encode(message: CUserMessageHapticsManagerEffect, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.handId !== undefined && message.handId !== 0) {
      writer.uint32(8).int32(message.handId);
    }
    if (message.effectNameHashCode !== undefined && message.effectNameHashCode !== 0) {
      writer.uint32(16).uint32(message.effectNameHashCode);
    }
    if (message.effectScale !== undefined && message.effectScale !== 0) {
      writer.uint32(29).float(message.effectScale);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CUserMessageHapticsManagerEffect {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCUserMessageHapticsManagerEffect();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.handId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.effectNameHashCode = reader.uint32();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.effectScale = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CUserMessageHapticsManagerEffect {
    return {
      handId: isSet(object.handId) ? globalThis.Number(object.handId) : 0,
      effectNameHashCode: isSet(object.effectNameHashCode) ? globalThis.Number(object.effectNameHashCode) : 0,
      effectScale: isSet(object.effectScale) ? globalThis.Number(object.effectScale) : 0,
    };
  },

  toJSON(message: CUserMessageHapticsManagerEffect): unknown {
    const obj: any = {};
    if (message.handId !== undefined && message.handId !== 0) {
      obj.handId = Math.round(message.handId);
    }
    if (message.effectNameHashCode !== undefined && message.effectNameHashCode !== 0) {
      obj.effectNameHashCode = Math.round(message.effectNameHashCode);
    }
    if (message.effectScale !== undefined && message.effectScale !== 0) {
      obj.effectScale = message.effectScale;
    }
    return obj;
  },

  create(base?: DeepPartial<CUserMessageHapticsManagerEffect>): CUserMessageHapticsManagerEffect {
    return CUserMessageHapticsManagerEffect.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CUserMessageHapticsManagerEffect>): CUserMessageHapticsManagerEffect {
    const message = createBaseCUserMessageHapticsManagerEffect();
    message.handId = object.handId ?? 0;
    message.effectNameHashCode = object.effectNameHashCode ?? 0;
    message.effectScale = object.effectScale ?? 0;
    return message;
  },
};

function createBaseCUserMessageAnimStateGraphState(): CUserMessageAnimStateGraphState {
  return { entityIndex: 0, data: Buffer.alloc(0) };
}

export const CUserMessageAnimStateGraphState = {
  encode(message: CUserMessageAnimStateGraphState, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.entityIndex !== undefined && message.entityIndex !== 0) {
      writer.uint32(8).int32(message.entityIndex);
    }
    if (message.data !== undefined && message.data.length !== 0) {
      writer.uint32(18).bytes(message.data);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CUserMessageAnimStateGraphState {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCUserMessageAnimStateGraphState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.entityIndex = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.data = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CUserMessageAnimStateGraphState {
    return {
      entityIndex: isSet(object.entityIndex) ? globalThis.Number(object.entityIndex) : 0,
      data: isSet(object.data) ? Buffer.from(bytesFromBase64(object.data)) : Buffer.alloc(0),
    };
  },

  toJSON(message: CUserMessageAnimStateGraphState): unknown {
    const obj: any = {};
    if (message.entityIndex !== undefined && message.entityIndex !== 0) {
      obj.entityIndex = Math.round(message.entityIndex);
    }
    if (message.data !== undefined && message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    return obj;
  },

  create(base?: DeepPartial<CUserMessageAnimStateGraphState>): CUserMessageAnimStateGraphState {
    return CUserMessageAnimStateGraphState.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CUserMessageAnimStateGraphState>): CUserMessageAnimStateGraphState {
    const message = createBaseCUserMessageAnimStateGraphState();
    message.entityIndex = object.entityIndex ?? 0;
    message.data = object.data ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseCUserMessageUpdateCssClasses(): CUserMessageUpdateCssClasses {
  return { targetWorldPanel: 0, cssClasses: "", isAdd: false };
}

export const CUserMessageUpdateCssClasses = {
  encode(message: CUserMessageUpdateCssClasses, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.targetWorldPanel !== undefined && message.targetWorldPanel !== 0) {
      writer.uint32(8).int32(message.targetWorldPanel);
    }
    if (message.cssClasses !== undefined && message.cssClasses !== "") {
      writer.uint32(18).string(message.cssClasses);
    }
    if (message.isAdd !== undefined && message.isAdd !== false) {
      writer.uint32(24).bool(message.isAdd);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CUserMessageUpdateCssClasses {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCUserMessageUpdateCssClasses();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.targetWorldPanel = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.cssClasses = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.isAdd = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CUserMessageUpdateCssClasses {
    return {
      targetWorldPanel: isSet(object.targetWorldPanel) ? globalThis.Number(object.targetWorldPanel) : 0,
      cssClasses: isSet(object.cssClasses) ? globalThis.String(object.cssClasses) : "",
      isAdd: isSet(object.isAdd) ? globalThis.Boolean(object.isAdd) : false,
    };
  },

  toJSON(message: CUserMessageUpdateCssClasses): unknown {
    const obj: any = {};
    if (message.targetWorldPanel !== undefined && message.targetWorldPanel !== 0) {
      obj.targetWorldPanel = Math.round(message.targetWorldPanel);
    }
    if (message.cssClasses !== undefined && message.cssClasses !== "") {
      obj.cssClasses = message.cssClasses;
    }
    if (message.isAdd !== undefined && message.isAdd !== false) {
      obj.isAdd = message.isAdd;
    }
    return obj;
  },

  create(base?: DeepPartial<CUserMessageUpdateCssClasses>): CUserMessageUpdateCssClasses {
    return CUserMessageUpdateCssClasses.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CUserMessageUpdateCssClasses>): CUserMessageUpdateCssClasses {
    const message = createBaseCUserMessageUpdateCssClasses();
    message.targetWorldPanel = object.targetWorldPanel ?? 0;
    message.cssClasses = object.cssClasses ?? "";
    message.isAdd = object.isAdd ?? false;
    return message;
  },
};

function createBaseCUserMessageServerFrameTime(): CUserMessageServerFrameTime {
  return { frameTime: 0 };
}

export const CUserMessageServerFrameTime = {
  encode(message: CUserMessageServerFrameTime, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.frameTime !== undefined && message.frameTime !== 0) {
      writer.uint32(13).float(message.frameTime);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CUserMessageServerFrameTime {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCUserMessageServerFrameTime();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.frameTime = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CUserMessageServerFrameTime {
    return { frameTime: isSet(object.frameTime) ? globalThis.Number(object.frameTime) : 0 };
  },

  toJSON(message: CUserMessageServerFrameTime): unknown {
    const obj: any = {};
    if (message.frameTime !== undefined && message.frameTime !== 0) {
      obj.frameTime = message.frameTime;
    }
    return obj;
  },

  create(base?: DeepPartial<CUserMessageServerFrameTime>): CUserMessageServerFrameTime {
    return CUserMessageServerFrameTime.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CUserMessageServerFrameTime>): CUserMessageServerFrameTime {
    const message = createBaseCUserMessageServerFrameTime();
    message.frameTime = object.frameTime ?? 0;
    return message;
  },
};

function createBaseCUserMessageLagCompensationError(): CUserMessageLagCompensationError {
  return { distance: 0 };
}

export const CUserMessageLagCompensationError = {
  encode(message: CUserMessageLagCompensationError, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.distance !== undefined && message.distance !== 0) {
      writer.uint32(13).float(message.distance);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CUserMessageLagCompensationError {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCUserMessageLagCompensationError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.distance = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CUserMessageLagCompensationError {
    return { distance: isSet(object.distance) ? globalThis.Number(object.distance) : 0 };
  },

  toJSON(message: CUserMessageLagCompensationError): unknown {
    const obj: any = {};
    if (message.distance !== undefined && message.distance !== 0) {
      obj.distance = message.distance;
    }
    return obj;
  },

  create(base?: DeepPartial<CUserMessageLagCompensationError>): CUserMessageLagCompensationError {
    return CUserMessageLagCompensationError.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CUserMessageLagCompensationError>): CUserMessageLagCompensationError {
    const message = createBaseCUserMessageLagCompensationError();
    message.distance = object.distance ?? 0;
    return message;
  },
};

function createBaseCUserMessageRequestDllStatus(): CUserMessageRequestDllStatus {
  return { dllAction: "", fullReport: false };
}

export const CUserMessageRequestDllStatus = {
  encode(message: CUserMessageRequestDllStatus, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.dllAction !== undefined && message.dllAction !== "") {
      writer.uint32(10).string(message.dllAction);
    }
    if (message.fullReport !== undefined && message.fullReport !== false) {
      writer.uint32(16).bool(message.fullReport);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CUserMessageRequestDllStatus {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCUserMessageRequestDllStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.dllAction = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.fullReport = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CUserMessageRequestDllStatus {
    return {
      dllAction: isSet(object.dllAction) ? globalThis.String(object.dllAction) : "",
      fullReport: isSet(object.fullReport) ? globalThis.Boolean(object.fullReport) : false,
    };
  },

  toJSON(message: CUserMessageRequestDllStatus): unknown {
    const obj: any = {};
    if (message.dllAction !== undefined && message.dllAction !== "") {
      obj.dllAction = message.dllAction;
    }
    if (message.fullReport !== undefined && message.fullReport !== false) {
      obj.fullReport = message.fullReport;
    }
    return obj;
  },

  create(base?: DeepPartial<CUserMessageRequestDllStatus>): CUserMessageRequestDllStatus {
    return CUserMessageRequestDllStatus.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CUserMessageRequestDllStatus>): CUserMessageRequestDllStatus {
    const message = createBaseCUserMessageRequestDllStatus();
    message.dllAction = object.dllAction ?? "";
    message.fullReport = object.fullReport ?? false;
    return message;
  },
};

function createBaseCUserMessageRequestUtilAction(): CUserMessageRequestUtilAction {
  return { util1: 0, util2: 0, util3: 0, util4: 0, util5: 0 };
}

export const CUserMessageRequestUtilAction = {
  encode(message: CUserMessageRequestUtilAction, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.util1 !== undefined && message.util1 !== 0) {
      writer.uint32(16).int32(message.util1);
    }
    if (message.util2 !== undefined && message.util2 !== 0) {
      writer.uint32(24).int32(message.util2);
    }
    if (message.util3 !== undefined && message.util3 !== 0) {
      writer.uint32(32).int32(message.util3);
    }
    if (message.util4 !== undefined && message.util4 !== 0) {
      writer.uint32(40).int32(message.util4);
    }
    if (message.util5 !== undefined && message.util5 !== 0) {
      writer.uint32(48).int32(message.util5);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CUserMessageRequestUtilAction {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCUserMessageRequestUtilAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 16) {
            break;
          }

          message.util1 = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.util2 = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.util3 = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.util4 = reader.int32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.util5 = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CUserMessageRequestUtilAction {
    return {
      util1: isSet(object.util1) ? globalThis.Number(object.util1) : 0,
      util2: isSet(object.util2) ? globalThis.Number(object.util2) : 0,
      util3: isSet(object.util3) ? globalThis.Number(object.util3) : 0,
      util4: isSet(object.util4) ? globalThis.Number(object.util4) : 0,
      util5: isSet(object.util5) ? globalThis.Number(object.util5) : 0,
    };
  },

  toJSON(message: CUserMessageRequestUtilAction): unknown {
    const obj: any = {};
    if (message.util1 !== undefined && message.util1 !== 0) {
      obj.util1 = Math.round(message.util1);
    }
    if (message.util2 !== undefined && message.util2 !== 0) {
      obj.util2 = Math.round(message.util2);
    }
    if (message.util3 !== undefined && message.util3 !== 0) {
      obj.util3 = Math.round(message.util3);
    }
    if (message.util4 !== undefined && message.util4 !== 0) {
      obj.util4 = Math.round(message.util4);
    }
    if (message.util5 !== undefined && message.util5 !== 0) {
      obj.util5 = Math.round(message.util5);
    }
    return obj;
  },

  create(base?: DeepPartial<CUserMessageRequestUtilAction>): CUserMessageRequestUtilAction {
    return CUserMessageRequestUtilAction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CUserMessageRequestUtilAction>): CUserMessageRequestUtilAction {
    const message = createBaseCUserMessageRequestUtilAction();
    message.util1 = object.util1 ?? 0;
    message.util2 = object.util2 ?? 0;
    message.util3 = object.util3 ?? 0;
    message.util4 = object.util4 ?? 0;
    message.util5 = object.util5 ?? 0;
    return message;
  },
};

function createBaseCUserMessageUtilMsgResponse(): CUserMessageUtilMsgResponse {
  return {
    crc: 0,
    itemCount: 0,
    crc2: 0,
    itemCount2: 0,
    crcPart: [],
    crcPart2: [],
    clientTimestamp: 0,
    platform: 0,
    itemdetails: [],
    itemgroup: 0,
    totalCount: 0,
    totalCount2: 0,
  };
}

export const CUserMessageUtilMsgResponse = {
  encode(message: CUserMessageUtilMsgResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.crc !== undefined && message.crc !== 0) {
      writer.uint32(13).fixed32(message.crc);
    }
    if (message.itemCount !== undefined && message.itemCount !== 0) {
      writer.uint32(16).int32(message.itemCount);
    }
    if (message.crc2 !== undefined && message.crc2 !== 0) {
      writer.uint32(29).fixed32(message.crc2);
    }
    if (message.itemCount2 !== undefined && message.itemCount2 !== 0) {
      writer.uint32(32).int32(message.itemCount2);
    }
    writer.uint32(42).fork();
    for (const v of message.crcPart) {
      writer.int32(v);
    }
    writer.ldelim();
    writer.uint32(50).fork();
    for (const v of message.crcPart2) {
      writer.int32(v);
    }
    writer.ldelim();
    if (message.clientTimestamp !== undefined && message.clientTimestamp !== 0) {
      writer.uint32(56).int32(message.clientTimestamp);
    }
    if (message.platform !== undefined && message.platform !== 0) {
      writer.uint32(64).int32(message.platform);
    }
    for (const v of message.itemdetails) {
      CUserMessageUtilMsgResponse_ItemDetail.encode(v!, writer.uint32(74).fork()).ldelim();
    }
    if (message.itemgroup !== undefined && message.itemgroup !== 0) {
      writer.uint32(80).int32(message.itemgroup);
    }
    if (message.totalCount !== undefined && message.totalCount !== 0) {
      writer.uint32(88).int32(message.totalCount);
    }
    if (message.totalCount2 !== undefined && message.totalCount2 !== 0) {
      writer.uint32(96).int32(message.totalCount2);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CUserMessageUtilMsgResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCUserMessageUtilMsgResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.crc = reader.fixed32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.itemCount = reader.int32();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.crc2 = reader.fixed32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.itemCount2 = reader.int32();
          continue;
        case 5:
          if (tag === 40) {
            message.crcPart.push(reader.int32());

            continue;
          }

          if (tag === 42) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.crcPart.push(reader.int32());
            }

            continue;
          }

          break;
        case 6:
          if (tag === 48) {
            message.crcPart2.push(reader.int32());

            continue;
          }

          if (tag === 50) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.crcPart2.push(reader.int32());
            }

            continue;
          }

          break;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.clientTimestamp = reader.int32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.platform = reader.int32();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.itemdetails.push(CUserMessageUtilMsgResponse_ItemDetail.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.itemgroup = reader.int32();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.totalCount = reader.int32();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.totalCount2 = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CUserMessageUtilMsgResponse {
    return {
      crc: isSet(object.crc) ? globalThis.Number(object.crc) : 0,
      itemCount: isSet(object.itemCount) ? globalThis.Number(object.itemCount) : 0,
      crc2: isSet(object.crc2) ? globalThis.Number(object.crc2) : 0,
      itemCount2: isSet(object.itemCount2) ? globalThis.Number(object.itemCount2) : 0,
      crcPart: globalThis.Array.isArray(object?.crcPart) ? object.crcPart.map((e: any) => globalThis.Number(e)) : [],
      crcPart2: globalThis.Array.isArray(object?.crcPart2) ? object.crcPart2.map((e: any) => globalThis.Number(e)) : [],
      clientTimestamp: isSet(object.clientTimestamp) ? globalThis.Number(object.clientTimestamp) : 0,
      platform: isSet(object.platform) ? globalThis.Number(object.platform) : 0,
      itemdetails: globalThis.Array.isArray(object?.itemdetails)
        ? object.itemdetails.map((e: any) => CUserMessageUtilMsgResponse_ItemDetail.fromJSON(e))
        : [],
      itemgroup: isSet(object.itemgroup) ? globalThis.Number(object.itemgroup) : 0,
      totalCount: isSet(object.totalCount) ? globalThis.Number(object.totalCount) : 0,
      totalCount2: isSet(object.totalCount2) ? globalThis.Number(object.totalCount2) : 0,
    };
  },

  toJSON(message: CUserMessageUtilMsgResponse): unknown {
    const obj: any = {};
    if (message.crc !== undefined && message.crc !== 0) {
      obj.crc = Math.round(message.crc);
    }
    if (message.itemCount !== undefined && message.itemCount !== 0) {
      obj.itemCount = Math.round(message.itemCount);
    }
    if (message.crc2 !== undefined && message.crc2 !== 0) {
      obj.crc2 = Math.round(message.crc2);
    }
    if (message.itemCount2 !== undefined && message.itemCount2 !== 0) {
      obj.itemCount2 = Math.round(message.itemCount2);
    }
    if (message.crcPart?.length) {
      obj.crcPart = message.crcPart.map((e) => Math.round(e));
    }
    if (message.crcPart2?.length) {
      obj.crcPart2 = message.crcPart2.map((e) => Math.round(e));
    }
    if (message.clientTimestamp !== undefined && message.clientTimestamp !== 0) {
      obj.clientTimestamp = Math.round(message.clientTimestamp);
    }
    if (message.platform !== undefined && message.platform !== 0) {
      obj.platform = Math.round(message.platform);
    }
    if (message.itemdetails?.length) {
      obj.itemdetails = message.itemdetails.map((e) => CUserMessageUtilMsgResponse_ItemDetail.toJSON(e));
    }
    if (message.itemgroup !== undefined && message.itemgroup !== 0) {
      obj.itemgroup = Math.round(message.itemgroup);
    }
    if (message.totalCount !== undefined && message.totalCount !== 0) {
      obj.totalCount = Math.round(message.totalCount);
    }
    if (message.totalCount2 !== undefined && message.totalCount2 !== 0) {
      obj.totalCount2 = Math.round(message.totalCount2);
    }
    return obj;
  },

  create(base?: DeepPartial<CUserMessageUtilMsgResponse>): CUserMessageUtilMsgResponse {
    return CUserMessageUtilMsgResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CUserMessageUtilMsgResponse>): CUserMessageUtilMsgResponse {
    const message = createBaseCUserMessageUtilMsgResponse();
    message.crc = object.crc ?? 0;
    message.itemCount = object.itemCount ?? 0;
    message.crc2 = object.crc2 ?? 0;
    message.itemCount2 = object.itemCount2 ?? 0;
    message.crcPart = object.crcPart?.map((e) => e) || [];
    message.crcPart2 = object.crcPart2?.map((e) => e) || [];
    message.clientTimestamp = object.clientTimestamp ?? 0;
    message.platform = object.platform ?? 0;
    message.itemdetails = object.itemdetails?.map((e) => CUserMessageUtilMsgResponse_ItemDetail.fromPartial(e)) || [];
    message.itemgroup = object.itemgroup ?? 0;
    message.totalCount = object.totalCount ?? 0;
    message.totalCount2 = object.totalCount2 ?? 0;
    return message;
  },
};

function createBaseCUserMessageUtilMsgResponse_ItemDetail(): CUserMessageUtilMsgResponse_ItemDetail {
  return { index: 0, hash: 0, crc: 0, name: "" };
}

export const CUserMessageUtilMsgResponse_ItemDetail = {
  encode(message: CUserMessageUtilMsgResponse_ItemDetail, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.index !== undefined && message.index !== 0) {
      writer.uint32(8).int32(message.index);
    }
    if (message.hash !== undefined && message.hash !== 0) {
      writer.uint32(16).int32(message.hash);
    }
    if (message.crc !== undefined && message.crc !== 0) {
      writer.uint32(24).int32(message.crc);
    }
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(34).string(message.name);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CUserMessageUtilMsgResponse_ItemDetail {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCUserMessageUtilMsgResponse_ItemDetail();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.index = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.hash = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.crc = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CUserMessageUtilMsgResponse_ItemDetail {
    return {
      index: isSet(object.index) ? globalThis.Number(object.index) : 0,
      hash: isSet(object.hash) ? globalThis.Number(object.hash) : 0,
      crc: isSet(object.crc) ? globalThis.Number(object.crc) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: CUserMessageUtilMsgResponse_ItemDetail): unknown {
    const obj: any = {};
    if (message.index !== undefined && message.index !== 0) {
      obj.index = Math.round(message.index);
    }
    if (message.hash !== undefined && message.hash !== 0) {
      obj.hash = Math.round(message.hash);
    }
    if (message.crc !== undefined && message.crc !== 0) {
      obj.crc = Math.round(message.crc);
    }
    if (message.name !== undefined && message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<CUserMessageUtilMsgResponse_ItemDetail>): CUserMessageUtilMsgResponse_ItemDetail {
    return CUserMessageUtilMsgResponse_ItemDetail.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CUserMessageUtilMsgResponse_ItemDetail>): CUserMessageUtilMsgResponse_ItemDetail {
    const message = createBaseCUserMessageUtilMsgResponse_ItemDetail();
    message.index = object.index ?? 0;
    message.hash = object.hash ?? 0;
    message.crc = object.crc ?? 0;
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseCUserMessageDllStatus(): CUserMessageDllStatus {
  return {
    fileReport: "",
    commandLine: "",
    totalFiles: 0,
    processId: 0,
    osversion: 0,
    clientTime: "0",
    diagnostics: [],
    modules: [],
  };
}

export const CUserMessageDllStatus = {
  encode(message: CUserMessageDllStatus, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.fileReport !== undefined && message.fileReport !== "") {
      writer.uint32(10).string(message.fileReport);
    }
    if (message.commandLine !== undefined && message.commandLine !== "") {
      writer.uint32(18).string(message.commandLine);
    }
    if (message.totalFiles !== undefined && message.totalFiles !== 0) {
      writer.uint32(24).uint32(message.totalFiles);
    }
    if (message.processId !== undefined && message.processId !== 0) {
      writer.uint32(32).uint32(message.processId);
    }
    if (message.osversion !== undefined && message.osversion !== 0) {
      writer.uint32(40).int32(message.osversion);
    }
    if (message.clientTime !== undefined && message.clientTime !== "0") {
      writer.uint32(48).uint64(message.clientTime);
    }
    for (const v of message.diagnostics) {
      CUserMessageDllStatus_CVDiagnostic.encode(v!, writer.uint32(58).fork()).ldelim();
    }
    for (const v of message.modules) {
      CUserMessageDllStatus_CModule.encode(v!, writer.uint32(66).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CUserMessageDllStatus {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCUserMessageDllStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.fileReport = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.commandLine = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.totalFiles = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.processId = reader.uint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.osversion = reader.int32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.clientTime = longToString(reader.uint64() as Long);
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.diagnostics.push(CUserMessageDllStatus_CVDiagnostic.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.modules.push(CUserMessageDllStatus_CModule.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CUserMessageDllStatus {
    return {
      fileReport: isSet(object.fileReport) ? globalThis.String(object.fileReport) : "",
      commandLine: isSet(object.commandLine) ? globalThis.String(object.commandLine) : "",
      totalFiles: isSet(object.totalFiles) ? globalThis.Number(object.totalFiles) : 0,
      processId: isSet(object.processId) ? globalThis.Number(object.processId) : 0,
      osversion: isSet(object.osversion) ? globalThis.Number(object.osversion) : 0,
      clientTime: isSet(object.clientTime) ? globalThis.String(object.clientTime) : "0",
      diagnostics: globalThis.Array.isArray(object?.diagnostics)
        ? object.diagnostics.map((e: any) => CUserMessageDllStatus_CVDiagnostic.fromJSON(e))
        : [],
      modules: globalThis.Array.isArray(object?.modules)
        ? object.modules.map((e: any) => CUserMessageDllStatus_CModule.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CUserMessageDllStatus): unknown {
    const obj: any = {};
    if (message.fileReport !== undefined && message.fileReport !== "") {
      obj.fileReport = message.fileReport;
    }
    if (message.commandLine !== undefined && message.commandLine !== "") {
      obj.commandLine = message.commandLine;
    }
    if (message.totalFiles !== undefined && message.totalFiles !== 0) {
      obj.totalFiles = Math.round(message.totalFiles);
    }
    if (message.processId !== undefined && message.processId !== 0) {
      obj.processId = Math.round(message.processId);
    }
    if (message.osversion !== undefined && message.osversion !== 0) {
      obj.osversion = Math.round(message.osversion);
    }
    if (message.clientTime !== undefined && message.clientTime !== "0") {
      obj.clientTime = message.clientTime;
    }
    if (message.diagnostics?.length) {
      obj.diagnostics = message.diagnostics.map((e) => CUserMessageDllStatus_CVDiagnostic.toJSON(e));
    }
    if (message.modules?.length) {
      obj.modules = message.modules.map((e) => CUserMessageDllStatus_CModule.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CUserMessageDllStatus>): CUserMessageDllStatus {
    return CUserMessageDllStatus.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CUserMessageDllStatus>): CUserMessageDllStatus {
    const message = createBaseCUserMessageDllStatus();
    message.fileReport = object.fileReport ?? "";
    message.commandLine = object.commandLine ?? "";
    message.totalFiles = object.totalFiles ?? 0;
    message.processId = object.processId ?? 0;
    message.osversion = object.osversion ?? 0;
    message.clientTime = object.clientTime ?? "0";
    message.diagnostics = object.diagnostics?.map((e) => CUserMessageDllStatus_CVDiagnostic.fromPartial(e)) || [];
    message.modules = object.modules?.map((e) => CUserMessageDllStatus_CModule.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCUserMessageDllStatus_CVDiagnostic(): CUserMessageDllStatus_CVDiagnostic {
  return { id: 0, extended: 0, value: "0", stringValue: "" };
}

export const CUserMessageDllStatus_CVDiagnostic = {
  encode(message: CUserMessageDllStatus_CVDiagnostic, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== undefined && message.id !== 0) {
      writer.uint32(8).uint32(message.id);
    }
    if (message.extended !== undefined && message.extended !== 0) {
      writer.uint32(16).uint32(message.extended);
    }
    if (message.value !== undefined && message.value !== "0") {
      writer.uint32(24).uint64(message.value);
    }
    if (message.stringValue !== undefined && message.stringValue !== "") {
      writer.uint32(34).string(message.stringValue);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CUserMessageDllStatus_CVDiagnostic {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCUserMessageDllStatus_CVDiagnostic();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.extended = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.value = longToString(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.stringValue = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CUserMessageDllStatus_CVDiagnostic {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      extended: isSet(object.extended) ? globalThis.Number(object.extended) : 0,
      value: isSet(object.value) ? globalThis.String(object.value) : "0",
      stringValue: isSet(object.stringValue) ? globalThis.String(object.stringValue) : "",
    };
  },

  toJSON(message: CUserMessageDllStatus_CVDiagnostic): unknown {
    const obj: any = {};
    if (message.id !== undefined && message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.extended !== undefined && message.extended !== 0) {
      obj.extended = Math.round(message.extended);
    }
    if (message.value !== undefined && message.value !== "0") {
      obj.value = message.value;
    }
    if (message.stringValue !== undefined && message.stringValue !== "") {
      obj.stringValue = message.stringValue;
    }
    return obj;
  },

  create(base?: DeepPartial<CUserMessageDllStatus_CVDiagnostic>): CUserMessageDllStatus_CVDiagnostic {
    return CUserMessageDllStatus_CVDiagnostic.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CUserMessageDllStatus_CVDiagnostic>): CUserMessageDllStatus_CVDiagnostic {
    const message = createBaseCUserMessageDllStatus_CVDiagnostic();
    message.id = object.id ?? 0;
    message.extended = object.extended ?? 0;
    message.value = object.value ?? "0";
    message.stringValue = object.stringValue ?? "";
    return message;
  },
};

function createBaseCUserMessageDllStatus_CModule(): CUserMessageDllStatus_CModule {
  return { baseAddr: "0", name: "", size: 0, timestamp: 0 };
}

export const CUserMessageDllStatus_CModule = {
  encode(message: CUserMessageDllStatus_CModule, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.baseAddr !== undefined && message.baseAddr !== "0") {
      writer.uint32(8).uint64(message.baseAddr);
    }
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.size !== undefined && message.size !== 0) {
      writer.uint32(24).uint32(message.size);
    }
    if (message.timestamp !== undefined && message.timestamp !== 0) {
      writer.uint32(32).uint32(message.timestamp);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CUserMessageDllStatus_CModule {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCUserMessageDllStatus_CModule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.baseAddr = longToString(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.size = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.timestamp = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CUserMessageDllStatus_CModule {
    return {
      baseAddr: isSet(object.baseAddr) ? globalThis.String(object.baseAddr) : "0",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      size: isSet(object.size) ? globalThis.Number(object.size) : 0,
      timestamp: isSet(object.timestamp) ? globalThis.Number(object.timestamp) : 0,
    };
  },

  toJSON(message: CUserMessageDllStatus_CModule): unknown {
    const obj: any = {};
    if (message.baseAddr !== undefined && message.baseAddr !== "0") {
      obj.baseAddr = message.baseAddr;
    }
    if (message.name !== undefined && message.name !== "") {
      obj.name = message.name;
    }
    if (message.size !== undefined && message.size !== 0) {
      obj.size = Math.round(message.size);
    }
    if (message.timestamp !== undefined && message.timestamp !== 0) {
      obj.timestamp = Math.round(message.timestamp);
    }
    return obj;
  },

  create(base?: DeepPartial<CUserMessageDllStatus_CModule>): CUserMessageDllStatus_CModule {
    return CUserMessageDllStatus_CModule.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CUserMessageDllStatus_CModule>): CUserMessageDllStatus_CModule {
    const message = createBaseCUserMessageDllStatus_CModule();
    message.baseAddr = object.baseAddr ?? "0";
    message.name = object.name ?? "";
    message.size = object.size ?? 0;
    message.timestamp = object.timestamp ?? 0;
    return message;
  },
};

function createBaseCUserMessageRequestInventory(): CUserMessageRequestInventory {
  return { inventory: 0, offset: 0, options: 0 };
}

export const CUserMessageRequestInventory = {
  encode(message: CUserMessageRequestInventory, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.inventory !== undefined && message.inventory !== 0) {
      writer.uint32(8).int32(message.inventory);
    }
    if (message.offset !== undefined && message.offset !== 0) {
      writer.uint32(16).int32(message.offset);
    }
    if (message.options !== undefined && message.options !== 0) {
      writer.uint32(24).int32(message.options);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CUserMessageRequestInventory {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCUserMessageRequestInventory();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.inventory = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.offset = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.options = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CUserMessageRequestInventory {
    return {
      inventory: isSet(object.inventory) ? globalThis.Number(object.inventory) : 0,
      offset: isSet(object.offset) ? globalThis.Number(object.offset) : 0,
      options: isSet(object.options) ? globalThis.Number(object.options) : 0,
    };
  },

  toJSON(message: CUserMessageRequestInventory): unknown {
    const obj: any = {};
    if (message.inventory !== undefined && message.inventory !== 0) {
      obj.inventory = Math.round(message.inventory);
    }
    if (message.offset !== undefined && message.offset !== 0) {
      obj.offset = Math.round(message.offset);
    }
    if (message.options !== undefined && message.options !== 0) {
      obj.options = Math.round(message.options);
    }
    return obj;
  },

  create(base?: DeepPartial<CUserMessageRequestInventory>): CUserMessageRequestInventory {
    return CUserMessageRequestInventory.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CUserMessageRequestInventory>): CUserMessageRequestInventory {
    const message = createBaseCUserMessageRequestInventory();
    message.inventory = object.inventory ?? 0;
    message.offset = object.offset ?? 0;
    message.options = object.options ?? 0;
    return message;
  },
};

function createBaseCUserMessageInventoryResponse(): CUserMessageInventoryResponse {
  return {
    crc: 0,
    itemCount: 0,
    osversion: 0,
    perfTime: 0,
    clientTimestamp: 0,
    platform: 0,
    inventories: [],
    inventories2: [],
    inventories3: [],
    invType: 0,
    buildVersion: 0,
    instance: 0,
    startTime: "0",
  };
}

export const CUserMessageInventoryResponse = {
  encode(message: CUserMessageInventoryResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.crc !== undefined && message.crc !== 0) {
      writer.uint32(13).fixed32(message.crc);
    }
    if (message.itemCount !== undefined && message.itemCount !== 0) {
      writer.uint32(16).int32(message.itemCount);
    }
    if (message.osversion !== undefined && message.osversion !== 0) {
      writer.uint32(40).int32(message.osversion);
    }
    if (message.perfTime !== undefined && message.perfTime !== 0) {
      writer.uint32(48).int32(message.perfTime);
    }
    if (message.clientTimestamp !== undefined && message.clientTimestamp !== 0) {
      writer.uint32(56).int32(message.clientTimestamp);
    }
    if (message.platform !== undefined && message.platform !== 0) {
      writer.uint32(64).int32(message.platform);
    }
    for (const v of message.inventories) {
      CUserMessageInventoryResponse_InventoryDetail.encode(v!, writer.uint32(74).fork()).ldelim();
    }
    for (const v of message.inventories2) {
      CUserMessageInventoryResponse_InventoryDetail.encode(v!, writer.uint32(82).fork()).ldelim();
    }
    for (const v of message.inventories3) {
      CUserMessageInventoryResponse_InventoryDetail.encode(v!, writer.uint32(114).fork()).ldelim();
    }
    if (message.invType !== undefined && message.invType !== 0) {
      writer.uint32(88).int32(message.invType);
    }
    if (message.buildVersion !== undefined && message.buildVersion !== 0) {
      writer.uint32(96).int32(message.buildVersion);
    }
    if (message.instance !== undefined && message.instance !== 0) {
      writer.uint32(104).int32(message.instance);
    }
    if (message.startTime !== undefined && message.startTime !== "0") {
      writer.uint32(120).int64(message.startTime);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CUserMessageInventoryResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCUserMessageInventoryResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.crc = reader.fixed32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.itemCount = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.osversion = reader.int32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.perfTime = reader.int32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.clientTimestamp = reader.int32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.platform = reader.int32();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.inventories.push(CUserMessageInventoryResponse_InventoryDetail.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.inventories2.push(CUserMessageInventoryResponse_InventoryDetail.decode(reader, reader.uint32()));
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.inventories3.push(CUserMessageInventoryResponse_InventoryDetail.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.invType = reader.int32();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.buildVersion = reader.int32();
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.instance = reader.int32();
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.startTime = longToString(reader.int64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CUserMessageInventoryResponse {
    return {
      crc: isSet(object.crc) ? globalThis.Number(object.crc) : 0,
      itemCount: isSet(object.itemCount) ? globalThis.Number(object.itemCount) : 0,
      osversion: isSet(object.osversion) ? globalThis.Number(object.osversion) : 0,
      perfTime: isSet(object.perfTime) ? globalThis.Number(object.perfTime) : 0,
      clientTimestamp: isSet(object.clientTimestamp) ? globalThis.Number(object.clientTimestamp) : 0,
      platform: isSet(object.platform) ? globalThis.Number(object.platform) : 0,
      inventories: globalThis.Array.isArray(object?.inventories)
        ? object.inventories.map((e: any) => CUserMessageInventoryResponse_InventoryDetail.fromJSON(e))
        : [],
      inventories2: globalThis.Array.isArray(object?.inventories2)
        ? object.inventories2.map((e: any) => CUserMessageInventoryResponse_InventoryDetail.fromJSON(e))
        : [],
      inventories3: globalThis.Array.isArray(object?.inventories3)
        ? object.inventories3.map((e: any) => CUserMessageInventoryResponse_InventoryDetail.fromJSON(e))
        : [],
      invType: isSet(object.invType) ? globalThis.Number(object.invType) : 0,
      buildVersion: isSet(object.buildVersion) ? globalThis.Number(object.buildVersion) : 0,
      instance: isSet(object.instance) ? globalThis.Number(object.instance) : 0,
      startTime: isSet(object.startTime) ? globalThis.String(object.startTime) : "0",
    };
  },

  toJSON(message: CUserMessageInventoryResponse): unknown {
    const obj: any = {};
    if (message.crc !== undefined && message.crc !== 0) {
      obj.crc = Math.round(message.crc);
    }
    if (message.itemCount !== undefined && message.itemCount !== 0) {
      obj.itemCount = Math.round(message.itemCount);
    }
    if (message.osversion !== undefined && message.osversion !== 0) {
      obj.osversion = Math.round(message.osversion);
    }
    if (message.perfTime !== undefined && message.perfTime !== 0) {
      obj.perfTime = Math.round(message.perfTime);
    }
    if (message.clientTimestamp !== undefined && message.clientTimestamp !== 0) {
      obj.clientTimestamp = Math.round(message.clientTimestamp);
    }
    if (message.platform !== undefined && message.platform !== 0) {
      obj.platform = Math.round(message.platform);
    }
    if (message.inventories?.length) {
      obj.inventories = message.inventories.map((e) => CUserMessageInventoryResponse_InventoryDetail.toJSON(e));
    }
    if (message.inventories2?.length) {
      obj.inventories2 = message.inventories2.map((e) => CUserMessageInventoryResponse_InventoryDetail.toJSON(e));
    }
    if (message.inventories3?.length) {
      obj.inventories3 = message.inventories3.map((e) => CUserMessageInventoryResponse_InventoryDetail.toJSON(e));
    }
    if (message.invType !== undefined && message.invType !== 0) {
      obj.invType = Math.round(message.invType);
    }
    if (message.buildVersion !== undefined && message.buildVersion !== 0) {
      obj.buildVersion = Math.round(message.buildVersion);
    }
    if (message.instance !== undefined && message.instance !== 0) {
      obj.instance = Math.round(message.instance);
    }
    if (message.startTime !== undefined && message.startTime !== "0") {
      obj.startTime = message.startTime;
    }
    return obj;
  },

  create(base?: DeepPartial<CUserMessageInventoryResponse>): CUserMessageInventoryResponse {
    return CUserMessageInventoryResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CUserMessageInventoryResponse>): CUserMessageInventoryResponse {
    const message = createBaseCUserMessageInventoryResponse();
    message.crc = object.crc ?? 0;
    message.itemCount = object.itemCount ?? 0;
    message.osversion = object.osversion ?? 0;
    message.perfTime = object.perfTime ?? 0;
    message.clientTimestamp = object.clientTimestamp ?? 0;
    message.platform = object.platform ?? 0;
    message.inventories =
      object.inventories?.map((e) => CUserMessageInventoryResponse_InventoryDetail.fromPartial(e)) || [];
    message.inventories2 =
      object.inventories2?.map((e) => CUserMessageInventoryResponse_InventoryDetail.fromPartial(e)) || [];
    message.inventories3 =
      object.inventories3?.map((e) => CUserMessageInventoryResponse_InventoryDetail.fromPartial(e)) || [];
    message.invType = object.invType ?? 0;
    message.buildVersion = object.buildVersion ?? 0;
    message.instance = object.instance ?? 0;
    message.startTime = object.startTime ?? "0";
    return message;
  },
};

function createBaseCUserMessageInventoryResponse_InventoryDetail(): CUserMessageInventoryResponse_InventoryDetail {
  return {
    index: 0,
    primary: "0",
    offset: "0",
    first: "0",
    base: "0",
    name: "",
    baseName: "",
    baseDetail: 0,
    baseTime: 0,
    baseHash: 0,
  };
}

export const CUserMessageInventoryResponse_InventoryDetail = {
  encode(message: CUserMessageInventoryResponse_InventoryDetail, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.index !== undefined && message.index !== 0) {
      writer.uint32(8).int32(message.index);
    }
    if (message.primary !== undefined && message.primary !== "0") {
      writer.uint32(16).int64(message.primary);
    }
    if (message.offset !== undefined && message.offset !== "0") {
      writer.uint32(24).int64(message.offset);
    }
    if (message.first !== undefined && message.first !== "0") {
      writer.uint32(32).int64(message.first);
    }
    if (message.base !== undefined && message.base !== "0") {
      writer.uint32(40).int64(message.base);
    }
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(50).string(message.name);
    }
    if (message.baseName !== undefined && message.baseName !== "") {
      writer.uint32(58).string(message.baseName);
    }
    if (message.baseDetail !== undefined && message.baseDetail !== 0) {
      writer.uint32(64).int32(message.baseDetail);
    }
    if (message.baseTime !== undefined && message.baseTime !== 0) {
      writer.uint32(72).int32(message.baseTime);
    }
    if (message.baseHash !== undefined && message.baseHash !== 0) {
      writer.uint32(80).int32(message.baseHash);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CUserMessageInventoryResponse_InventoryDetail {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCUserMessageInventoryResponse_InventoryDetail();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.index = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.primary = longToString(reader.int64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.offset = longToString(reader.int64() as Long);
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.first = longToString(reader.int64() as Long);
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.base = longToString(reader.int64() as Long);
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.name = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.baseName = reader.string();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.baseDetail = reader.int32();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.baseTime = reader.int32();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.baseHash = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CUserMessageInventoryResponse_InventoryDetail {
    return {
      index: isSet(object.index) ? globalThis.Number(object.index) : 0,
      primary: isSet(object.primary) ? globalThis.String(object.primary) : "0",
      offset: isSet(object.offset) ? globalThis.String(object.offset) : "0",
      first: isSet(object.first) ? globalThis.String(object.first) : "0",
      base: isSet(object.base) ? globalThis.String(object.base) : "0",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      baseName: isSet(object.baseName) ? globalThis.String(object.baseName) : "",
      baseDetail: isSet(object.baseDetail) ? globalThis.Number(object.baseDetail) : 0,
      baseTime: isSet(object.baseTime) ? globalThis.Number(object.baseTime) : 0,
      baseHash: isSet(object.baseHash) ? globalThis.Number(object.baseHash) : 0,
    };
  },

  toJSON(message: CUserMessageInventoryResponse_InventoryDetail): unknown {
    const obj: any = {};
    if (message.index !== undefined && message.index !== 0) {
      obj.index = Math.round(message.index);
    }
    if (message.primary !== undefined && message.primary !== "0") {
      obj.primary = message.primary;
    }
    if (message.offset !== undefined && message.offset !== "0") {
      obj.offset = message.offset;
    }
    if (message.first !== undefined && message.first !== "0") {
      obj.first = message.first;
    }
    if (message.base !== undefined && message.base !== "0") {
      obj.base = message.base;
    }
    if (message.name !== undefined && message.name !== "") {
      obj.name = message.name;
    }
    if (message.baseName !== undefined && message.baseName !== "") {
      obj.baseName = message.baseName;
    }
    if (message.baseDetail !== undefined && message.baseDetail !== 0) {
      obj.baseDetail = Math.round(message.baseDetail);
    }
    if (message.baseTime !== undefined && message.baseTime !== 0) {
      obj.baseTime = Math.round(message.baseTime);
    }
    if (message.baseHash !== undefined && message.baseHash !== 0) {
      obj.baseHash = Math.round(message.baseHash);
    }
    return obj;
  },

  create(
    base?: DeepPartial<CUserMessageInventoryResponse_InventoryDetail>,
  ): CUserMessageInventoryResponse_InventoryDetail {
    return CUserMessageInventoryResponse_InventoryDetail.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CUserMessageInventoryResponse_InventoryDetail>,
  ): CUserMessageInventoryResponse_InventoryDetail {
    const message = createBaseCUserMessageInventoryResponse_InventoryDetail();
    message.index = object.index ?? 0;
    message.primary = object.primary ?? "0";
    message.offset = object.offset ?? "0";
    message.first = object.first ?? "0";
    message.base = object.base ?? "0";
    message.name = object.name ?? "";
    message.baseName = object.baseName ?? "";
    message.baseDetail = object.baseDetail ?? 0;
    message.baseTime = object.baseTime ?? 0;
    message.baseHash = object.baseHash ?? 0;
    return message;
  },
};

function createBaseCUserMessageRequestDiagnostic(): CUserMessageRequestDiagnostic {
  return { diagnostics: [] };
}

export const CUserMessageRequestDiagnostic = {
  encode(message: CUserMessageRequestDiagnostic, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.diagnostics) {
      CUserMessageRequestDiagnostic_Diagnostic.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CUserMessageRequestDiagnostic {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCUserMessageRequestDiagnostic();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.diagnostics.push(CUserMessageRequestDiagnostic_Diagnostic.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CUserMessageRequestDiagnostic {
    return {
      diagnostics: globalThis.Array.isArray(object?.diagnostics)
        ? object.diagnostics.map((e: any) => CUserMessageRequestDiagnostic_Diagnostic.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CUserMessageRequestDiagnostic): unknown {
    const obj: any = {};
    if (message.diagnostics?.length) {
      obj.diagnostics = message.diagnostics.map((e) => CUserMessageRequestDiagnostic_Diagnostic.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CUserMessageRequestDiagnostic>): CUserMessageRequestDiagnostic {
    return CUserMessageRequestDiagnostic.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CUserMessageRequestDiagnostic>): CUserMessageRequestDiagnostic {
    const message = createBaseCUserMessageRequestDiagnostic();
    message.diagnostics = object.diagnostics?.map((e) => CUserMessageRequestDiagnostic_Diagnostic.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCUserMessageRequestDiagnostic_Diagnostic(): CUserMessageRequestDiagnostic_Diagnostic {
  return {
    index: 0,
    offset: "0",
    param: 0,
    length: 0,
    type: 0,
    base: "0",
    range: "0",
    extent: "0",
    detail: "0",
    name: "",
    alias: "",
    vardetail: Buffer.alloc(0),
    context: 0,
  };
}

export const CUserMessageRequestDiagnostic_Diagnostic = {
  encode(message: CUserMessageRequestDiagnostic_Diagnostic, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.index !== undefined && message.index !== 0) {
      writer.uint32(8).int32(message.index);
    }
    if (message.offset !== undefined && message.offset !== "0") {
      writer.uint32(16).int64(message.offset);
    }
    if (message.param !== undefined && message.param !== 0) {
      writer.uint32(24).int32(message.param);
    }
    if (message.length !== undefined && message.length !== 0) {
      writer.uint32(32).int32(message.length);
    }
    if (message.type !== undefined && message.type !== 0) {
      writer.uint32(40).int32(message.type);
    }
    if (message.base !== undefined && message.base !== "0") {
      writer.uint32(48).int64(message.base);
    }
    if (message.range !== undefined && message.range !== "0") {
      writer.uint32(56).int64(message.range);
    }
    if (message.extent !== undefined && message.extent !== "0") {
      writer.uint32(64).int64(message.extent);
    }
    if (message.detail !== undefined && message.detail !== "0") {
      writer.uint32(72).int64(message.detail);
    }
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(82).string(message.name);
    }
    if (message.alias !== undefined && message.alias !== "") {
      writer.uint32(90).string(message.alias);
    }
    if (message.vardetail !== undefined && message.vardetail.length !== 0) {
      writer.uint32(98).bytes(message.vardetail);
    }
    if (message.context !== undefined && message.context !== 0) {
      writer.uint32(104).int32(message.context);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CUserMessageRequestDiagnostic_Diagnostic {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCUserMessageRequestDiagnostic_Diagnostic();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.index = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.offset = longToString(reader.int64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.param = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.length = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.type = reader.int32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.base = longToString(reader.int64() as Long);
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.range = longToString(reader.int64() as Long);
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.extent = longToString(reader.int64() as Long);
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.detail = longToString(reader.int64() as Long);
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.name = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.alias = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.vardetail = reader.bytes() as Buffer;
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.context = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CUserMessageRequestDiagnostic_Diagnostic {
    return {
      index: isSet(object.index) ? globalThis.Number(object.index) : 0,
      offset: isSet(object.offset) ? globalThis.String(object.offset) : "0",
      param: isSet(object.param) ? globalThis.Number(object.param) : 0,
      length: isSet(object.length) ? globalThis.Number(object.length) : 0,
      type: isSet(object.type) ? globalThis.Number(object.type) : 0,
      base: isSet(object.base) ? globalThis.String(object.base) : "0",
      range: isSet(object.range) ? globalThis.String(object.range) : "0",
      extent: isSet(object.extent) ? globalThis.String(object.extent) : "0",
      detail: isSet(object.detail) ? globalThis.String(object.detail) : "0",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      alias: isSet(object.alias) ? globalThis.String(object.alias) : "",
      vardetail: isSet(object.vardetail) ? Buffer.from(bytesFromBase64(object.vardetail)) : Buffer.alloc(0),
      context: isSet(object.context) ? globalThis.Number(object.context) : 0,
    };
  },

  toJSON(message: CUserMessageRequestDiagnostic_Diagnostic): unknown {
    const obj: any = {};
    if (message.index !== undefined && message.index !== 0) {
      obj.index = Math.round(message.index);
    }
    if (message.offset !== undefined && message.offset !== "0") {
      obj.offset = message.offset;
    }
    if (message.param !== undefined && message.param !== 0) {
      obj.param = Math.round(message.param);
    }
    if (message.length !== undefined && message.length !== 0) {
      obj.length = Math.round(message.length);
    }
    if (message.type !== undefined && message.type !== 0) {
      obj.type = Math.round(message.type);
    }
    if (message.base !== undefined && message.base !== "0") {
      obj.base = message.base;
    }
    if (message.range !== undefined && message.range !== "0") {
      obj.range = message.range;
    }
    if (message.extent !== undefined && message.extent !== "0") {
      obj.extent = message.extent;
    }
    if (message.detail !== undefined && message.detail !== "0") {
      obj.detail = message.detail;
    }
    if (message.name !== undefined && message.name !== "") {
      obj.name = message.name;
    }
    if (message.alias !== undefined && message.alias !== "") {
      obj.alias = message.alias;
    }
    if (message.vardetail !== undefined && message.vardetail.length !== 0) {
      obj.vardetail = base64FromBytes(message.vardetail);
    }
    if (message.context !== undefined && message.context !== 0) {
      obj.context = Math.round(message.context);
    }
    return obj;
  },

  create(base?: DeepPartial<CUserMessageRequestDiagnostic_Diagnostic>): CUserMessageRequestDiagnostic_Diagnostic {
    return CUserMessageRequestDiagnostic_Diagnostic.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CUserMessageRequestDiagnostic_Diagnostic>): CUserMessageRequestDiagnostic_Diagnostic {
    const message = createBaseCUserMessageRequestDiagnostic_Diagnostic();
    message.index = object.index ?? 0;
    message.offset = object.offset ?? "0";
    message.param = object.param ?? 0;
    message.length = object.length ?? 0;
    message.type = object.type ?? 0;
    message.base = object.base ?? "0";
    message.range = object.range ?? "0";
    message.extent = object.extent ?? "0";
    message.detail = object.detail ?? "0";
    message.name = object.name ?? "";
    message.alias = object.alias ?? "";
    message.vardetail = object.vardetail ?? Buffer.alloc(0);
    message.context = object.context ?? 0;
    return message;
  },
};

function createBaseCUserMessageDiagnosticResponse(): CUserMessageDiagnosticResponse {
  return { diagnostics: [], buildVersion: 0, instance: 0, startTime: "0", osversion: 0, platform: 0 };
}

export const CUserMessageDiagnosticResponse = {
  encode(message: CUserMessageDiagnosticResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.diagnostics) {
      CUserMessageDiagnosticResponse_Diagnostic.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.buildVersion !== undefined && message.buildVersion !== 0) {
      writer.uint32(16).int32(message.buildVersion);
    }
    if (message.instance !== undefined && message.instance !== 0) {
      writer.uint32(24).int32(message.instance);
    }
    if (message.startTime !== undefined && message.startTime !== "0") {
      writer.uint32(32).int64(message.startTime);
    }
    if (message.osversion !== undefined && message.osversion !== 0) {
      writer.uint32(40).int32(message.osversion);
    }
    if (message.platform !== undefined && message.platform !== 0) {
      writer.uint32(48).int32(message.platform);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CUserMessageDiagnosticResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCUserMessageDiagnosticResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.diagnostics.push(CUserMessageDiagnosticResponse_Diagnostic.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.buildVersion = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.instance = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.startTime = longToString(reader.int64() as Long);
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.osversion = reader.int32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.platform = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CUserMessageDiagnosticResponse {
    return {
      diagnostics: globalThis.Array.isArray(object?.diagnostics)
        ? object.diagnostics.map((e: any) => CUserMessageDiagnosticResponse_Diagnostic.fromJSON(e))
        : [],
      buildVersion: isSet(object.buildVersion) ? globalThis.Number(object.buildVersion) : 0,
      instance: isSet(object.instance) ? globalThis.Number(object.instance) : 0,
      startTime: isSet(object.startTime) ? globalThis.String(object.startTime) : "0",
      osversion: isSet(object.osversion) ? globalThis.Number(object.osversion) : 0,
      platform: isSet(object.platform) ? globalThis.Number(object.platform) : 0,
    };
  },

  toJSON(message: CUserMessageDiagnosticResponse): unknown {
    const obj: any = {};
    if (message.diagnostics?.length) {
      obj.diagnostics = message.diagnostics.map((e) => CUserMessageDiagnosticResponse_Diagnostic.toJSON(e));
    }
    if (message.buildVersion !== undefined && message.buildVersion !== 0) {
      obj.buildVersion = Math.round(message.buildVersion);
    }
    if (message.instance !== undefined && message.instance !== 0) {
      obj.instance = Math.round(message.instance);
    }
    if (message.startTime !== undefined && message.startTime !== "0") {
      obj.startTime = message.startTime;
    }
    if (message.osversion !== undefined && message.osversion !== 0) {
      obj.osversion = Math.round(message.osversion);
    }
    if (message.platform !== undefined && message.platform !== 0) {
      obj.platform = Math.round(message.platform);
    }
    return obj;
  },

  create(base?: DeepPartial<CUserMessageDiagnosticResponse>): CUserMessageDiagnosticResponse {
    return CUserMessageDiagnosticResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CUserMessageDiagnosticResponse>): CUserMessageDiagnosticResponse {
    const message = createBaseCUserMessageDiagnosticResponse();
    message.diagnostics =
      object.diagnostics?.map((e) => CUserMessageDiagnosticResponse_Diagnostic.fromPartial(e)) || [];
    message.buildVersion = object.buildVersion ?? 0;
    message.instance = object.instance ?? 0;
    message.startTime = object.startTime ?? "0";
    message.osversion = object.osversion ?? 0;
    message.platform = object.platform ?? 0;
    return message;
  },
};

function createBaseCUserMessageDiagnosticResponse_Diagnostic(): CUserMessageDiagnosticResponse_Diagnostic {
  return {
    index: 0,
    offset: "0",
    param: 0,
    length: 0,
    detail: Buffer.alloc(0),
    base: "0",
    range: "0",
    type: 0,
    name: "",
    alias: "",
    backup: Buffer.alloc(0),
    context: 0,
    control: "0",
    augment: "0",
    placebo: "0",
  };
}

export const CUserMessageDiagnosticResponse_Diagnostic = {
  encode(message: CUserMessageDiagnosticResponse_Diagnostic, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.index !== undefined && message.index !== 0) {
      writer.uint32(8).int32(message.index);
    }
    if (message.offset !== undefined && message.offset !== "0") {
      writer.uint32(16).int64(message.offset);
    }
    if (message.param !== undefined && message.param !== 0) {
      writer.uint32(24).int32(message.param);
    }
    if (message.length !== undefined && message.length !== 0) {
      writer.uint32(32).int32(message.length);
    }
    if (message.detail !== undefined && message.detail.length !== 0) {
      writer.uint32(42).bytes(message.detail);
    }
    if (message.base !== undefined && message.base !== "0") {
      writer.uint32(48).int64(message.base);
    }
    if (message.range !== undefined && message.range !== "0") {
      writer.uint32(56).int64(message.range);
    }
    if (message.type !== undefined && message.type !== 0) {
      writer.uint32(64).int32(message.type);
    }
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(82).string(message.name);
    }
    if (message.alias !== undefined && message.alias !== "") {
      writer.uint32(90).string(message.alias);
    }
    if (message.backup !== undefined && message.backup.length !== 0) {
      writer.uint32(98).bytes(message.backup);
    }
    if (message.context !== undefined && message.context !== 0) {
      writer.uint32(104).int32(message.context);
    }
    if (message.control !== undefined && message.control !== "0") {
      writer.uint32(112).int64(message.control);
    }
    if (message.augment !== undefined && message.augment !== "0") {
      writer.uint32(120).int64(message.augment);
    }
    if (message.placebo !== undefined && message.placebo !== "0") {
      writer.uint32(128).int64(message.placebo);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CUserMessageDiagnosticResponse_Diagnostic {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCUserMessageDiagnosticResponse_Diagnostic();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.index = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.offset = longToString(reader.int64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.param = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.length = reader.int32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.detail = reader.bytes() as Buffer;
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.base = longToString(reader.int64() as Long);
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.range = longToString(reader.int64() as Long);
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.type = reader.int32();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.name = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.alias = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.backup = reader.bytes() as Buffer;
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.context = reader.int32();
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.control = longToString(reader.int64() as Long);
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.augment = longToString(reader.int64() as Long);
          continue;
        case 16:
          if (tag !== 128) {
            break;
          }

          message.placebo = longToString(reader.int64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CUserMessageDiagnosticResponse_Diagnostic {
    return {
      index: isSet(object.index) ? globalThis.Number(object.index) : 0,
      offset: isSet(object.offset) ? globalThis.String(object.offset) : "0",
      param: isSet(object.param) ? globalThis.Number(object.param) : 0,
      length: isSet(object.length) ? globalThis.Number(object.length) : 0,
      detail: isSet(object.detail) ? Buffer.from(bytesFromBase64(object.detail)) : Buffer.alloc(0),
      base: isSet(object.base) ? globalThis.String(object.base) : "0",
      range: isSet(object.range) ? globalThis.String(object.range) : "0",
      type: isSet(object.type) ? globalThis.Number(object.type) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      alias: isSet(object.alias) ? globalThis.String(object.alias) : "",
      backup: isSet(object.backup) ? Buffer.from(bytesFromBase64(object.backup)) : Buffer.alloc(0),
      context: isSet(object.context) ? globalThis.Number(object.context) : 0,
      control: isSet(object.control) ? globalThis.String(object.control) : "0",
      augment: isSet(object.augment) ? globalThis.String(object.augment) : "0",
      placebo: isSet(object.placebo) ? globalThis.String(object.placebo) : "0",
    };
  },

  toJSON(message: CUserMessageDiagnosticResponse_Diagnostic): unknown {
    const obj: any = {};
    if (message.index !== undefined && message.index !== 0) {
      obj.index = Math.round(message.index);
    }
    if (message.offset !== undefined && message.offset !== "0") {
      obj.offset = message.offset;
    }
    if (message.param !== undefined && message.param !== 0) {
      obj.param = Math.round(message.param);
    }
    if (message.length !== undefined && message.length !== 0) {
      obj.length = Math.round(message.length);
    }
    if (message.detail !== undefined && message.detail.length !== 0) {
      obj.detail = base64FromBytes(message.detail);
    }
    if (message.base !== undefined && message.base !== "0") {
      obj.base = message.base;
    }
    if (message.range !== undefined && message.range !== "0") {
      obj.range = message.range;
    }
    if (message.type !== undefined && message.type !== 0) {
      obj.type = Math.round(message.type);
    }
    if (message.name !== undefined && message.name !== "") {
      obj.name = message.name;
    }
    if (message.alias !== undefined && message.alias !== "") {
      obj.alias = message.alias;
    }
    if (message.backup !== undefined && message.backup.length !== 0) {
      obj.backup = base64FromBytes(message.backup);
    }
    if (message.context !== undefined && message.context !== 0) {
      obj.context = Math.round(message.context);
    }
    if (message.control !== undefined && message.control !== "0") {
      obj.control = message.control;
    }
    if (message.augment !== undefined && message.augment !== "0") {
      obj.augment = message.augment;
    }
    if (message.placebo !== undefined && message.placebo !== "0") {
      obj.placebo = message.placebo;
    }
    return obj;
  },

  create(base?: DeepPartial<CUserMessageDiagnosticResponse_Diagnostic>): CUserMessageDiagnosticResponse_Diagnostic {
    return CUserMessageDiagnosticResponse_Diagnostic.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CUserMessageDiagnosticResponse_Diagnostic>,
  ): CUserMessageDiagnosticResponse_Diagnostic {
    const message = createBaseCUserMessageDiagnosticResponse_Diagnostic();
    message.index = object.index ?? 0;
    message.offset = object.offset ?? "0";
    message.param = object.param ?? 0;
    message.length = object.length ?? 0;
    message.detail = object.detail ?? Buffer.alloc(0);
    message.base = object.base ?? "0";
    message.range = object.range ?? "0";
    message.type = object.type ?? 0;
    message.name = object.name ?? "";
    message.alias = object.alias ?? "";
    message.backup = object.backup ?? Buffer.alloc(0);
    message.context = object.context ?? 0;
    message.control = object.control ?? "0";
    message.augment = object.augment ?? "0";
    message.placebo = object.placebo ?? "0";
    return message;
  },
};

function createBaseCUserMessageExtraUserData(): CUserMessageExtraUserData {
  return { item: 0, value1: "0", value2: "0", detail1: [], detail2: [] };
}

export const CUserMessageExtraUserData = {
  encode(message: CUserMessageExtraUserData, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.item !== undefined && message.item !== 0) {
      writer.uint32(8).int32(message.item);
    }
    if (message.value1 !== undefined && message.value1 !== "0") {
      writer.uint32(16).int64(message.value1);
    }
    if (message.value2 !== undefined && message.value2 !== "0") {
      writer.uint32(24).int64(message.value2);
    }
    for (const v of message.detail1) {
      writer.uint32(34).bytes(v!);
    }
    for (const v of message.detail2) {
      writer.uint32(42).bytes(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CUserMessageExtraUserData {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCUserMessageExtraUserData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.item = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.value1 = longToString(reader.int64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.value2 = longToString(reader.int64() as Long);
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.detail1.push(reader.bytes() as Buffer);
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.detail2.push(reader.bytes() as Buffer);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CUserMessageExtraUserData {
    return {
      item: isSet(object.item) ? globalThis.Number(object.item) : 0,
      value1: isSet(object.value1) ? globalThis.String(object.value1) : "0",
      value2: isSet(object.value2) ? globalThis.String(object.value2) : "0",
      detail1: globalThis.Array.isArray(object?.detail1)
        ? object.detail1.map((e: any) => Buffer.from(bytesFromBase64(e)))
        : [],
      detail2: globalThis.Array.isArray(object?.detail2)
        ? object.detail2.map((e: any) => Buffer.from(bytesFromBase64(e)))
        : [],
    };
  },

  toJSON(message: CUserMessageExtraUserData): unknown {
    const obj: any = {};
    if (message.item !== undefined && message.item !== 0) {
      obj.item = Math.round(message.item);
    }
    if (message.value1 !== undefined && message.value1 !== "0") {
      obj.value1 = message.value1;
    }
    if (message.value2 !== undefined && message.value2 !== "0") {
      obj.value2 = message.value2;
    }
    if (message.detail1?.length) {
      obj.detail1 = message.detail1.map((e) => base64FromBytes(e));
    }
    if (message.detail2?.length) {
      obj.detail2 = message.detail2.map((e) => base64FromBytes(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CUserMessageExtraUserData>): CUserMessageExtraUserData {
    return CUserMessageExtraUserData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CUserMessageExtraUserData>): CUserMessageExtraUserData {
    const message = createBaseCUserMessageExtraUserData();
    message.item = object.item ?? 0;
    message.value1 = object.value1 ?? "0";
    message.value2 = object.value2 ?? "0";
    message.detail1 = object.detail1?.map((e) => e) || [];
    message.detail2 = object.detail2?.map((e) => e) || [];
    return message;
  },
};

function createBaseCUserMessageNotifyResponseFound(): CUserMessageNotifyResponseFound {
  return { entIndex: -1, ruleName: "", responseValue: "", responseConcept: "", criteria: [] };
}

export const CUserMessageNotifyResponseFound = {
  encode(message: CUserMessageNotifyResponseFound, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.entIndex !== undefined && message.entIndex !== -1) {
      writer.uint32(8).int32(message.entIndex);
    }
    if (message.ruleName !== undefined && message.ruleName !== "") {
      writer.uint32(18).string(message.ruleName);
    }
    if (message.responseValue !== undefined && message.responseValue !== "") {
      writer.uint32(26).string(message.responseValue);
    }
    if (message.responseConcept !== undefined && message.responseConcept !== "") {
      writer.uint32(34).string(message.responseConcept);
    }
    for (const v of message.criteria) {
      CUserMessageNotifyResponseFound_Criteria.encode(v!, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CUserMessageNotifyResponseFound {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCUserMessageNotifyResponseFound();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.entIndex = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.ruleName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.responseValue = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.responseConcept = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.criteria.push(CUserMessageNotifyResponseFound_Criteria.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CUserMessageNotifyResponseFound {
    return {
      entIndex: isSet(object.entIndex) ? globalThis.Number(object.entIndex) : -1,
      ruleName: isSet(object.ruleName) ? globalThis.String(object.ruleName) : "",
      responseValue: isSet(object.responseValue) ? globalThis.String(object.responseValue) : "",
      responseConcept: isSet(object.responseConcept) ? globalThis.String(object.responseConcept) : "",
      criteria: globalThis.Array.isArray(object?.criteria)
        ? object.criteria.map((e: any) => CUserMessageNotifyResponseFound_Criteria.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CUserMessageNotifyResponseFound): unknown {
    const obj: any = {};
    if (message.entIndex !== undefined && message.entIndex !== -1) {
      obj.entIndex = Math.round(message.entIndex);
    }
    if (message.ruleName !== undefined && message.ruleName !== "") {
      obj.ruleName = message.ruleName;
    }
    if (message.responseValue !== undefined && message.responseValue !== "") {
      obj.responseValue = message.responseValue;
    }
    if (message.responseConcept !== undefined && message.responseConcept !== "") {
      obj.responseConcept = message.responseConcept;
    }
    if (message.criteria?.length) {
      obj.criteria = message.criteria.map((e) => CUserMessageNotifyResponseFound_Criteria.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CUserMessageNotifyResponseFound>): CUserMessageNotifyResponseFound {
    return CUserMessageNotifyResponseFound.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CUserMessageNotifyResponseFound>): CUserMessageNotifyResponseFound {
    const message = createBaseCUserMessageNotifyResponseFound();
    message.entIndex = object.entIndex ?? -1;
    message.ruleName = object.ruleName ?? "";
    message.responseValue = object.responseValue ?? "";
    message.responseConcept = object.responseConcept ?? "";
    message.criteria = object.criteria?.map((e) => CUserMessageNotifyResponseFound_Criteria.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCUserMessageNotifyResponseFound_Criteria(): CUserMessageNotifyResponseFound_Criteria {
  return { nameSymbol: 0, value: "" };
}

export const CUserMessageNotifyResponseFound_Criteria = {
  encode(message: CUserMessageNotifyResponseFound_Criteria, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.nameSymbol !== undefined && message.nameSymbol !== 0) {
      writer.uint32(8).uint32(message.nameSymbol);
    }
    if (message.value !== undefined && message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CUserMessageNotifyResponseFound_Criteria {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCUserMessageNotifyResponseFound_Criteria();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.nameSymbol = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CUserMessageNotifyResponseFound_Criteria {
    return {
      nameSymbol: isSet(object.nameSymbol) ? globalThis.Number(object.nameSymbol) : 0,
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: CUserMessageNotifyResponseFound_Criteria): unknown {
    const obj: any = {};
    if (message.nameSymbol !== undefined && message.nameSymbol !== 0) {
      obj.nameSymbol = Math.round(message.nameSymbol);
    }
    if (message.value !== undefined && message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<CUserMessageNotifyResponseFound_Criteria>): CUserMessageNotifyResponseFound_Criteria {
    return CUserMessageNotifyResponseFound_Criteria.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CUserMessageNotifyResponseFound_Criteria>): CUserMessageNotifyResponseFound_Criteria {
    const message = createBaseCUserMessageNotifyResponseFound_Criteria();
    message.nameSymbol = object.nameSymbol ?? 0;
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseCUserMessagePlayResponseConditional(): CUserMessagePlayResponseConditional {
  return { entIndex: -1, playerSlots: [], response: "", entOrigin: undefined };
}

export const CUserMessagePlayResponseConditional = {
  encode(message: CUserMessagePlayResponseConditional, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.entIndex !== undefined && message.entIndex !== -1) {
      writer.uint32(8).int32(message.entIndex);
    }
    writer.uint32(18).fork();
    for (const v of message.playerSlots) {
      writer.int32(v);
    }
    writer.ldelim();
    if (message.response !== undefined && message.response !== "") {
      writer.uint32(26).string(message.response);
    }
    if (message.entOrigin !== undefined) {
      CMsgVector.encode(message.entOrigin, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CUserMessagePlayResponseConditional {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCUserMessagePlayResponseConditional();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.entIndex = reader.int32();
          continue;
        case 2:
          if (tag === 16) {
            message.playerSlots.push(reader.int32());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.playerSlots.push(reader.int32());
            }

            continue;
          }

          break;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.response = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.entOrigin = CMsgVector.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CUserMessagePlayResponseConditional {
    return {
      entIndex: isSet(object.entIndex) ? globalThis.Number(object.entIndex) : -1,
      playerSlots: globalThis.Array.isArray(object?.playerSlots)
        ? object.playerSlots.map((e: any) => globalThis.Number(e))
        : [],
      response: isSet(object.response) ? globalThis.String(object.response) : "",
      entOrigin: isSet(object.entOrigin) ? CMsgVector.fromJSON(object.entOrigin) : undefined,
    };
  },

  toJSON(message: CUserMessagePlayResponseConditional): unknown {
    const obj: any = {};
    if (message.entIndex !== undefined && message.entIndex !== -1) {
      obj.entIndex = Math.round(message.entIndex);
    }
    if (message.playerSlots?.length) {
      obj.playerSlots = message.playerSlots.map((e) => Math.round(e));
    }
    if (message.response !== undefined && message.response !== "") {
      obj.response = message.response;
    }
    if (message.entOrigin !== undefined) {
      obj.entOrigin = CMsgVector.toJSON(message.entOrigin);
    }
    return obj;
  },

  create(base?: DeepPartial<CUserMessagePlayResponseConditional>): CUserMessagePlayResponseConditional {
    return CUserMessagePlayResponseConditional.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CUserMessagePlayResponseConditional>): CUserMessagePlayResponseConditional {
    const message = createBaseCUserMessagePlayResponseConditional();
    message.entIndex = object.entIndex ?? -1;
    message.playerSlots = object.playerSlots?.map((e) => e) || [];
    message.response = object.response ?? "";
    message.entOrigin =
      object.entOrigin !== undefined && object.entOrigin !== null
        ? CMsgVector.fromPartial(object.entOrigin)
        : undefined;
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin
  ? T
  : T extends globalThis.Array<infer U>
    ? globalThis.Array<DeepPartial<U>>
    : T extends ReadonlyArray<infer U>
      ? ReadonlyArray<DeepPartial<U>>
      : T extends {}
        ? { [K in keyof T]?: DeepPartial<T[K]> }
        : Partial<T>;

function longToString(long: Long) {
  return long.toString();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

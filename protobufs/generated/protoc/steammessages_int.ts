// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.176.1
//   protoc               v5.26.1
// source: steammessages_int.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";

export interface CMsgWebAPIKey {
  status?: number | undefined;
  accountId?: number | undefined;
  publisherGroupId?: number | undefined;
  keyId?: number | undefined;
  domain?: string | undefined;
}

export interface CMsgHttpRequest {
  requestMethod?: number | undefined;
  hostname?: string | undefined;
  url?: string | undefined;
  headers: CMsgHttpRequest_RequestHeader[];
  getParams: CMsgHttpRequest_QueryParam[];
  postParams: CMsgHttpRequest_QueryParam[];
  body?: Buffer | undefined;
  absoluteTimeout?: number | undefined;
  useHttps?: boolean | undefined;
}

export interface CMsgHttpRequest_RequestHeader {
  name?: string | undefined;
  value?: string | undefined;
}

export interface CMsgHttpRequest_QueryParam {
  name?: string | undefined;
  value?: Buffer | undefined;
}

export interface CMsgWebAPIRequest {
  interfaceName?: string | undefined;
  methodName?: string | undefined;
  version?: number | undefined;
  apiKey?: CMsgWebAPIKey | undefined;
  request?: CMsgHttpRequest | undefined;
  routingAppId?: number | undefined;
}

export interface CMsgHttpResponse {
  statusCode?: number | undefined;
  headers: CMsgHttpResponse_ResponseHeader[];
  body?: Buffer | undefined;
}

export interface CMsgHttpResponse_ResponseHeader {
  name?: string | undefined;
  value?: string | undefined;
}

export interface CMsgAMFindAccounts {
  searchType?: number | undefined;
  searchString?: string | undefined;
}

export interface CMsgAMFindAccountsResponse {
  steamId: string[];
}

export interface CMsgNotifyWatchdog {
  source?: number | undefined;
  alertType?: number | undefined;
  critical?: boolean | undefined;
  time?: number | undefined;
  appid?: number | undefined;
  text?: string | undefined;
  recipient?: string | undefined;
}

export interface CMsgAMGetLicenses {
  steamid?: string | undefined;
}

export interface CMsgPackageLicense {
  packageId?: number | undefined;
  timeCreated?: number | undefined;
  ownerId?: number | undefined;
}

export interface CMsgAMGetLicensesResponse {
  license: CMsgPackageLicense[];
  result?: number | undefined;
}

export interface CMsgGCGetCommandList {
  appId?: number | undefined;
  commandPrefix?: string | undefined;
}

export interface CMsgGCGetCommandListResponse {
  commandName: string[];
}

export interface CGCMsgMemCachedGet {
  keys: string[];
}

export interface CGCMsgMemCachedGetResponse {
  values: CGCMsgMemCachedGetResponse_ValueTag[];
}

export interface CGCMsgMemCachedGetResponse_ValueTag {
  found?: boolean | undefined;
  value?: Buffer | undefined;
}

export interface CGCMsgMemCachedSet {
  keys: CGCMsgMemCachedSet_KeyPair[];
}

export interface CGCMsgMemCachedSet_KeyPair {
  name?: string | undefined;
  value?: Buffer | undefined;
}

export interface CGCMsgMemCachedDelete {
  keys: string[];
}

export interface CGCMsgMemCachedStats {
}

export interface CGCMsgMemCachedStatsResponse {
  currConnections?: string | undefined;
  cmdGet?: string | undefined;
  cmdSet?: string | undefined;
  cmdFlush?: string | undefined;
  getHits?: string | undefined;
  getMisses?: string | undefined;
  deleteHits?: string | undefined;
  deleteMisses?: string | undefined;
  bytesRead?: string | undefined;
  bytesWritten?: string | undefined;
  limitMaxbytes?: string | undefined;
  currItems?: string | undefined;
  evictions?: string | undefined;
  bytes?: string | undefined;
}

export interface CGCMsgSQLStats {
  schemaCatalog?: number | undefined;
}

export interface CGCMsgSQLStatsResponse {
  threads?: number | undefined;
  threadsConnected?: number | undefined;
  threadsActive?: number | undefined;
  operationsSubmitted?: number | undefined;
  preparedStatementsExecuted?: number | undefined;
  nonPreparedStatementsExecuted?: number | undefined;
  deadlockRetries?: number | undefined;
  operationsTimedOutInQueue?: number | undefined;
  errors?: number | undefined;
}

export interface CMsgAMAddFreeLicense {
  steamid?: string | undefined;
  ipPublic?: number | undefined;
  packageid?: number | undefined;
  storeCountryCode?: string | undefined;
}

export interface CMsgAMAddFreeLicenseResponse {
  eresult?: number | undefined;
  purchaseResultDetail?: number | undefined;
  transid?: string | undefined;
}

export interface CGCMsgGetIPLocation {
  ips: number[];
}

export interface CGCMsgGetIPASN {
  ips: number[];
}

export interface CIPASNInfo {
  ip?: number | undefined;
  asn?: number | undefined;
}

export interface CGCMsgGetIPASNResponse {
  infos: CIPASNInfo[];
}

export interface CMsgAMSendEmail {
  steamid?: string | undefined;
  emailMsgType?: number | undefined;
  emailFormat?: number | undefined;
  personaNameTokens: CMsgAMSendEmail_PersonaNameReplacementToken[];
  sourceGc?: number | undefined;
  tokens: CMsgAMSendEmail_ReplacementToken[];
}

export interface CMsgAMSendEmail_ReplacementToken {
  tokenName?: string | undefined;
  tokenValue?: string | undefined;
}

export interface CMsgAMSendEmail_PersonaNameReplacementToken {
  steamid?: string | undefined;
  tokenName?: string | undefined;
}

export interface CMsgAMSendEmailResponse {
  eresult?: number | undefined;
}

export interface CMsgGCGetEmailTemplate {
  appId?: number | undefined;
  emailMsgType?: number | undefined;
  emailLang?: number | undefined;
  emailFormat?: number | undefined;
}

export interface CMsgGCGetEmailTemplateResponse {
  eresult?: number | undefined;
  templateExists?: boolean | undefined;
  template?: string | undefined;
}

export interface CMsgAMGrantGuestPasses2 {
  steamId?: string | undefined;
  packageId?: number | undefined;
  passesToGrant?: number | undefined;
  daysToExpiration?: number | undefined;
  action?: number | undefined;
}

export interface CMsgAMGrantGuestPasses2Response {
  eresult?: number | undefined;
  passesGranted?: number | undefined;
}

export interface CMsgGCGetPersonaNames {
  steamids: string[];
}

export interface CMsgGCGetPersonaNamesResponse {
  succeededLookups: CMsgGCGetPersonaNamesResponse_PersonaName[];
  failedLookupSteamids: string[];
}

export interface CMsgGCGetPersonaNamesResponse_PersonaName {
  steamid?: string | undefined;
  personaName?: string | undefined;
}

export interface CMsgGCCheckFriendship {
  steamidLeft?: string | undefined;
  steamidRight?: string | undefined;
}

export interface CMsgGCCheckFriendshipResponse {
  success?: boolean | undefined;
  foundFriendship?: boolean | undefined;
}

export interface CMsgGCGetAppFriendsList {
  steamid?: string | undefined;
  includeFriendshipTimestamps?: boolean | undefined;
  includeFriendsWithNoPlayTime?: boolean | undefined;
}

export interface CMsgGCGetAppFriendsListResponse {
  success?: boolean | undefined;
  steamids: string[];
  friendshipTimestamps: number[];
  lastPlaytimes: number[];
}

export interface CMsgGCMsgMasterSetDirectory {
  masterDirIndex?: number | undefined;
  dir: CMsgGCMsgMasterSetDirectory_SubGC[];
}

export interface CMsgGCMsgMasterSetDirectory_SubGC {
  dirIndex?: number | undefined;
  name?: string | undefined;
  box?: string | undefined;
  commandLine?: string | undefined;
  gcBinary?: string | undefined;
}

export interface CMsgGCMsgMasterSetDirectoryResponse {
  eresult?: number | undefined;
  message?: string | undefined;
}

export interface CMsgGCMsgWebAPIJobRequestForwardResponse {
  dirIndex?: number | undefined;
}

export interface CGCSystemMsgGetPurchaseTrustRequest {
  steamid?: string | undefined;
}

export interface CGCSystemMsgGetPurchaseTrustResponse {
  hasPriorPurchaseHistory?: boolean | undefined;
  hasNoRecentPasswordResets?: boolean | undefined;
  isWalletCashTrusted?: boolean | undefined;
  timeAllTrusted?: number | undefined;
}

export interface CMsgGCHAccountVacStatusChange {
  steamId?: string | undefined;
  appId?: number | undefined;
  rtimeVacbanStarts?: number | undefined;
  isBannedNow?: boolean | undefined;
  isBannedFuture?: boolean | undefined;
}

export interface CMsgGCRoutingInfo {
  dirIndex: number[];
  method?: CMsgGCRoutingInfo_RoutingMethod | undefined;
  fallback?: CMsgGCRoutingInfo_RoutingMethod | undefined;
  protobufField?: number | undefined;
  webapiParam?: string | undefined;
}

export enum CMsgGCRoutingInfo_RoutingMethod {
  RANDOM = 0,
  DISCARD = 1,
  CLIENT_STEAMID = 2,
  PROTOBUF_FIELD_UINT64 = 3,
  WEBAPI_PARAM = 4,
  WEBAPI_PARAM_STEAMID_ACCOUNTID = 5,
}

export function cMsgGCRoutingInfo_RoutingMethodFromJSON(object: any): CMsgGCRoutingInfo_RoutingMethod {
  switch (object) {
    case 0:
    case "RANDOM":
      return CMsgGCRoutingInfo_RoutingMethod.RANDOM;
    case 1:
    case "DISCARD":
      return CMsgGCRoutingInfo_RoutingMethod.DISCARD;
    case 2:
    case "CLIENT_STEAMID":
      return CMsgGCRoutingInfo_RoutingMethod.CLIENT_STEAMID;
    case 3:
    case "PROTOBUF_FIELD_UINT64":
      return CMsgGCRoutingInfo_RoutingMethod.PROTOBUF_FIELD_UINT64;
    case 4:
    case "WEBAPI_PARAM":
      return CMsgGCRoutingInfo_RoutingMethod.WEBAPI_PARAM;
    case 5:
    case "WEBAPI_PARAM_STEAMID_ACCOUNTID":
      return CMsgGCRoutingInfo_RoutingMethod.WEBAPI_PARAM_STEAMID_ACCOUNTID;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum CMsgGCRoutingInfo_RoutingMethod");
  }
}

export function cMsgGCRoutingInfo_RoutingMethodToJSON(object: CMsgGCRoutingInfo_RoutingMethod): string {
  switch (object) {
    case CMsgGCRoutingInfo_RoutingMethod.RANDOM:
      return "RANDOM";
    case CMsgGCRoutingInfo_RoutingMethod.DISCARD:
      return "DISCARD";
    case CMsgGCRoutingInfo_RoutingMethod.CLIENT_STEAMID:
      return "CLIENT_STEAMID";
    case CMsgGCRoutingInfo_RoutingMethod.PROTOBUF_FIELD_UINT64:
      return "PROTOBUF_FIELD_UINT64";
    case CMsgGCRoutingInfo_RoutingMethod.WEBAPI_PARAM:
      return "WEBAPI_PARAM";
    case CMsgGCRoutingInfo_RoutingMethod.WEBAPI_PARAM_STEAMID_ACCOUNTID:
      return "WEBAPI_PARAM_STEAMID_ACCOUNTID";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum CMsgGCRoutingInfo_RoutingMethod");
  }
}

export interface CMsgGCMsgMasterSetWebAPIRouting {
  entries: CMsgGCMsgMasterSetWebAPIRouting_Entry[];
}

export interface CMsgGCMsgMasterSetWebAPIRouting_Entry {
  interfaceName?: string | undefined;
  methodName?: string | undefined;
  routing?: CMsgGCRoutingInfo | undefined;
}

export interface CMsgGCMsgMasterSetClientMsgRouting {
  entries: CMsgGCMsgMasterSetClientMsgRouting_Entry[];
}

export interface CMsgGCMsgMasterSetClientMsgRouting_Entry {
  msgType?: number | undefined;
  routing?: CMsgGCRoutingInfo | undefined;
}

export interface CMsgGCMsgMasterSetWebAPIRoutingResponse {
  eresult?: number | undefined;
}

export interface CMsgGCMsgMasterSetClientMsgRoutingResponse {
  eresult?: number | undefined;
}

export interface CMsgGCMsgSetOptions {
  options: CMsgGCMsgSetOptions_Option[];
  clientMsgRanges: CMsgGCMsgSetOptions_MessageRange[];
  gcsqlVersion?: CMsgGCMsgSetOptions_GCSQLVersion | undefined;
}

export enum CMsgGCMsgSetOptions_Option {
  NOTIFY_USER_SESSIONS = 0,
  NOTIFY_SERVER_SESSIONS = 1,
  NOTIFY_ACHIEVEMENTS = 2,
  NOTIFY_VAC_ACTION = 3,
}

export function cMsgGCMsgSetOptions_OptionFromJSON(object: any): CMsgGCMsgSetOptions_Option {
  switch (object) {
    case 0:
    case "NOTIFY_USER_SESSIONS":
      return CMsgGCMsgSetOptions_Option.NOTIFY_USER_SESSIONS;
    case 1:
    case "NOTIFY_SERVER_SESSIONS":
      return CMsgGCMsgSetOptions_Option.NOTIFY_SERVER_SESSIONS;
    case 2:
    case "NOTIFY_ACHIEVEMENTS":
      return CMsgGCMsgSetOptions_Option.NOTIFY_ACHIEVEMENTS;
    case 3:
    case "NOTIFY_VAC_ACTION":
      return CMsgGCMsgSetOptions_Option.NOTIFY_VAC_ACTION;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum CMsgGCMsgSetOptions_Option");
  }
}

export function cMsgGCMsgSetOptions_OptionToJSON(object: CMsgGCMsgSetOptions_Option): string {
  switch (object) {
    case CMsgGCMsgSetOptions_Option.NOTIFY_USER_SESSIONS:
      return "NOTIFY_USER_SESSIONS";
    case CMsgGCMsgSetOptions_Option.NOTIFY_SERVER_SESSIONS:
      return "NOTIFY_SERVER_SESSIONS";
    case CMsgGCMsgSetOptions_Option.NOTIFY_ACHIEVEMENTS:
      return "NOTIFY_ACHIEVEMENTS";
    case CMsgGCMsgSetOptions_Option.NOTIFY_VAC_ACTION:
      return "NOTIFY_VAC_ACTION";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum CMsgGCMsgSetOptions_Option");
  }
}

export enum CMsgGCMsgSetOptions_GCSQLVersion {
  GCSQL_VERSION_BASELINE = 1,
  GCSQL_VERSION_BOOLTYPE = 2,
}

export function cMsgGCMsgSetOptions_GCSQLVersionFromJSON(object: any): CMsgGCMsgSetOptions_GCSQLVersion {
  switch (object) {
    case 1:
    case "GCSQL_VERSION_BASELINE":
      return CMsgGCMsgSetOptions_GCSQLVersion.GCSQL_VERSION_BASELINE;
    case 2:
    case "GCSQL_VERSION_BOOLTYPE":
      return CMsgGCMsgSetOptions_GCSQLVersion.GCSQL_VERSION_BOOLTYPE;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum CMsgGCMsgSetOptions_GCSQLVersion");
  }
}

export function cMsgGCMsgSetOptions_GCSQLVersionToJSON(object: CMsgGCMsgSetOptions_GCSQLVersion): string {
  switch (object) {
    case CMsgGCMsgSetOptions_GCSQLVersion.GCSQL_VERSION_BASELINE:
      return "GCSQL_VERSION_BASELINE";
    case CMsgGCMsgSetOptions_GCSQLVersion.GCSQL_VERSION_BOOLTYPE:
      return "GCSQL_VERSION_BOOLTYPE";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum CMsgGCMsgSetOptions_GCSQLVersion");
  }
}

export interface CMsgGCMsgSetOptions_MessageRange {
  low: number;
  high: number;
}

export interface CMsgGCHUpdateSession {
  steamId?: string | undefined;
  appId?: number | undefined;
  online?: boolean | undefined;
  serverSteamId?: string | undefined;
  serverAddr?: number | undefined;
  serverPort?: number | undefined;
  osType?: number | undefined;
  clientAddr?: number | undefined;
  extraFields: CMsgGCHUpdateSession_ExtraField[];
}

export interface CMsgGCHUpdateSession_ExtraField {
  name?: string | undefined;
  value?: string | undefined;
}

export interface CMsgNotificationOfSuspiciousActivity {
  steamid?: string | undefined;
  appid?: number | undefined;
  multipleInstances?: CMsgNotificationOfSuspiciousActivity_MultipleGameInstances | undefined;
}

export interface CMsgNotificationOfSuspiciousActivity_MultipleGameInstances {
  appInstanceCount?: number | undefined;
  otherSteamids: string[];
}

export interface CMsgGCHVacVerificationChange {
  steamid?: string | undefined;
  appid?: number | undefined;
  isVerified?: boolean | undefined;
}

export interface CMsgGCCheckClanMembership {
  steamid?: string | undefined;
  clanid?: number | undefined;
}

export interface CMsgGCCheckClanMembershipResponse {
  ismember?: boolean | undefined;
}

export interface CMsgGCHAppCheersReceived {
  appid?: number | undefined;
  cheerTargets: CMsgGCHAppCheersReceived_CheerTarget[];
}

export interface CMsgGCHAppCheersReceived_CheerTypeAmount {
  cheerType?: number | undefined;
  cheerAmount?: number | undefined;
}

export interface CMsgGCHAppCheersReceived_CheerTarget {
  cheerTarget?: string | undefined;
  cheerTypes: CMsgGCHAppCheersReceived_CheerTypeAmount[];
}

export interface CMsgGCHAppCheersGetAllowedTypes {
  appid?: number | undefined;
  cheerTarget?: string | undefined;
}

export interface CMsgGCHAppCheersGetAllowedTypesResponse {
  cheerTypesValidAllUsers: number[];
  cheerRemaps: CMsgGCHAppCheersGetAllowedTypesResponse_CheerRemaps[];
  cacheDuration?: number | undefined;
}

export interface CMsgGCHAppCheersGetAllowedTypesResponse_CheerRemaps {
  originalCheerType?: number | undefined;
  remappedCheerType?: number | undefined;
  accountIds: number[];
}

export interface CWorkshopAddSpecialPaymentRequest {
  appid?: number | undefined;
  gameitemid?: number | undefined;
  date?: string | undefined;
  paymentUsUsd?: string | undefined;
  paymentRowUsd?: string | undefined;
}

export interface CWorkshopAddSpecialPaymentResponse {
}

export interface CWorkshopGetSpecialPaymentsRequest {
  appid?: number | undefined;
  gameitemid?: number | undefined;
  date?: string | undefined;
}

export interface CWorkshopGetSpecialPaymentsResponse {
  specialPayments: CWorkshopGetSpecialPaymentsResponse_SpecialPayment[];
}

export interface CWorkshopGetSpecialPaymentsResponse_SpecialPayment {
  appid?: number | undefined;
  gameitemid?: number | undefined;
  date?: string | undefined;
  netPaymentUsUsd?: string | undefined;
  netPaymentRowUsd?: string | undefined;
}

function createBaseCMsgWebAPIKey(): CMsgWebAPIKey {
  return { status: 255, accountId: 0, publisherGroupId: 0, keyId: 0, domain: "" };
}

export const CMsgWebAPIKey = {
  encode(message: CMsgWebAPIKey, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.status !== undefined && message.status !== 255) {
      writer.uint32(8).uint32(message.status);
    }
    if (message.accountId !== undefined && message.accountId !== 0) {
      writer.uint32(16).uint32(message.accountId);
    }
    if (message.publisherGroupId !== undefined && message.publisherGroupId !== 0) {
      writer.uint32(24).uint32(message.publisherGroupId);
    }
    if (message.keyId !== undefined && message.keyId !== 0) {
      writer.uint32(32).uint32(message.keyId);
    }
    if (message.domain !== undefined && message.domain !== "") {
      writer.uint32(42).string(message.domain);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgWebAPIKey {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgWebAPIKey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.status = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.publisherGroupId = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.keyId = reader.uint32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.domain = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgWebAPIKey {
    return {
      status: isSet(object.status) ? globalThis.Number(object.status) : 255,
      accountId: isSet(object.accountId) ? globalThis.Number(object.accountId) : 0,
      publisherGroupId: isSet(object.publisherGroupId) ? globalThis.Number(object.publisherGroupId) : 0,
      keyId: isSet(object.keyId) ? globalThis.Number(object.keyId) : 0,
      domain: isSet(object.domain) ? globalThis.String(object.domain) : "",
    };
  },

  toJSON(message: CMsgWebAPIKey): unknown {
    const obj: any = {};
    if (message.status !== undefined && message.status !== 255) {
      obj.status = Math.round(message.status);
    }
    if (message.accountId !== undefined && message.accountId !== 0) {
      obj.accountId = Math.round(message.accountId);
    }
    if (message.publisherGroupId !== undefined && message.publisherGroupId !== 0) {
      obj.publisherGroupId = Math.round(message.publisherGroupId);
    }
    if (message.keyId !== undefined && message.keyId !== 0) {
      obj.keyId = Math.round(message.keyId);
    }
    if (message.domain !== undefined && message.domain !== "") {
      obj.domain = message.domain;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgWebAPIKey>): CMsgWebAPIKey {
    return CMsgWebAPIKey.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgWebAPIKey>): CMsgWebAPIKey {
    const message = createBaseCMsgWebAPIKey();
    message.status = object.status ?? 255;
    message.accountId = object.accountId ?? 0;
    message.publisherGroupId = object.publisherGroupId ?? 0;
    message.keyId = object.keyId ?? 0;
    message.domain = object.domain ?? "";
    return message;
  },
};

function createBaseCMsgHttpRequest(): CMsgHttpRequest {
  return {
    requestMethod: 0,
    hostname: "",
    url: "",
    headers: [],
    getParams: [],
    postParams: [],
    body: Buffer.alloc(0),
    absoluteTimeout: 0,
    useHttps: false,
  };
}

export const CMsgHttpRequest = {
  encode(message: CMsgHttpRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.requestMethod !== undefined && message.requestMethod !== 0) {
      writer.uint32(8).uint32(message.requestMethod);
    }
    if (message.hostname !== undefined && message.hostname !== "") {
      writer.uint32(18).string(message.hostname);
    }
    if (message.url !== undefined && message.url !== "") {
      writer.uint32(26).string(message.url);
    }
    for (const v of message.headers) {
      CMsgHttpRequest_RequestHeader.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    for (const v of message.getParams) {
      CMsgHttpRequest_QueryParam.encode(v!, writer.uint32(42).fork()).ldelim();
    }
    for (const v of message.postParams) {
      CMsgHttpRequest_QueryParam.encode(v!, writer.uint32(50).fork()).ldelim();
    }
    if (message.body !== undefined && message.body.length !== 0) {
      writer.uint32(58).bytes(message.body);
    }
    if (message.absoluteTimeout !== undefined && message.absoluteTimeout !== 0) {
      writer.uint32(64).uint32(message.absoluteTimeout);
    }
    if (message.useHttps !== undefined && message.useHttps !== false) {
      writer.uint32(72).bool(message.useHttps);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgHttpRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgHttpRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.requestMethod = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.hostname = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.url = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.headers.push(CMsgHttpRequest_RequestHeader.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.getParams.push(CMsgHttpRequest_QueryParam.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.postParams.push(CMsgHttpRequest_QueryParam.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.body = reader.bytes() as Buffer;
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.absoluteTimeout = reader.uint32();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.useHttps = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgHttpRequest {
    return {
      requestMethod: isSet(object.requestMethod) ? globalThis.Number(object.requestMethod) : 0,
      hostname: isSet(object.hostname) ? globalThis.String(object.hostname) : "",
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      headers: globalThis.Array.isArray(object?.headers)
        ? object.headers.map((e: any) => CMsgHttpRequest_RequestHeader.fromJSON(e))
        : [],
      getParams: globalThis.Array.isArray(object?.getParams)
        ? object.getParams.map((e: any) => CMsgHttpRequest_QueryParam.fromJSON(e))
        : [],
      postParams: globalThis.Array.isArray(object?.postParams)
        ? object.postParams.map((e: any) => CMsgHttpRequest_QueryParam.fromJSON(e))
        : [],
      body: isSet(object.body) ? Buffer.from(bytesFromBase64(object.body)) : Buffer.alloc(0),
      absoluteTimeout: isSet(object.absoluteTimeout) ? globalThis.Number(object.absoluteTimeout) : 0,
      useHttps: isSet(object.useHttps) ? globalThis.Boolean(object.useHttps) : false,
    };
  },

  toJSON(message: CMsgHttpRequest): unknown {
    const obj: any = {};
    if (message.requestMethod !== undefined && message.requestMethod !== 0) {
      obj.requestMethod = Math.round(message.requestMethod);
    }
    if (message.hostname !== undefined && message.hostname !== "") {
      obj.hostname = message.hostname;
    }
    if (message.url !== undefined && message.url !== "") {
      obj.url = message.url;
    }
    if (message.headers?.length) {
      obj.headers = message.headers.map((e) => CMsgHttpRequest_RequestHeader.toJSON(e));
    }
    if (message.getParams?.length) {
      obj.getParams = message.getParams.map((e) => CMsgHttpRequest_QueryParam.toJSON(e));
    }
    if (message.postParams?.length) {
      obj.postParams = message.postParams.map((e) => CMsgHttpRequest_QueryParam.toJSON(e));
    }
    if (message.body !== undefined && message.body.length !== 0) {
      obj.body = base64FromBytes(message.body);
    }
    if (message.absoluteTimeout !== undefined && message.absoluteTimeout !== 0) {
      obj.absoluteTimeout = Math.round(message.absoluteTimeout);
    }
    if (message.useHttps !== undefined && message.useHttps !== false) {
      obj.useHttps = message.useHttps;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgHttpRequest>): CMsgHttpRequest {
    return CMsgHttpRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgHttpRequest>): CMsgHttpRequest {
    const message = createBaseCMsgHttpRequest();
    message.requestMethod = object.requestMethod ?? 0;
    message.hostname = object.hostname ?? "";
    message.url = object.url ?? "";
    message.headers = object.headers?.map((e) => CMsgHttpRequest_RequestHeader.fromPartial(e)) || [];
    message.getParams = object.getParams?.map((e) => CMsgHttpRequest_QueryParam.fromPartial(e)) || [];
    message.postParams = object.postParams?.map((e) => CMsgHttpRequest_QueryParam.fromPartial(e)) || [];
    message.body = object.body ?? Buffer.alloc(0);
    message.absoluteTimeout = object.absoluteTimeout ?? 0;
    message.useHttps = object.useHttps ?? false;
    return message;
  },
};

function createBaseCMsgHttpRequest_RequestHeader(): CMsgHttpRequest_RequestHeader {
  return { name: "", value: "" };
}

export const CMsgHttpRequest_RequestHeader = {
  encode(message: CMsgHttpRequest_RequestHeader, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.value !== undefined && message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgHttpRequest_RequestHeader {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgHttpRequest_RequestHeader();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgHttpRequest_RequestHeader {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: CMsgHttpRequest_RequestHeader): unknown {
    const obj: any = {};
    if (message.name !== undefined && message.name !== "") {
      obj.name = message.name;
    }
    if (message.value !== undefined && message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgHttpRequest_RequestHeader>): CMsgHttpRequest_RequestHeader {
    return CMsgHttpRequest_RequestHeader.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgHttpRequest_RequestHeader>): CMsgHttpRequest_RequestHeader {
    const message = createBaseCMsgHttpRequest_RequestHeader();
    message.name = object.name ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseCMsgHttpRequest_QueryParam(): CMsgHttpRequest_QueryParam {
  return { name: "", value: Buffer.alloc(0) };
}

export const CMsgHttpRequest_QueryParam = {
  encode(message: CMsgHttpRequest_QueryParam, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.value !== undefined && message.value.length !== 0) {
      writer.uint32(18).bytes(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgHttpRequest_QueryParam {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgHttpRequest_QueryParam();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgHttpRequest_QueryParam {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      value: isSet(object.value) ? Buffer.from(bytesFromBase64(object.value)) : Buffer.alloc(0),
    };
  },

  toJSON(message: CMsgHttpRequest_QueryParam): unknown {
    const obj: any = {};
    if (message.name !== undefined && message.name !== "") {
      obj.name = message.name;
    }
    if (message.value !== undefined && message.value.length !== 0) {
      obj.value = base64FromBytes(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgHttpRequest_QueryParam>): CMsgHttpRequest_QueryParam {
    return CMsgHttpRequest_QueryParam.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgHttpRequest_QueryParam>): CMsgHttpRequest_QueryParam {
    const message = createBaseCMsgHttpRequest_QueryParam();
    message.name = object.name ?? "";
    message.value = object.value ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseCMsgWebAPIRequest(): CMsgWebAPIRequest {
  return { interfaceName: "", methodName: "", version: 0, apiKey: undefined, request: undefined, routingAppId: 0 };
}

export const CMsgWebAPIRequest = {
  encode(message: CMsgWebAPIRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.interfaceName !== undefined && message.interfaceName !== "") {
      writer.uint32(18).string(message.interfaceName);
    }
    if (message.methodName !== undefined && message.methodName !== "") {
      writer.uint32(26).string(message.methodName);
    }
    if (message.version !== undefined && message.version !== 0) {
      writer.uint32(32).uint32(message.version);
    }
    if (message.apiKey !== undefined) {
      CMsgWebAPIKey.encode(message.apiKey, writer.uint32(42).fork()).ldelim();
    }
    if (message.request !== undefined) {
      CMsgHttpRequest.encode(message.request, writer.uint32(50).fork()).ldelim();
    }
    if (message.routingAppId !== undefined && message.routingAppId !== 0) {
      writer.uint32(56).uint32(message.routingAppId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgWebAPIRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgWebAPIRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.interfaceName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.methodName = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.version = reader.uint32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.apiKey = CMsgWebAPIKey.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.request = CMsgHttpRequest.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.routingAppId = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgWebAPIRequest {
    return {
      interfaceName: isSet(object.interfaceName) ? globalThis.String(object.interfaceName) : "",
      methodName: isSet(object.methodName) ? globalThis.String(object.methodName) : "",
      version: isSet(object.version) ? globalThis.Number(object.version) : 0,
      apiKey: isSet(object.apiKey) ? CMsgWebAPIKey.fromJSON(object.apiKey) : undefined,
      request: isSet(object.request) ? CMsgHttpRequest.fromJSON(object.request) : undefined,
      routingAppId: isSet(object.routingAppId) ? globalThis.Number(object.routingAppId) : 0,
    };
  },

  toJSON(message: CMsgWebAPIRequest): unknown {
    const obj: any = {};
    if (message.interfaceName !== undefined && message.interfaceName !== "") {
      obj.interfaceName = message.interfaceName;
    }
    if (message.methodName !== undefined && message.methodName !== "") {
      obj.methodName = message.methodName;
    }
    if (message.version !== undefined && message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    if (message.apiKey !== undefined) {
      obj.apiKey = CMsgWebAPIKey.toJSON(message.apiKey);
    }
    if (message.request !== undefined) {
      obj.request = CMsgHttpRequest.toJSON(message.request);
    }
    if (message.routingAppId !== undefined && message.routingAppId !== 0) {
      obj.routingAppId = Math.round(message.routingAppId);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgWebAPIRequest>): CMsgWebAPIRequest {
    return CMsgWebAPIRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgWebAPIRequest>): CMsgWebAPIRequest {
    const message = createBaseCMsgWebAPIRequest();
    message.interfaceName = object.interfaceName ?? "";
    message.methodName = object.methodName ?? "";
    message.version = object.version ?? 0;
    message.apiKey = (object.apiKey !== undefined && object.apiKey !== null)
      ? CMsgWebAPIKey.fromPartial(object.apiKey)
      : undefined;
    message.request = (object.request !== undefined && object.request !== null)
      ? CMsgHttpRequest.fromPartial(object.request)
      : undefined;
    message.routingAppId = object.routingAppId ?? 0;
    return message;
  },
};

function createBaseCMsgHttpResponse(): CMsgHttpResponse {
  return { statusCode: 0, headers: [], body: Buffer.alloc(0) };
}

export const CMsgHttpResponse = {
  encode(message: CMsgHttpResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.statusCode !== undefined && message.statusCode !== 0) {
      writer.uint32(8).uint32(message.statusCode);
    }
    for (const v of message.headers) {
      CMsgHttpResponse_ResponseHeader.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.body !== undefined && message.body.length !== 0) {
      writer.uint32(26).bytes(message.body);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgHttpResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgHttpResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.statusCode = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.headers.push(CMsgHttpResponse_ResponseHeader.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.body = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgHttpResponse {
    return {
      statusCode: isSet(object.statusCode) ? globalThis.Number(object.statusCode) : 0,
      headers: globalThis.Array.isArray(object?.headers)
        ? object.headers.map((e: any) => CMsgHttpResponse_ResponseHeader.fromJSON(e))
        : [],
      body: isSet(object.body) ? Buffer.from(bytesFromBase64(object.body)) : Buffer.alloc(0),
    };
  },

  toJSON(message: CMsgHttpResponse): unknown {
    const obj: any = {};
    if (message.statusCode !== undefined && message.statusCode !== 0) {
      obj.statusCode = Math.round(message.statusCode);
    }
    if (message.headers?.length) {
      obj.headers = message.headers.map((e) => CMsgHttpResponse_ResponseHeader.toJSON(e));
    }
    if (message.body !== undefined && message.body.length !== 0) {
      obj.body = base64FromBytes(message.body);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgHttpResponse>): CMsgHttpResponse {
    return CMsgHttpResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgHttpResponse>): CMsgHttpResponse {
    const message = createBaseCMsgHttpResponse();
    message.statusCode = object.statusCode ?? 0;
    message.headers = object.headers?.map((e) => CMsgHttpResponse_ResponseHeader.fromPartial(e)) || [];
    message.body = object.body ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseCMsgHttpResponse_ResponseHeader(): CMsgHttpResponse_ResponseHeader {
  return { name: "", value: "" };
}

export const CMsgHttpResponse_ResponseHeader = {
  encode(message: CMsgHttpResponse_ResponseHeader, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.value !== undefined && message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgHttpResponse_ResponseHeader {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgHttpResponse_ResponseHeader();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgHttpResponse_ResponseHeader {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: CMsgHttpResponse_ResponseHeader): unknown {
    const obj: any = {};
    if (message.name !== undefined && message.name !== "") {
      obj.name = message.name;
    }
    if (message.value !== undefined && message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgHttpResponse_ResponseHeader>): CMsgHttpResponse_ResponseHeader {
    return CMsgHttpResponse_ResponseHeader.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgHttpResponse_ResponseHeader>): CMsgHttpResponse_ResponseHeader {
    const message = createBaseCMsgHttpResponse_ResponseHeader();
    message.name = object.name ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseCMsgAMFindAccounts(): CMsgAMFindAccounts {
  return { searchType: 0, searchString: "" };
}

export const CMsgAMFindAccounts = {
  encode(message: CMsgAMFindAccounts, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.searchType !== undefined && message.searchType !== 0) {
      writer.uint32(8).uint32(message.searchType);
    }
    if (message.searchString !== undefined && message.searchString !== "") {
      writer.uint32(18).string(message.searchString);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgAMFindAccounts {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgAMFindAccounts();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.searchType = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.searchString = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgAMFindAccounts {
    return {
      searchType: isSet(object.searchType) ? globalThis.Number(object.searchType) : 0,
      searchString: isSet(object.searchString) ? globalThis.String(object.searchString) : "",
    };
  },

  toJSON(message: CMsgAMFindAccounts): unknown {
    const obj: any = {};
    if (message.searchType !== undefined && message.searchType !== 0) {
      obj.searchType = Math.round(message.searchType);
    }
    if (message.searchString !== undefined && message.searchString !== "") {
      obj.searchString = message.searchString;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgAMFindAccounts>): CMsgAMFindAccounts {
    return CMsgAMFindAccounts.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgAMFindAccounts>): CMsgAMFindAccounts {
    const message = createBaseCMsgAMFindAccounts();
    message.searchType = object.searchType ?? 0;
    message.searchString = object.searchString ?? "";
    return message;
  },
};

function createBaseCMsgAMFindAccountsResponse(): CMsgAMFindAccountsResponse {
  return { steamId: [] };
}

export const CMsgAMFindAccountsResponse = {
  encode(message: CMsgAMFindAccountsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.steamId) {
      writer.fixed64(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgAMFindAccountsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgAMFindAccountsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 9) {
            message.steamId.push(longToString(reader.fixed64() as Long));

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.steamId.push(longToString(reader.fixed64() as Long));
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgAMFindAccountsResponse {
    return {
      steamId: globalThis.Array.isArray(object?.steamId) ? object.steamId.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: CMsgAMFindAccountsResponse): unknown {
    const obj: any = {};
    if (message.steamId?.length) {
      obj.steamId = message.steamId;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgAMFindAccountsResponse>): CMsgAMFindAccountsResponse {
    return CMsgAMFindAccountsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgAMFindAccountsResponse>): CMsgAMFindAccountsResponse {
    const message = createBaseCMsgAMFindAccountsResponse();
    message.steamId = object.steamId?.map((e) => e) || [];
    return message;
  },
};

function createBaseCMsgNotifyWatchdog(): CMsgNotifyWatchdog {
  return { source: 0, alertType: 0, critical: false, time: 0, appid: 0, text: "", recipient: "" };
}

export const CMsgNotifyWatchdog = {
  encode(message: CMsgNotifyWatchdog, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.source !== undefined && message.source !== 0) {
      writer.uint32(8).uint32(message.source);
    }
    if (message.alertType !== undefined && message.alertType !== 0) {
      writer.uint32(16).uint32(message.alertType);
    }
    if (message.critical !== undefined && message.critical !== false) {
      writer.uint32(32).bool(message.critical);
    }
    if (message.time !== undefined && message.time !== 0) {
      writer.uint32(40).uint32(message.time);
    }
    if (message.appid !== undefined && message.appid !== 0) {
      writer.uint32(48).uint32(message.appid);
    }
    if (message.text !== undefined && message.text !== "") {
      writer.uint32(58).string(message.text);
    }
    if (message.recipient !== undefined && message.recipient !== "") {
      writer.uint32(98).string(message.recipient);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgNotifyWatchdog {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgNotifyWatchdog();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.source = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.alertType = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.critical = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.time = reader.uint32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.appid = reader.uint32();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.text = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.recipient = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgNotifyWatchdog {
    return {
      source: isSet(object.source) ? globalThis.Number(object.source) : 0,
      alertType: isSet(object.alertType) ? globalThis.Number(object.alertType) : 0,
      critical: isSet(object.critical) ? globalThis.Boolean(object.critical) : false,
      time: isSet(object.time) ? globalThis.Number(object.time) : 0,
      appid: isSet(object.appid) ? globalThis.Number(object.appid) : 0,
      text: isSet(object.text) ? globalThis.String(object.text) : "",
      recipient: isSet(object.recipient) ? globalThis.String(object.recipient) : "",
    };
  },

  toJSON(message: CMsgNotifyWatchdog): unknown {
    const obj: any = {};
    if (message.source !== undefined && message.source !== 0) {
      obj.source = Math.round(message.source);
    }
    if (message.alertType !== undefined && message.alertType !== 0) {
      obj.alertType = Math.round(message.alertType);
    }
    if (message.critical !== undefined && message.critical !== false) {
      obj.critical = message.critical;
    }
    if (message.time !== undefined && message.time !== 0) {
      obj.time = Math.round(message.time);
    }
    if (message.appid !== undefined && message.appid !== 0) {
      obj.appid = Math.round(message.appid);
    }
    if (message.text !== undefined && message.text !== "") {
      obj.text = message.text;
    }
    if (message.recipient !== undefined && message.recipient !== "") {
      obj.recipient = message.recipient;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgNotifyWatchdog>): CMsgNotifyWatchdog {
    return CMsgNotifyWatchdog.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgNotifyWatchdog>): CMsgNotifyWatchdog {
    const message = createBaseCMsgNotifyWatchdog();
    message.source = object.source ?? 0;
    message.alertType = object.alertType ?? 0;
    message.critical = object.critical ?? false;
    message.time = object.time ?? 0;
    message.appid = object.appid ?? 0;
    message.text = object.text ?? "";
    message.recipient = object.recipient ?? "";
    return message;
  },
};

function createBaseCMsgAMGetLicenses(): CMsgAMGetLicenses {
  return { steamid: "0" };
}

export const CMsgAMGetLicenses = {
  encode(message: CMsgAMGetLicenses, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.steamid !== undefined && message.steamid !== "0") {
      writer.uint32(9).fixed64(message.steamid);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgAMGetLicenses {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgAMGetLicenses();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.steamid = longToString(reader.fixed64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgAMGetLicenses {
    return { steamid: isSet(object.steamid) ? globalThis.String(object.steamid) : "0" };
  },

  toJSON(message: CMsgAMGetLicenses): unknown {
    const obj: any = {};
    if (message.steamid !== undefined && message.steamid !== "0") {
      obj.steamid = message.steamid;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgAMGetLicenses>): CMsgAMGetLicenses {
    return CMsgAMGetLicenses.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgAMGetLicenses>): CMsgAMGetLicenses {
    const message = createBaseCMsgAMGetLicenses();
    message.steamid = object.steamid ?? "0";
    return message;
  },
};

function createBaseCMsgPackageLicense(): CMsgPackageLicense {
  return { packageId: 0, timeCreated: 0, ownerId: 0 };
}

export const CMsgPackageLicense = {
  encode(message: CMsgPackageLicense, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.packageId !== undefined && message.packageId !== 0) {
      writer.uint32(8).uint32(message.packageId);
    }
    if (message.timeCreated !== undefined && message.timeCreated !== 0) {
      writer.uint32(16).uint32(message.timeCreated);
    }
    if (message.ownerId !== undefined && message.ownerId !== 0) {
      writer.uint32(24).uint32(message.ownerId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgPackageLicense {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgPackageLicense();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.packageId = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.timeCreated = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.ownerId = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgPackageLicense {
    return {
      packageId: isSet(object.packageId) ? globalThis.Number(object.packageId) : 0,
      timeCreated: isSet(object.timeCreated) ? globalThis.Number(object.timeCreated) : 0,
      ownerId: isSet(object.ownerId) ? globalThis.Number(object.ownerId) : 0,
    };
  },

  toJSON(message: CMsgPackageLicense): unknown {
    const obj: any = {};
    if (message.packageId !== undefined && message.packageId !== 0) {
      obj.packageId = Math.round(message.packageId);
    }
    if (message.timeCreated !== undefined && message.timeCreated !== 0) {
      obj.timeCreated = Math.round(message.timeCreated);
    }
    if (message.ownerId !== undefined && message.ownerId !== 0) {
      obj.ownerId = Math.round(message.ownerId);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgPackageLicense>): CMsgPackageLicense {
    return CMsgPackageLicense.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgPackageLicense>): CMsgPackageLicense {
    const message = createBaseCMsgPackageLicense();
    message.packageId = object.packageId ?? 0;
    message.timeCreated = object.timeCreated ?? 0;
    message.ownerId = object.ownerId ?? 0;
    return message;
  },
};

function createBaseCMsgAMGetLicensesResponse(): CMsgAMGetLicensesResponse {
  return { license: [], result: 0 };
}

export const CMsgAMGetLicensesResponse = {
  encode(message: CMsgAMGetLicensesResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.license) {
      CMsgPackageLicense.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.result !== undefined && message.result !== 0) {
      writer.uint32(16).uint32(message.result);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgAMGetLicensesResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgAMGetLicensesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.license.push(CMsgPackageLicense.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.result = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgAMGetLicensesResponse {
    return {
      license: globalThis.Array.isArray(object?.license)
        ? object.license.map((e: any) => CMsgPackageLicense.fromJSON(e))
        : [],
      result: isSet(object.result) ? globalThis.Number(object.result) : 0,
    };
  },

  toJSON(message: CMsgAMGetLicensesResponse): unknown {
    const obj: any = {};
    if (message.license?.length) {
      obj.license = message.license.map((e) => CMsgPackageLicense.toJSON(e));
    }
    if (message.result !== undefined && message.result !== 0) {
      obj.result = Math.round(message.result);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgAMGetLicensesResponse>): CMsgAMGetLicensesResponse {
    return CMsgAMGetLicensesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgAMGetLicensesResponse>): CMsgAMGetLicensesResponse {
    const message = createBaseCMsgAMGetLicensesResponse();
    message.license = object.license?.map((e) => CMsgPackageLicense.fromPartial(e)) || [];
    message.result = object.result ?? 0;
    return message;
  },
};

function createBaseCMsgGCGetCommandList(): CMsgGCGetCommandList {
  return { appId: 0, commandPrefix: "" };
}

export const CMsgGCGetCommandList = {
  encode(message: CMsgGCGetCommandList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.appId !== undefined && message.appId !== 0) {
      writer.uint32(8).uint32(message.appId);
    }
    if (message.commandPrefix !== undefined && message.commandPrefix !== "") {
      writer.uint32(18).string(message.commandPrefix);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCGetCommandList {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCGetCommandList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.appId = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.commandPrefix = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCGetCommandList {
    return {
      appId: isSet(object.appId) ? globalThis.Number(object.appId) : 0,
      commandPrefix: isSet(object.commandPrefix) ? globalThis.String(object.commandPrefix) : "",
    };
  },

  toJSON(message: CMsgGCGetCommandList): unknown {
    const obj: any = {};
    if (message.appId !== undefined && message.appId !== 0) {
      obj.appId = Math.round(message.appId);
    }
    if (message.commandPrefix !== undefined && message.commandPrefix !== "") {
      obj.commandPrefix = message.commandPrefix;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCGetCommandList>): CMsgGCGetCommandList {
    return CMsgGCGetCommandList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCGetCommandList>): CMsgGCGetCommandList {
    const message = createBaseCMsgGCGetCommandList();
    message.appId = object.appId ?? 0;
    message.commandPrefix = object.commandPrefix ?? "";
    return message;
  },
};

function createBaseCMsgGCGetCommandListResponse(): CMsgGCGetCommandListResponse {
  return { commandName: [] };
}

export const CMsgGCGetCommandListResponse = {
  encode(message: CMsgGCGetCommandListResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.commandName) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCGetCommandListResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCGetCommandListResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.commandName.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCGetCommandListResponse {
    return {
      commandName: globalThis.Array.isArray(object?.commandName)
        ? object.commandName.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: CMsgGCGetCommandListResponse): unknown {
    const obj: any = {};
    if (message.commandName?.length) {
      obj.commandName = message.commandName;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCGetCommandListResponse>): CMsgGCGetCommandListResponse {
    return CMsgGCGetCommandListResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCGetCommandListResponse>): CMsgGCGetCommandListResponse {
    const message = createBaseCMsgGCGetCommandListResponse();
    message.commandName = object.commandName?.map((e) => e) || [];
    return message;
  },
};

function createBaseCGCMsgMemCachedGet(): CGCMsgMemCachedGet {
  return { keys: [] };
}

export const CGCMsgMemCachedGet = {
  encode(message: CGCMsgMemCachedGet, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.keys) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CGCMsgMemCachedGet {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCGCMsgMemCachedGet();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.keys.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CGCMsgMemCachedGet {
    return { keys: globalThis.Array.isArray(object?.keys) ? object.keys.map((e: any) => globalThis.String(e)) : [] };
  },

  toJSON(message: CGCMsgMemCachedGet): unknown {
    const obj: any = {};
    if (message.keys?.length) {
      obj.keys = message.keys;
    }
    return obj;
  },

  create(base?: DeepPartial<CGCMsgMemCachedGet>): CGCMsgMemCachedGet {
    return CGCMsgMemCachedGet.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CGCMsgMemCachedGet>): CGCMsgMemCachedGet {
    const message = createBaseCGCMsgMemCachedGet();
    message.keys = object.keys?.map((e) => e) || [];
    return message;
  },
};

function createBaseCGCMsgMemCachedGetResponse(): CGCMsgMemCachedGetResponse {
  return { values: [] };
}

export const CGCMsgMemCachedGetResponse = {
  encode(message: CGCMsgMemCachedGetResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.values) {
      CGCMsgMemCachedGetResponse_ValueTag.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CGCMsgMemCachedGetResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCGCMsgMemCachedGetResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.values.push(CGCMsgMemCachedGetResponse_ValueTag.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CGCMsgMemCachedGetResponse {
    return {
      values: globalThis.Array.isArray(object?.values)
        ? object.values.map((e: any) => CGCMsgMemCachedGetResponse_ValueTag.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CGCMsgMemCachedGetResponse): unknown {
    const obj: any = {};
    if (message.values?.length) {
      obj.values = message.values.map((e) => CGCMsgMemCachedGetResponse_ValueTag.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CGCMsgMemCachedGetResponse>): CGCMsgMemCachedGetResponse {
    return CGCMsgMemCachedGetResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CGCMsgMemCachedGetResponse>): CGCMsgMemCachedGetResponse {
    const message = createBaseCGCMsgMemCachedGetResponse();
    message.values = object.values?.map((e) => CGCMsgMemCachedGetResponse_ValueTag.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCGCMsgMemCachedGetResponse_ValueTag(): CGCMsgMemCachedGetResponse_ValueTag {
  return { found: false, value: Buffer.alloc(0) };
}

export const CGCMsgMemCachedGetResponse_ValueTag = {
  encode(message: CGCMsgMemCachedGetResponse_ValueTag, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.found !== undefined && message.found !== false) {
      writer.uint32(8).bool(message.found);
    }
    if (message.value !== undefined && message.value.length !== 0) {
      writer.uint32(18).bytes(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CGCMsgMemCachedGetResponse_ValueTag {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCGCMsgMemCachedGetResponse_ValueTag();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.found = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CGCMsgMemCachedGetResponse_ValueTag {
    return {
      found: isSet(object.found) ? globalThis.Boolean(object.found) : false,
      value: isSet(object.value) ? Buffer.from(bytesFromBase64(object.value)) : Buffer.alloc(0),
    };
  },

  toJSON(message: CGCMsgMemCachedGetResponse_ValueTag): unknown {
    const obj: any = {};
    if (message.found !== undefined && message.found !== false) {
      obj.found = message.found;
    }
    if (message.value !== undefined && message.value.length !== 0) {
      obj.value = base64FromBytes(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<CGCMsgMemCachedGetResponse_ValueTag>): CGCMsgMemCachedGetResponse_ValueTag {
    return CGCMsgMemCachedGetResponse_ValueTag.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CGCMsgMemCachedGetResponse_ValueTag>): CGCMsgMemCachedGetResponse_ValueTag {
    const message = createBaseCGCMsgMemCachedGetResponse_ValueTag();
    message.found = object.found ?? false;
    message.value = object.value ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseCGCMsgMemCachedSet(): CGCMsgMemCachedSet {
  return { keys: [] };
}

export const CGCMsgMemCachedSet = {
  encode(message: CGCMsgMemCachedSet, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.keys) {
      CGCMsgMemCachedSet_KeyPair.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CGCMsgMemCachedSet {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCGCMsgMemCachedSet();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.keys.push(CGCMsgMemCachedSet_KeyPair.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CGCMsgMemCachedSet {
    return {
      keys: globalThis.Array.isArray(object?.keys)
        ? object.keys.map((e: any) => CGCMsgMemCachedSet_KeyPair.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CGCMsgMemCachedSet): unknown {
    const obj: any = {};
    if (message.keys?.length) {
      obj.keys = message.keys.map((e) => CGCMsgMemCachedSet_KeyPair.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CGCMsgMemCachedSet>): CGCMsgMemCachedSet {
    return CGCMsgMemCachedSet.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CGCMsgMemCachedSet>): CGCMsgMemCachedSet {
    const message = createBaseCGCMsgMemCachedSet();
    message.keys = object.keys?.map((e) => CGCMsgMemCachedSet_KeyPair.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCGCMsgMemCachedSet_KeyPair(): CGCMsgMemCachedSet_KeyPair {
  return { name: "", value: Buffer.alloc(0) };
}

export const CGCMsgMemCachedSet_KeyPair = {
  encode(message: CGCMsgMemCachedSet_KeyPair, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.value !== undefined && message.value.length !== 0) {
      writer.uint32(18).bytes(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CGCMsgMemCachedSet_KeyPair {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCGCMsgMemCachedSet_KeyPair();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CGCMsgMemCachedSet_KeyPair {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      value: isSet(object.value) ? Buffer.from(bytesFromBase64(object.value)) : Buffer.alloc(0),
    };
  },

  toJSON(message: CGCMsgMemCachedSet_KeyPair): unknown {
    const obj: any = {};
    if (message.name !== undefined && message.name !== "") {
      obj.name = message.name;
    }
    if (message.value !== undefined && message.value.length !== 0) {
      obj.value = base64FromBytes(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<CGCMsgMemCachedSet_KeyPair>): CGCMsgMemCachedSet_KeyPair {
    return CGCMsgMemCachedSet_KeyPair.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CGCMsgMemCachedSet_KeyPair>): CGCMsgMemCachedSet_KeyPair {
    const message = createBaseCGCMsgMemCachedSet_KeyPair();
    message.name = object.name ?? "";
    message.value = object.value ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseCGCMsgMemCachedDelete(): CGCMsgMemCachedDelete {
  return { keys: [] };
}

export const CGCMsgMemCachedDelete = {
  encode(message: CGCMsgMemCachedDelete, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.keys) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CGCMsgMemCachedDelete {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCGCMsgMemCachedDelete();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.keys.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CGCMsgMemCachedDelete {
    return { keys: globalThis.Array.isArray(object?.keys) ? object.keys.map((e: any) => globalThis.String(e)) : [] };
  },

  toJSON(message: CGCMsgMemCachedDelete): unknown {
    const obj: any = {};
    if (message.keys?.length) {
      obj.keys = message.keys;
    }
    return obj;
  },

  create(base?: DeepPartial<CGCMsgMemCachedDelete>): CGCMsgMemCachedDelete {
    return CGCMsgMemCachedDelete.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CGCMsgMemCachedDelete>): CGCMsgMemCachedDelete {
    const message = createBaseCGCMsgMemCachedDelete();
    message.keys = object.keys?.map((e) => e) || [];
    return message;
  },
};

function createBaseCGCMsgMemCachedStats(): CGCMsgMemCachedStats {
  return {};
}

export const CGCMsgMemCachedStats = {
  encode(_: CGCMsgMemCachedStats, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CGCMsgMemCachedStats {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCGCMsgMemCachedStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CGCMsgMemCachedStats {
    return {};
  },

  toJSON(_: CGCMsgMemCachedStats): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<CGCMsgMemCachedStats>): CGCMsgMemCachedStats {
    return CGCMsgMemCachedStats.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<CGCMsgMemCachedStats>): CGCMsgMemCachedStats {
    const message = createBaseCGCMsgMemCachedStats();
    return message;
  },
};

function createBaseCGCMsgMemCachedStatsResponse(): CGCMsgMemCachedStatsResponse {
  return {
    currConnections: "0",
    cmdGet: "0",
    cmdSet: "0",
    cmdFlush: "0",
    getHits: "0",
    getMisses: "0",
    deleteHits: "0",
    deleteMisses: "0",
    bytesRead: "0",
    bytesWritten: "0",
    limitMaxbytes: "0",
    currItems: "0",
    evictions: "0",
    bytes: "0",
  };
}

export const CGCMsgMemCachedStatsResponse = {
  encode(message: CGCMsgMemCachedStatsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.currConnections !== undefined && message.currConnections !== "0") {
      writer.uint32(8).uint64(message.currConnections);
    }
    if (message.cmdGet !== undefined && message.cmdGet !== "0") {
      writer.uint32(16).uint64(message.cmdGet);
    }
    if (message.cmdSet !== undefined && message.cmdSet !== "0") {
      writer.uint32(24).uint64(message.cmdSet);
    }
    if (message.cmdFlush !== undefined && message.cmdFlush !== "0") {
      writer.uint32(32).uint64(message.cmdFlush);
    }
    if (message.getHits !== undefined && message.getHits !== "0") {
      writer.uint32(40).uint64(message.getHits);
    }
    if (message.getMisses !== undefined && message.getMisses !== "0") {
      writer.uint32(48).uint64(message.getMisses);
    }
    if (message.deleteHits !== undefined && message.deleteHits !== "0") {
      writer.uint32(56).uint64(message.deleteHits);
    }
    if (message.deleteMisses !== undefined && message.deleteMisses !== "0") {
      writer.uint32(64).uint64(message.deleteMisses);
    }
    if (message.bytesRead !== undefined && message.bytesRead !== "0") {
      writer.uint32(72).uint64(message.bytesRead);
    }
    if (message.bytesWritten !== undefined && message.bytesWritten !== "0") {
      writer.uint32(80).uint64(message.bytesWritten);
    }
    if (message.limitMaxbytes !== undefined && message.limitMaxbytes !== "0") {
      writer.uint32(88).uint64(message.limitMaxbytes);
    }
    if (message.currItems !== undefined && message.currItems !== "0") {
      writer.uint32(96).uint64(message.currItems);
    }
    if (message.evictions !== undefined && message.evictions !== "0") {
      writer.uint32(104).uint64(message.evictions);
    }
    if (message.bytes !== undefined && message.bytes !== "0") {
      writer.uint32(112).uint64(message.bytes);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CGCMsgMemCachedStatsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCGCMsgMemCachedStatsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.currConnections = longToString(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.cmdGet = longToString(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.cmdSet = longToString(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.cmdFlush = longToString(reader.uint64() as Long);
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.getHits = longToString(reader.uint64() as Long);
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.getMisses = longToString(reader.uint64() as Long);
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.deleteHits = longToString(reader.uint64() as Long);
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.deleteMisses = longToString(reader.uint64() as Long);
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.bytesRead = longToString(reader.uint64() as Long);
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.bytesWritten = longToString(reader.uint64() as Long);
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.limitMaxbytes = longToString(reader.uint64() as Long);
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.currItems = longToString(reader.uint64() as Long);
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.evictions = longToString(reader.uint64() as Long);
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.bytes = longToString(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CGCMsgMemCachedStatsResponse {
    return {
      currConnections: isSet(object.currConnections) ? globalThis.String(object.currConnections) : "0",
      cmdGet: isSet(object.cmdGet) ? globalThis.String(object.cmdGet) : "0",
      cmdSet: isSet(object.cmdSet) ? globalThis.String(object.cmdSet) : "0",
      cmdFlush: isSet(object.cmdFlush) ? globalThis.String(object.cmdFlush) : "0",
      getHits: isSet(object.getHits) ? globalThis.String(object.getHits) : "0",
      getMisses: isSet(object.getMisses) ? globalThis.String(object.getMisses) : "0",
      deleteHits: isSet(object.deleteHits) ? globalThis.String(object.deleteHits) : "0",
      deleteMisses: isSet(object.deleteMisses) ? globalThis.String(object.deleteMisses) : "0",
      bytesRead: isSet(object.bytesRead) ? globalThis.String(object.bytesRead) : "0",
      bytesWritten: isSet(object.bytesWritten) ? globalThis.String(object.bytesWritten) : "0",
      limitMaxbytes: isSet(object.limitMaxbytes) ? globalThis.String(object.limitMaxbytes) : "0",
      currItems: isSet(object.currItems) ? globalThis.String(object.currItems) : "0",
      evictions: isSet(object.evictions) ? globalThis.String(object.evictions) : "0",
      bytes: isSet(object.bytes) ? globalThis.String(object.bytes) : "0",
    };
  },

  toJSON(message: CGCMsgMemCachedStatsResponse): unknown {
    const obj: any = {};
    if (message.currConnections !== undefined && message.currConnections !== "0") {
      obj.currConnections = message.currConnections;
    }
    if (message.cmdGet !== undefined && message.cmdGet !== "0") {
      obj.cmdGet = message.cmdGet;
    }
    if (message.cmdSet !== undefined && message.cmdSet !== "0") {
      obj.cmdSet = message.cmdSet;
    }
    if (message.cmdFlush !== undefined && message.cmdFlush !== "0") {
      obj.cmdFlush = message.cmdFlush;
    }
    if (message.getHits !== undefined && message.getHits !== "0") {
      obj.getHits = message.getHits;
    }
    if (message.getMisses !== undefined && message.getMisses !== "0") {
      obj.getMisses = message.getMisses;
    }
    if (message.deleteHits !== undefined && message.deleteHits !== "0") {
      obj.deleteHits = message.deleteHits;
    }
    if (message.deleteMisses !== undefined && message.deleteMisses !== "0") {
      obj.deleteMisses = message.deleteMisses;
    }
    if (message.bytesRead !== undefined && message.bytesRead !== "0") {
      obj.bytesRead = message.bytesRead;
    }
    if (message.bytesWritten !== undefined && message.bytesWritten !== "0") {
      obj.bytesWritten = message.bytesWritten;
    }
    if (message.limitMaxbytes !== undefined && message.limitMaxbytes !== "0") {
      obj.limitMaxbytes = message.limitMaxbytes;
    }
    if (message.currItems !== undefined && message.currItems !== "0") {
      obj.currItems = message.currItems;
    }
    if (message.evictions !== undefined && message.evictions !== "0") {
      obj.evictions = message.evictions;
    }
    if (message.bytes !== undefined && message.bytes !== "0") {
      obj.bytes = message.bytes;
    }
    return obj;
  },

  create(base?: DeepPartial<CGCMsgMemCachedStatsResponse>): CGCMsgMemCachedStatsResponse {
    return CGCMsgMemCachedStatsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CGCMsgMemCachedStatsResponse>): CGCMsgMemCachedStatsResponse {
    const message = createBaseCGCMsgMemCachedStatsResponse();
    message.currConnections = object.currConnections ?? "0";
    message.cmdGet = object.cmdGet ?? "0";
    message.cmdSet = object.cmdSet ?? "0";
    message.cmdFlush = object.cmdFlush ?? "0";
    message.getHits = object.getHits ?? "0";
    message.getMisses = object.getMisses ?? "0";
    message.deleteHits = object.deleteHits ?? "0";
    message.deleteMisses = object.deleteMisses ?? "0";
    message.bytesRead = object.bytesRead ?? "0";
    message.bytesWritten = object.bytesWritten ?? "0";
    message.limitMaxbytes = object.limitMaxbytes ?? "0";
    message.currItems = object.currItems ?? "0";
    message.evictions = object.evictions ?? "0";
    message.bytes = object.bytes ?? "0";
    return message;
  },
};

function createBaseCGCMsgSQLStats(): CGCMsgSQLStats {
  return { schemaCatalog: 0 };
}

export const CGCMsgSQLStats = {
  encode(message: CGCMsgSQLStats, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.schemaCatalog !== undefined && message.schemaCatalog !== 0) {
      writer.uint32(8).uint32(message.schemaCatalog);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CGCMsgSQLStats {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCGCMsgSQLStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.schemaCatalog = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CGCMsgSQLStats {
    return { schemaCatalog: isSet(object.schemaCatalog) ? globalThis.Number(object.schemaCatalog) : 0 };
  },

  toJSON(message: CGCMsgSQLStats): unknown {
    const obj: any = {};
    if (message.schemaCatalog !== undefined && message.schemaCatalog !== 0) {
      obj.schemaCatalog = Math.round(message.schemaCatalog);
    }
    return obj;
  },

  create(base?: DeepPartial<CGCMsgSQLStats>): CGCMsgSQLStats {
    return CGCMsgSQLStats.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CGCMsgSQLStats>): CGCMsgSQLStats {
    const message = createBaseCGCMsgSQLStats();
    message.schemaCatalog = object.schemaCatalog ?? 0;
    return message;
  },
};

function createBaseCGCMsgSQLStatsResponse(): CGCMsgSQLStatsResponse {
  return {
    threads: 0,
    threadsConnected: 0,
    threadsActive: 0,
    operationsSubmitted: 0,
    preparedStatementsExecuted: 0,
    nonPreparedStatementsExecuted: 0,
    deadlockRetries: 0,
    operationsTimedOutInQueue: 0,
    errors: 0,
  };
}

export const CGCMsgSQLStatsResponse = {
  encode(message: CGCMsgSQLStatsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.threads !== undefined && message.threads !== 0) {
      writer.uint32(8).uint32(message.threads);
    }
    if (message.threadsConnected !== undefined && message.threadsConnected !== 0) {
      writer.uint32(16).uint32(message.threadsConnected);
    }
    if (message.threadsActive !== undefined && message.threadsActive !== 0) {
      writer.uint32(24).uint32(message.threadsActive);
    }
    if (message.operationsSubmitted !== undefined && message.operationsSubmitted !== 0) {
      writer.uint32(32).uint32(message.operationsSubmitted);
    }
    if (message.preparedStatementsExecuted !== undefined && message.preparedStatementsExecuted !== 0) {
      writer.uint32(40).uint32(message.preparedStatementsExecuted);
    }
    if (message.nonPreparedStatementsExecuted !== undefined && message.nonPreparedStatementsExecuted !== 0) {
      writer.uint32(48).uint32(message.nonPreparedStatementsExecuted);
    }
    if (message.deadlockRetries !== undefined && message.deadlockRetries !== 0) {
      writer.uint32(56).uint32(message.deadlockRetries);
    }
    if (message.operationsTimedOutInQueue !== undefined && message.operationsTimedOutInQueue !== 0) {
      writer.uint32(64).uint32(message.operationsTimedOutInQueue);
    }
    if (message.errors !== undefined && message.errors !== 0) {
      writer.uint32(72).uint32(message.errors);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CGCMsgSQLStatsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCGCMsgSQLStatsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.threads = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.threadsConnected = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.threadsActive = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.operationsSubmitted = reader.uint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.preparedStatementsExecuted = reader.uint32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.nonPreparedStatementsExecuted = reader.uint32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.deadlockRetries = reader.uint32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.operationsTimedOutInQueue = reader.uint32();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.errors = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CGCMsgSQLStatsResponse {
    return {
      threads: isSet(object.threads) ? globalThis.Number(object.threads) : 0,
      threadsConnected: isSet(object.threadsConnected) ? globalThis.Number(object.threadsConnected) : 0,
      threadsActive: isSet(object.threadsActive) ? globalThis.Number(object.threadsActive) : 0,
      operationsSubmitted: isSet(object.operationsSubmitted) ? globalThis.Number(object.operationsSubmitted) : 0,
      preparedStatementsExecuted: isSet(object.preparedStatementsExecuted)
        ? globalThis.Number(object.preparedStatementsExecuted)
        : 0,
      nonPreparedStatementsExecuted: isSet(object.nonPreparedStatementsExecuted)
        ? globalThis.Number(object.nonPreparedStatementsExecuted)
        : 0,
      deadlockRetries: isSet(object.deadlockRetries) ? globalThis.Number(object.deadlockRetries) : 0,
      operationsTimedOutInQueue: isSet(object.operationsTimedOutInQueue)
        ? globalThis.Number(object.operationsTimedOutInQueue)
        : 0,
      errors: isSet(object.errors) ? globalThis.Number(object.errors) : 0,
    };
  },

  toJSON(message: CGCMsgSQLStatsResponse): unknown {
    const obj: any = {};
    if (message.threads !== undefined && message.threads !== 0) {
      obj.threads = Math.round(message.threads);
    }
    if (message.threadsConnected !== undefined && message.threadsConnected !== 0) {
      obj.threadsConnected = Math.round(message.threadsConnected);
    }
    if (message.threadsActive !== undefined && message.threadsActive !== 0) {
      obj.threadsActive = Math.round(message.threadsActive);
    }
    if (message.operationsSubmitted !== undefined && message.operationsSubmitted !== 0) {
      obj.operationsSubmitted = Math.round(message.operationsSubmitted);
    }
    if (message.preparedStatementsExecuted !== undefined && message.preparedStatementsExecuted !== 0) {
      obj.preparedStatementsExecuted = Math.round(message.preparedStatementsExecuted);
    }
    if (message.nonPreparedStatementsExecuted !== undefined && message.nonPreparedStatementsExecuted !== 0) {
      obj.nonPreparedStatementsExecuted = Math.round(message.nonPreparedStatementsExecuted);
    }
    if (message.deadlockRetries !== undefined && message.deadlockRetries !== 0) {
      obj.deadlockRetries = Math.round(message.deadlockRetries);
    }
    if (message.operationsTimedOutInQueue !== undefined && message.operationsTimedOutInQueue !== 0) {
      obj.operationsTimedOutInQueue = Math.round(message.operationsTimedOutInQueue);
    }
    if (message.errors !== undefined && message.errors !== 0) {
      obj.errors = Math.round(message.errors);
    }
    return obj;
  },

  create(base?: DeepPartial<CGCMsgSQLStatsResponse>): CGCMsgSQLStatsResponse {
    return CGCMsgSQLStatsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CGCMsgSQLStatsResponse>): CGCMsgSQLStatsResponse {
    const message = createBaseCGCMsgSQLStatsResponse();
    message.threads = object.threads ?? 0;
    message.threadsConnected = object.threadsConnected ?? 0;
    message.threadsActive = object.threadsActive ?? 0;
    message.operationsSubmitted = object.operationsSubmitted ?? 0;
    message.preparedStatementsExecuted = object.preparedStatementsExecuted ?? 0;
    message.nonPreparedStatementsExecuted = object.nonPreparedStatementsExecuted ?? 0;
    message.deadlockRetries = object.deadlockRetries ?? 0;
    message.operationsTimedOutInQueue = object.operationsTimedOutInQueue ?? 0;
    message.errors = object.errors ?? 0;
    return message;
  },
};

function createBaseCMsgAMAddFreeLicense(): CMsgAMAddFreeLicense {
  return { steamid: "0", ipPublic: 0, packageid: 0, storeCountryCode: "" };
}

export const CMsgAMAddFreeLicense = {
  encode(message: CMsgAMAddFreeLicense, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.steamid !== undefined && message.steamid !== "0") {
      writer.uint32(9).fixed64(message.steamid);
    }
    if (message.ipPublic !== undefined && message.ipPublic !== 0) {
      writer.uint32(16).uint32(message.ipPublic);
    }
    if (message.packageid !== undefined && message.packageid !== 0) {
      writer.uint32(24).uint32(message.packageid);
    }
    if (message.storeCountryCode !== undefined && message.storeCountryCode !== "") {
      writer.uint32(34).string(message.storeCountryCode);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgAMAddFreeLicense {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgAMAddFreeLicense();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.steamid = longToString(reader.fixed64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.ipPublic = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.packageid = reader.uint32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.storeCountryCode = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgAMAddFreeLicense {
    return {
      steamid: isSet(object.steamid) ? globalThis.String(object.steamid) : "0",
      ipPublic: isSet(object.ipPublic) ? globalThis.Number(object.ipPublic) : 0,
      packageid: isSet(object.packageid) ? globalThis.Number(object.packageid) : 0,
      storeCountryCode: isSet(object.storeCountryCode) ? globalThis.String(object.storeCountryCode) : "",
    };
  },

  toJSON(message: CMsgAMAddFreeLicense): unknown {
    const obj: any = {};
    if (message.steamid !== undefined && message.steamid !== "0") {
      obj.steamid = message.steamid;
    }
    if (message.ipPublic !== undefined && message.ipPublic !== 0) {
      obj.ipPublic = Math.round(message.ipPublic);
    }
    if (message.packageid !== undefined && message.packageid !== 0) {
      obj.packageid = Math.round(message.packageid);
    }
    if (message.storeCountryCode !== undefined && message.storeCountryCode !== "") {
      obj.storeCountryCode = message.storeCountryCode;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgAMAddFreeLicense>): CMsgAMAddFreeLicense {
    return CMsgAMAddFreeLicense.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgAMAddFreeLicense>): CMsgAMAddFreeLicense {
    const message = createBaseCMsgAMAddFreeLicense();
    message.steamid = object.steamid ?? "0";
    message.ipPublic = object.ipPublic ?? 0;
    message.packageid = object.packageid ?? 0;
    message.storeCountryCode = object.storeCountryCode ?? "";
    return message;
  },
};

function createBaseCMsgAMAddFreeLicenseResponse(): CMsgAMAddFreeLicenseResponse {
  return { eresult: 2, purchaseResultDetail: 0, transid: "0" };
}

export const CMsgAMAddFreeLicenseResponse = {
  encode(message: CMsgAMAddFreeLicenseResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.eresult !== undefined && message.eresult !== 2) {
      writer.uint32(8).int32(message.eresult);
    }
    if (message.purchaseResultDetail !== undefined && message.purchaseResultDetail !== 0) {
      writer.uint32(16).int32(message.purchaseResultDetail);
    }
    if (message.transid !== undefined && message.transid !== "0") {
      writer.uint32(25).fixed64(message.transid);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgAMAddFreeLicenseResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgAMAddFreeLicenseResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.eresult = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.purchaseResultDetail = reader.int32();
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.transid = longToString(reader.fixed64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgAMAddFreeLicenseResponse {
    return {
      eresult: isSet(object.eresult) ? globalThis.Number(object.eresult) : 2,
      purchaseResultDetail: isSet(object.purchaseResultDetail) ? globalThis.Number(object.purchaseResultDetail) : 0,
      transid: isSet(object.transid) ? globalThis.String(object.transid) : "0",
    };
  },

  toJSON(message: CMsgAMAddFreeLicenseResponse): unknown {
    const obj: any = {};
    if (message.eresult !== undefined && message.eresult !== 2) {
      obj.eresult = Math.round(message.eresult);
    }
    if (message.purchaseResultDetail !== undefined && message.purchaseResultDetail !== 0) {
      obj.purchaseResultDetail = Math.round(message.purchaseResultDetail);
    }
    if (message.transid !== undefined && message.transid !== "0") {
      obj.transid = message.transid;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgAMAddFreeLicenseResponse>): CMsgAMAddFreeLicenseResponse {
    return CMsgAMAddFreeLicenseResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgAMAddFreeLicenseResponse>): CMsgAMAddFreeLicenseResponse {
    const message = createBaseCMsgAMAddFreeLicenseResponse();
    message.eresult = object.eresult ?? 2;
    message.purchaseResultDetail = object.purchaseResultDetail ?? 0;
    message.transid = object.transid ?? "0";
    return message;
  },
};

function createBaseCGCMsgGetIPLocation(): CGCMsgGetIPLocation {
  return { ips: [] };
}

export const CGCMsgGetIPLocation = {
  encode(message: CGCMsgGetIPLocation, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.ips) {
      writer.fixed32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CGCMsgGetIPLocation {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCGCMsgGetIPLocation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 13) {
            message.ips.push(reader.fixed32());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.ips.push(reader.fixed32());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CGCMsgGetIPLocation {
    return { ips: globalThis.Array.isArray(object?.ips) ? object.ips.map((e: any) => globalThis.Number(e)) : [] };
  },

  toJSON(message: CGCMsgGetIPLocation): unknown {
    const obj: any = {};
    if (message.ips?.length) {
      obj.ips = message.ips.map((e) => Math.round(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CGCMsgGetIPLocation>): CGCMsgGetIPLocation {
    return CGCMsgGetIPLocation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CGCMsgGetIPLocation>): CGCMsgGetIPLocation {
    const message = createBaseCGCMsgGetIPLocation();
    message.ips = object.ips?.map((e) => e) || [];
    return message;
  },
};

function createBaseCGCMsgGetIPASN(): CGCMsgGetIPASN {
  return { ips: [] };
}

export const CGCMsgGetIPASN = {
  encode(message: CGCMsgGetIPASN, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.ips) {
      writer.fixed32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CGCMsgGetIPASN {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCGCMsgGetIPASN();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 13) {
            message.ips.push(reader.fixed32());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.ips.push(reader.fixed32());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CGCMsgGetIPASN {
    return { ips: globalThis.Array.isArray(object?.ips) ? object.ips.map((e: any) => globalThis.Number(e)) : [] };
  },

  toJSON(message: CGCMsgGetIPASN): unknown {
    const obj: any = {};
    if (message.ips?.length) {
      obj.ips = message.ips.map((e) => Math.round(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CGCMsgGetIPASN>): CGCMsgGetIPASN {
    return CGCMsgGetIPASN.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CGCMsgGetIPASN>): CGCMsgGetIPASN {
    const message = createBaseCGCMsgGetIPASN();
    message.ips = object.ips?.map((e) => e) || [];
    return message;
  },
};

function createBaseCIPASNInfo(): CIPASNInfo {
  return { ip: 0, asn: 0 };
}

export const CIPASNInfo = {
  encode(message: CIPASNInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.ip !== undefined && message.ip !== 0) {
      writer.uint32(13).fixed32(message.ip);
    }
    if (message.asn !== undefined && message.asn !== 0) {
      writer.uint32(16).uint32(message.asn);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CIPASNInfo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCIPASNInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.ip = reader.fixed32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.asn = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CIPASNInfo {
    return {
      ip: isSet(object.ip) ? globalThis.Number(object.ip) : 0,
      asn: isSet(object.asn) ? globalThis.Number(object.asn) : 0,
    };
  },

  toJSON(message: CIPASNInfo): unknown {
    const obj: any = {};
    if (message.ip !== undefined && message.ip !== 0) {
      obj.ip = Math.round(message.ip);
    }
    if (message.asn !== undefined && message.asn !== 0) {
      obj.asn = Math.round(message.asn);
    }
    return obj;
  },

  create(base?: DeepPartial<CIPASNInfo>): CIPASNInfo {
    return CIPASNInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CIPASNInfo>): CIPASNInfo {
    const message = createBaseCIPASNInfo();
    message.ip = object.ip ?? 0;
    message.asn = object.asn ?? 0;
    return message;
  },
};

function createBaseCGCMsgGetIPASNResponse(): CGCMsgGetIPASNResponse {
  return { infos: [] };
}

export const CGCMsgGetIPASNResponse = {
  encode(message: CGCMsgGetIPASNResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.infos) {
      CIPASNInfo.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CGCMsgGetIPASNResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCGCMsgGetIPASNResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.infos.push(CIPASNInfo.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CGCMsgGetIPASNResponse {
    return {
      infos: globalThis.Array.isArray(object?.infos) ? object.infos.map((e: any) => CIPASNInfo.fromJSON(e)) : [],
    };
  },

  toJSON(message: CGCMsgGetIPASNResponse): unknown {
    const obj: any = {};
    if (message.infos?.length) {
      obj.infos = message.infos.map((e) => CIPASNInfo.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CGCMsgGetIPASNResponse>): CGCMsgGetIPASNResponse {
    return CGCMsgGetIPASNResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CGCMsgGetIPASNResponse>): CGCMsgGetIPASNResponse {
    const message = createBaseCGCMsgGetIPASNResponse();
    message.infos = object.infos?.map((e) => CIPASNInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgAMSendEmail(): CMsgAMSendEmail {
  return { steamid: "0", emailMsgType: 0, emailFormat: 0, personaNameTokens: [], sourceGc: 0, tokens: [] };
}

export const CMsgAMSendEmail = {
  encode(message: CMsgAMSendEmail, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.steamid !== undefined && message.steamid !== "0") {
      writer.uint32(9).fixed64(message.steamid);
    }
    if (message.emailMsgType !== undefined && message.emailMsgType !== 0) {
      writer.uint32(16).uint32(message.emailMsgType);
    }
    if (message.emailFormat !== undefined && message.emailFormat !== 0) {
      writer.uint32(24).uint32(message.emailFormat);
    }
    for (const v of message.personaNameTokens) {
      CMsgAMSendEmail_PersonaNameReplacementToken.encode(v!, writer.uint32(42).fork()).ldelim();
    }
    if (message.sourceGc !== undefined && message.sourceGc !== 0) {
      writer.uint32(48).uint32(message.sourceGc);
    }
    for (const v of message.tokens) {
      CMsgAMSendEmail_ReplacementToken.encode(v!, writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgAMSendEmail {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgAMSendEmail();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.steamid = longToString(reader.fixed64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.emailMsgType = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.emailFormat = reader.uint32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.personaNameTokens.push(CMsgAMSendEmail_PersonaNameReplacementToken.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.sourceGc = reader.uint32();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.tokens.push(CMsgAMSendEmail_ReplacementToken.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgAMSendEmail {
    return {
      steamid: isSet(object.steamid) ? globalThis.String(object.steamid) : "0",
      emailMsgType: isSet(object.emailMsgType) ? globalThis.Number(object.emailMsgType) : 0,
      emailFormat: isSet(object.emailFormat) ? globalThis.Number(object.emailFormat) : 0,
      personaNameTokens: globalThis.Array.isArray(object?.personaNameTokens)
        ? object.personaNameTokens.map((e: any) => CMsgAMSendEmail_PersonaNameReplacementToken.fromJSON(e))
        : [],
      sourceGc: isSet(object.sourceGc) ? globalThis.Number(object.sourceGc) : 0,
      tokens: globalThis.Array.isArray(object?.tokens)
        ? object.tokens.map((e: any) => CMsgAMSendEmail_ReplacementToken.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgAMSendEmail): unknown {
    const obj: any = {};
    if (message.steamid !== undefined && message.steamid !== "0") {
      obj.steamid = message.steamid;
    }
    if (message.emailMsgType !== undefined && message.emailMsgType !== 0) {
      obj.emailMsgType = Math.round(message.emailMsgType);
    }
    if (message.emailFormat !== undefined && message.emailFormat !== 0) {
      obj.emailFormat = Math.round(message.emailFormat);
    }
    if (message.personaNameTokens?.length) {
      obj.personaNameTokens = message.personaNameTokens.map((e) =>
        CMsgAMSendEmail_PersonaNameReplacementToken.toJSON(e)
      );
    }
    if (message.sourceGc !== undefined && message.sourceGc !== 0) {
      obj.sourceGc = Math.round(message.sourceGc);
    }
    if (message.tokens?.length) {
      obj.tokens = message.tokens.map((e) => CMsgAMSendEmail_ReplacementToken.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgAMSendEmail>): CMsgAMSendEmail {
    return CMsgAMSendEmail.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgAMSendEmail>): CMsgAMSendEmail {
    const message = createBaseCMsgAMSendEmail();
    message.steamid = object.steamid ?? "0";
    message.emailMsgType = object.emailMsgType ?? 0;
    message.emailFormat = object.emailFormat ?? 0;
    message.personaNameTokens =
      object.personaNameTokens?.map((e) => CMsgAMSendEmail_PersonaNameReplacementToken.fromPartial(e)) || [];
    message.sourceGc = object.sourceGc ?? 0;
    message.tokens = object.tokens?.map((e) => CMsgAMSendEmail_ReplacementToken.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgAMSendEmail_ReplacementToken(): CMsgAMSendEmail_ReplacementToken {
  return { tokenName: "", tokenValue: "" };
}

export const CMsgAMSendEmail_ReplacementToken = {
  encode(message: CMsgAMSendEmail_ReplacementToken, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.tokenName !== undefined && message.tokenName !== "") {
      writer.uint32(10).string(message.tokenName);
    }
    if (message.tokenValue !== undefined && message.tokenValue !== "") {
      writer.uint32(18).string(message.tokenValue);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgAMSendEmail_ReplacementToken {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgAMSendEmail_ReplacementToken();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.tokenName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.tokenValue = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgAMSendEmail_ReplacementToken {
    return {
      tokenName: isSet(object.tokenName) ? globalThis.String(object.tokenName) : "",
      tokenValue: isSet(object.tokenValue) ? globalThis.String(object.tokenValue) : "",
    };
  },

  toJSON(message: CMsgAMSendEmail_ReplacementToken): unknown {
    const obj: any = {};
    if (message.tokenName !== undefined && message.tokenName !== "") {
      obj.tokenName = message.tokenName;
    }
    if (message.tokenValue !== undefined && message.tokenValue !== "") {
      obj.tokenValue = message.tokenValue;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgAMSendEmail_ReplacementToken>): CMsgAMSendEmail_ReplacementToken {
    return CMsgAMSendEmail_ReplacementToken.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgAMSendEmail_ReplacementToken>): CMsgAMSendEmail_ReplacementToken {
    const message = createBaseCMsgAMSendEmail_ReplacementToken();
    message.tokenName = object.tokenName ?? "";
    message.tokenValue = object.tokenValue ?? "";
    return message;
  },
};

function createBaseCMsgAMSendEmail_PersonaNameReplacementToken(): CMsgAMSendEmail_PersonaNameReplacementToken {
  return { steamid: "0", tokenName: "" };
}

export const CMsgAMSendEmail_PersonaNameReplacementToken = {
  encode(message: CMsgAMSendEmail_PersonaNameReplacementToken, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.steamid !== undefined && message.steamid !== "0") {
      writer.uint32(9).fixed64(message.steamid);
    }
    if (message.tokenName !== undefined && message.tokenName !== "") {
      writer.uint32(18).string(message.tokenName);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgAMSendEmail_PersonaNameReplacementToken {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgAMSendEmail_PersonaNameReplacementToken();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.steamid = longToString(reader.fixed64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.tokenName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgAMSendEmail_PersonaNameReplacementToken {
    return {
      steamid: isSet(object.steamid) ? globalThis.String(object.steamid) : "0",
      tokenName: isSet(object.tokenName) ? globalThis.String(object.tokenName) : "",
    };
  },

  toJSON(message: CMsgAMSendEmail_PersonaNameReplacementToken): unknown {
    const obj: any = {};
    if (message.steamid !== undefined && message.steamid !== "0") {
      obj.steamid = message.steamid;
    }
    if (message.tokenName !== undefined && message.tokenName !== "") {
      obj.tokenName = message.tokenName;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgAMSendEmail_PersonaNameReplacementToken>): CMsgAMSendEmail_PersonaNameReplacementToken {
    return CMsgAMSendEmail_PersonaNameReplacementToken.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgAMSendEmail_PersonaNameReplacementToken>,
  ): CMsgAMSendEmail_PersonaNameReplacementToken {
    const message = createBaseCMsgAMSendEmail_PersonaNameReplacementToken();
    message.steamid = object.steamid ?? "0";
    message.tokenName = object.tokenName ?? "";
    return message;
  },
};

function createBaseCMsgAMSendEmailResponse(): CMsgAMSendEmailResponse {
  return { eresult: 2 };
}

export const CMsgAMSendEmailResponse = {
  encode(message: CMsgAMSendEmailResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.eresult !== undefined && message.eresult !== 2) {
      writer.uint32(8).uint32(message.eresult);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgAMSendEmailResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgAMSendEmailResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.eresult = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgAMSendEmailResponse {
    return { eresult: isSet(object.eresult) ? globalThis.Number(object.eresult) : 2 };
  },

  toJSON(message: CMsgAMSendEmailResponse): unknown {
    const obj: any = {};
    if (message.eresult !== undefined && message.eresult !== 2) {
      obj.eresult = Math.round(message.eresult);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgAMSendEmailResponse>): CMsgAMSendEmailResponse {
    return CMsgAMSendEmailResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgAMSendEmailResponse>): CMsgAMSendEmailResponse {
    const message = createBaseCMsgAMSendEmailResponse();
    message.eresult = object.eresult ?? 2;
    return message;
  },
};

function createBaseCMsgGCGetEmailTemplate(): CMsgGCGetEmailTemplate {
  return { appId: 0, emailMsgType: 0, emailLang: 0, emailFormat: 0 };
}

export const CMsgGCGetEmailTemplate = {
  encode(message: CMsgGCGetEmailTemplate, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.appId !== undefined && message.appId !== 0) {
      writer.uint32(8).uint32(message.appId);
    }
    if (message.emailMsgType !== undefined && message.emailMsgType !== 0) {
      writer.uint32(16).uint32(message.emailMsgType);
    }
    if (message.emailLang !== undefined && message.emailLang !== 0) {
      writer.uint32(24).int32(message.emailLang);
    }
    if (message.emailFormat !== undefined && message.emailFormat !== 0) {
      writer.uint32(32).int32(message.emailFormat);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCGetEmailTemplate {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCGetEmailTemplate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.appId = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.emailMsgType = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.emailLang = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.emailFormat = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCGetEmailTemplate {
    return {
      appId: isSet(object.appId) ? globalThis.Number(object.appId) : 0,
      emailMsgType: isSet(object.emailMsgType) ? globalThis.Number(object.emailMsgType) : 0,
      emailLang: isSet(object.emailLang) ? globalThis.Number(object.emailLang) : 0,
      emailFormat: isSet(object.emailFormat) ? globalThis.Number(object.emailFormat) : 0,
    };
  },

  toJSON(message: CMsgGCGetEmailTemplate): unknown {
    const obj: any = {};
    if (message.appId !== undefined && message.appId !== 0) {
      obj.appId = Math.round(message.appId);
    }
    if (message.emailMsgType !== undefined && message.emailMsgType !== 0) {
      obj.emailMsgType = Math.round(message.emailMsgType);
    }
    if (message.emailLang !== undefined && message.emailLang !== 0) {
      obj.emailLang = Math.round(message.emailLang);
    }
    if (message.emailFormat !== undefined && message.emailFormat !== 0) {
      obj.emailFormat = Math.round(message.emailFormat);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCGetEmailTemplate>): CMsgGCGetEmailTemplate {
    return CMsgGCGetEmailTemplate.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCGetEmailTemplate>): CMsgGCGetEmailTemplate {
    const message = createBaseCMsgGCGetEmailTemplate();
    message.appId = object.appId ?? 0;
    message.emailMsgType = object.emailMsgType ?? 0;
    message.emailLang = object.emailLang ?? 0;
    message.emailFormat = object.emailFormat ?? 0;
    return message;
  },
};

function createBaseCMsgGCGetEmailTemplateResponse(): CMsgGCGetEmailTemplateResponse {
  return { eresult: 2, templateExists: false, template: "" };
}

export const CMsgGCGetEmailTemplateResponse = {
  encode(message: CMsgGCGetEmailTemplateResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.eresult !== undefined && message.eresult !== 2) {
      writer.uint32(8).uint32(message.eresult);
    }
    if (message.templateExists !== undefined && message.templateExists !== false) {
      writer.uint32(16).bool(message.templateExists);
    }
    if (message.template !== undefined && message.template !== "") {
      writer.uint32(26).string(message.template);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCGetEmailTemplateResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCGetEmailTemplateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.eresult = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.templateExists = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.template = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCGetEmailTemplateResponse {
    return {
      eresult: isSet(object.eresult) ? globalThis.Number(object.eresult) : 2,
      templateExists: isSet(object.templateExists) ? globalThis.Boolean(object.templateExists) : false,
      template: isSet(object.template) ? globalThis.String(object.template) : "",
    };
  },

  toJSON(message: CMsgGCGetEmailTemplateResponse): unknown {
    const obj: any = {};
    if (message.eresult !== undefined && message.eresult !== 2) {
      obj.eresult = Math.round(message.eresult);
    }
    if (message.templateExists !== undefined && message.templateExists !== false) {
      obj.templateExists = message.templateExists;
    }
    if (message.template !== undefined && message.template !== "") {
      obj.template = message.template;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCGetEmailTemplateResponse>): CMsgGCGetEmailTemplateResponse {
    return CMsgGCGetEmailTemplateResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCGetEmailTemplateResponse>): CMsgGCGetEmailTemplateResponse {
    const message = createBaseCMsgGCGetEmailTemplateResponse();
    message.eresult = object.eresult ?? 2;
    message.templateExists = object.templateExists ?? false;
    message.template = object.template ?? "";
    return message;
  },
};

function createBaseCMsgAMGrantGuestPasses2(): CMsgAMGrantGuestPasses2 {
  return { steamId: "0", packageId: 0, passesToGrant: 0, daysToExpiration: 0, action: 0 };
}

export const CMsgAMGrantGuestPasses2 = {
  encode(message: CMsgAMGrantGuestPasses2, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.steamId !== undefined && message.steamId !== "0") {
      writer.uint32(9).fixed64(message.steamId);
    }
    if (message.packageId !== undefined && message.packageId !== 0) {
      writer.uint32(16).uint32(message.packageId);
    }
    if (message.passesToGrant !== undefined && message.passesToGrant !== 0) {
      writer.uint32(24).int32(message.passesToGrant);
    }
    if (message.daysToExpiration !== undefined && message.daysToExpiration !== 0) {
      writer.uint32(32).int32(message.daysToExpiration);
    }
    if (message.action !== undefined && message.action !== 0) {
      writer.uint32(40).int32(message.action);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgAMGrantGuestPasses2 {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgAMGrantGuestPasses2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.steamId = longToString(reader.fixed64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.packageId = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.passesToGrant = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.daysToExpiration = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.action = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgAMGrantGuestPasses2 {
    return {
      steamId: isSet(object.steamId) ? globalThis.String(object.steamId) : "0",
      packageId: isSet(object.packageId) ? globalThis.Number(object.packageId) : 0,
      passesToGrant: isSet(object.passesToGrant) ? globalThis.Number(object.passesToGrant) : 0,
      daysToExpiration: isSet(object.daysToExpiration) ? globalThis.Number(object.daysToExpiration) : 0,
      action: isSet(object.action) ? globalThis.Number(object.action) : 0,
    };
  },

  toJSON(message: CMsgAMGrantGuestPasses2): unknown {
    const obj: any = {};
    if (message.steamId !== undefined && message.steamId !== "0") {
      obj.steamId = message.steamId;
    }
    if (message.packageId !== undefined && message.packageId !== 0) {
      obj.packageId = Math.round(message.packageId);
    }
    if (message.passesToGrant !== undefined && message.passesToGrant !== 0) {
      obj.passesToGrant = Math.round(message.passesToGrant);
    }
    if (message.daysToExpiration !== undefined && message.daysToExpiration !== 0) {
      obj.daysToExpiration = Math.round(message.daysToExpiration);
    }
    if (message.action !== undefined && message.action !== 0) {
      obj.action = Math.round(message.action);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgAMGrantGuestPasses2>): CMsgAMGrantGuestPasses2 {
    return CMsgAMGrantGuestPasses2.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgAMGrantGuestPasses2>): CMsgAMGrantGuestPasses2 {
    const message = createBaseCMsgAMGrantGuestPasses2();
    message.steamId = object.steamId ?? "0";
    message.packageId = object.packageId ?? 0;
    message.passesToGrant = object.passesToGrant ?? 0;
    message.daysToExpiration = object.daysToExpiration ?? 0;
    message.action = object.action ?? 0;
    return message;
  },
};

function createBaseCMsgAMGrantGuestPasses2Response(): CMsgAMGrantGuestPasses2Response {
  return { eresult: 2, passesGranted: 0 };
}

export const CMsgAMGrantGuestPasses2Response = {
  encode(message: CMsgAMGrantGuestPasses2Response, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.eresult !== undefined && message.eresult !== 2) {
      writer.uint32(8).int32(message.eresult);
    }
    if (message.passesGranted !== undefined && message.passesGranted !== 0) {
      writer.uint32(16).int32(message.passesGranted);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgAMGrantGuestPasses2Response {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgAMGrantGuestPasses2Response();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.eresult = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.passesGranted = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgAMGrantGuestPasses2Response {
    return {
      eresult: isSet(object.eresult) ? globalThis.Number(object.eresult) : 2,
      passesGranted: isSet(object.passesGranted) ? globalThis.Number(object.passesGranted) : 0,
    };
  },

  toJSON(message: CMsgAMGrantGuestPasses2Response): unknown {
    const obj: any = {};
    if (message.eresult !== undefined && message.eresult !== 2) {
      obj.eresult = Math.round(message.eresult);
    }
    if (message.passesGranted !== undefined && message.passesGranted !== 0) {
      obj.passesGranted = Math.round(message.passesGranted);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgAMGrantGuestPasses2Response>): CMsgAMGrantGuestPasses2Response {
    return CMsgAMGrantGuestPasses2Response.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgAMGrantGuestPasses2Response>): CMsgAMGrantGuestPasses2Response {
    const message = createBaseCMsgAMGrantGuestPasses2Response();
    message.eresult = object.eresult ?? 2;
    message.passesGranted = object.passesGranted ?? 0;
    return message;
  },
};

function createBaseCMsgGCGetPersonaNames(): CMsgGCGetPersonaNames {
  return { steamids: [] };
}

export const CMsgGCGetPersonaNames = {
  encode(message: CMsgGCGetPersonaNames, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.steamids) {
      writer.fixed64(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCGetPersonaNames {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCGetPersonaNames();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 9) {
            message.steamids.push(longToString(reader.fixed64() as Long));

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.steamids.push(longToString(reader.fixed64() as Long));
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCGetPersonaNames {
    return {
      steamids: globalThis.Array.isArray(object?.steamids) ? object.steamids.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: CMsgGCGetPersonaNames): unknown {
    const obj: any = {};
    if (message.steamids?.length) {
      obj.steamids = message.steamids;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCGetPersonaNames>): CMsgGCGetPersonaNames {
    return CMsgGCGetPersonaNames.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCGetPersonaNames>): CMsgGCGetPersonaNames {
    const message = createBaseCMsgGCGetPersonaNames();
    message.steamids = object.steamids?.map((e) => e) || [];
    return message;
  },
};

function createBaseCMsgGCGetPersonaNamesResponse(): CMsgGCGetPersonaNamesResponse {
  return { succeededLookups: [], failedLookupSteamids: [] };
}

export const CMsgGCGetPersonaNamesResponse = {
  encode(message: CMsgGCGetPersonaNamesResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.succeededLookups) {
      CMsgGCGetPersonaNamesResponse_PersonaName.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    writer.uint32(18).fork();
    for (const v of message.failedLookupSteamids) {
      writer.fixed64(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCGetPersonaNamesResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCGetPersonaNamesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.succeededLookups.push(CMsgGCGetPersonaNamesResponse_PersonaName.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag === 17) {
            message.failedLookupSteamids.push(longToString(reader.fixed64() as Long));

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.failedLookupSteamids.push(longToString(reader.fixed64() as Long));
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCGetPersonaNamesResponse {
    return {
      succeededLookups: globalThis.Array.isArray(object?.succeededLookups)
        ? object.succeededLookups.map((e: any) => CMsgGCGetPersonaNamesResponse_PersonaName.fromJSON(e))
        : [],
      failedLookupSteamids: globalThis.Array.isArray(object?.failedLookupSteamids)
        ? object.failedLookupSteamids.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: CMsgGCGetPersonaNamesResponse): unknown {
    const obj: any = {};
    if (message.succeededLookups?.length) {
      obj.succeededLookups = message.succeededLookups.map((e) => CMsgGCGetPersonaNamesResponse_PersonaName.toJSON(e));
    }
    if (message.failedLookupSteamids?.length) {
      obj.failedLookupSteamids = message.failedLookupSteamids;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCGetPersonaNamesResponse>): CMsgGCGetPersonaNamesResponse {
    return CMsgGCGetPersonaNamesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCGetPersonaNamesResponse>): CMsgGCGetPersonaNamesResponse {
    const message = createBaseCMsgGCGetPersonaNamesResponse();
    message.succeededLookups =
      object.succeededLookups?.map((e) => CMsgGCGetPersonaNamesResponse_PersonaName.fromPartial(e)) || [];
    message.failedLookupSteamids = object.failedLookupSteamids?.map((e) => e) || [];
    return message;
  },
};

function createBaseCMsgGCGetPersonaNamesResponse_PersonaName(): CMsgGCGetPersonaNamesResponse_PersonaName {
  return { steamid: "0", personaName: "" };
}

export const CMsgGCGetPersonaNamesResponse_PersonaName = {
  encode(message: CMsgGCGetPersonaNamesResponse_PersonaName, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.steamid !== undefined && message.steamid !== "0") {
      writer.uint32(9).fixed64(message.steamid);
    }
    if (message.personaName !== undefined && message.personaName !== "") {
      writer.uint32(18).string(message.personaName);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCGetPersonaNamesResponse_PersonaName {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCGetPersonaNamesResponse_PersonaName();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.steamid = longToString(reader.fixed64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.personaName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCGetPersonaNamesResponse_PersonaName {
    return {
      steamid: isSet(object.steamid) ? globalThis.String(object.steamid) : "0",
      personaName: isSet(object.personaName) ? globalThis.String(object.personaName) : "",
    };
  },

  toJSON(message: CMsgGCGetPersonaNamesResponse_PersonaName): unknown {
    const obj: any = {};
    if (message.steamid !== undefined && message.steamid !== "0") {
      obj.steamid = message.steamid;
    }
    if (message.personaName !== undefined && message.personaName !== "") {
      obj.personaName = message.personaName;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCGetPersonaNamesResponse_PersonaName>): CMsgGCGetPersonaNamesResponse_PersonaName {
    return CMsgGCGetPersonaNamesResponse_PersonaName.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgGCGetPersonaNamesResponse_PersonaName>,
  ): CMsgGCGetPersonaNamesResponse_PersonaName {
    const message = createBaseCMsgGCGetPersonaNamesResponse_PersonaName();
    message.steamid = object.steamid ?? "0";
    message.personaName = object.personaName ?? "";
    return message;
  },
};

function createBaseCMsgGCCheckFriendship(): CMsgGCCheckFriendship {
  return { steamidLeft: "0", steamidRight: "0" };
}

export const CMsgGCCheckFriendship = {
  encode(message: CMsgGCCheckFriendship, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.steamidLeft !== undefined && message.steamidLeft !== "0") {
      writer.uint32(9).fixed64(message.steamidLeft);
    }
    if (message.steamidRight !== undefined && message.steamidRight !== "0") {
      writer.uint32(17).fixed64(message.steamidRight);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCCheckFriendship {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCCheckFriendship();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.steamidLeft = longToString(reader.fixed64() as Long);
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.steamidRight = longToString(reader.fixed64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCCheckFriendship {
    return {
      steamidLeft: isSet(object.steamidLeft) ? globalThis.String(object.steamidLeft) : "0",
      steamidRight: isSet(object.steamidRight) ? globalThis.String(object.steamidRight) : "0",
    };
  },

  toJSON(message: CMsgGCCheckFriendship): unknown {
    const obj: any = {};
    if (message.steamidLeft !== undefined && message.steamidLeft !== "0") {
      obj.steamidLeft = message.steamidLeft;
    }
    if (message.steamidRight !== undefined && message.steamidRight !== "0") {
      obj.steamidRight = message.steamidRight;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCCheckFriendship>): CMsgGCCheckFriendship {
    return CMsgGCCheckFriendship.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCCheckFriendship>): CMsgGCCheckFriendship {
    const message = createBaseCMsgGCCheckFriendship();
    message.steamidLeft = object.steamidLeft ?? "0";
    message.steamidRight = object.steamidRight ?? "0";
    return message;
  },
};

function createBaseCMsgGCCheckFriendshipResponse(): CMsgGCCheckFriendshipResponse {
  return { success: false, foundFriendship: false };
}

export const CMsgGCCheckFriendshipResponse = {
  encode(message: CMsgGCCheckFriendshipResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.success !== undefined && message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.foundFriendship !== undefined && message.foundFriendship !== false) {
      writer.uint32(16).bool(message.foundFriendship);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCCheckFriendshipResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCCheckFriendshipResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.foundFriendship = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCCheckFriendshipResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      foundFriendship: isSet(object.foundFriendship) ? globalThis.Boolean(object.foundFriendship) : false,
    };
  },

  toJSON(message: CMsgGCCheckFriendshipResponse): unknown {
    const obj: any = {};
    if (message.success !== undefined && message.success !== false) {
      obj.success = message.success;
    }
    if (message.foundFriendship !== undefined && message.foundFriendship !== false) {
      obj.foundFriendship = message.foundFriendship;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCCheckFriendshipResponse>): CMsgGCCheckFriendshipResponse {
    return CMsgGCCheckFriendshipResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCCheckFriendshipResponse>): CMsgGCCheckFriendshipResponse {
    const message = createBaseCMsgGCCheckFriendshipResponse();
    message.success = object.success ?? false;
    message.foundFriendship = object.foundFriendship ?? false;
    return message;
  },
};

function createBaseCMsgGCGetAppFriendsList(): CMsgGCGetAppFriendsList {
  return { steamid: "0", includeFriendshipTimestamps: false, includeFriendsWithNoPlayTime: false };
}

export const CMsgGCGetAppFriendsList = {
  encode(message: CMsgGCGetAppFriendsList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.steamid !== undefined && message.steamid !== "0") {
      writer.uint32(9).fixed64(message.steamid);
    }
    if (message.includeFriendshipTimestamps !== undefined && message.includeFriendshipTimestamps !== false) {
      writer.uint32(16).bool(message.includeFriendshipTimestamps);
    }
    if (message.includeFriendsWithNoPlayTime !== undefined && message.includeFriendsWithNoPlayTime !== false) {
      writer.uint32(24).bool(message.includeFriendsWithNoPlayTime);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCGetAppFriendsList {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCGetAppFriendsList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.steamid = longToString(reader.fixed64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.includeFriendshipTimestamps = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.includeFriendsWithNoPlayTime = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCGetAppFriendsList {
    return {
      steamid: isSet(object.steamid) ? globalThis.String(object.steamid) : "0",
      includeFriendshipTimestamps: isSet(object.includeFriendshipTimestamps)
        ? globalThis.Boolean(object.includeFriendshipTimestamps)
        : false,
      includeFriendsWithNoPlayTime: isSet(object.includeFriendsWithNoPlayTime)
        ? globalThis.Boolean(object.includeFriendsWithNoPlayTime)
        : false,
    };
  },

  toJSON(message: CMsgGCGetAppFriendsList): unknown {
    const obj: any = {};
    if (message.steamid !== undefined && message.steamid !== "0") {
      obj.steamid = message.steamid;
    }
    if (message.includeFriendshipTimestamps !== undefined && message.includeFriendshipTimestamps !== false) {
      obj.includeFriendshipTimestamps = message.includeFriendshipTimestamps;
    }
    if (message.includeFriendsWithNoPlayTime !== undefined && message.includeFriendsWithNoPlayTime !== false) {
      obj.includeFriendsWithNoPlayTime = message.includeFriendsWithNoPlayTime;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCGetAppFriendsList>): CMsgGCGetAppFriendsList {
    return CMsgGCGetAppFriendsList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCGetAppFriendsList>): CMsgGCGetAppFriendsList {
    const message = createBaseCMsgGCGetAppFriendsList();
    message.steamid = object.steamid ?? "0";
    message.includeFriendshipTimestamps = object.includeFriendshipTimestamps ?? false;
    message.includeFriendsWithNoPlayTime = object.includeFriendsWithNoPlayTime ?? false;
    return message;
  },
};

function createBaseCMsgGCGetAppFriendsListResponse(): CMsgGCGetAppFriendsListResponse {
  return { success: false, steamids: [], friendshipTimestamps: [], lastPlaytimes: [] };
}

export const CMsgGCGetAppFriendsListResponse = {
  encode(message: CMsgGCGetAppFriendsListResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.success !== undefined && message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    writer.uint32(18).fork();
    for (const v of message.steamids) {
      writer.fixed64(v);
    }
    writer.ldelim();
    writer.uint32(26).fork();
    for (const v of message.friendshipTimestamps) {
      writer.fixed32(v);
    }
    writer.ldelim();
    writer.uint32(34).fork();
    for (const v of message.lastPlaytimes) {
      writer.fixed32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCGetAppFriendsListResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCGetAppFriendsListResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag === 17) {
            message.steamids.push(longToString(reader.fixed64() as Long));

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.steamids.push(longToString(reader.fixed64() as Long));
            }

            continue;
          }

          break;
        case 3:
          if (tag === 29) {
            message.friendshipTimestamps.push(reader.fixed32());

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.friendshipTimestamps.push(reader.fixed32());
            }

            continue;
          }

          break;
        case 4:
          if (tag === 37) {
            message.lastPlaytimes.push(reader.fixed32());

            continue;
          }

          if (tag === 34) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.lastPlaytimes.push(reader.fixed32());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCGetAppFriendsListResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      steamids: globalThis.Array.isArray(object?.steamids) ? object.steamids.map((e: any) => globalThis.String(e)) : [],
      friendshipTimestamps: globalThis.Array.isArray(object?.friendshipTimestamps)
        ? object.friendshipTimestamps.map((e: any) => globalThis.Number(e))
        : [],
      lastPlaytimes: globalThis.Array.isArray(object?.lastPlaytimes)
        ? object.lastPlaytimes.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: CMsgGCGetAppFriendsListResponse): unknown {
    const obj: any = {};
    if (message.success !== undefined && message.success !== false) {
      obj.success = message.success;
    }
    if (message.steamids?.length) {
      obj.steamids = message.steamids;
    }
    if (message.friendshipTimestamps?.length) {
      obj.friendshipTimestamps = message.friendshipTimestamps.map((e) => Math.round(e));
    }
    if (message.lastPlaytimes?.length) {
      obj.lastPlaytimes = message.lastPlaytimes.map((e) => Math.round(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCGetAppFriendsListResponse>): CMsgGCGetAppFriendsListResponse {
    return CMsgGCGetAppFriendsListResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCGetAppFriendsListResponse>): CMsgGCGetAppFriendsListResponse {
    const message = createBaseCMsgGCGetAppFriendsListResponse();
    message.success = object.success ?? false;
    message.steamids = object.steamids?.map((e) => e) || [];
    message.friendshipTimestamps = object.friendshipTimestamps?.map((e) => e) || [];
    message.lastPlaytimes = object.lastPlaytimes?.map((e) => e) || [];
    return message;
  },
};

function createBaseCMsgGCMsgMasterSetDirectory(): CMsgGCMsgMasterSetDirectory {
  return { masterDirIndex: -1, dir: [] };
}

export const CMsgGCMsgMasterSetDirectory = {
  encode(message: CMsgGCMsgMasterSetDirectory, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.masterDirIndex !== undefined && message.masterDirIndex !== -1) {
      writer.uint32(8).int32(message.masterDirIndex);
    }
    for (const v of message.dir) {
      CMsgGCMsgMasterSetDirectory_SubGC.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCMsgMasterSetDirectory {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCMsgMasterSetDirectory();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.masterDirIndex = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.dir.push(CMsgGCMsgMasterSetDirectory_SubGC.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCMsgMasterSetDirectory {
    return {
      masterDirIndex: isSet(object.masterDirIndex) ? globalThis.Number(object.masterDirIndex) : -1,
      dir: globalThis.Array.isArray(object?.dir)
        ? object.dir.map((e: any) => CMsgGCMsgMasterSetDirectory_SubGC.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgGCMsgMasterSetDirectory): unknown {
    const obj: any = {};
    if (message.masterDirIndex !== undefined && message.masterDirIndex !== -1) {
      obj.masterDirIndex = Math.round(message.masterDirIndex);
    }
    if (message.dir?.length) {
      obj.dir = message.dir.map((e) => CMsgGCMsgMasterSetDirectory_SubGC.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCMsgMasterSetDirectory>): CMsgGCMsgMasterSetDirectory {
    return CMsgGCMsgMasterSetDirectory.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCMsgMasterSetDirectory>): CMsgGCMsgMasterSetDirectory {
    const message = createBaseCMsgGCMsgMasterSetDirectory();
    message.masterDirIndex = object.masterDirIndex ?? -1;
    message.dir = object.dir?.map((e) => CMsgGCMsgMasterSetDirectory_SubGC.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgGCMsgMasterSetDirectory_SubGC(): CMsgGCMsgMasterSetDirectory_SubGC {
  return { dirIndex: -1, name: "", box: "", commandLine: "", gcBinary: "" };
}

export const CMsgGCMsgMasterSetDirectory_SubGC = {
  encode(message: CMsgGCMsgMasterSetDirectory_SubGC, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.dirIndex !== undefined && message.dirIndex !== -1) {
      writer.uint32(8).int32(message.dirIndex);
    }
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.box !== undefined && message.box !== "") {
      writer.uint32(26).string(message.box);
    }
    if (message.commandLine !== undefined && message.commandLine !== "") {
      writer.uint32(34).string(message.commandLine);
    }
    if (message.gcBinary !== undefined && message.gcBinary !== "") {
      writer.uint32(42).string(message.gcBinary);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCMsgMasterSetDirectory_SubGC {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCMsgMasterSetDirectory_SubGC();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.dirIndex = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.box = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.commandLine = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.gcBinary = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCMsgMasterSetDirectory_SubGC {
    return {
      dirIndex: isSet(object.dirIndex) ? globalThis.Number(object.dirIndex) : -1,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      box: isSet(object.box) ? globalThis.String(object.box) : "",
      commandLine: isSet(object.commandLine) ? globalThis.String(object.commandLine) : "",
      gcBinary: isSet(object.gcBinary) ? globalThis.String(object.gcBinary) : "",
    };
  },

  toJSON(message: CMsgGCMsgMasterSetDirectory_SubGC): unknown {
    const obj: any = {};
    if (message.dirIndex !== undefined && message.dirIndex !== -1) {
      obj.dirIndex = Math.round(message.dirIndex);
    }
    if (message.name !== undefined && message.name !== "") {
      obj.name = message.name;
    }
    if (message.box !== undefined && message.box !== "") {
      obj.box = message.box;
    }
    if (message.commandLine !== undefined && message.commandLine !== "") {
      obj.commandLine = message.commandLine;
    }
    if (message.gcBinary !== undefined && message.gcBinary !== "") {
      obj.gcBinary = message.gcBinary;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCMsgMasterSetDirectory_SubGC>): CMsgGCMsgMasterSetDirectory_SubGC {
    return CMsgGCMsgMasterSetDirectory_SubGC.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCMsgMasterSetDirectory_SubGC>): CMsgGCMsgMasterSetDirectory_SubGC {
    const message = createBaseCMsgGCMsgMasterSetDirectory_SubGC();
    message.dirIndex = object.dirIndex ?? -1;
    message.name = object.name ?? "";
    message.box = object.box ?? "";
    message.commandLine = object.commandLine ?? "";
    message.gcBinary = object.gcBinary ?? "";
    return message;
  },
};

function createBaseCMsgGCMsgMasterSetDirectoryResponse(): CMsgGCMsgMasterSetDirectoryResponse {
  return { eresult: 2, message: "" };
}

export const CMsgGCMsgMasterSetDirectoryResponse = {
  encode(message: CMsgGCMsgMasterSetDirectoryResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.eresult !== undefined && message.eresult !== 2) {
      writer.uint32(8).int32(message.eresult);
    }
    if (message.message !== undefined && message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCMsgMasterSetDirectoryResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCMsgMasterSetDirectoryResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.eresult = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCMsgMasterSetDirectoryResponse {
    return {
      eresult: isSet(object.eresult) ? globalThis.Number(object.eresult) : 2,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: CMsgGCMsgMasterSetDirectoryResponse): unknown {
    const obj: any = {};
    if (message.eresult !== undefined && message.eresult !== 2) {
      obj.eresult = Math.round(message.eresult);
    }
    if (message.message !== undefined && message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCMsgMasterSetDirectoryResponse>): CMsgGCMsgMasterSetDirectoryResponse {
    return CMsgGCMsgMasterSetDirectoryResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCMsgMasterSetDirectoryResponse>): CMsgGCMsgMasterSetDirectoryResponse {
    const message = createBaseCMsgGCMsgMasterSetDirectoryResponse();
    message.eresult = object.eresult ?? 2;
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseCMsgGCMsgWebAPIJobRequestForwardResponse(): CMsgGCMsgWebAPIJobRequestForwardResponse {
  return { dirIndex: -1 };
}

export const CMsgGCMsgWebAPIJobRequestForwardResponse = {
  encode(message: CMsgGCMsgWebAPIJobRequestForwardResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.dirIndex !== undefined && message.dirIndex !== -1) {
      writer.uint32(8).int32(message.dirIndex);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCMsgWebAPIJobRequestForwardResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCMsgWebAPIJobRequestForwardResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.dirIndex = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCMsgWebAPIJobRequestForwardResponse {
    return { dirIndex: isSet(object.dirIndex) ? globalThis.Number(object.dirIndex) : -1 };
  },

  toJSON(message: CMsgGCMsgWebAPIJobRequestForwardResponse): unknown {
    const obj: any = {};
    if (message.dirIndex !== undefined && message.dirIndex !== -1) {
      obj.dirIndex = Math.round(message.dirIndex);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCMsgWebAPIJobRequestForwardResponse>): CMsgGCMsgWebAPIJobRequestForwardResponse {
    return CMsgGCMsgWebAPIJobRequestForwardResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCMsgWebAPIJobRequestForwardResponse>): CMsgGCMsgWebAPIJobRequestForwardResponse {
    const message = createBaseCMsgGCMsgWebAPIJobRequestForwardResponse();
    message.dirIndex = object.dirIndex ?? -1;
    return message;
  },
};

function createBaseCGCSystemMsgGetPurchaseTrustRequest(): CGCSystemMsgGetPurchaseTrustRequest {
  return { steamid: "0" };
}

export const CGCSystemMsgGetPurchaseTrustRequest = {
  encode(message: CGCSystemMsgGetPurchaseTrustRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.steamid !== undefined && message.steamid !== "0") {
      writer.uint32(9).fixed64(message.steamid);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CGCSystemMsgGetPurchaseTrustRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCGCSystemMsgGetPurchaseTrustRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.steamid = longToString(reader.fixed64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CGCSystemMsgGetPurchaseTrustRequest {
    return { steamid: isSet(object.steamid) ? globalThis.String(object.steamid) : "0" };
  },

  toJSON(message: CGCSystemMsgGetPurchaseTrustRequest): unknown {
    const obj: any = {};
    if (message.steamid !== undefined && message.steamid !== "0") {
      obj.steamid = message.steamid;
    }
    return obj;
  },

  create(base?: DeepPartial<CGCSystemMsgGetPurchaseTrustRequest>): CGCSystemMsgGetPurchaseTrustRequest {
    return CGCSystemMsgGetPurchaseTrustRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CGCSystemMsgGetPurchaseTrustRequest>): CGCSystemMsgGetPurchaseTrustRequest {
    const message = createBaseCGCSystemMsgGetPurchaseTrustRequest();
    message.steamid = object.steamid ?? "0";
    return message;
  },
};

function createBaseCGCSystemMsgGetPurchaseTrustResponse(): CGCSystemMsgGetPurchaseTrustResponse {
  return {
    hasPriorPurchaseHistory: false,
    hasNoRecentPasswordResets: false,
    isWalletCashTrusted: false,
    timeAllTrusted: 0,
  };
}

export const CGCSystemMsgGetPurchaseTrustResponse = {
  encode(message: CGCSystemMsgGetPurchaseTrustResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.hasPriorPurchaseHistory !== undefined && message.hasPriorPurchaseHistory !== false) {
      writer.uint32(8).bool(message.hasPriorPurchaseHistory);
    }
    if (message.hasNoRecentPasswordResets !== undefined && message.hasNoRecentPasswordResets !== false) {
      writer.uint32(16).bool(message.hasNoRecentPasswordResets);
    }
    if (message.isWalletCashTrusted !== undefined && message.isWalletCashTrusted !== false) {
      writer.uint32(24).bool(message.isWalletCashTrusted);
    }
    if (message.timeAllTrusted !== undefined && message.timeAllTrusted !== 0) {
      writer.uint32(32).uint32(message.timeAllTrusted);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CGCSystemMsgGetPurchaseTrustResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCGCSystemMsgGetPurchaseTrustResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.hasPriorPurchaseHistory = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.hasNoRecentPasswordResets = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.isWalletCashTrusted = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.timeAllTrusted = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CGCSystemMsgGetPurchaseTrustResponse {
    return {
      hasPriorPurchaseHistory: isSet(object.hasPriorPurchaseHistory)
        ? globalThis.Boolean(object.hasPriorPurchaseHistory)
        : false,
      hasNoRecentPasswordResets: isSet(object.hasNoRecentPasswordResets)
        ? globalThis.Boolean(object.hasNoRecentPasswordResets)
        : false,
      isWalletCashTrusted: isSet(object.isWalletCashTrusted) ? globalThis.Boolean(object.isWalletCashTrusted) : false,
      timeAllTrusted: isSet(object.timeAllTrusted) ? globalThis.Number(object.timeAllTrusted) : 0,
    };
  },

  toJSON(message: CGCSystemMsgGetPurchaseTrustResponse): unknown {
    const obj: any = {};
    if (message.hasPriorPurchaseHistory !== undefined && message.hasPriorPurchaseHistory !== false) {
      obj.hasPriorPurchaseHistory = message.hasPriorPurchaseHistory;
    }
    if (message.hasNoRecentPasswordResets !== undefined && message.hasNoRecentPasswordResets !== false) {
      obj.hasNoRecentPasswordResets = message.hasNoRecentPasswordResets;
    }
    if (message.isWalletCashTrusted !== undefined && message.isWalletCashTrusted !== false) {
      obj.isWalletCashTrusted = message.isWalletCashTrusted;
    }
    if (message.timeAllTrusted !== undefined && message.timeAllTrusted !== 0) {
      obj.timeAllTrusted = Math.round(message.timeAllTrusted);
    }
    return obj;
  },

  create(base?: DeepPartial<CGCSystemMsgGetPurchaseTrustResponse>): CGCSystemMsgGetPurchaseTrustResponse {
    return CGCSystemMsgGetPurchaseTrustResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CGCSystemMsgGetPurchaseTrustResponse>): CGCSystemMsgGetPurchaseTrustResponse {
    const message = createBaseCGCSystemMsgGetPurchaseTrustResponse();
    message.hasPriorPurchaseHistory = object.hasPriorPurchaseHistory ?? false;
    message.hasNoRecentPasswordResets = object.hasNoRecentPasswordResets ?? false;
    message.isWalletCashTrusted = object.isWalletCashTrusted ?? false;
    message.timeAllTrusted = object.timeAllTrusted ?? 0;
    return message;
  },
};

function createBaseCMsgGCHAccountVacStatusChange(): CMsgGCHAccountVacStatusChange {
  return { steamId: "0", appId: 0, rtimeVacbanStarts: 0, isBannedNow: false, isBannedFuture: false };
}

export const CMsgGCHAccountVacStatusChange = {
  encode(message: CMsgGCHAccountVacStatusChange, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.steamId !== undefined && message.steamId !== "0") {
      writer.uint32(9).fixed64(message.steamId);
    }
    if (message.appId !== undefined && message.appId !== 0) {
      writer.uint32(16).uint32(message.appId);
    }
    if (message.rtimeVacbanStarts !== undefined && message.rtimeVacbanStarts !== 0) {
      writer.uint32(24).uint32(message.rtimeVacbanStarts);
    }
    if (message.isBannedNow !== undefined && message.isBannedNow !== false) {
      writer.uint32(32).bool(message.isBannedNow);
    }
    if (message.isBannedFuture !== undefined && message.isBannedFuture !== false) {
      writer.uint32(40).bool(message.isBannedFuture);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCHAccountVacStatusChange {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCHAccountVacStatusChange();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.steamId = longToString(reader.fixed64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.appId = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.rtimeVacbanStarts = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.isBannedNow = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.isBannedFuture = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCHAccountVacStatusChange {
    return {
      steamId: isSet(object.steamId) ? globalThis.String(object.steamId) : "0",
      appId: isSet(object.appId) ? globalThis.Number(object.appId) : 0,
      rtimeVacbanStarts: isSet(object.rtimeVacbanStarts) ? globalThis.Number(object.rtimeVacbanStarts) : 0,
      isBannedNow: isSet(object.isBannedNow) ? globalThis.Boolean(object.isBannedNow) : false,
      isBannedFuture: isSet(object.isBannedFuture) ? globalThis.Boolean(object.isBannedFuture) : false,
    };
  },

  toJSON(message: CMsgGCHAccountVacStatusChange): unknown {
    const obj: any = {};
    if (message.steamId !== undefined && message.steamId !== "0") {
      obj.steamId = message.steamId;
    }
    if (message.appId !== undefined && message.appId !== 0) {
      obj.appId = Math.round(message.appId);
    }
    if (message.rtimeVacbanStarts !== undefined && message.rtimeVacbanStarts !== 0) {
      obj.rtimeVacbanStarts = Math.round(message.rtimeVacbanStarts);
    }
    if (message.isBannedNow !== undefined && message.isBannedNow !== false) {
      obj.isBannedNow = message.isBannedNow;
    }
    if (message.isBannedFuture !== undefined && message.isBannedFuture !== false) {
      obj.isBannedFuture = message.isBannedFuture;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCHAccountVacStatusChange>): CMsgGCHAccountVacStatusChange {
    return CMsgGCHAccountVacStatusChange.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCHAccountVacStatusChange>): CMsgGCHAccountVacStatusChange {
    const message = createBaseCMsgGCHAccountVacStatusChange();
    message.steamId = object.steamId ?? "0";
    message.appId = object.appId ?? 0;
    message.rtimeVacbanStarts = object.rtimeVacbanStarts ?? 0;
    message.isBannedNow = object.isBannedNow ?? false;
    message.isBannedFuture = object.isBannedFuture ?? false;
    return message;
  },
};

function createBaseCMsgGCRoutingInfo(): CMsgGCRoutingInfo {
  return { dirIndex: [], method: 0, fallback: 1, protobufField: 0, webapiParam: "" };
}

export const CMsgGCRoutingInfo = {
  encode(message: CMsgGCRoutingInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.dirIndex) {
      writer.int32(v);
    }
    writer.ldelim();
    if (message.method !== undefined && message.method !== 0) {
      writer.uint32(16).int32(message.method);
    }
    if (message.fallback !== undefined && message.fallback !== 1) {
      writer.uint32(24).int32(message.fallback);
    }
    if (message.protobufField !== undefined && message.protobufField !== 0) {
      writer.uint32(32).uint32(message.protobufField);
    }
    if (message.webapiParam !== undefined && message.webapiParam !== "") {
      writer.uint32(42).string(message.webapiParam);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCRoutingInfo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCRoutingInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.dirIndex.push(reader.int32());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.dirIndex.push(reader.int32());
            }

            continue;
          }

          break;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.method = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.fallback = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.protobufField = reader.uint32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.webapiParam = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCRoutingInfo {
    return {
      dirIndex: globalThis.Array.isArray(object?.dirIndex) ? object.dirIndex.map((e: any) => globalThis.Number(e)) : [],
      method: isSet(object.method) ? cMsgGCRoutingInfo_RoutingMethodFromJSON(object.method) : 0,
      fallback: isSet(object.fallback) ? cMsgGCRoutingInfo_RoutingMethodFromJSON(object.fallback) : 1,
      protobufField: isSet(object.protobufField) ? globalThis.Number(object.protobufField) : 0,
      webapiParam: isSet(object.webapiParam) ? globalThis.String(object.webapiParam) : "",
    };
  },

  toJSON(message: CMsgGCRoutingInfo): unknown {
    const obj: any = {};
    if (message.dirIndex?.length) {
      obj.dirIndex = message.dirIndex.map((e) => Math.round(e));
    }
    if (message.method !== undefined && message.method !== 0) {
      obj.method = cMsgGCRoutingInfo_RoutingMethodToJSON(message.method);
    }
    if (message.fallback !== undefined && message.fallback !== 1) {
      obj.fallback = cMsgGCRoutingInfo_RoutingMethodToJSON(message.fallback);
    }
    if (message.protobufField !== undefined && message.protobufField !== 0) {
      obj.protobufField = Math.round(message.protobufField);
    }
    if (message.webapiParam !== undefined && message.webapiParam !== "") {
      obj.webapiParam = message.webapiParam;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCRoutingInfo>): CMsgGCRoutingInfo {
    return CMsgGCRoutingInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCRoutingInfo>): CMsgGCRoutingInfo {
    const message = createBaseCMsgGCRoutingInfo();
    message.dirIndex = object.dirIndex?.map((e) => e) || [];
    message.method = object.method ?? 0;
    message.fallback = object.fallback ?? 1;
    message.protobufField = object.protobufField ?? 0;
    message.webapiParam = object.webapiParam ?? "";
    return message;
  },
};

function createBaseCMsgGCMsgMasterSetWebAPIRouting(): CMsgGCMsgMasterSetWebAPIRouting {
  return { entries: [] };
}

export const CMsgGCMsgMasterSetWebAPIRouting = {
  encode(message: CMsgGCMsgMasterSetWebAPIRouting, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.entries) {
      CMsgGCMsgMasterSetWebAPIRouting_Entry.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCMsgMasterSetWebAPIRouting {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCMsgMasterSetWebAPIRouting();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.entries.push(CMsgGCMsgMasterSetWebAPIRouting_Entry.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCMsgMasterSetWebAPIRouting {
    return {
      entries: globalThis.Array.isArray(object?.entries)
        ? object.entries.map((e: any) => CMsgGCMsgMasterSetWebAPIRouting_Entry.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgGCMsgMasterSetWebAPIRouting): unknown {
    const obj: any = {};
    if (message.entries?.length) {
      obj.entries = message.entries.map((e) => CMsgGCMsgMasterSetWebAPIRouting_Entry.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCMsgMasterSetWebAPIRouting>): CMsgGCMsgMasterSetWebAPIRouting {
    return CMsgGCMsgMasterSetWebAPIRouting.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCMsgMasterSetWebAPIRouting>): CMsgGCMsgMasterSetWebAPIRouting {
    const message = createBaseCMsgGCMsgMasterSetWebAPIRouting();
    message.entries = object.entries?.map((e) => CMsgGCMsgMasterSetWebAPIRouting_Entry.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgGCMsgMasterSetWebAPIRouting_Entry(): CMsgGCMsgMasterSetWebAPIRouting_Entry {
  return { interfaceName: "", methodName: "", routing: undefined };
}

export const CMsgGCMsgMasterSetWebAPIRouting_Entry = {
  encode(message: CMsgGCMsgMasterSetWebAPIRouting_Entry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.interfaceName !== undefined && message.interfaceName !== "") {
      writer.uint32(10).string(message.interfaceName);
    }
    if (message.methodName !== undefined && message.methodName !== "") {
      writer.uint32(18).string(message.methodName);
    }
    if (message.routing !== undefined) {
      CMsgGCRoutingInfo.encode(message.routing, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCMsgMasterSetWebAPIRouting_Entry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCMsgMasterSetWebAPIRouting_Entry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.interfaceName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.methodName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.routing = CMsgGCRoutingInfo.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCMsgMasterSetWebAPIRouting_Entry {
    return {
      interfaceName: isSet(object.interfaceName) ? globalThis.String(object.interfaceName) : "",
      methodName: isSet(object.methodName) ? globalThis.String(object.methodName) : "",
      routing: isSet(object.routing) ? CMsgGCRoutingInfo.fromJSON(object.routing) : undefined,
    };
  },

  toJSON(message: CMsgGCMsgMasterSetWebAPIRouting_Entry): unknown {
    const obj: any = {};
    if (message.interfaceName !== undefined && message.interfaceName !== "") {
      obj.interfaceName = message.interfaceName;
    }
    if (message.methodName !== undefined && message.methodName !== "") {
      obj.methodName = message.methodName;
    }
    if (message.routing !== undefined) {
      obj.routing = CMsgGCRoutingInfo.toJSON(message.routing);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCMsgMasterSetWebAPIRouting_Entry>): CMsgGCMsgMasterSetWebAPIRouting_Entry {
    return CMsgGCMsgMasterSetWebAPIRouting_Entry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCMsgMasterSetWebAPIRouting_Entry>): CMsgGCMsgMasterSetWebAPIRouting_Entry {
    const message = createBaseCMsgGCMsgMasterSetWebAPIRouting_Entry();
    message.interfaceName = object.interfaceName ?? "";
    message.methodName = object.methodName ?? "";
    message.routing = (object.routing !== undefined && object.routing !== null)
      ? CMsgGCRoutingInfo.fromPartial(object.routing)
      : undefined;
    return message;
  },
};

function createBaseCMsgGCMsgMasterSetClientMsgRouting(): CMsgGCMsgMasterSetClientMsgRouting {
  return { entries: [] };
}

export const CMsgGCMsgMasterSetClientMsgRouting = {
  encode(message: CMsgGCMsgMasterSetClientMsgRouting, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.entries) {
      CMsgGCMsgMasterSetClientMsgRouting_Entry.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCMsgMasterSetClientMsgRouting {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCMsgMasterSetClientMsgRouting();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.entries.push(CMsgGCMsgMasterSetClientMsgRouting_Entry.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCMsgMasterSetClientMsgRouting {
    return {
      entries: globalThis.Array.isArray(object?.entries)
        ? object.entries.map((e: any) => CMsgGCMsgMasterSetClientMsgRouting_Entry.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgGCMsgMasterSetClientMsgRouting): unknown {
    const obj: any = {};
    if (message.entries?.length) {
      obj.entries = message.entries.map((e) => CMsgGCMsgMasterSetClientMsgRouting_Entry.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCMsgMasterSetClientMsgRouting>): CMsgGCMsgMasterSetClientMsgRouting {
    return CMsgGCMsgMasterSetClientMsgRouting.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCMsgMasterSetClientMsgRouting>): CMsgGCMsgMasterSetClientMsgRouting {
    const message = createBaseCMsgGCMsgMasterSetClientMsgRouting();
    message.entries = object.entries?.map((e) => CMsgGCMsgMasterSetClientMsgRouting_Entry.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgGCMsgMasterSetClientMsgRouting_Entry(): CMsgGCMsgMasterSetClientMsgRouting_Entry {
  return { msgType: 0, routing: undefined };
}

export const CMsgGCMsgMasterSetClientMsgRouting_Entry = {
  encode(message: CMsgGCMsgMasterSetClientMsgRouting_Entry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.msgType !== undefined && message.msgType !== 0) {
      writer.uint32(8).uint32(message.msgType);
    }
    if (message.routing !== undefined) {
      CMsgGCRoutingInfo.encode(message.routing, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCMsgMasterSetClientMsgRouting_Entry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCMsgMasterSetClientMsgRouting_Entry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.msgType = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.routing = CMsgGCRoutingInfo.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCMsgMasterSetClientMsgRouting_Entry {
    return {
      msgType: isSet(object.msgType) ? globalThis.Number(object.msgType) : 0,
      routing: isSet(object.routing) ? CMsgGCRoutingInfo.fromJSON(object.routing) : undefined,
    };
  },

  toJSON(message: CMsgGCMsgMasterSetClientMsgRouting_Entry): unknown {
    const obj: any = {};
    if (message.msgType !== undefined && message.msgType !== 0) {
      obj.msgType = Math.round(message.msgType);
    }
    if (message.routing !== undefined) {
      obj.routing = CMsgGCRoutingInfo.toJSON(message.routing);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCMsgMasterSetClientMsgRouting_Entry>): CMsgGCMsgMasterSetClientMsgRouting_Entry {
    return CMsgGCMsgMasterSetClientMsgRouting_Entry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCMsgMasterSetClientMsgRouting_Entry>): CMsgGCMsgMasterSetClientMsgRouting_Entry {
    const message = createBaseCMsgGCMsgMasterSetClientMsgRouting_Entry();
    message.msgType = object.msgType ?? 0;
    message.routing = (object.routing !== undefined && object.routing !== null)
      ? CMsgGCRoutingInfo.fromPartial(object.routing)
      : undefined;
    return message;
  },
};

function createBaseCMsgGCMsgMasterSetWebAPIRoutingResponse(): CMsgGCMsgMasterSetWebAPIRoutingResponse {
  return { eresult: 2 };
}

export const CMsgGCMsgMasterSetWebAPIRoutingResponse = {
  encode(message: CMsgGCMsgMasterSetWebAPIRoutingResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.eresult !== undefined && message.eresult !== 2) {
      writer.uint32(8).int32(message.eresult);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCMsgMasterSetWebAPIRoutingResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCMsgMasterSetWebAPIRoutingResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.eresult = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCMsgMasterSetWebAPIRoutingResponse {
    return { eresult: isSet(object.eresult) ? globalThis.Number(object.eresult) : 2 };
  },

  toJSON(message: CMsgGCMsgMasterSetWebAPIRoutingResponse): unknown {
    const obj: any = {};
    if (message.eresult !== undefined && message.eresult !== 2) {
      obj.eresult = Math.round(message.eresult);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCMsgMasterSetWebAPIRoutingResponse>): CMsgGCMsgMasterSetWebAPIRoutingResponse {
    return CMsgGCMsgMasterSetWebAPIRoutingResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCMsgMasterSetWebAPIRoutingResponse>): CMsgGCMsgMasterSetWebAPIRoutingResponse {
    const message = createBaseCMsgGCMsgMasterSetWebAPIRoutingResponse();
    message.eresult = object.eresult ?? 2;
    return message;
  },
};

function createBaseCMsgGCMsgMasterSetClientMsgRoutingResponse(): CMsgGCMsgMasterSetClientMsgRoutingResponse {
  return { eresult: 2 };
}

export const CMsgGCMsgMasterSetClientMsgRoutingResponse = {
  encode(message: CMsgGCMsgMasterSetClientMsgRoutingResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.eresult !== undefined && message.eresult !== 2) {
      writer.uint32(8).int32(message.eresult);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCMsgMasterSetClientMsgRoutingResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCMsgMasterSetClientMsgRoutingResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.eresult = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCMsgMasterSetClientMsgRoutingResponse {
    return { eresult: isSet(object.eresult) ? globalThis.Number(object.eresult) : 2 };
  },

  toJSON(message: CMsgGCMsgMasterSetClientMsgRoutingResponse): unknown {
    const obj: any = {};
    if (message.eresult !== undefined && message.eresult !== 2) {
      obj.eresult = Math.round(message.eresult);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCMsgMasterSetClientMsgRoutingResponse>): CMsgGCMsgMasterSetClientMsgRoutingResponse {
    return CMsgGCMsgMasterSetClientMsgRoutingResponse.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgGCMsgMasterSetClientMsgRoutingResponse>,
  ): CMsgGCMsgMasterSetClientMsgRoutingResponse {
    const message = createBaseCMsgGCMsgMasterSetClientMsgRoutingResponse();
    message.eresult = object.eresult ?? 2;
    return message;
  },
};

function createBaseCMsgGCMsgSetOptions(): CMsgGCMsgSetOptions {
  return { options: [], clientMsgRanges: [], gcsqlVersion: 1 };
}

export const CMsgGCMsgSetOptions = {
  encode(message: CMsgGCMsgSetOptions, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.options) {
      writer.int32(v);
    }
    writer.ldelim();
    for (const v of message.clientMsgRanges) {
      CMsgGCMsgSetOptions_MessageRange.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.gcsqlVersion !== undefined && message.gcsqlVersion !== 1) {
      writer.uint32(24).int32(message.gcsqlVersion);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCMsgSetOptions {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCMsgSetOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.options.push(reader.int32() as any);

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.options.push(reader.int32() as any);
            }

            continue;
          }

          break;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.clientMsgRanges.push(CMsgGCMsgSetOptions_MessageRange.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.gcsqlVersion = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCMsgSetOptions {
    return {
      options: globalThis.Array.isArray(object?.options)
        ? object.options.map((e: any) => cMsgGCMsgSetOptions_OptionFromJSON(e))
        : [],
      clientMsgRanges: globalThis.Array.isArray(object?.clientMsgRanges)
        ? object.clientMsgRanges.map((e: any) => CMsgGCMsgSetOptions_MessageRange.fromJSON(e))
        : [],
      gcsqlVersion: isSet(object.gcsqlVersion) ? cMsgGCMsgSetOptions_GCSQLVersionFromJSON(object.gcsqlVersion) : 1,
    };
  },

  toJSON(message: CMsgGCMsgSetOptions): unknown {
    const obj: any = {};
    if (message.options?.length) {
      obj.options = message.options.map((e) => cMsgGCMsgSetOptions_OptionToJSON(e));
    }
    if (message.clientMsgRanges?.length) {
      obj.clientMsgRanges = message.clientMsgRanges.map((e) => CMsgGCMsgSetOptions_MessageRange.toJSON(e));
    }
    if (message.gcsqlVersion !== undefined && message.gcsqlVersion !== 1) {
      obj.gcsqlVersion = cMsgGCMsgSetOptions_GCSQLVersionToJSON(message.gcsqlVersion);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCMsgSetOptions>): CMsgGCMsgSetOptions {
    return CMsgGCMsgSetOptions.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCMsgSetOptions>): CMsgGCMsgSetOptions {
    const message = createBaseCMsgGCMsgSetOptions();
    message.options = object.options?.map((e) => e) || [];
    message.clientMsgRanges = object.clientMsgRanges?.map((e) => CMsgGCMsgSetOptions_MessageRange.fromPartial(e)) || [];
    message.gcsqlVersion = object.gcsqlVersion ?? 1;
    return message;
  },
};

function createBaseCMsgGCMsgSetOptions_MessageRange(): CMsgGCMsgSetOptions_MessageRange {
  return { low: 0, high: 0 };
}

export const CMsgGCMsgSetOptions_MessageRange = {
  encode(message: CMsgGCMsgSetOptions_MessageRange, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.low !== 0) {
      writer.uint32(8).uint32(message.low);
    }
    if (message.high !== 0) {
      writer.uint32(16).uint32(message.high);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCMsgSetOptions_MessageRange {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCMsgSetOptions_MessageRange();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.low = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.high = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCMsgSetOptions_MessageRange {
    return {
      low: isSet(object.low) ? globalThis.Number(object.low) : 0,
      high: isSet(object.high) ? globalThis.Number(object.high) : 0,
    };
  },

  toJSON(message: CMsgGCMsgSetOptions_MessageRange): unknown {
    const obj: any = {};
    if (message.low !== 0) {
      obj.low = Math.round(message.low);
    }
    if (message.high !== 0) {
      obj.high = Math.round(message.high);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCMsgSetOptions_MessageRange>): CMsgGCMsgSetOptions_MessageRange {
    return CMsgGCMsgSetOptions_MessageRange.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCMsgSetOptions_MessageRange>): CMsgGCMsgSetOptions_MessageRange {
    const message = createBaseCMsgGCMsgSetOptions_MessageRange();
    message.low = object.low ?? 0;
    message.high = object.high ?? 0;
    return message;
  },
};

function createBaseCMsgGCHUpdateSession(): CMsgGCHUpdateSession {
  return {
    steamId: "0",
    appId: 0,
    online: false,
    serverSteamId: "0",
    serverAddr: 0,
    serverPort: 0,
    osType: 0,
    clientAddr: 0,
    extraFields: [],
  };
}

export const CMsgGCHUpdateSession = {
  encode(message: CMsgGCHUpdateSession, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.steamId !== undefined && message.steamId !== "0") {
      writer.uint32(9).fixed64(message.steamId);
    }
    if (message.appId !== undefined && message.appId !== 0) {
      writer.uint32(16).uint32(message.appId);
    }
    if (message.online !== undefined && message.online !== false) {
      writer.uint32(24).bool(message.online);
    }
    if (message.serverSteamId !== undefined && message.serverSteamId !== "0") {
      writer.uint32(33).fixed64(message.serverSteamId);
    }
    if (message.serverAddr !== undefined && message.serverAddr !== 0) {
      writer.uint32(40).uint32(message.serverAddr);
    }
    if (message.serverPort !== undefined && message.serverPort !== 0) {
      writer.uint32(48).uint32(message.serverPort);
    }
    if (message.osType !== undefined && message.osType !== 0) {
      writer.uint32(56).uint32(message.osType);
    }
    if (message.clientAddr !== undefined && message.clientAddr !== 0) {
      writer.uint32(64).uint32(message.clientAddr);
    }
    for (const v of message.extraFields) {
      CMsgGCHUpdateSession_ExtraField.encode(v!, writer.uint32(74).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCHUpdateSession {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCHUpdateSession();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.steamId = longToString(reader.fixed64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.appId = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.online = reader.bool();
          continue;
        case 4:
          if (tag !== 33) {
            break;
          }

          message.serverSteamId = longToString(reader.fixed64() as Long);
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.serverAddr = reader.uint32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.serverPort = reader.uint32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.osType = reader.uint32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.clientAddr = reader.uint32();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.extraFields.push(CMsgGCHUpdateSession_ExtraField.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCHUpdateSession {
    return {
      steamId: isSet(object.steamId) ? globalThis.String(object.steamId) : "0",
      appId: isSet(object.appId) ? globalThis.Number(object.appId) : 0,
      online: isSet(object.online) ? globalThis.Boolean(object.online) : false,
      serverSteamId: isSet(object.serverSteamId) ? globalThis.String(object.serverSteamId) : "0",
      serverAddr: isSet(object.serverAddr) ? globalThis.Number(object.serverAddr) : 0,
      serverPort: isSet(object.serverPort) ? globalThis.Number(object.serverPort) : 0,
      osType: isSet(object.osType) ? globalThis.Number(object.osType) : 0,
      clientAddr: isSet(object.clientAddr) ? globalThis.Number(object.clientAddr) : 0,
      extraFields: globalThis.Array.isArray(object?.extraFields)
        ? object.extraFields.map((e: any) => CMsgGCHUpdateSession_ExtraField.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgGCHUpdateSession): unknown {
    const obj: any = {};
    if (message.steamId !== undefined && message.steamId !== "0") {
      obj.steamId = message.steamId;
    }
    if (message.appId !== undefined && message.appId !== 0) {
      obj.appId = Math.round(message.appId);
    }
    if (message.online !== undefined && message.online !== false) {
      obj.online = message.online;
    }
    if (message.serverSteamId !== undefined && message.serverSteamId !== "0") {
      obj.serverSteamId = message.serverSteamId;
    }
    if (message.serverAddr !== undefined && message.serverAddr !== 0) {
      obj.serverAddr = Math.round(message.serverAddr);
    }
    if (message.serverPort !== undefined && message.serverPort !== 0) {
      obj.serverPort = Math.round(message.serverPort);
    }
    if (message.osType !== undefined && message.osType !== 0) {
      obj.osType = Math.round(message.osType);
    }
    if (message.clientAddr !== undefined && message.clientAddr !== 0) {
      obj.clientAddr = Math.round(message.clientAddr);
    }
    if (message.extraFields?.length) {
      obj.extraFields = message.extraFields.map((e) => CMsgGCHUpdateSession_ExtraField.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCHUpdateSession>): CMsgGCHUpdateSession {
    return CMsgGCHUpdateSession.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCHUpdateSession>): CMsgGCHUpdateSession {
    const message = createBaseCMsgGCHUpdateSession();
    message.steamId = object.steamId ?? "0";
    message.appId = object.appId ?? 0;
    message.online = object.online ?? false;
    message.serverSteamId = object.serverSteamId ?? "0";
    message.serverAddr = object.serverAddr ?? 0;
    message.serverPort = object.serverPort ?? 0;
    message.osType = object.osType ?? 0;
    message.clientAddr = object.clientAddr ?? 0;
    message.extraFields = object.extraFields?.map((e) => CMsgGCHUpdateSession_ExtraField.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgGCHUpdateSession_ExtraField(): CMsgGCHUpdateSession_ExtraField {
  return { name: "", value: "" };
}

export const CMsgGCHUpdateSession_ExtraField = {
  encode(message: CMsgGCHUpdateSession_ExtraField, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.value !== undefined && message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCHUpdateSession_ExtraField {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCHUpdateSession_ExtraField();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCHUpdateSession_ExtraField {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: CMsgGCHUpdateSession_ExtraField): unknown {
    const obj: any = {};
    if (message.name !== undefined && message.name !== "") {
      obj.name = message.name;
    }
    if (message.value !== undefined && message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCHUpdateSession_ExtraField>): CMsgGCHUpdateSession_ExtraField {
    return CMsgGCHUpdateSession_ExtraField.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCHUpdateSession_ExtraField>): CMsgGCHUpdateSession_ExtraField {
    const message = createBaseCMsgGCHUpdateSession_ExtraField();
    message.name = object.name ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseCMsgNotificationOfSuspiciousActivity(): CMsgNotificationOfSuspiciousActivity {
  return { steamid: "0", appid: 0, multipleInstances: undefined };
}

export const CMsgNotificationOfSuspiciousActivity = {
  encode(message: CMsgNotificationOfSuspiciousActivity, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.steamid !== undefined && message.steamid !== "0") {
      writer.uint32(9).fixed64(message.steamid);
    }
    if (message.appid !== undefined && message.appid !== 0) {
      writer.uint32(16).uint32(message.appid);
    }
    if (message.multipleInstances !== undefined) {
      CMsgNotificationOfSuspiciousActivity_MultipleGameInstances.encode(
        message.multipleInstances,
        writer.uint32(26).fork(),
      ).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgNotificationOfSuspiciousActivity {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgNotificationOfSuspiciousActivity();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.steamid = longToString(reader.fixed64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.appid = reader.uint32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.multipleInstances = CMsgNotificationOfSuspiciousActivity_MultipleGameInstances.decode(
            reader,
            reader.uint32(),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgNotificationOfSuspiciousActivity {
    return {
      steamid: isSet(object.steamid) ? globalThis.String(object.steamid) : "0",
      appid: isSet(object.appid) ? globalThis.Number(object.appid) : 0,
      multipleInstances: isSet(object.multipleInstances)
        ? CMsgNotificationOfSuspiciousActivity_MultipleGameInstances.fromJSON(object.multipleInstances)
        : undefined,
    };
  },

  toJSON(message: CMsgNotificationOfSuspiciousActivity): unknown {
    const obj: any = {};
    if (message.steamid !== undefined && message.steamid !== "0") {
      obj.steamid = message.steamid;
    }
    if (message.appid !== undefined && message.appid !== 0) {
      obj.appid = Math.round(message.appid);
    }
    if (message.multipleInstances !== undefined) {
      obj.multipleInstances = CMsgNotificationOfSuspiciousActivity_MultipleGameInstances.toJSON(
        message.multipleInstances,
      );
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgNotificationOfSuspiciousActivity>): CMsgNotificationOfSuspiciousActivity {
    return CMsgNotificationOfSuspiciousActivity.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgNotificationOfSuspiciousActivity>): CMsgNotificationOfSuspiciousActivity {
    const message = createBaseCMsgNotificationOfSuspiciousActivity();
    message.steamid = object.steamid ?? "0";
    message.appid = object.appid ?? 0;
    message.multipleInstances = (object.multipleInstances !== undefined && object.multipleInstances !== null)
      ? CMsgNotificationOfSuspiciousActivity_MultipleGameInstances.fromPartial(object.multipleInstances)
      : undefined;
    return message;
  },
};

function createBaseCMsgNotificationOfSuspiciousActivity_MultipleGameInstances(): CMsgNotificationOfSuspiciousActivity_MultipleGameInstances {
  return { appInstanceCount: 0, otherSteamids: [] };
}

export const CMsgNotificationOfSuspiciousActivity_MultipleGameInstances = {
  encode(
    message: CMsgNotificationOfSuspiciousActivity_MultipleGameInstances,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.appInstanceCount !== undefined && message.appInstanceCount !== 0) {
      writer.uint32(8).uint32(message.appInstanceCount);
    }
    writer.uint32(18).fork();
    for (const v of message.otherSteamids) {
      writer.fixed64(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgNotificationOfSuspiciousActivity_MultipleGameInstances {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgNotificationOfSuspiciousActivity_MultipleGameInstances();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.appInstanceCount = reader.uint32();
          continue;
        case 2:
          if (tag === 17) {
            message.otherSteamids.push(longToString(reader.fixed64() as Long));

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.otherSteamids.push(longToString(reader.fixed64() as Long));
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgNotificationOfSuspiciousActivity_MultipleGameInstances {
    return {
      appInstanceCount: isSet(object.appInstanceCount) ? globalThis.Number(object.appInstanceCount) : 0,
      otherSteamids: globalThis.Array.isArray(object?.otherSteamids)
        ? object.otherSteamids.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: CMsgNotificationOfSuspiciousActivity_MultipleGameInstances): unknown {
    const obj: any = {};
    if (message.appInstanceCount !== undefined && message.appInstanceCount !== 0) {
      obj.appInstanceCount = Math.round(message.appInstanceCount);
    }
    if (message.otherSteamids?.length) {
      obj.otherSteamids = message.otherSteamids;
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgNotificationOfSuspiciousActivity_MultipleGameInstances>,
  ): CMsgNotificationOfSuspiciousActivity_MultipleGameInstances {
    return CMsgNotificationOfSuspiciousActivity_MultipleGameInstances.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgNotificationOfSuspiciousActivity_MultipleGameInstances>,
  ): CMsgNotificationOfSuspiciousActivity_MultipleGameInstances {
    const message = createBaseCMsgNotificationOfSuspiciousActivity_MultipleGameInstances();
    message.appInstanceCount = object.appInstanceCount ?? 0;
    message.otherSteamids = object.otherSteamids?.map((e) => e) || [];
    return message;
  },
};

function createBaseCMsgGCHVacVerificationChange(): CMsgGCHVacVerificationChange {
  return { steamid: "0", appid: 0, isVerified: false };
}

export const CMsgGCHVacVerificationChange = {
  encode(message: CMsgGCHVacVerificationChange, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.steamid !== undefined && message.steamid !== "0") {
      writer.uint32(9).fixed64(message.steamid);
    }
    if (message.appid !== undefined && message.appid !== 0) {
      writer.uint32(16).uint32(message.appid);
    }
    if (message.isVerified !== undefined && message.isVerified !== false) {
      writer.uint32(24).bool(message.isVerified);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCHVacVerificationChange {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCHVacVerificationChange();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.steamid = longToString(reader.fixed64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.appid = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.isVerified = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCHVacVerificationChange {
    return {
      steamid: isSet(object.steamid) ? globalThis.String(object.steamid) : "0",
      appid: isSet(object.appid) ? globalThis.Number(object.appid) : 0,
      isVerified: isSet(object.isVerified) ? globalThis.Boolean(object.isVerified) : false,
    };
  },

  toJSON(message: CMsgGCHVacVerificationChange): unknown {
    const obj: any = {};
    if (message.steamid !== undefined && message.steamid !== "0") {
      obj.steamid = message.steamid;
    }
    if (message.appid !== undefined && message.appid !== 0) {
      obj.appid = Math.round(message.appid);
    }
    if (message.isVerified !== undefined && message.isVerified !== false) {
      obj.isVerified = message.isVerified;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCHVacVerificationChange>): CMsgGCHVacVerificationChange {
    return CMsgGCHVacVerificationChange.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCHVacVerificationChange>): CMsgGCHVacVerificationChange {
    const message = createBaseCMsgGCHVacVerificationChange();
    message.steamid = object.steamid ?? "0";
    message.appid = object.appid ?? 0;
    message.isVerified = object.isVerified ?? false;
    return message;
  },
};

function createBaseCMsgGCCheckClanMembership(): CMsgGCCheckClanMembership {
  return { steamid: "0", clanid: 0 };
}

export const CMsgGCCheckClanMembership = {
  encode(message: CMsgGCCheckClanMembership, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.steamid !== undefined && message.steamid !== "0") {
      writer.uint32(9).fixed64(message.steamid);
    }
    if (message.clanid !== undefined && message.clanid !== 0) {
      writer.uint32(16).uint32(message.clanid);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCCheckClanMembership {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCCheckClanMembership();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.steamid = longToString(reader.fixed64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.clanid = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCCheckClanMembership {
    return {
      steamid: isSet(object.steamid) ? globalThis.String(object.steamid) : "0",
      clanid: isSet(object.clanid) ? globalThis.Number(object.clanid) : 0,
    };
  },

  toJSON(message: CMsgGCCheckClanMembership): unknown {
    const obj: any = {};
    if (message.steamid !== undefined && message.steamid !== "0") {
      obj.steamid = message.steamid;
    }
    if (message.clanid !== undefined && message.clanid !== 0) {
      obj.clanid = Math.round(message.clanid);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCCheckClanMembership>): CMsgGCCheckClanMembership {
    return CMsgGCCheckClanMembership.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCCheckClanMembership>): CMsgGCCheckClanMembership {
    const message = createBaseCMsgGCCheckClanMembership();
    message.steamid = object.steamid ?? "0";
    message.clanid = object.clanid ?? 0;
    return message;
  },
};

function createBaseCMsgGCCheckClanMembershipResponse(): CMsgGCCheckClanMembershipResponse {
  return { ismember: false };
}

export const CMsgGCCheckClanMembershipResponse = {
  encode(message: CMsgGCCheckClanMembershipResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.ismember !== undefined && message.ismember !== false) {
      writer.uint32(8).bool(message.ismember);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCCheckClanMembershipResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCCheckClanMembershipResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.ismember = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCCheckClanMembershipResponse {
    return { ismember: isSet(object.ismember) ? globalThis.Boolean(object.ismember) : false };
  },

  toJSON(message: CMsgGCCheckClanMembershipResponse): unknown {
    const obj: any = {};
    if (message.ismember !== undefined && message.ismember !== false) {
      obj.ismember = message.ismember;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCCheckClanMembershipResponse>): CMsgGCCheckClanMembershipResponse {
    return CMsgGCCheckClanMembershipResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCCheckClanMembershipResponse>): CMsgGCCheckClanMembershipResponse {
    const message = createBaseCMsgGCCheckClanMembershipResponse();
    message.ismember = object.ismember ?? false;
    return message;
  },
};

function createBaseCMsgGCHAppCheersReceived(): CMsgGCHAppCheersReceived {
  return { appid: 0, cheerTargets: [] };
}

export const CMsgGCHAppCheersReceived = {
  encode(message: CMsgGCHAppCheersReceived, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.appid !== undefined && message.appid !== 0) {
      writer.uint32(8).uint32(message.appid);
    }
    for (const v of message.cheerTargets) {
      CMsgGCHAppCheersReceived_CheerTarget.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCHAppCheersReceived {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCHAppCheersReceived();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.appid = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.cheerTargets.push(CMsgGCHAppCheersReceived_CheerTarget.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCHAppCheersReceived {
    return {
      appid: isSet(object.appid) ? globalThis.Number(object.appid) : 0,
      cheerTargets: globalThis.Array.isArray(object?.cheerTargets)
        ? object.cheerTargets.map((e: any) => CMsgGCHAppCheersReceived_CheerTarget.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgGCHAppCheersReceived): unknown {
    const obj: any = {};
    if (message.appid !== undefined && message.appid !== 0) {
      obj.appid = Math.round(message.appid);
    }
    if (message.cheerTargets?.length) {
      obj.cheerTargets = message.cheerTargets.map((e) => CMsgGCHAppCheersReceived_CheerTarget.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCHAppCheersReceived>): CMsgGCHAppCheersReceived {
    return CMsgGCHAppCheersReceived.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCHAppCheersReceived>): CMsgGCHAppCheersReceived {
    const message = createBaseCMsgGCHAppCheersReceived();
    message.appid = object.appid ?? 0;
    message.cheerTargets = object.cheerTargets?.map((e) => CMsgGCHAppCheersReceived_CheerTarget.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgGCHAppCheersReceived_CheerTypeAmount(): CMsgGCHAppCheersReceived_CheerTypeAmount {
  return { cheerType: 0, cheerAmount: 0 };
}

export const CMsgGCHAppCheersReceived_CheerTypeAmount = {
  encode(message: CMsgGCHAppCheersReceived_CheerTypeAmount, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.cheerType !== undefined && message.cheerType !== 0) {
      writer.uint32(8).uint32(message.cheerType);
    }
    if (message.cheerAmount !== undefined && message.cheerAmount !== 0) {
      writer.uint32(16).uint32(message.cheerAmount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCHAppCheersReceived_CheerTypeAmount {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCHAppCheersReceived_CheerTypeAmount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.cheerType = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.cheerAmount = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCHAppCheersReceived_CheerTypeAmount {
    return {
      cheerType: isSet(object.cheerType) ? globalThis.Number(object.cheerType) : 0,
      cheerAmount: isSet(object.cheerAmount) ? globalThis.Number(object.cheerAmount) : 0,
    };
  },

  toJSON(message: CMsgGCHAppCheersReceived_CheerTypeAmount): unknown {
    const obj: any = {};
    if (message.cheerType !== undefined && message.cheerType !== 0) {
      obj.cheerType = Math.round(message.cheerType);
    }
    if (message.cheerAmount !== undefined && message.cheerAmount !== 0) {
      obj.cheerAmount = Math.round(message.cheerAmount);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCHAppCheersReceived_CheerTypeAmount>): CMsgGCHAppCheersReceived_CheerTypeAmount {
    return CMsgGCHAppCheersReceived_CheerTypeAmount.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCHAppCheersReceived_CheerTypeAmount>): CMsgGCHAppCheersReceived_CheerTypeAmount {
    const message = createBaseCMsgGCHAppCheersReceived_CheerTypeAmount();
    message.cheerType = object.cheerType ?? 0;
    message.cheerAmount = object.cheerAmount ?? 0;
    return message;
  },
};

function createBaseCMsgGCHAppCheersReceived_CheerTarget(): CMsgGCHAppCheersReceived_CheerTarget {
  return { cheerTarget: "0", cheerTypes: [] };
}

export const CMsgGCHAppCheersReceived_CheerTarget = {
  encode(message: CMsgGCHAppCheersReceived_CheerTarget, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.cheerTarget !== undefined && message.cheerTarget !== "0") {
      writer.uint32(8).uint64(message.cheerTarget);
    }
    for (const v of message.cheerTypes) {
      CMsgGCHAppCheersReceived_CheerTypeAmount.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCHAppCheersReceived_CheerTarget {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCHAppCheersReceived_CheerTarget();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.cheerTarget = longToString(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.cheerTypes.push(CMsgGCHAppCheersReceived_CheerTypeAmount.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCHAppCheersReceived_CheerTarget {
    return {
      cheerTarget: isSet(object.cheerTarget) ? globalThis.String(object.cheerTarget) : "0",
      cheerTypes: globalThis.Array.isArray(object?.cheerTypes)
        ? object.cheerTypes.map((e: any) => CMsgGCHAppCheersReceived_CheerTypeAmount.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgGCHAppCheersReceived_CheerTarget): unknown {
    const obj: any = {};
    if (message.cheerTarget !== undefined && message.cheerTarget !== "0") {
      obj.cheerTarget = message.cheerTarget;
    }
    if (message.cheerTypes?.length) {
      obj.cheerTypes = message.cheerTypes.map((e) => CMsgGCHAppCheersReceived_CheerTypeAmount.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCHAppCheersReceived_CheerTarget>): CMsgGCHAppCheersReceived_CheerTarget {
    return CMsgGCHAppCheersReceived_CheerTarget.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCHAppCheersReceived_CheerTarget>): CMsgGCHAppCheersReceived_CheerTarget {
    const message = createBaseCMsgGCHAppCheersReceived_CheerTarget();
    message.cheerTarget = object.cheerTarget ?? "0";
    message.cheerTypes = object.cheerTypes?.map((e) => CMsgGCHAppCheersReceived_CheerTypeAmount.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgGCHAppCheersGetAllowedTypes(): CMsgGCHAppCheersGetAllowedTypes {
  return { appid: 0, cheerTarget: "0" };
}

export const CMsgGCHAppCheersGetAllowedTypes = {
  encode(message: CMsgGCHAppCheersGetAllowedTypes, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.appid !== undefined && message.appid !== 0) {
      writer.uint32(8).uint32(message.appid);
    }
    if (message.cheerTarget !== undefined && message.cheerTarget !== "0") {
      writer.uint32(16).uint64(message.cheerTarget);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCHAppCheersGetAllowedTypes {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCHAppCheersGetAllowedTypes();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.appid = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.cheerTarget = longToString(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCHAppCheersGetAllowedTypes {
    return {
      appid: isSet(object.appid) ? globalThis.Number(object.appid) : 0,
      cheerTarget: isSet(object.cheerTarget) ? globalThis.String(object.cheerTarget) : "0",
    };
  },

  toJSON(message: CMsgGCHAppCheersGetAllowedTypes): unknown {
    const obj: any = {};
    if (message.appid !== undefined && message.appid !== 0) {
      obj.appid = Math.round(message.appid);
    }
    if (message.cheerTarget !== undefined && message.cheerTarget !== "0") {
      obj.cheerTarget = message.cheerTarget;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCHAppCheersGetAllowedTypes>): CMsgGCHAppCheersGetAllowedTypes {
    return CMsgGCHAppCheersGetAllowedTypes.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCHAppCheersGetAllowedTypes>): CMsgGCHAppCheersGetAllowedTypes {
    const message = createBaseCMsgGCHAppCheersGetAllowedTypes();
    message.appid = object.appid ?? 0;
    message.cheerTarget = object.cheerTarget ?? "0";
    return message;
  },
};

function createBaseCMsgGCHAppCheersGetAllowedTypesResponse(): CMsgGCHAppCheersGetAllowedTypesResponse {
  return { cheerTypesValidAllUsers: [], cheerRemaps: [], cacheDuration: 0 };
}

export const CMsgGCHAppCheersGetAllowedTypesResponse = {
  encode(message: CMsgGCHAppCheersGetAllowedTypesResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.cheerTypesValidAllUsers) {
      writer.uint32(v);
    }
    writer.ldelim();
    for (const v of message.cheerRemaps) {
      CMsgGCHAppCheersGetAllowedTypesResponse_CheerRemaps.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.cacheDuration !== undefined && message.cacheDuration !== 0) {
      writer.uint32(24).uint32(message.cacheDuration);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCHAppCheersGetAllowedTypesResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCHAppCheersGetAllowedTypesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.cheerTypesValidAllUsers.push(reader.uint32());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.cheerTypesValidAllUsers.push(reader.uint32());
            }

            continue;
          }

          break;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.cheerRemaps.push(CMsgGCHAppCheersGetAllowedTypesResponse_CheerRemaps.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.cacheDuration = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCHAppCheersGetAllowedTypesResponse {
    return {
      cheerTypesValidAllUsers: globalThis.Array.isArray(object?.cheerTypesValidAllUsers)
        ? object.cheerTypesValidAllUsers.map((e: any) => globalThis.Number(e))
        : [],
      cheerRemaps: globalThis.Array.isArray(object?.cheerRemaps)
        ? object.cheerRemaps.map((e: any) => CMsgGCHAppCheersGetAllowedTypesResponse_CheerRemaps.fromJSON(e))
        : [],
      cacheDuration: isSet(object.cacheDuration) ? globalThis.Number(object.cacheDuration) : 0,
    };
  },

  toJSON(message: CMsgGCHAppCheersGetAllowedTypesResponse): unknown {
    const obj: any = {};
    if (message.cheerTypesValidAllUsers?.length) {
      obj.cheerTypesValidAllUsers = message.cheerTypesValidAllUsers.map((e) => Math.round(e));
    }
    if (message.cheerRemaps?.length) {
      obj.cheerRemaps = message.cheerRemaps.map((e) => CMsgGCHAppCheersGetAllowedTypesResponse_CheerRemaps.toJSON(e));
    }
    if (message.cacheDuration !== undefined && message.cacheDuration !== 0) {
      obj.cacheDuration = Math.round(message.cacheDuration);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgGCHAppCheersGetAllowedTypesResponse>): CMsgGCHAppCheersGetAllowedTypesResponse {
    return CMsgGCHAppCheersGetAllowedTypesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgGCHAppCheersGetAllowedTypesResponse>): CMsgGCHAppCheersGetAllowedTypesResponse {
    const message = createBaseCMsgGCHAppCheersGetAllowedTypesResponse();
    message.cheerTypesValidAllUsers = object.cheerTypesValidAllUsers?.map((e) => e) || [];
    message.cheerRemaps =
      object.cheerRemaps?.map((e) => CMsgGCHAppCheersGetAllowedTypesResponse_CheerRemaps.fromPartial(e)) || [];
    message.cacheDuration = object.cacheDuration ?? 0;
    return message;
  },
};

function createBaseCMsgGCHAppCheersGetAllowedTypesResponse_CheerRemaps(): CMsgGCHAppCheersGetAllowedTypesResponse_CheerRemaps {
  return { originalCheerType: 0, remappedCheerType: 0, accountIds: [] };
}

export const CMsgGCHAppCheersGetAllowedTypesResponse_CheerRemaps = {
  encode(
    message: CMsgGCHAppCheersGetAllowedTypesResponse_CheerRemaps,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.originalCheerType !== undefined && message.originalCheerType !== 0) {
      writer.uint32(8).uint32(message.originalCheerType);
    }
    if (message.remappedCheerType !== undefined && message.remappedCheerType !== 0) {
      writer.uint32(16).uint32(message.remappedCheerType);
    }
    writer.uint32(26).fork();
    for (const v of message.accountIds) {
      writer.uint32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgGCHAppCheersGetAllowedTypesResponse_CheerRemaps {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgGCHAppCheersGetAllowedTypesResponse_CheerRemaps();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.originalCheerType = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.remappedCheerType = reader.uint32();
          continue;
        case 3:
          if (tag === 24) {
            message.accountIds.push(reader.uint32());

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.accountIds.push(reader.uint32());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgGCHAppCheersGetAllowedTypesResponse_CheerRemaps {
    return {
      originalCheerType: isSet(object.originalCheerType) ? globalThis.Number(object.originalCheerType) : 0,
      remappedCheerType: isSet(object.remappedCheerType) ? globalThis.Number(object.remappedCheerType) : 0,
      accountIds: globalThis.Array.isArray(object?.accountIds)
        ? object.accountIds.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: CMsgGCHAppCheersGetAllowedTypesResponse_CheerRemaps): unknown {
    const obj: any = {};
    if (message.originalCheerType !== undefined && message.originalCheerType !== 0) {
      obj.originalCheerType = Math.round(message.originalCheerType);
    }
    if (message.remappedCheerType !== undefined && message.remappedCheerType !== 0) {
      obj.remappedCheerType = Math.round(message.remappedCheerType);
    }
    if (message.accountIds?.length) {
      obj.accountIds = message.accountIds.map((e) => Math.round(e));
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgGCHAppCheersGetAllowedTypesResponse_CheerRemaps>,
  ): CMsgGCHAppCheersGetAllowedTypesResponse_CheerRemaps {
    return CMsgGCHAppCheersGetAllowedTypesResponse_CheerRemaps.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgGCHAppCheersGetAllowedTypesResponse_CheerRemaps>,
  ): CMsgGCHAppCheersGetAllowedTypesResponse_CheerRemaps {
    const message = createBaseCMsgGCHAppCheersGetAllowedTypesResponse_CheerRemaps();
    message.originalCheerType = object.originalCheerType ?? 0;
    message.remappedCheerType = object.remappedCheerType ?? 0;
    message.accountIds = object.accountIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseCWorkshopAddSpecialPaymentRequest(): CWorkshopAddSpecialPaymentRequest {
  return { appid: 0, gameitemid: 0, date: "", paymentUsUsd: "0", paymentRowUsd: "0" };
}

export const CWorkshopAddSpecialPaymentRequest = {
  encode(message: CWorkshopAddSpecialPaymentRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.appid !== undefined && message.appid !== 0) {
      writer.uint32(8).uint32(message.appid);
    }
    if (message.gameitemid !== undefined && message.gameitemid !== 0) {
      writer.uint32(16).uint32(message.gameitemid);
    }
    if (message.date !== undefined && message.date !== "") {
      writer.uint32(26).string(message.date);
    }
    if (message.paymentUsUsd !== undefined && message.paymentUsUsd !== "0") {
      writer.uint32(32).uint64(message.paymentUsUsd);
    }
    if (message.paymentRowUsd !== undefined && message.paymentRowUsd !== "0") {
      writer.uint32(40).uint64(message.paymentRowUsd);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CWorkshopAddSpecialPaymentRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCWorkshopAddSpecialPaymentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.appid = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.gameitemid = reader.uint32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.date = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.paymentUsUsd = longToString(reader.uint64() as Long);
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.paymentRowUsd = longToString(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CWorkshopAddSpecialPaymentRequest {
    return {
      appid: isSet(object.appid) ? globalThis.Number(object.appid) : 0,
      gameitemid: isSet(object.gameitemid) ? globalThis.Number(object.gameitemid) : 0,
      date: isSet(object.date) ? globalThis.String(object.date) : "",
      paymentUsUsd: isSet(object.paymentUsUsd) ? globalThis.String(object.paymentUsUsd) : "0",
      paymentRowUsd: isSet(object.paymentRowUsd) ? globalThis.String(object.paymentRowUsd) : "0",
    };
  },

  toJSON(message: CWorkshopAddSpecialPaymentRequest): unknown {
    const obj: any = {};
    if (message.appid !== undefined && message.appid !== 0) {
      obj.appid = Math.round(message.appid);
    }
    if (message.gameitemid !== undefined && message.gameitemid !== 0) {
      obj.gameitemid = Math.round(message.gameitemid);
    }
    if (message.date !== undefined && message.date !== "") {
      obj.date = message.date;
    }
    if (message.paymentUsUsd !== undefined && message.paymentUsUsd !== "0") {
      obj.paymentUsUsd = message.paymentUsUsd;
    }
    if (message.paymentRowUsd !== undefined && message.paymentRowUsd !== "0") {
      obj.paymentRowUsd = message.paymentRowUsd;
    }
    return obj;
  },

  create(base?: DeepPartial<CWorkshopAddSpecialPaymentRequest>): CWorkshopAddSpecialPaymentRequest {
    return CWorkshopAddSpecialPaymentRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CWorkshopAddSpecialPaymentRequest>): CWorkshopAddSpecialPaymentRequest {
    const message = createBaseCWorkshopAddSpecialPaymentRequest();
    message.appid = object.appid ?? 0;
    message.gameitemid = object.gameitemid ?? 0;
    message.date = object.date ?? "";
    message.paymentUsUsd = object.paymentUsUsd ?? "0";
    message.paymentRowUsd = object.paymentRowUsd ?? "0";
    return message;
  },
};

function createBaseCWorkshopAddSpecialPaymentResponse(): CWorkshopAddSpecialPaymentResponse {
  return {};
}

export const CWorkshopAddSpecialPaymentResponse = {
  encode(_: CWorkshopAddSpecialPaymentResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CWorkshopAddSpecialPaymentResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCWorkshopAddSpecialPaymentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CWorkshopAddSpecialPaymentResponse {
    return {};
  },

  toJSON(_: CWorkshopAddSpecialPaymentResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<CWorkshopAddSpecialPaymentResponse>): CWorkshopAddSpecialPaymentResponse {
    return CWorkshopAddSpecialPaymentResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<CWorkshopAddSpecialPaymentResponse>): CWorkshopAddSpecialPaymentResponse {
    const message = createBaseCWorkshopAddSpecialPaymentResponse();
    return message;
  },
};

function createBaseCWorkshopGetSpecialPaymentsRequest(): CWorkshopGetSpecialPaymentsRequest {
  return { appid: 0, gameitemid: 0, date: "" };
}

export const CWorkshopGetSpecialPaymentsRequest = {
  encode(message: CWorkshopGetSpecialPaymentsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.appid !== undefined && message.appid !== 0) {
      writer.uint32(8).uint32(message.appid);
    }
    if (message.gameitemid !== undefined && message.gameitemid !== 0) {
      writer.uint32(16).uint32(message.gameitemid);
    }
    if (message.date !== undefined && message.date !== "") {
      writer.uint32(26).string(message.date);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CWorkshopGetSpecialPaymentsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCWorkshopGetSpecialPaymentsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.appid = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.gameitemid = reader.uint32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.date = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CWorkshopGetSpecialPaymentsRequest {
    return {
      appid: isSet(object.appid) ? globalThis.Number(object.appid) : 0,
      gameitemid: isSet(object.gameitemid) ? globalThis.Number(object.gameitemid) : 0,
      date: isSet(object.date) ? globalThis.String(object.date) : "",
    };
  },

  toJSON(message: CWorkshopGetSpecialPaymentsRequest): unknown {
    const obj: any = {};
    if (message.appid !== undefined && message.appid !== 0) {
      obj.appid = Math.round(message.appid);
    }
    if (message.gameitemid !== undefined && message.gameitemid !== 0) {
      obj.gameitemid = Math.round(message.gameitemid);
    }
    if (message.date !== undefined && message.date !== "") {
      obj.date = message.date;
    }
    return obj;
  },

  create(base?: DeepPartial<CWorkshopGetSpecialPaymentsRequest>): CWorkshopGetSpecialPaymentsRequest {
    return CWorkshopGetSpecialPaymentsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CWorkshopGetSpecialPaymentsRequest>): CWorkshopGetSpecialPaymentsRequest {
    const message = createBaseCWorkshopGetSpecialPaymentsRequest();
    message.appid = object.appid ?? 0;
    message.gameitemid = object.gameitemid ?? 0;
    message.date = object.date ?? "";
    return message;
  },
};

function createBaseCWorkshopGetSpecialPaymentsResponse(): CWorkshopGetSpecialPaymentsResponse {
  return { specialPayments: [] };
}

export const CWorkshopGetSpecialPaymentsResponse = {
  encode(message: CWorkshopGetSpecialPaymentsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.specialPayments) {
      CWorkshopGetSpecialPaymentsResponse_SpecialPayment.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CWorkshopGetSpecialPaymentsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCWorkshopGetSpecialPaymentsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.specialPayments.push(
            CWorkshopGetSpecialPaymentsResponse_SpecialPayment.decode(reader, reader.uint32()),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CWorkshopGetSpecialPaymentsResponse {
    return {
      specialPayments: globalThis.Array.isArray(object?.specialPayments)
        ? object.specialPayments.map((e: any) => CWorkshopGetSpecialPaymentsResponse_SpecialPayment.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CWorkshopGetSpecialPaymentsResponse): unknown {
    const obj: any = {};
    if (message.specialPayments?.length) {
      obj.specialPayments = message.specialPayments.map((e) =>
        CWorkshopGetSpecialPaymentsResponse_SpecialPayment.toJSON(e)
      );
    }
    return obj;
  },

  create(base?: DeepPartial<CWorkshopGetSpecialPaymentsResponse>): CWorkshopGetSpecialPaymentsResponse {
    return CWorkshopGetSpecialPaymentsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CWorkshopGetSpecialPaymentsResponse>): CWorkshopGetSpecialPaymentsResponse {
    const message = createBaseCWorkshopGetSpecialPaymentsResponse();
    message.specialPayments =
      object.specialPayments?.map((e) => CWorkshopGetSpecialPaymentsResponse_SpecialPayment.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCWorkshopGetSpecialPaymentsResponse_SpecialPayment(): CWorkshopGetSpecialPaymentsResponse_SpecialPayment {
  return { appid: 0, gameitemid: 0, date: "", netPaymentUsUsd: "0", netPaymentRowUsd: "0" };
}

export const CWorkshopGetSpecialPaymentsResponse_SpecialPayment = {
  encode(
    message: CWorkshopGetSpecialPaymentsResponse_SpecialPayment,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.appid !== undefined && message.appid !== 0) {
      writer.uint32(8).uint32(message.appid);
    }
    if (message.gameitemid !== undefined && message.gameitemid !== 0) {
      writer.uint32(16).uint32(message.gameitemid);
    }
    if (message.date !== undefined && message.date !== "") {
      writer.uint32(26).string(message.date);
    }
    if (message.netPaymentUsUsd !== undefined && message.netPaymentUsUsd !== "0") {
      writer.uint32(32).uint64(message.netPaymentUsUsd);
    }
    if (message.netPaymentRowUsd !== undefined && message.netPaymentRowUsd !== "0") {
      writer.uint32(40).uint64(message.netPaymentRowUsd);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CWorkshopGetSpecialPaymentsResponse_SpecialPayment {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCWorkshopGetSpecialPaymentsResponse_SpecialPayment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.appid = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.gameitemid = reader.uint32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.date = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.netPaymentUsUsd = longToString(reader.uint64() as Long);
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.netPaymentRowUsd = longToString(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CWorkshopGetSpecialPaymentsResponse_SpecialPayment {
    return {
      appid: isSet(object.appid) ? globalThis.Number(object.appid) : 0,
      gameitemid: isSet(object.gameitemid) ? globalThis.Number(object.gameitemid) : 0,
      date: isSet(object.date) ? globalThis.String(object.date) : "",
      netPaymentUsUsd: isSet(object.netPaymentUsUsd) ? globalThis.String(object.netPaymentUsUsd) : "0",
      netPaymentRowUsd: isSet(object.netPaymentRowUsd) ? globalThis.String(object.netPaymentRowUsd) : "0",
    };
  },

  toJSON(message: CWorkshopGetSpecialPaymentsResponse_SpecialPayment): unknown {
    const obj: any = {};
    if (message.appid !== undefined && message.appid !== 0) {
      obj.appid = Math.round(message.appid);
    }
    if (message.gameitemid !== undefined && message.gameitemid !== 0) {
      obj.gameitemid = Math.round(message.gameitemid);
    }
    if (message.date !== undefined && message.date !== "") {
      obj.date = message.date;
    }
    if (message.netPaymentUsUsd !== undefined && message.netPaymentUsUsd !== "0") {
      obj.netPaymentUsUsd = message.netPaymentUsUsd;
    }
    if (message.netPaymentRowUsd !== undefined && message.netPaymentRowUsd !== "0") {
      obj.netPaymentRowUsd = message.netPaymentRowUsd;
    }
    return obj;
  },

  create(
    base?: DeepPartial<CWorkshopGetSpecialPaymentsResponse_SpecialPayment>,
  ): CWorkshopGetSpecialPaymentsResponse_SpecialPayment {
    return CWorkshopGetSpecialPaymentsResponse_SpecialPayment.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CWorkshopGetSpecialPaymentsResponse_SpecialPayment>,
  ): CWorkshopGetSpecialPaymentsResponse_SpecialPayment {
    const message = createBaseCWorkshopGetSpecialPaymentsResponse_SpecialPayment();
    message.appid = object.appid ?? 0;
    message.gameitemid = object.gameitemid ?? 0;
    message.date = object.date ?? "";
    message.netPaymentUsUsd = object.netPaymentUsUsd ?? "0";
    message.netPaymentRowUsd = object.netPaymentRowUsd ?? "0";
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function longToString(long: Long) {
  return long.toString();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.176.1
//   protoc               v5.26.1
// source: steammessages_steamlearn.steamworkssdk.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";

export enum ESteamLearnDataType {
  STEAMLEARN_DATATYPE_INVALID = 0,
  STEAMLEARN_DATATYPE_INT32 = 1,
  STEAMLEARN_DATATYPE_FLOAT32 = 2,
  STEAMLEARN_DATATYPE_BOOL = 3,
  STEAMLEARN_DATATYPE_STRING = 4,
  STEAMLEARN_DATATYPE_OBJECT = 5,
}

export function eSteamLearnDataTypeFromJSON(object: any): ESteamLearnDataType {
  switch (object) {
    case 0:
    case "STEAMLEARN_DATATYPE_INVALID":
      return ESteamLearnDataType.STEAMLEARN_DATATYPE_INVALID;
    case 1:
    case "STEAMLEARN_DATATYPE_INT32":
      return ESteamLearnDataType.STEAMLEARN_DATATYPE_INT32;
    case 2:
    case "STEAMLEARN_DATATYPE_FLOAT32":
      return ESteamLearnDataType.STEAMLEARN_DATATYPE_FLOAT32;
    case 3:
    case "STEAMLEARN_DATATYPE_BOOL":
      return ESteamLearnDataType.STEAMLEARN_DATATYPE_BOOL;
    case 4:
    case "STEAMLEARN_DATATYPE_STRING":
      return ESteamLearnDataType.STEAMLEARN_DATATYPE_STRING;
    case 5:
    case "STEAMLEARN_DATATYPE_OBJECT":
      return ESteamLearnDataType.STEAMLEARN_DATATYPE_OBJECT;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ESteamLearnDataType");
  }
}

export function eSteamLearnDataTypeToJSON(object: ESteamLearnDataType): string {
  switch (object) {
    case ESteamLearnDataType.STEAMLEARN_DATATYPE_INVALID:
      return "STEAMLEARN_DATATYPE_INVALID";
    case ESteamLearnDataType.STEAMLEARN_DATATYPE_INT32:
      return "STEAMLEARN_DATATYPE_INT32";
    case ESteamLearnDataType.STEAMLEARN_DATATYPE_FLOAT32:
      return "STEAMLEARN_DATATYPE_FLOAT32";
    case ESteamLearnDataType.STEAMLEARN_DATATYPE_BOOL:
      return "STEAMLEARN_DATATYPE_BOOL";
    case ESteamLearnDataType.STEAMLEARN_DATATYPE_STRING:
      return "STEAMLEARN_DATATYPE_STRING";
    case ESteamLearnDataType.STEAMLEARN_DATATYPE_OBJECT:
      return "STEAMLEARN_DATATYPE_OBJECT";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ESteamLearnDataType");
  }
}

export enum ESteammLearnRegisterDataSourceResult {
  STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR = 0,
  STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_SUCCESS_CREATED = 1,
  STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_SUCCESS_FOUND = 2,
  STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_GENERIC = 3,
  STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_INVALID_NAME = 4,
  STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_INVALID_VERSION = 5,
  STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_DATA_CHANGED = 6,
  STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_DATA_INVALID = 7,
  STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_FORBIDDEN = 8,
  STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_INVALID_TIMESTAMP = 9,
  STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_DISABLED = 10,
}

export function eSteammLearnRegisterDataSourceResultFromJSON(object: any): ESteammLearnRegisterDataSourceResult {
  switch (object) {
    case 0:
    case "STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR":
      return ESteammLearnRegisterDataSourceResult.STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR;
    case 1:
    case "STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_SUCCESS_CREATED":
      return ESteammLearnRegisterDataSourceResult.STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_SUCCESS_CREATED;
    case 2:
    case "STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_SUCCESS_FOUND":
      return ESteammLearnRegisterDataSourceResult.STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_SUCCESS_FOUND;
    case 3:
    case "STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_GENERIC":
      return ESteammLearnRegisterDataSourceResult.STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_GENERIC;
    case 4:
    case "STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_INVALID_NAME":
      return ESteammLearnRegisterDataSourceResult.STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_INVALID_NAME;
    case 5:
    case "STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_INVALID_VERSION":
      return ESteammLearnRegisterDataSourceResult.STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_INVALID_VERSION;
    case 6:
    case "STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_DATA_CHANGED":
      return ESteammLearnRegisterDataSourceResult.STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_DATA_CHANGED;
    case 7:
    case "STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_DATA_INVALID":
      return ESteammLearnRegisterDataSourceResult.STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_DATA_INVALID;
    case 8:
    case "STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_FORBIDDEN":
      return ESteammLearnRegisterDataSourceResult.STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_FORBIDDEN;
    case 9:
    case "STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_INVALID_TIMESTAMP":
      return ESteammLearnRegisterDataSourceResult.STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_INVALID_TIMESTAMP;
    case 10:
    case "STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_DISABLED":
      return ESteammLearnRegisterDataSourceResult.STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_DISABLED;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum ESteammLearnRegisterDataSourceResult",
      );
  }
}

export function eSteammLearnRegisterDataSourceResultToJSON(object: ESteammLearnRegisterDataSourceResult): string {
  switch (object) {
    case ESteammLearnRegisterDataSourceResult.STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR:
      return "STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR";
    case ESteammLearnRegisterDataSourceResult.STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_SUCCESS_CREATED:
      return "STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_SUCCESS_CREATED";
    case ESteammLearnRegisterDataSourceResult.STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_SUCCESS_FOUND:
      return "STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_SUCCESS_FOUND";
    case ESteammLearnRegisterDataSourceResult.STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_GENERIC:
      return "STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_GENERIC";
    case ESteammLearnRegisterDataSourceResult.STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_INVALID_NAME:
      return "STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_INVALID_NAME";
    case ESteammLearnRegisterDataSourceResult.STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_INVALID_VERSION:
      return "STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_INVALID_VERSION";
    case ESteammLearnRegisterDataSourceResult.STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_DATA_CHANGED:
      return "STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_DATA_CHANGED";
    case ESteammLearnRegisterDataSourceResult.STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_DATA_INVALID:
      return "STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_DATA_INVALID";
    case ESteammLearnRegisterDataSourceResult.STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_FORBIDDEN:
      return "STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_FORBIDDEN";
    case ESteammLearnRegisterDataSourceResult.STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_INVALID_TIMESTAMP:
      return "STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_INVALID_TIMESTAMP";
    case ESteammLearnRegisterDataSourceResult.STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_DISABLED:
      return "STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_DISABLED";
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum ESteammLearnRegisterDataSourceResult",
      );
  }
}

export enum ESteamLearnCacheDataResult {
  STEAMLEARN_CACHE_DATA_ERROR = 0,
  STEAMLEARN_CACHE_DATA_SUCCESS = 1,
  STEAMLEARN_CACHE_DATA_ERROR_UNKNOWN_DATA_SOURCE = 2,
  STEAMLEARN_CACHE_DATA_ERROR_UNCACHED_DATA_SOURCE = 3,
  STEAMLEARN_CACHE_DATA_ERROR_INVALID_KEYS = 4,
  STEAMLEARN_CACHE_DATA_ERROR_FORBIDDEN = 5,
  STEAMLEARN_CACHE_DATA_ERROR_INVALID_TIMESTAMP = 6,
  STEAMLEARN_CACHE_DATA_DISABLED = 7,
}

export function eSteamLearnCacheDataResultFromJSON(object: any): ESteamLearnCacheDataResult {
  switch (object) {
    case 0:
    case "STEAMLEARN_CACHE_DATA_ERROR":
      return ESteamLearnCacheDataResult.STEAMLEARN_CACHE_DATA_ERROR;
    case 1:
    case "STEAMLEARN_CACHE_DATA_SUCCESS":
      return ESteamLearnCacheDataResult.STEAMLEARN_CACHE_DATA_SUCCESS;
    case 2:
    case "STEAMLEARN_CACHE_DATA_ERROR_UNKNOWN_DATA_SOURCE":
      return ESteamLearnCacheDataResult.STEAMLEARN_CACHE_DATA_ERROR_UNKNOWN_DATA_SOURCE;
    case 3:
    case "STEAMLEARN_CACHE_DATA_ERROR_UNCACHED_DATA_SOURCE":
      return ESteamLearnCacheDataResult.STEAMLEARN_CACHE_DATA_ERROR_UNCACHED_DATA_SOURCE;
    case 4:
    case "STEAMLEARN_CACHE_DATA_ERROR_INVALID_KEYS":
      return ESteamLearnCacheDataResult.STEAMLEARN_CACHE_DATA_ERROR_INVALID_KEYS;
    case 5:
    case "STEAMLEARN_CACHE_DATA_ERROR_FORBIDDEN":
      return ESteamLearnCacheDataResult.STEAMLEARN_CACHE_DATA_ERROR_FORBIDDEN;
    case 6:
    case "STEAMLEARN_CACHE_DATA_ERROR_INVALID_TIMESTAMP":
      return ESteamLearnCacheDataResult.STEAMLEARN_CACHE_DATA_ERROR_INVALID_TIMESTAMP;
    case 7:
    case "STEAMLEARN_CACHE_DATA_DISABLED":
      return ESteamLearnCacheDataResult.STEAMLEARN_CACHE_DATA_DISABLED;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ESteamLearnCacheDataResult");
  }
}

export function eSteamLearnCacheDataResultToJSON(object: ESteamLearnCacheDataResult): string {
  switch (object) {
    case ESteamLearnCacheDataResult.STEAMLEARN_CACHE_DATA_ERROR:
      return "STEAMLEARN_CACHE_DATA_ERROR";
    case ESteamLearnCacheDataResult.STEAMLEARN_CACHE_DATA_SUCCESS:
      return "STEAMLEARN_CACHE_DATA_SUCCESS";
    case ESteamLearnCacheDataResult.STEAMLEARN_CACHE_DATA_ERROR_UNKNOWN_DATA_SOURCE:
      return "STEAMLEARN_CACHE_DATA_ERROR_UNKNOWN_DATA_SOURCE";
    case ESteamLearnCacheDataResult.STEAMLEARN_CACHE_DATA_ERROR_UNCACHED_DATA_SOURCE:
      return "STEAMLEARN_CACHE_DATA_ERROR_UNCACHED_DATA_SOURCE";
    case ESteamLearnCacheDataResult.STEAMLEARN_CACHE_DATA_ERROR_INVALID_KEYS:
      return "STEAMLEARN_CACHE_DATA_ERROR_INVALID_KEYS";
    case ESteamLearnCacheDataResult.STEAMLEARN_CACHE_DATA_ERROR_FORBIDDEN:
      return "STEAMLEARN_CACHE_DATA_ERROR_FORBIDDEN";
    case ESteamLearnCacheDataResult.STEAMLEARN_CACHE_DATA_ERROR_INVALID_TIMESTAMP:
      return "STEAMLEARN_CACHE_DATA_ERROR_INVALID_TIMESTAMP";
    case ESteamLearnCacheDataResult.STEAMLEARN_CACHE_DATA_DISABLED:
      return "STEAMLEARN_CACHE_DATA_DISABLED";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ESteamLearnCacheDataResult");
  }
}

export enum ESteamLearnSnapshotProjectResult {
  STEAMLEARN_SNAPSHOT_PROJECT_ERROR = 0,
  STEAMLEARN_SNAPSHOT_PROJECT_SUCCESS_STORED = 1,
  STEAMLEARN_SNAPSHOT_PROJECT_SUCCESS_QUEUED = 2,
  STEAMLEARN_SNAPSHOT_PROJECT_ERROR_INVALID_PROJECT_ID = 3,
  STEAMLEARN_SNAPSHOT_PROJECT_ERROR_UNKNOWN_DATA_SOURCE = 4,
  STEAMLEARN_SNAPSHOT_PROJECT_ERROR_INVALID_DATA_SOURCE_KEY = 5,
  STEAMLEARN_SNAPSHOT_PROJECT_ERROR_MISSING_CACHE_DURATION = 6,
  STEAMLEARN_SNAPSHOT_PROJECT_ERROR_NO_PUBLISHED_CONFIG = 7,
  STEAMLEARN_SNAPSHOT_PROJECT_ERROR_FORBIDDEN = 8,
  STEAMLEARN_SNAPSHOT_PROJECT_ERROR_INVALID_TIMESTAMP = 9,
  STEAMLEARN_SNAPSHOT_PROJECT_ERROR_INTERNAL_DATA_SOURCE_ERROR = 10,
  STEAMLEARN_SNAPSHOT_PROJECT_DISABLED = 11,
  STEAMLEARN_SNAPSHOT_PROJECT_ERROR_INVALID_PUBLISHED_VERSION = 12,
}

export function eSteamLearnSnapshotProjectResultFromJSON(object: any): ESteamLearnSnapshotProjectResult {
  switch (object) {
    case 0:
    case "STEAMLEARN_SNAPSHOT_PROJECT_ERROR":
      return ESteamLearnSnapshotProjectResult.STEAMLEARN_SNAPSHOT_PROJECT_ERROR;
    case 1:
    case "STEAMLEARN_SNAPSHOT_PROJECT_SUCCESS_STORED":
      return ESteamLearnSnapshotProjectResult.STEAMLEARN_SNAPSHOT_PROJECT_SUCCESS_STORED;
    case 2:
    case "STEAMLEARN_SNAPSHOT_PROJECT_SUCCESS_QUEUED":
      return ESteamLearnSnapshotProjectResult.STEAMLEARN_SNAPSHOT_PROJECT_SUCCESS_QUEUED;
    case 3:
    case "STEAMLEARN_SNAPSHOT_PROJECT_ERROR_INVALID_PROJECT_ID":
      return ESteamLearnSnapshotProjectResult.STEAMLEARN_SNAPSHOT_PROJECT_ERROR_INVALID_PROJECT_ID;
    case 4:
    case "STEAMLEARN_SNAPSHOT_PROJECT_ERROR_UNKNOWN_DATA_SOURCE":
      return ESteamLearnSnapshotProjectResult.STEAMLEARN_SNAPSHOT_PROJECT_ERROR_UNKNOWN_DATA_SOURCE;
    case 5:
    case "STEAMLEARN_SNAPSHOT_PROJECT_ERROR_INVALID_DATA_SOURCE_KEY":
      return ESteamLearnSnapshotProjectResult.STEAMLEARN_SNAPSHOT_PROJECT_ERROR_INVALID_DATA_SOURCE_KEY;
    case 6:
    case "STEAMLEARN_SNAPSHOT_PROJECT_ERROR_MISSING_CACHE_DURATION":
      return ESteamLearnSnapshotProjectResult.STEAMLEARN_SNAPSHOT_PROJECT_ERROR_MISSING_CACHE_DURATION;
    case 7:
    case "STEAMLEARN_SNAPSHOT_PROJECT_ERROR_NO_PUBLISHED_CONFIG":
      return ESteamLearnSnapshotProjectResult.STEAMLEARN_SNAPSHOT_PROJECT_ERROR_NO_PUBLISHED_CONFIG;
    case 8:
    case "STEAMLEARN_SNAPSHOT_PROJECT_ERROR_FORBIDDEN":
      return ESteamLearnSnapshotProjectResult.STEAMLEARN_SNAPSHOT_PROJECT_ERROR_FORBIDDEN;
    case 9:
    case "STEAMLEARN_SNAPSHOT_PROJECT_ERROR_INVALID_TIMESTAMP":
      return ESteamLearnSnapshotProjectResult.STEAMLEARN_SNAPSHOT_PROJECT_ERROR_INVALID_TIMESTAMP;
    case 10:
    case "STEAMLEARN_SNAPSHOT_PROJECT_ERROR_INTERNAL_DATA_SOURCE_ERROR":
      return ESteamLearnSnapshotProjectResult.STEAMLEARN_SNAPSHOT_PROJECT_ERROR_INTERNAL_DATA_SOURCE_ERROR;
    case 11:
    case "STEAMLEARN_SNAPSHOT_PROJECT_DISABLED":
      return ESteamLearnSnapshotProjectResult.STEAMLEARN_SNAPSHOT_PROJECT_DISABLED;
    case 12:
    case "STEAMLEARN_SNAPSHOT_PROJECT_ERROR_INVALID_PUBLISHED_VERSION":
      return ESteamLearnSnapshotProjectResult.STEAMLEARN_SNAPSHOT_PROJECT_ERROR_INVALID_PUBLISHED_VERSION;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ESteamLearnSnapshotProjectResult");
  }
}

export function eSteamLearnSnapshotProjectResultToJSON(object: ESteamLearnSnapshotProjectResult): string {
  switch (object) {
    case ESteamLearnSnapshotProjectResult.STEAMLEARN_SNAPSHOT_PROJECT_ERROR:
      return "STEAMLEARN_SNAPSHOT_PROJECT_ERROR";
    case ESteamLearnSnapshotProjectResult.STEAMLEARN_SNAPSHOT_PROJECT_SUCCESS_STORED:
      return "STEAMLEARN_SNAPSHOT_PROJECT_SUCCESS_STORED";
    case ESteamLearnSnapshotProjectResult.STEAMLEARN_SNAPSHOT_PROJECT_SUCCESS_QUEUED:
      return "STEAMLEARN_SNAPSHOT_PROJECT_SUCCESS_QUEUED";
    case ESteamLearnSnapshotProjectResult.STEAMLEARN_SNAPSHOT_PROJECT_ERROR_INVALID_PROJECT_ID:
      return "STEAMLEARN_SNAPSHOT_PROJECT_ERROR_INVALID_PROJECT_ID";
    case ESteamLearnSnapshotProjectResult.STEAMLEARN_SNAPSHOT_PROJECT_ERROR_UNKNOWN_DATA_SOURCE:
      return "STEAMLEARN_SNAPSHOT_PROJECT_ERROR_UNKNOWN_DATA_SOURCE";
    case ESteamLearnSnapshotProjectResult.STEAMLEARN_SNAPSHOT_PROJECT_ERROR_INVALID_DATA_SOURCE_KEY:
      return "STEAMLEARN_SNAPSHOT_PROJECT_ERROR_INVALID_DATA_SOURCE_KEY";
    case ESteamLearnSnapshotProjectResult.STEAMLEARN_SNAPSHOT_PROJECT_ERROR_MISSING_CACHE_DURATION:
      return "STEAMLEARN_SNAPSHOT_PROJECT_ERROR_MISSING_CACHE_DURATION";
    case ESteamLearnSnapshotProjectResult.STEAMLEARN_SNAPSHOT_PROJECT_ERROR_NO_PUBLISHED_CONFIG:
      return "STEAMLEARN_SNAPSHOT_PROJECT_ERROR_NO_PUBLISHED_CONFIG";
    case ESteamLearnSnapshotProjectResult.STEAMLEARN_SNAPSHOT_PROJECT_ERROR_FORBIDDEN:
      return "STEAMLEARN_SNAPSHOT_PROJECT_ERROR_FORBIDDEN";
    case ESteamLearnSnapshotProjectResult.STEAMLEARN_SNAPSHOT_PROJECT_ERROR_INVALID_TIMESTAMP:
      return "STEAMLEARN_SNAPSHOT_PROJECT_ERROR_INVALID_TIMESTAMP";
    case ESteamLearnSnapshotProjectResult.STEAMLEARN_SNAPSHOT_PROJECT_ERROR_INTERNAL_DATA_SOURCE_ERROR:
      return "STEAMLEARN_SNAPSHOT_PROJECT_ERROR_INTERNAL_DATA_SOURCE_ERROR";
    case ESteamLearnSnapshotProjectResult.STEAMLEARN_SNAPSHOT_PROJECT_DISABLED:
      return "STEAMLEARN_SNAPSHOT_PROJECT_DISABLED";
    case ESteamLearnSnapshotProjectResult.STEAMLEARN_SNAPSHOT_PROJECT_ERROR_INVALID_PUBLISHED_VERSION:
      return "STEAMLEARN_SNAPSHOT_PROJECT_ERROR_INVALID_PUBLISHED_VERSION";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ESteamLearnSnapshotProjectResult");
  }
}

export enum ESteamLearnGetAccessTokensResult {
  STEAMLEARN_GET_ACCESS_TOKENS_ERROR = 0,
  STEAMLEARN_GET_ACCESS_TOKENS_SUCCESS = 1,
}

export function eSteamLearnGetAccessTokensResultFromJSON(object: any): ESteamLearnGetAccessTokensResult {
  switch (object) {
    case 0:
    case "STEAMLEARN_GET_ACCESS_TOKENS_ERROR":
      return ESteamLearnGetAccessTokensResult.STEAMLEARN_GET_ACCESS_TOKENS_ERROR;
    case 1:
    case "STEAMLEARN_GET_ACCESS_TOKENS_SUCCESS":
      return ESteamLearnGetAccessTokensResult.STEAMLEARN_GET_ACCESS_TOKENS_SUCCESS;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ESteamLearnGetAccessTokensResult");
  }
}

export function eSteamLearnGetAccessTokensResultToJSON(object: ESteamLearnGetAccessTokensResult): string {
  switch (object) {
    case ESteamLearnGetAccessTokensResult.STEAMLEARN_GET_ACCESS_TOKENS_ERROR:
      return "STEAMLEARN_GET_ACCESS_TOKENS_ERROR";
    case ESteamLearnGetAccessTokensResult.STEAMLEARN_GET_ACCESS_TOKENS_SUCCESS:
      return "STEAMLEARN_GET_ACCESS_TOKENS_SUCCESS";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ESteamLearnGetAccessTokensResult");
  }
}

export enum ESteamLearnInferenceResult {
  STEAMLEARN_INFERENCE_ERROR = 0,
  STEAMLEARN_INFERENCE_SUCCESS = 1,
  STEAMLEARN_INFERENCE_ERROR_INVALID_PROJECT_ID = 2,
  STEAMLEARN_INFERENCE_ERROR_MISSING_CACHED_SCHEMA_DATA = 3,
  STEAMLEARN_INFERENCE_ERROR_NO_PUBLISHED_CONFIG = 4,
  STEAMLEARN_INFERENCE_ERROR_FORBIDDEN = 5,
  STEAMLEARN_INFERENCE_ERROR_INVALID_TIMESTAMP = 6,
  STEAMLEARN_INFERENCE_ERROR_INVALID_PUBLISHED_VERSION = 7,
  STEAMLEARN_INFERENCE_ERROR_NO_FETCH_ID_FOUND = 8,
  STEAMLEARN_INFERENCE_ERROR_TOO_BUSY = 9,
}

export function eSteamLearnInferenceResultFromJSON(object: any): ESteamLearnInferenceResult {
  switch (object) {
    case 0:
    case "STEAMLEARN_INFERENCE_ERROR":
      return ESteamLearnInferenceResult.STEAMLEARN_INFERENCE_ERROR;
    case 1:
    case "STEAMLEARN_INFERENCE_SUCCESS":
      return ESteamLearnInferenceResult.STEAMLEARN_INFERENCE_SUCCESS;
    case 2:
    case "STEAMLEARN_INFERENCE_ERROR_INVALID_PROJECT_ID":
      return ESteamLearnInferenceResult.STEAMLEARN_INFERENCE_ERROR_INVALID_PROJECT_ID;
    case 3:
    case "STEAMLEARN_INFERENCE_ERROR_MISSING_CACHED_SCHEMA_DATA":
      return ESteamLearnInferenceResult.STEAMLEARN_INFERENCE_ERROR_MISSING_CACHED_SCHEMA_DATA;
    case 4:
    case "STEAMLEARN_INFERENCE_ERROR_NO_PUBLISHED_CONFIG":
      return ESteamLearnInferenceResult.STEAMLEARN_INFERENCE_ERROR_NO_PUBLISHED_CONFIG;
    case 5:
    case "STEAMLEARN_INFERENCE_ERROR_FORBIDDEN":
      return ESteamLearnInferenceResult.STEAMLEARN_INFERENCE_ERROR_FORBIDDEN;
    case 6:
    case "STEAMLEARN_INFERENCE_ERROR_INVALID_TIMESTAMP":
      return ESteamLearnInferenceResult.STEAMLEARN_INFERENCE_ERROR_INVALID_TIMESTAMP;
    case 7:
    case "STEAMLEARN_INFERENCE_ERROR_INVALID_PUBLISHED_VERSION":
      return ESteamLearnInferenceResult.STEAMLEARN_INFERENCE_ERROR_INVALID_PUBLISHED_VERSION;
    case 8:
    case "STEAMLEARN_INFERENCE_ERROR_NO_FETCH_ID_FOUND":
      return ESteamLearnInferenceResult.STEAMLEARN_INFERENCE_ERROR_NO_FETCH_ID_FOUND;
    case 9:
    case "STEAMLEARN_INFERENCE_ERROR_TOO_BUSY":
      return ESteamLearnInferenceResult.STEAMLEARN_INFERENCE_ERROR_TOO_BUSY;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ESteamLearnInferenceResult");
  }
}

export function eSteamLearnInferenceResultToJSON(object: ESteamLearnInferenceResult): string {
  switch (object) {
    case ESteamLearnInferenceResult.STEAMLEARN_INFERENCE_ERROR:
      return "STEAMLEARN_INFERENCE_ERROR";
    case ESteamLearnInferenceResult.STEAMLEARN_INFERENCE_SUCCESS:
      return "STEAMLEARN_INFERENCE_SUCCESS";
    case ESteamLearnInferenceResult.STEAMLEARN_INFERENCE_ERROR_INVALID_PROJECT_ID:
      return "STEAMLEARN_INFERENCE_ERROR_INVALID_PROJECT_ID";
    case ESteamLearnInferenceResult.STEAMLEARN_INFERENCE_ERROR_MISSING_CACHED_SCHEMA_DATA:
      return "STEAMLEARN_INFERENCE_ERROR_MISSING_CACHED_SCHEMA_DATA";
    case ESteamLearnInferenceResult.STEAMLEARN_INFERENCE_ERROR_NO_PUBLISHED_CONFIG:
      return "STEAMLEARN_INFERENCE_ERROR_NO_PUBLISHED_CONFIG";
    case ESteamLearnInferenceResult.STEAMLEARN_INFERENCE_ERROR_FORBIDDEN:
      return "STEAMLEARN_INFERENCE_ERROR_FORBIDDEN";
    case ESteamLearnInferenceResult.STEAMLEARN_INFERENCE_ERROR_INVALID_TIMESTAMP:
      return "STEAMLEARN_INFERENCE_ERROR_INVALID_TIMESTAMP";
    case ESteamLearnInferenceResult.STEAMLEARN_INFERENCE_ERROR_INVALID_PUBLISHED_VERSION:
      return "STEAMLEARN_INFERENCE_ERROR_INVALID_PUBLISHED_VERSION";
    case ESteamLearnInferenceResult.STEAMLEARN_INFERENCE_ERROR_NO_FETCH_ID_FOUND:
      return "STEAMLEARN_INFERENCE_ERROR_NO_FETCH_ID_FOUND";
    case ESteamLearnInferenceResult.STEAMLEARN_INFERENCE_ERROR_TOO_BUSY:
      return "STEAMLEARN_INFERENCE_ERROR_TOO_BUSY";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ESteamLearnInferenceResult");
  }
}

export enum ESteamLearnInferenceMetadataResult {
  STEAMLEARN_INFERENCE_METADATA_ERROR = 0,
  STEAMLEARN_INFERENCE_METADATA_SUCCESS = 1,
  STEAMLEARN_INFERENCE_METADATA_ERROR_INVALID_PROJECT_ID = 2,
  STEAMLEARN_INFERENCE_METADATA_ERROR_NO_PUBLISHED_CONFIG = 3,
  STEAMLEARN_INFERENCE_METADATA_ERROR_FORBIDDEN = 4,
  STEAMLEARN_INFERENCE_METADATA_ERROR_INVALID_TIMESTAMP = 5,
  STEAMLEARN_INFERENCE_METADATA_ERROR_INVALID_PUBLISHED_VERSION = 6,
  STEAMLEARN_INFERENCE_METADATA_ERROR_NO_FETCH_ID_FOUND = 7,
}

export function eSteamLearnInferenceMetadataResultFromJSON(object: any): ESteamLearnInferenceMetadataResult {
  switch (object) {
    case 0:
    case "STEAMLEARN_INFERENCE_METADATA_ERROR":
      return ESteamLearnInferenceMetadataResult.STEAMLEARN_INFERENCE_METADATA_ERROR;
    case 1:
    case "STEAMLEARN_INFERENCE_METADATA_SUCCESS":
      return ESteamLearnInferenceMetadataResult.STEAMLEARN_INFERENCE_METADATA_SUCCESS;
    case 2:
    case "STEAMLEARN_INFERENCE_METADATA_ERROR_INVALID_PROJECT_ID":
      return ESteamLearnInferenceMetadataResult.STEAMLEARN_INFERENCE_METADATA_ERROR_INVALID_PROJECT_ID;
    case 3:
    case "STEAMLEARN_INFERENCE_METADATA_ERROR_NO_PUBLISHED_CONFIG":
      return ESteamLearnInferenceMetadataResult.STEAMLEARN_INFERENCE_METADATA_ERROR_NO_PUBLISHED_CONFIG;
    case 4:
    case "STEAMLEARN_INFERENCE_METADATA_ERROR_FORBIDDEN":
      return ESteamLearnInferenceMetadataResult.STEAMLEARN_INFERENCE_METADATA_ERROR_FORBIDDEN;
    case 5:
    case "STEAMLEARN_INFERENCE_METADATA_ERROR_INVALID_TIMESTAMP":
      return ESteamLearnInferenceMetadataResult.STEAMLEARN_INFERENCE_METADATA_ERROR_INVALID_TIMESTAMP;
    case 6:
    case "STEAMLEARN_INFERENCE_METADATA_ERROR_INVALID_PUBLISHED_VERSION":
      return ESteamLearnInferenceMetadataResult.STEAMLEARN_INFERENCE_METADATA_ERROR_INVALID_PUBLISHED_VERSION;
    case 7:
    case "STEAMLEARN_INFERENCE_METADATA_ERROR_NO_FETCH_ID_FOUND":
      return ESteamLearnInferenceMetadataResult.STEAMLEARN_INFERENCE_METADATA_ERROR_NO_FETCH_ID_FOUND;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ESteamLearnInferenceMetadataResult");
  }
}

export function eSteamLearnInferenceMetadataResultToJSON(object: ESteamLearnInferenceMetadataResult): string {
  switch (object) {
    case ESteamLearnInferenceMetadataResult.STEAMLEARN_INFERENCE_METADATA_ERROR:
      return "STEAMLEARN_INFERENCE_METADATA_ERROR";
    case ESteamLearnInferenceMetadataResult.STEAMLEARN_INFERENCE_METADATA_SUCCESS:
      return "STEAMLEARN_INFERENCE_METADATA_SUCCESS";
    case ESteamLearnInferenceMetadataResult.STEAMLEARN_INFERENCE_METADATA_ERROR_INVALID_PROJECT_ID:
      return "STEAMLEARN_INFERENCE_METADATA_ERROR_INVALID_PROJECT_ID";
    case ESteamLearnInferenceMetadataResult.STEAMLEARN_INFERENCE_METADATA_ERROR_NO_PUBLISHED_CONFIG:
      return "STEAMLEARN_INFERENCE_METADATA_ERROR_NO_PUBLISHED_CONFIG";
    case ESteamLearnInferenceMetadataResult.STEAMLEARN_INFERENCE_METADATA_ERROR_FORBIDDEN:
      return "STEAMLEARN_INFERENCE_METADATA_ERROR_FORBIDDEN";
    case ESteamLearnInferenceMetadataResult.STEAMLEARN_INFERENCE_METADATA_ERROR_INVALID_TIMESTAMP:
      return "STEAMLEARN_INFERENCE_METADATA_ERROR_INVALID_TIMESTAMP";
    case ESteamLearnInferenceMetadataResult.STEAMLEARN_INFERENCE_METADATA_ERROR_INVALID_PUBLISHED_VERSION:
      return "STEAMLEARN_INFERENCE_METADATA_ERROR_INVALID_PUBLISHED_VERSION";
    case ESteamLearnInferenceMetadataResult.STEAMLEARN_INFERENCE_METADATA_ERROR_NO_FETCH_ID_FOUND:
      return "STEAMLEARN_INFERENCE_METADATA_ERROR_NO_FETCH_ID_FOUND";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ESteamLearnInferenceMetadataResult");
  }
}

export interface CMsgSteamLearnDataSourceDescObject {
  elements: CMsgSteamLearnDataSourceDescElement[];
}

export interface CMsgSteamLearnDataSourceDescElement {
  name?: string | undefined;
  dataType?: ESteamLearnDataType | undefined;
  object?: CMsgSteamLearnDataSourceDescObject | undefined;
  count?: number | undefined;
}

export interface CMsgSteamLearnDataSource {
  id?: number | undefined;
  name?: string | undefined;
  version?: number | undefined;
  sourceDescription?: string | undefined;
  structure?: CMsgSteamLearnDataSourceDescObject | undefined;
  structureCrc?: number | undefined;
  cacheDurationSeconds?: number | undefined;
}

export interface CMsgSteamLearnDataObject {
  elements: CMsgSteamLearnDataElement[];
}

export interface CMsgSteamLearnDataElement {
  name?: string | undefined;
  dataInt32s: number[];
  dataFloats: number[];
  dataBools: boolean[];
  dataStrings: string[];
  dataObjects: CMsgSteamLearnDataObject[];
}

export interface CMsgSteamLearnData {
  dataSourceId?: number | undefined;
  keys: string[];
  dataObject?: CMsgSteamLearnDataObject | undefined;
}

export interface CMsgSteamLearnDataList {
  data: CMsgSteamLearnData[];
}

export interface CMsgSteamLearnRegisterDataSourceRequest {
  accessToken?: string | undefined;
  dataSource?: CMsgSteamLearnDataSource | undefined;
}

export interface CMsgSteamLearnRegisterDataSourceResponse {
  result?: ESteammLearnRegisterDataSourceResult | undefined;
  dataSource?: CMsgSteamLearnDataSource | undefined;
}

export interface CMsgSteamLearnCacheDataRequest {
  accessToken?: string | undefined;
  data?: CMsgSteamLearnData | undefined;
}

export interface CMsgSteamLearnCacheDataResponse {
  cacheDataResult?: ESteamLearnCacheDataResult | undefined;
}

export interface CMsgSteamLearnSnapshotProjectRequest {
  accessToken?: string | undefined;
  projectId?: number | undefined;
  publishedVersion?: number | undefined;
  keys: string[];
  data: CMsgSteamLearnData[];
  pendingDataLimitSeconds?: number | undefined;
}

export interface CMsgSteamLearnSnapshotProjectResponse {
  snapshotResult?: ESteamLearnSnapshotProjectResult | undefined;
}

export interface CMsgSteamLearnBatchOperationRequest {
  cacheDataRequests: CMsgSteamLearnCacheDataRequest[];
  snapshotRequests: CMsgSteamLearnSnapshotProjectRequest[];
  inferenceRequests: CMsgSteamLearnInferenceRequest[];
}

export interface CMsgSteamLearnBatchOperationResponse {
  cacheDataResponses: CMsgSteamLearnCacheDataResponse[];
  snapshotResponses: CMsgSteamLearnSnapshotProjectResponse[];
  inferenceResponses: CMsgSteamLearnInferenceResponse[];
}

export interface CMsgSteamLearnAccessTokens {
  registerDataSourceAccessToken?: string | undefined;
  cacheDataAccessTokens: CMsgSteamLearnAccessTokens_CacheDataAccessToken[];
  snapshotProjectAccessTokens: CMsgSteamLearnAccessTokens_SnapshotProjectAccessToken[];
  inferenceAccessTokens: CMsgSteamLearnAccessTokens_InferenceAccessToken[];
}

export interface CMsgSteamLearnAccessTokens_CacheDataAccessToken {
  dataSourceId?: number | undefined;
  accessToken?: string | undefined;
}

export interface CMsgSteamLearnAccessTokens_SnapshotProjectAccessToken {
  projectId?: number | undefined;
  accessToken?: string | undefined;
}

export interface CMsgSteamLearnAccessTokens_InferenceAccessToken {
  projectId?: number | undefined;
  accessToken?: string | undefined;
}

export interface CMsgSteamLearnGetAccessTokensRequest {
  appid?: number | undefined;
}

export interface CMsgSteamLearnGetAccessTokensResponse {
  result?: ESteamLearnGetAccessTokensResult | undefined;
  accessTokens?: CMsgSteamLearnAccessTokens | undefined;
}

export interface CMsgSteamLearnInferenceRequest {
  accessToken?: string | undefined;
  projectId?: number | undefined;
  publishedVersion?: number | undefined;
  overrideTrainId?: number | undefined;
  data?: CMsgSteamLearnDataList | undefined;
  additionalData: number[];
}

export interface CMsgSteamLearnInferenceMetadataRequest {
  accessToken?: string | undefined;
  projectId?: number | undefined;
  publishedVersion?: number | undefined;
  overrideTrainId?: number | undefined;
}

export interface CMsgSteamLearnInferenceMetadataBackendRequest {
  projectId?: number | undefined;
  fetchId?: number | undefined;
}

export interface CMsgSteamLearnInferenceMetadataResponse {
  inferenceMetadataResult?: ESteamLearnInferenceMetadataResult | undefined;
  rowRange?: CMsgSteamLearnInferenceMetadataResponse_RowRange | undefined;
  ranges: CMsgSteamLearnInferenceMetadataResponse_Range[];
  stdDevs: CMsgSteamLearnInferenceMetadataResponse_StdDev[];
  compactTables: CMsgSteamLearnInferenceMetadataResponse_CompactTable[];
  kmeans: CMsgSteamLearnInferenceMetadataResponse_KMeans[];
  snapshotHistogram?: CMsgSteamLearnInferenceMetadataResponse_SnapshotHistogram | undefined;
}

export interface CMsgSteamLearnInferenceMetadataResponse_RowRange {
  minRow?: string | undefined;
  maxRow?: string | undefined;
}

export interface CMsgSteamLearnInferenceMetadataResponse_Range {
  dataElementPath?: string | undefined;
  minValue?: number | undefined;
  maxValue?: number | undefined;
}

export interface CMsgSteamLearnInferenceMetadataResponse_StdDev {
  dataElementPath?: string | undefined;
  mean?: number | undefined;
  stdDev?: number | undefined;
}

export interface CMsgSteamLearnInferenceMetadataResponse_CompactTable {
  name?: string | undefined;
  mapValues: CMsgSteamLearnInferenceMetadataResponse_CompactTable_MapValuesEntry[];
  mapMappings: CMsgSteamLearnInferenceMetadataResponse_CompactTable_MapMappingsEntry[];
}

export interface CMsgSteamLearnInferenceMetadataResponse_CompactTable_Entry {
  value?: number | undefined;
  mapping?: number | undefined;
  count?: string | undefined;
}

export interface CMsgSteamLearnInferenceMetadataResponse_CompactTable_MapValuesEntry {
  key?: number | undefined;
  value?: CMsgSteamLearnInferenceMetadataResponse_CompactTable_Entry | undefined;
}

export interface CMsgSteamLearnInferenceMetadataResponse_CompactTable_MapMappingsEntry {
  key?: number | undefined;
  value?: CMsgSteamLearnInferenceMetadataResponse_CompactTable_Entry | undefined;
}

export interface CMsgSteamLearnInferenceMetadataResponse_KMeans {
  name?: string | undefined;
  clusters: CMsgSteamLearnInferenceMetadataResponse_KMeans_Cluster[];
}

export interface CMsgSteamLearnInferenceMetadataResponse_KMeans_Cluster {
  x?: number | undefined;
  y?: number | undefined;
  radius?: number | undefined;
  radius75pct?: number | undefined;
  radius50pct?: number | undefined;
  radius25pct?: number | undefined;
}

export interface CMsgSteamLearnInferenceMetadataResponse_SnapshotHistogram {
  minValue?: number | undefined;
  maxValue?: number | undefined;
  numBuckets?: number | undefined;
  bucketCounts: number[];
}

export interface CMsgSteamLearnInferenceBackendResponse {
  outputs: CMsgSteamLearnInferenceBackendResponse_Output[];
}

export interface CMsgSteamLearnInferenceBackendResponse_RegressionOutput {
  value?: number | undefined;
}

export interface CMsgSteamLearnInferenceBackendResponse_BinaryCrossEntropyOutput {
  value?: number | undefined;
}

export interface CMsgSteamLearnInferenceBackendResponse_MutliBinaryCrossEntropyOutput {
  weight: number[];
  value: number[];
}

export interface CMsgSteamLearnInferenceBackendResponse_CategoricalCrossEntropyOutput {
  weight: number[];
  value: number[];
}

export interface CMsgSteamLearnInferenceBackendResponse_Output {
  binaryCrossentropy?: CMsgSteamLearnInferenceBackendResponse_BinaryCrossEntropyOutput | undefined;
  categoricalCrossentropy?: CMsgSteamLearnInferenceBackendResponse_CategoricalCrossEntropyOutput | undefined;
  multiBinaryCrossentropy?: CMsgSteamLearnInferenceBackendResponse_MutliBinaryCrossEntropyOutput | undefined;
  regression?: CMsgSteamLearnInferenceBackendResponse_RegressionOutput | undefined;
}

export interface CMsgSteamLearnInferenceResponse {
  inferenceResult?: ESteamLearnInferenceResult | undefined;
  backendResponse?: CMsgSteamLearnInferenceBackendResponse | undefined;
  keys: string[];
}

function createBaseCMsgSteamLearnDataSourceDescObject(): CMsgSteamLearnDataSourceDescObject {
  return { elements: [] };
}

export const CMsgSteamLearnDataSourceDescObject = {
  encode(message: CMsgSteamLearnDataSourceDescObject, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.elements) {
      CMsgSteamLearnDataSourceDescElement.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSteamLearnDataSourceDescObject {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSteamLearnDataSourceDescObject();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.elements.push(CMsgSteamLearnDataSourceDescElement.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSteamLearnDataSourceDescObject {
    return {
      elements: globalThis.Array.isArray(object?.elements)
        ? object.elements.map((e: any) => CMsgSteamLearnDataSourceDescElement.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgSteamLearnDataSourceDescObject): unknown {
    const obj: any = {};
    if (message.elements?.length) {
      obj.elements = message.elements.map((e) => CMsgSteamLearnDataSourceDescElement.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSteamLearnDataSourceDescObject>): CMsgSteamLearnDataSourceDescObject {
    return CMsgSteamLearnDataSourceDescObject.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSteamLearnDataSourceDescObject>): CMsgSteamLearnDataSourceDescObject {
    const message = createBaseCMsgSteamLearnDataSourceDescObject();
    message.elements = object.elements?.map((e) => CMsgSteamLearnDataSourceDescElement.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgSteamLearnDataSourceDescElement(): CMsgSteamLearnDataSourceDescElement {
  return { name: "", dataType: 0, object: undefined, count: 0 };
}

export const CMsgSteamLearnDataSourceDescElement = {
  encode(message: CMsgSteamLearnDataSourceDescElement, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.dataType !== undefined && message.dataType !== 0) {
      writer.uint32(16).int32(message.dataType);
    }
    if (message.object !== undefined) {
      CMsgSteamLearnDataSourceDescObject.encode(message.object, writer.uint32(26).fork()).ldelim();
    }
    if (message.count !== undefined && message.count !== 0) {
      writer.uint32(32).uint32(message.count);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSteamLearnDataSourceDescElement {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSteamLearnDataSourceDescElement();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.dataType = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.object = CMsgSteamLearnDataSourceDescObject.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.count = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSteamLearnDataSourceDescElement {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      dataType: isSet(object.dataType) ? eSteamLearnDataTypeFromJSON(object.dataType) : 0,
      object: isSet(object.object) ? CMsgSteamLearnDataSourceDescObject.fromJSON(object.object) : undefined,
      count: isSet(object.count) ? globalThis.Number(object.count) : 0,
    };
  },

  toJSON(message: CMsgSteamLearnDataSourceDescElement): unknown {
    const obj: any = {};
    if (message.name !== undefined && message.name !== "") {
      obj.name = message.name;
    }
    if (message.dataType !== undefined && message.dataType !== 0) {
      obj.dataType = eSteamLearnDataTypeToJSON(message.dataType);
    }
    if (message.object !== undefined) {
      obj.object = CMsgSteamLearnDataSourceDescObject.toJSON(message.object);
    }
    if (message.count !== undefined && message.count !== 0) {
      obj.count = Math.round(message.count);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSteamLearnDataSourceDescElement>): CMsgSteamLearnDataSourceDescElement {
    return CMsgSteamLearnDataSourceDescElement.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSteamLearnDataSourceDescElement>): CMsgSteamLearnDataSourceDescElement {
    const message = createBaseCMsgSteamLearnDataSourceDescElement();
    message.name = object.name ?? "";
    message.dataType = object.dataType ?? 0;
    message.object =
      object.object !== undefined && object.object !== null
        ? CMsgSteamLearnDataSourceDescObject.fromPartial(object.object)
        : undefined;
    message.count = object.count ?? 0;
    return message;
  },
};

function createBaseCMsgSteamLearnDataSource(): CMsgSteamLearnDataSource {
  return {
    id: 0,
    name: "",
    version: 0,
    sourceDescription: "",
    structure: undefined,
    structureCrc: 0,
    cacheDurationSeconds: 0,
  };
}

export const CMsgSteamLearnDataSource = {
  encode(message: CMsgSteamLearnDataSource, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== undefined && message.id !== 0) {
      writer.uint32(8).uint32(message.id);
    }
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.version !== undefined && message.version !== 0) {
      writer.uint32(24).uint32(message.version);
    }
    if (message.sourceDescription !== undefined && message.sourceDescription !== "") {
      writer.uint32(34).string(message.sourceDescription);
    }
    if (message.structure !== undefined) {
      CMsgSteamLearnDataSourceDescObject.encode(message.structure, writer.uint32(42).fork()).ldelim();
    }
    if (message.structureCrc !== undefined && message.structureCrc !== 0) {
      writer.uint32(48).uint32(message.structureCrc);
    }
    if (message.cacheDurationSeconds !== undefined && message.cacheDurationSeconds !== 0) {
      writer.uint32(56).uint32(message.cacheDurationSeconds);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSteamLearnDataSource {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSteamLearnDataSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.version = reader.uint32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.sourceDescription = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.structure = CMsgSteamLearnDataSourceDescObject.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.structureCrc = reader.uint32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.cacheDurationSeconds = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSteamLearnDataSource {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      version: isSet(object.version) ? globalThis.Number(object.version) : 0,
      sourceDescription: isSet(object.sourceDescription) ? globalThis.String(object.sourceDescription) : "",
      structure: isSet(object.structure) ? CMsgSteamLearnDataSourceDescObject.fromJSON(object.structure) : undefined,
      structureCrc: isSet(object.structureCrc) ? globalThis.Number(object.structureCrc) : 0,
      cacheDurationSeconds: isSet(object.cacheDurationSeconds) ? globalThis.Number(object.cacheDurationSeconds) : 0,
    };
  },

  toJSON(message: CMsgSteamLearnDataSource): unknown {
    const obj: any = {};
    if (message.id !== undefined && message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.name !== undefined && message.name !== "") {
      obj.name = message.name;
    }
    if (message.version !== undefined && message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    if (message.sourceDescription !== undefined && message.sourceDescription !== "") {
      obj.sourceDescription = message.sourceDescription;
    }
    if (message.structure !== undefined) {
      obj.structure = CMsgSteamLearnDataSourceDescObject.toJSON(message.structure);
    }
    if (message.structureCrc !== undefined && message.structureCrc !== 0) {
      obj.structureCrc = Math.round(message.structureCrc);
    }
    if (message.cacheDurationSeconds !== undefined && message.cacheDurationSeconds !== 0) {
      obj.cacheDurationSeconds = Math.round(message.cacheDurationSeconds);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSteamLearnDataSource>): CMsgSteamLearnDataSource {
    return CMsgSteamLearnDataSource.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSteamLearnDataSource>): CMsgSteamLearnDataSource {
    const message = createBaseCMsgSteamLearnDataSource();
    message.id = object.id ?? 0;
    message.name = object.name ?? "";
    message.version = object.version ?? 0;
    message.sourceDescription = object.sourceDescription ?? "";
    message.structure =
      object.structure !== undefined && object.structure !== null
        ? CMsgSteamLearnDataSourceDescObject.fromPartial(object.structure)
        : undefined;
    message.structureCrc = object.structureCrc ?? 0;
    message.cacheDurationSeconds = object.cacheDurationSeconds ?? 0;
    return message;
  },
};

function createBaseCMsgSteamLearnDataObject(): CMsgSteamLearnDataObject {
  return { elements: [] };
}

export const CMsgSteamLearnDataObject = {
  encode(message: CMsgSteamLearnDataObject, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.elements) {
      CMsgSteamLearnDataElement.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSteamLearnDataObject {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSteamLearnDataObject();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.elements.push(CMsgSteamLearnDataElement.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSteamLearnDataObject {
    return {
      elements: globalThis.Array.isArray(object?.elements)
        ? object.elements.map((e: any) => CMsgSteamLearnDataElement.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgSteamLearnDataObject): unknown {
    const obj: any = {};
    if (message.elements?.length) {
      obj.elements = message.elements.map((e) => CMsgSteamLearnDataElement.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSteamLearnDataObject>): CMsgSteamLearnDataObject {
    return CMsgSteamLearnDataObject.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSteamLearnDataObject>): CMsgSteamLearnDataObject {
    const message = createBaseCMsgSteamLearnDataObject();
    message.elements = object.elements?.map((e) => CMsgSteamLearnDataElement.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgSteamLearnDataElement(): CMsgSteamLearnDataElement {
  return { name: "", dataInt32s: [], dataFloats: [], dataBools: [], dataStrings: [], dataObjects: [] };
}

export const CMsgSteamLearnDataElement = {
  encode(message: CMsgSteamLearnDataElement, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    writer.uint32(162).fork();
    for (const v of message.dataInt32s) {
      writer.int32(v);
    }
    writer.ldelim();
    writer.uint32(170).fork();
    for (const v of message.dataFloats) {
      writer.float(v);
    }
    writer.ldelim();
    writer.uint32(178).fork();
    for (const v of message.dataBools) {
      writer.bool(v);
    }
    writer.ldelim();
    for (const v of message.dataStrings) {
      writer.uint32(186).string(v!);
    }
    for (const v of message.dataObjects) {
      CMsgSteamLearnDataObject.encode(v!, writer.uint32(194).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSteamLearnDataElement {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSteamLearnDataElement();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 20:
          if (tag === 160) {
            message.dataInt32s.push(reader.int32());

            continue;
          }

          if (tag === 162) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.dataInt32s.push(reader.int32());
            }

            continue;
          }

          break;
        case 21:
          if (tag === 173) {
            message.dataFloats.push(reader.float());

            continue;
          }

          if (tag === 170) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.dataFloats.push(reader.float());
            }

            continue;
          }

          break;
        case 22:
          if (tag === 176) {
            message.dataBools.push(reader.bool());

            continue;
          }

          if (tag === 178) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.dataBools.push(reader.bool());
            }

            continue;
          }

          break;
        case 23:
          if (tag !== 186) {
            break;
          }

          message.dataStrings.push(reader.string());
          continue;
        case 24:
          if (tag !== 194) {
            break;
          }

          message.dataObjects.push(CMsgSteamLearnDataObject.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSteamLearnDataElement {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      dataInt32s: globalThis.Array.isArray(object?.dataInt32s)
        ? object.dataInt32s.map((e: any) => globalThis.Number(e))
        : [],
      dataFloats: globalThis.Array.isArray(object?.dataFloats)
        ? object.dataFloats.map((e: any) => globalThis.Number(e))
        : [],
      dataBools: globalThis.Array.isArray(object?.dataBools)
        ? object.dataBools.map((e: any) => globalThis.Boolean(e))
        : [],
      dataStrings: globalThis.Array.isArray(object?.dataStrings)
        ? object.dataStrings.map((e: any) => globalThis.String(e))
        : [],
      dataObjects: globalThis.Array.isArray(object?.dataObjects)
        ? object.dataObjects.map((e: any) => CMsgSteamLearnDataObject.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgSteamLearnDataElement): unknown {
    const obj: any = {};
    if (message.name !== undefined && message.name !== "") {
      obj.name = message.name;
    }
    if (message.dataInt32s?.length) {
      obj.dataInt32s = message.dataInt32s.map((e) => Math.round(e));
    }
    if (message.dataFloats?.length) {
      obj.dataFloats = message.dataFloats;
    }
    if (message.dataBools?.length) {
      obj.dataBools = message.dataBools;
    }
    if (message.dataStrings?.length) {
      obj.dataStrings = message.dataStrings;
    }
    if (message.dataObjects?.length) {
      obj.dataObjects = message.dataObjects.map((e) => CMsgSteamLearnDataObject.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSteamLearnDataElement>): CMsgSteamLearnDataElement {
    return CMsgSteamLearnDataElement.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSteamLearnDataElement>): CMsgSteamLearnDataElement {
    const message = createBaseCMsgSteamLearnDataElement();
    message.name = object.name ?? "";
    message.dataInt32s = object.dataInt32s?.map((e) => e) || [];
    message.dataFloats = object.dataFloats?.map((e) => e) || [];
    message.dataBools = object.dataBools?.map((e) => e) || [];
    message.dataStrings = object.dataStrings?.map((e) => e) || [];
    message.dataObjects = object.dataObjects?.map((e) => CMsgSteamLearnDataObject.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgSteamLearnData(): CMsgSteamLearnData {
  return { dataSourceId: 0, keys: [], dataObject: undefined };
}

export const CMsgSteamLearnData = {
  encode(message: CMsgSteamLearnData, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.dataSourceId !== undefined && message.dataSourceId !== 0) {
      writer.uint32(8).uint32(message.dataSourceId);
    }
    writer.uint32(18).fork();
    for (const v of message.keys) {
      writer.uint64(v);
    }
    writer.ldelim();
    if (message.dataObject !== undefined) {
      CMsgSteamLearnDataObject.encode(message.dataObject, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSteamLearnData {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSteamLearnData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.dataSourceId = reader.uint32();
          continue;
        case 2:
          if (tag === 16) {
            message.keys.push(longToString(reader.uint64() as Long));

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.keys.push(longToString(reader.uint64() as Long));
            }

            continue;
          }

          break;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.dataObject = CMsgSteamLearnDataObject.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSteamLearnData {
    return {
      dataSourceId: isSet(object.dataSourceId) ? globalThis.Number(object.dataSourceId) : 0,
      keys: globalThis.Array.isArray(object?.keys) ? object.keys.map((e: any) => globalThis.String(e)) : [],
      dataObject: isSet(object.dataObject) ? CMsgSteamLearnDataObject.fromJSON(object.dataObject) : undefined,
    };
  },

  toJSON(message: CMsgSteamLearnData): unknown {
    const obj: any = {};
    if (message.dataSourceId !== undefined && message.dataSourceId !== 0) {
      obj.dataSourceId = Math.round(message.dataSourceId);
    }
    if (message.keys?.length) {
      obj.keys = message.keys;
    }
    if (message.dataObject !== undefined) {
      obj.dataObject = CMsgSteamLearnDataObject.toJSON(message.dataObject);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSteamLearnData>): CMsgSteamLearnData {
    return CMsgSteamLearnData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSteamLearnData>): CMsgSteamLearnData {
    const message = createBaseCMsgSteamLearnData();
    message.dataSourceId = object.dataSourceId ?? 0;
    message.keys = object.keys?.map((e) => e) || [];
    message.dataObject =
      object.dataObject !== undefined && object.dataObject !== null
        ? CMsgSteamLearnDataObject.fromPartial(object.dataObject)
        : undefined;
    return message;
  },
};

function createBaseCMsgSteamLearnDataList(): CMsgSteamLearnDataList {
  return { data: [] };
}

export const CMsgSteamLearnDataList = {
  encode(message: CMsgSteamLearnDataList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.data) {
      CMsgSteamLearnData.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSteamLearnDataList {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSteamLearnDataList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.data.push(CMsgSteamLearnData.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSteamLearnDataList {
    return {
      data: globalThis.Array.isArray(object?.data) ? object.data.map((e: any) => CMsgSteamLearnData.fromJSON(e)) : [],
    };
  },

  toJSON(message: CMsgSteamLearnDataList): unknown {
    const obj: any = {};
    if (message.data?.length) {
      obj.data = message.data.map((e) => CMsgSteamLearnData.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSteamLearnDataList>): CMsgSteamLearnDataList {
    return CMsgSteamLearnDataList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSteamLearnDataList>): CMsgSteamLearnDataList {
    const message = createBaseCMsgSteamLearnDataList();
    message.data = object.data?.map((e) => CMsgSteamLearnData.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgSteamLearnRegisterDataSourceRequest(): CMsgSteamLearnRegisterDataSourceRequest {
  return { accessToken: "", dataSource: undefined };
}

export const CMsgSteamLearnRegisterDataSourceRequest = {
  encode(message: CMsgSteamLearnRegisterDataSourceRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.accessToken !== undefined && message.accessToken !== "") {
      writer.uint32(10).string(message.accessToken);
    }
    if (message.dataSource !== undefined) {
      CMsgSteamLearnDataSource.encode(message.dataSource, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSteamLearnRegisterDataSourceRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSteamLearnRegisterDataSourceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.accessToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.dataSource = CMsgSteamLearnDataSource.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSteamLearnRegisterDataSourceRequest {
    return {
      accessToken: isSet(object.accessToken) ? globalThis.String(object.accessToken) : "",
      dataSource: isSet(object.dataSource) ? CMsgSteamLearnDataSource.fromJSON(object.dataSource) : undefined,
    };
  },

  toJSON(message: CMsgSteamLearnRegisterDataSourceRequest): unknown {
    const obj: any = {};
    if (message.accessToken !== undefined && message.accessToken !== "") {
      obj.accessToken = message.accessToken;
    }
    if (message.dataSource !== undefined) {
      obj.dataSource = CMsgSteamLearnDataSource.toJSON(message.dataSource);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSteamLearnRegisterDataSourceRequest>): CMsgSteamLearnRegisterDataSourceRequest {
    return CMsgSteamLearnRegisterDataSourceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSteamLearnRegisterDataSourceRequest>): CMsgSteamLearnRegisterDataSourceRequest {
    const message = createBaseCMsgSteamLearnRegisterDataSourceRequest();
    message.accessToken = object.accessToken ?? "";
    message.dataSource =
      object.dataSource !== undefined && object.dataSource !== null
        ? CMsgSteamLearnDataSource.fromPartial(object.dataSource)
        : undefined;
    return message;
  },
};

function createBaseCMsgSteamLearnRegisterDataSourceResponse(): CMsgSteamLearnRegisterDataSourceResponse {
  return { result: 0, dataSource: undefined };
}

export const CMsgSteamLearnRegisterDataSourceResponse = {
  encode(message: CMsgSteamLearnRegisterDataSourceResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result !== undefined && message.result !== 0) {
      writer.uint32(8).int32(message.result);
    }
    if (message.dataSource !== undefined) {
      CMsgSteamLearnDataSource.encode(message.dataSource, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSteamLearnRegisterDataSourceResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSteamLearnRegisterDataSourceResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.result = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.dataSource = CMsgSteamLearnDataSource.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSteamLearnRegisterDataSourceResponse {
    return {
      result: isSet(object.result) ? eSteammLearnRegisterDataSourceResultFromJSON(object.result) : 0,
      dataSource: isSet(object.dataSource) ? CMsgSteamLearnDataSource.fromJSON(object.dataSource) : undefined,
    };
  },

  toJSON(message: CMsgSteamLearnRegisterDataSourceResponse): unknown {
    const obj: any = {};
    if (message.result !== undefined && message.result !== 0) {
      obj.result = eSteammLearnRegisterDataSourceResultToJSON(message.result);
    }
    if (message.dataSource !== undefined) {
      obj.dataSource = CMsgSteamLearnDataSource.toJSON(message.dataSource);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSteamLearnRegisterDataSourceResponse>): CMsgSteamLearnRegisterDataSourceResponse {
    return CMsgSteamLearnRegisterDataSourceResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSteamLearnRegisterDataSourceResponse>): CMsgSteamLearnRegisterDataSourceResponse {
    const message = createBaseCMsgSteamLearnRegisterDataSourceResponse();
    message.result = object.result ?? 0;
    message.dataSource =
      object.dataSource !== undefined && object.dataSource !== null
        ? CMsgSteamLearnDataSource.fromPartial(object.dataSource)
        : undefined;
    return message;
  },
};

function createBaseCMsgSteamLearnCacheDataRequest(): CMsgSteamLearnCacheDataRequest {
  return { accessToken: "", data: undefined };
}

export const CMsgSteamLearnCacheDataRequest = {
  encode(message: CMsgSteamLearnCacheDataRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.accessToken !== undefined && message.accessToken !== "") {
      writer.uint32(10).string(message.accessToken);
    }
    if (message.data !== undefined) {
      CMsgSteamLearnData.encode(message.data, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSteamLearnCacheDataRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSteamLearnCacheDataRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.accessToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.data = CMsgSteamLearnData.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSteamLearnCacheDataRequest {
    return {
      accessToken: isSet(object.accessToken) ? globalThis.String(object.accessToken) : "",
      data: isSet(object.data) ? CMsgSteamLearnData.fromJSON(object.data) : undefined,
    };
  },

  toJSON(message: CMsgSteamLearnCacheDataRequest): unknown {
    const obj: any = {};
    if (message.accessToken !== undefined && message.accessToken !== "") {
      obj.accessToken = message.accessToken;
    }
    if (message.data !== undefined) {
      obj.data = CMsgSteamLearnData.toJSON(message.data);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSteamLearnCacheDataRequest>): CMsgSteamLearnCacheDataRequest {
    return CMsgSteamLearnCacheDataRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSteamLearnCacheDataRequest>): CMsgSteamLearnCacheDataRequest {
    const message = createBaseCMsgSteamLearnCacheDataRequest();
    message.accessToken = object.accessToken ?? "";
    message.data =
      object.data !== undefined && object.data !== null ? CMsgSteamLearnData.fromPartial(object.data) : undefined;
    return message;
  },
};

function createBaseCMsgSteamLearnCacheDataResponse(): CMsgSteamLearnCacheDataResponse {
  return { cacheDataResult: 0 };
}

export const CMsgSteamLearnCacheDataResponse = {
  encode(message: CMsgSteamLearnCacheDataResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.cacheDataResult !== undefined && message.cacheDataResult !== 0) {
      writer.uint32(8).int32(message.cacheDataResult);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSteamLearnCacheDataResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSteamLearnCacheDataResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.cacheDataResult = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSteamLearnCacheDataResponse {
    return {
      cacheDataResult: isSet(object.cacheDataResult) ? eSteamLearnCacheDataResultFromJSON(object.cacheDataResult) : 0,
    };
  },

  toJSON(message: CMsgSteamLearnCacheDataResponse): unknown {
    const obj: any = {};
    if (message.cacheDataResult !== undefined && message.cacheDataResult !== 0) {
      obj.cacheDataResult = eSteamLearnCacheDataResultToJSON(message.cacheDataResult);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSteamLearnCacheDataResponse>): CMsgSteamLearnCacheDataResponse {
    return CMsgSteamLearnCacheDataResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSteamLearnCacheDataResponse>): CMsgSteamLearnCacheDataResponse {
    const message = createBaseCMsgSteamLearnCacheDataResponse();
    message.cacheDataResult = object.cacheDataResult ?? 0;
    return message;
  },
};

function createBaseCMsgSteamLearnSnapshotProjectRequest(): CMsgSteamLearnSnapshotProjectRequest {
  return { accessToken: "", projectId: 0, publishedVersion: 0, keys: [], data: [], pendingDataLimitSeconds: 0 };
}

export const CMsgSteamLearnSnapshotProjectRequest = {
  encode(message: CMsgSteamLearnSnapshotProjectRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.accessToken !== undefined && message.accessToken !== "") {
      writer.uint32(10).string(message.accessToken);
    }
    if (message.projectId !== undefined && message.projectId !== 0) {
      writer.uint32(24).uint32(message.projectId);
    }
    if (message.publishedVersion !== undefined && message.publishedVersion !== 0) {
      writer.uint32(56).uint32(message.publishedVersion);
    }
    writer.uint32(34).fork();
    for (const v of message.keys) {
      writer.uint64(v);
    }
    writer.ldelim();
    for (const v of message.data) {
      CMsgSteamLearnData.encode(v!, writer.uint32(42).fork()).ldelim();
    }
    if (message.pendingDataLimitSeconds !== undefined && message.pendingDataLimitSeconds !== 0) {
      writer.uint32(48).uint32(message.pendingDataLimitSeconds);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSteamLearnSnapshotProjectRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSteamLearnSnapshotProjectRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.accessToken = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.projectId = reader.uint32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.publishedVersion = reader.uint32();
          continue;
        case 4:
          if (tag === 32) {
            message.keys.push(longToString(reader.uint64() as Long));

            continue;
          }

          if (tag === 34) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.keys.push(longToString(reader.uint64() as Long));
            }

            continue;
          }

          break;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.data.push(CMsgSteamLearnData.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.pendingDataLimitSeconds = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSteamLearnSnapshotProjectRequest {
    return {
      accessToken: isSet(object.accessToken) ? globalThis.String(object.accessToken) : "",
      projectId: isSet(object.projectId) ? globalThis.Number(object.projectId) : 0,
      publishedVersion: isSet(object.publishedVersion) ? globalThis.Number(object.publishedVersion) : 0,
      keys: globalThis.Array.isArray(object?.keys) ? object.keys.map((e: any) => globalThis.String(e)) : [],
      data: globalThis.Array.isArray(object?.data) ? object.data.map((e: any) => CMsgSteamLearnData.fromJSON(e)) : [],
      pendingDataLimitSeconds: isSet(object.pendingDataLimitSeconds)
        ? globalThis.Number(object.pendingDataLimitSeconds)
        : 0,
    };
  },

  toJSON(message: CMsgSteamLearnSnapshotProjectRequest): unknown {
    const obj: any = {};
    if (message.accessToken !== undefined && message.accessToken !== "") {
      obj.accessToken = message.accessToken;
    }
    if (message.projectId !== undefined && message.projectId !== 0) {
      obj.projectId = Math.round(message.projectId);
    }
    if (message.publishedVersion !== undefined && message.publishedVersion !== 0) {
      obj.publishedVersion = Math.round(message.publishedVersion);
    }
    if (message.keys?.length) {
      obj.keys = message.keys;
    }
    if (message.data?.length) {
      obj.data = message.data.map((e) => CMsgSteamLearnData.toJSON(e));
    }
    if (message.pendingDataLimitSeconds !== undefined && message.pendingDataLimitSeconds !== 0) {
      obj.pendingDataLimitSeconds = Math.round(message.pendingDataLimitSeconds);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSteamLearnSnapshotProjectRequest>): CMsgSteamLearnSnapshotProjectRequest {
    return CMsgSteamLearnSnapshotProjectRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSteamLearnSnapshotProjectRequest>): CMsgSteamLearnSnapshotProjectRequest {
    const message = createBaseCMsgSteamLearnSnapshotProjectRequest();
    message.accessToken = object.accessToken ?? "";
    message.projectId = object.projectId ?? 0;
    message.publishedVersion = object.publishedVersion ?? 0;
    message.keys = object.keys?.map((e) => e) || [];
    message.data = object.data?.map((e) => CMsgSteamLearnData.fromPartial(e)) || [];
    message.pendingDataLimitSeconds = object.pendingDataLimitSeconds ?? 0;
    return message;
  },
};

function createBaseCMsgSteamLearnSnapshotProjectResponse(): CMsgSteamLearnSnapshotProjectResponse {
  return { snapshotResult: 0 };
}

export const CMsgSteamLearnSnapshotProjectResponse = {
  encode(message: CMsgSteamLearnSnapshotProjectResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.snapshotResult !== undefined && message.snapshotResult !== 0) {
      writer.uint32(8).int32(message.snapshotResult);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSteamLearnSnapshotProjectResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSteamLearnSnapshotProjectResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.snapshotResult = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSteamLearnSnapshotProjectResponse {
    return {
      snapshotResult: isSet(object.snapshotResult)
        ? eSteamLearnSnapshotProjectResultFromJSON(object.snapshotResult)
        : 0,
    };
  },

  toJSON(message: CMsgSteamLearnSnapshotProjectResponse): unknown {
    const obj: any = {};
    if (message.snapshotResult !== undefined && message.snapshotResult !== 0) {
      obj.snapshotResult = eSteamLearnSnapshotProjectResultToJSON(message.snapshotResult);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSteamLearnSnapshotProjectResponse>): CMsgSteamLearnSnapshotProjectResponse {
    return CMsgSteamLearnSnapshotProjectResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSteamLearnSnapshotProjectResponse>): CMsgSteamLearnSnapshotProjectResponse {
    const message = createBaseCMsgSteamLearnSnapshotProjectResponse();
    message.snapshotResult = object.snapshotResult ?? 0;
    return message;
  },
};

function createBaseCMsgSteamLearnBatchOperationRequest(): CMsgSteamLearnBatchOperationRequest {
  return { cacheDataRequests: [], snapshotRequests: [], inferenceRequests: [] };
}

export const CMsgSteamLearnBatchOperationRequest = {
  encode(message: CMsgSteamLearnBatchOperationRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.cacheDataRequests) {
      CMsgSteamLearnCacheDataRequest.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.snapshotRequests) {
      CMsgSteamLearnSnapshotProjectRequest.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.inferenceRequests) {
      CMsgSteamLearnInferenceRequest.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSteamLearnBatchOperationRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSteamLearnBatchOperationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.cacheDataRequests.push(CMsgSteamLearnCacheDataRequest.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.snapshotRequests.push(CMsgSteamLearnSnapshotProjectRequest.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.inferenceRequests.push(CMsgSteamLearnInferenceRequest.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSteamLearnBatchOperationRequest {
    return {
      cacheDataRequests: globalThis.Array.isArray(object?.cacheDataRequests)
        ? object.cacheDataRequests.map((e: any) => CMsgSteamLearnCacheDataRequest.fromJSON(e))
        : [],
      snapshotRequests: globalThis.Array.isArray(object?.snapshotRequests)
        ? object.snapshotRequests.map((e: any) => CMsgSteamLearnSnapshotProjectRequest.fromJSON(e))
        : [],
      inferenceRequests: globalThis.Array.isArray(object?.inferenceRequests)
        ? object.inferenceRequests.map((e: any) => CMsgSteamLearnInferenceRequest.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgSteamLearnBatchOperationRequest): unknown {
    const obj: any = {};
    if (message.cacheDataRequests?.length) {
      obj.cacheDataRequests = message.cacheDataRequests.map((e) => CMsgSteamLearnCacheDataRequest.toJSON(e));
    }
    if (message.snapshotRequests?.length) {
      obj.snapshotRequests = message.snapshotRequests.map((e) => CMsgSteamLearnSnapshotProjectRequest.toJSON(e));
    }
    if (message.inferenceRequests?.length) {
      obj.inferenceRequests = message.inferenceRequests.map((e) => CMsgSteamLearnInferenceRequest.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSteamLearnBatchOperationRequest>): CMsgSteamLearnBatchOperationRequest {
    return CMsgSteamLearnBatchOperationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSteamLearnBatchOperationRequest>): CMsgSteamLearnBatchOperationRequest {
    const message = createBaseCMsgSteamLearnBatchOperationRequest();
    message.cacheDataRequests =
      object.cacheDataRequests?.map((e) => CMsgSteamLearnCacheDataRequest.fromPartial(e)) || [];
    message.snapshotRequests =
      object.snapshotRequests?.map((e) => CMsgSteamLearnSnapshotProjectRequest.fromPartial(e)) || [];
    message.inferenceRequests =
      object.inferenceRequests?.map((e) => CMsgSteamLearnInferenceRequest.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgSteamLearnBatchOperationResponse(): CMsgSteamLearnBatchOperationResponse {
  return { cacheDataResponses: [], snapshotResponses: [], inferenceResponses: [] };
}

export const CMsgSteamLearnBatchOperationResponse = {
  encode(message: CMsgSteamLearnBatchOperationResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.cacheDataResponses) {
      CMsgSteamLearnCacheDataResponse.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.snapshotResponses) {
      CMsgSteamLearnSnapshotProjectResponse.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.inferenceResponses) {
      CMsgSteamLearnInferenceResponse.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSteamLearnBatchOperationResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSteamLearnBatchOperationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.cacheDataResponses.push(CMsgSteamLearnCacheDataResponse.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.snapshotResponses.push(CMsgSteamLearnSnapshotProjectResponse.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.inferenceResponses.push(CMsgSteamLearnInferenceResponse.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSteamLearnBatchOperationResponse {
    return {
      cacheDataResponses: globalThis.Array.isArray(object?.cacheDataResponses)
        ? object.cacheDataResponses.map((e: any) => CMsgSteamLearnCacheDataResponse.fromJSON(e))
        : [],
      snapshotResponses: globalThis.Array.isArray(object?.snapshotResponses)
        ? object.snapshotResponses.map((e: any) => CMsgSteamLearnSnapshotProjectResponse.fromJSON(e))
        : [],
      inferenceResponses: globalThis.Array.isArray(object?.inferenceResponses)
        ? object.inferenceResponses.map((e: any) => CMsgSteamLearnInferenceResponse.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgSteamLearnBatchOperationResponse): unknown {
    const obj: any = {};
    if (message.cacheDataResponses?.length) {
      obj.cacheDataResponses = message.cacheDataResponses.map((e) => CMsgSteamLearnCacheDataResponse.toJSON(e));
    }
    if (message.snapshotResponses?.length) {
      obj.snapshotResponses = message.snapshotResponses.map((e) => CMsgSteamLearnSnapshotProjectResponse.toJSON(e));
    }
    if (message.inferenceResponses?.length) {
      obj.inferenceResponses = message.inferenceResponses.map((e) => CMsgSteamLearnInferenceResponse.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSteamLearnBatchOperationResponse>): CMsgSteamLearnBatchOperationResponse {
    return CMsgSteamLearnBatchOperationResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSteamLearnBatchOperationResponse>): CMsgSteamLearnBatchOperationResponse {
    const message = createBaseCMsgSteamLearnBatchOperationResponse();
    message.cacheDataResponses =
      object.cacheDataResponses?.map((e) => CMsgSteamLearnCacheDataResponse.fromPartial(e)) || [];
    message.snapshotResponses =
      object.snapshotResponses?.map((e) => CMsgSteamLearnSnapshotProjectResponse.fromPartial(e)) || [];
    message.inferenceResponses =
      object.inferenceResponses?.map((e) => CMsgSteamLearnInferenceResponse.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgSteamLearnAccessTokens(): CMsgSteamLearnAccessTokens {
  return {
    registerDataSourceAccessToken: "",
    cacheDataAccessTokens: [],
    snapshotProjectAccessTokens: [],
    inferenceAccessTokens: [],
  };
}

export const CMsgSteamLearnAccessTokens = {
  encode(message: CMsgSteamLearnAccessTokens, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.registerDataSourceAccessToken !== undefined && message.registerDataSourceAccessToken !== "") {
      writer.uint32(10).string(message.registerDataSourceAccessToken);
    }
    for (const v of message.cacheDataAccessTokens) {
      CMsgSteamLearnAccessTokens_CacheDataAccessToken.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.snapshotProjectAccessTokens) {
      CMsgSteamLearnAccessTokens_SnapshotProjectAccessToken.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    for (const v of message.inferenceAccessTokens) {
      CMsgSteamLearnAccessTokens_InferenceAccessToken.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSteamLearnAccessTokens {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSteamLearnAccessTokens();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.registerDataSourceAccessToken = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.cacheDataAccessTokens.push(
            CMsgSteamLearnAccessTokens_CacheDataAccessToken.decode(reader, reader.uint32()),
          );
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.snapshotProjectAccessTokens.push(
            CMsgSteamLearnAccessTokens_SnapshotProjectAccessToken.decode(reader, reader.uint32()),
          );
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.inferenceAccessTokens.push(
            CMsgSteamLearnAccessTokens_InferenceAccessToken.decode(reader, reader.uint32()),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSteamLearnAccessTokens {
    return {
      registerDataSourceAccessToken: isSet(object.registerDataSourceAccessToken)
        ? globalThis.String(object.registerDataSourceAccessToken)
        : "",
      cacheDataAccessTokens: globalThis.Array.isArray(object?.cacheDataAccessTokens)
        ? object.cacheDataAccessTokens.map((e: any) => CMsgSteamLearnAccessTokens_CacheDataAccessToken.fromJSON(e))
        : [],
      snapshotProjectAccessTokens: globalThis.Array.isArray(object?.snapshotProjectAccessTokens)
        ? object.snapshotProjectAccessTokens.map((e: any) =>
            CMsgSteamLearnAccessTokens_SnapshotProjectAccessToken.fromJSON(e),
          )
        : [],
      inferenceAccessTokens: globalThis.Array.isArray(object?.inferenceAccessTokens)
        ? object.inferenceAccessTokens.map((e: any) => CMsgSteamLearnAccessTokens_InferenceAccessToken.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgSteamLearnAccessTokens): unknown {
    const obj: any = {};
    if (message.registerDataSourceAccessToken !== undefined && message.registerDataSourceAccessToken !== "") {
      obj.registerDataSourceAccessToken = message.registerDataSourceAccessToken;
    }
    if (message.cacheDataAccessTokens?.length) {
      obj.cacheDataAccessTokens = message.cacheDataAccessTokens.map((e) =>
        CMsgSteamLearnAccessTokens_CacheDataAccessToken.toJSON(e),
      );
    }
    if (message.snapshotProjectAccessTokens?.length) {
      obj.snapshotProjectAccessTokens = message.snapshotProjectAccessTokens.map((e) =>
        CMsgSteamLearnAccessTokens_SnapshotProjectAccessToken.toJSON(e),
      );
    }
    if (message.inferenceAccessTokens?.length) {
      obj.inferenceAccessTokens = message.inferenceAccessTokens.map((e) =>
        CMsgSteamLearnAccessTokens_InferenceAccessToken.toJSON(e),
      );
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSteamLearnAccessTokens>): CMsgSteamLearnAccessTokens {
    return CMsgSteamLearnAccessTokens.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSteamLearnAccessTokens>): CMsgSteamLearnAccessTokens {
    const message = createBaseCMsgSteamLearnAccessTokens();
    message.registerDataSourceAccessToken = object.registerDataSourceAccessToken ?? "";
    message.cacheDataAccessTokens =
      object.cacheDataAccessTokens?.map((e) => CMsgSteamLearnAccessTokens_CacheDataAccessToken.fromPartial(e)) || [];
    message.snapshotProjectAccessTokens =
      object.snapshotProjectAccessTokens?.map((e) =>
        CMsgSteamLearnAccessTokens_SnapshotProjectAccessToken.fromPartial(e),
      ) || [];
    message.inferenceAccessTokens =
      object.inferenceAccessTokens?.map((e) => CMsgSteamLearnAccessTokens_InferenceAccessToken.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgSteamLearnAccessTokens_CacheDataAccessToken(): CMsgSteamLearnAccessTokens_CacheDataAccessToken {
  return { dataSourceId: 0, accessToken: "" };
}

export const CMsgSteamLearnAccessTokens_CacheDataAccessToken = {
  encode(
    message: CMsgSteamLearnAccessTokens_CacheDataAccessToken,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.dataSourceId !== undefined && message.dataSourceId !== 0) {
      writer.uint32(8).uint32(message.dataSourceId);
    }
    if (message.accessToken !== undefined && message.accessToken !== "") {
      writer.uint32(18).string(message.accessToken);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSteamLearnAccessTokens_CacheDataAccessToken {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSteamLearnAccessTokens_CacheDataAccessToken();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.dataSourceId = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.accessToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSteamLearnAccessTokens_CacheDataAccessToken {
    return {
      dataSourceId: isSet(object.dataSourceId) ? globalThis.Number(object.dataSourceId) : 0,
      accessToken: isSet(object.accessToken) ? globalThis.String(object.accessToken) : "",
    };
  },

  toJSON(message: CMsgSteamLearnAccessTokens_CacheDataAccessToken): unknown {
    const obj: any = {};
    if (message.dataSourceId !== undefined && message.dataSourceId !== 0) {
      obj.dataSourceId = Math.round(message.dataSourceId);
    }
    if (message.accessToken !== undefined && message.accessToken !== "") {
      obj.accessToken = message.accessToken;
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgSteamLearnAccessTokens_CacheDataAccessToken>,
  ): CMsgSteamLearnAccessTokens_CacheDataAccessToken {
    return CMsgSteamLearnAccessTokens_CacheDataAccessToken.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgSteamLearnAccessTokens_CacheDataAccessToken>,
  ): CMsgSteamLearnAccessTokens_CacheDataAccessToken {
    const message = createBaseCMsgSteamLearnAccessTokens_CacheDataAccessToken();
    message.dataSourceId = object.dataSourceId ?? 0;
    message.accessToken = object.accessToken ?? "";
    return message;
  },
};

function createBaseCMsgSteamLearnAccessTokens_SnapshotProjectAccessToken(): CMsgSteamLearnAccessTokens_SnapshotProjectAccessToken {
  return { projectId: 0, accessToken: "" };
}

export const CMsgSteamLearnAccessTokens_SnapshotProjectAccessToken = {
  encode(
    message: CMsgSteamLearnAccessTokens_SnapshotProjectAccessToken,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.projectId !== undefined && message.projectId !== 0) {
      writer.uint32(8).uint32(message.projectId);
    }
    if (message.accessToken !== undefined && message.accessToken !== "") {
      writer.uint32(18).string(message.accessToken);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSteamLearnAccessTokens_SnapshotProjectAccessToken {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSteamLearnAccessTokens_SnapshotProjectAccessToken();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.projectId = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.accessToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSteamLearnAccessTokens_SnapshotProjectAccessToken {
    return {
      projectId: isSet(object.projectId) ? globalThis.Number(object.projectId) : 0,
      accessToken: isSet(object.accessToken) ? globalThis.String(object.accessToken) : "",
    };
  },

  toJSON(message: CMsgSteamLearnAccessTokens_SnapshotProjectAccessToken): unknown {
    const obj: any = {};
    if (message.projectId !== undefined && message.projectId !== 0) {
      obj.projectId = Math.round(message.projectId);
    }
    if (message.accessToken !== undefined && message.accessToken !== "") {
      obj.accessToken = message.accessToken;
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgSteamLearnAccessTokens_SnapshotProjectAccessToken>,
  ): CMsgSteamLearnAccessTokens_SnapshotProjectAccessToken {
    return CMsgSteamLearnAccessTokens_SnapshotProjectAccessToken.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgSteamLearnAccessTokens_SnapshotProjectAccessToken>,
  ): CMsgSteamLearnAccessTokens_SnapshotProjectAccessToken {
    const message = createBaseCMsgSteamLearnAccessTokens_SnapshotProjectAccessToken();
    message.projectId = object.projectId ?? 0;
    message.accessToken = object.accessToken ?? "";
    return message;
  },
};

function createBaseCMsgSteamLearnAccessTokens_InferenceAccessToken(): CMsgSteamLearnAccessTokens_InferenceAccessToken {
  return { projectId: 0, accessToken: "" };
}

export const CMsgSteamLearnAccessTokens_InferenceAccessToken = {
  encode(
    message: CMsgSteamLearnAccessTokens_InferenceAccessToken,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.projectId !== undefined && message.projectId !== 0) {
      writer.uint32(8).uint32(message.projectId);
    }
    if (message.accessToken !== undefined && message.accessToken !== "") {
      writer.uint32(18).string(message.accessToken);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSteamLearnAccessTokens_InferenceAccessToken {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSteamLearnAccessTokens_InferenceAccessToken();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.projectId = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.accessToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSteamLearnAccessTokens_InferenceAccessToken {
    return {
      projectId: isSet(object.projectId) ? globalThis.Number(object.projectId) : 0,
      accessToken: isSet(object.accessToken) ? globalThis.String(object.accessToken) : "",
    };
  },

  toJSON(message: CMsgSteamLearnAccessTokens_InferenceAccessToken): unknown {
    const obj: any = {};
    if (message.projectId !== undefined && message.projectId !== 0) {
      obj.projectId = Math.round(message.projectId);
    }
    if (message.accessToken !== undefined && message.accessToken !== "") {
      obj.accessToken = message.accessToken;
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgSteamLearnAccessTokens_InferenceAccessToken>,
  ): CMsgSteamLearnAccessTokens_InferenceAccessToken {
    return CMsgSteamLearnAccessTokens_InferenceAccessToken.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgSteamLearnAccessTokens_InferenceAccessToken>,
  ): CMsgSteamLearnAccessTokens_InferenceAccessToken {
    const message = createBaseCMsgSteamLearnAccessTokens_InferenceAccessToken();
    message.projectId = object.projectId ?? 0;
    message.accessToken = object.accessToken ?? "";
    return message;
  },
};

function createBaseCMsgSteamLearnGetAccessTokensRequest(): CMsgSteamLearnGetAccessTokensRequest {
  return { appid: 0 };
}

export const CMsgSteamLearnGetAccessTokensRequest = {
  encode(message: CMsgSteamLearnGetAccessTokensRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.appid !== undefined && message.appid !== 0) {
      writer.uint32(8).uint32(message.appid);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSteamLearnGetAccessTokensRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSteamLearnGetAccessTokensRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.appid = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSteamLearnGetAccessTokensRequest {
    return { appid: isSet(object.appid) ? globalThis.Number(object.appid) : 0 };
  },

  toJSON(message: CMsgSteamLearnGetAccessTokensRequest): unknown {
    const obj: any = {};
    if (message.appid !== undefined && message.appid !== 0) {
      obj.appid = Math.round(message.appid);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSteamLearnGetAccessTokensRequest>): CMsgSteamLearnGetAccessTokensRequest {
    return CMsgSteamLearnGetAccessTokensRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSteamLearnGetAccessTokensRequest>): CMsgSteamLearnGetAccessTokensRequest {
    const message = createBaseCMsgSteamLearnGetAccessTokensRequest();
    message.appid = object.appid ?? 0;
    return message;
  },
};

function createBaseCMsgSteamLearnGetAccessTokensResponse(): CMsgSteamLearnGetAccessTokensResponse {
  return { result: 0, accessTokens: undefined };
}

export const CMsgSteamLearnGetAccessTokensResponse = {
  encode(message: CMsgSteamLearnGetAccessTokensResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result !== undefined && message.result !== 0) {
      writer.uint32(8).int32(message.result);
    }
    if (message.accessTokens !== undefined) {
      CMsgSteamLearnAccessTokens.encode(message.accessTokens, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSteamLearnGetAccessTokensResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSteamLearnGetAccessTokensResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.result = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.accessTokens = CMsgSteamLearnAccessTokens.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSteamLearnGetAccessTokensResponse {
    return {
      result: isSet(object.result) ? eSteamLearnGetAccessTokensResultFromJSON(object.result) : 0,
      accessTokens: isSet(object.accessTokens) ? CMsgSteamLearnAccessTokens.fromJSON(object.accessTokens) : undefined,
    };
  },

  toJSON(message: CMsgSteamLearnGetAccessTokensResponse): unknown {
    const obj: any = {};
    if (message.result !== undefined && message.result !== 0) {
      obj.result = eSteamLearnGetAccessTokensResultToJSON(message.result);
    }
    if (message.accessTokens !== undefined) {
      obj.accessTokens = CMsgSteamLearnAccessTokens.toJSON(message.accessTokens);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSteamLearnGetAccessTokensResponse>): CMsgSteamLearnGetAccessTokensResponse {
    return CMsgSteamLearnGetAccessTokensResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSteamLearnGetAccessTokensResponse>): CMsgSteamLearnGetAccessTokensResponse {
    const message = createBaseCMsgSteamLearnGetAccessTokensResponse();
    message.result = object.result ?? 0;
    message.accessTokens =
      object.accessTokens !== undefined && object.accessTokens !== null
        ? CMsgSteamLearnAccessTokens.fromPartial(object.accessTokens)
        : undefined;
    return message;
  },
};

function createBaseCMsgSteamLearnInferenceRequest(): CMsgSteamLearnInferenceRequest {
  return {
    accessToken: "",
    projectId: 0,
    publishedVersion: 0,
    overrideTrainId: 0,
    data: undefined,
    additionalData: [],
  };
}

export const CMsgSteamLearnInferenceRequest = {
  encode(message: CMsgSteamLearnInferenceRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.accessToken !== undefined && message.accessToken !== "") {
      writer.uint32(10).string(message.accessToken);
    }
    if (message.projectId !== undefined && message.projectId !== 0) {
      writer.uint32(24).uint32(message.projectId);
    }
    if (message.publishedVersion !== undefined && message.publishedVersion !== 0) {
      writer.uint32(32).uint32(message.publishedVersion);
    }
    if (message.overrideTrainId !== undefined && message.overrideTrainId !== 0) {
      writer.uint32(40).uint32(message.overrideTrainId);
    }
    if (message.data !== undefined) {
      CMsgSteamLearnDataList.encode(message.data, writer.uint32(50).fork()).ldelim();
    }
    writer.uint32(58).fork();
    for (const v of message.additionalData) {
      writer.float(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSteamLearnInferenceRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSteamLearnInferenceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.accessToken = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.projectId = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.publishedVersion = reader.uint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.overrideTrainId = reader.uint32();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.data = CMsgSteamLearnDataList.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag === 61) {
            message.additionalData.push(reader.float());

            continue;
          }

          if (tag === 58) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.additionalData.push(reader.float());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSteamLearnInferenceRequest {
    return {
      accessToken: isSet(object.accessToken) ? globalThis.String(object.accessToken) : "",
      projectId: isSet(object.projectId) ? globalThis.Number(object.projectId) : 0,
      publishedVersion: isSet(object.publishedVersion) ? globalThis.Number(object.publishedVersion) : 0,
      overrideTrainId: isSet(object.overrideTrainId) ? globalThis.Number(object.overrideTrainId) : 0,
      data: isSet(object.data) ? CMsgSteamLearnDataList.fromJSON(object.data) : undefined,
      additionalData: globalThis.Array.isArray(object?.additionalData)
        ? object.additionalData.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: CMsgSteamLearnInferenceRequest): unknown {
    const obj: any = {};
    if (message.accessToken !== undefined && message.accessToken !== "") {
      obj.accessToken = message.accessToken;
    }
    if (message.projectId !== undefined && message.projectId !== 0) {
      obj.projectId = Math.round(message.projectId);
    }
    if (message.publishedVersion !== undefined && message.publishedVersion !== 0) {
      obj.publishedVersion = Math.round(message.publishedVersion);
    }
    if (message.overrideTrainId !== undefined && message.overrideTrainId !== 0) {
      obj.overrideTrainId = Math.round(message.overrideTrainId);
    }
    if (message.data !== undefined) {
      obj.data = CMsgSteamLearnDataList.toJSON(message.data);
    }
    if (message.additionalData?.length) {
      obj.additionalData = message.additionalData;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSteamLearnInferenceRequest>): CMsgSteamLearnInferenceRequest {
    return CMsgSteamLearnInferenceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSteamLearnInferenceRequest>): CMsgSteamLearnInferenceRequest {
    const message = createBaseCMsgSteamLearnInferenceRequest();
    message.accessToken = object.accessToken ?? "";
    message.projectId = object.projectId ?? 0;
    message.publishedVersion = object.publishedVersion ?? 0;
    message.overrideTrainId = object.overrideTrainId ?? 0;
    message.data =
      object.data !== undefined && object.data !== null ? CMsgSteamLearnDataList.fromPartial(object.data) : undefined;
    message.additionalData = object.additionalData?.map((e) => e) || [];
    return message;
  },
};

function createBaseCMsgSteamLearnInferenceMetadataRequest(): CMsgSteamLearnInferenceMetadataRequest {
  return { accessToken: "", projectId: 0, publishedVersion: 0, overrideTrainId: 0 };
}

export const CMsgSteamLearnInferenceMetadataRequest = {
  encode(message: CMsgSteamLearnInferenceMetadataRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.accessToken !== undefined && message.accessToken !== "") {
      writer.uint32(10).string(message.accessToken);
    }
    if (message.projectId !== undefined && message.projectId !== 0) {
      writer.uint32(24).uint32(message.projectId);
    }
    if (message.publishedVersion !== undefined && message.publishedVersion !== 0) {
      writer.uint32(32).uint32(message.publishedVersion);
    }
    if (message.overrideTrainId !== undefined && message.overrideTrainId !== 0) {
      writer.uint32(40).uint32(message.overrideTrainId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSteamLearnInferenceMetadataRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSteamLearnInferenceMetadataRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.accessToken = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.projectId = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.publishedVersion = reader.uint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.overrideTrainId = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSteamLearnInferenceMetadataRequest {
    return {
      accessToken: isSet(object.accessToken) ? globalThis.String(object.accessToken) : "",
      projectId: isSet(object.projectId) ? globalThis.Number(object.projectId) : 0,
      publishedVersion: isSet(object.publishedVersion) ? globalThis.Number(object.publishedVersion) : 0,
      overrideTrainId: isSet(object.overrideTrainId) ? globalThis.Number(object.overrideTrainId) : 0,
    };
  },

  toJSON(message: CMsgSteamLearnInferenceMetadataRequest): unknown {
    const obj: any = {};
    if (message.accessToken !== undefined && message.accessToken !== "") {
      obj.accessToken = message.accessToken;
    }
    if (message.projectId !== undefined && message.projectId !== 0) {
      obj.projectId = Math.round(message.projectId);
    }
    if (message.publishedVersion !== undefined && message.publishedVersion !== 0) {
      obj.publishedVersion = Math.round(message.publishedVersion);
    }
    if (message.overrideTrainId !== undefined && message.overrideTrainId !== 0) {
      obj.overrideTrainId = Math.round(message.overrideTrainId);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSteamLearnInferenceMetadataRequest>): CMsgSteamLearnInferenceMetadataRequest {
    return CMsgSteamLearnInferenceMetadataRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSteamLearnInferenceMetadataRequest>): CMsgSteamLearnInferenceMetadataRequest {
    const message = createBaseCMsgSteamLearnInferenceMetadataRequest();
    message.accessToken = object.accessToken ?? "";
    message.projectId = object.projectId ?? 0;
    message.publishedVersion = object.publishedVersion ?? 0;
    message.overrideTrainId = object.overrideTrainId ?? 0;
    return message;
  },
};

function createBaseCMsgSteamLearnInferenceMetadataBackendRequest(): CMsgSteamLearnInferenceMetadataBackendRequest {
  return { projectId: 0, fetchId: 0 };
}

export const CMsgSteamLearnInferenceMetadataBackendRequest = {
  encode(message: CMsgSteamLearnInferenceMetadataBackendRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.projectId !== undefined && message.projectId !== 0) {
      writer.uint32(8).uint32(message.projectId);
    }
    if (message.fetchId !== undefined && message.fetchId !== 0) {
      writer.uint32(16).uint32(message.fetchId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSteamLearnInferenceMetadataBackendRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSteamLearnInferenceMetadataBackendRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.projectId = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.fetchId = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSteamLearnInferenceMetadataBackendRequest {
    return {
      projectId: isSet(object.projectId) ? globalThis.Number(object.projectId) : 0,
      fetchId: isSet(object.fetchId) ? globalThis.Number(object.fetchId) : 0,
    };
  },

  toJSON(message: CMsgSteamLearnInferenceMetadataBackendRequest): unknown {
    const obj: any = {};
    if (message.projectId !== undefined && message.projectId !== 0) {
      obj.projectId = Math.round(message.projectId);
    }
    if (message.fetchId !== undefined && message.fetchId !== 0) {
      obj.fetchId = Math.round(message.fetchId);
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgSteamLearnInferenceMetadataBackendRequest>,
  ): CMsgSteamLearnInferenceMetadataBackendRequest {
    return CMsgSteamLearnInferenceMetadataBackendRequest.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgSteamLearnInferenceMetadataBackendRequest>,
  ): CMsgSteamLearnInferenceMetadataBackendRequest {
    const message = createBaseCMsgSteamLearnInferenceMetadataBackendRequest();
    message.projectId = object.projectId ?? 0;
    message.fetchId = object.fetchId ?? 0;
    return message;
  },
};

function createBaseCMsgSteamLearnInferenceMetadataResponse(): CMsgSteamLearnInferenceMetadataResponse {
  return {
    inferenceMetadataResult: 0,
    rowRange: undefined,
    ranges: [],
    stdDevs: [],
    compactTables: [],
    kmeans: [],
    snapshotHistogram: undefined,
  };
}

export const CMsgSteamLearnInferenceMetadataResponse = {
  encode(message: CMsgSteamLearnInferenceMetadataResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.inferenceMetadataResult !== undefined && message.inferenceMetadataResult !== 0) {
      writer.uint32(8).int32(message.inferenceMetadataResult);
    }
    if (message.rowRange !== undefined) {
      CMsgSteamLearnInferenceMetadataResponse_RowRange.encode(message.rowRange, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.ranges) {
      CMsgSteamLearnInferenceMetadataResponse_Range.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    for (const v of message.stdDevs) {
      CMsgSteamLearnInferenceMetadataResponse_StdDev.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    for (const v of message.compactTables) {
      CMsgSteamLearnInferenceMetadataResponse_CompactTable.encode(v!, writer.uint32(42).fork()).ldelim();
    }
    for (const v of message.kmeans) {
      CMsgSteamLearnInferenceMetadataResponse_KMeans.encode(v!, writer.uint32(50).fork()).ldelim();
    }
    if (message.snapshotHistogram !== undefined) {
      CMsgSteamLearnInferenceMetadataResponse_SnapshotHistogram.encode(
        message.snapshotHistogram,
        writer.uint32(58).fork(),
      ).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSteamLearnInferenceMetadataResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSteamLearnInferenceMetadataResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.inferenceMetadataResult = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.rowRange = CMsgSteamLearnInferenceMetadataResponse_RowRange.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.ranges.push(CMsgSteamLearnInferenceMetadataResponse_Range.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.stdDevs.push(CMsgSteamLearnInferenceMetadataResponse_StdDev.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.compactTables.push(
            CMsgSteamLearnInferenceMetadataResponse_CompactTable.decode(reader, reader.uint32()),
          );
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.kmeans.push(CMsgSteamLearnInferenceMetadataResponse_KMeans.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.snapshotHistogram = CMsgSteamLearnInferenceMetadataResponse_SnapshotHistogram.decode(
            reader,
            reader.uint32(),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSteamLearnInferenceMetadataResponse {
    return {
      inferenceMetadataResult: isSet(object.inferenceMetadataResult)
        ? eSteamLearnInferenceMetadataResultFromJSON(object.inferenceMetadataResult)
        : 0,
      rowRange: isSet(object.rowRange)
        ? CMsgSteamLearnInferenceMetadataResponse_RowRange.fromJSON(object.rowRange)
        : undefined,
      ranges: globalThis.Array.isArray(object?.ranges)
        ? object.ranges.map((e: any) => CMsgSteamLearnInferenceMetadataResponse_Range.fromJSON(e))
        : [],
      stdDevs: globalThis.Array.isArray(object?.stdDevs)
        ? object.stdDevs.map((e: any) => CMsgSteamLearnInferenceMetadataResponse_StdDev.fromJSON(e))
        : [],
      compactTables: globalThis.Array.isArray(object?.compactTables)
        ? object.compactTables.map((e: any) => CMsgSteamLearnInferenceMetadataResponse_CompactTable.fromJSON(e))
        : [],
      kmeans: globalThis.Array.isArray(object?.kmeans)
        ? object.kmeans.map((e: any) => CMsgSteamLearnInferenceMetadataResponse_KMeans.fromJSON(e))
        : [],
      snapshotHistogram: isSet(object.snapshotHistogram)
        ? CMsgSteamLearnInferenceMetadataResponse_SnapshotHistogram.fromJSON(object.snapshotHistogram)
        : undefined,
    };
  },

  toJSON(message: CMsgSteamLearnInferenceMetadataResponse): unknown {
    const obj: any = {};
    if (message.inferenceMetadataResult !== undefined && message.inferenceMetadataResult !== 0) {
      obj.inferenceMetadataResult = eSteamLearnInferenceMetadataResultToJSON(message.inferenceMetadataResult);
    }
    if (message.rowRange !== undefined) {
      obj.rowRange = CMsgSteamLearnInferenceMetadataResponse_RowRange.toJSON(message.rowRange);
    }
    if (message.ranges?.length) {
      obj.ranges = message.ranges.map((e) => CMsgSteamLearnInferenceMetadataResponse_Range.toJSON(e));
    }
    if (message.stdDevs?.length) {
      obj.stdDevs = message.stdDevs.map((e) => CMsgSteamLearnInferenceMetadataResponse_StdDev.toJSON(e));
    }
    if (message.compactTables?.length) {
      obj.compactTables = message.compactTables.map((e) =>
        CMsgSteamLearnInferenceMetadataResponse_CompactTable.toJSON(e),
      );
    }
    if (message.kmeans?.length) {
      obj.kmeans = message.kmeans.map((e) => CMsgSteamLearnInferenceMetadataResponse_KMeans.toJSON(e));
    }
    if (message.snapshotHistogram !== undefined) {
      obj.snapshotHistogram = CMsgSteamLearnInferenceMetadataResponse_SnapshotHistogram.toJSON(
        message.snapshotHistogram,
      );
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSteamLearnInferenceMetadataResponse>): CMsgSteamLearnInferenceMetadataResponse {
    return CMsgSteamLearnInferenceMetadataResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSteamLearnInferenceMetadataResponse>): CMsgSteamLearnInferenceMetadataResponse {
    const message = createBaseCMsgSteamLearnInferenceMetadataResponse();
    message.inferenceMetadataResult = object.inferenceMetadataResult ?? 0;
    message.rowRange =
      object.rowRange !== undefined && object.rowRange !== null
        ? CMsgSteamLearnInferenceMetadataResponse_RowRange.fromPartial(object.rowRange)
        : undefined;
    message.ranges = object.ranges?.map((e) => CMsgSteamLearnInferenceMetadataResponse_Range.fromPartial(e)) || [];
    message.stdDevs = object.stdDevs?.map((e) => CMsgSteamLearnInferenceMetadataResponse_StdDev.fromPartial(e)) || [];
    message.compactTables =
      object.compactTables?.map((e) => CMsgSteamLearnInferenceMetadataResponse_CompactTable.fromPartial(e)) || [];
    message.kmeans = object.kmeans?.map((e) => CMsgSteamLearnInferenceMetadataResponse_KMeans.fromPartial(e)) || [];
    message.snapshotHistogram =
      object.snapshotHistogram !== undefined && object.snapshotHistogram !== null
        ? CMsgSteamLearnInferenceMetadataResponse_SnapshotHistogram.fromPartial(object.snapshotHistogram)
        : undefined;
    return message;
  },
};

function createBaseCMsgSteamLearnInferenceMetadataResponse_RowRange(): CMsgSteamLearnInferenceMetadataResponse_RowRange {
  return { minRow: "0", maxRow: "0" };
}

export const CMsgSteamLearnInferenceMetadataResponse_RowRange = {
  encode(
    message: CMsgSteamLearnInferenceMetadataResponse_RowRange,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.minRow !== undefined && message.minRow !== "0") {
      writer.uint32(8).uint64(message.minRow);
    }
    if (message.maxRow !== undefined && message.maxRow !== "0") {
      writer.uint32(16).uint64(message.maxRow);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSteamLearnInferenceMetadataResponse_RowRange {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSteamLearnInferenceMetadataResponse_RowRange();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.minRow = longToString(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.maxRow = longToString(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSteamLearnInferenceMetadataResponse_RowRange {
    return {
      minRow: isSet(object.minRow) ? globalThis.String(object.minRow) : "0",
      maxRow: isSet(object.maxRow) ? globalThis.String(object.maxRow) : "0",
    };
  },

  toJSON(message: CMsgSteamLearnInferenceMetadataResponse_RowRange): unknown {
    const obj: any = {};
    if (message.minRow !== undefined && message.minRow !== "0") {
      obj.minRow = message.minRow;
    }
    if (message.maxRow !== undefined && message.maxRow !== "0") {
      obj.maxRow = message.maxRow;
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgSteamLearnInferenceMetadataResponse_RowRange>,
  ): CMsgSteamLearnInferenceMetadataResponse_RowRange {
    return CMsgSteamLearnInferenceMetadataResponse_RowRange.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgSteamLearnInferenceMetadataResponse_RowRange>,
  ): CMsgSteamLearnInferenceMetadataResponse_RowRange {
    const message = createBaseCMsgSteamLearnInferenceMetadataResponse_RowRange();
    message.minRow = object.minRow ?? "0";
    message.maxRow = object.maxRow ?? "0";
    return message;
  },
};

function createBaseCMsgSteamLearnInferenceMetadataResponse_Range(): CMsgSteamLearnInferenceMetadataResponse_Range {
  return { dataElementPath: "", minValue: 0, maxValue: 0 };
}

export const CMsgSteamLearnInferenceMetadataResponse_Range = {
  encode(message: CMsgSteamLearnInferenceMetadataResponse_Range, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.dataElementPath !== undefined && message.dataElementPath !== "") {
      writer.uint32(10).string(message.dataElementPath);
    }
    if (message.minValue !== undefined && message.minValue !== 0) {
      writer.uint32(21).float(message.minValue);
    }
    if (message.maxValue !== undefined && message.maxValue !== 0) {
      writer.uint32(29).float(message.maxValue);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSteamLearnInferenceMetadataResponse_Range {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSteamLearnInferenceMetadataResponse_Range();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.dataElementPath = reader.string();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.minValue = reader.float();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.maxValue = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSteamLearnInferenceMetadataResponse_Range {
    return {
      dataElementPath: isSet(object.dataElementPath) ? globalThis.String(object.dataElementPath) : "",
      minValue: isSet(object.minValue) ? globalThis.Number(object.minValue) : 0,
      maxValue: isSet(object.maxValue) ? globalThis.Number(object.maxValue) : 0,
    };
  },

  toJSON(message: CMsgSteamLearnInferenceMetadataResponse_Range): unknown {
    const obj: any = {};
    if (message.dataElementPath !== undefined && message.dataElementPath !== "") {
      obj.dataElementPath = message.dataElementPath;
    }
    if (message.minValue !== undefined && message.minValue !== 0) {
      obj.minValue = message.minValue;
    }
    if (message.maxValue !== undefined && message.maxValue !== 0) {
      obj.maxValue = message.maxValue;
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgSteamLearnInferenceMetadataResponse_Range>,
  ): CMsgSteamLearnInferenceMetadataResponse_Range {
    return CMsgSteamLearnInferenceMetadataResponse_Range.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgSteamLearnInferenceMetadataResponse_Range>,
  ): CMsgSteamLearnInferenceMetadataResponse_Range {
    const message = createBaseCMsgSteamLearnInferenceMetadataResponse_Range();
    message.dataElementPath = object.dataElementPath ?? "";
    message.minValue = object.minValue ?? 0;
    message.maxValue = object.maxValue ?? 0;
    return message;
  },
};

function createBaseCMsgSteamLearnInferenceMetadataResponse_StdDev(): CMsgSteamLearnInferenceMetadataResponse_StdDev {
  return { dataElementPath: "", mean: 0, stdDev: 0 };
}

export const CMsgSteamLearnInferenceMetadataResponse_StdDev = {
  encode(
    message: CMsgSteamLearnInferenceMetadataResponse_StdDev,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.dataElementPath !== undefined && message.dataElementPath !== "") {
      writer.uint32(10).string(message.dataElementPath);
    }
    if (message.mean !== undefined && message.mean !== 0) {
      writer.uint32(21).float(message.mean);
    }
    if (message.stdDev !== undefined && message.stdDev !== 0) {
      writer.uint32(29).float(message.stdDev);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSteamLearnInferenceMetadataResponse_StdDev {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSteamLearnInferenceMetadataResponse_StdDev();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.dataElementPath = reader.string();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.mean = reader.float();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.stdDev = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSteamLearnInferenceMetadataResponse_StdDev {
    return {
      dataElementPath: isSet(object.dataElementPath) ? globalThis.String(object.dataElementPath) : "",
      mean: isSet(object.mean) ? globalThis.Number(object.mean) : 0,
      stdDev: isSet(object.stdDev) ? globalThis.Number(object.stdDev) : 0,
    };
  },

  toJSON(message: CMsgSteamLearnInferenceMetadataResponse_StdDev): unknown {
    const obj: any = {};
    if (message.dataElementPath !== undefined && message.dataElementPath !== "") {
      obj.dataElementPath = message.dataElementPath;
    }
    if (message.mean !== undefined && message.mean !== 0) {
      obj.mean = message.mean;
    }
    if (message.stdDev !== undefined && message.stdDev !== 0) {
      obj.stdDev = message.stdDev;
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgSteamLearnInferenceMetadataResponse_StdDev>,
  ): CMsgSteamLearnInferenceMetadataResponse_StdDev {
    return CMsgSteamLearnInferenceMetadataResponse_StdDev.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgSteamLearnInferenceMetadataResponse_StdDev>,
  ): CMsgSteamLearnInferenceMetadataResponse_StdDev {
    const message = createBaseCMsgSteamLearnInferenceMetadataResponse_StdDev();
    message.dataElementPath = object.dataElementPath ?? "";
    message.mean = object.mean ?? 0;
    message.stdDev = object.stdDev ?? 0;
    return message;
  },
};

function createBaseCMsgSteamLearnInferenceMetadataResponse_CompactTable(): CMsgSteamLearnInferenceMetadataResponse_CompactTable {
  return { name: "", mapValues: [], mapMappings: [] };
}

export const CMsgSteamLearnInferenceMetadataResponse_CompactTable = {
  encode(
    message: CMsgSteamLearnInferenceMetadataResponse_CompactTable,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.mapValues) {
      CMsgSteamLearnInferenceMetadataResponse_CompactTable_MapValuesEntry.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.mapMappings) {
      CMsgSteamLearnInferenceMetadataResponse_CompactTable_MapMappingsEntry.encode(
        v!,
        writer.uint32(26).fork(),
      ).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSteamLearnInferenceMetadataResponse_CompactTable {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSteamLearnInferenceMetadataResponse_CompactTable();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.mapValues.push(
            CMsgSteamLearnInferenceMetadataResponse_CompactTable_MapValuesEntry.decode(reader, reader.uint32()),
          );
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.mapMappings.push(
            CMsgSteamLearnInferenceMetadataResponse_CompactTable_MapMappingsEntry.decode(reader, reader.uint32()),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSteamLearnInferenceMetadataResponse_CompactTable {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      mapValues: globalThis.Array.isArray(object?.mapValues)
        ? object.mapValues.map((e: any) =>
            CMsgSteamLearnInferenceMetadataResponse_CompactTable_MapValuesEntry.fromJSON(e),
          )
        : [],
      mapMappings: globalThis.Array.isArray(object?.mapMappings)
        ? object.mapMappings.map((e: any) =>
            CMsgSteamLearnInferenceMetadataResponse_CompactTable_MapMappingsEntry.fromJSON(e),
          )
        : [],
    };
  },

  toJSON(message: CMsgSteamLearnInferenceMetadataResponse_CompactTable): unknown {
    const obj: any = {};
    if (message.name !== undefined && message.name !== "") {
      obj.name = message.name;
    }
    if (message.mapValues?.length) {
      obj.mapValues = message.mapValues.map((e) =>
        CMsgSteamLearnInferenceMetadataResponse_CompactTable_MapValuesEntry.toJSON(e),
      );
    }
    if (message.mapMappings?.length) {
      obj.mapMappings = message.mapMappings.map((e) =>
        CMsgSteamLearnInferenceMetadataResponse_CompactTable_MapMappingsEntry.toJSON(e),
      );
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgSteamLearnInferenceMetadataResponse_CompactTable>,
  ): CMsgSteamLearnInferenceMetadataResponse_CompactTable {
    return CMsgSteamLearnInferenceMetadataResponse_CompactTable.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgSteamLearnInferenceMetadataResponse_CompactTable>,
  ): CMsgSteamLearnInferenceMetadataResponse_CompactTable {
    const message = createBaseCMsgSteamLearnInferenceMetadataResponse_CompactTable();
    message.name = object.name ?? "";
    message.mapValues =
      object.mapValues?.map((e) =>
        CMsgSteamLearnInferenceMetadataResponse_CompactTable_MapValuesEntry.fromPartial(e),
      ) || [];
    message.mapMappings =
      object.mapMappings?.map((e) =>
        CMsgSteamLearnInferenceMetadataResponse_CompactTable_MapMappingsEntry.fromPartial(e),
      ) || [];
    return message;
  },
};

function createBaseCMsgSteamLearnInferenceMetadataResponse_CompactTable_Entry(): CMsgSteamLearnInferenceMetadataResponse_CompactTable_Entry {
  return { value: 0, mapping: 0, count: "0" };
}

export const CMsgSteamLearnInferenceMetadataResponse_CompactTable_Entry = {
  encode(
    message: CMsgSteamLearnInferenceMetadataResponse_CompactTable_Entry,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.value !== undefined && message.value !== 0) {
      writer.uint32(8).uint32(message.value);
    }
    if (message.mapping !== undefined && message.mapping !== 0) {
      writer.uint32(16).uint32(message.mapping);
    }
    if (message.count !== undefined && message.count !== "0") {
      writer.uint32(24).uint64(message.count);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSteamLearnInferenceMetadataResponse_CompactTable_Entry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSteamLearnInferenceMetadataResponse_CompactTable_Entry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.value = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.mapping = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.count = longToString(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSteamLearnInferenceMetadataResponse_CompactTable_Entry {
    return {
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
      mapping: isSet(object.mapping) ? globalThis.Number(object.mapping) : 0,
      count: isSet(object.count) ? globalThis.String(object.count) : "0",
    };
  },

  toJSON(message: CMsgSteamLearnInferenceMetadataResponse_CompactTable_Entry): unknown {
    const obj: any = {};
    if (message.value !== undefined && message.value !== 0) {
      obj.value = Math.round(message.value);
    }
    if (message.mapping !== undefined && message.mapping !== 0) {
      obj.mapping = Math.round(message.mapping);
    }
    if (message.count !== undefined && message.count !== "0") {
      obj.count = message.count;
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgSteamLearnInferenceMetadataResponse_CompactTable_Entry>,
  ): CMsgSteamLearnInferenceMetadataResponse_CompactTable_Entry {
    return CMsgSteamLearnInferenceMetadataResponse_CompactTable_Entry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgSteamLearnInferenceMetadataResponse_CompactTable_Entry>,
  ): CMsgSteamLearnInferenceMetadataResponse_CompactTable_Entry {
    const message = createBaseCMsgSteamLearnInferenceMetadataResponse_CompactTable_Entry();
    message.value = object.value ?? 0;
    message.mapping = object.mapping ?? 0;
    message.count = object.count ?? "0";
    return message;
  },
};

function createBaseCMsgSteamLearnInferenceMetadataResponse_CompactTable_MapValuesEntry(): CMsgSteamLearnInferenceMetadataResponse_CompactTable_MapValuesEntry {
  return { key: 0, value: undefined };
}

export const CMsgSteamLearnInferenceMetadataResponse_CompactTable_MapValuesEntry = {
  encode(
    message: CMsgSteamLearnInferenceMetadataResponse_CompactTable_MapValuesEntry,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.key !== undefined && message.key !== 0) {
      writer.uint32(8).uint32(message.key);
    }
    if (message.value !== undefined) {
      CMsgSteamLearnInferenceMetadataResponse_CompactTable_Entry.encode(
        message.value,
        writer.uint32(18).fork(),
      ).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): CMsgSteamLearnInferenceMetadataResponse_CompactTable_MapValuesEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSteamLearnInferenceMetadataResponse_CompactTable_MapValuesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.key = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = CMsgSteamLearnInferenceMetadataResponse_CompactTable_Entry.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSteamLearnInferenceMetadataResponse_CompactTable_MapValuesEntry {
    return {
      key: isSet(object.key) ? globalThis.Number(object.key) : 0,
      value: isSet(object.value)
        ? CMsgSteamLearnInferenceMetadataResponse_CompactTable_Entry.fromJSON(object.value)
        : undefined,
    };
  },

  toJSON(message: CMsgSteamLearnInferenceMetadataResponse_CompactTable_MapValuesEntry): unknown {
    const obj: any = {};
    if (message.key !== undefined && message.key !== 0) {
      obj.key = Math.round(message.key);
    }
    if (message.value !== undefined) {
      obj.value = CMsgSteamLearnInferenceMetadataResponse_CompactTable_Entry.toJSON(message.value);
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgSteamLearnInferenceMetadataResponse_CompactTable_MapValuesEntry>,
  ): CMsgSteamLearnInferenceMetadataResponse_CompactTable_MapValuesEntry {
    return CMsgSteamLearnInferenceMetadataResponse_CompactTable_MapValuesEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgSteamLearnInferenceMetadataResponse_CompactTable_MapValuesEntry>,
  ): CMsgSteamLearnInferenceMetadataResponse_CompactTable_MapValuesEntry {
    const message = createBaseCMsgSteamLearnInferenceMetadataResponse_CompactTable_MapValuesEntry();
    message.key = object.key ?? 0;
    message.value =
      object.value !== undefined && object.value !== null
        ? CMsgSteamLearnInferenceMetadataResponse_CompactTable_Entry.fromPartial(object.value)
        : undefined;
    return message;
  },
};

function createBaseCMsgSteamLearnInferenceMetadataResponse_CompactTable_MapMappingsEntry(): CMsgSteamLearnInferenceMetadataResponse_CompactTable_MapMappingsEntry {
  return { key: 0, value: undefined };
}

export const CMsgSteamLearnInferenceMetadataResponse_CompactTable_MapMappingsEntry = {
  encode(
    message: CMsgSteamLearnInferenceMetadataResponse_CompactTable_MapMappingsEntry,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.key !== undefined && message.key !== 0) {
      writer.uint32(8).uint32(message.key);
    }
    if (message.value !== undefined) {
      CMsgSteamLearnInferenceMetadataResponse_CompactTable_Entry.encode(
        message.value,
        writer.uint32(18).fork(),
      ).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): CMsgSteamLearnInferenceMetadataResponse_CompactTable_MapMappingsEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSteamLearnInferenceMetadataResponse_CompactTable_MapMappingsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.key = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = CMsgSteamLearnInferenceMetadataResponse_CompactTable_Entry.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSteamLearnInferenceMetadataResponse_CompactTable_MapMappingsEntry {
    return {
      key: isSet(object.key) ? globalThis.Number(object.key) : 0,
      value: isSet(object.value)
        ? CMsgSteamLearnInferenceMetadataResponse_CompactTable_Entry.fromJSON(object.value)
        : undefined,
    };
  },

  toJSON(message: CMsgSteamLearnInferenceMetadataResponse_CompactTable_MapMappingsEntry): unknown {
    const obj: any = {};
    if (message.key !== undefined && message.key !== 0) {
      obj.key = Math.round(message.key);
    }
    if (message.value !== undefined) {
      obj.value = CMsgSteamLearnInferenceMetadataResponse_CompactTable_Entry.toJSON(message.value);
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgSteamLearnInferenceMetadataResponse_CompactTable_MapMappingsEntry>,
  ): CMsgSteamLearnInferenceMetadataResponse_CompactTable_MapMappingsEntry {
    return CMsgSteamLearnInferenceMetadataResponse_CompactTable_MapMappingsEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgSteamLearnInferenceMetadataResponse_CompactTable_MapMappingsEntry>,
  ): CMsgSteamLearnInferenceMetadataResponse_CompactTable_MapMappingsEntry {
    const message = createBaseCMsgSteamLearnInferenceMetadataResponse_CompactTable_MapMappingsEntry();
    message.key = object.key ?? 0;
    message.value =
      object.value !== undefined && object.value !== null
        ? CMsgSteamLearnInferenceMetadataResponse_CompactTable_Entry.fromPartial(object.value)
        : undefined;
    return message;
  },
};

function createBaseCMsgSteamLearnInferenceMetadataResponse_KMeans(): CMsgSteamLearnInferenceMetadataResponse_KMeans {
  return { name: "", clusters: [] };
}

export const CMsgSteamLearnInferenceMetadataResponse_KMeans = {
  encode(
    message: CMsgSteamLearnInferenceMetadataResponse_KMeans,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.clusters) {
      CMsgSteamLearnInferenceMetadataResponse_KMeans_Cluster.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSteamLearnInferenceMetadataResponse_KMeans {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSteamLearnInferenceMetadataResponse_KMeans();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.clusters.push(CMsgSteamLearnInferenceMetadataResponse_KMeans_Cluster.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSteamLearnInferenceMetadataResponse_KMeans {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      clusters: globalThis.Array.isArray(object?.clusters)
        ? object.clusters.map((e: any) => CMsgSteamLearnInferenceMetadataResponse_KMeans_Cluster.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgSteamLearnInferenceMetadataResponse_KMeans): unknown {
    const obj: any = {};
    if (message.name !== undefined && message.name !== "") {
      obj.name = message.name;
    }
    if (message.clusters?.length) {
      obj.clusters = message.clusters.map((e) => CMsgSteamLearnInferenceMetadataResponse_KMeans_Cluster.toJSON(e));
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgSteamLearnInferenceMetadataResponse_KMeans>,
  ): CMsgSteamLearnInferenceMetadataResponse_KMeans {
    return CMsgSteamLearnInferenceMetadataResponse_KMeans.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgSteamLearnInferenceMetadataResponse_KMeans>,
  ): CMsgSteamLearnInferenceMetadataResponse_KMeans {
    const message = createBaseCMsgSteamLearnInferenceMetadataResponse_KMeans();
    message.name = object.name ?? "";
    message.clusters =
      object.clusters?.map((e) => CMsgSteamLearnInferenceMetadataResponse_KMeans_Cluster.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgSteamLearnInferenceMetadataResponse_KMeans_Cluster(): CMsgSteamLearnInferenceMetadataResponse_KMeans_Cluster {
  return { x: 0, y: 0, radius: 0, radius75pct: 0, radius50pct: 0, radius25pct: 0 };
}

export const CMsgSteamLearnInferenceMetadataResponse_KMeans_Cluster = {
  encode(
    message: CMsgSteamLearnInferenceMetadataResponse_KMeans_Cluster,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.x !== undefined && message.x !== 0) {
      writer.uint32(13).float(message.x);
    }
    if (message.y !== undefined && message.y !== 0) {
      writer.uint32(21).float(message.y);
    }
    if (message.radius !== undefined && message.radius !== 0) {
      writer.uint32(29).float(message.radius);
    }
    if (message.radius75pct !== undefined && message.radius75pct !== 0) {
      writer.uint32(37).float(message.radius75pct);
    }
    if (message.radius50pct !== undefined && message.radius50pct !== 0) {
      writer.uint32(45).float(message.radius50pct);
    }
    if (message.radius25pct !== undefined && message.radius25pct !== 0) {
      writer.uint32(53).float(message.radius25pct);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSteamLearnInferenceMetadataResponse_KMeans_Cluster {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSteamLearnInferenceMetadataResponse_KMeans_Cluster();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.x = reader.float();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.y = reader.float();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.radius = reader.float();
          continue;
        case 4:
          if (tag !== 37) {
            break;
          }

          message.radius75pct = reader.float();
          continue;
        case 5:
          if (tag !== 45) {
            break;
          }

          message.radius50pct = reader.float();
          continue;
        case 6:
          if (tag !== 53) {
            break;
          }

          message.radius25pct = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSteamLearnInferenceMetadataResponse_KMeans_Cluster {
    return {
      x: isSet(object.x) ? globalThis.Number(object.x) : 0,
      y: isSet(object.y) ? globalThis.Number(object.y) : 0,
      radius: isSet(object.radius) ? globalThis.Number(object.radius) : 0,
      radius75pct: isSet(object.radius75pct) ? globalThis.Number(object.radius75pct) : 0,
      radius50pct: isSet(object.radius50pct) ? globalThis.Number(object.radius50pct) : 0,
      radius25pct: isSet(object.radius25pct) ? globalThis.Number(object.radius25pct) : 0,
    };
  },

  toJSON(message: CMsgSteamLearnInferenceMetadataResponse_KMeans_Cluster): unknown {
    const obj: any = {};
    if (message.x !== undefined && message.x !== 0) {
      obj.x = message.x;
    }
    if (message.y !== undefined && message.y !== 0) {
      obj.y = message.y;
    }
    if (message.radius !== undefined && message.radius !== 0) {
      obj.radius = message.radius;
    }
    if (message.radius75pct !== undefined && message.radius75pct !== 0) {
      obj.radius75pct = message.radius75pct;
    }
    if (message.radius50pct !== undefined && message.radius50pct !== 0) {
      obj.radius50pct = message.radius50pct;
    }
    if (message.radius25pct !== undefined && message.radius25pct !== 0) {
      obj.radius25pct = message.radius25pct;
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgSteamLearnInferenceMetadataResponse_KMeans_Cluster>,
  ): CMsgSteamLearnInferenceMetadataResponse_KMeans_Cluster {
    return CMsgSteamLearnInferenceMetadataResponse_KMeans_Cluster.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgSteamLearnInferenceMetadataResponse_KMeans_Cluster>,
  ): CMsgSteamLearnInferenceMetadataResponse_KMeans_Cluster {
    const message = createBaseCMsgSteamLearnInferenceMetadataResponse_KMeans_Cluster();
    message.x = object.x ?? 0;
    message.y = object.y ?? 0;
    message.radius = object.radius ?? 0;
    message.radius75pct = object.radius75pct ?? 0;
    message.radius50pct = object.radius50pct ?? 0;
    message.radius25pct = object.radius25pct ?? 0;
    return message;
  },
};

function createBaseCMsgSteamLearnInferenceMetadataResponse_SnapshotHistogram(): CMsgSteamLearnInferenceMetadataResponse_SnapshotHistogram {
  return { minValue: 0, maxValue: 0, numBuckets: 0, bucketCounts: [] };
}

export const CMsgSteamLearnInferenceMetadataResponse_SnapshotHistogram = {
  encode(
    message: CMsgSteamLearnInferenceMetadataResponse_SnapshotHistogram,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.minValue !== undefined && message.minValue !== 0) {
      writer.uint32(13).float(message.minValue);
    }
    if (message.maxValue !== undefined && message.maxValue !== 0) {
      writer.uint32(21).float(message.maxValue);
    }
    if (message.numBuckets !== undefined && message.numBuckets !== 0) {
      writer.uint32(24).uint32(message.numBuckets);
    }
    writer.uint32(34).fork();
    for (const v of message.bucketCounts) {
      writer.uint32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSteamLearnInferenceMetadataResponse_SnapshotHistogram {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSteamLearnInferenceMetadataResponse_SnapshotHistogram();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.minValue = reader.float();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.maxValue = reader.float();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.numBuckets = reader.uint32();
          continue;
        case 4:
          if (tag === 32) {
            message.bucketCounts.push(reader.uint32());

            continue;
          }

          if (tag === 34) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.bucketCounts.push(reader.uint32());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSteamLearnInferenceMetadataResponse_SnapshotHistogram {
    return {
      minValue: isSet(object.minValue) ? globalThis.Number(object.minValue) : 0,
      maxValue: isSet(object.maxValue) ? globalThis.Number(object.maxValue) : 0,
      numBuckets: isSet(object.numBuckets) ? globalThis.Number(object.numBuckets) : 0,
      bucketCounts: globalThis.Array.isArray(object?.bucketCounts)
        ? object.bucketCounts.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: CMsgSteamLearnInferenceMetadataResponse_SnapshotHistogram): unknown {
    const obj: any = {};
    if (message.minValue !== undefined && message.minValue !== 0) {
      obj.minValue = message.minValue;
    }
    if (message.maxValue !== undefined && message.maxValue !== 0) {
      obj.maxValue = message.maxValue;
    }
    if (message.numBuckets !== undefined && message.numBuckets !== 0) {
      obj.numBuckets = Math.round(message.numBuckets);
    }
    if (message.bucketCounts?.length) {
      obj.bucketCounts = message.bucketCounts.map((e) => Math.round(e));
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgSteamLearnInferenceMetadataResponse_SnapshotHistogram>,
  ): CMsgSteamLearnInferenceMetadataResponse_SnapshotHistogram {
    return CMsgSteamLearnInferenceMetadataResponse_SnapshotHistogram.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgSteamLearnInferenceMetadataResponse_SnapshotHistogram>,
  ): CMsgSteamLearnInferenceMetadataResponse_SnapshotHistogram {
    const message = createBaseCMsgSteamLearnInferenceMetadataResponse_SnapshotHistogram();
    message.minValue = object.minValue ?? 0;
    message.maxValue = object.maxValue ?? 0;
    message.numBuckets = object.numBuckets ?? 0;
    message.bucketCounts = object.bucketCounts?.map((e) => e) || [];
    return message;
  },
};

function createBaseCMsgSteamLearnInferenceBackendResponse(): CMsgSteamLearnInferenceBackendResponse {
  return { outputs: [] };
}

export const CMsgSteamLearnInferenceBackendResponse = {
  encode(message: CMsgSteamLearnInferenceBackendResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.outputs) {
      CMsgSteamLearnInferenceBackendResponse_Output.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSteamLearnInferenceBackendResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSteamLearnInferenceBackendResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.outputs.push(CMsgSteamLearnInferenceBackendResponse_Output.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSteamLearnInferenceBackendResponse {
    return {
      outputs: globalThis.Array.isArray(object?.outputs)
        ? object.outputs.map((e: any) => CMsgSteamLearnInferenceBackendResponse_Output.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgSteamLearnInferenceBackendResponse): unknown {
    const obj: any = {};
    if (message.outputs?.length) {
      obj.outputs = message.outputs.map((e) => CMsgSteamLearnInferenceBackendResponse_Output.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSteamLearnInferenceBackendResponse>): CMsgSteamLearnInferenceBackendResponse {
    return CMsgSteamLearnInferenceBackendResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSteamLearnInferenceBackendResponse>): CMsgSteamLearnInferenceBackendResponse {
    const message = createBaseCMsgSteamLearnInferenceBackendResponse();
    message.outputs = object.outputs?.map((e) => CMsgSteamLearnInferenceBackendResponse_Output.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgSteamLearnInferenceBackendResponse_RegressionOutput(): CMsgSteamLearnInferenceBackendResponse_RegressionOutput {
  return { value: 0 };
}

export const CMsgSteamLearnInferenceBackendResponse_RegressionOutput = {
  encode(
    message: CMsgSteamLearnInferenceBackendResponse_RegressionOutput,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.value !== undefined && message.value !== 0) {
      writer.uint32(13).float(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSteamLearnInferenceBackendResponse_RegressionOutput {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSteamLearnInferenceBackendResponse_RegressionOutput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.value = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSteamLearnInferenceBackendResponse_RegressionOutput {
    return { value: isSet(object.value) ? globalThis.Number(object.value) : 0 };
  },

  toJSON(message: CMsgSteamLearnInferenceBackendResponse_RegressionOutput): unknown {
    const obj: any = {};
    if (message.value !== undefined && message.value !== 0) {
      obj.value = message.value;
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgSteamLearnInferenceBackendResponse_RegressionOutput>,
  ): CMsgSteamLearnInferenceBackendResponse_RegressionOutput {
    return CMsgSteamLearnInferenceBackendResponse_RegressionOutput.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgSteamLearnInferenceBackendResponse_RegressionOutput>,
  ): CMsgSteamLearnInferenceBackendResponse_RegressionOutput {
    const message = createBaseCMsgSteamLearnInferenceBackendResponse_RegressionOutput();
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseCMsgSteamLearnInferenceBackendResponse_BinaryCrossEntropyOutput(): CMsgSteamLearnInferenceBackendResponse_BinaryCrossEntropyOutput {
  return { value: 0 };
}

export const CMsgSteamLearnInferenceBackendResponse_BinaryCrossEntropyOutput = {
  encode(
    message: CMsgSteamLearnInferenceBackendResponse_BinaryCrossEntropyOutput,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.value !== undefined && message.value !== 0) {
      writer.uint32(13).float(message.value);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): CMsgSteamLearnInferenceBackendResponse_BinaryCrossEntropyOutput {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSteamLearnInferenceBackendResponse_BinaryCrossEntropyOutput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.value = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSteamLearnInferenceBackendResponse_BinaryCrossEntropyOutput {
    return { value: isSet(object.value) ? globalThis.Number(object.value) : 0 };
  },

  toJSON(message: CMsgSteamLearnInferenceBackendResponse_BinaryCrossEntropyOutput): unknown {
    const obj: any = {};
    if (message.value !== undefined && message.value !== 0) {
      obj.value = message.value;
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgSteamLearnInferenceBackendResponse_BinaryCrossEntropyOutput>,
  ): CMsgSteamLearnInferenceBackendResponse_BinaryCrossEntropyOutput {
    return CMsgSteamLearnInferenceBackendResponse_BinaryCrossEntropyOutput.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgSteamLearnInferenceBackendResponse_BinaryCrossEntropyOutput>,
  ): CMsgSteamLearnInferenceBackendResponse_BinaryCrossEntropyOutput {
    const message = createBaseCMsgSteamLearnInferenceBackendResponse_BinaryCrossEntropyOutput();
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseCMsgSteamLearnInferenceBackendResponse_MutliBinaryCrossEntropyOutput(): CMsgSteamLearnInferenceBackendResponse_MutliBinaryCrossEntropyOutput {
  return { weight: [], value: [] };
}

export const CMsgSteamLearnInferenceBackendResponse_MutliBinaryCrossEntropyOutput = {
  encode(
    message: CMsgSteamLearnInferenceBackendResponse_MutliBinaryCrossEntropyOutput,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.weight) {
      writer.float(v);
    }
    writer.ldelim();
    writer.uint32(18).fork();
    for (const v of message.value) {
      writer.float(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): CMsgSteamLearnInferenceBackendResponse_MutliBinaryCrossEntropyOutput {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSteamLearnInferenceBackendResponse_MutliBinaryCrossEntropyOutput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 13) {
            message.weight.push(reader.float());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.weight.push(reader.float());
            }

            continue;
          }

          break;
        case 2:
          if (tag === 21) {
            message.value.push(reader.float());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.value.push(reader.float());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSteamLearnInferenceBackendResponse_MutliBinaryCrossEntropyOutput {
    return {
      weight: globalThis.Array.isArray(object?.weight) ? object.weight.map((e: any) => globalThis.Number(e)) : [],
      value: globalThis.Array.isArray(object?.value) ? object.value.map((e: any) => globalThis.Number(e)) : [],
    };
  },

  toJSON(message: CMsgSteamLearnInferenceBackendResponse_MutliBinaryCrossEntropyOutput): unknown {
    const obj: any = {};
    if (message.weight?.length) {
      obj.weight = message.weight;
    }
    if (message.value?.length) {
      obj.value = message.value;
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgSteamLearnInferenceBackendResponse_MutliBinaryCrossEntropyOutput>,
  ): CMsgSteamLearnInferenceBackendResponse_MutliBinaryCrossEntropyOutput {
    return CMsgSteamLearnInferenceBackendResponse_MutliBinaryCrossEntropyOutput.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgSteamLearnInferenceBackendResponse_MutliBinaryCrossEntropyOutput>,
  ): CMsgSteamLearnInferenceBackendResponse_MutliBinaryCrossEntropyOutput {
    const message = createBaseCMsgSteamLearnInferenceBackendResponse_MutliBinaryCrossEntropyOutput();
    message.weight = object.weight?.map((e) => e) || [];
    message.value = object.value?.map((e) => e) || [];
    return message;
  },
};

function createBaseCMsgSteamLearnInferenceBackendResponse_CategoricalCrossEntropyOutput(): CMsgSteamLearnInferenceBackendResponse_CategoricalCrossEntropyOutput {
  return { weight: [], value: [] };
}

export const CMsgSteamLearnInferenceBackendResponse_CategoricalCrossEntropyOutput = {
  encode(
    message: CMsgSteamLearnInferenceBackendResponse_CategoricalCrossEntropyOutput,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.weight) {
      writer.float(v);
    }
    writer.ldelim();
    writer.uint32(18).fork();
    for (const v of message.value) {
      writer.float(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): CMsgSteamLearnInferenceBackendResponse_CategoricalCrossEntropyOutput {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSteamLearnInferenceBackendResponse_CategoricalCrossEntropyOutput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 13) {
            message.weight.push(reader.float());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.weight.push(reader.float());
            }

            continue;
          }

          break;
        case 2:
          if (tag === 21) {
            message.value.push(reader.float());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.value.push(reader.float());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSteamLearnInferenceBackendResponse_CategoricalCrossEntropyOutput {
    return {
      weight: globalThis.Array.isArray(object?.weight) ? object.weight.map((e: any) => globalThis.Number(e)) : [],
      value: globalThis.Array.isArray(object?.value) ? object.value.map((e: any) => globalThis.Number(e)) : [],
    };
  },

  toJSON(message: CMsgSteamLearnInferenceBackendResponse_CategoricalCrossEntropyOutput): unknown {
    const obj: any = {};
    if (message.weight?.length) {
      obj.weight = message.weight;
    }
    if (message.value?.length) {
      obj.value = message.value;
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgSteamLearnInferenceBackendResponse_CategoricalCrossEntropyOutput>,
  ): CMsgSteamLearnInferenceBackendResponse_CategoricalCrossEntropyOutput {
    return CMsgSteamLearnInferenceBackendResponse_CategoricalCrossEntropyOutput.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgSteamLearnInferenceBackendResponse_CategoricalCrossEntropyOutput>,
  ): CMsgSteamLearnInferenceBackendResponse_CategoricalCrossEntropyOutput {
    const message = createBaseCMsgSteamLearnInferenceBackendResponse_CategoricalCrossEntropyOutput();
    message.weight = object.weight?.map((e) => e) || [];
    message.value = object.value?.map((e) => e) || [];
    return message;
  },
};

function createBaseCMsgSteamLearnInferenceBackendResponse_Output(): CMsgSteamLearnInferenceBackendResponse_Output {
  return {
    binaryCrossentropy: undefined,
    categoricalCrossentropy: undefined,
    multiBinaryCrossentropy: undefined,
    regression: undefined,
  };
}

export const CMsgSteamLearnInferenceBackendResponse_Output = {
  encode(message: CMsgSteamLearnInferenceBackendResponse_Output, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.binaryCrossentropy !== undefined) {
      CMsgSteamLearnInferenceBackendResponse_BinaryCrossEntropyOutput.encode(
        message.binaryCrossentropy,
        writer.uint32(10).fork(),
      ).ldelim();
    }
    if (message.categoricalCrossentropy !== undefined) {
      CMsgSteamLearnInferenceBackendResponse_CategoricalCrossEntropyOutput.encode(
        message.categoricalCrossentropy,
        writer.uint32(18).fork(),
      ).ldelim();
    }
    if (message.multiBinaryCrossentropy !== undefined) {
      CMsgSteamLearnInferenceBackendResponse_MutliBinaryCrossEntropyOutput.encode(
        message.multiBinaryCrossentropy,
        writer.uint32(26).fork(),
      ).ldelim();
    }
    if (message.regression !== undefined) {
      CMsgSteamLearnInferenceBackendResponse_RegressionOutput.encode(
        message.regression,
        writer.uint32(34).fork(),
      ).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSteamLearnInferenceBackendResponse_Output {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSteamLearnInferenceBackendResponse_Output();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.binaryCrossentropy = CMsgSteamLearnInferenceBackendResponse_BinaryCrossEntropyOutput.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.categoricalCrossentropy = CMsgSteamLearnInferenceBackendResponse_CategoricalCrossEntropyOutput.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.multiBinaryCrossentropy = CMsgSteamLearnInferenceBackendResponse_MutliBinaryCrossEntropyOutput.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.regression = CMsgSteamLearnInferenceBackendResponse_RegressionOutput.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSteamLearnInferenceBackendResponse_Output {
    return {
      binaryCrossentropy: isSet(object.binaryCrossentropy)
        ? CMsgSteamLearnInferenceBackendResponse_BinaryCrossEntropyOutput.fromJSON(object.binaryCrossentropy)
        : undefined,
      categoricalCrossentropy: isSet(object.categoricalCrossentropy)
        ? CMsgSteamLearnInferenceBackendResponse_CategoricalCrossEntropyOutput.fromJSON(object.categoricalCrossentropy)
        : undefined,
      multiBinaryCrossentropy: isSet(object.multiBinaryCrossentropy)
        ? CMsgSteamLearnInferenceBackendResponse_MutliBinaryCrossEntropyOutput.fromJSON(object.multiBinaryCrossentropy)
        : undefined,
      regression: isSet(object.regression)
        ? CMsgSteamLearnInferenceBackendResponse_RegressionOutput.fromJSON(object.regression)
        : undefined,
    };
  },

  toJSON(message: CMsgSteamLearnInferenceBackendResponse_Output): unknown {
    const obj: any = {};
    if (message.binaryCrossentropy !== undefined) {
      obj.binaryCrossentropy = CMsgSteamLearnInferenceBackendResponse_BinaryCrossEntropyOutput.toJSON(
        message.binaryCrossentropy,
      );
    }
    if (message.categoricalCrossentropy !== undefined) {
      obj.categoricalCrossentropy = CMsgSteamLearnInferenceBackendResponse_CategoricalCrossEntropyOutput.toJSON(
        message.categoricalCrossentropy,
      );
    }
    if (message.multiBinaryCrossentropy !== undefined) {
      obj.multiBinaryCrossentropy = CMsgSteamLearnInferenceBackendResponse_MutliBinaryCrossEntropyOutput.toJSON(
        message.multiBinaryCrossentropy,
      );
    }
    if (message.regression !== undefined) {
      obj.regression = CMsgSteamLearnInferenceBackendResponse_RegressionOutput.toJSON(message.regression);
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgSteamLearnInferenceBackendResponse_Output>,
  ): CMsgSteamLearnInferenceBackendResponse_Output {
    return CMsgSteamLearnInferenceBackendResponse_Output.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgSteamLearnInferenceBackendResponse_Output>,
  ): CMsgSteamLearnInferenceBackendResponse_Output {
    const message = createBaseCMsgSteamLearnInferenceBackendResponse_Output();
    message.binaryCrossentropy =
      object.binaryCrossentropy !== undefined && object.binaryCrossentropy !== null
        ? CMsgSteamLearnInferenceBackendResponse_BinaryCrossEntropyOutput.fromPartial(object.binaryCrossentropy)
        : undefined;
    message.categoricalCrossentropy =
      object.categoricalCrossentropy !== undefined && object.categoricalCrossentropy !== null
        ? CMsgSteamLearnInferenceBackendResponse_CategoricalCrossEntropyOutput.fromPartial(
            object.categoricalCrossentropy,
          )
        : undefined;
    message.multiBinaryCrossentropy =
      object.multiBinaryCrossentropy !== undefined && object.multiBinaryCrossentropy !== null
        ? CMsgSteamLearnInferenceBackendResponse_MutliBinaryCrossEntropyOutput.fromPartial(
            object.multiBinaryCrossentropy,
          )
        : undefined;
    message.regression =
      object.regression !== undefined && object.regression !== null
        ? CMsgSteamLearnInferenceBackendResponse_RegressionOutput.fromPartial(object.regression)
        : undefined;
    return message;
  },
};

function createBaseCMsgSteamLearnInferenceResponse(): CMsgSteamLearnInferenceResponse {
  return { inferenceResult: 0, backendResponse: undefined, keys: [] };
}

export const CMsgSteamLearnInferenceResponse = {
  encode(message: CMsgSteamLearnInferenceResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.inferenceResult !== undefined && message.inferenceResult !== 0) {
      writer.uint32(8).int32(message.inferenceResult);
    }
    if (message.backendResponse !== undefined) {
      CMsgSteamLearnInferenceBackendResponse.encode(message.backendResponse, writer.uint32(18).fork()).ldelim();
    }
    writer.uint32(26).fork();
    for (const v of message.keys) {
      writer.uint64(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSteamLearnInferenceResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSteamLearnInferenceResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.inferenceResult = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.backendResponse = CMsgSteamLearnInferenceBackendResponse.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag === 24) {
            message.keys.push(longToString(reader.uint64() as Long));

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.keys.push(longToString(reader.uint64() as Long));
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSteamLearnInferenceResponse {
    return {
      inferenceResult: isSet(object.inferenceResult) ? eSteamLearnInferenceResultFromJSON(object.inferenceResult) : 0,
      backendResponse: isSet(object.backendResponse)
        ? CMsgSteamLearnInferenceBackendResponse.fromJSON(object.backendResponse)
        : undefined,
      keys: globalThis.Array.isArray(object?.keys) ? object.keys.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: CMsgSteamLearnInferenceResponse): unknown {
    const obj: any = {};
    if (message.inferenceResult !== undefined && message.inferenceResult !== 0) {
      obj.inferenceResult = eSteamLearnInferenceResultToJSON(message.inferenceResult);
    }
    if (message.backendResponse !== undefined) {
      obj.backendResponse = CMsgSteamLearnInferenceBackendResponse.toJSON(message.backendResponse);
    }
    if (message.keys?.length) {
      obj.keys = message.keys;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSteamLearnInferenceResponse>): CMsgSteamLearnInferenceResponse {
    return CMsgSteamLearnInferenceResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSteamLearnInferenceResponse>): CMsgSteamLearnInferenceResponse {
    const message = createBaseCMsgSteamLearnInferenceResponse();
    message.inferenceResult = object.inferenceResult ?? 0;
    message.backendResponse =
      object.backendResponse !== undefined && object.backendResponse !== null
        ? CMsgSteamLearnInferenceBackendResponse.fromPartial(object.backendResponse)
        : undefined;
    message.keys = object.keys?.map((e) => e) || [];
    return message;
  },
};

export interface SteamLearn {
  RegisterDataSource(
    request: CMsgSteamLearnRegisterDataSourceRequest,
  ): Promise<CMsgSteamLearnRegisterDataSourceResponse>;
  CacheData(request: CMsgSteamLearnCacheDataRequest): Promise<CMsgSteamLearnCacheDataResponse>;
  SnapshotProject(request: CMsgSteamLearnSnapshotProjectRequest): Promise<CMsgSteamLearnSnapshotProjectResponse>;
  BatchOperation(request: CMsgSteamLearnBatchOperationRequest): Promise<CMsgSteamLearnBatchOperationResponse>;
  GetAccessTokens(request: CMsgSteamLearnGetAccessTokensRequest): Promise<CMsgSteamLearnGetAccessTokensResponse>;
  Inference(request: CMsgSteamLearnInferenceRequest): Promise<CMsgSteamLearnInferenceResponse>;
  InferenceMetadata(request: CMsgSteamLearnInferenceMetadataRequest): Promise<CMsgSteamLearnInferenceMetadataResponse>;
}

export const SteamLearnServiceName = "SteamLearn";
export class SteamLearnClientImpl implements SteamLearn {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || SteamLearnServiceName;
    this.rpc = rpc;
    this.RegisterDataSource = this.RegisterDataSource.bind(this);
    this.CacheData = this.CacheData.bind(this);
    this.SnapshotProject = this.SnapshotProject.bind(this);
    this.BatchOperation = this.BatchOperation.bind(this);
    this.GetAccessTokens = this.GetAccessTokens.bind(this);
    this.Inference = this.Inference.bind(this);
    this.InferenceMetadata = this.InferenceMetadata.bind(this);
  }
  RegisterDataSource(
    request: CMsgSteamLearnRegisterDataSourceRequest,
  ): Promise<CMsgSteamLearnRegisterDataSourceResponse> {
    const data = CMsgSteamLearnRegisterDataSourceRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "RegisterDataSource", data);
    return promise.then((data) => CMsgSteamLearnRegisterDataSourceResponse.decode(_m0.Reader.create(data)));
  }

  CacheData(request: CMsgSteamLearnCacheDataRequest): Promise<CMsgSteamLearnCacheDataResponse> {
    const data = CMsgSteamLearnCacheDataRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CacheData", data);
    return promise.then((data) => CMsgSteamLearnCacheDataResponse.decode(_m0.Reader.create(data)));
  }

  SnapshotProject(request: CMsgSteamLearnSnapshotProjectRequest): Promise<CMsgSteamLearnSnapshotProjectResponse> {
    const data = CMsgSteamLearnSnapshotProjectRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "SnapshotProject", data);
    return promise.then((data) => CMsgSteamLearnSnapshotProjectResponse.decode(_m0.Reader.create(data)));
  }

  BatchOperation(request: CMsgSteamLearnBatchOperationRequest): Promise<CMsgSteamLearnBatchOperationResponse> {
    const data = CMsgSteamLearnBatchOperationRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "BatchOperation", data);
    return promise.then((data) => CMsgSteamLearnBatchOperationResponse.decode(_m0.Reader.create(data)));
  }

  GetAccessTokens(request: CMsgSteamLearnGetAccessTokensRequest): Promise<CMsgSteamLearnGetAccessTokensResponse> {
    const data = CMsgSteamLearnGetAccessTokensRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetAccessTokens", data);
    return promise.then((data) => CMsgSteamLearnGetAccessTokensResponse.decode(_m0.Reader.create(data)));
  }

  Inference(request: CMsgSteamLearnInferenceRequest): Promise<CMsgSteamLearnInferenceResponse> {
    const data = CMsgSteamLearnInferenceRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Inference", data);
    return promise.then((data) => CMsgSteamLearnInferenceResponse.decode(_m0.Reader.create(data)));
  }

  InferenceMetadata(request: CMsgSteamLearnInferenceMetadataRequest): Promise<CMsgSteamLearnInferenceMetadataResponse> {
    const data = CMsgSteamLearnInferenceMetadataRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "InferenceMetadata", data);
    return promise.then((data) => CMsgSteamLearnInferenceMetadataResponse.decode(_m0.Reader.create(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin
  ? T
  : T extends globalThis.Array<infer U>
    ? globalThis.Array<DeepPartial<U>>
    : T extends ReadonlyArray<infer U>
      ? ReadonlyArray<DeepPartial<U>>
      : T extends {}
        ? { [K in keyof T]?: DeepPartial<T[K]> }
        : Partial<T>;

function longToString(long: Long) {
  return long.toString();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.176.1
//   protoc               v5.26.1
// source: dota_scenariomessages.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";

export interface CScenarioPosition {
  x?: number | undefined;
  y?: number | undefined;
}

export interface CScenarioGameRoshanSpawner {
  killCount?: number | undefined;
  state?: number | undefined;
  cooldown?: number | undefined;
  killerTeam?: number | undefined;
}

export interface CScenarioEntCourier {
  teamNumber?: number | undefined;
  ownerPlayerId?: number | undefined;
  cooldown?: number | undefined;
}

export interface CScenarioEntNPC {
  position?: CScenarioPosition | undefined;
  unitName?: string | undefined;
  teamNumber?: number | undefined;
  healthFrac?: number | undefined;
  owningCamp?: string | undefined;
  owningCampPosition?: CScenarioPosition | undefined;
  invadeGoal?: string | undefined;
}

export interface CScenarioEntSpiritBear {
  ownerId?: number | undefined;
  teamId?: number | undefined;
}

export interface CScenarioEntDroppedItem {
  position?: CScenarioPosition | undefined;
}

export interface CMsgDotaScenario {
  lobbyId?: string | undefined;
  game?: CMsgDotaScenario_Game | undefined;
  teams: CMsgDotaScenario_Team[];
  heroes: CMsgDotaScenario_Hero[];
  stock: CMsgDotaScenario_Stock[];
  buildings: CMsgDotaScenario_Building[];
  entities: CMsgDotaScenario_Entity[];
  items: CMsgDotaScenario_Item[];
  modifiers: CMsgDotaScenario_Modifier[];
}

export interface CMsgDotaScenario_EntityRef {
  playerId?: number | undefined;
  neutralStashId?: number | undefined;
  entityIdx?: number | undefined;
  roshan?: boolean | undefined;
  abilityName?: string | undefined;
}

export interface CMsgDotaScenario_Game {
  matchId?: string | undefined;
  gameMode?: number | undefined;
  clockTime?: number | undefined;
  internalTime?: number | undefined;
  roshan?: CScenarioGameRoshanSpawner | undefined;
}

export interface CMsgDotaScenario_TeamNeutralItem {
  name?: string | undefined;
  consumed?: boolean | undefined;
  tier?: number | undefined;
}

export interface CMsgDotaScenario_Team {
  teamNumber?: number | undefined;
  neutralItems: CMsgDotaScenario_TeamNeutralItem[];
  heroKills?: number | undefined;
  towerKills?: number | undefined;
  barracksKills?: number | undefined;
  glyphCooldown?: number | undefined;
  radarCooldown?: number | undefined;
}

export interface CMsgDotaScenario_HeroHeroInt {
  playerId?: number | undefined;
  value?: number | undefined;
}

export interface CMsgDotaScenario_HeroHeroFloat {
  playerId?: number | undefined;
  value?: number | undefined;
}

export interface CMsgDotaScenario_DamageStatsByType {
  damageType?: number | undefined;
  receivedPreReduction?: number | undefined;
  receivedPostReduction?: number | undefined;
  outgoingPreReduction?: number | undefined;
  outgoingPostReduction?: number | undefined;
}

export interface CMsgDotaScenario_HeroAbility {
  name?: string | undefined;
  level?: number | undefined;
}

export interface CMsgDotaScenario_Hero {
  steamId?: string | undefined;
  playerId?: number | undefined;
  teamId?: number | undefined;
  hero?: string | undefined;
  totalXp?: number | undefined;
  bkbChargesUsed?: number | undefined;
  aeonChargesUsed?: number | undefined;
  reliableGold?: number | undefined;
  unreliableGold?: number | undefined;
  totalEarnedGold?: number | undefined;
  sharedGold?: number | undefined;
  heroKillGold?: number | undefined;
  creepKillGold?: number | undefined;
  neutralKillGold?: number | undefined;
  courierGold?: number | undefined;
  bountyGold?: number | undefined;
  roshanGold?: number | undefined;
  buildingGold?: number | undefined;
  otherGold?: number | undefined;
  incomeGold?: number | undefined;
  wardKillGold?: number | undefined;
  abilityGold?: number | undefined;
  denies?: number | undefined;
  lastHits?: number | undefined;
  lastHitStreak?: number | undefined;
  lastHitMultikill?: number | undefined;
  nearbyCreepDeathCount?: number | undefined;
  claimedDenyCount?: number | undefined;
  claimedMissCount?: number | undefined;
  missCount?: number | undefined;
  buybackCooldownTime?: number | undefined;
  buybackGoldLimitTime?: number | undefined;
  stunDuration?: number | undefined;
  healing?: number | undefined;
  towerKills?: number | undefined;
  roshanKills?: number | undefined;
  observerWardsPlaced?: number | undefined;
  sentryWardsPlaced?: number | undefined;
  creepsStacked?: number | undefined;
  campsStacked?: number | undefined;
  runePickups?: number | undefined;
  goldSpentOnSupport?: number | undefined;
  heroDamage?: number | undefined;
  wardsPurchased?: number | undefined;
  wardsDestroyed?: number | undefined;
  goldSpentOnConsumables?: number | undefined;
  goldSpentOnItems?: number | undefined;
  goldSpentOnBuybacks?: number | undefined;
  goldLostToDeath?: number | undefined;
  kills?: number | undefined;
  assists?: number | undefined;
  deaths?: number | undefined;
  killStreak?: number | undefined;
  respawnSeconds?: number | undefined;
  lastBuybackTime?: number | undefined;
  firstBloodClaimed?: boolean | undefined;
  firstBloodGiven?: boolean | undefined;
  bountyRunes?: number | undefined;
  outpostsCaptured?: number | undefined;
  position?: CScenarioPosition | undefined;
  enemyKills: CMsgDotaScenario_HeroHeroInt[];
  damageStats: CMsgDotaScenario_DamageStatsByType[];
  abilities: CMsgDotaScenario_HeroAbility[];
  heroFacet?: number | undefined;
}

export interface CMsgDotaScenario_Stock {
  name?: string | undefined;
  teamNumber?: number | undefined;
  playerId?: number | undefined;
  currentStock?: number | undefined;
  cooldown?: number | undefined;
  bonusStock?: number | undefined;
}

export interface CMsgDotaScenario_Building {
  entityName?: string | undefined;
  entityClass?: string | undefined;
  teamId?: number | undefined;
  isDestroyed?: boolean | undefined;
  healthFrac?: number | undefined;
}

export interface CMsgDotaScenario_Entity {
  courier?: CScenarioEntCourier | undefined;
  npc?: CScenarioEntNPC | undefined;
  spiritBear?: CScenarioEntSpiritBear | undefined;
  droppedItem?: CScenarioEntDroppedItem | undefined;
}

export interface CMsgDotaScenario_Item {
  name?: string | undefined;
  location?: CMsgDotaScenario_EntityRef | undefined;
  ownerId?: number | undefined;
  itemSlot?: number | undefined;
  neutralDropTeam?: number | undefined;
  charges?: number | undefined;
  secondaryCharges?: number | undefined;
  lifetime?: number | undefined;
  storedRuneType?: number | undefined;
}

export interface CMsgDotaScenario_Modifier {
  name?: string | undefined;
  parent?: CMsgDotaScenario_EntityRef | undefined;
  caster?: CMsgDotaScenario_EntityRef | undefined;
  ability?: CMsgDotaScenario_EntityRef | undefined;
  duration?: number | undefined;
  lifetimeRemaining?: number | undefined;
  stackCount?: number | undefined;
  createEvenIfExisting?: boolean | undefined;
  createWithoutCaster?: boolean | undefined;
  createWithoutAbility?: boolean | undefined;
  moonshardConsumedBonus?: number | undefined;
  moonshardConsumedBonusNightVision?: number | undefined;
  wardtruesightRange?: number | undefined;
  ultimateScepterConsumedAlchemistBonusAllStats?: number | undefined;
  ultimateScepterConsumedAlchemistBonusHealth?: number | undefined;
  ultimateScepterConsumedAlchemistBonusMana?: number | undefined;
}

function createBaseCScenarioPosition(): CScenarioPosition {
  return { x: 0, y: 0 };
}

export const CScenarioPosition = {
  encode(message: CScenarioPosition, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.x !== undefined && message.x !== 0) {
      writer.uint32(13).float(message.x);
    }
    if (message.y !== undefined && message.y !== 0) {
      writer.uint32(21).float(message.y);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CScenarioPosition {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCScenarioPosition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.x = reader.float();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.y = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CScenarioPosition {
    return {
      x: isSet(object.x) ? globalThis.Number(object.x) : 0,
      y: isSet(object.y) ? globalThis.Number(object.y) : 0,
    };
  },

  toJSON(message: CScenarioPosition): unknown {
    const obj: any = {};
    if (message.x !== undefined && message.x !== 0) {
      obj.x = message.x;
    }
    if (message.y !== undefined && message.y !== 0) {
      obj.y = message.y;
    }
    return obj;
  },

  create(base?: DeepPartial<CScenarioPosition>): CScenarioPosition {
    return CScenarioPosition.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CScenarioPosition>): CScenarioPosition {
    const message = createBaseCScenarioPosition();
    message.x = object.x ?? 0;
    message.y = object.y ?? 0;
    return message;
  },
};

function createBaseCScenarioGameRoshanSpawner(): CScenarioGameRoshanSpawner {
  return { killCount: 0, state: 0, cooldown: 0, killerTeam: 0 };
}

export const CScenarioGameRoshanSpawner = {
  encode(message: CScenarioGameRoshanSpawner, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.killCount !== undefined && message.killCount !== 0) {
      writer.uint32(8).int32(message.killCount);
    }
    if (message.state !== undefined && message.state !== 0) {
      writer.uint32(16).int32(message.state);
    }
    if (message.cooldown !== undefined && message.cooldown !== 0) {
      writer.uint32(29).float(message.cooldown);
    }
    if (message.killerTeam !== undefined && message.killerTeam !== 0) {
      writer.uint32(32).int32(message.killerTeam);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CScenarioGameRoshanSpawner {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCScenarioGameRoshanSpawner();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.killCount = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.state = reader.int32();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.cooldown = reader.float();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.killerTeam = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CScenarioGameRoshanSpawner {
    return {
      killCount: isSet(object.killCount) ? globalThis.Number(object.killCount) : 0,
      state: isSet(object.state) ? globalThis.Number(object.state) : 0,
      cooldown: isSet(object.cooldown) ? globalThis.Number(object.cooldown) : 0,
      killerTeam: isSet(object.killerTeam) ? globalThis.Number(object.killerTeam) : 0,
    };
  },

  toJSON(message: CScenarioGameRoshanSpawner): unknown {
    const obj: any = {};
    if (message.killCount !== undefined && message.killCount !== 0) {
      obj.killCount = Math.round(message.killCount);
    }
    if (message.state !== undefined && message.state !== 0) {
      obj.state = Math.round(message.state);
    }
    if (message.cooldown !== undefined && message.cooldown !== 0) {
      obj.cooldown = message.cooldown;
    }
    if (message.killerTeam !== undefined && message.killerTeam !== 0) {
      obj.killerTeam = Math.round(message.killerTeam);
    }
    return obj;
  },

  create(base?: DeepPartial<CScenarioGameRoshanSpawner>): CScenarioGameRoshanSpawner {
    return CScenarioGameRoshanSpawner.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CScenarioGameRoshanSpawner>): CScenarioGameRoshanSpawner {
    const message = createBaseCScenarioGameRoshanSpawner();
    message.killCount = object.killCount ?? 0;
    message.state = object.state ?? 0;
    message.cooldown = object.cooldown ?? 0;
    message.killerTeam = object.killerTeam ?? 0;
    return message;
  },
};

function createBaseCScenarioEntCourier(): CScenarioEntCourier {
  return { teamNumber: 0, ownerPlayerId: -1, cooldown: -1 };
}

export const CScenarioEntCourier = {
  encode(message: CScenarioEntCourier, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.teamNumber !== undefined && message.teamNumber !== 0) {
      writer.uint32(8).int32(message.teamNumber);
    }
    if (message.ownerPlayerId !== undefined && message.ownerPlayerId !== -1) {
      writer.uint32(16).int32(message.ownerPlayerId);
    }
    if (message.cooldown !== undefined && message.cooldown !== -1) {
      writer.uint32(29).float(message.cooldown);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CScenarioEntCourier {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCScenarioEntCourier();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.teamNumber = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.ownerPlayerId = reader.int32();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.cooldown = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CScenarioEntCourier {
    return {
      teamNumber: isSet(object.teamNumber) ? globalThis.Number(object.teamNumber) : 0,
      ownerPlayerId: isSet(object.ownerPlayerId) ? globalThis.Number(object.ownerPlayerId) : -1,
      cooldown: isSet(object.cooldown) ? globalThis.Number(object.cooldown) : -1,
    };
  },

  toJSON(message: CScenarioEntCourier): unknown {
    const obj: any = {};
    if (message.teamNumber !== undefined && message.teamNumber !== 0) {
      obj.teamNumber = Math.round(message.teamNumber);
    }
    if (message.ownerPlayerId !== undefined && message.ownerPlayerId !== -1) {
      obj.ownerPlayerId = Math.round(message.ownerPlayerId);
    }
    if (message.cooldown !== undefined && message.cooldown !== -1) {
      obj.cooldown = message.cooldown;
    }
    return obj;
  },

  create(base?: DeepPartial<CScenarioEntCourier>): CScenarioEntCourier {
    return CScenarioEntCourier.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CScenarioEntCourier>): CScenarioEntCourier {
    const message = createBaseCScenarioEntCourier();
    message.teamNumber = object.teamNumber ?? 0;
    message.ownerPlayerId = object.ownerPlayerId ?? -1;
    message.cooldown = object.cooldown ?? -1;
    return message;
  },
};

function createBaseCScenarioEntNPC(): CScenarioEntNPC {
  return {
    position: undefined,
    unitName: "",
    teamNumber: 0,
    healthFrac: 1,
    owningCamp: "",
    owningCampPosition: undefined,
    invadeGoal: "",
  };
}

export const CScenarioEntNPC = {
  encode(message: CScenarioEntNPC, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.position !== undefined) {
      CScenarioPosition.encode(message.position, writer.uint32(10).fork()).ldelim();
    }
    if (message.unitName !== undefined && message.unitName !== "") {
      writer.uint32(18).string(message.unitName);
    }
    if (message.teamNumber !== undefined && message.teamNumber !== 0) {
      writer.uint32(24).int32(message.teamNumber);
    }
    if (message.healthFrac !== undefined && message.healthFrac !== 1) {
      writer.uint32(37).float(message.healthFrac);
    }
    if (message.owningCamp !== undefined && message.owningCamp !== "") {
      writer.uint32(82).string(message.owningCamp);
    }
    if (message.owningCampPosition !== undefined) {
      CScenarioPosition.encode(message.owningCampPosition, writer.uint32(90).fork()).ldelim();
    }
    if (message.invadeGoal !== undefined && message.invadeGoal !== "") {
      writer.uint32(162).string(message.invadeGoal);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CScenarioEntNPC {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCScenarioEntNPC();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.position = CScenarioPosition.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.unitName = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.teamNumber = reader.int32();
          continue;
        case 4:
          if (tag !== 37) {
            break;
          }

          message.healthFrac = reader.float();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.owningCamp = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.owningCampPosition = CScenarioPosition.decode(reader, reader.uint32());
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.invadeGoal = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CScenarioEntNPC {
    return {
      position: isSet(object.position) ? CScenarioPosition.fromJSON(object.position) : undefined,
      unitName: isSet(object.unitName) ? globalThis.String(object.unitName) : "",
      teamNumber: isSet(object.teamNumber) ? globalThis.Number(object.teamNumber) : 0,
      healthFrac: isSet(object.healthFrac) ? globalThis.Number(object.healthFrac) : 1,
      owningCamp: isSet(object.owningCamp) ? globalThis.String(object.owningCamp) : "",
      owningCampPosition: isSet(object.owningCampPosition)
        ? CScenarioPosition.fromJSON(object.owningCampPosition)
        : undefined,
      invadeGoal: isSet(object.invadeGoal) ? globalThis.String(object.invadeGoal) : "",
    };
  },

  toJSON(message: CScenarioEntNPC): unknown {
    const obj: any = {};
    if (message.position !== undefined) {
      obj.position = CScenarioPosition.toJSON(message.position);
    }
    if (message.unitName !== undefined && message.unitName !== "") {
      obj.unitName = message.unitName;
    }
    if (message.teamNumber !== undefined && message.teamNumber !== 0) {
      obj.teamNumber = Math.round(message.teamNumber);
    }
    if (message.healthFrac !== undefined && message.healthFrac !== 1) {
      obj.healthFrac = message.healthFrac;
    }
    if (message.owningCamp !== undefined && message.owningCamp !== "") {
      obj.owningCamp = message.owningCamp;
    }
    if (message.owningCampPosition !== undefined) {
      obj.owningCampPosition = CScenarioPosition.toJSON(message.owningCampPosition);
    }
    if (message.invadeGoal !== undefined && message.invadeGoal !== "") {
      obj.invadeGoal = message.invadeGoal;
    }
    return obj;
  },

  create(base?: DeepPartial<CScenarioEntNPC>): CScenarioEntNPC {
    return CScenarioEntNPC.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CScenarioEntNPC>): CScenarioEntNPC {
    const message = createBaseCScenarioEntNPC();
    message.position = (object.position !== undefined && object.position !== null)
      ? CScenarioPosition.fromPartial(object.position)
      : undefined;
    message.unitName = object.unitName ?? "";
    message.teamNumber = object.teamNumber ?? 0;
    message.healthFrac = object.healthFrac ?? 1;
    message.owningCamp = object.owningCamp ?? "";
    message.owningCampPosition = (object.owningCampPosition !== undefined && object.owningCampPosition !== null)
      ? CScenarioPosition.fromPartial(object.owningCampPosition)
      : undefined;
    message.invadeGoal = object.invadeGoal ?? "";
    return message;
  },
};

function createBaseCScenarioEntSpiritBear(): CScenarioEntSpiritBear {
  return { ownerId: -1, teamId: 0 };
}

export const CScenarioEntSpiritBear = {
  encode(message: CScenarioEntSpiritBear, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.ownerId !== undefined && message.ownerId !== -1) {
      writer.uint32(8).int32(message.ownerId);
    }
    if (message.teamId !== undefined && message.teamId !== 0) {
      writer.uint32(16).int32(message.teamId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CScenarioEntSpiritBear {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCScenarioEntSpiritBear();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.ownerId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.teamId = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CScenarioEntSpiritBear {
    return {
      ownerId: isSet(object.ownerId) ? globalThis.Number(object.ownerId) : -1,
      teamId: isSet(object.teamId) ? globalThis.Number(object.teamId) : 0,
    };
  },

  toJSON(message: CScenarioEntSpiritBear): unknown {
    const obj: any = {};
    if (message.ownerId !== undefined && message.ownerId !== -1) {
      obj.ownerId = Math.round(message.ownerId);
    }
    if (message.teamId !== undefined && message.teamId !== 0) {
      obj.teamId = Math.round(message.teamId);
    }
    return obj;
  },

  create(base?: DeepPartial<CScenarioEntSpiritBear>): CScenarioEntSpiritBear {
    return CScenarioEntSpiritBear.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CScenarioEntSpiritBear>): CScenarioEntSpiritBear {
    const message = createBaseCScenarioEntSpiritBear();
    message.ownerId = object.ownerId ?? -1;
    message.teamId = object.teamId ?? 0;
    return message;
  },
};

function createBaseCScenarioEntDroppedItem(): CScenarioEntDroppedItem {
  return { position: undefined };
}

export const CScenarioEntDroppedItem = {
  encode(message: CScenarioEntDroppedItem, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.position !== undefined) {
      CScenarioPosition.encode(message.position, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CScenarioEntDroppedItem {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCScenarioEntDroppedItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.position = CScenarioPosition.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CScenarioEntDroppedItem {
    return { position: isSet(object.position) ? CScenarioPosition.fromJSON(object.position) : undefined };
  },

  toJSON(message: CScenarioEntDroppedItem): unknown {
    const obj: any = {};
    if (message.position !== undefined) {
      obj.position = CScenarioPosition.toJSON(message.position);
    }
    return obj;
  },

  create(base?: DeepPartial<CScenarioEntDroppedItem>): CScenarioEntDroppedItem {
    return CScenarioEntDroppedItem.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CScenarioEntDroppedItem>): CScenarioEntDroppedItem {
    const message = createBaseCScenarioEntDroppedItem();
    message.position = (object.position !== undefined && object.position !== null)
      ? CScenarioPosition.fromPartial(object.position)
      : undefined;
    return message;
  },
};

function createBaseCMsgDotaScenario(): CMsgDotaScenario {
  return {
    lobbyId: "0",
    game: undefined,
    teams: [],
    heroes: [],
    stock: [],
    buildings: [],
    entities: [],
    items: [],
    modifiers: [],
  };
}

export const CMsgDotaScenario = {
  encode(message: CMsgDotaScenario, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.lobbyId !== undefined && message.lobbyId !== "0") {
      writer.uint32(8).uint64(message.lobbyId);
    }
    if (message.game !== undefined) {
      CMsgDotaScenario_Game.encode(message.game, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.teams) {
      CMsgDotaScenario_Team.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    for (const v of message.heroes) {
      CMsgDotaScenario_Hero.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    for (const v of message.stock) {
      CMsgDotaScenario_Stock.encode(v!, writer.uint32(42).fork()).ldelim();
    }
    for (const v of message.buildings) {
      CMsgDotaScenario_Building.encode(v!, writer.uint32(50).fork()).ldelim();
    }
    for (const v of message.entities) {
      CMsgDotaScenario_Entity.encode(v!, writer.uint32(58).fork()).ldelim();
    }
    for (const v of message.items) {
      CMsgDotaScenario_Item.encode(v!, writer.uint32(66).fork()).ldelim();
    }
    for (const v of message.modifiers) {
      CMsgDotaScenario_Modifier.encode(v!, writer.uint32(74).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDotaScenario {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDotaScenario();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.lobbyId = longToString(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.game = CMsgDotaScenario_Game.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.teams.push(CMsgDotaScenario_Team.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.heroes.push(CMsgDotaScenario_Hero.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.stock.push(CMsgDotaScenario_Stock.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.buildings.push(CMsgDotaScenario_Building.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.entities.push(CMsgDotaScenario_Entity.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.items.push(CMsgDotaScenario_Item.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.modifiers.push(CMsgDotaScenario_Modifier.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDotaScenario {
    return {
      lobbyId: isSet(object.lobbyId) ? globalThis.String(object.lobbyId) : "0",
      game: isSet(object.game) ? CMsgDotaScenario_Game.fromJSON(object.game) : undefined,
      teams: globalThis.Array.isArray(object?.teams)
        ? object.teams.map((e: any) => CMsgDotaScenario_Team.fromJSON(e))
        : [],
      heroes: globalThis.Array.isArray(object?.heroes)
        ? object.heroes.map((e: any) => CMsgDotaScenario_Hero.fromJSON(e))
        : [],
      stock: globalThis.Array.isArray(object?.stock)
        ? object.stock.map((e: any) => CMsgDotaScenario_Stock.fromJSON(e))
        : [],
      buildings: globalThis.Array.isArray(object?.buildings)
        ? object.buildings.map((e: any) => CMsgDotaScenario_Building.fromJSON(e))
        : [],
      entities: globalThis.Array.isArray(object?.entities)
        ? object.entities.map((e: any) => CMsgDotaScenario_Entity.fromJSON(e))
        : [],
      items: globalThis.Array.isArray(object?.items)
        ? object.items.map((e: any) => CMsgDotaScenario_Item.fromJSON(e))
        : [],
      modifiers: globalThis.Array.isArray(object?.modifiers)
        ? object.modifiers.map((e: any) => CMsgDotaScenario_Modifier.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgDotaScenario): unknown {
    const obj: any = {};
    if (message.lobbyId !== undefined && message.lobbyId !== "0") {
      obj.lobbyId = message.lobbyId;
    }
    if (message.game !== undefined) {
      obj.game = CMsgDotaScenario_Game.toJSON(message.game);
    }
    if (message.teams?.length) {
      obj.teams = message.teams.map((e) => CMsgDotaScenario_Team.toJSON(e));
    }
    if (message.heroes?.length) {
      obj.heroes = message.heroes.map((e) => CMsgDotaScenario_Hero.toJSON(e));
    }
    if (message.stock?.length) {
      obj.stock = message.stock.map((e) => CMsgDotaScenario_Stock.toJSON(e));
    }
    if (message.buildings?.length) {
      obj.buildings = message.buildings.map((e) => CMsgDotaScenario_Building.toJSON(e));
    }
    if (message.entities?.length) {
      obj.entities = message.entities.map((e) => CMsgDotaScenario_Entity.toJSON(e));
    }
    if (message.items?.length) {
      obj.items = message.items.map((e) => CMsgDotaScenario_Item.toJSON(e));
    }
    if (message.modifiers?.length) {
      obj.modifiers = message.modifiers.map((e) => CMsgDotaScenario_Modifier.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDotaScenario>): CMsgDotaScenario {
    return CMsgDotaScenario.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDotaScenario>): CMsgDotaScenario {
    const message = createBaseCMsgDotaScenario();
    message.lobbyId = object.lobbyId ?? "0";
    message.game = (object.game !== undefined && object.game !== null)
      ? CMsgDotaScenario_Game.fromPartial(object.game)
      : undefined;
    message.teams = object.teams?.map((e) => CMsgDotaScenario_Team.fromPartial(e)) || [];
    message.heroes = object.heroes?.map((e) => CMsgDotaScenario_Hero.fromPartial(e)) || [];
    message.stock = object.stock?.map((e) => CMsgDotaScenario_Stock.fromPartial(e)) || [];
    message.buildings = object.buildings?.map((e) => CMsgDotaScenario_Building.fromPartial(e)) || [];
    message.entities = object.entities?.map((e) => CMsgDotaScenario_Entity.fromPartial(e)) || [];
    message.items = object.items?.map((e) => CMsgDotaScenario_Item.fromPartial(e)) || [];
    message.modifiers = object.modifiers?.map((e) => CMsgDotaScenario_Modifier.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgDotaScenario_EntityRef(): CMsgDotaScenario_EntityRef {
  return { playerId: -1, neutralStashId: -1, entityIdx: -1, roshan: false, abilityName: "" };
}

export const CMsgDotaScenario_EntityRef = {
  encode(message: CMsgDotaScenario_EntityRef, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.playerId !== undefined && message.playerId !== -1) {
      writer.uint32(8).int32(message.playerId);
    }
    if (message.neutralStashId !== undefined && message.neutralStashId !== -1) {
      writer.uint32(16).int32(message.neutralStashId);
    }
    if (message.entityIdx !== undefined && message.entityIdx !== -1) {
      writer.uint32(24).int32(message.entityIdx);
    }
    if (message.roshan !== undefined && message.roshan !== false) {
      writer.uint32(32).bool(message.roshan);
    }
    if (message.abilityName !== undefined && message.abilityName !== "") {
      writer.uint32(82).string(message.abilityName);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDotaScenario_EntityRef {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDotaScenario_EntityRef();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.playerId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.neutralStashId = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.entityIdx = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.roshan = reader.bool();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.abilityName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDotaScenario_EntityRef {
    return {
      playerId: isSet(object.playerId) ? globalThis.Number(object.playerId) : -1,
      neutralStashId: isSet(object.neutralStashId) ? globalThis.Number(object.neutralStashId) : -1,
      entityIdx: isSet(object.entityIdx) ? globalThis.Number(object.entityIdx) : -1,
      roshan: isSet(object.roshan) ? globalThis.Boolean(object.roshan) : false,
      abilityName: isSet(object.abilityName) ? globalThis.String(object.abilityName) : "",
    };
  },

  toJSON(message: CMsgDotaScenario_EntityRef): unknown {
    const obj: any = {};
    if (message.playerId !== undefined && message.playerId !== -1) {
      obj.playerId = Math.round(message.playerId);
    }
    if (message.neutralStashId !== undefined && message.neutralStashId !== -1) {
      obj.neutralStashId = Math.round(message.neutralStashId);
    }
    if (message.entityIdx !== undefined && message.entityIdx !== -1) {
      obj.entityIdx = Math.round(message.entityIdx);
    }
    if (message.roshan !== undefined && message.roshan !== false) {
      obj.roshan = message.roshan;
    }
    if (message.abilityName !== undefined && message.abilityName !== "") {
      obj.abilityName = message.abilityName;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDotaScenario_EntityRef>): CMsgDotaScenario_EntityRef {
    return CMsgDotaScenario_EntityRef.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDotaScenario_EntityRef>): CMsgDotaScenario_EntityRef {
    const message = createBaseCMsgDotaScenario_EntityRef();
    message.playerId = object.playerId ?? -1;
    message.neutralStashId = object.neutralStashId ?? -1;
    message.entityIdx = object.entityIdx ?? -1;
    message.roshan = object.roshan ?? false;
    message.abilityName = object.abilityName ?? "";
    return message;
  },
};

function createBaseCMsgDotaScenario_Game(): CMsgDotaScenario_Game {
  return { matchId: "0", gameMode: 0, clockTime: 0, internalTime: 0, roshan: undefined };
}

export const CMsgDotaScenario_Game = {
  encode(message: CMsgDotaScenario_Game, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.matchId !== undefined && message.matchId !== "0") {
      writer.uint32(8).uint64(message.matchId);
    }
    if (message.gameMode !== undefined && message.gameMode !== 0) {
      writer.uint32(16).int32(message.gameMode);
    }
    if (message.clockTime !== undefined && message.clockTime !== 0) {
      writer.uint32(29).float(message.clockTime);
    }
    if (message.internalTime !== undefined && message.internalTime !== 0) {
      writer.uint32(37).float(message.internalTime);
    }
    if (message.roshan !== undefined) {
      CScenarioGameRoshanSpawner.encode(message.roshan, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDotaScenario_Game {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDotaScenario_Game();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.matchId = longToString(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.gameMode = reader.int32();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.clockTime = reader.float();
          continue;
        case 4:
          if (tag !== 37) {
            break;
          }

          message.internalTime = reader.float();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.roshan = CScenarioGameRoshanSpawner.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDotaScenario_Game {
    return {
      matchId: isSet(object.matchId) ? globalThis.String(object.matchId) : "0",
      gameMode: isSet(object.gameMode) ? globalThis.Number(object.gameMode) : 0,
      clockTime: isSet(object.clockTime) ? globalThis.Number(object.clockTime) : 0,
      internalTime: isSet(object.internalTime) ? globalThis.Number(object.internalTime) : 0,
      roshan: isSet(object.roshan) ? CScenarioGameRoshanSpawner.fromJSON(object.roshan) : undefined,
    };
  },

  toJSON(message: CMsgDotaScenario_Game): unknown {
    const obj: any = {};
    if (message.matchId !== undefined && message.matchId !== "0") {
      obj.matchId = message.matchId;
    }
    if (message.gameMode !== undefined && message.gameMode !== 0) {
      obj.gameMode = Math.round(message.gameMode);
    }
    if (message.clockTime !== undefined && message.clockTime !== 0) {
      obj.clockTime = message.clockTime;
    }
    if (message.internalTime !== undefined && message.internalTime !== 0) {
      obj.internalTime = message.internalTime;
    }
    if (message.roshan !== undefined) {
      obj.roshan = CScenarioGameRoshanSpawner.toJSON(message.roshan);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDotaScenario_Game>): CMsgDotaScenario_Game {
    return CMsgDotaScenario_Game.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDotaScenario_Game>): CMsgDotaScenario_Game {
    const message = createBaseCMsgDotaScenario_Game();
    message.matchId = object.matchId ?? "0";
    message.gameMode = object.gameMode ?? 0;
    message.clockTime = object.clockTime ?? 0;
    message.internalTime = object.internalTime ?? 0;
    message.roshan = (object.roshan !== undefined && object.roshan !== null)
      ? CScenarioGameRoshanSpawner.fromPartial(object.roshan)
      : undefined;
    return message;
  },
};

function createBaseCMsgDotaScenario_TeamNeutralItem(): CMsgDotaScenario_TeamNeutralItem {
  return { name: "", consumed: false, tier: 0 };
}

export const CMsgDotaScenario_TeamNeutralItem = {
  encode(message: CMsgDotaScenario_TeamNeutralItem, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.consumed !== undefined && message.consumed !== false) {
      writer.uint32(16).bool(message.consumed);
    }
    if (message.tier !== undefined && message.tier !== 0) {
      writer.uint32(24).int32(message.tier);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDotaScenario_TeamNeutralItem {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDotaScenario_TeamNeutralItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.consumed = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.tier = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDotaScenario_TeamNeutralItem {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      consumed: isSet(object.consumed) ? globalThis.Boolean(object.consumed) : false,
      tier: isSet(object.tier) ? globalThis.Number(object.tier) : 0,
    };
  },

  toJSON(message: CMsgDotaScenario_TeamNeutralItem): unknown {
    const obj: any = {};
    if (message.name !== undefined && message.name !== "") {
      obj.name = message.name;
    }
    if (message.consumed !== undefined && message.consumed !== false) {
      obj.consumed = message.consumed;
    }
    if (message.tier !== undefined && message.tier !== 0) {
      obj.tier = Math.round(message.tier);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDotaScenario_TeamNeutralItem>): CMsgDotaScenario_TeamNeutralItem {
    return CMsgDotaScenario_TeamNeutralItem.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDotaScenario_TeamNeutralItem>): CMsgDotaScenario_TeamNeutralItem {
    const message = createBaseCMsgDotaScenario_TeamNeutralItem();
    message.name = object.name ?? "";
    message.consumed = object.consumed ?? false;
    message.tier = object.tier ?? 0;
    return message;
  },
};

function createBaseCMsgDotaScenario_Team(): CMsgDotaScenario_Team {
  return {
    teamNumber: 0,
    neutralItems: [],
    heroKills: 0,
    towerKills: 0,
    barracksKills: 0,
    glyphCooldown: 0,
    radarCooldown: 0,
  };
}

export const CMsgDotaScenario_Team = {
  encode(message: CMsgDotaScenario_Team, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.teamNumber !== undefined && message.teamNumber !== 0) {
      writer.uint32(8).int32(message.teamNumber);
    }
    for (const v of message.neutralItems) {
      CMsgDotaScenario_TeamNeutralItem.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.heroKills !== undefined && message.heroKills !== 0) {
      writer.uint32(24).int32(message.heroKills);
    }
    if (message.towerKills !== undefined && message.towerKills !== 0) {
      writer.uint32(32).int32(message.towerKills);
    }
    if (message.barracksKills !== undefined && message.barracksKills !== 0) {
      writer.uint32(40).int32(message.barracksKills);
    }
    if (message.glyphCooldown !== undefined && message.glyphCooldown !== 0) {
      writer.uint32(53).float(message.glyphCooldown);
    }
    if (message.radarCooldown !== undefined && message.radarCooldown !== 0) {
      writer.uint32(61).float(message.radarCooldown);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDotaScenario_Team {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDotaScenario_Team();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.teamNumber = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.neutralItems.push(CMsgDotaScenario_TeamNeutralItem.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.heroKills = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.towerKills = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.barracksKills = reader.int32();
          continue;
        case 6:
          if (tag !== 53) {
            break;
          }

          message.glyphCooldown = reader.float();
          continue;
        case 7:
          if (tag !== 61) {
            break;
          }

          message.radarCooldown = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDotaScenario_Team {
    return {
      teamNumber: isSet(object.teamNumber) ? globalThis.Number(object.teamNumber) : 0,
      neutralItems: globalThis.Array.isArray(object?.neutralItems)
        ? object.neutralItems.map((e: any) => CMsgDotaScenario_TeamNeutralItem.fromJSON(e))
        : [],
      heroKills: isSet(object.heroKills) ? globalThis.Number(object.heroKills) : 0,
      towerKills: isSet(object.towerKills) ? globalThis.Number(object.towerKills) : 0,
      barracksKills: isSet(object.barracksKills) ? globalThis.Number(object.barracksKills) : 0,
      glyphCooldown: isSet(object.glyphCooldown) ? globalThis.Number(object.glyphCooldown) : 0,
      radarCooldown: isSet(object.radarCooldown) ? globalThis.Number(object.radarCooldown) : 0,
    };
  },

  toJSON(message: CMsgDotaScenario_Team): unknown {
    const obj: any = {};
    if (message.teamNumber !== undefined && message.teamNumber !== 0) {
      obj.teamNumber = Math.round(message.teamNumber);
    }
    if (message.neutralItems?.length) {
      obj.neutralItems = message.neutralItems.map((e) => CMsgDotaScenario_TeamNeutralItem.toJSON(e));
    }
    if (message.heroKills !== undefined && message.heroKills !== 0) {
      obj.heroKills = Math.round(message.heroKills);
    }
    if (message.towerKills !== undefined && message.towerKills !== 0) {
      obj.towerKills = Math.round(message.towerKills);
    }
    if (message.barracksKills !== undefined && message.barracksKills !== 0) {
      obj.barracksKills = Math.round(message.barracksKills);
    }
    if (message.glyphCooldown !== undefined && message.glyphCooldown !== 0) {
      obj.glyphCooldown = message.glyphCooldown;
    }
    if (message.radarCooldown !== undefined && message.radarCooldown !== 0) {
      obj.radarCooldown = message.radarCooldown;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDotaScenario_Team>): CMsgDotaScenario_Team {
    return CMsgDotaScenario_Team.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDotaScenario_Team>): CMsgDotaScenario_Team {
    const message = createBaseCMsgDotaScenario_Team();
    message.teamNumber = object.teamNumber ?? 0;
    message.neutralItems = object.neutralItems?.map((e) => CMsgDotaScenario_TeamNeutralItem.fromPartial(e)) || [];
    message.heroKills = object.heroKills ?? 0;
    message.towerKills = object.towerKills ?? 0;
    message.barracksKills = object.barracksKills ?? 0;
    message.glyphCooldown = object.glyphCooldown ?? 0;
    message.radarCooldown = object.radarCooldown ?? 0;
    return message;
  },
};

function createBaseCMsgDotaScenario_HeroHeroInt(): CMsgDotaScenario_HeroHeroInt {
  return { playerId: -1, value: 0 };
}

export const CMsgDotaScenario_HeroHeroInt = {
  encode(message: CMsgDotaScenario_HeroHeroInt, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.playerId !== undefined && message.playerId !== -1) {
      writer.uint32(8).int32(message.playerId);
    }
    if (message.value !== undefined && message.value !== 0) {
      writer.uint32(16).int32(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDotaScenario_HeroHeroInt {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDotaScenario_HeroHeroInt();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.playerId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.value = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDotaScenario_HeroHeroInt {
    return {
      playerId: isSet(object.playerId) ? globalThis.Number(object.playerId) : -1,
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
    };
  },

  toJSON(message: CMsgDotaScenario_HeroHeroInt): unknown {
    const obj: any = {};
    if (message.playerId !== undefined && message.playerId !== -1) {
      obj.playerId = Math.round(message.playerId);
    }
    if (message.value !== undefined && message.value !== 0) {
      obj.value = Math.round(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDotaScenario_HeroHeroInt>): CMsgDotaScenario_HeroHeroInt {
    return CMsgDotaScenario_HeroHeroInt.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDotaScenario_HeroHeroInt>): CMsgDotaScenario_HeroHeroInt {
    const message = createBaseCMsgDotaScenario_HeroHeroInt();
    message.playerId = object.playerId ?? -1;
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseCMsgDotaScenario_HeroHeroFloat(): CMsgDotaScenario_HeroHeroFloat {
  return { playerId: -1, value: 0 };
}

export const CMsgDotaScenario_HeroHeroFloat = {
  encode(message: CMsgDotaScenario_HeroHeroFloat, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.playerId !== undefined && message.playerId !== -1) {
      writer.uint32(8).int32(message.playerId);
    }
    if (message.value !== undefined && message.value !== 0) {
      writer.uint32(21).float(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDotaScenario_HeroHeroFloat {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDotaScenario_HeroHeroFloat();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.playerId = reader.int32();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.value = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDotaScenario_HeroHeroFloat {
    return {
      playerId: isSet(object.playerId) ? globalThis.Number(object.playerId) : -1,
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
    };
  },

  toJSON(message: CMsgDotaScenario_HeroHeroFloat): unknown {
    const obj: any = {};
    if (message.playerId !== undefined && message.playerId !== -1) {
      obj.playerId = Math.round(message.playerId);
    }
    if (message.value !== undefined && message.value !== 0) {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDotaScenario_HeroHeroFloat>): CMsgDotaScenario_HeroHeroFloat {
    return CMsgDotaScenario_HeroHeroFloat.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDotaScenario_HeroHeroFloat>): CMsgDotaScenario_HeroHeroFloat {
    const message = createBaseCMsgDotaScenario_HeroHeroFloat();
    message.playerId = object.playerId ?? -1;
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseCMsgDotaScenario_DamageStatsByType(): CMsgDotaScenario_DamageStatsByType {
  return {
    damageType: 0,
    receivedPreReduction: 0,
    receivedPostReduction: 0,
    outgoingPreReduction: 0,
    outgoingPostReduction: 0,
  };
}

export const CMsgDotaScenario_DamageStatsByType = {
  encode(message: CMsgDotaScenario_DamageStatsByType, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.damageType !== undefined && message.damageType !== 0) {
      writer.uint32(8).int32(message.damageType);
    }
    if (message.receivedPreReduction !== undefined && message.receivedPreReduction !== 0) {
      writer.uint32(16).int32(message.receivedPreReduction);
    }
    if (message.receivedPostReduction !== undefined && message.receivedPostReduction !== 0) {
      writer.uint32(24).int32(message.receivedPostReduction);
    }
    if (message.outgoingPreReduction !== undefined && message.outgoingPreReduction !== 0) {
      writer.uint32(32).int32(message.outgoingPreReduction);
    }
    if (message.outgoingPostReduction !== undefined && message.outgoingPostReduction !== 0) {
      writer.uint32(40).int32(message.outgoingPostReduction);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDotaScenario_DamageStatsByType {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDotaScenario_DamageStatsByType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.damageType = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.receivedPreReduction = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.receivedPostReduction = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.outgoingPreReduction = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.outgoingPostReduction = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDotaScenario_DamageStatsByType {
    return {
      damageType: isSet(object.damageType) ? globalThis.Number(object.damageType) : 0,
      receivedPreReduction: isSet(object.receivedPreReduction) ? globalThis.Number(object.receivedPreReduction) : 0,
      receivedPostReduction: isSet(object.receivedPostReduction) ? globalThis.Number(object.receivedPostReduction) : 0,
      outgoingPreReduction: isSet(object.outgoingPreReduction) ? globalThis.Number(object.outgoingPreReduction) : 0,
      outgoingPostReduction: isSet(object.outgoingPostReduction) ? globalThis.Number(object.outgoingPostReduction) : 0,
    };
  },

  toJSON(message: CMsgDotaScenario_DamageStatsByType): unknown {
    const obj: any = {};
    if (message.damageType !== undefined && message.damageType !== 0) {
      obj.damageType = Math.round(message.damageType);
    }
    if (message.receivedPreReduction !== undefined && message.receivedPreReduction !== 0) {
      obj.receivedPreReduction = Math.round(message.receivedPreReduction);
    }
    if (message.receivedPostReduction !== undefined && message.receivedPostReduction !== 0) {
      obj.receivedPostReduction = Math.round(message.receivedPostReduction);
    }
    if (message.outgoingPreReduction !== undefined && message.outgoingPreReduction !== 0) {
      obj.outgoingPreReduction = Math.round(message.outgoingPreReduction);
    }
    if (message.outgoingPostReduction !== undefined && message.outgoingPostReduction !== 0) {
      obj.outgoingPostReduction = Math.round(message.outgoingPostReduction);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDotaScenario_DamageStatsByType>): CMsgDotaScenario_DamageStatsByType {
    return CMsgDotaScenario_DamageStatsByType.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDotaScenario_DamageStatsByType>): CMsgDotaScenario_DamageStatsByType {
    const message = createBaseCMsgDotaScenario_DamageStatsByType();
    message.damageType = object.damageType ?? 0;
    message.receivedPreReduction = object.receivedPreReduction ?? 0;
    message.receivedPostReduction = object.receivedPostReduction ?? 0;
    message.outgoingPreReduction = object.outgoingPreReduction ?? 0;
    message.outgoingPostReduction = object.outgoingPostReduction ?? 0;
    return message;
  },
};

function createBaseCMsgDotaScenario_HeroAbility(): CMsgDotaScenario_HeroAbility {
  return { name: "", level: 0 };
}

export const CMsgDotaScenario_HeroAbility = {
  encode(message: CMsgDotaScenario_HeroAbility, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.level !== undefined && message.level !== 0) {
      writer.uint32(16).int32(message.level);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDotaScenario_HeroAbility {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDotaScenario_HeroAbility();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.level = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDotaScenario_HeroAbility {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      level: isSet(object.level) ? globalThis.Number(object.level) : 0,
    };
  },

  toJSON(message: CMsgDotaScenario_HeroAbility): unknown {
    const obj: any = {};
    if (message.name !== undefined && message.name !== "") {
      obj.name = message.name;
    }
    if (message.level !== undefined && message.level !== 0) {
      obj.level = Math.round(message.level);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDotaScenario_HeroAbility>): CMsgDotaScenario_HeroAbility {
    return CMsgDotaScenario_HeroAbility.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDotaScenario_HeroAbility>): CMsgDotaScenario_HeroAbility {
    const message = createBaseCMsgDotaScenario_HeroAbility();
    message.name = object.name ?? "";
    message.level = object.level ?? 0;
    return message;
  },
};

function createBaseCMsgDotaScenario_Hero(): CMsgDotaScenario_Hero {
  return {
    steamId: "0",
    playerId: -1,
    teamId: 0,
    hero: "",
    totalXp: 0,
    bkbChargesUsed: 0,
    aeonChargesUsed: 0,
    reliableGold: 0,
    unreliableGold: 0,
    totalEarnedGold: 0,
    sharedGold: 0,
    heroKillGold: 0,
    creepKillGold: 0,
    neutralKillGold: 0,
    courierGold: 0,
    bountyGold: 0,
    roshanGold: 0,
    buildingGold: 0,
    otherGold: 0,
    incomeGold: 0,
    wardKillGold: 0,
    abilityGold: 0,
    denies: 0,
    lastHits: 0,
    lastHitStreak: 0,
    lastHitMultikill: 0,
    nearbyCreepDeathCount: 0,
    claimedDenyCount: 0,
    claimedMissCount: 0,
    missCount: 0,
    buybackCooldownTime: 0,
    buybackGoldLimitTime: 0,
    stunDuration: 0,
    healing: 0,
    towerKills: 0,
    roshanKills: 0,
    observerWardsPlaced: 0,
    sentryWardsPlaced: 0,
    creepsStacked: 0,
    campsStacked: 0,
    runePickups: 0,
    goldSpentOnSupport: 0,
    heroDamage: 0,
    wardsPurchased: 0,
    wardsDestroyed: 0,
    goldSpentOnConsumables: 0,
    goldSpentOnItems: 0,
    goldSpentOnBuybacks: 0,
    goldLostToDeath: 0,
    kills: 0,
    assists: 0,
    deaths: 0,
    killStreak: 0,
    respawnSeconds: -1,
    lastBuybackTime: 0,
    firstBloodClaimed: false,
    firstBloodGiven: false,
    bountyRunes: 0,
    outpostsCaptured: 0,
    position: undefined,
    enemyKills: [],
    damageStats: [],
    abilities: [],
    heroFacet: 0,
  };
}

export const CMsgDotaScenario_Hero = {
  encode(message: CMsgDotaScenario_Hero, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.steamId !== undefined && message.steamId !== "0") {
      writer.uint32(9).fixed64(message.steamId);
    }
    if (message.playerId !== undefined && message.playerId !== -1) {
      writer.uint32(16).int32(message.playerId);
    }
    if (message.teamId !== undefined && message.teamId !== 0) {
      writer.uint32(24).int32(message.teamId);
    }
    if (message.hero !== undefined && message.hero !== "") {
      writer.uint32(34).string(message.hero);
    }
    if (message.totalXp !== undefined && message.totalXp !== 0) {
      writer.uint32(40).int32(message.totalXp);
    }
    if (message.bkbChargesUsed !== undefined && message.bkbChargesUsed !== 0) {
      writer.uint32(48).int32(message.bkbChargesUsed);
    }
    if (message.aeonChargesUsed !== undefined && message.aeonChargesUsed !== 0) {
      writer.uint32(56).int32(message.aeonChargesUsed);
    }
    if (message.reliableGold !== undefined && message.reliableGold !== 0) {
      writer.uint32(64).int32(message.reliableGold);
    }
    if (message.unreliableGold !== undefined && message.unreliableGold !== 0) {
      writer.uint32(72).int32(message.unreliableGold);
    }
    if (message.totalEarnedGold !== undefined && message.totalEarnedGold !== 0) {
      writer.uint32(80).int32(message.totalEarnedGold);
    }
    if (message.sharedGold !== undefined && message.sharedGold !== 0) {
      writer.uint32(88).int32(message.sharedGold);
    }
    if (message.heroKillGold !== undefined && message.heroKillGold !== 0) {
      writer.uint32(96).int32(message.heroKillGold);
    }
    if (message.creepKillGold !== undefined && message.creepKillGold !== 0) {
      writer.uint32(104).int32(message.creepKillGold);
    }
    if (message.neutralKillGold !== undefined && message.neutralKillGold !== 0) {
      writer.uint32(112).int32(message.neutralKillGold);
    }
    if (message.courierGold !== undefined && message.courierGold !== 0) {
      writer.uint32(120).int32(message.courierGold);
    }
    if (message.bountyGold !== undefined && message.bountyGold !== 0) {
      writer.uint32(128).int32(message.bountyGold);
    }
    if (message.roshanGold !== undefined && message.roshanGold !== 0) {
      writer.uint32(136).int32(message.roshanGold);
    }
    if (message.buildingGold !== undefined && message.buildingGold !== 0) {
      writer.uint32(144).int32(message.buildingGold);
    }
    if (message.otherGold !== undefined && message.otherGold !== 0) {
      writer.uint32(152).int32(message.otherGold);
    }
    if (message.incomeGold !== undefined && message.incomeGold !== 0) {
      writer.uint32(208).int32(message.incomeGold);
    }
    if (message.wardKillGold !== undefined && message.wardKillGold !== 0) {
      writer.uint32(216).int32(message.wardKillGold);
    }
    if (message.abilityGold !== undefined && message.abilityGold !== 0) {
      writer.uint32(224).int32(message.abilityGold);
    }
    if (message.denies !== undefined && message.denies !== 0) {
      writer.uint32(232).int32(message.denies);
    }
    if (message.lastHits !== undefined && message.lastHits !== 0) {
      writer.uint32(240).int32(message.lastHits);
    }
    if (message.lastHitStreak !== undefined && message.lastHitStreak !== 0) {
      writer.uint32(248).int32(message.lastHitStreak);
    }
    if (message.lastHitMultikill !== undefined && message.lastHitMultikill !== 0) {
      writer.uint32(256).int32(message.lastHitMultikill);
    }
    if (message.nearbyCreepDeathCount !== undefined && message.nearbyCreepDeathCount !== 0) {
      writer.uint32(264).int32(message.nearbyCreepDeathCount);
    }
    if (message.claimedDenyCount !== undefined && message.claimedDenyCount !== 0) {
      writer.uint32(272).int32(message.claimedDenyCount);
    }
    if (message.claimedMissCount !== undefined && message.claimedMissCount !== 0) {
      writer.uint32(280).int32(message.claimedMissCount);
    }
    if (message.missCount !== undefined && message.missCount !== 0) {
      writer.uint32(288).int32(message.missCount);
    }
    if (message.buybackCooldownTime !== undefined && message.buybackCooldownTime !== 0) {
      writer.uint32(325).float(message.buybackCooldownTime);
    }
    if (message.buybackGoldLimitTime !== undefined && message.buybackGoldLimitTime !== 0) {
      writer.uint32(333).float(message.buybackGoldLimitTime);
    }
    if (message.stunDuration !== undefined && message.stunDuration !== 0) {
      writer.uint32(357).float(message.stunDuration);
    }
    if (message.healing !== undefined && message.healing !== 0) {
      writer.uint32(365).float(message.healing);
    }
    if (message.towerKills !== undefined && message.towerKills !== 0) {
      writer.uint32(368).int32(message.towerKills);
    }
    if (message.roshanKills !== undefined && message.roshanKills !== 0) {
      writer.uint32(376).int32(message.roshanKills);
    }
    if (message.observerWardsPlaced !== undefined && message.observerWardsPlaced !== 0) {
      writer.uint32(384).int32(message.observerWardsPlaced);
    }
    if (message.sentryWardsPlaced !== undefined && message.sentryWardsPlaced !== 0) {
      writer.uint32(392).int32(message.sentryWardsPlaced);
    }
    if (message.creepsStacked !== undefined && message.creepsStacked !== 0) {
      writer.uint32(400).int32(message.creepsStacked);
    }
    if (message.campsStacked !== undefined && message.campsStacked !== 0) {
      writer.uint32(408).int32(message.campsStacked);
    }
    if (message.runePickups !== undefined && message.runePickups !== 0) {
      writer.uint32(416).int32(message.runePickups);
    }
    if (message.goldSpentOnSupport !== undefined && message.goldSpentOnSupport !== 0) {
      writer.uint32(424).int32(message.goldSpentOnSupport);
    }
    if (message.heroDamage !== undefined && message.heroDamage !== 0) {
      writer.uint32(432).int32(message.heroDamage);
    }
    if (message.wardsPurchased !== undefined && message.wardsPurchased !== 0) {
      writer.uint32(440).int32(message.wardsPurchased);
    }
    if (message.wardsDestroyed !== undefined && message.wardsDestroyed !== 0) {
      writer.uint32(448).int32(message.wardsDestroyed);
    }
    if (message.goldSpentOnConsumables !== undefined && message.goldSpentOnConsumables !== 0) {
      writer.uint32(464).int32(message.goldSpentOnConsumables);
    }
    if (message.goldSpentOnItems !== undefined && message.goldSpentOnItems !== 0) {
      writer.uint32(472).int32(message.goldSpentOnItems);
    }
    if (message.goldSpentOnBuybacks !== undefined && message.goldSpentOnBuybacks !== 0) {
      writer.uint32(480).int32(message.goldSpentOnBuybacks);
    }
    if (message.goldLostToDeath !== undefined && message.goldLostToDeath !== 0) {
      writer.uint32(488).int32(message.goldLostToDeath);
    }
    if (message.kills !== undefined && message.kills !== 0) {
      writer.uint32(496).int32(message.kills);
    }
    if (message.assists !== undefined && message.assists !== 0) {
      writer.uint32(504).int32(message.assists);
    }
    if (message.deaths !== undefined && message.deaths !== 0) {
      writer.uint32(512).int32(message.deaths);
    }
    if (message.killStreak !== undefined && message.killStreak !== 0) {
      writer.uint32(520).int32(message.killStreak);
    }
    if (message.respawnSeconds !== undefined && message.respawnSeconds !== -1) {
      writer.uint32(544).int32(message.respawnSeconds);
    }
    if (message.lastBuybackTime !== undefined && message.lastBuybackTime !== 0) {
      writer.uint32(552).int32(message.lastBuybackTime);
    }
    if (message.firstBloodClaimed !== undefined && message.firstBloodClaimed !== false) {
      writer.uint32(568).bool(message.firstBloodClaimed);
    }
    if (message.firstBloodGiven !== undefined && message.firstBloodGiven !== false) {
      writer.uint32(576).bool(message.firstBloodGiven);
    }
    if (message.bountyRunes !== undefined && message.bountyRunes !== 0) {
      writer.uint32(584).int32(message.bountyRunes);
    }
    if (message.outpostsCaptured !== undefined && message.outpostsCaptured !== 0) {
      writer.uint32(592).int32(message.outpostsCaptured);
    }
    if (message.position !== undefined) {
      CScenarioPosition.encode(message.position, writer.uint32(602).fork()).ldelim();
    }
    for (const v of message.enemyKills) {
      CMsgDotaScenario_HeroHeroInt.encode(v!, writer.uint32(1202).fork()).ldelim();
    }
    for (const v of message.damageStats) {
      CMsgDotaScenario_DamageStatsByType.encode(v!, writer.uint32(1210).fork()).ldelim();
    }
    for (const v of message.abilities) {
      CMsgDotaScenario_HeroAbility.encode(v!, writer.uint32(1218).fork()).ldelim();
    }
    if (message.heroFacet !== undefined && message.heroFacet !== 0) {
      writer.uint32(1224).uint32(message.heroFacet);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDotaScenario_Hero {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDotaScenario_Hero();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.steamId = longToString(reader.fixed64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.playerId = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.teamId = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.hero = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.totalXp = reader.int32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.bkbChargesUsed = reader.int32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.aeonChargesUsed = reader.int32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.reliableGold = reader.int32();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.unreliableGold = reader.int32();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.totalEarnedGold = reader.int32();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.sharedGold = reader.int32();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.heroKillGold = reader.int32();
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.creepKillGold = reader.int32();
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.neutralKillGold = reader.int32();
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.courierGold = reader.int32();
          continue;
        case 16:
          if (tag !== 128) {
            break;
          }

          message.bountyGold = reader.int32();
          continue;
        case 17:
          if (tag !== 136) {
            break;
          }

          message.roshanGold = reader.int32();
          continue;
        case 18:
          if (tag !== 144) {
            break;
          }

          message.buildingGold = reader.int32();
          continue;
        case 19:
          if (tag !== 152) {
            break;
          }

          message.otherGold = reader.int32();
          continue;
        case 26:
          if (tag !== 208) {
            break;
          }

          message.incomeGold = reader.int32();
          continue;
        case 27:
          if (tag !== 216) {
            break;
          }

          message.wardKillGold = reader.int32();
          continue;
        case 28:
          if (tag !== 224) {
            break;
          }

          message.abilityGold = reader.int32();
          continue;
        case 29:
          if (tag !== 232) {
            break;
          }

          message.denies = reader.int32();
          continue;
        case 30:
          if (tag !== 240) {
            break;
          }

          message.lastHits = reader.int32();
          continue;
        case 31:
          if (tag !== 248) {
            break;
          }

          message.lastHitStreak = reader.int32();
          continue;
        case 32:
          if (tag !== 256) {
            break;
          }

          message.lastHitMultikill = reader.int32();
          continue;
        case 33:
          if (tag !== 264) {
            break;
          }

          message.nearbyCreepDeathCount = reader.int32();
          continue;
        case 34:
          if (tag !== 272) {
            break;
          }

          message.claimedDenyCount = reader.int32();
          continue;
        case 35:
          if (tag !== 280) {
            break;
          }

          message.claimedMissCount = reader.int32();
          continue;
        case 36:
          if (tag !== 288) {
            break;
          }

          message.missCount = reader.int32();
          continue;
        case 40:
          if (tag !== 325) {
            break;
          }

          message.buybackCooldownTime = reader.float();
          continue;
        case 41:
          if (tag !== 333) {
            break;
          }

          message.buybackGoldLimitTime = reader.float();
          continue;
        case 44:
          if (tag !== 357) {
            break;
          }

          message.stunDuration = reader.float();
          continue;
        case 45:
          if (tag !== 365) {
            break;
          }

          message.healing = reader.float();
          continue;
        case 46:
          if (tag !== 368) {
            break;
          }

          message.towerKills = reader.int32();
          continue;
        case 47:
          if (tag !== 376) {
            break;
          }

          message.roshanKills = reader.int32();
          continue;
        case 48:
          if (tag !== 384) {
            break;
          }

          message.observerWardsPlaced = reader.int32();
          continue;
        case 49:
          if (tag !== 392) {
            break;
          }

          message.sentryWardsPlaced = reader.int32();
          continue;
        case 50:
          if (tag !== 400) {
            break;
          }

          message.creepsStacked = reader.int32();
          continue;
        case 51:
          if (tag !== 408) {
            break;
          }

          message.campsStacked = reader.int32();
          continue;
        case 52:
          if (tag !== 416) {
            break;
          }

          message.runePickups = reader.int32();
          continue;
        case 53:
          if (tag !== 424) {
            break;
          }

          message.goldSpentOnSupport = reader.int32();
          continue;
        case 54:
          if (tag !== 432) {
            break;
          }

          message.heroDamage = reader.int32();
          continue;
        case 55:
          if (tag !== 440) {
            break;
          }

          message.wardsPurchased = reader.int32();
          continue;
        case 56:
          if (tag !== 448) {
            break;
          }

          message.wardsDestroyed = reader.int32();
          continue;
        case 58:
          if (tag !== 464) {
            break;
          }

          message.goldSpentOnConsumables = reader.int32();
          continue;
        case 59:
          if (tag !== 472) {
            break;
          }

          message.goldSpentOnItems = reader.int32();
          continue;
        case 60:
          if (tag !== 480) {
            break;
          }

          message.goldSpentOnBuybacks = reader.int32();
          continue;
        case 61:
          if (tag !== 488) {
            break;
          }

          message.goldLostToDeath = reader.int32();
          continue;
        case 62:
          if (tag !== 496) {
            break;
          }

          message.kills = reader.int32();
          continue;
        case 63:
          if (tag !== 504) {
            break;
          }

          message.assists = reader.int32();
          continue;
        case 64:
          if (tag !== 512) {
            break;
          }

          message.deaths = reader.int32();
          continue;
        case 65:
          if (tag !== 520) {
            break;
          }

          message.killStreak = reader.int32();
          continue;
        case 68:
          if (tag !== 544) {
            break;
          }

          message.respawnSeconds = reader.int32();
          continue;
        case 69:
          if (tag !== 552) {
            break;
          }

          message.lastBuybackTime = reader.int32();
          continue;
        case 71:
          if (tag !== 568) {
            break;
          }

          message.firstBloodClaimed = reader.bool();
          continue;
        case 72:
          if (tag !== 576) {
            break;
          }

          message.firstBloodGiven = reader.bool();
          continue;
        case 73:
          if (tag !== 584) {
            break;
          }

          message.bountyRunes = reader.int32();
          continue;
        case 74:
          if (tag !== 592) {
            break;
          }

          message.outpostsCaptured = reader.int32();
          continue;
        case 75:
          if (tag !== 602) {
            break;
          }

          message.position = CScenarioPosition.decode(reader, reader.uint32());
          continue;
        case 150:
          if (tag !== 1202) {
            break;
          }

          message.enemyKills.push(CMsgDotaScenario_HeroHeroInt.decode(reader, reader.uint32()));
          continue;
        case 151:
          if (tag !== 1210) {
            break;
          }

          message.damageStats.push(CMsgDotaScenario_DamageStatsByType.decode(reader, reader.uint32()));
          continue;
        case 152:
          if (tag !== 1218) {
            break;
          }

          message.abilities.push(CMsgDotaScenario_HeroAbility.decode(reader, reader.uint32()));
          continue;
        case 153:
          if (tag !== 1224) {
            break;
          }

          message.heroFacet = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDotaScenario_Hero {
    return {
      steamId: isSet(object.steamId) ? globalThis.String(object.steamId) : "0",
      playerId: isSet(object.playerId) ? globalThis.Number(object.playerId) : -1,
      teamId: isSet(object.teamId) ? globalThis.Number(object.teamId) : 0,
      hero: isSet(object.hero) ? globalThis.String(object.hero) : "",
      totalXp: isSet(object.totalXp) ? globalThis.Number(object.totalXp) : 0,
      bkbChargesUsed: isSet(object.bkbChargesUsed) ? globalThis.Number(object.bkbChargesUsed) : 0,
      aeonChargesUsed: isSet(object.aeonChargesUsed) ? globalThis.Number(object.aeonChargesUsed) : 0,
      reliableGold: isSet(object.reliableGold) ? globalThis.Number(object.reliableGold) : 0,
      unreliableGold: isSet(object.unreliableGold) ? globalThis.Number(object.unreliableGold) : 0,
      totalEarnedGold: isSet(object.totalEarnedGold) ? globalThis.Number(object.totalEarnedGold) : 0,
      sharedGold: isSet(object.sharedGold) ? globalThis.Number(object.sharedGold) : 0,
      heroKillGold: isSet(object.heroKillGold) ? globalThis.Number(object.heroKillGold) : 0,
      creepKillGold: isSet(object.creepKillGold) ? globalThis.Number(object.creepKillGold) : 0,
      neutralKillGold: isSet(object.neutralKillGold) ? globalThis.Number(object.neutralKillGold) : 0,
      courierGold: isSet(object.courierGold) ? globalThis.Number(object.courierGold) : 0,
      bountyGold: isSet(object.bountyGold) ? globalThis.Number(object.bountyGold) : 0,
      roshanGold: isSet(object.roshanGold) ? globalThis.Number(object.roshanGold) : 0,
      buildingGold: isSet(object.buildingGold) ? globalThis.Number(object.buildingGold) : 0,
      otherGold: isSet(object.otherGold) ? globalThis.Number(object.otherGold) : 0,
      incomeGold: isSet(object.incomeGold) ? globalThis.Number(object.incomeGold) : 0,
      wardKillGold: isSet(object.wardKillGold) ? globalThis.Number(object.wardKillGold) : 0,
      abilityGold: isSet(object.abilityGold) ? globalThis.Number(object.abilityGold) : 0,
      denies: isSet(object.denies) ? globalThis.Number(object.denies) : 0,
      lastHits: isSet(object.lastHits) ? globalThis.Number(object.lastHits) : 0,
      lastHitStreak: isSet(object.lastHitStreak) ? globalThis.Number(object.lastHitStreak) : 0,
      lastHitMultikill: isSet(object.lastHitMultikill) ? globalThis.Number(object.lastHitMultikill) : 0,
      nearbyCreepDeathCount: isSet(object.nearbyCreepDeathCount) ? globalThis.Number(object.nearbyCreepDeathCount) : 0,
      claimedDenyCount: isSet(object.claimedDenyCount) ? globalThis.Number(object.claimedDenyCount) : 0,
      claimedMissCount: isSet(object.claimedMissCount) ? globalThis.Number(object.claimedMissCount) : 0,
      missCount: isSet(object.missCount) ? globalThis.Number(object.missCount) : 0,
      buybackCooldownTime: isSet(object.buybackCooldownTime) ? globalThis.Number(object.buybackCooldownTime) : 0,
      buybackGoldLimitTime: isSet(object.buybackGoldLimitTime) ? globalThis.Number(object.buybackGoldLimitTime) : 0,
      stunDuration: isSet(object.stunDuration) ? globalThis.Number(object.stunDuration) : 0,
      healing: isSet(object.healing) ? globalThis.Number(object.healing) : 0,
      towerKills: isSet(object.towerKills) ? globalThis.Number(object.towerKills) : 0,
      roshanKills: isSet(object.roshanKills) ? globalThis.Number(object.roshanKills) : 0,
      observerWardsPlaced: isSet(object.observerWardsPlaced) ? globalThis.Number(object.observerWardsPlaced) : 0,
      sentryWardsPlaced: isSet(object.sentryWardsPlaced) ? globalThis.Number(object.sentryWardsPlaced) : 0,
      creepsStacked: isSet(object.creepsStacked) ? globalThis.Number(object.creepsStacked) : 0,
      campsStacked: isSet(object.campsStacked) ? globalThis.Number(object.campsStacked) : 0,
      runePickups: isSet(object.runePickups) ? globalThis.Number(object.runePickups) : 0,
      goldSpentOnSupport: isSet(object.goldSpentOnSupport) ? globalThis.Number(object.goldSpentOnSupport) : 0,
      heroDamage: isSet(object.heroDamage) ? globalThis.Number(object.heroDamage) : 0,
      wardsPurchased: isSet(object.wardsPurchased) ? globalThis.Number(object.wardsPurchased) : 0,
      wardsDestroyed: isSet(object.wardsDestroyed) ? globalThis.Number(object.wardsDestroyed) : 0,
      goldSpentOnConsumables: isSet(object.goldSpentOnConsumables)
        ? globalThis.Number(object.goldSpentOnConsumables)
        : 0,
      goldSpentOnItems: isSet(object.goldSpentOnItems) ? globalThis.Number(object.goldSpentOnItems) : 0,
      goldSpentOnBuybacks: isSet(object.goldSpentOnBuybacks) ? globalThis.Number(object.goldSpentOnBuybacks) : 0,
      goldLostToDeath: isSet(object.goldLostToDeath) ? globalThis.Number(object.goldLostToDeath) : 0,
      kills: isSet(object.kills) ? globalThis.Number(object.kills) : 0,
      assists: isSet(object.assists) ? globalThis.Number(object.assists) : 0,
      deaths: isSet(object.deaths) ? globalThis.Number(object.deaths) : 0,
      killStreak: isSet(object.killStreak) ? globalThis.Number(object.killStreak) : 0,
      respawnSeconds: isSet(object.respawnSeconds) ? globalThis.Number(object.respawnSeconds) : -1,
      lastBuybackTime: isSet(object.lastBuybackTime) ? globalThis.Number(object.lastBuybackTime) : 0,
      firstBloodClaimed: isSet(object.firstBloodClaimed) ? globalThis.Boolean(object.firstBloodClaimed) : false,
      firstBloodGiven: isSet(object.firstBloodGiven) ? globalThis.Boolean(object.firstBloodGiven) : false,
      bountyRunes: isSet(object.bountyRunes) ? globalThis.Number(object.bountyRunes) : 0,
      outpostsCaptured: isSet(object.outpostsCaptured) ? globalThis.Number(object.outpostsCaptured) : 0,
      position: isSet(object.position) ? CScenarioPosition.fromJSON(object.position) : undefined,
      enemyKills: globalThis.Array.isArray(object?.enemyKills)
        ? object.enemyKills.map((e: any) => CMsgDotaScenario_HeroHeroInt.fromJSON(e))
        : [],
      damageStats: globalThis.Array.isArray(object?.damageStats)
        ? object.damageStats.map((e: any) => CMsgDotaScenario_DamageStatsByType.fromJSON(e))
        : [],
      abilities: globalThis.Array.isArray(object?.abilities)
        ? object.abilities.map((e: any) => CMsgDotaScenario_HeroAbility.fromJSON(e))
        : [],
      heroFacet: isSet(object.heroFacet) ? globalThis.Number(object.heroFacet) : 0,
    };
  },

  toJSON(message: CMsgDotaScenario_Hero): unknown {
    const obj: any = {};
    if (message.steamId !== undefined && message.steamId !== "0") {
      obj.steamId = message.steamId;
    }
    if (message.playerId !== undefined && message.playerId !== -1) {
      obj.playerId = Math.round(message.playerId);
    }
    if (message.teamId !== undefined && message.teamId !== 0) {
      obj.teamId = Math.round(message.teamId);
    }
    if (message.hero !== undefined && message.hero !== "") {
      obj.hero = message.hero;
    }
    if (message.totalXp !== undefined && message.totalXp !== 0) {
      obj.totalXp = Math.round(message.totalXp);
    }
    if (message.bkbChargesUsed !== undefined && message.bkbChargesUsed !== 0) {
      obj.bkbChargesUsed = Math.round(message.bkbChargesUsed);
    }
    if (message.aeonChargesUsed !== undefined && message.aeonChargesUsed !== 0) {
      obj.aeonChargesUsed = Math.round(message.aeonChargesUsed);
    }
    if (message.reliableGold !== undefined && message.reliableGold !== 0) {
      obj.reliableGold = Math.round(message.reliableGold);
    }
    if (message.unreliableGold !== undefined && message.unreliableGold !== 0) {
      obj.unreliableGold = Math.round(message.unreliableGold);
    }
    if (message.totalEarnedGold !== undefined && message.totalEarnedGold !== 0) {
      obj.totalEarnedGold = Math.round(message.totalEarnedGold);
    }
    if (message.sharedGold !== undefined && message.sharedGold !== 0) {
      obj.sharedGold = Math.round(message.sharedGold);
    }
    if (message.heroKillGold !== undefined && message.heroKillGold !== 0) {
      obj.heroKillGold = Math.round(message.heroKillGold);
    }
    if (message.creepKillGold !== undefined && message.creepKillGold !== 0) {
      obj.creepKillGold = Math.round(message.creepKillGold);
    }
    if (message.neutralKillGold !== undefined && message.neutralKillGold !== 0) {
      obj.neutralKillGold = Math.round(message.neutralKillGold);
    }
    if (message.courierGold !== undefined && message.courierGold !== 0) {
      obj.courierGold = Math.round(message.courierGold);
    }
    if (message.bountyGold !== undefined && message.bountyGold !== 0) {
      obj.bountyGold = Math.round(message.bountyGold);
    }
    if (message.roshanGold !== undefined && message.roshanGold !== 0) {
      obj.roshanGold = Math.round(message.roshanGold);
    }
    if (message.buildingGold !== undefined && message.buildingGold !== 0) {
      obj.buildingGold = Math.round(message.buildingGold);
    }
    if (message.otherGold !== undefined && message.otherGold !== 0) {
      obj.otherGold = Math.round(message.otherGold);
    }
    if (message.incomeGold !== undefined && message.incomeGold !== 0) {
      obj.incomeGold = Math.round(message.incomeGold);
    }
    if (message.wardKillGold !== undefined && message.wardKillGold !== 0) {
      obj.wardKillGold = Math.round(message.wardKillGold);
    }
    if (message.abilityGold !== undefined && message.abilityGold !== 0) {
      obj.abilityGold = Math.round(message.abilityGold);
    }
    if (message.denies !== undefined && message.denies !== 0) {
      obj.denies = Math.round(message.denies);
    }
    if (message.lastHits !== undefined && message.lastHits !== 0) {
      obj.lastHits = Math.round(message.lastHits);
    }
    if (message.lastHitStreak !== undefined && message.lastHitStreak !== 0) {
      obj.lastHitStreak = Math.round(message.lastHitStreak);
    }
    if (message.lastHitMultikill !== undefined && message.lastHitMultikill !== 0) {
      obj.lastHitMultikill = Math.round(message.lastHitMultikill);
    }
    if (message.nearbyCreepDeathCount !== undefined && message.nearbyCreepDeathCount !== 0) {
      obj.nearbyCreepDeathCount = Math.round(message.nearbyCreepDeathCount);
    }
    if (message.claimedDenyCount !== undefined && message.claimedDenyCount !== 0) {
      obj.claimedDenyCount = Math.round(message.claimedDenyCount);
    }
    if (message.claimedMissCount !== undefined && message.claimedMissCount !== 0) {
      obj.claimedMissCount = Math.round(message.claimedMissCount);
    }
    if (message.missCount !== undefined && message.missCount !== 0) {
      obj.missCount = Math.round(message.missCount);
    }
    if (message.buybackCooldownTime !== undefined && message.buybackCooldownTime !== 0) {
      obj.buybackCooldownTime = message.buybackCooldownTime;
    }
    if (message.buybackGoldLimitTime !== undefined && message.buybackGoldLimitTime !== 0) {
      obj.buybackGoldLimitTime = message.buybackGoldLimitTime;
    }
    if (message.stunDuration !== undefined && message.stunDuration !== 0) {
      obj.stunDuration = message.stunDuration;
    }
    if (message.healing !== undefined && message.healing !== 0) {
      obj.healing = message.healing;
    }
    if (message.towerKills !== undefined && message.towerKills !== 0) {
      obj.towerKills = Math.round(message.towerKills);
    }
    if (message.roshanKills !== undefined && message.roshanKills !== 0) {
      obj.roshanKills = Math.round(message.roshanKills);
    }
    if (message.observerWardsPlaced !== undefined && message.observerWardsPlaced !== 0) {
      obj.observerWardsPlaced = Math.round(message.observerWardsPlaced);
    }
    if (message.sentryWardsPlaced !== undefined && message.sentryWardsPlaced !== 0) {
      obj.sentryWardsPlaced = Math.round(message.sentryWardsPlaced);
    }
    if (message.creepsStacked !== undefined && message.creepsStacked !== 0) {
      obj.creepsStacked = Math.round(message.creepsStacked);
    }
    if (message.campsStacked !== undefined && message.campsStacked !== 0) {
      obj.campsStacked = Math.round(message.campsStacked);
    }
    if (message.runePickups !== undefined && message.runePickups !== 0) {
      obj.runePickups = Math.round(message.runePickups);
    }
    if (message.goldSpentOnSupport !== undefined && message.goldSpentOnSupport !== 0) {
      obj.goldSpentOnSupport = Math.round(message.goldSpentOnSupport);
    }
    if (message.heroDamage !== undefined && message.heroDamage !== 0) {
      obj.heroDamage = Math.round(message.heroDamage);
    }
    if (message.wardsPurchased !== undefined && message.wardsPurchased !== 0) {
      obj.wardsPurchased = Math.round(message.wardsPurchased);
    }
    if (message.wardsDestroyed !== undefined && message.wardsDestroyed !== 0) {
      obj.wardsDestroyed = Math.round(message.wardsDestroyed);
    }
    if (message.goldSpentOnConsumables !== undefined && message.goldSpentOnConsumables !== 0) {
      obj.goldSpentOnConsumables = Math.round(message.goldSpentOnConsumables);
    }
    if (message.goldSpentOnItems !== undefined && message.goldSpentOnItems !== 0) {
      obj.goldSpentOnItems = Math.round(message.goldSpentOnItems);
    }
    if (message.goldSpentOnBuybacks !== undefined && message.goldSpentOnBuybacks !== 0) {
      obj.goldSpentOnBuybacks = Math.round(message.goldSpentOnBuybacks);
    }
    if (message.goldLostToDeath !== undefined && message.goldLostToDeath !== 0) {
      obj.goldLostToDeath = Math.round(message.goldLostToDeath);
    }
    if (message.kills !== undefined && message.kills !== 0) {
      obj.kills = Math.round(message.kills);
    }
    if (message.assists !== undefined && message.assists !== 0) {
      obj.assists = Math.round(message.assists);
    }
    if (message.deaths !== undefined && message.deaths !== 0) {
      obj.deaths = Math.round(message.deaths);
    }
    if (message.killStreak !== undefined && message.killStreak !== 0) {
      obj.killStreak = Math.round(message.killStreak);
    }
    if (message.respawnSeconds !== undefined && message.respawnSeconds !== -1) {
      obj.respawnSeconds = Math.round(message.respawnSeconds);
    }
    if (message.lastBuybackTime !== undefined && message.lastBuybackTime !== 0) {
      obj.lastBuybackTime = Math.round(message.lastBuybackTime);
    }
    if (message.firstBloodClaimed !== undefined && message.firstBloodClaimed !== false) {
      obj.firstBloodClaimed = message.firstBloodClaimed;
    }
    if (message.firstBloodGiven !== undefined && message.firstBloodGiven !== false) {
      obj.firstBloodGiven = message.firstBloodGiven;
    }
    if (message.bountyRunes !== undefined && message.bountyRunes !== 0) {
      obj.bountyRunes = Math.round(message.bountyRunes);
    }
    if (message.outpostsCaptured !== undefined && message.outpostsCaptured !== 0) {
      obj.outpostsCaptured = Math.round(message.outpostsCaptured);
    }
    if (message.position !== undefined) {
      obj.position = CScenarioPosition.toJSON(message.position);
    }
    if (message.enemyKills?.length) {
      obj.enemyKills = message.enemyKills.map((e) => CMsgDotaScenario_HeroHeroInt.toJSON(e));
    }
    if (message.damageStats?.length) {
      obj.damageStats = message.damageStats.map((e) => CMsgDotaScenario_DamageStatsByType.toJSON(e));
    }
    if (message.abilities?.length) {
      obj.abilities = message.abilities.map((e) => CMsgDotaScenario_HeroAbility.toJSON(e));
    }
    if (message.heroFacet !== undefined && message.heroFacet !== 0) {
      obj.heroFacet = Math.round(message.heroFacet);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDotaScenario_Hero>): CMsgDotaScenario_Hero {
    return CMsgDotaScenario_Hero.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDotaScenario_Hero>): CMsgDotaScenario_Hero {
    const message = createBaseCMsgDotaScenario_Hero();
    message.steamId = object.steamId ?? "0";
    message.playerId = object.playerId ?? -1;
    message.teamId = object.teamId ?? 0;
    message.hero = object.hero ?? "";
    message.totalXp = object.totalXp ?? 0;
    message.bkbChargesUsed = object.bkbChargesUsed ?? 0;
    message.aeonChargesUsed = object.aeonChargesUsed ?? 0;
    message.reliableGold = object.reliableGold ?? 0;
    message.unreliableGold = object.unreliableGold ?? 0;
    message.totalEarnedGold = object.totalEarnedGold ?? 0;
    message.sharedGold = object.sharedGold ?? 0;
    message.heroKillGold = object.heroKillGold ?? 0;
    message.creepKillGold = object.creepKillGold ?? 0;
    message.neutralKillGold = object.neutralKillGold ?? 0;
    message.courierGold = object.courierGold ?? 0;
    message.bountyGold = object.bountyGold ?? 0;
    message.roshanGold = object.roshanGold ?? 0;
    message.buildingGold = object.buildingGold ?? 0;
    message.otherGold = object.otherGold ?? 0;
    message.incomeGold = object.incomeGold ?? 0;
    message.wardKillGold = object.wardKillGold ?? 0;
    message.abilityGold = object.abilityGold ?? 0;
    message.denies = object.denies ?? 0;
    message.lastHits = object.lastHits ?? 0;
    message.lastHitStreak = object.lastHitStreak ?? 0;
    message.lastHitMultikill = object.lastHitMultikill ?? 0;
    message.nearbyCreepDeathCount = object.nearbyCreepDeathCount ?? 0;
    message.claimedDenyCount = object.claimedDenyCount ?? 0;
    message.claimedMissCount = object.claimedMissCount ?? 0;
    message.missCount = object.missCount ?? 0;
    message.buybackCooldownTime = object.buybackCooldownTime ?? 0;
    message.buybackGoldLimitTime = object.buybackGoldLimitTime ?? 0;
    message.stunDuration = object.stunDuration ?? 0;
    message.healing = object.healing ?? 0;
    message.towerKills = object.towerKills ?? 0;
    message.roshanKills = object.roshanKills ?? 0;
    message.observerWardsPlaced = object.observerWardsPlaced ?? 0;
    message.sentryWardsPlaced = object.sentryWardsPlaced ?? 0;
    message.creepsStacked = object.creepsStacked ?? 0;
    message.campsStacked = object.campsStacked ?? 0;
    message.runePickups = object.runePickups ?? 0;
    message.goldSpentOnSupport = object.goldSpentOnSupport ?? 0;
    message.heroDamage = object.heroDamage ?? 0;
    message.wardsPurchased = object.wardsPurchased ?? 0;
    message.wardsDestroyed = object.wardsDestroyed ?? 0;
    message.goldSpentOnConsumables = object.goldSpentOnConsumables ?? 0;
    message.goldSpentOnItems = object.goldSpentOnItems ?? 0;
    message.goldSpentOnBuybacks = object.goldSpentOnBuybacks ?? 0;
    message.goldLostToDeath = object.goldLostToDeath ?? 0;
    message.kills = object.kills ?? 0;
    message.assists = object.assists ?? 0;
    message.deaths = object.deaths ?? 0;
    message.killStreak = object.killStreak ?? 0;
    message.respawnSeconds = object.respawnSeconds ?? -1;
    message.lastBuybackTime = object.lastBuybackTime ?? 0;
    message.firstBloodClaimed = object.firstBloodClaimed ?? false;
    message.firstBloodGiven = object.firstBloodGiven ?? false;
    message.bountyRunes = object.bountyRunes ?? 0;
    message.outpostsCaptured = object.outpostsCaptured ?? 0;
    message.position = (object.position !== undefined && object.position !== null)
      ? CScenarioPosition.fromPartial(object.position)
      : undefined;
    message.enemyKills = object.enemyKills?.map((e) => CMsgDotaScenario_HeroHeroInt.fromPartial(e)) || [];
    message.damageStats = object.damageStats?.map((e) => CMsgDotaScenario_DamageStatsByType.fromPartial(e)) || [];
    message.abilities = object.abilities?.map((e) => CMsgDotaScenario_HeroAbility.fromPartial(e)) || [];
    message.heroFacet = object.heroFacet ?? 0;
    return message;
  },
};

function createBaseCMsgDotaScenario_Stock(): CMsgDotaScenario_Stock {
  return { name: "", teamNumber: -1, playerId: -1, currentStock: 0, cooldown: 0, bonusStock: 0 };
}

export const CMsgDotaScenario_Stock = {
  encode(message: CMsgDotaScenario_Stock, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.teamNumber !== undefined && message.teamNumber !== -1) {
      writer.uint32(16).int32(message.teamNumber);
    }
    if (message.playerId !== undefined && message.playerId !== -1) {
      writer.uint32(24).int32(message.playerId);
    }
    if (message.currentStock !== undefined && message.currentStock !== 0) {
      writer.uint32(32).int32(message.currentStock);
    }
    if (message.cooldown !== undefined && message.cooldown !== 0) {
      writer.uint32(45).float(message.cooldown);
    }
    if (message.bonusStock !== undefined && message.bonusStock !== 0) {
      writer.uint32(48).int32(message.bonusStock);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDotaScenario_Stock {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDotaScenario_Stock();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.teamNumber = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.playerId = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.currentStock = reader.int32();
          continue;
        case 5:
          if (tag !== 45) {
            break;
          }

          message.cooldown = reader.float();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.bonusStock = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDotaScenario_Stock {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      teamNumber: isSet(object.teamNumber) ? globalThis.Number(object.teamNumber) : -1,
      playerId: isSet(object.playerId) ? globalThis.Number(object.playerId) : -1,
      currentStock: isSet(object.currentStock) ? globalThis.Number(object.currentStock) : 0,
      cooldown: isSet(object.cooldown) ? globalThis.Number(object.cooldown) : 0,
      bonusStock: isSet(object.bonusStock) ? globalThis.Number(object.bonusStock) : 0,
    };
  },

  toJSON(message: CMsgDotaScenario_Stock): unknown {
    const obj: any = {};
    if (message.name !== undefined && message.name !== "") {
      obj.name = message.name;
    }
    if (message.teamNumber !== undefined && message.teamNumber !== -1) {
      obj.teamNumber = Math.round(message.teamNumber);
    }
    if (message.playerId !== undefined && message.playerId !== -1) {
      obj.playerId = Math.round(message.playerId);
    }
    if (message.currentStock !== undefined && message.currentStock !== 0) {
      obj.currentStock = Math.round(message.currentStock);
    }
    if (message.cooldown !== undefined && message.cooldown !== 0) {
      obj.cooldown = message.cooldown;
    }
    if (message.bonusStock !== undefined && message.bonusStock !== 0) {
      obj.bonusStock = Math.round(message.bonusStock);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDotaScenario_Stock>): CMsgDotaScenario_Stock {
    return CMsgDotaScenario_Stock.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDotaScenario_Stock>): CMsgDotaScenario_Stock {
    const message = createBaseCMsgDotaScenario_Stock();
    message.name = object.name ?? "";
    message.teamNumber = object.teamNumber ?? -1;
    message.playerId = object.playerId ?? -1;
    message.currentStock = object.currentStock ?? 0;
    message.cooldown = object.cooldown ?? 0;
    message.bonusStock = object.bonusStock ?? 0;
    return message;
  },
};

function createBaseCMsgDotaScenario_Building(): CMsgDotaScenario_Building {
  return { entityName: "", entityClass: "", teamId: 0, isDestroyed: false, healthFrac: 1 };
}

export const CMsgDotaScenario_Building = {
  encode(message: CMsgDotaScenario_Building, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.entityName !== undefined && message.entityName !== "") {
      writer.uint32(10).string(message.entityName);
    }
    if (message.entityClass !== undefined && message.entityClass !== "") {
      writer.uint32(18).string(message.entityClass);
    }
    if (message.teamId !== undefined && message.teamId !== 0) {
      writer.uint32(24).int32(message.teamId);
    }
    if (message.isDestroyed !== undefined && message.isDestroyed !== false) {
      writer.uint32(32).bool(message.isDestroyed);
    }
    if (message.healthFrac !== undefined && message.healthFrac !== 1) {
      writer.uint32(45).float(message.healthFrac);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDotaScenario_Building {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDotaScenario_Building();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.entityName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.entityClass = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.teamId = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.isDestroyed = reader.bool();
          continue;
        case 5:
          if (tag !== 45) {
            break;
          }

          message.healthFrac = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDotaScenario_Building {
    return {
      entityName: isSet(object.entityName) ? globalThis.String(object.entityName) : "",
      entityClass: isSet(object.entityClass) ? globalThis.String(object.entityClass) : "",
      teamId: isSet(object.teamId) ? globalThis.Number(object.teamId) : 0,
      isDestroyed: isSet(object.isDestroyed) ? globalThis.Boolean(object.isDestroyed) : false,
      healthFrac: isSet(object.healthFrac) ? globalThis.Number(object.healthFrac) : 1,
    };
  },

  toJSON(message: CMsgDotaScenario_Building): unknown {
    const obj: any = {};
    if (message.entityName !== undefined && message.entityName !== "") {
      obj.entityName = message.entityName;
    }
    if (message.entityClass !== undefined && message.entityClass !== "") {
      obj.entityClass = message.entityClass;
    }
    if (message.teamId !== undefined && message.teamId !== 0) {
      obj.teamId = Math.round(message.teamId);
    }
    if (message.isDestroyed !== undefined && message.isDestroyed !== false) {
      obj.isDestroyed = message.isDestroyed;
    }
    if (message.healthFrac !== undefined && message.healthFrac !== 1) {
      obj.healthFrac = message.healthFrac;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDotaScenario_Building>): CMsgDotaScenario_Building {
    return CMsgDotaScenario_Building.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDotaScenario_Building>): CMsgDotaScenario_Building {
    const message = createBaseCMsgDotaScenario_Building();
    message.entityName = object.entityName ?? "";
    message.entityClass = object.entityClass ?? "";
    message.teamId = object.teamId ?? 0;
    message.isDestroyed = object.isDestroyed ?? false;
    message.healthFrac = object.healthFrac ?? 1;
    return message;
  },
};

function createBaseCMsgDotaScenario_Entity(): CMsgDotaScenario_Entity {
  return { courier: undefined, npc: undefined, spiritBear: undefined, droppedItem: undefined };
}

export const CMsgDotaScenario_Entity = {
  encode(message: CMsgDotaScenario_Entity, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.courier !== undefined) {
      CScenarioEntCourier.encode(message.courier, writer.uint32(10).fork()).ldelim();
    }
    if (message.npc !== undefined) {
      CScenarioEntNPC.encode(message.npc, writer.uint32(18).fork()).ldelim();
    }
    if (message.spiritBear !== undefined) {
      CScenarioEntSpiritBear.encode(message.spiritBear, writer.uint32(26).fork()).ldelim();
    }
    if (message.droppedItem !== undefined) {
      CScenarioEntDroppedItem.encode(message.droppedItem, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDotaScenario_Entity {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDotaScenario_Entity();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.courier = CScenarioEntCourier.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.npc = CScenarioEntNPC.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.spiritBear = CScenarioEntSpiritBear.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.droppedItem = CScenarioEntDroppedItem.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDotaScenario_Entity {
    return {
      courier: isSet(object.courier) ? CScenarioEntCourier.fromJSON(object.courier) : undefined,
      npc: isSet(object.npc) ? CScenarioEntNPC.fromJSON(object.npc) : undefined,
      spiritBear: isSet(object.spiritBear) ? CScenarioEntSpiritBear.fromJSON(object.spiritBear) : undefined,
      droppedItem: isSet(object.droppedItem) ? CScenarioEntDroppedItem.fromJSON(object.droppedItem) : undefined,
    };
  },

  toJSON(message: CMsgDotaScenario_Entity): unknown {
    const obj: any = {};
    if (message.courier !== undefined) {
      obj.courier = CScenarioEntCourier.toJSON(message.courier);
    }
    if (message.npc !== undefined) {
      obj.npc = CScenarioEntNPC.toJSON(message.npc);
    }
    if (message.spiritBear !== undefined) {
      obj.spiritBear = CScenarioEntSpiritBear.toJSON(message.spiritBear);
    }
    if (message.droppedItem !== undefined) {
      obj.droppedItem = CScenarioEntDroppedItem.toJSON(message.droppedItem);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDotaScenario_Entity>): CMsgDotaScenario_Entity {
    return CMsgDotaScenario_Entity.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDotaScenario_Entity>): CMsgDotaScenario_Entity {
    const message = createBaseCMsgDotaScenario_Entity();
    message.courier = (object.courier !== undefined && object.courier !== null)
      ? CScenarioEntCourier.fromPartial(object.courier)
      : undefined;
    message.npc = (object.npc !== undefined && object.npc !== null)
      ? CScenarioEntNPC.fromPartial(object.npc)
      : undefined;
    message.spiritBear = (object.spiritBear !== undefined && object.spiritBear !== null)
      ? CScenarioEntSpiritBear.fromPartial(object.spiritBear)
      : undefined;
    message.droppedItem = (object.droppedItem !== undefined && object.droppedItem !== null)
      ? CScenarioEntDroppedItem.fromPartial(object.droppedItem)
      : undefined;
    return message;
  },
};

function createBaseCMsgDotaScenario_Item(): CMsgDotaScenario_Item {
  return {
    name: "",
    location: undefined,
    ownerId: -1,
    itemSlot: 0,
    neutralDropTeam: 0,
    charges: 0,
    secondaryCharges: 0,
    lifetime: -1,
    storedRuneType: -1,
  };
}

export const CMsgDotaScenario_Item = {
  encode(message: CMsgDotaScenario_Item, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.location !== undefined) {
      CMsgDotaScenario_EntityRef.encode(message.location, writer.uint32(18).fork()).ldelim();
    }
    if (message.ownerId !== undefined && message.ownerId !== -1) {
      writer.uint32(24).int32(message.ownerId);
    }
    if (message.itemSlot !== undefined && message.itemSlot !== 0) {
      writer.uint32(32).int32(message.itemSlot);
    }
    if (message.neutralDropTeam !== undefined && message.neutralDropTeam !== 0) {
      writer.uint32(40).int32(message.neutralDropTeam);
    }
    if (message.charges !== undefined && message.charges !== 0) {
      writer.uint32(48).int32(message.charges);
    }
    if (message.secondaryCharges !== undefined && message.secondaryCharges !== 0) {
      writer.uint32(56).int32(message.secondaryCharges);
    }
    if (message.lifetime !== undefined && message.lifetime !== -1) {
      writer.uint32(69).float(message.lifetime);
    }
    if (message.storedRuneType !== undefined && message.storedRuneType !== -1) {
      writer.uint32(72).int32(message.storedRuneType);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDotaScenario_Item {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDotaScenario_Item();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.location = CMsgDotaScenario_EntityRef.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.ownerId = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.itemSlot = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.neutralDropTeam = reader.int32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.charges = reader.int32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.secondaryCharges = reader.int32();
          continue;
        case 8:
          if (tag !== 69) {
            break;
          }

          message.lifetime = reader.float();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.storedRuneType = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDotaScenario_Item {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      location: isSet(object.location) ? CMsgDotaScenario_EntityRef.fromJSON(object.location) : undefined,
      ownerId: isSet(object.ownerId) ? globalThis.Number(object.ownerId) : -1,
      itemSlot: isSet(object.itemSlot) ? globalThis.Number(object.itemSlot) : 0,
      neutralDropTeam: isSet(object.neutralDropTeam) ? globalThis.Number(object.neutralDropTeam) : 0,
      charges: isSet(object.charges) ? globalThis.Number(object.charges) : 0,
      secondaryCharges: isSet(object.secondaryCharges) ? globalThis.Number(object.secondaryCharges) : 0,
      lifetime: isSet(object.lifetime) ? globalThis.Number(object.lifetime) : -1,
      storedRuneType: isSet(object.storedRuneType) ? globalThis.Number(object.storedRuneType) : -1,
    };
  },

  toJSON(message: CMsgDotaScenario_Item): unknown {
    const obj: any = {};
    if (message.name !== undefined && message.name !== "") {
      obj.name = message.name;
    }
    if (message.location !== undefined) {
      obj.location = CMsgDotaScenario_EntityRef.toJSON(message.location);
    }
    if (message.ownerId !== undefined && message.ownerId !== -1) {
      obj.ownerId = Math.round(message.ownerId);
    }
    if (message.itemSlot !== undefined && message.itemSlot !== 0) {
      obj.itemSlot = Math.round(message.itemSlot);
    }
    if (message.neutralDropTeam !== undefined && message.neutralDropTeam !== 0) {
      obj.neutralDropTeam = Math.round(message.neutralDropTeam);
    }
    if (message.charges !== undefined && message.charges !== 0) {
      obj.charges = Math.round(message.charges);
    }
    if (message.secondaryCharges !== undefined && message.secondaryCharges !== 0) {
      obj.secondaryCharges = Math.round(message.secondaryCharges);
    }
    if (message.lifetime !== undefined && message.lifetime !== -1) {
      obj.lifetime = message.lifetime;
    }
    if (message.storedRuneType !== undefined && message.storedRuneType !== -1) {
      obj.storedRuneType = Math.round(message.storedRuneType);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDotaScenario_Item>): CMsgDotaScenario_Item {
    return CMsgDotaScenario_Item.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDotaScenario_Item>): CMsgDotaScenario_Item {
    const message = createBaseCMsgDotaScenario_Item();
    message.name = object.name ?? "";
    message.location = (object.location !== undefined && object.location !== null)
      ? CMsgDotaScenario_EntityRef.fromPartial(object.location)
      : undefined;
    message.ownerId = object.ownerId ?? -1;
    message.itemSlot = object.itemSlot ?? 0;
    message.neutralDropTeam = object.neutralDropTeam ?? 0;
    message.charges = object.charges ?? 0;
    message.secondaryCharges = object.secondaryCharges ?? 0;
    message.lifetime = object.lifetime ?? -1;
    message.storedRuneType = object.storedRuneType ?? -1;
    return message;
  },
};

function createBaseCMsgDotaScenario_Modifier(): CMsgDotaScenario_Modifier {
  return {
    name: "",
    parent: undefined,
    caster: undefined,
    ability: undefined,
    duration: -1,
    lifetimeRemaining: 0,
    stackCount: 0,
    createEvenIfExisting: false,
    createWithoutCaster: false,
    createWithoutAbility: false,
    moonshardConsumedBonus: 0,
    moonshardConsumedBonusNightVision: 0,
    wardtruesightRange: 0,
    ultimateScepterConsumedAlchemistBonusAllStats: 0,
    ultimateScepterConsumedAlchemistBonusHealth: 0,
    ultimateScepterConsumedAlchemistBonusMana: 0,
  };
}

export const CMsgDotaScenario_Modifier = {
  encode(message: CMsgDotaScenario_Modifier, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.parent !== undefined) {
      CMsgDotaScenario_EntityRef.encode(message.parent, writer.uint32(18).fork()).ldelim();
    }
    if (message.caster !== undefined) {
      CMsgDotaScenario_EntityRef.encode(message.caster, writer.uint32(26).fork()).ldelim();
    }
    if (message.ability !== undefined) {
      CMsgDotaScenario_EntityRef.encode(message.ability, writer.uint32(34).fork()).ldelim();
    }
    if (message.duration !== undefined && message.duration !== -1) {
      writer.uint32(45).float(message.duration);
    }
    if (message.lifetimeRemaining !== undefined && message.lifetimeRemaining !== 0) {
      writer.uint32(53).float(message.lifetimeRemaining);
    }
    if (message.stackCount !== undefined && message.stackCount !== 0) {
      writer.uint32(56).int32(message.stackCount);
    }
    if (message.createEvenIfExisting !== undefined && message.createEvenIfExisting !== false) {
      writer.uint32(64).bool(message.createEvenIfExisting);
    }
    if (message.createWithoutCaster !== undefined && message.createWithoutCaster !== false) {
      writer.uint32(72).bool(message.createWithoutCaster);
    }
    if (message.createWithoutAbility !== undefined && message.createWithoutAbility !== false) {
      writer.uint32(80).bool(message.createWithoutAbility);
    }
    if (message.moonshardConsumedBonus !== undefined && message.moonshardConsumedBonus !== 0) {
      writer.uint32(800).int32(message.moonshardConsumedBonus);
    }
    if (message.moonshardConsumedBonusNightVision !== undefined && message.moonshardConsumedBonusNightVision !== 0) {
      writer.uint32(808).int32(message.moonshardConsumedBonusNightVision);
    }
    if (message.wardtruesightRange !== undefined && message.wardtruesightRange !== 0) {
      writer.uint32(880).int32(message.wardtruesightRange);
    }
    if (
      message.ultimateScepterConsumedAlchemistBonusAllStats !== undefined &&
      message.ultimateScepterConsumedAlchemistBonusAllStats !== 0
    ) {
      writer.uint32(960).int32(message.ultimateScepterConsumedAlchemistBonusAllStats);
    }
    if (
      message.ultimateScepterConsumedAlchemistBonusHealth !== undefined &&
      message.ultimateScepterConsumedAlchemistBonusHealth !== 0
    ) {
      writer.uint32(968).int32(message.ultimateScepterConsumedAlchemistBonusHealth);
    }
    if (
      message.ultimateScepterConsumedAlchemistBonusMana !== undefined &&
      message.ultimateScepterConsumedAlchemistBonusMana !== 0
    ) {
      writer.uint32(976).int32(message.ultimateScepterConsumedAlchemistBonusMana);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDotaScenario_Modifier {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDotaScenario_Modifier();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.parent = CMsgDotaScenario_EntityRef.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.caster = CMsgDotaScenario_EntityRef.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.ability = CMsgDotaScenario_EntityRef.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 45) {
            break;
          }

          message.duration = reader.float();
          continue;
        case 6:
          if (tag !== 53) {
            break;
          }

          message.lifetimeRemaining = reader.float();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.stackCount = reader.int32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.createEvenIfExisting = reader.bool();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.createWithoutCaster = reader.bool();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.createWithoutAbility = reader.bool();
          continue;
        case 100:
          if (tag !== 800) {
            break;
          }

          message.moonshardConsumedBonus = reader.int32();
          continue;
        case 101:
          if (tag !== 808) {
            break;
          }

          message.moonshardConsumedBonusNightVision = reader.int32();
          continue;
        case 110:
          if (tag !== 880) {
            break;
          }

          message.wardtruesightRange = reader.int32();
          continue;
        case 120:
          if (tag !== 960) {
            break;
          }

          message.ultimateScepterConsumedAlchemistBonusAllStats = reader.int32();
          continue;
        case 121:
          if (tag !== 968) {
            break;
          }

          message.ultimateScepterConsumedAlchemistBonusHealth = reader.int32();
          continue;
        case 122:
          if (tag !== 976) {
            break;
          }

          message.ultimateScepterConsumedAlchemistBonusMana = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDotaScenario_Modifier {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      parent: isSet(object.parent) ? CMsgDotaScenario_EntityRef.fromJSON(object.parent) : undefined,
      caster: isSet(object.caster) ? CMsgDotaScenario_EntityRef.fromJSON(object.caster) : undefined,
      ability: isSet(object.ability) ? CMsgDotaScenario_EntityRef.fromJSON(object.ability) : undefined,
      duration: isSet(object.duration) ? globalThis.Number(object.duration) : -1,
      lifetimeRemaining: isSet(object.lifetimeRemaining) ? globalThis.Number(object.lifetimeRemaining) : 0,
      stackCount: isSet(object.stackCount) ? globalThis.Number(object.stackCount) : 0,
      createEvenIfExisting: isSet(object.createEvenIfExisting)
        ? globalThis.Boolean(object.createEvenIfExisting)
        : false,
      createWithoutCaster: isSet(object.createWithoutCaster) ? globalThis.Boolean(object.createWithoutCaster) : false,
      createWithoutAbility: isSet(object.createWithoutAbility)
        ? globalThis.Boolean(object.createWithoutAbility)
        : false,
      moonshardConsumedBonus: isSet(object.moonshardConsumedBonus)
        ? globalThis.Number(object.moonshardConsumedBonus)
        : 0,
      moonshardConsumedBonusNightVision: isSet(object.moonshardConsumedBonusNightVision)
        ? globalThis.Number(object.moonshardConsumedBonusNightVision)
        : 0,
      wardtruesightRange: isSet(object.wardtruesightRange) ? globalThis.Number(object.wardtruesightRange) : 0,
      ultimateScepterConsumedAlchemistBonusAllStats: isSet(object.ultimateScepterConsumedAlchemistBonusAllStats)
        ? globalThis.Number(object.ultimateScepterConsumedAlchemistBonusAllStats)
        : 0,
      ultimateScepterConsumedAlchemistBonusHealth: isSet(object.ultimateScepterConsumedAlchemistBonusHealth)
        ? globalThis.Number(object.ultimateScepterConsumedAlchemistBonusHealth)
        : 0,
      ultimateScepterConsumedAlchemistBonusMana: isSet(object.ultimateScepterConsumedAlchemistBonusMana)
        ? globalThis.Number(object.ultimateScepterConsumedAlchemistBonusMana)
        : 0,
    };
  },

  toJSON(message: CMsgDotaScenario_Modifier): unknown {
    const obj: any = {};
    if (message.name !== undefined && message.name !== "") {
      obj.name = message.name;
    }
    if (message.parent !== undefined) {
      obj.parent = CMsgDotaScenario_EntityRef.toJSON(message.parent);
    }
    if (message.caster !== undefined) {
      obj.caster = CMsgDotaScenario_EntityRef.toJSON(message.caster);
    }
    if (message.ability !== undefined) {
      obj.ability = CMsgDotaScenario_EntityRef.toJSON(message.ability);
    }
    if (message.duration !== undefined && message.duration !== -1) {
      obj.duration = message.duration;
    }
    if (message.lifetimeRemaining !== undefined && message.lifetimeRemaining !== 0) {
      obj.lifetimeRemaining = message.lifetimeRemaining;
    }
    if (message.stackCount !== undefined && message.stackCount !== 0) {
      obj.stackCount = Math.round(message.stackCount);
    }
    if (message.createEvenIfExisting !== undefined && message.createEvenIfExisting !== false) {
      obj.createEvenIfExisting = message.createEvenIfExisting;
    }
    if (message.createWithoutCaster !== undefined && message.createWithoutCaster !== false) {
      obj.createWithoutCaster = message.createWithoutCaster;
    }
    if (message.createWithoutAbility !== undefined && message.createWithoutAbility !== false) {
      obj.createWithoutAbility = message.createWithoutAbility;
    }
    if (message.moonshardConsumedBonus !== undefined && message.moonshardConsumedBonus !== 0) {
      obj.moonshardConsumedBonus = Math.round(message.moonshardConsumedBonus);
    }
    if (message.moonshardConsumedBonusNightVision !== undefined && message.moonshardConsumedBonusNightVision !== 0) {
      obj.moonshardConsumedBonusNightVision = Math.round(message.moonshardConsumedBonusNightVision);
    }
    if (message.wardtruesightRange !== undefined && message.wardtruesightRange !== 0) {
      obj.wardtruesightRange = Math.round(message.wardtruesightRange);
    }
    if (
      message.ultimateScepterConsumedAlchemistBonusAllStats !== undefined &&
      message.ultimateScepterConsumedAlchemistBonusAllStats !== 0
    ) {
      obj.ultimateScepterConsumedAlchemistBonusAllStats = Math.round(
        message.ultimateScepterConsumedAlchemistBonusAllStats,
      );
    }
    if (
      message.ultimateScepterConsumedAlchemistBonusHealth !== undefined &&
      message.ultimateScepterConsumedAlchemistBonusHealth !== 0
    ) {
      obj.ultimateScepterConsumedAlchemistBonusHealth = Math.round(message.ultimateScepterConsumedAlchemistBonusHealth);
    }
    if (
      message.ultimateScepterConsumedAlchemistBonusMana !== undefined &&
      message.ultimateScepterConsumedAlchemistBonusMana !== 0
    ) {
      obj.ultimateScepterConsumedAlchemistBonusMana = Math.round(message.ultimateScepterConsumedAlchemistBonusMana);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDotaScenario_Modifier>): CMsgDotaScenario_Modifier {
    return CMsgDotaScenario_Modifier.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDotaScenario_Modifier>): CMsgDotaScenario_Modifier {
    const message = createBaseCMsgDotaScenario_Modifier();
    message.name = object.name ?? "";
    message.parent = (object.parent !== undefined && object.parent !== null)
      ? CMsgDotaScenario_EntityRef.fromPartial(object.parent)
      : undefined;
    message.caster = (object.caster !== undefined && object.caster !== null)
      ? CMsgDotaScenario_EntityRef.fromPartial(object.caster)
      : undefined;
    message.ability = (object.ability !== undefined && object.ability !== null)
      ? CMsgDotaScenario_EntityRef.fromPartial(object.ability)
      : undefined;
    message.duration = object.duration ?? -1;
    message.lifetimeRemaining = object.lifetimeRemaining ?? 0;
    message.stackCount = object.stackCount ?? 0;
    message.createEvenIfExisting = object.createEvenIfExisting ?? false;
    message.createWithoutCaster = object.createWithoutCaster ?? false;
    message.createWithoutAbility = object.createWithoutAbility ?? false;
    message.moonshardConsumedBonus = object.moonshardConsumedBonus ?? 0;
    message.moonshardConsumedBonusNightVision = object.moonshardConsumedBonusNightVision ?? 0;
    message.wardtruesightRange = object.wardtruesightRange ?? 0;
    message.ultimateScepterConsumedAlchemistBonusAllStats = object.ultimateScepterConsumedAlchemistBonusAllStats ?? 0;
    message.ultimateScepterConsumedAlchemistBonusHealth = object.ultimateScepterConsumedAlchemistBonusHealth ?? 0;
    message.ultimateScepterConsumedAlchemistBonusMana = object.ultimateScepterConsumedAlchemistBonusMana ?? 0;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function longToString(long: Long) {
  return long.toString();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

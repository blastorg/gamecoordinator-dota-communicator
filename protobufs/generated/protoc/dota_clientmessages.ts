// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.176.1
//   protoc               v5.26.1
// source: dota_clientmessages.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";
import { CSOEconItem } from "./base_gcmessages";
import {
  CDOTAMsgDismissAllStatPopups,
  CDOTAMsgItemAlert,
  CDOTAMsgLocationPing,
  CDOTAMsgMapLine,
  CDOTAMsgSendStatPopup,
  CDOTAMsgUnitOrder,
  CDOTAMsgWorldLine,
  EDOTAVersusScenePlayerBehavior,
  eDOTAVersusScenePlayerBehaviorFromJSON,
  eDOTAVersusScenePlayerBehaviorToJSON,
  VersusSceneChatWheel,
  VersusScenePlayActivity,
  VersusScenePlaybackRate,
} from "./dota_commonmessages";
import {
  EEvent,
  eEventFromJSON,
  eEventToJSON,
  EItemSuggestPreference,
  eItemSuggestPreferenceFromJSON,
  eItemSuggestPreferenceToJSON,
  EOverwatchReportReason,
  eOverwatchReportReasonFromJSON,
  eOverwatchReportReasonToJSON,
  ETimerAlertType,
  eTimerAlertTypeFromJSON,
  eTimerAlertTypeToJSON,
} from "./dota_shared_enums";

export enum EDotaClientMessages {
  DOTA_CM_MapLine = 301,
  DOTA_CM_AspectRatio = 302,
  DOTA_CM_MapPing = 303,
  DOTA_CM_UnitsAutoAttack = 304,
  DOTA_CM_SearchString = 307,
  DOTA_CM_Pause = 308,
  DOTA_CM_ShopViewMode = 309,
  DOTA_CM_SetUnitShareFlag = 310,
  DOTA_CM_SwapRequest = 311,
  DOTA_CM_SwapAccept = 312,
  DOTA_CM_WorldLine = 313,
  DOTA_CM_RequestGraphUpdate = 314,
  DOTA_CM_ItemAlert = 315,
  DOTA_CM_ChatWheel = 316,
  DOTA_CM_SendStatPopup = 317,
  DOTA_CM_BeginLastHitChallenge = 318,
  DOTA_CM_UpdateQuickBuy = 319,
  DOTA_CM_UpdateCoachListen = 320,
  DOTA_CM_CoachHUDPing = 321,
  DOTA_CM_RecordVote = 322,
  DOTA_CM_UnitsAutoAttackAfterSpell = 323,
  DOTA_CM_WillPurchaseAlert = 324,
  DOTA_CM_PlayerShowCase = 325,
  DOTA_CM_TeleportRequiresHalt = 326,
  DOTA_CM_CameraZoomAmount = 327,
  DOTA_CM_BroadcasterUsingCamerman = 328,
  DOTA_CM_BroadcasterUsingAssistedCameraOperator = 329,
  DOTA_CM_EnemyItemAlert = 330,
  DOTA_CM_FreeInventory = 331,
  DOTA_CM_BuyBackStateAlert = 332,
  DOTA_CM_QuickBuyAlert = 333,
  DOTA_CM_HeroStatueLike = 334,
  DOTA_CM_ModifierAlert = 335,
  DOTA_CM_TeamShowcaseEditor = 336,
  DOTA_CM_HPManaAlert = 337,
  DOTA_CM_GlyphAlert = 338,
  DOTA_CM_TeamShowcaseClientData = 339,
  DOTA_CM_PlayTeamShowcase = 340,
  DOTA_CM_EventCNY2015Cmd = 341,
  DOTA_CM_FillEmptySlotsWithBots = 342,
  DOTA_CM_DemoHero = 343,
  DOTA_CM_AbilityLearnModeToggled = 344,
  DOTA_CM_AbilityStartUse = 345,
  DOTA_CM_ChallengeSelect = 346,
  DOTA_CM_ChallengeReroll = 347,
  DOTA_CM_ClickedBuff = 348,
  DOTA_CM_CoinWager = 349,
  DOTA_CM_ExecuteOrders = 350,
  DOTA_CM_XPAlert = 351,
  DOTA_CM_EventPointsTip = 353,
  DOTA_CM_KillMyHero = 355,
  DOTA_CM_QuestStatus = 356,
  DOTA_CM_ToggleAutoattack = 357,
  DOTA_CM_SpecialAbility = 358,
  DOTA_CM_KillcamDamageTaken = 359,
  DOTA_CM_SetEnemyStartingPosition = 360,
  DOTA_CM_SetDesiredWardPlacement = 361,
  DOTA_CM_RollDice = 362,
  DOTA_CM_FlipCoin = 363,
  DOTA_CM_RequestItemSuggestions = 364,
  DOTA_CM_MakeTeamCaptain = 365,
  DOTA_CM_CoinWagerToken = 366,
  DOTA_CM_RankWager = 367,
  DOTA_CM_DismissAllStatPopups = 368,
  DOTA_CM_HelpTipSystemStateChanged = 369,
  DOTA_CM_ChannelRequiresHalt = 370,
  DOTA_CM_RequestBulkCombatLog = 371,
  DOTA_CM_AbilityDraftRequestAbility = 372,
  DOTA_CM_GuideSelectOption = 373,
  DOTA_CM_GuideSelected = 374,
  DOTA_CM_DamageReport = 375,
  DOTA_CM_SalutePlayer = 376,
  DOTA_CM_SprayWheel = 377,
  DOTA_CM_TipAlert = 378,
  DOTA_CM_EmptyTeleportAlert = 379,
  DOTA_CM_RadarAlert = 380,
  DOTA_CM_TalentTreeAlert = 381,
  DOTA_CM_SetCavernMapVariant = 382,
  DOTA_CM_PauseGameOrder = 383,
  DOTA_CM_VersusScene_PlayerBehavior = 384,
  DOTA_CM_PlayerBounty = 385,
  DOTA_CM_PlayerBountyCancel = 386,
  DOTA_CM_EmptyItemSlotAlert = 388,
  DOTA_CM_AddOverwatchReportMarker = 389,
  DOTA_CM_AghsStatusAlert = 390,
  DOTA_CM_PerfReport = 391,
  DOTA_CM_ContextualTips_Subscribe = 393,
  DOTA_CM_ChatMessage = 394,
  DOTA_CM_AddCommunicationsReportMarker = 395,
  DOTA_CM_AddCommunicationsBlockMarker = 396,
  DOTA_CM_NeutralCampAlert = 397,
  DOTA_CM_DuelAccepted = 398,
  DOTA_CM_ChooseNeutralItem = 399,
  DOTA_CM_PlayerDraftPick = 800,
  DOTA_CM_PlayerDraftSuggest = 801,
  DOTA_CM_PlayerDraftPreferRole = 802,
  DOTA_CM_PlayerDraftPreferTeam = 803,
  DOTA_CM_ChatWheelAlert = 804,
  DOTA_CM_AbilityAlert = 805,
  DOTA_CM_AllyAbilityAlert = 806,
  DOTA_CM_GiftPlayer = 807,
  DOTA_CM_GiftEveryone = 808,
  DOTA_CM_SelectOverworldTokenRewards = 809,
  DOTA_CM_FacetAlert = 810,
  DOTA_CM_InnateAlert = 811,
  DOTA_CM_SelectOverworldID = 812,
  DOTA_CM_RerollNeutralItem = 813,
  DOTA_CM_RoshanTimer = 814,
  DOTA_CM_SuggestItemPreference = 815,
  DOTA_CM_CraftNeutralItem = 816,
  DOTA_CM_ChooseCraftedNeutral = 817,
  DOTA_CM_TimerAlert = 818,
  DOTA_CM_MadstoneAlert = 819,
}

export function eDotaClientMessagesFromJSON(object: any): EDotaClientMessages {
  switch (object) {
    case 301:
    case "DOTA_CM_MapLine":
      return EDotaClientMessages.DOTA_CM_MapLine;
    case 302:
    case "DOTA_CM_AspectRatio":
      return EDotaClientMessages.DOTA_CM_AspectRatio;
    case 303:
    case "DOTA_CM_MapPing":
      return EDotaClientMessages.DOTA_CM_MapPing;
    case 304:
    case "DOTA_CM_UnitsAutoAttack":
      return EDotaClientMessages.DOTA_CM_UnitsAutoAttack;
    case 307:
    case "DOTA_CM_SearchString":
      return EDotaClientMessages.DOTA_CM_SearchString;
    case 308:
    case "DOTA_CM_Pause":
      return EDotaClientMessages.DOTA_CM_Pause;
    case 309:
    case "DOTA_CM_ShopViewMode":
      return EDotaClientMessages.DOTA_CM_ShopViewMode;
    case 310:
    case "DOTA_CM_SetUnitShareFlag":
      return EDotaClientMessages.DOTA_CM_SetUnitShareFlag;
    case 311:
    case "DOTA_CM_SwapRequest":
      return EDotaClientMessages.DOTA_CM_SwapRequest;
    case 312:
    case "DOTA_CM_SwapAccept":
      return EDotaClientMessages.DOTA_CM_SwapAccept;
    case 313:
    case "DOTA_CM_WorldLine":
      return EDotaClientMessages.DOTA_CM_WorldLine;
    case 314:
    case "DOTA_CM_RequestGraphUpdate":
      return EDotaClientMessages.DOTA_CM_RequestGraphUpdate;
    case 315:
    case "DOTA_CM_ItemAlert":
      return EDotaClientMessages.DOTA_CM_ItemAlert;
    case 316:
    case "DOTA_CM_ChatWheel":
      return EDotaClientMessages.DOTA_CM_ChatWheel;
    case 317:
    case "DOTA_CM_SendStatPopup":
      return EDotaClientMessages.DOTA_CM_SendStatPopup;
    case 318:
    case "DOTA_CM_BeginLastHitChallenge":
      return EDotaClientMessages.DOTA_CM_BeginLastHitChallenge;
    case 319:
    case "DOTA_CM_UpdateQuickBuy":
      return EDotaClientMessages.DOTA_CM_UpdateQuickBuy;
    case 320:
    case "DOTA_CM_UpdateCoachListen":
      return EDotaClientMessages.DOTA_CM_UpdateCoachListen;
    case 321:
    case "DOTA_CM_CoachHUDPing":
      return EDotaClientMessages.DOTA_CM_CoachHUDPing;
    case 322:
    case "DOTA_CM_RecordVote":
      return EDotaClientMessages.DOTA_CM_RecordVote;
    case 323:
    case "DOTA_CM_UnitsAutoAttackAfterSpell":
      return EDotaClientMessages.DOTA_CM_UnitsAutoAttackAfterSpell;
    case 324:
    case "DOTA_CM_WillPurchaseAlert":
      return EDotaClientMessages.DOTA_CM_WillPurchaseAlert;
    case 325:
    case "DOTA_CM_PlayerShowCase":
      return EDotaClientMessages.DOTA_CM_PlayerShowCase;
    case 326:
    case "DOTA_CM_TeleportRequiresHalt":
      return EDotaClientMessages.DOTA_CM_TeleportRequiresHalt;
    case 327:
    case "DOTA_CM_CameraZoomAmount":
      return EDotaClientMessages.DOTA_CM_CameraZoomAmount;
    case 328:
    case "DOTA_CM_BroadcasterUsingCamerman":
      return EDotaClientMessages.DOTA_CM_BroadcasterUsingCamerman;
    case 329:
    case "DOTA_CM_BroadcasterUsingAssistedCameraOperator":
      return EDotaClientMessages.DOTA_CM_BroadcasterUsingAssistedCameraOperator;
    case 330:
    case "DOTA_CM_EnemyItemAlert":
      return EDotaClientMessages.DOTA_CM_EnemyItemAlert;
    case 331:
    case "DOTA_CM_FreeInventory":
      return EDotaClientMessages.DOTA_CM_FreeInventory;
    case 332:
    case "DOTA_CM_BuyBackStateAlert":
      return EDotaClientMessages.DOTA_CM_BuyBackStateAlert;
    case 333:
    case "DOTA_CM_QuickBuyAlert":
      return EDotaClientMessages.DOTA_CM_QuickBuyAlert;
    case 334:
    case "DOTA_CM_HeroStatueLike":
      return EDotaClientMessages.DOTA_CM_HeroStatueLike;
    case 335:
    case "DOTA_CM_ModifierAlert":
      return EDotaClientMessages.DOTA_CM_ModifierAlert;
    case 336:
    case "DOTA_CM_TeamShowcaseEditor":
      return EDotaClientMessages.DOTA_CM_TeamShowcaseEditor;
    case 337:
    case "DOTA_CM_HPManaAlert":
      return EDotaClientMessages.DOTA_CM_HPManaAlert;
    case 338:
    case "DOTA_CM_GlyphAlert":
      return EDotaClientMessages.DOTA_CM_GlyphAlert;
    case 339:
    case "DOTA_CM_TeamShowcaseClientData":
      return EDotaClientMessages.DOTA_CM_TeamShowcaseClientData;
    case 340:
    case "DOTA_CM_PlayTeamShowcase":
      return EDotaClientMessages.DOTA_CM_PlayTeamShowcase;
    case 341:
    case "DOTA_CM_EventCNY2015Cmd":
      return EDotaClientMessages.DOTA_CM_EventCNY2015Cmd;
    case 342:
    case "DOTA_CM_FillEmptySlotsWithBots":
      return EDotaClientMessages.DOTA_CM_FillEmptySlotsWithBots;
    case 343:
    case "DOTA_CM_DemoHero":
      return EDotaClientMessages.DOTA_CM_DemoHero;
    case 344:
    case "DOTA_CM_AbilityLearnModeToggled":
      return EDotaClientMessages.DOTA_CM_AbilityLearnModeToggled;
    case 345:
    case "DOTA_CM_AbilityStartUse":
      return EDotaClientMessages.DOTA_CM_AbilityStartUse;
    case 346:
    case "DOTA_CM_ChallengeSelect":
      return EDotaClientMessages.DOTA_CM_ChallengeSelect;
    case 347:
    case "DOTA_CM_ChallengeReroll":
      return EDotaClientMessages.DOTA_CM_ChallengeReroll;
    case 348:
    case "DOTA_CM_ClickedBuff":
      return EDotaClientMessages.DOTA_CM_ClickedBuff;
    case 349:
    case "DOTA_CM_CoinWager":
      return EDotaClientMessages.DOTA_CM_CoinWager;
    case 350:
    case "DOTA_CM_ExecuteOrders":
      return EDotaClientMessages.DOTA_CM_ExecuteOrders;
    case 351:
    case "DOTA_CM_XPAlert":
      return EDotaClientMessages.DOTA_CM_XPAlert;
    case 353:
    case "DOTA_CM_EventPointsTip":
      return EDotaClientMessages.DOTA_CM_EventPointsTip;
    case 355:
    case "DOTA_CM_KillMyHero":
      return EDotaClientMessages.DOTA_CM_KillMyHero;
    case 356:
    case "DOTA_CM_QuestStatus":
      return EDotaClientMessages.DOTA_CM_QuestStatus;
    case 357:
    case "DOTA_CM_ToggleAutoattack":
      return EDotaClientMessages.DOTA_CM_ToggleAutoattack;
    case 358:
    case "DOTA_CM_SpecialAbility":
      return EDotaClientMessages.DOTA_CM_SpecialAbility;
    case 359:
    case "DOTA_CM_KillcamDamageTaken":
      return EDotaClientMessages.DOTA_CM_KillcamDamageTaken;
    case 360:
    case "DOTA_CM_SetEnemyStartingPosition":
      return EDotaClientMessages.DOTA_CM_SetEnemyStartingPosition;
    case 361:
    case "DOTA_CM_SetDesiredWardPlacement":
      return EDotaClientMessages.DOTA_CM_SetDesiredWardPlacement;
    case 362:
    case "DOTA_CM_RollDice":
      return EDotaClientMessages.DOTA_CM_RollDice;
    case 363:
    case "DOTA_CM_FlipCoin":
      return EDotaClientMessages.DOTA_CM_FlipCoin;
    case 364:
    case "DOTA_CM_RequestItemSuggestions":
      return EDotaClientMessages.DOTA_CM_RequestItemSuggestions;
    case 365:
    case "DOTA_CM_MakeTeamCaptain":
      return EDotaClientMessages.DOTA_CM_MakeTeamCaptain;
    case 366:
    case "DOTA_CM_CoinWagerToken":
      return EDotaClientMessages.DOTA_CM_CoinWagerToken;
    case 367:
    case "DOTA_CM_RankWager":
      return EDotaClientMessages.DOTA_CM_RankWager;
    case 368:
    case "DOTA_CM_DismissAllStatPopups":
      return EDotaClientMessages.DOTA_CM_DismissAllStatPopups;
    case 369:
    case "DOTA_CM_HelpTipSystemStateChanged":
      return EDotaClientMessages.DOTA_CM_HelpTipSystemStateChanged;
    case 370:
    case "DOTA_CM_ChannelRequiresHalt":
      return EDotaClientMessages.DOTA_CM_ChannelRequiresHalt;
    case 371:
    case "DOTA_CM_RequestBulkCombatLog":
      return EDotaClientMessages.DOTA_CM_RequestBulkCombatLog;
    case 372:
    case "DOTA_CM_AbilityDraftRequestAbility":
      return EDotaClientMessages.DOTA_CM_AbilityDraftRequestAbility;
    case 373:
    case "DOTA_CM_GuideSelectOption":
      return EDotaClientMessages.DOTA_CM_GuideSelectOption;
    case 374:
    case "DOTA_CM_GuideSelected":
      return EDotaClientMessages.DOTA_CM_GuideSelected;
    case 375:
    case "DOTA_CM_DamageReport":
      return EDotaClientMessages.DOTA_CM_DamageReport;
    case 376:
    case "DOTA_CM_SalutePlayer":
      return EDotaClientMessages.DOTA_CM_SalutePlayer;
    case 377:
    case "DOTA_CM_SprayWheel":
      return EDotaClientMessages.DOTA_CM_SprayWheel;
    case 378:
    case "DOTA_CM_TipAlert":
      return EDotaClientMessages.DOTA_CM_TipAlert;
    case 379:
    case "DOTA_CM_EmptyTeleportAlert":
      return EDotaClientMessages.DOTA_CM_EmptyTeleportAlert;
    case 380:
    case "DOTA_CM_RadarAlert":
      return EDotaClientMessages.DOTA_CM_RadarAlert;
    case 381:
    case "DOTA_CM_TalentTreeAlert":
      return EDotaClientMessages.DOTA_CM_TalentTreeAlert;
    case 382:
    case "DOTA_CM_SetCavernMapVariant":
      return EDotaClientMessages.DOTA_CM_SetCavernMapVariant;
    case 383:
    case "DOTA_CM_PauseGameOrder":
      return EDotaClientMessages.DOTA_CM_PauseGameOrder;
    case 384:
    case "DOTA_CM_VersusScene_PlayerBehavior":
      return EDotaClientMessages.DOTA_CM_VersusScene_PlayerBehavior;
    case 385:
    case "DOTA_CM_PlayerBounty":
      return EDotaClientMessages.DOTA_CM_PlayerBounty;
    case 386:
    case "DOTA_CM_PlayerBountyCancel":
      return EDotaClientMessages.DOTA_CM_PlayerBountyCancel;
    case 388:
    case "DOTA_CM_EmptyItemSlotAlert":
      return EDotaClientMessages.DOTA_CM_EmptyItemSlotAlert;
    case 389:
    case "DOTA_CM_AddOverwatchReportMarker":
      return EDotaClientMessages.DOTA_CM_AddOverwatchReportMarker;
    case 390:
    case "DOTA_CM_AghsStatusAlert":
      return EDotaClientMessages.DOTA_CM_AghsStatusAlert;
    case 391:
    case "DOTA_CM_PerfReport":
      return EDotaClientMessages.DOTA_CM_PerfReport;
    case 393:
    case "DOTA_CM_ContextualTips_Subscribe":
      return EDotaClientMessages.DOTA_CM_ContextualTips_Subscribe;
    case 394:
    case "DOTA_CM_ChatMessage":
      return EDotaClientMessages.DOTA_CM_ChatMessage;
    case 395:
    case "DOTA_CM_AddCommunicationsReportMarker":
      return EDotaClientMessages.DOTA_CM_AddCommunicationsReportMarker;
    case 396:
    case "DOTA_CM_AddCommunicationsBlockMarker":
      return EDotaClientMessages.DOTA_CM_AddCommunicationsBlockMarker;
    case 397:
    case "DOTA_CM_NeutralCampAlert":
      return EDotaClientMessages.DOTA_CM_NeutralCampAlert;
    case 398:
    case "DOTA_CM_DuelAccepted":
      return EDotaClientMessages.DOTA_CM_DuelAccepted;
    case 399:
    case "DOTA_CM_ChooseNeutralItem":
      return EDotaClientMessages.DOTA_CM_ChooseNeutralItem;
    case 800:
    case "DOTA_CM_PlayerDraftPick":
      return EDotaClientMessages.DOTA_CM_PlayerDraftPick;
    case 801:
    case "DOTA_CM_PlayerDraftSuggest":
      return EDotaClientMessages.DOTA_CM_PlayerDraftSuggest;
    case 802:
    case "DOTA_CM_PlayerDraftPreferRole":
      return EDotaClientMessages.DOTA_CM_PlayerDraftPreferRole;
    case 803:
    case "DOTA_CM_PlayerDraftPreferTeam":
      return EDotaClientMessages.DOTA_CM_PlayerDraftPreferTeam;
    case 804:
    case "DOTA_CM_ChatWheelAlert":
      return EDotaClientMessages.DOTA_CM_ChatWheelAlert;
    case 805:
    case "DOTA_CM_AbilityAlert":
      return EDotaClientMessages.DOTA_CM_AbilityAlert;
    case 806:
    case "DOTA_CM_AllyAbilityAlert":
      return EDotaClientMessages.DOTA_CM_AllyAbilityAlert;
    case 807:
    case "DOTA_CM_GiftPlayer":
      return EDotaClientMessages.DOTA_CM_GiftPlayer;
    case 808:
    case "DOTA_CM_GiftEveryone":
      return EDotaClientMessages.DOTA_CM_GiftEveryone;
    case 809:
    case "DOTA_CM_SelectOverworldTokenRewards":
      return EDotaClientMessages.DOTA_CM_SelectOverworldTokenRewards;
    case 810:
    case "DOTA_CM_FacetAlert":
      return EDotaClientMessages.DOTA_CM_FacetAlert;
    case 811:
    case "DOTA_CM_InnateAlert":
      return EDotaClientMessages.DOTA_CM_InnateAlert;
    case 812:
    case "DOTA_CM_SelectOverworldID":
      return EDotaClientMessages.DOTA_CM_SelectOverworldID;
    case 813:
    case "DOTA_CM_RerollNeutralItem":
      return EDotaClientMessages.DOTA_CM_RerollNeutralItem;
    case 814:
    case "DOTA_CM_RoshanTimer":
      return EDotaClientMessages.DOTA_CM_RoshanTimer;
    case 815:
    case "DOTA_CM_SuggestItemPreference":
      return EDotaClientMessages.DOTA_CM_SuggestItemPreference;
    case 816:
    case "DOTA_CM_CraftNeutralItem":
      return EDotaClientMessages.DOTA_CM_CraftNeutralItem;
    case 817:
    case "DOTA_CM_ChooseCraftedNeutral":
      return EDotaClientMessages.DOTA_CM_ChooseCraftedNeutral;
    case 818:
    case "DOTA_CM_TimerAlert":
      return EDotaClientMessages.DOTA_CM_TimerAlert;
    case 819:
    case "DOTA_CM_MadstoneAlert":
      return EDotaClientMessages.DOTA_CM_MadstoneAlert;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum EDotaClientMessages");
  }
}

export function eDotaClientMessagesToJSON(object: EDotaClientMessages): string {
  switch (object) {
    case EDotaClientMessages.DOTA_CM_MapLine:
      return "DOTA_CM_MapLine";
    case EDotaClientMessages.DOTA_CM_AspectRatio:
      return "DOTA_CM_AspectRatio";
    case EDotaClientMessages.DOTA_CM_MapPing:
      return "DOTA_CM_MapPing";
    case EDotaClientMessages.DOTA_CM_UnitsAutoAttack:
      return "DOTA_CM_UnitsAutoAttack";
    case EDotaClientMessages.DOTA_CM_SearchString:
      return "DOTA_CM_SearchString";
    case EDotaClientMessages.DOTA_CM_Pause:
      return "DOTA_CM_Pause";
    case EDotaClientMessages.DOTA_CM_ShopViewMode:
      return "DOTA_CM_ShopViewMode";
    case EDotaClientMessages.DOTA_CM_SetUnitShareFlag:
      return "DOTA_CM_SetUnitShareFlag";
    case EDotaClientMessages.DOTA_CM_SwapRequest:
      return "DOTA_CM_SwapRequest";
    case EDotaClientMessages.DOTA_CM_SwapAccept:
      return "DOTA_CM_SwapAccept";
    case EDotaClientMessages.DOTA_CM_WorldLine:
      return "DOTA_CM_WorldLine";
    case EDotaClientMessages.DOTA_CM_RequestGraphUpdate:
      return "DOTA_CM_RequestGraphUpdate";
    case EDotaClientMessages.DOTA_CM_ItemAlert:
      return "DOTA_CM_ItemAlert";
    case EDotaClientMessages.DOTA_CM_ChatWheel:
      return "DOTA_CM_ChatWheel";
    case EDotaClientMessages.DOTA_CM_SendStatPopup:
      return "DOTA_CM_SendStatPopup";
    case EDotaClientMessages.DOTA_CM_BeginLastHitChallenge:
      return "DOTA_CM_BeginLastHitChallenge";
    case EDotaClientMessages.DOTA_CM_UpdateQuickBuy:
      return "DOTA_CM_UpdateQuickBuy";
    case EDotaClientMessages.DOTA_CM_UpdateCoachListen:
      return "DOTA_CM_UpdateCoachListen";
    case EDotaClientMessages.DOTA_CM_CoachHUDPing:
      return "DOTA_CM_CoachHUDPing";
    case EDotaClientMessages.DOTA_CM_RecordVote:
      return "DOTA_CM_RecordVote";
    case EDotaClientMessages.DOTA_CM_UnitsAutoAttackAfterSpell:
      return "DOTA_CM_UnitsAutoAttackAfterSpell";
    case EDotaClientMessages.DOTA_CM_WillPurchaseAlert:
      return "DOTA_CM_WillPurchaseAlert";
    case EDotaClientMessages.DOTA_CM_PlayerShowCase:
      return "DOTA_CM_PlayerShowCase";
    case EDotaClientMessages.DOTA_CM_TeleportRequiresHalt:
      return "DOTA_CM_TeleportRequiresHalt";
    case EDotaClientMessages.DOTA_CM_CameraZoomAmount:
      return "DOTA_CM_CameraZoomAmount";
    case EDotaClientMessages.DOTA_CM_BroadcasterUsingCamerman:
      return "DOTA_CM_BroadcasterUsingCamerman";
    case EDotaClientMessages.DOTA_CM_BroadcasterUsingAssistedCameraOperator:
      return "DOTA_CM_BroadcasterUsingAssistedCameraOperator";
    case EDotaClientMessages.DOTA_CM_EnemyItemAlert:
      return "DOTA_CM_EnemyItemAlert";
    case EDotaClientMessages.DOTA_CM_FreeInventory:
      return "DOTA_CM_FreeInventory";
    case EDotaClientMessages.DOTA_CM_BuyBackStateAlert:
      return "DOTA_CM_BuyBackStateAlert";
    case EDotaClientMessages.DOTA_CM_QuickBuyAlert:
      return "DOTA_CM_QuickBuyAlert";
    case EDotaClientMessages.DOTA_CM_HeroStatueLike:
      return "DOTA_CM_HeroStatueLike";
    case EDotaClientMessages.DOTA_CM_ModifierAlert:
      return "DOTA_CM_ModifierAlert";
    case EDotaClientMessages.DOTA_CM_TeamShowcaseEditor:
      return "DOTA_CM_TeamShowcaseEditor";
    case EDotaClientMessages.DOTA_CM_HPManaAlert:
      return "DOTA_CM_HPManaAlert";
    case EDotaClientMessages.DOTA_CM_GlyphAlert:
      return "DOTA_CM_GlyphAlert";
    case EDotaClientMessages.DOTA_CM_TeamShowcaseClientData:
      return "DOTA_CM_TeamShowcaseClientData";
    case EDotaClientMessages.DOTA_CM_PlayTeamShowcase:
      return "DOTA_CM_PlayTeamShowcase";
    case EDotaClientMessages.DOTA_CM_EventCNY2015Cmd:
      return "DOTA_CM_EventCNY2015Cmd";
    case EDotaClientMessages.DOTA_CM_FillEmptySlotsWithBots:
      return "DOTA_CM_FillEmptySlotsWithBots";
    case EDotaClientMessages.DOTA_CM_DemoHero:
      return "DOTA_CM_DemoHero";
    case EDotaClientMessages.DOTA_CM_AbilityLearnModeToggled:
      return "DOTA_CM_AbilityLearnModeToggled";
    case EDotaClientMessages.DOTA_CM_AbilityStartUse:
      return "DOTA_CM_AbilityStartUse";
    case EDotaClientMessages.DOTA_CM_ChallengeSelect:
      return "DOTA_CM_ChallengeSelect";
    case EDotaClientMessages.DOTA_CM_ChallengeReroll:
      return "DOTA_CM_ChallengeReroll";
    case EDotaClientMessages.DOTA_CM_ClickedBuff:
      return "DOTA_CM_ClickedBuff";
    case EDotaClientMessages.DOTA_CM_CoinWager:
      return "DOTA_CM_CoinWager";
    case EDotaClientMessages.DOTA_CM_ExecuteOrders:
      return "DOTA_CM_ExecuteOrders";
    case EDotaClientMessages.DOTA_CM_XPAlert:
      return "DOTA_CM_XPAlert";
    case EDotaClientMessages.DOTA_CM_EventPointsTip:
      return "DOTA_CM_EventPointsTip";
    case EDotaClientMessages.DOTA_CM_KillMyHero:
      return "DOTA_CM_KillMyHero";
    case EDotaClientMessages.DOTA_CM_QuestStatus:
      return "DOTA_CM_QuestStatus";
    case EDotaClientMessages.DOTA_CM_ToggleAutoattack:
      return "DOTA_CM_ToggleAutoattack";
    case EDotaClientMessages.DOTA_CM_SpecialAbility:
      return "DOTA_CM_SpecialAbility";
    case EDotaClientMessages.DOTA_CM_KillcamDamageTaken:
      return "DOTA_CM_KillcamDamageTaken";
    case EDotaClientMessages.DOTA_CM_SetEnemyStartingPosition:
      return "DOTA_CM_SetEnemyStartingPosition";
    case EDotaClientMessages.DOTA_CM_SetDesiredWardPlacement:
      return "DOTA_CM_SetDesiredWardPlacement";
    case EDotaClientMessages.DOTA_CM_RollDice:
      return "DOTA_CM_RollDice";
    case EDotaClientMessages.DOTA_CM_FlipCoin:
      return "DOTA_CM_FlipCoin";
    case EDotaClientMessages.DOTA_CM_RequestItemSuggestions:
      return "DOTA_CM_RequestItemSuggestions";
    case EDotaClientMessages.DOTA_CM_MakeTeamCaptain:
      return "DOTA_CM_MakeTeamCaptain";
    case EDotaClientMessages.DOTA_CM_CoinWagerToken:
      return "DOTA_CM_CoinWagerToken";
    case EDotaClientMessages.DOTA_CM_RankWager:
      return "DOTA_CM_RankWager";
    case EDotaClientMessages.DOTA_CM_DismissAllStatPopups:
      return "DOTA_CM_DismissAllStatPopups";
    case EDotaClientMessages.DOTA_CM_HelpTipSystemStateChanged:
      return "DOTA_CM_HelpTipSystemStateChanged";
    case EDotaClientMessages.DOTA_CM_ChannelRequiresHalt:
      return "DOTA_CM_ChannelRequiresHalt";
    case EDotaClientMessages.DOTA_CM_RequestBulkCombatLog:
      return "DOTA_CM_RequestBulkCombatLog";
    case EDotaClientMessages.DOTA_CM_AbilityDraftRequestAbility:
      return "DOTA_CM_AbilityDraftRequestAbility";
    case EDotaClientMessages.DOTA_CM_GuideSelectOption:
      return "DOTA_CM_GuideSelectOption";
    case EDotaClientMessages.DOTA_CM_GuideSelected:
      return "DOTA_CM_GuideSelected";
    case EDotaClientMessages.DOTA_CM_DamageReport:
      return "DOTA_CM_DamageReport";
    case EDotaClientMessages.DOTA_CM_SalutePlayer:
      return "DOTA_CM_SalutePlayer";
    case EDotaClientMessages.DOTA_CM_SprayWheel:
      return "DOTA_CM_SprayWheel";
    case EDotaClientMessages.DOTA_CM_TipAlert:
      return "DOTA_CM_TipAlert";
    case EDotaClientMessages.DOTA_CM_EmptyTeleportAlert:
      return "DOTA_CM_EmptyTeleportAlert";
    case EDotaClientMessages.DOTA_CM_RadarAlert:
      return "DOTA_CM_RadarAlert";
    case EDotaClientMessages.DOTA_CM_TalentTreeAlert:
      return "DOTA_CM_TalentTreeAlert";
    case EDotaClientMessages.DOTA_CM_SetCavernMapVariant:
      return "DOTA_CM_SetCavernMapVariant";
    case EDotaClientMessages.DOTA_CM_PauseGameOrder:
      return "DOTA_CM_PauseGameOrder";
    case EDotaClientMessages.DOTA_CM_VersusScene_PlayerBehavior:
      return "DOTA_CM_VersusScene_PlayerBehavior";
    case EDotaClientMessages.DOTA_CM_PlayerBounty:
      return "DOTA_CM_PlayerBounty";
    case EDotaClientMessages.DOTA_CM_PlayerBountyCancel:
      return "DOTA_CM_PlayerBountyCancel";
    case EDotaClientMessages.DOTA_CM_EmptyItemSlotAlert:
      return "DOTA_CM_EmptyItemSlotAlert";
    case EDotaClientMessages.DOTA_CM_AddOverwatchReportMarker:
      return "DOTA_CM_AddOverwatchReportMarker";
    case EDotaClientMessages.DOTA_CM_AghsStatusAlert:
      return "DOTA_CM_AghsStatusAlert";
    case EDotaClientMessages.DOTA_CM_PerfReport:
      return "DOTA_CM_PerfReport";
    case EDotaClientMessages.DOTA_CM_ContextualTips_Subscribe:
      return "DOTA_CM_ContextualTips_Subscribe";
    case EDotaClientMessages.DOTA_CM_ChatMessage:
      return "DOTA_CM_ChatMessage";
    case EDotaClientMessages.DOTA_CM_AddCommunicationsReportMarker:
      return "DOTA_CM_AddCommunicationsReportMarker";
    case EDotaClientMessages.DOTA_CM_AddCommunicationsBlockMarker:
      return "DOTA_CM_AddCommunicationsBlockMarker";
    case EDotaClientMessages.DOTA_CM_NeutralCampAlert:
      return "DOTA_CM_NeutralCampAlert";
    case EDotaClientMessages.DOTA_CM_DuelAccepted:
      return "DOTA_CM_DuelAccepted";
    case EDotaClientMessages.DOTA_CM_ChooseNeutralItem:
      return "DOTA_CM_ChooseNeutralItem";
    case EDotaClientMessages.DOTA_CM_PlayerDraftPick:
      return "DOTA_CM_PlayerDraftPick";
    case EDotaClientMessages.DOTA_CM_PlayerDraftSuggest:
      return "DOTA_CM_PlayerDraftSuggest";
    case EDotaClientMessages.DOTA_CM_PlayerDraftPreferRole:
      return "DOTA_CM_PlayerDraftPreferRole";
    case EDotaClientMessages.DOTA_CM_PlayerDraftPreferTeam:
      return "DOTA_CM_PlayerDraftPreferTeam";
    case EDotaClientMessages.DOTA_CM_ChatWheelAlert:
      return "DOTA_CM_ChatWheelAlert";
    case EDotaClientMessages.DOTA_CM_AbilityAlert:
      return "DOTA_CM_AbilityAlert";
    case EDotaClientMessages.DOTA_CM_AllyAbilityAlert:
      return "DOTA_CM_AllyAbilityAlert";
    case EDotaClientMessages.DOTA_CM_GiftPlayer:
      return "DOTA_CM_GiftPlayer";
    case EDotaClientMessages.DOTA_CM_GiftEveryone:
      return "DOTA_CM_GiftEveryone";
    case EDotaClientMessages.DOTA_CM_SelectOverworldTokenRewards:
      return "DOTA_CM_SelectOverworldTokenRewards";
    case EDotaClientMessages.DOTA_CM_FacetAlert:
      return "DOTA_CM_FacetAlert";
    case EDotaClientMessages.DOTA_CM_InnateAlert:
      return "DOTA_CM_InnateAlert";
    case EDotaClientMessages.DOTA_CM_SelectOverworldID:
      return "DOTA_CM_SelectOverworldID";
    case EDotaClientMessages.DOTA_CM_RerollNeutralItem:
      return "DOTA_CM_RerollNeutralItem";
    case EDotaClientMessages.DOTA_CM_RoshanTimer:
      return "DOTA_CM_RoshanTimer";
    case EDotaClientMessages.DOTA_CM_SuggestItemPreference:
      return "DOTA_CM_SuggestItemPreference";
    case EDotaClientMessages.DOTA_CM_CraftNeutralItem:
      return "DOTA_CM_CraftNeutralItem";
    case EDotaClientMessages.DOTA_CM_ChooseCraftedNeutral:
      return "DOTA_CM_ChooseCraftedNeutral";
    case EDotaClientMessages.DOTA_CM_TimerAlert:
      return "DOTA_CM_TimerAlert";
    case EDotaClientMessages.DOTA_CM_MadstoneAlert:
      return "DOTA_CM_MadstoneAlert";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum EDotaClientMessages");
  }
}

export interface CDOTAClientMsgMapPing {
  locationPing?: CDOTAMsgLocationPing | undefined;
}

export interface CDOTAClientMsgItemAlert {
  itemAlert?: CDOTAMsgItemAlert | undefined;
}

export interface CDOTAClientMsgEnemyItemAlert {
  itemEntindex?: number | undefined;
  runeType?: number | undefined;
  itemLevel?: number | undefined;
  primaryCharges?: number | undefined;
  secondaryCharges?: number | undefined;
  abilityId?: number | undefined;
  ownerEntindex?: number | undefined;
}

export interface CDOTAClientMsgModifierAlert {
  buffInternalIndex?: number | undefined;
  targetEntindex?: number | undefined;
}

export interface CDOTAClientMsgClickedBuff {
  buffInternalIndex?: number | undefined;
  targetEntindex?: number | undefined;
}

export interface CDOTAClientMsgHPManaAlert {
  targetEntindex?: number | undefined;
  showRawValues?: boolean | undefined;
}

export interface CDOTAClientMsgNeutralCampAlert {
  spawnerEntindex?: number | undefined;
  unitEntindex?: number | undefined;
  stackRequest?: boolean | undefined;
}

export interface CDOTAClientMsgGlyphAlert {
  negative?: boolean | undefined;
}

export interface CDOTAClientMsgRadarAlert {
  negative?: boolean | undefined;
}

export interface CDOTAClientMsgMapLine {
  mapline?: CDOTAMsgMapLine | undefined;
}

export interface CDOTAClientMsgAspectRatio {
  ratio?: number | undefined;
}

export interface CDOTAClientMsgUnitsAutoAttackMode {
  mode?: CDOTAClientMsgUnitsAutoAttackMode_EMode | undefined;
  unitType?: CDOTAClientMsgUnitsAutoAttackMode_EUnitType | undefined;
}

export enum CDOTAClientMsgUnitsAutoAttackMode_EMode {
  INVALID = -1,
  NEVER = 0,
  AFTER_SPELLCAST = 1,
  ALWAYS = 2,
}

export function cDOTAClientMsgUnitsAutoAttackMode_EModeFromJSON(object: any): CDOTAClientMsgUnitsAutoAttackMode_EMode {
  switch (object) {
    case -1:
    case "INVALID":
      return CDOTAClientMsgUnitsAutoAttackMode_EMode.INVALID;
    case 0:
    case "NEVER":
      return CDOTAClientMsgUnitsAutoAttackMode_EMode.NEVER;
    case 1:
    case "AFTER_SPELLCAST":
      return CDOTAClientMsgUnitsAutoAttackMode_EMode.AFTER_SPELLCAST;
    case 2:
    case "ALWAYS":
      return CDOTAClientMsgUnitsAutoAttackMode_EMode.ALWAYS;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum CDOTAClientMsgUnitsAutoAttackMode_EMode",
      );
  }
}

export function cDOTAClientMsgUnitsAutoAttackMode_EModeToJSON(object: CDOTAClientMsgUnitsAutoAttackMode_EMode): string {
  switch (object) {
    case CDOTAClientMsgUnitsAutoAttackMode_EMode.INVALID:
      return "INVALID";
    case CDOTAClientMsgUnitsAutoAttackMode_EMode.NEVER:
      return "NEVER";
    case CDOTAClientMsgUnitsAutoAttackMode_EMode.AFTER_SPELLCAST:
      return "AFTER_SPELLCAST";
    case CDOTAClientMsgUnitsAutoAttackMode_EMode.ALWAYS:
      return "ALWAYS";
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum CDOTAClientMsgUnitsAutoAttackMode_EMode",
      );
  }
}

export enum CDOTAClientMsgUnitsAutoAttackMode_EUnitType {
  NORMAL = 0,
  SUMMONED = 1,
}

export function cDOTAClientMsgUnitsAutoAttackMode_EUnitTypeFromJSON(
  object: any,
): CDOTAClientMsgUnitsAutoAttackMode_EUnitType {
  switch (object) {
    case 0:
    case "NORMAL":
      return CDOTAClientMsgUnitsAutoAttackMode_EUnitType.NORMAL;
    case 1:
    case "SUMMONED":
      return CDOTAClientMsgUnitsAutoAttackMode_EUnitType.SUMMONED;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum CDOTAClientMsgUnitsAutoAttackMode_EUnitType",
      );
  }
}

export function cDOTAClientMsgUnitsAutoAttackMode_EUnitTypeToJSON(
  object: CDOTAClientMsgUnitsAutoAttackMode_EUnitType,
): string {
  switch (object) {
    case CDOTAClientMsgUnitsAutoAttackMode_EUnitType.NORMAL:
      return "NORMAL";
    case CDOTAClientMsgUnitsAutoAttackMode_EUnitType.SUMMONED:
      return "SUMMONED";
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum CDOTAClientMsgUnitsAutoAttackMode_EUnitType",
      );
  }
}

export interface CDOTAClientMsgUnitsAutoAttackAfterSpell {
  enabled?: boolean | undefined;
}

export interface CDOTAClientMsgTeleportRequiresHalt {
  enabled?: boolean | undefined;
}

export interface CDOTAClientMsgChannelRequiresHalt {
  enabled?: boolean | undefined;
}

export interface CDOTAClientMsgSearchString {
  search?: string | undefined;
}

export interface CDOTAClientMsgPause {
}

export interface CDOTAClientMsgShopViewMode {
  mode?: number | undefined;
}

export interface CDOTAClientMsgSetUnitShareFlag {
  playerId?: number | undefined;
  flag?: number | undefined;
  state?: boolean | undefined;
}

export interface CDOTAClientMsgSwapRequest {
  playerId?: number | undefined;
}

export interface CDOTAClientMsgSwapAccept {
  playerId?: number | undefined;
}

export interface CDOTAClientMsgWorldLine {
  worldline?: CDOTAMsgWorldLine | undefined;
}

export interface CDOTAClientMsgRequestGraphUpdate {
}

export interface CDOTAClientMsgChatWheel {
  chatMessageId?: number | undefined;
  paramHeroId?: number | undefined;
  emoticonId?: number | undefined;
}

export interface CDOTAClientMsgSendStatPopup {
  statpopup?: CDOTAMsgSendStatPopup | undefined;
}

export interface CDOTAClientMsgDismissAllStatPopups {
  dismissallmsg?: CDOTAMsgDismissAllStatPopups | undefined;
}

export interface CDOTAClientMsgBeginLastHitChallenge {
  chosenLane?: number | undefined;
  helperEnabled?: boolean | undefined;
}

export interface CDOTAClientMsgUpdateQuickBuyItem {
  itemAbilityId?: number | undefined;
  purchasable?: boolean | undefined;
}

export interface CDOTAClientMsgUpdateQuickBuy {
  items: CDOTAClientMsgUpdateQuickBuyItem[];
}

export interface CDOTAClientMsgRecordVote {
  choiceIndex?: number | undefined;
}

export interface CDOTAClientMsgWillPurchaseAlert {
  itemAbilityId?: number | undefined;
  goldRemaining?: number | undefined;
  suggestionPlayerId?: number | undefined;
}

export interface CDOTAClientMsgBuyBackStateAlert {
}

export interface CDOTAClientMsgQuickBuyAlert {
  itemAbilityId?: number | undefined;
  goldCost?: number | undefined;
  itemCooldownSeconds?: number | undefined;
  showBuyback?: boolean | undefined;
}

export interface CDOTAClientMsgPlayerShowCase {
  showcase?: boolean | undefined;
}

export interface CDOTAClientMsgCameraZoomAmount {
  zoomAmount?: number | undefined;
}

export interface CDOTAClientMsgBroadcasterUsingCameraman {
  cameraman?: boolean | undefined;
}

export interface CDOTAClientMsgBroadcasterUsingAssistedCameraOperator {
  enabled?: boolean | undefined;
}

export interface CDOTAClientMsgFillEmptySlotsWithBots {
  fillwithbots?: boolean | undefined;
}

export interface CDOTAClientMsgHeroStatueLike {
  ownerPlayerId?: number | undefined;
}

export interface CDOTAClientMsgEventCNY2015Cmd {
  data?: Buffer | undefined;
}

export interface CDOTAClientMsgDemoHero {
  heroId?: number | undefined;
  heroIdToSpawn?: number | undefined;
  itemDefs: number[];
  itemIds: string[];
  styleIndex?: number | undefined;
  keepExistingDemohero?: boolean | undefined;
  itemData: CSOEconItem[];
  heroVariant?: number | undefined;
}

export interface CDOTAClientMsgChallengeSelect {
  eventId?: number | undefined;
  slotId?: number | undefined;
  sequenceId?: number | undefined;
}

export interface CDOTAClientMsgChallengeReroll {
  eventId?: EEvent | undefined;
  slotId?: number | undefined;
  sequenceId?: number | undefined;
  heroId?: number | undefined;
}

export interface CDOTAClientMsgCoinWager {
  wagerAmount?: number | undefined;
}

export interface CDOTAClientMsgCoinWagerToken {
  wagerTokenItemId?: string | undefined;
}

export interface CDOTAClientMsgRankWager {
  announceWager?: boolean | undefined;
}

export interface CDOTAClientMsgPlayerBounty {
  playerId?: number | undefined;
}

export interface CDOTAClientMsgEventPointsTip {
  recipientPlayerId?: number | undefined;
}

export interface CDOTAClientMsgExecuteOrders {
  orders: CDOTAMsgUnitOrder[];
  lastOrderLatency?: number | undefined;
}

export interface CDOTAClientMsgXPAlert {
  targetEntindex?: number | undefined;
  damageTaken?: number | undefined;
}

export interface CDOTAClientMsgTalentTreeAlert {
  targetEntindex?: number | undefined;
  abilityId?: number | undefined;
  slot?: number | undefined;
  learned?: boolean | undefined;
}

export interface CDOTAClientMsgKillcamDamageTaken {
  targetEntindex?: number | undefined;
  damageTaken?: number | undefined;
  itemType?: number | undefined;
  itemAbilityId?: number | undefined;
  heroName?: string | undefined;
  damageColor?: string | undefined;
}

export interface CDOTAClientMsgKillMyHero {
}

export interface CDOTAClientMsgQuestStatus {
  questId?: number | undefined;
  challengeId?: number | undefined;
  progress?: number | undefined;
  goal?: number | undefined;
  query?: number | undefined;
  failGametime?: number | undefined;
  itemAbilityId?: number | undefined;
}

export interface CDOTAClientMsgToggleAutoattack {
  mode?: number | undefined;
  showMessage?: boolean | undefined;
}

export interface CDOTAClientMsgSpecialAbility {
  abilityIndex?: number | undefined;
  targetEntindex?: number | undefined;
}

export interface CDOTAClientMsgSetEnemyStartingPosition {
  enemyPlayerId?: number | undefined;
  enemyStartingPosition?: number | undefined;
}

export interface CDOTAClientMsgSetDesiredWardPlacement {
  wardIndex?: number | undefined;
  wardX?: number | undefined;
  wardY?: number | undefined;
}

export interface CDOTAClientMsgRollDice {
  channelType?: number | undefined;
  rollMin?: number | undefined;
  rollMax?: number | undefined;
}

export interface CDOTAClientMsgFlipCoin {
  channelType?: number | undefined;
}

export interface CDOTAClientMsgRequestItemSuggestions {
}

export interface CDOTAClientMsgSuggestItemPreference {
  itemPreferences: CDOTAClientMsgSuggestItemPreference_ItemPreference[];
}

export interface CDOTAClientMsgSuggestItemPreference_ItemPreference {
  itemId?: number | undefined;
  preference?: EItemSuggestPreference | undefined;
}

export interface CDOTAClientMsgMakeTeamCaptain {
  playerId?: number | undefined;
}

export interface CDOTAClientMsgHelpTipSystemStateChanged {
  tipDisplayed?: boolean | undefined;
}

export interface CDOTAClientMsgRequestBulkCombatLog {
  gameTime?: number | undefined;
  duration?: number | undefined;
  recentPlayerDeath?: boolean | undefined;
  playerId?: number | undefined;
}

export interface CDOTAClientMsgAbilityDraftRequestAbility {
  requestedAbilityId?: number | undefined;
  ctrlIsDown?: boolean | undefined;
  requestedHeroId?: number | undefined;
}

export interface CDOTAClientMsgGuideSelectOption {
  option?: number | undefined;
  forceRecalculate?: boolean | undefined;
}

export interface CDOTAClientMsgGuideSelected {
  guideWorkshopId?: string | undefined;
  isPlusGuide?: boolean | undefined;
}

export interface CDOTAClientMsgDamageReport {
  targetHeroId?: number | undefined;
  sourceHeroId?: number | undefined;
  damageAmount?: number | undefined;
  broadcast?: boolean | undefined;
}

export interface CDOTAClientMsgSalutePlayer {
  targetPlayerId?: number | undefined;
  eventId?: number | undefined;
}

export interface CDOTAClientMsgGiftPlayer {
  targetPlayerId?: number | undefined;
  itemDefIndex?: number | undefined;
}

export interface CDOTAClientMsgGiftEveryone {
  itemDefIndex?: number | undefined;
}

export interface CDOTAClientMsgTipAlert {
  tipText?: string | undefined;
}

export interface CDOTAClientMsgEmptyTeleportAlert {
  targetEntindex?: number | undefined;
}

export interface CDOTAClientMsgSetCavernMapVariant {
  mapVariant?: number | undefined;
}

export interface CDOTAClientMsgPauseGameOrder {
  orderId?: number | undefined;
  data?: number | undefined;
}

export interface CDOTAClientMsgVersusScenePlayerBehavior {
  behavior?: EDOTAVersusScenePlayerBehavior | undefined;
  playActivity?: VersusScenePlayActivity | undefined;
  chatWheel?: VersusSceneChatWheel | undefined;
  playbackRate?: VersusScenePlaybackRate | undefined;
}

export interface CDOTAClientMsgEmptyItemSlotAlert {
  targetEntindex?: number | undefined;
  slotIndex?: number | undefined;
}

export interface CDOTAClientMsgAddOverwatchReportMarker {
  targetPlayerId?: number | undefined;
  reason?: EOverwatchReportReason | undefined;
  secondsAgo?: number | undefined;
}

export interface CDOTAClientMsgAddCommunicationsReportMarker {
  targetPlayerId?: number | undefined;
}

export interface CDOTAClientMsgAddCommunicationsBlockMarker {
  targetPlayerId?: number | undefined;
}

export interface CDOTAClientMsgAghsStatusAlert {
  sourcePlayerId?: number | undefined;
  targetPlayerId?: number | undefined;
  targetEntindex?: number | undefined;
  alertType?: number | undefined;
}

export interface CDOTAClientMsgPerfReport {
  averageFrameTime?: number | undefined;
  maxFrameTime?: number | undefined;
  averageComputeTime?: number | undefined;
  maxComputeTime?: number | undefined;
  averageClientTickTime?: number | undefined;
  maxClientTickTime?: number | undefined;
  averageClientSimulateTime?: number | undefined;
  maxClientSimulateTime?: number | undefined;
  averageOutputTime?: number | undefined;
  maxOutputTime?: number | undefined;
  averageWaitForRenderingToCompleteTime?: number | undefined;
  maxWaitForRenderingToCompleteTime?: number | undefined;
  averageSwapTime?: number | undefined;
  maxSwapTime?: number | undefined;
  averageFrameUpdateTime?: number | undefined;
  maxFrameUpdateTime?: number | undefined;
  averageIdleTime?: number | undefined;
  maxIdleTime?: number | undefined;
  averageInputProcessingTime?: number | undefined;
  maxInputProcessingTime?: number | undefined;
}

export interface CDOTAClientMsgContextualTipsSubscribeEntry {
  unsubscribe?: boolean | undefined;
  tipId?: number | undefined;
  priorDisplayCount?: number | undefined;
  variantsSeen: number[];
}

export interface CDOTAClientMsgContextualTipsSubscribe {
  tips: CDOTAClientMsgContextualTipsSubscribeEntry[];
}

export interface CDOTAClientMsgChatMessage {
  channelType?: number | undefined;
  messageText?: string | undefined;
}

export interface CDOTAClientMsgDuelAccepted {
  challengerPlayerId?: number | undefined;
  accepterPlayerId?: number | undefined;
}

export interface CDOTAClientMsgChooseNeutralItem {
  neutralItemIndex?: number | undefined;
  targetEntindex?: number | undefined;
  slotIndex?: number | undefined;
}

export interface CDOTAClientMsgRerollNeutralItem {
  targetEntindex?: number | undefined;
  slotIndex?: number | undefined;
}

export interface CDOTAClientMsgPlayerDraftPick {
  playerId?: number | undefined;
}

export interface CDOTAClientMsgPlayerDraftSuggest {
  playerId?: number | undefined;
}

export interface CDOTAClientMsgPlayerDraftPreferRole {
  roleIdx?: number | undefined;
  desired?: boolean | undefined;
}

export interface CDOTAClientMsgPlayerDraftPreferTeam {
  team?: number | undefined;
}

export interface CDOTAClientMsgAbilityAlert {
  abilityEntindex?: number | undefined;
  ctrlHeld?: boolean | undefined;
  ownerEntindex?: number | undefined;
  abilityId?: number | undefined;
  primaryCharges?: number | undefined;
  secondaryCharges?: number | undefined;
  reclaimTime?: number | undefined;
}

export interface CDOTAClientMsgSelectOverworldTokenRewards {
  tokenIds: number[];
}

export interface CDOTAClientMsgFacetAlert {
  facetStrhash?: number | undefined;
  heroEntindex?: number | undefined;
  ctrlHeld?: boolean | undefined;
}

export interface CDOTAClientMsgInnateAlert {
  abilityEntindex?: number | undefined;
  ctrlHeld?: boolean | undefined;
}

export interface CDOTAClientMsgSelectOverworldID {
  overworldId?: number | undefined;
}

export interface CDOTAClientMsgRoshanTimer {
  negative?: boolean | undefined;
}

export interface CDOTAClientMsgCraftNeutralItem {
}

export interface CDOTAClientMsgChooseCraftedNeutralItem {
  neutralItemIndex?: number | undefined;
  itemTier?: number | undefined;
  enhancementIndex?: number | undefined;
}

export interface CDOTAClientMsgTimerAlert {
  timerAlertType?: ETimerAlertType | undefined;
}

export interface CDOTAClientMsgMadstoneAlert {
  targetEntindex?: number | undefined;
}

function createBaseCDOTAClientMsgMapPing(): CDOTAClientMsgMapPing {
  return { locationPing: undefined };
}

export const CDOTAClientMsgMapPing = {
  encode(message: CDOTAClientMsgMapPing, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.locationPing !== undefined) {
      CDOTAMsgLocationPing.encode(message.locationPing, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAClientMsgMapPing {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAClientMsgMapPing();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.locationPing = CDOTAMsgLocationPing.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAClientMsgMapPing {
    return {
      locationPing: isSet(object.locationPing) ? CDOTAMsgLocationPing.fromJSON(object.locationPing) : undefined,
    };
  },

  toJSON(message: CDOTAClientMsgMapPing): unknown {
    const obj: any = {};
    if (message.locationPing !== undefined) {
      obj.locationPing = CDOTAMsgLocationPing.toJSON(message.locationPing);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAClientMsgMapPing>): CDOTAClientMsgMapPing {
    return CDOTAClientMsgMapPing.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAClientMsgMapPing>): CDOTAClientMsgMapPing {
    const message = createBaseCDOTAClientMsgMapPing();
    message.locationPing = (object.locationPing !== undefined && object.locationPing !== null)
      ? CDOTAMsgLocationPing.fromPartial(object.locationPing)
      : undefined;
    return message;
  },
};

function createBaseCDOTAClientMsgItemAlert(): CDOTAClientMsgItemAlert {
  return { itemAlert: undefined };
}

export const CDOTAClientMsgItemAlert = {
  encode(message: CDOTAClientMsgItemAlert, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.itemAlert !== undefined) {
      CDOTAMsgItemAlert.encode(message.itemAlert, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAClientMsgItemAlert {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAClientMsgItemAlert();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.itemAlert = CDOTAMsgItemAlert.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAClientMsgItemAlert {
    return { itemAlert: isSet(object.itemAlert) ? CDOTAMsgItemAlert.fromJSON(object.itemAlert) : undefined };
  },

  toJSON(message: CDOTAClientMsgItemAlert): unknown {
    const obj: any = {};
    if (message.itemAlert !== undefined) {
      obj.itemAlert = CDOTAMsgItemAlert.toJSON(message.itemAlert);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAClientMsgItemAlert>): CDOTAClientMsgItemAlert {
    return CDOTAClientMsgItemAlert.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAClientMsgItemAlert>): CDOTAClientMsgItemAlert {
    const message = createBaseCDOTAClientMsgItemAlert();
    message.itemAlert = (object.itemAlert !== undefined && object.itemAlert !== null)
      ? CDOTAMsgItemAlert.fromPartial(object.itemAlert)
      : undefined;
    return message;
  },
};

function createBaseCDOTAClientMsgEnemyItemAlert(): CDOTAClientMsgEnemyItemAlert {
  return {
    itemEntindex: -1,
    runeType: -1,
    itemLevel: -1,
    primaryCharges: -1,
    secondaryCharges: -1,
    abilityId: -1,
    ownerEntindex: -1,
  };
}

export const CDOTAClientMsgEnemyItemAlert = {
  encode(message: CDOTAClientMsgEnemyItemAlert, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.itemEntindex !== undefined && message.itemEntindex !== -1) {
      writer.uint32(8).int32(message.itemEntindex);
    }
    if (message.runeType !== undefined && message.runeType !== -1) {
      writer.uint32(16).int32(message.runeType);
    }
    if (message.itemLevel !== undefined && message.itemLevel !== -1) {
      writer.uint32(24).int32(message.itemLevel);
    }
    if (message.primaryCharges !== undefined && message.primaryCharges !== -1) {
      writer.uint32(32).int32(message.primaryCharges);
    }
    if (message.secondaryCharges !== undefined && message.secondaryCharges !== -1) {
      writer.uint32(40).int32(message.secondaryCharges);
    }
    if (message.abilityId !== undefined && message.abilityId !== -1) {
      writer.uint32(48).int32(message.abilityId);
    }
    if (message.ownerEntindex !== undefined && message.ownerEntindex !== -1) {
      writer.uint32(56).int32(message.ownerEntindex);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAClientMsgEnemyItemAlert {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAClientMsgEnemyItemAlert();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.itemEntindex = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.runeType = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.itemLevel = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.primaryCharges = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.secondaryCharges = reader.int32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.abilityId = reader.int32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.ownerEntindex = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAClientMsgEnemyItemAlert {
    return {
      itemEntindex: isSet(object.itemEntindex) ? globalThis.Number(object.itemEntindex) : -1,
      runeType: isSet(object.runeType) ? globalThis.Number(object.runeType) : -1,
      itemLevel: isSet(object.itemLevel) ? globalThis.Number(object.itemLevel) : -1,
      primaryCharges: isSet(object.primaryCharges) ? globalThis.Number(object.primaryCharges) : -1,
      secondaryCharges: isSet(object.secondaryCharges) ? globalThis.Number(object.secondaryCharges) : -1,
      abilityId: isSet(object.abilityId) ? globalThis.Number(object.abilityId) : -1,
      ownerEntindex: isSet(object.ownerEntindex) ? globalThis.Number(object.ownerEntindex) : -1,
    };
  },

  toJSON(message: CDOTAClientMsgEnemyItemAlert): unknown {
    const obj: any = {};
    if (message.itemEntindex !== undefined && message.itemEntindex !== -1) {
      obj.itemEntindex = Math.round(message.itemEntindex);
    }
    if (message.runeType !== undefined && message.runeType !== -1) {
      obj.runeType = Math.round(message.runeType);
    }
    if (message.itemLevel !== undefined && message.itemLevel !== -1) {
      obj.itemLevel = Math.round(message.itemLevel);
    }
    if (message.primaryCharges !== undefined && message.primaryCharges !== -1) {
      obj.primaryCharges = Math.round(message.primaryCharges);
    }
    if (message.secondaryCharges !== undefined && message.secondaryCharges !== -1) {
      obj.secondaryCharges = Math.round(message.secondaryCharges);
    }
    if (message.abilityId !== undefined && message.abilityId !== -1) {
      obj.abilityId = Math.round(message.abilityId);
    }
    if (message.ownerEntindex !== undefined && message.ownerEntindex !== -1) {
      obj.ownerEntindex = Math.round(message.ownerEntindex);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAClientMsgEnemyItemAlert>): CDOTAClientMsgEnemyItemAlert {
    return CDOTAClientMsgEnemyItemAlert.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAClientMsgEnemyItemAlert>): CDOTAClientMsgEnemyItemAlert {
    const message = createBaseCDOTAClientMsgEnemyItemAlert();
    message.itemEntindex = object.itemEntindex ?? -1;
    message.runeType = object.runeType ?? -1;
    message.itemLevel = object.itemLevel ?? -1;
    message.primaryCharges = object.primaryCharges ?? -1;
    message.secondaryCharges = object.secondaryCharges ?? -1;
    message.abilityId = object.abilityId ?? -1;
    message.ownerEntindex = object.ownerEntindex ?? -1;
    return message;
  },
};

function createBaseCDOTAClientMsgModifierAlert(): CDOTAClientMsgModifierAlert {
  return { buffInternalIndex: 0, targetEntindex: -1 };
}

export const CDOTAClientMsgModifierAlert = {
  encode(message: CDOTAClientMsgModifierAlert, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.buffInternalIndex !== undefined && message.buffInternalIndex !== 0) {
      writer.uint32(8).int32(message.buffInternalIndex);
    }
    if (message.targetEntindex !== undefined && message.targetEntindex !== -1) {
      writer.uint32(16).int32(message.targetEntindex);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAClientMsgModifierAlert {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAClientMsgModifierAlert();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.buffInternalIndex = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.targetEntindex = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAClientMsgModifierAlert {
    return {
      buffInternalIndex: isSet(object.buffInternalIndex) ? globalThis.Number(object.buffInternalIndex) : 0,
      targetEntindex: isSet(object.targetEntindex) ? globalThis.Number(object.targetEntindex) : -1,
    };
  },

  toJSON(message: CDOTAClientMsgModifierAlert): unknown {
    const obj: any = {};
    if (message.buffInternalIndex !== undefined && message.buffInternalIndex !== 0) {
      obj.buffInternalIndex = Math.round(message.buffInternalIndex);
    }
    if (message.targetEntindex !== undefined && message.targetEntindex !== -1) {
      obj.targetEntindex = Math.round(message.targetEntindex);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAClientMsgModifierAlert>): CDOTAClientMsgModifierAlert {
    return CDOTAClientMsgModifierAlert.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAClientMsgModifierAlert>): CDOTAClientMsgModifierAlert {
    const message = createBaseCDOTAClientMsgModifierAlert();
    message.buffInternalIndex = object.buffInternalIndex ?? 0;
    message.targetEntindex = object.targetEntindex ?? -1;
    return message;
  },
};

function createBaseCDOTAClientMsgClickedBuff(): CDOTAClientMsgClickedBuff {
  return { buffInternalIndex: 0, targetEntindex: -1 };
}

export const CDOTAClientMsgClickedBuff = {
  encode(message: CDOTAClientMsgClickedBuff, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.buffInternalIndex !== undefined && message.buffInternalIndex !== 0) {
      writer.uint32(8).int32(message.buffInternalIndex);
    }
    if (message.targetEntindex !== undefined && message.targetEntindex !== -1) {
      writer.uint32(16).int32(message.targetEntindex);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAClientMsgClickedBuff {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAClientMsgClickedBuff();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.buffInternalIndex = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.targetEntindex = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAClientMsgClickedBuff {
    return {
      buffInternalIndex: isSet(object.buffInternalIndex) ? globalThis.Number(object.buffInternalIndex) : 0,
      targetEntindex: isSet(object.targetEntindex) ? globalThis.Number(object.targetEntindex) : -1,
    };
  },

  toJSON(message: CDOTAClientMsgClickedBuff): unknown {
    const obj: any = {};
    if (message.buffInternalIndex !== undefined && message.buffInternalIndex !== 0) {
      obj.buffInternalIndex = Math.round(message.buffInternalIndex);
    }
    if (message.targetEntindex !== undefined && message.targetEntindex !== -1) {
      obj.targetEntindex = Math.round(message.targetEntindex);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAClientMsgClickedBuff>): CDOTAClientMsgClickedBuff {
    return CDOTAClientMsgClickedBuff.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAClientMsgClickedBuff>): CDOTAClientMsgClickedBuff {
    const message = createBaseCDOTAClientMsgClickedBuff();
    message.buffInternalIndex = object.buffInternalIndex ?? 0;
    message.targetEntindex = object.targetEntindex ?? -1;
    return message;
  },
};

function createBaseCDOTAClientMsgHPManaAlert(): CDOTAClientMsgHPManaAlert {
  return { targetEntindex: -1, showRawValues: false };
}

export const CDOTAClientMsgHPManaAlert = {
  encode(message: CDOTAClientMsgHPManaAlert, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.targetEntindex !== undefined && message.targetEntindex !== -1) {
      writer.uint32(8).int32(message.targetEntindex);
    }
    if (message.showRawValues !== undefined && message.showRawValues !== false) {
      writer.uint32(16).bool(message.showRawValues);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAClientMsgHPManaAlert {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAClientMsgHPManaAlert();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.targetEntindex = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.showRawValues = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAClientMsgHPManaAlert {
    return {
      targetEntindex: isSet(object.targetEntindex) ? globalThis.Number(object.targetEntindex) : -1,
      showRawValues: isSet(object.showRawValues) ? globalThis.Boolean(object.showRawValues) : false,
    };
  },

  toJSON(message: CDOTAClientMsgHPManaAlert): unknown {
    const obj: any = {};
    if (message.targetEntindex !== undefined && message.targetEntindex !== -1) {
      obj.targetEntindex = Math.round(message.targetEntindex);
    }
    if (message.showRawValues !== undefined && message.showRawValues !== false) {
      obj.showRawValues = message.showRawValues;
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAClientMsgHPManaAlert>): CDOTAClientMsgHPManaAlert {
    return CDOTAClientMsgHPManaAlert.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAClientMsgHPManaAlert>): CDOTAClientMsgHPManaAlert {
    const message = createBaseCDOTAClientMsgHPManaAlert();
    message.targetEntindex = object.targetEntindex ?? -1;
    message.showRawValues = object.showRawValues ?? false;
    return message;
  },
};

function createBaseCDOTAClientMsgNeutralCampAlert(): CDOTAClientMsgNeutralCampAlert {
  return { spawnerEntindex: -1, unitEntindex: -1, stackRequest: false };
}

export const CDOTAClientMsgNeutralCampAlert = {
  encode(message: CDOTAClientMsgNeutralCampAlert, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.spawnerEntindex !== undefined && message.spawnerEntindex !== -1) {
      writer.uint32(8).int32(message.spawnerEntindex);
    }
    if (message.unitEntindex !== undefined && message.unitEntindex !== -1) {
      writer.uint32(16).int32(message.unitEntindex);
    }
    if (message.stackRequest !== undefined && message.stackRequest !== false) {
      writer.uint32(24).bool(message.stackRequest);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAClientMsgNeutralCampAlert {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAClientMsgNeutralCampAlert();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.spawnerEntindex = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.unitEntindex = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.stackRequest = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAClientMsgNeutralCampAlert {
    return {
      spawnerEntindex: isSet(object.spawnerEntindex) ? globalThis.Number(object.spawnerEntindex) : -1,
      unitEntindex: isSet(object.unitEntindex) ? globalThis.Number(object.unitEntindex) : -1,
      stackRequest: isSet(object.stackRequest) ? globalThis.Boolean(object.stackRequest) : false,
    };
  },

  toJSON(message: CDOTAClientMsgNeutralCampAlert): unknown {
    const obj: any = {};
    if (message.spawnerEntindex !== undefined && message.spawnerEntindex !== -1) {
      obj.spawnerEntindex = Math.round(message.spawnerEntindex);
    }
    if (message.unitEntindex !== undefined && message.unitEntindex !== -1) {
      obj.unitEntindex = Math.round(message.unitEntindex);
    }
    if (message.stackRequest !== undefined && message.stackRequest !== false) {
      obj.stackRequest = message.stackRequest;
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAClientMsgNeutralCampAlert>): CDOTAClientMsgNeutralCampAlert {
    return CDOTAClientMsgNeutralCampAlert.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAClientMsgNeutralCampAlert>): CDOTAClientMsgNeutralCampAlert {
    const message = createBaseCDOTAClientMsgNeutralCampAlert();
    message.spawnerEntindex = object.spawnerEntindex ?? -1;
    message.unitEntindex = object.unitEntindex ?? -1;
    message.stackRequest = object.stackRequest ?? false;
    return message;
  },
};

function createBaseCDOTAClientMsgGlyphAlert(): CDOTAClientMsgGlyphAlert {
  return { negative: false };
}

export const CDOTAClientMsgGlyphAlert = {
  encode(message: CDOTAClientMsgGlyphAlert, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.negative !== undefined && message.negative !== false) {
      writer.uint32(8).bool(message.negative);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAClientMsgGlyphAlert {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAClientMsgGlyphAlert();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.negative = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAClientMsgGlyphAlert {
    return { negative: isSet(object.negative) ? globalThis.Boolean(object.negative) : false };
  },

  toJSON(message: CDOTAClientMsgGlyphAlert): unknown {
    const obj: any = {};
    if (message.negative !== undefined && message.negative !== false) {
      obj.negative = message.negative;
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAClientMsgGlyphAlert>): CDOTAClientMsgGlyphAlert {
    return CDOTAClientMsgGlyphAlert.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAClientMsgGlyphAlert>): CDOTAClientMsgGlyphAlert {
    const message = createBaseCDOTAClientMsgGlyphAlert();
    message.negative = object.negative ?? false;
    return message;
  },
};

function createBaseCDOTAClientMsgRadarAlert(): CDOTAClientMsgRadarAlert {
  return { negative: false };
}

export const CDOTAClientMsgRadarAlert = {
  encode(message: CDOTAClientMsgRadarAlert, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.negative !== undefined && message.negative !== false) {
      writer.uint32(8).bool(message.negative);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAClientMsgRadarAlert {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAClientMsgRadarAlert();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.negative = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAClientMsgRadarAlert {
    return { negative: isSet(object.negative) ? globalThis.Boolean(object.negative) : false };
  },

  toJSON(message: CDOTAClientMsgRadarAlert): unknown {
    const obj: any = {};
    if (message.negative !== undefined && message.negative !== false) {
      obj.negative = message.negative;
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAClientMsgRadarAlert>): CDOTAClientMsgRadarAlert {
    return CDOTAClientMsgRadarAlert.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAClientMsgRadarAlert>): CDOTAClientMsgRadarAlert {
    const message = createBaseCDOTAClientMsgRadarAlert();
    message.negative = object.negative ?? false;
    return message;
  },
};

function createBaseCDOTAClientMsgMapLine(): CDOTAClientMsgMapLine {
  return { mapline: undefined };
}

export const CDOTAClientMsgMapLine = {
  encode(message: CDOTAClientMsgMapLine, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.mapline !== undefined) {
      CDOTAMsgMapLine.encode(message.mapline, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAClientMsgMapLine {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAClientMsgMapLine();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.mapline = CDOTAMsgMapLine.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAClientMsgMapLine {
    return { mapline: isSet(object.mapline) ? CDOTAMsgMapLine.fromJSON(object.mapline) : undefined };
  },

  toJSON(message: CDOTAClientMsgMapLine): unknown {
    const obj: any = {};
    if (message.mapline !== undefined) {
      obj.mapline = CDOTAMsgMapLine.toJSON(message.mapline);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAClientMsgMapLine>): CDOTAClientMsgMapLine {
    return CDOTAClientMsgMapLine.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAClientMsgMapLine>): CDOTAClientMsgMapLine {
    const message = createBaseCDOTAClientMsgMapLine();
    message.mapline = (object.mapline !== undefined && object.mapline !== null)
      ? CDOTAMsgMapLine.fromPartial(object.mapline)
      : undefined;
    return message;
  },
};

function createBaseCDOTAClientMsgAspectRatio(): CDOTAClientMsgAspectRatio {
  return { ratio: 0 };
}

export const CDOTAClientMsgAspectRatio = {
  encode(message: CDOTAClientMsgAspectRatio, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.ratio !== undefined && message.ratio !== 0) {
      writer.uint32(13).float(message.ratio);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAClientMsgAspectRatio {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAClientMsgAspectRatio();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.ratio = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAClientMsgAspectRatio {
    return { ratio: isSet(object.ratio) ? globalThis.Number(object.ratio) : 0 };
  },

  toJSON(message: CDOTAClientMsgAspectRatio): unknown {
    const obj: any = {};
    if (message.ratio !== undefined && message.ratio !== 0) {
      obj.ratio = message.ratio;
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAClientMsgAspectRatio>): CDOTAClientMsgAspectRatio {
    return CDOTAClientMsgAspectRatio.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAClientMsgAspectRatio>): CDOTAClientMsgAspectRatio {
    const message = createBaseCDOTAClientMsgAspectRatio();
    message.ratio = object.ratio ?? 0;
    return message;
  },
};

function createBaseCDOTAClientMsgUnitsAutoAttackMode(): CDOTAClientMsgUnitsAutoAttackMode {
  return { mode: -1, unitType: 0 };
}

export const CDOTAClientMsgUnitsAutoAttackMode = {
  encode(message: CDOTAClientMsgUnitsAutoAttackMode, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.mode !== undefined && message.mode !== -1) {
      writer.uint32(8).int32(message.mode);
    }
    if (message.unitType !== undefined && message.unitType !== 0) {
      writer.uint32(16).int32(message.unitType);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAClientMsgUnitsAutoAttackMode {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAClientMsgUnitsAutoAttackMode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.mode = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.unitType = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAClientMsgUnitsAutoAttackMode {
    return {
      mode: isSet(object.mode) ? cDOTAClientMsgUnitsAutoAttackMode_EModeFromJSON(object.mode) : -1,
      unitType: isSet(object.unitType) ? cDOTAClientMsgUnitsAutoAttackMode_EUnitTypeFromJSON(object.unitType) : 0,
    };
  },

  toJSON(message: CDOTAClientMsgUnitsAutoAttackMode): unknown {
    const obj: any = {};
    if (message.mode !== undefined && message.mode !== -1) {
      obj.mode = cDOTAClientMsgUnitsAutoAttackMode_EModeToJSON(message.mode);
    }
    if (message.unitType !== undefined && message.unitType !== 0) {
      obj.unitType = cDOTAClientMsgUnitsAutoAttackMode_EUnitTypeToJSON(message.unitType);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAClientMsgUnitsAutoAttackMode>): CDOTAClientMsgUnitsAutoAttackMode {
    return CDOTAClientMsgUnitsAutoAttackMode.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAClientMsgUnitsAutoAttackMode>): CDOTAClientMsgUnitsAutoAttackMode {
    const message = createBaseCDOTAClientMsgUnitsAutoAttackMode();
    message.mode = object.mode ?? -1;
    message.unitType = object.unitType ?? 0;
    return message;
  },
};

function createBaseCDOTAClientMsgUnitsAutoAttackAfterSpell(): CDOTAClientMsgUnitsAutoAttackAfterSpell {
  return { enabled: false };
}

export const CDOTAClientMsgUnitsAutoAttackAfterSpell = {
  encode(message: CDOTAClientMsgUnitsAutoAttackAfterSpell, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.enabled !== undefined && message.enabled !== false) {
      writer.uint32(8).bool(message.enabled);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAClientMsgUnitsAutoAttackAfterSpell {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAClientMsgUnitsAutoAttackAfterSpell();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.enabled = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAClientMsgUnitsAutoAttackAfterSpell {
    return { enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false };
  },

  toJSON(message: CDOTAClientMsgUnitsAutoAttackAfterSpell): unknown {
    const obj: any = {};
    if (message.enabled !== undefined && message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAClientMsgUnitsAutoAttackAfterSpell>): CDOTAClientMsgUnitsAutoAttackAfterSpell {
    return CDOTAClientMsgUnitsAutoAttackAfterSpell.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAClientMsgUnitsAutoAttackAfterSpell>): CDOTAClientMsgUnitsAutoAttackAfterSpell {
    const message = createBaseCDOTAClientMsgUnitsAutoAttackAfterSpell();
    message.enabled = object.enabled ?? false;
    return message;
  },
};

function createBaseCDOTAClientMsgTeleportRequiresHalt(): CDOTAClientMsgTeleportRequiresHalt {
  return { enabled: false };
}

export const CDOTAClientMsgTeleportRequiresHalt = {
  encode(message: CDOTAClientMsgTeleportRequiresHalt, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.enabled !== undefined && message.enabled !== false) {
      writer.uint32(8).bool(message.enabled);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAClientMsgTeleportRequiresHalt {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAClientMsgTeleportRequiresHalt();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.enabled = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAClientMsgTeleportRequiresHalt {
    return { enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false };
  },

  toJSON(message: CDOTAClientMsgTeleportRequiresHalt): unknown {
    const obj: any = {};
    if (message.enabled !== undefined && message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAClientMsgTeleportRequiresHalt>): CDOTAClientMsgTeleportRequiresHalt {
    return CDOTAClientMsgTeleportRequiresHalt.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAClientMsgTeleportRequiresHalt>): CDOTAClientMsgTeleportRequiresHalt {
    const message = createBaseCDOTAClientMsgTeleportRequiresHalt();
    message.enabled = object.enabled ?? false;
    return message;
  },
};

function createBaseCDOTAClientMsgChannelRequiresHalt(): CDOTAClientMsgChannelRequiresHalt {
  return { enabled: false };
}

export const CDOTAClientMsgChannelRequiresHalt = {
  encode(message: CDOTAClientMsgChannelRequiresHalt, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.enabled !== undefined && message.enabled !== false) {
      writer.uint32(8).bool(message.enabled);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAClientMsgChannelRequiresHalt {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAClientMsgChannelRequiresHalt();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.enabled = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAClientMsgChannelRequiresHalt {
    return { enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false };
  },

  toJSON(message: CDOTAClientMsgChannelRequiresHalt): unknown {
    const obj: any = {};
    if (message.enabled !== undefined && message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAClientMsgChannelRequiresHalt>): CDOTAClientMsgChannelRequiresHalt {
    return CDOTAClientMsgChannelRequiresHalt.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAClientMsgChannelRequiresHalt>): CDOTAClientMsgChannelRequiresHalt {
    const message = createBaseCDOTAClientMsgChannelRequiresHalt();
    message.enabled = object.enabled ?? false;
    return message;
  },
};

function createBaseCDOTAClientMsgSearchString(): CDOTAClientMsgSearchString {
  return { search: "" };
}

export const CDOTAClientMsgSearchString = {
  encode(message: CDOTAClientMsgSearchString, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.search !== undefined && message.search !== "") {
      writer.uint32(10).string(message.search);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAClientMsgSearchString {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAClientMsgSearchString();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.search = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAClientMsgSearchString {
    return { search: isSet(object.search) ? globalThis.String(object.search) : "" };
  },

  toJSON(message: CDOTAClientMsgSearchString): unknown {
    const obj: any = {};
    if (message.search !== undefined && message.search !== "") {
      obj.search = message.search;
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAClientMsgSearchString>): CDOTAClientMsgSearchString {
    return CDOTAClientMsgSearchString.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAClientMsgSearchString>): CDOTAClientMsgSearchString {
    const message = createBaseCDOTAClientMsgSearchString();
    message.search = object.search ?? "";
    return message;
  },
};

function createBaseCDOTAClientMsgPause(): CDOTAClientMsgPause {
  return {};
}

export const CDOTAClientMsgPause = {
  encode(_: CDOTAClientMsgPause, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAClientMsgPause {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAClientMsgPause();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CDOTAClientMsgPause {
    return {};
  },

  toJSON(_: CDOTAClientMsgPause): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<CDOTAClientMsgPause>): CDOTAClientMsgPause {
    return CDOTAClientMsgPause.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<CDOTAClientMsgPause>): CDOTAClientMsgPause {
    const message = createBaseCDOTAClientMsgPause();
    return message;
  },
};

function createBaseCDOTAClientMsgShopViewMode(): CDOTAClientMsgShopViewMode {
  return { mode: 0 };
}

export const CDOTAClientMsgShopViewMode = {
  encode(message: CDOTAClientMsgShopViewMode, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.mode !== undefined && message.mode !== 0) {
      writer.uint32(8).uint32(message.mode);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAClientMsgShopViewMode {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAClientMsgShopViewMode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.mode = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAClientMsgShopViewMode {
    return { mode: isSet(object.mode) ? globalThis.Number(object.mode) : 0 };
  },

  toJSON(message: CDOTAClientMsgShopViewMode): unknown {
    const obj: any = {};
    if (message.mode !== undefined && message.mode !== 0) {
      obj.mode = Math.round(message.mode);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAClientMsgShopViewMode>): CDOTAClientMsgShopViewMode {
    return CDOTAClientMsgShopViewMode.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAClientMsgShopViewMode>): CDOTAClientMsgShopViewMode {
    const message = createBaseCDOTAClientMsgShopViewMode();
    message.mode = object.mode ?? 0;
    return message;
  },
};

function createBaseCDOTAClientMsgSetUnitShareFlag(): CDOTAClientMsgSetUnitShareFlag {
  return { playerId: -1, flag: 0, state: false };
}

export const CDOTAClientMsgSetUnitShareFlag = {
  encode(message: CDOTAClientMsgSetUnitShareFlag, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.playerId !== undefined && message.playerId !== -1) {
      writer.uint32(8).int32(message.playerId);
    }
    if (message.flag !== undefined && message.flag !== 0) {
      writer.uint32(16).uint32(message.flag);
    }
    if (message.state !== undefined && message.state !== false) {
      writer.uint32(24).bool(message.state);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAClientMsgSetUnitShareFlag {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAClientMsgSetUnitShareFlag();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.playerId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.flag = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.state = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAClientMsgSetUnitShareFlag {
    return {
      playerId: isSet(object.playerId) ? globalThis.Number(object.playerId) : -1,
      flag: isSet(object.flag) ? globalThis.Number(object.flag) : 0,
      state: isSet(object.state) ? globalThis.Boolean(object.state) : false,
    };
  },

  toJSON(message: CDOTAClientMsgSetUnitShareFlag): unknown {
    const obj: any = {};
    if (message.playerId !== undefined && message.playerId !== -1) {
      obj.playerId = Math.round(message.playerId);
    }
    if (message.flag !== undefined && message.flag !== 0) {
      obj.flag = Math.round(message.flag);
    }
    if (message.state !== undefined && message.state !== false) {
      obj.state = message.state;
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAClientMsgSetUnitShareFlag>): CDOTAClientMsgSetUnitShareFlag {
    return CDOTAClientMsgSetUnitShareFlag.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAClientMsgSetUnitShareFlag>): CDOTAClientMsgSetUnitShareFlag {
    const message = createBaseCDOTAClientMsgSetUnitShareFlag();
    message.playerId = object.playerId ?? -1;
    message.flag = object.flag ?? 0;
    message.state = object.state ?? false;
    return message;
  },
};

function createBaseCDOTAClientMsgSwapRequest(): CDOTAClientMsgSwapRequest {
  return { playerId: -1 };
}

export const CDOTAClientMsgSwapRequest = {
  encode(message: CDOTAClientMsgSwapRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.playerId !== undefined && message.playerId !== -1) {
      writer.uint32(8).int32(message.playerId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAClientMsgSwapRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAClientMsgSwapRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.playerId = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAClientMsgSwapRequest {
    return { playerId: isSet(object.playerId) ? globalThis.Number(object.playerId) : -1 };
  },

  toJSON(message: CDOTAClientMsgSwapRequest): unknown {
    const obj: any = {};
    if (message.playerId !== undefined && message.playerId !== -1) {
      obj.playerId = Math.round(message.playerId);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAClientMsgSwapRequest>): CDOTAClientMsgSwapRequest {
    return CDOTAClientMsgSwapRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAClientMsgSwapRequest>): CDOTAClientMsgSwapRequest {
    const message = createBaseCDOTAClientMsgSwapRequest();
    message.playerId = object.playerId ?? -1;
    return message;
  },
};

function createBaseCDOTAClientMsgSwapAccept(): CDOTAClientMsgSwapAccept {
  return { playerId: -1 };
}

export const CDOTAClientMsgSwapAccept = {
  encode(message: CDOTAClientMsgSwapAccept, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.playerId !== undefined && message.playerId !== -1) {
      writer.uint32(8).int32(message.playerId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAClientMsgSwapAccept {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAClientMsgSwapAccept();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.playerId = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAClientMsgSwapAccept {
    return { playerId: isSet(object.playerId) ? globalThis.Number(object.playerId) : -1 };
  },

  toJSON(message: CDOTAClientMsgSwapAccept): unknown {
    const obj: any = {};
    if (message.playerId !== undefined && message.playerId !== -1) {
      obj.playerId = Math.round(message.playerId);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAClientMsgSwapAccept>): CDOTAClientMsgSwapAccept {
    return CDOTAClientMsgSwapAccept.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAClientMsgSwapAccept>): CDOTAClientMsgSwapAccept {
    const message = createBaseCDOTAClientMsgSwapAccept();
    message.playerId = object.playerId ?? -1;
    return message;
  },
};

function createBaseCDOTAClientMsgWorldLine(): CDOTAClientMsgWorldLine {
  return { worldline: undefined };
}

export const CDOTAClientMsgWorldLine = {
  encode(message: CDOTAClientMsgWorldLine, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.worldline !== undefined) {
      CDOTAMsgWorldLine.encode(message.worldline, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAClientMsgWorldLine {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAClientMsgWorldLine();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.worldline = CDOTAMsgWorldLine.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAClientMsgWorldLine {
    return { worldline: isSet(object.worldline) ? CDOTAMsgWorldLine.fromJSON(object.worldline) : undefined };
  },

  toJSON(message: CDOTAClientMsgWorldLine): unknown {
    const obj: any = {};
    if (message.worldline !== undefined) {
      obj.worldline = CDOTAMsgWorldLine.toJSON(message.worldline);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAClientMsgWorldLine>): CDOTAClientMsgWorldLine {
    return CDOTAClientMsgWorldLine.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAClientMsgWorldLine>): CDOTAClientMsgWorldLine {
    const message = createBaseCDOTAClientMsgWorldLine();
    message.worldline = (object.worldline !== undefined && object.worldline !== null)
      ? CDOTAMsgWorldLine.fromPartial(object.worldline)
      : undefined;
    return message;
  },
};

function createBaseCDOTAClientMsgRequestGraphUpdate(): CDOTAClientMsgRequestGraphUpdate {
  return {};
}

export const CDOTAClientMsgRequestGraphUpdate = {
  encode(_: CDOTAClientMsgRequestGraphUpdate, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAClientMsgRequestGraphUpdate {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAClientMsgRequestGraphUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CDOTAClientMsgRequestGraphUpdate {
    return {};
  },

  toJSON(_: CDOTAClientMsgRequestGraphUpdate): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<CDOTAClientMsgRequestGraphUpdate>): CDOTAClientMsgRequestGraphUpdate {
    return CDOTAClientMsgRequestGraphUpdate.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<CDOTAClientMsgRequestGraphUpdate>): CDOTAClientMsgRequestGraphUpdate {
    const message = createBaseCDOTAClientMsgRequestGraphUpdate();
    return message;
  },
};

function createBaseCDOTAClientMsgChatWheel(): CDOTAClientMsgChatWheel {
  return { chatMessageId: 4294967295, paramHeroId: 0, emoticonId: 0 };
}

export const CDOTAClientMsgChatWheel = {
  encode(message: CDOTAClientMsgChatWheel, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.chatMessageId !== undefined && message.chatMessageId !== 4294967295) {
      writer.uint32(8).uint32(message.chatMessageId);
    }
    if (message.paramHeroId !== undefined && message.paramHeroId !== 0) {
      writer.uint32(16).int32(message.paramHeroId);
    }
    if (message.emoticonId !== undefined && message.emoticonId !== 0) {
      writer.uint32(24).uint32(message.emoticonId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAClientMsgChatWheel {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAClientMsgChatWheel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.chatMessageId = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.paramHeroId = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.emoticonId = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAClientMsgChatWheel {
    return {
      chatMessageId: isSet(object.chatMessageId) ? globalThis.Number(object.chatMessageId) : 4294967295,
      paramHeroId: isSet(object.paramHeroId) ? globalThis.Number(object.paramHeroId) : 0,
      emoticonId: isSet(object.emoticonId) ? globalThis.Number(object.emoticonId) : 0,
    };
  },

  toJSON(message: CDOTAClientMsgChatWheel): unknown {
    const obj: any = {};
    if (message.chatMessageId !== undefined && message.chatMessageId !== 4294967295) {
      obj.chatMessageId = Math.round(message.chatMessageId);
    }
    if (message.paramHeroId !== undefined && message.paramHeroId !== 0) {
      obj.paramHeroId = Math.round(message.paramHeroId);
    }
    if (message.emoticonId !== undefined && message.emoticonId !== 0) {
      obj.emoticonId = Math.round(message.emoticonId);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAClientMsgChatWheel>): CDOTAClientMsgChatWheel {
    return CDOTAClientMsgChatWheel.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAClientMsgChatWheel>): CDOTAClientMsgChatWheel {
    const message = createBaseCDOTAClientMsgChatWheel();
    message.chatMessageId = object.chatMessageId ?? 4294967295;
    message.paramHeroId = object.paramHeroId ?? 0;
    message.emoticonId = object.emoticonId ?? 0;
    return message;
  },
};

function createBaseCDOTAClientMsgSendStatPopup(): CDOTAClientMsgSendStatPopup {
  return { statpopup: undefined };
}

export const CDOTAClientMsgSendStatPopup = {
  encode(message: CDOTAClientMsgSendStatPopup, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.statpopup !== undefined) {
      CDOTAMsgSendStatPopup.encode(message.statpopup, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAClientMsgSendStatPopup {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAClientMsgSendStatPopup();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.statpopup = CDOTAMsgSendStatPopup.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAClientMsgSendStatPopup {
    return { statpopup: isSet(object.statpopup) ? CDOTAMsgSendStatPopup.fromJSON(object.statpopup) : undefined };
  },

  toJSON(message: CDOTAClientMsgSendStatPopup): unknown {
    const obj: any = {};
    if (message.statpopup !== undefined) {
      obj.statpopup = CDOTAMsgSendStatPopup.toJSON(message.statpopup);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAClientMsgSendStatPopup>): CDOTAClientMsgSendStatPopup {
    return CDOTAClientMsgSendStatPopup.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAClientMsgSendStatPopup>): CDOTAClientMsgSendStatPopup {
    const message = createBaseCDOTAClientMsgSendStatPopup();
    message.statpopup = (object.statpopup !== undefined && object.statpopup !== null)
      ? CDOTAMsgSendStatPopup.fromPartial(object.statpopup)
      : undefined;
    return message;
  },
};

function createBaseCDOTAClientMsgDismissAllStatPopups(): CDOTAClientMsgDismissAllStatPopups {
  return { dismissallmsg: undefined };
}

export const CDOTAClientMsgDismissAllStatPopups = {
  encode(message: CDOTAClientMsgDismissAllStatPopups, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.dismissallmsg !== undefined) {
      CDOTAMsgDismissAllStatPopups.encode(message.dismissallmsg, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAClientMsgDismissAllStatPopups {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAClientMsgDismissAllStatPopups();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.dismissallmsg = CDOTAMsgDismissAllStatPopups.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAClientMsgDismissAllStatPopups {
    return {
      dismissallmsg: isSet(object.dismissallmsg)
        ? CDOTAMsgDismissAllStatPopups.fromJSON(object.dismissallmsg)
        : undefined,
    };
  },

  toJSON(message: CDOTAClientMsgDismissAllStatPopups): unknown {
    const obj: any = {};
    if (message.dismissallmsg !== undefined) {
      obj.dismissallmsg = CDOTAMsgDismissAllStatPopups.toJSON(message.dismissallmsg);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAClientMsgDismissAllStatPopups>): CDOTAClientMsgDismissAllStatPopups {
    return CDOTAClientMsgDismissAllStatPopups.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAClientMsgDismissAllStatPopups>): CDOTAClientMsgDismissAllStatPopups {
    const message = createBaseCDOTAClientMsgDismissAllStatPopups();
    message.dismissallmsg = (object.dismissallmsg !== undefined && object.dismissallmsg !== null)
      ? CDOTAMsgDismissAllStatPopups.fromPartial(object.dismissallmsg)
      : undefined;
    return message;
  },
};

function createBaseCDOTAClientMsgBeginLastHitChallenge(): CDOTAClientMsgBeginLastHitChallenge {
  return { chosenLane: 0, helperEnabled: false };
}

export const CDOTAClientMsgBeginLastHitChallenge = {
  encode(message: CDOTAClientMsgBeginLastHitChallenge, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.chosenLane !== undefined && message.chosenLane !== 0) {
      writer.uint32(8).uint32(message.chosenLane);
    }
    if (message.helperEnabled !== undefined && message.helperEnabled !== false) {
      writer.uint32(16).bool(message.helperEnabled);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAClientMsgBeginLastHitChallenge {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAClientMsgBeginLastHitChallenge();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.chosenLane = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.helperEnabled = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAClientMsgBeginLastHitChallenge {
    return {
      chosenLane: isSet(object.chosenLane) ? globalThis.Number(object.chosenLane) : 0,
      helperEnabled: isSet(object.helperEnabled) ? globalThis.Boolean(object.helperEnabled) : false,
    };
  },

  toJSON(message: CDOTAClientMsgBeginLastHitChallenge): unknown {
    const obj: any = {};
    if (message.chosenLane !== undefined && message.chosenLane !== 0) {
      obj.chosenLane = Math.round(message.chosenLane);
    }
    if (message.helperEnabled !== undefined && message.helperEnabled !== false) {
      obj.helperEnabled = message.helperEnabled;
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAClientMsgBeginLastHitChallenge>): CDOTAClientMsgBeginLastHitChallenge {
    return CDOTAClientMsgBeginLastHitChallenge.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAClientMsgBeginLastHitChallenge>): CDOTAClientMsgBeginLastHitChallenge {
    const message = createBaseCDOTAClientMsgBeginLastHitChallenge();
    message.chosenLane = object.chosenLane ?? 0;
    message.helperEnabled = object.helperEnabled ?? false;
    return message;
  },
};

function createBaseCDOTAClientMsgUpdateQuickBuyItem(): CDOTAClientMsgUpdateQuickBuyItem {
  return { itemAbilityId: -1, purchasable: false };
}

export const CDOTAClientMsgUpdateQuickBuyItem = {
  encode(message: CDOTAClientMsgUpdateQuickBuyItem, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.itemAbilityId !== undefined && message.itemAbilityId !== -1) {
      writer.uint32(8).int32(message.itemAbilityId);
    }
    if (message.purchasable !== undefined && message.purchasable !== false) {
      writer.uint32(16).bool(message.purchasable);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAClientMsgUpdateQuickBuyItem {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAClientMsgUpdateQuickBuyItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.itemAbilityId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.purchasable = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAClientMsgUpdateQuickBuyItem {
    return {
      itemAbilityId: isSet(object.itemAbilityId) ? globalThis.Number(object.itemAbilityId) : -1,
      purchasable: isSet(object.purchasable) ? globalThis.Boolean(object.purchasable) : false,
    };
  },

  toJSON(message: CDOTAClientMsgUpdateQuickBuyItem): unknown {
    const obj: any = {};
    if (message.itemAbilityId !== undefined && message.itemAbilityId !== -1) {
      obj.itemAbilityId = Math.round(message.itemAbilityId);
    }
    if (message.purchasable !== undefined && message.purchasable !== false) {
      obj.purchasable = message.purchasable;
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAClientMsgUpdateQuickBuyItem>): CDOTAClientMsgUpdateQuickBuyItem {
    return CDOTAClientMsgUpdateQuickBuyItem.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAClientMsgUpdateQuickBuyItem>): CDOTAClientMsgUpdateQuickBuyItem {
    const message = createBaseCDOTAClientMsgUpdateQuickBuyItem();
    message.itemAbilityId = object.itemAbilityId ?? -1;
    message.purchasable = object.purchasable ?? false;
    return message;
  },
};

function createBaseCDOTAClientMsgUpdateQuickBuy(): CDOTAClientMsgUpdateQuickBuy {
  return { items: [] };
}

export const CDOTAClientMsgUpdateQuickBuy = {
  encode(message: CDOTAClientMsgUpdateQuickBuy, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.items) {
      CDOTAClientMsgUpdateQuickBuyItem.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAClientMsgUpdateQuickBuy {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAClientMsgUpdateQuickBuy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.items.push(CDOTAClientMsgUpdateQuickBuyItem.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAClientMsgUpdateQuickBuy {
    return {
      items: globalThis.Array.isArray(object?.items)
        ? object.items.map((e: any) => CDOTAClientMsgUpdateQuickBuyItem.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CDOTAClientMsgUpdateQuickBuy): unknown {
    const obj: any = {};
    if (message.items?.length) {
      obj.items = message.items.map((e) => CDOTAClientMsgUpdateQuickBuyItem.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAClientMsgUpdateQuickBuy>): CDOTAClientMsgUpdateQuickBuy {
    return CDOTAClientMsgUpdateQuickBuy.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAClientMsgUpdateQuickBuy>): CDOTAClientMsgUpdateQuickBuy {
    const message = createBaseCDOTAClientMsgUpdateQuickBuy();
    message.items = object.items?.map((e) => CDOTAClientMsgUpdateQuickBuyItem.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCDOTAClientMsgRecordVote(): CDOTAClientMsgRecordVote {
  return { choiceIndex: 0 };
}

export const CDOTAClientMsgRecordVote = {
  encode(message: CDOTAClientMsgRecordVote, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.choiceIndex !== undefined && message.choiceIndex !== 0) {
      writer.uint32(8).int32(message.choiceIndex);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAClientMsgRecordVote {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAClientMsgRecordVote();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.choiceIndex = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAClientMsgRecordVote {
    return { choiceIndex: isSet(object.choiceIndex) ? globalThis.Number(object.choiceIndex) : 0 };
  },

  toJSON(message: CDOTAClientMsgRecordVote): unknown {
    const obj: any = {};
    if (message.choiceIndex !== undefined && message.choiceIndex !== 0) {
      obj.choiceIndex = Math.round(message.choiceIndex);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAClientMsgRecordVote>): CDOTAClientMsgRecordVote {
    return CDOTAClientMsgRecordVote.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAClientMsgRecordVote>): CDOTAClientMsgRecordVote {
    const message = createBaseCDOTAClientMsgRecordVote();
    message.choiceIndex = object.choiceIndex ?? 0;
    return message;
  },
};

function createBaseCDOTAClientMsgWillPurchaseAlert(): CDOTAClientMsgWillPurchaseAlert {
  return { itemAbilityId: -1, goldRemaining: 0, suggestionPlayerId: -1 };
}

export const CDOTAClientMsgWillPurchaseAlert = {
  encode(message: CDOTAClientMsgWillPurchaseAlert, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.itemAbilityId !== undefined && message.itemAbilityId !== -1) {
      writer.uint32(8).int32(message.itemAbilityId);
    }
    if (message.goldRemaining !== undefined && message.goldRemaining !== 0) {
      writer.uint32(16).uint32(message.goldRemaining);
    }
    if (message.suggestionPlayerId !== undefined && message.suggestionPlayerId !== -1) {
      writer.uint32(24).int32(message.suggestionPlayerId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAClientMsgWillPurchaseAlert {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAClientMsgWillPurchaseAlert();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.itemAbilityId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.goldRemaining = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.suggestionPlayerId = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAClientMsgWillPurchaseAlert {
    return {
      itemAbilityId: isSet(object.itemAbilityId) ? globalThis.Number(object.itemAbilityId) : -1,
      goldRemaining: isSet(object.goldRemaining) ? globalThis.Number(object.goldRemaining) : 0,
      suggestionPlayerId: isSet(object.suggestionPlayerId) ? globalThis.Number(object.suggestionPlayerId) : -1,
    };
  },

  toJSON(message: CDOTAClientMsgWillPurchaseAlert): unknown {
    const obj: any = {};
    if (message.itemAbilityId !== undefined && message.itemAbilityId !== -1) {
      obj.itemAbilityId = Math.round(message.itemAbilityId);
    }
    if (message.goldRemaining !== undefined && message.goldRemaining !== 0) {
      obj.goldRemaining = Math.round(message.goldRemaining);
    }
    if (message.suggestionPlayerId !== undefined && message.suggestionPlayerId !== -1) {
      obj.suggestionPlayerId = Math.round(message.suggestionPlayerId);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAClientMsgWillPurchaseAlert>): CDOTAClientMsgWillPurchaseAlert {
    return CDOTAClientMsgWillPurchaseAlert.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAClientMsgWillPurchaseAlert>): CDOTAClientMsgWillPurchaseAlert {
    const message = createBaseCDOTAClientMsgWillPurchaseAlert();
    message.itemAbilityId = object.itemAbilityId ?? -1;
    message.goldRemaining = object.goldRemaining ?? 0;
    message.suggestionPlayerId = object.suggestionPlayerId ?? -1;
    return message;
  },
};

function createBaseCDOTAClientMsgBuyBackStateAlert(): CDOTAClientMsgBuyBackStateAlert {
  return {};
}

export const CDOTAClientMsgBuyBackStateAlert = {
  encode(_: CDOTAClientMsgBuyBackStateAlert, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAClientMsgBuyBackStateAlert {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAClientMsgBuyBackStateAlert();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CDOTAClientMsgBuyBackStateAlert {
    return {};
  },

  toJSON(_: CDOTAClientMsgBuyBackStateAlert): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<CDOTAClientMsgBuyBackStateAlert>): CDOTAClientMsgBuyBackStateAlert {
    return CDOTAClientMsgBuyBackStateAlert.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<CDOTAClientMsgBuyBackStateAlert>): CDOTAClientMsgBuyBackStateAlert {
    const message = createBaseCDOTAClientMsgBuyBackStateAlert();
    return message;
  },
};

function createBaseCDOTAClientMsgQuickBuyAlert(): CDOTAClientMsgQuickBuyAlert {
  return { itemAbilityId: -1, goldCost: 0, itemCooldownSeconds: 0, showBuyback: false };
}

export const CDOTAClientMsgQuickBuyAlert = {
  encode(message: CDOTAClientMsgQuickBuyAlert, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.itemAbilityId !== undefined && message.itemAbilityId !== -1) {
      writer.uint32(8).int32(message.itemAbilityId);
    }
    if (message.goldCost !== undefined && message.goldCost !== 0) {
      writer.uint32(16).int32(message.goldCost);
    }
    if (message.itemCooldownSeconds !== undefined && message.itemCooldownSeconds !== 0) {
      writer.uint32(24).int32(message.itemCooldownSeconds);
    }
    if (message.showBuyback !== undefined && message.showBuyback !== false) {
      writer.uint32(32).bool(message.showBuyback);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAClientMsgQuickBuyAlert {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAClientMsgQuickBuyAlert();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.itemAbilityId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.goldCost = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.itemCooldownSeconds = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.showBuyback = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAClientMsgQuickBuyAlert {
    return {
      itemAbilityId: isSet(object.itemAbilityId) ? globalThis.Number(object.itemAbilityId) : -1,
      goldCost: isSet(object.goldCost) ? globalThis.Number(object.goldCost) : 0,
      itemCooldownSeconds: isSet(object.itemCooldownSeconds) ? globalThis.Number(object.itemCooldownSeconds) : 0,
      showBuyback: isSet(object.showBuyback) ? globalThis.Boolean(object.showBuyback) : false,
    };
  },

  toJSON(message: CDOTAClientMsgQuickBuyAlert): unknown {
    const obj: any = {};
    if (message.itemAbilityId !== undefined && message.itemAbilityId !== -1) {
      obj.itemAbilityId = Math.round(message.itemAbilityId);
    }
    if (message.goldCost !== undefined && message.goldCost !== 0) {
      obj.goldCost = Math.round(message.goldCost);
    }
    if (message.itemCooldownSeconds !== undefined && message.itemCooldownSeconds !== 0) {
      obj.itemCooldownSeconds = Math.round(message.itemCooldownSeconds);
    }
    if (message.showBuyback !== undefined && message.showBuyback !== false) {
      obj.showBuyback = message.showBuyback;
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAClientMsgQuickBuyAlert>): CDOTAClientMsgQuickBuyAlert {
    return CDOTAClientMsgQuickBuyAlert.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAClientMsgQuickBuyAlert>): CDOTAClientMsgQuickBuyAlert {
    const message = createBaseCDOTAClientMsgQuickBuyAlert();
    message.itemAbilityId = object.itemAbilityId ?? -1;
    message.goldCost = object.goldCost ?? 0;
    message.itemCooldownSeconds = object.itemCooldownSeconds ?? 0;
    message.showBuyback = object.showBuyback ?? false;
    return message;
  },
};

function createBaseCDOTAClientMsgPlayerShowCase(): CDOTAClientMsgPlayerShowCase {
  return { showcase: false };
}

export const CDOTAClientMsgPlayerShowCase = {
  encode(message: CDOTAClientMsgPlayerShowCase, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.showcase !== undefined && message.showcase !== false) {
      writer.uint32(8).bool(message.showcase);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAClientMsgPlayerShowCase {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAClientMsgPlayerShowCase();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.showcase = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAClientMsgPlayerShowCase {
    return { showcase: isSet(object.showcase) ? globalThis.Boolean(object.showcase) : false };
  },

  toJSON(message: CDOTAClientMsgPlayerShowCase): unknown {
    const obj: any = {};
    if (message.showcase !== undefined && message.showcase !== false) {
      obj.showcase = message.showcase;
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAClientMsgPlayerShowCase>): CDOTAClientMsgPlayerShowCase {
    return CDOTAClientMsgPlayerShowCase.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAClientMsgPlayerShowCase>): CDOTAClientMsgPlayerShowCase {
    const message = createBaseCDOTAClientMsgPlayerShowCase();
    message.showcase = object.showcase ?? false;
    return message;
  },
};

function createBaseCDOTAClientMsgCameraZoomAmount(): CDOTAClientMsgCameraZoomAmount {
  return { zoomAmount: 0 };
}

export const CDOTAClientMsgCameraZoomAmount = {
  encode(message: CDOTAClientMsgCameraZoomAmount, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.zoomAmount !== undefined && message.zoomAmount !== 0) {
      writer.uint32(13).float(message.zoomAmount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAClientMsgCameraZoomAmount {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAClientMsgCameraZoomAmount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.zoomAmount = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAClientMsgCameraZoomAmount {
    return { zoomAmount: isSet(object.zoomAmount) ? globalThis.Number(object.zoomAmount) : 0 };
  },

  toJSON(message: CDOTAClientMsgCameraZoomAmount): unknown {
    const obj: any = {};
    if (message.zoomAmount !== undefined && message.zoomAmount !== 0) {
      obj.zoomAmount = message.zoomAmount;
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAClientMsgCameraZoomAmount>): CDOTAClientMsgCameraZoomAmount {
    return CDOTAClientMsgCameraZoomAmount.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAClientMsgCameraZoomAmount>): CDOTAClientMsgCameraZoomAmount {
    const message = createBaseCDOTAClientMsgCameraZoomAmount();
    message.zoomAmount = object.zoomAmount ?? 0;
    return message;
  },
};

function createBaseCDOTAClientMsgBroadcasterUsingCameraman(): CDOTAClientMsgBroadcasterUsingCameraman {
  return { cameraman: false };
}

export const CDOTAClientMsgBroadcasterUsingCameraman = {
  encode(message: CDOTAClientMsgBroadcasterUsingCameraman, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.cameraman !== undefined && message.cameraman !== false) {
      writer.uint32(8).bool(message.cameraman);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAClientMsgBroadcasterUsingCameraman {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAClientMsgBroadcasterUsingCameraman();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.cameraman = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAClientMsgBroadcasterUsingCameraman {
    return { cameraman: isSet(object.cameraman) ? globalThis.Boolean(object.cameraman) : false };
  },

  toJSON(message: CDOTAClientMsgBroadcasterUsingCameraman): unknown {
    const obj: any = {};
    if (message.cameraman !== undefined && message.cameraman !== false) {
      obj.cameraman = message.cameraman;
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAClientMsgBroadcasterUsingCameraman>): CDOTAClientMsgBroadcasterUsingCameraman {
    return CDOTAClientMsgBroadcasterUsingCameraman.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAClientMsgBroadcasterUsingCameraman>): CDOTAClientMsgBroadcasterUsingCameraman {
    const message = createBaseCDOTAClientMsgBroadcasterUsingCameraman();
    message.cameraman = object.cameraman ?? false;
    return message;
  },
};

function createBaseCDOTAClientMsgBroadcasterUsingAssistedCameraOperator(): CDOTAClientMsgBroadcasterUsingAssistedCameraOperator {
  return { enabled: false };
}

export const CDOTAClientMsgBroadcasterUsingAssistedCameraOperator = {
  encode(
    message: CDOTAClientMsgBroadcasterUsingAssistedCameraOperator,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.enabled !== undefined && message.enabled !== false) {
      writer.uint32(8).bool(message.enabled);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAClientMsgBroadcasterUsingAssistedCameraOperator {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAClientMsgBroadcasterUsingAssistedCameraOperator();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.enabled = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAClientMsgBroadcasterUsingAssistedCameraOperator {
    return { enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false };
  },

  toJSON(message: CDOTAClientMsgBroadcasterUsingAssistedCameraOperator): unknown {
    const obj: any = {};
    if (message.enabled !== undefined && message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    return obj;
  },

  create(
    base?: DeepPartial<CDOTAClientMsgBroadcasterUsingAssistedCameraOperator>,
  ): CDOTAClientMsgBroadcasterUsingAssistedCameraOperator {
    return CDOTAClientMsgBroadcasterUsingAssistedCameraOperator.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CDOTAClientMsgBroadcasterUsingAssistedCameraOperator>,
  ): CDOTAClientMsgBroadcasterUsingAssistedCameraOperator {
    const message = createBaseCDOTAClientMsgBroadcasterUsingAssistedCameraOperator();
    message.enabled = object.enabled ?? false;
    return message;
  },
};

function createBaseCDOTAClientMsgFillEmptySlotsWithBots(): CDOTAClientMsgFillEmptySlotsWithBots {
  return { fillwithbots: false };
}

export const CDOTAClientMsgFillEmptySlotsWithBots = {
  encode(message: CDOTAClientMsgFillEmptySlotsWithBots, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.fillwithbots !== undefined && message.fillwithbots !== false) {
      writer.uint32(8).bool(message.fillwithbots);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAClientMsgFillEmptySlotsWithBots {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAClientMsgFillEmptySlotsWithBots();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.fillwithbots = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAClientMsgFillEmptySlotsWithBots {
    return { fillwithbots: isSet(object.fillwithbots) ? globalThis.Boolean(object.fillwithbots) : false };
  },

  toJSON(message: CDOTAClientMsgFillEmptySlotsWithBots): unknown {
    const obj: any = {};
    if (message.fillwithbots !== undefined && message.fillwithbots !== false) {
      obj.fillwithbots = message.fillwithbots;
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAClientMsgFillEmptySlotsWithBots>): CDOTAClientMsgFillEmptySlotsWithBots {
    return CDOTAClientMsgFillEmptySlotsWithBots.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAClientMsgFillEmptySlotsWithBots>): CDOTAClientMsgFillEmptySlotsWithBots {
    const message = createBaseCDOTAClientMsgFillEmptySlotsWithBots();
    message.fillwithbots = object.fillwithbots ?? false;
    return message;
  },
};

function createBaseCDOTAClientMsgHeroStatueLike(): CDOTAClientMsgHeroStatueLike {
  return { ownerPlayerId: -1 };
}

export const CDOTAClientMsgHeroStatueLike = {
  encode(message: CDOTAClientMsgHeroStatueLike, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.ownerPlayerId !== undefined && message.ownerPlayerId !== -1) {
      writer.uint32(8).int32(message.ownerPlayerId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAClientMsgHeroStatueLike {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAClientMsgHeroStatueLike();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.ownerPlayerId = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAClientMsgHeroStatueLike {
    return { ownerPlayerId: isSet(object.ownerPlayerId) ? globalThis.Number(object.ownerPlayerId) : -1 };
  },

  toJSON(message: CDOTAClientMsgHeroStatueLike): unknown {
    const obj: any = {};
    if (message.ownerPlayerId !== undefined && message.ownerPlayerId !== -1) {
      obj.ownerPlayerId = Math.round(message.ownerPlayerId);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAClientMsgHeroStatueLike>): CDOTAClientMsgHeroStatueLike {
    return CDOTAClientMsgHeroStatueLike.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAClientMsgHeroStatueLike>): CDOTAClientMsgHeroStatueLike {
    const message = createBaseCDOTAClientMsgHeroStatueLike();
    message.ownerPlayerId = object.ownerPlayerId ?? -1;
    return message;
  },
};

function createBaseCDOTAClientMsgEventCNY2015Cmd(): CDOTAClientMsgEventCNY2015Cmd {
  return { data: Buffer.alloc(0) };
}

export const CDOTAClientMsgEventCNY2015Cmd = {
  encode(message: CDOTAClientMsgEventCNY2015Cmd, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.data !== undefined && message.data.length !== 0) {
      writer.uint32(10).bytes(message.data);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAClientMsgEventCNY2015Cmd {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAClientMsgEventCNY2015Cmd();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.data = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAClientMsgEventCNY2015Cmd {
    return { data: isSet(object.data) ? Buffer.from(bytesFromBase64(object.data)) : Buffer.alloc(0) };
  },

  toJSON(message: CDOTAClientMsgEventCNY2015Cmd): unknown {
    const obj: any = {};
    if (message.data !== undefined && message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAClientMsgEventCNY2015Cmd>): CDOTAClientMsgEventCNY2015Cmd {
    return CDOTAClientMsgEventCNY2015Cmd.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAClientMsgEventCNY2015Cmd>): CDOTAClientMsgEventCNY2015Cmd {
    const message = createBaseCDOTAClientMsgEventCNY2015Cmd();
    message.data = object.data ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseCDOTAClientMsgDemoHero(): CDOTAClientMsgDemoHero {
  return {
    heroId: 0,
    heroIdToSpawn: 0,
    itemDefs: [],
    itemIds: [],
    styleIndex: 255,
    keepExistingDemohero: false,
    itemData: [],
    heroVariant: 0,
  };
}

export const CDOTAClientMsgDemoHero = {
  encode(message: CDOTAClientMsgDemoHero, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.heroId !== undefined && message.heroId !== 0) {
      writer.uint32(8).int32(message.heroId);
    }
    if (message.heroIdToSpawn !== undefined && message.heroIdToSpawn !== 0) {
      writer.uint32(16).int32(message.heroIdToSpawn);
    }
    writer.uint32(26).fork();
    for (const v of message.itemDefs) {
      writer.uint32(v);
    }
    writer.ldelim();
    writer.uint32(34).fork();
    for (const v of message.itemIds) {
      writer.uint64(v);
    }
    writer.ldelim();
    if (message.styleIndex !== undefined && message.styleIndex !== 255) {
      writer.uint32(40).uint32(message.styleIndex);
    }
    if (message.keepExistingDemohero !== undefined && message.keepExistingDemohero !== false) {
      writer.uint32(48).bool(message.keepExistingDemohero);
    }
    for (const v of message.itemData) {
      CSOEconItem.encode(v!, writer.uint32(58).fork()).ldelim();
    }
    if (message.heroVariant !== undefined && message.heroVariant !== 0) {
      writer.uint32(64).int32(message.heroVariant);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAClientMsgDemoHero {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAClientMsgDemoHero();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.heroId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.heroIdToSpawn = reader.int32();
          continue;
        case 3:
          if (tag === 24) {
            message.itemDefs.push(reader.uint32());

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.itemDefs.push(reader.uint32());
            }

            continue;
          }

          break;
        case 4:
          if (tag === 32) {
            message.itemIds.push(longToString(reader.uint64() as Long));

            continue;
          }

          if (tag === 34) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.itemIds.push(longToString(reader.uint64() as Long));
            }

            continue;
          }

          break;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.styleIndex = reader.uint32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.keepExistingDemohero = reader.bool();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.itemData.push(CSOEconItem.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.heroVariant = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAClientMsgDemoHero {
    return {
      heroId: isSet(object.heroId) ? globalThis.Number(object.heroId) : 0,
      heroIdToSpawn: isSet(object.heroIdToSpawn) ? globalThis.Number(object.heroIdToSpawn) : 0,
      itemDefs: globalThis.Array.isArray(object?.itemDefs) ? object.itemDefs.map((e: any) => globalThis.Number(e)) : [],
      itemIds: globalThis.Array.isArray(object?.itemIds) ? object.itemIds.map((e: any) => globalThis.String(e)) : [],
      styleIndex: isSet(object.styleIndex) ? globalThis.Number(object.styleIndex) : 255,
      keepExistingDemohero: isSet(object.keepExistingDemohero)
        ? globalThis.Boolean(object.keepExistingDemohero)
        : false,
      itemData: globalThis.Array.isArray(object?.itemData)
        ? object.itemData.map((e: any) => CSOEconItem.fromJSON(e))
        : [],
      heroVariant: isSet(object.heroVariant) ? globalThis.Number(object.heroVariant) : 0,
    };
  },

  toJSON(message: CDOTAClientMsgDemoHero): unknown {
    const obj: any = {};
    if (message.heroId !== undefined && message.heroId !== 0) {
      obj.heroId = Math.round(message.heroId);
    }
    if (message.heroIdToSpawn !== undefined && message.heroIdToSpawn !== 0) {
      obj.heroIdToSpawn = Math.round(message.heroIdToSpawn);
    }
    if (message.itemDefs?.length) {
      obj.itemDefs = message.itemDefs.map((e) => Math.round(e));
    }
    if (message.itemIds?.length) {
      obj.itemIds = message.itemIds;
    }
    if (message.styleIndex !== undefined && message.styleIndex !== 255) {
      obj.styleIndex = Math.round(message.styleIndex);
    }
    if (message.keepExistingDemohero !== undefined && message.keepExistingDemohero !== false) {
      obj.keepExistingDemohero = message.keepExistingDemohero;
    }
    if (message.itemData?.length) {
      obj.itemData = message.itemData.map((e) => CSOEconItem.toJSON(e));
    }
    if (message.heroVariant !== undefined && message.heroVariant !== 0) {
      obj.heroVariant = Math.round(message.heroVariant);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAClientMsgDemoHero>): CDOTAClientMsgDemoHero {
    return CDOTAClientMsgDemoHero.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAClientMsgDemoHero>): CDOTAClientMsgDemoHero {
    const message = createBaseCDOTAClientMsgDemoHero();
    message.heroId = object.heroId ?? 0;
    message.heroIdToSpawn = object.heroIdToSpawn ?? 0;
    message.itemDefs = object.itemDefs?.map((e) => e) || [];
    message.itemIds = object.itemIds?.map((e) => e) || [];
    message.styleIndex = object.styleIndex ?? 255;
    message.keepExistingDemohero = object.keepExistingDemohero ?? false;
    message.itemData = object.itemData?.map((e) => CSOEconItem.fromPartial(e)) || [];
    message.heroVariant = object.heroVariant ?? 0;
    return message;
  },
};

function createBaseCDOTAClientMsgChallengeSelect(): CDOTAClientMsgChallengeSelect {
  return { eventId: 0, slotId: 0, sequenceId: 0 };
}

export const CDOTAClientMsgChallengeSelect = {
  encode(message: CDOTAClientMsgChallengeSelect, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.eventId !== undefined && message.eventId !== 0) {
      writer.uint32(8).uint32(message.eventId);
    }
    if (message.slotId !== undefined && message.slotId !== 0) {
      writer.uint32(16).uint32(message.slotId);
    }
    if (message.sequenceId !== undefined && message.sequenceId !== 0) {
      writer.uint32(24).uint32(message.sequenceId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAClientMsgChallengeSelect {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAClientMsgChallengeSelect();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.eventId = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.slotId = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.sequenceId = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAClientMsgChallengeSelect {
    return {
      eventId: isSet(object.eventId) ? globalThis.Number(object.eventId) : 0,
      slotId: isSet(object.slotId) ? globalThis.Number(object.slotId) : 0,
      sequenceId: isSet(object.sequenceId) ? globalThis.Number(object.sequenceId) : 0,
    };
  },

  toJSON(message: CDOTAClientMsgChallengeSelect): unknown {
    const obj: any = {};
    if (message.eventId !== undefined && message.eventId !== 0) {
      obj.eventId = Math.round(message.eventId);
    }
    if (message.slotId !== undefined && message.slotId !== 0) {
      obj.slotId = Math.round(message.slotId);
    }
    if (message.sequenceId !== undefined && message.sequenceId !== 0) {
      obj.sequenceId = Math.round(message.sequenceId);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAClientMsgChallengeSelect>): CDOTAClientMsgChallengeSelect {
    return CDOTAClientMsgChallengeSelect.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAClientMsgChallengeSelect>): CDOTAClientMsgChallengeSelect {
    const message = createBaseCDOTAClientMsgChallengeSelect();
    message.eventId = object.eventId ?? 0;
    message.slotId = object.slotId ?? 0;
    message.sequenceId = object.sequenceId ?? 0;
    return message;
  },
};

function createBaseCDOTAClientMsgChallengeReroll(): CDOTAClientMsgChallengeReroll {
  return { eventId: 0, slotId: 0, sequenceId: 0, heroId: 0 };
}

export const CDOTAClientMsgChallengeReroll = {
  encode(message: CDOTAClientMsgChallengeReroll, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.eventId !== undefined && message.eventId !== 0) {
      writer.uint32(8).int32(message.eventId);
    }
    if (message.slotId !== undefined && message.slotId !== 0) {
      writer.uint32(16).uint32(message.slotId);
    }
    if (message.sequenceId !== undefined && message.sequenceId !== 0) {
      writer.uint32(24).uint32(message.sequenceId);
    }
    if (message.heroId !== undefined && message.heroId !== 0) {
      writer.uint32(32).int32(message.heroId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAClientMsgChallengeReroll {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAClientMsgChallengeReroll();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.eventId = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.slotId = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.sequenceId = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.heroId = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAClientMsgChallengeReroll {
    return {
      eventId: isSet(object.eventId) ? eEventFromJSON(object.eventId) : 0,
      slotId: isSet(object.slotId) ? globalThis.Number(object.slotId) : 0,
      sequenceId: isSet(object.sequenceId) ? globalThis.Number(object.sequenceId) : 0,
      heroId: isSet(object.heroId) ? globalThis.Number(object.heroId) : 0,
    };
  },

  toJSON(message: CDOTAClientMsgChallengeReroll): unknown {
    const obj: any = {};
    if (message.eventId !== undefined && message.eventId !== 0) {
      obj.eventId = eEventToJSON(message.eventId);
    }
    if (message.slotId !== undefined && message.slotId !== 0) {
      obj.slotId = Math.round(message.slotId);
    }
    if (message.sequenceId !== undefined && message.sequenceId !== 0) {
      obj.sequenceId = Math.round(message.sequenceId);
    }
    if (message.heroId !== undefined && message.heroId !== 0) {
      obj.heroId = Math.round(message.heroId);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAClientMsgChallengeReroll>): CDOTAClientMsgChallengeReroll {
    return CDOTAClientMsgChallengeReroll.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAClientMsgChallengeReroll>): CDOTAClientMsgChallengeReroll {
    const message = createBaseCDOTAClientMsgChallengeReroll();
    message.eventId = object.eventId ?? 0;
    message.slotId = object.slotId ?? 0;
    message.sequenceId = object.sequenceId ?? 0;
    message.heroId = object.heroId ?? 0;
    return message;
  },
};

function createBaseCDOTAClientMsgCoinWager(): CDOTAClientMsgCoinWager {
  return { wagerAmount: 0 };
}

export const CDOTAClientMsgCoinWager = {
  encode(message: CDOTAClientMsgCoinWager, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.wagerAmount !== undefined && message.wagerAmount !== 0) {
      writer.uint32(8).uint32(message.wagerAmount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAClientMsgCoinWager {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAClientMsgCoinWager();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.wagerAmount = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAClientMsgCoinWager {
    return { wagerAmount: isSet(object.wagerAmount) ? globalThis.Number(object.wagerAmount) : 0 };
  },

  toJSON(message: CDOTAClientMsgCoinWager): unknown {
    const obj: any = {};
    if (message.wagerAmount !== undefined && message.wagerAmount !== 0) {
      obj.wagerAmount = Math.round(message.wagerAmount);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAClientMsgCoinWager>): CDOTAClientMsgCoinWager {
    return CDOTAClientMsgCoinWager.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAClientMsgCoinWager>): CDOTAClientMsgCoinWager {
    const message = createBaseCDOTAClientMsgCoinWager();
    message.wagerAmount = object.wagerAmount ?? 0;
    return message;
  },
};

function createBaseCDOTAClientMsgCoinWagerToken(): CDOTAClientMsgCoinWagerToken {
  return { wagerTokenItemId: "0" };
}

export const CDOTAClientMsgCoinWagerToken = {
  encode(message: CDOTAClientMsgCoinWagerToken, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.wagerTokenItemId !== undefined && message.wagerTokenItemId !== "0") {
      writer.uint32(8).uint64(message.wagerTokenItemId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAClientMsgCoinWagerToken {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAClientMsgCoinWagerToken();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.wagerTokenItemId = longToString(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAClientMsgCoinWagerToken {
    return { wagerTokenItemId: isSet(object.wagerTokenItemId) ? globalThis.String(object.wagerTokenItemId) : "0" };
  },

  toJSON(message: CDOTAClientMsgCoinWagerToken): unknown {
    const obj: any = {};
    if (message.wagerTokenItemId !== undefined && message.wagerTokenItemId !== "0") {
      obj.wagerTokenItemId = message.wagerTokenItemId;
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAClientMsgCoinWagerToken>): CDOTAClientMsgCoinWagerToken {
    return CDOTAClientMsgCoinWagerToken.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAClientMsgCoinWagerToken>): CDOTAClientMsgCoinWagerToken {
    const message = createBaseCDOTAClientMsgCoinWagerToken();
    message.wagerTokenItemId = object.wagerTokenItemId ?? "0";
    return message;
  },
};

function createBaseCDOTAClientMsgRankWager(): CDOTAClientMsgRankWager {
  return { announceWager: false };
}

export const CDOTAClientMsgRankWager = {
  encode(message: CDOTAClientMsgRankWager, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.announceWager !== undefined && message.announceWager !== false) {
      writer.uint32(8).bool(message.announceWager);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAClientMsgRankWager {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAClientMsgRankWager();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.announceWager = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAClientMsgRankWager {
    return { announceWager: isSet(object.announceWager) ? globalThis.Boolean(object.announceWager) : false };
  },

  toJSON(message: CDOTAClientMsgRankWager): unknown {
    const obj: any = {};
    if (message.announceWager !== undefined && message.announceWager !== false) {
      obj.announceWager = message.announceWager;
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAClientMsgRankWager>): CDOTAClientMsgRankWager {
    return CDOTAClientMsgRankWager.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAClientMsgRankWager>): CDOTAClientMsgRankWager {
    const message = createBaseCDOTAClientMsgRankWager();
    message.announceWager = object.announceWager ?? false;
    return message;
  },
};

function createBaseCDOTAClientMsgPlayerBounty(): CDOTAClientMsgPlayerBounty {
  return { playerId: -1 };
}

export const CDOTAClientMsgPlayerBounty = {
  encode(message: CDOTAClientMsgPlayerBounty, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.playerId !== undefined && message.playerId !== -1) {
      writer.uint32(8).int32(message.playerId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAClientMsgPlayerBounty {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAClientMsgPlayerBounty();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.playerId = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAClientMsgPlayerBounty {
    return { playerId: isSet(object.playerId) ? globalThis.Number(object.playerId) : -1 };
  },

  toJSON(message: CDOTAClientMsgPlayerBounty): unknown {
    const obj: any = {};
    if (message.playerId !== undefined && message.playerId !== -1) {
      obj.playerId = Math.round(message.playerId);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAClientMsgPlayerBounty>): CDOTAClientMsgPlayerBounty {
    return CDOTAClientMsgPlayerBounty.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAClientMsgPlayerBounty>): CDOTAClientMsgPlayerBounty {
    const message = createBaseCDOTAClientMsgPlayerBounty();
    message.playerId = object.playerId ?? -1;
    return message;
  },
};

function createBaseCDOTAClientMsgEventPointsTip(): CDOTAClientMsgEventPointsTip {
  return { recipientPlayerId: -1 };
}

export const CDOTAClientMsgEventPointsTip = {
  encode(message: CDOTAClientMsgEventPointsTip, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.recipientPlayerId !== undefined && message.recipientPlayerId !== -1) {
      writer.uint32(8).int32(message.recipientPlayerId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAClientMsgEventPointsTip {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAClientMsgEventPointsTip();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.recipientPlayerId = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAClientMsgEventPointsTip {
    return { recipientPlayerId: isSet(object.recipientPlayerId) ? globalThis.Number(object.recipientPlayerId) : -1 };
  },

  toJSON(message: CDOTAClientMsgEventPointsTip): unknown {
    const obj: any = {};
    if (message.recipientPlayerId !== undefined && message.recipientPlayerId !== -1) {
      obj.recipientPlayerId = Math.round(message.recipientPlayerId);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAClientMsgEventPointsTip>): CDOTAClientMsgEventPointsTip {
    return CDOTAClientMsgEventPointsTip.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAClientMsgEventPointsTip>): CDOTAClientMsgEventPointsTip {
    const message = createBaseCDOTAClientMsgEventPointsTip();
    message.recipientPlayerId = object.recipientPlayerId ?? -1;
    return message;
  },
};

function createBaseCDOTAClientMsgExecuteOrders(): CDOTAClientMsgExecuteOrders {
  return { orders: [], lastOrderLatency: 0 };
}

export const CDOTAClientMsgExecuteOrders = {
  encode(message: CDOTAClientMsgExecuteOrders, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.orders) {
      CDOTAMsgUnitOrder.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.lastOrderLatency !== undefined && message.lastOrderLatency !== 0) {
      writer.uint32(16).uint32(message.lastOrderLatency);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAClientMsgExecuteOrders {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAClientMsgExecuteOrders();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.orders.push(CDOTAMsgUnitOrder.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.lastOrderLatency = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAClientMsgExecuteOrders {
    return {
      orders: globalThis.Array.isArray(object?.orders)
        ? object.orders.map((e: any) => CDOTAMsgUnitOrder.fromJSON(e))
        : [],
      lastOrderLatency: isSet(object.lastOrderLatency) ? globalThis.Number(object.lastOrderLatency) : 0,
    };
  },

  toJSON(message: CDOTAClientMsgExecuteOrders): unknown {
    const obj: any = {};
    if (message.orders?.length) {
      obj.orders = message.orders.map((e) => CDOTAMsgUnitOrder.toJSON(e));
    }
    if (message.lastOrderLatency !== undefined && message.lastOrderLatency !== 0) {
      obj.lastOrderLatency = Math.round(message.lastOrderLatency);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAClientMsgExecuteOrders>): CDOTAClientMsgExecuteOrders {
    return CDOTAClientMsgExecuteOrders.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAClientMsgExecuteOrders>): CDOTAClientMsgExecuteOrders {
    const message = createBaseCDOTAClientMsgExecuteOrders();
    message.orders = object.orders?.map((e) => CDOTAMsgUnitOrder.fromPartial(e)) || [];
    message.lastOrderLatency = object.lastOrderLatency ?? 0;
    return message;
  },
};

function createBaseCDOTAClientMsgXPAlert(): CDOTAClientMsgXPAlert {
  return { targetEntindex: -1, damageTaken: 0 };
}

export const CDOTAClientMsgXPAlert = {
  encode(message: CDOTAClientMsgXPAlert, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.targetEntindex !== undefined && message.targetEntindex !== -1) {
      writer.uint32(8).int32(message.targetEntindex);
    }
    if (message.damageTaken !== undefined && message.damageTaken !== 0) {
      writer.uint32(16).uint32(message.damageTaken);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAClientMsgXPAlert {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAClientMsgXPAlert();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.targetEntindex = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.damageTaken = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAClientMsgXPAlert {
    return {
      targetEntindex: isSet(object.targetEntindex) ? globalThis.Number(object.targetEntindex) : -1,
      damageTaken: isSet(object.damageTaken) ? globalThis.Number(object.damageTaken) : 0,
    };
  },

  toJSON(message: CDOTAClientMsgXPAlert): unknown {
    const obj: any = {};
    if (message.targetEntindex !== undefined && message.targetEntindex !== -1) {
      obj.targetEntindex = Math.round(message.targetEntindex);
    }
    if (message.damageTaken !== undefined && message.damageTaken !== 0) {
      obj.damageTaken = Math.round(message.damageTaken);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAClientMsgXPAlert>): CDOTAClientMsgXPAlert {
    return CDOTAClientMsgXPAlert.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAClientMsgXPAlert>): CDOTAClientMsgXPAlert {
    const message = createBaseCDOTAClientMsgXPAlert();
    message.targetEntindex = object.targetEntindex ?? -1;
    message.damageTaken = object.damageTaken ?? 0;
    return message;
  },
};

function createBaseCDOTAClientMsgTalentTreeAlert(): CDOTAClientMsgTalentTreeAlert {
  return { targetEntindex: -1, abilityId: -1, slot: 0, learned: false };
}

export const CDOTAClientMsgTalentTreeAlert = {
  encode(message: CDOTAClientMsgTalentTreeAlert, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.targetEntindex !== undefined && message.targetEntindex !== -1) {
      writer.uint32(8).int32(message.targetEntindex);
    }
    if (message.abilityId !== undefined && message.abilityId !== -1) {
      writer.uint32(16).int32(message.abilityId);
    }
    if (message.slot !== undefined && message.slot !== 0) {
      writer.uint32(24).int32(message.slot);
    }
    if (message.learned !== undefined && message.learned !== false) {
      writer.uint32(32).bool(message.learned);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAClientMsgTalentTreeAlert {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAClientMsgTalentTreeAlert();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.targetEntindex = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.abilityId = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.slot = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.learned = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAClientMsgTalentTreeAlert {
    return {
      targetEntindex: isSet(object.targetEntindex) ? globalThis.Number(object.targetEntindex) : -1,
      abilityId: isSet(object.abilityId) ? globalThis.Number(object.abilityId) : -1,
      slot: isSet(object.slot) ? globalThis.Number(object.slot) : 0,
      learned: isSet(object.learned) ? globalThis.Boolean(object.learned) : false,
    };
  },

  toJSON(message: CDOTAClientMsgTalentTreeAlert): unknown {
    const obj: any = {};
    if (message.targetEntindex !== undefined && message.targetEntindex !== -1) {
      obj.targetEntindex = Math.round(message.targetEntindex);
    }
    if (message.abilityId !== undefined && message.abilityId !== -1) {
      obj.abilityId = Math.round(message.abilityId);
    }
    if (message.slot !== undefined && message.slot !== 0) {
      obj.slot = Math.round(message.slot);
    }
    if (message.learned !== undefined && message.learned !== false) {
      obj.learned = message.learned;
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAClientMsgTalentTreeAlert>): CDOTAClientMsgTalentTreeAlert {
    return CDOTAClientMsgTalentTreeAlert.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAClientMsgTalentTreeAlert>): CDOTAClientMsgTalentTreeAlert {
    const message = createBaseCDOTAClientMsgTalentTreeAlert();
    message.targetEntindex = object.targetEntindex ?? -1;
    message.abilityId = object.abilityId ?? -1;
    message.slot = object.slot ?? 0;
    message.learned = object.learned ?? false;
    return message;
  },
};

function createBaseCDOTAClientMsgKillcamDamageTaken(): CDOTAClientMsgKillcamDamageTaken {
  return { targetEntindex: -1, damageTaken: 0, itemType: 0, itemAbilityId: -1, heroName: "", damageColor: "" };
}

export const CDOTAClientMsgKillcamDamageTaken = {
  encode(message: CDOTAClientMsgKillcamDamageTaken, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.targetEntindex !== undefined && message.targetEntindex !== -1) {
      writer.uint32(8).int32(message.targetEntindex);
    }
    if (message.damageTaken !== undefined && message.damageTaken !== 0) {
      writer.uint32(16).uint32(message.damageTaken);
    }
    if (message.itemType !== undefined && message.itemType !== 0) {
      writer.uint32(24).uint32(message.itemType);
    }
    if (message.itemAbilityId !== undefined && message.itemAbilityId !== -1) {
      writer.uint32(32).int32(message.itemAbilityId);
    }
    if (message.heroName !== undefined && message.heroName !== "") {
      writer.uint32(42).string(message.heroName);
    }
    if (message.damageColor !== undefined && message.damageColor !== "") {
      writer.uint32(50).string(message.damageColor);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAClientMsgKillcamDamageTaken {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAClientMsgKillcamDamageTaken();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.targetEntindex = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.damageTaken = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.itemType = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.itemAbilityId = reader.int32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.heroName = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.damageColor = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAClientMsgKillcamDamageTaken {
    return {
      targetEntindex: isSet(object.targetEntindex) ? globalThis.Number(object.targetEntindex) : -1,
      damageTaken: isSet(object.damageTaken) ? globalThis.Number(object.damageTaken) : 0,
      itemType: isSet(object.itemType) ? globalThis.Number(object.itemType) : 0,
      itemAbilityId: isSet(object.itemAbilityId) ? globalThis.Number(object.itemAbilityId) : -1,
      heroName: isSet(object.heroName) ? globalThis.String(object.heroName) : "",
      damageColor: isSet(object.damageColor) ? globalThis.String(object.damageColor) : "",
    };
  },

  toJSON(message: CDOTAClientMsgKillcamDamageTaken): unknown {
    const obj: any = {};
    if (message.targetEntindex !== undefined && message.targetEntindex !== -1) {
      obj.targetEntindex = Math.round(message.targetEntindex);
    }
    if (message.damageTaken !== undefined && message.damageTaken !== 0) {
      obj.damageTaken = Math.round(message.damageTaken);
    }
    if (message.itemType !== undefined && message.itemType !== 0) {
      obj.itemType = Math.round(message.itemType);
    }
    if (message.itemAbilityId !== undefined && message.itemAbilityId !== -1) {
      obj.itemAbilityId = Math.round(message.itemAbilityId);
    }
    if (message.heroName !== undefined && message.heroName !== "") {
      obj.heroName = message.heroName;
    }
    if (message.damageColor !== undefined && message.damageColor !== "") {
      obj.damageColor = message.damageColor;
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAClientMsgKillcamDamageTaken>): CDOTAClientMsgKillcamDamageTaken {
    return CDOTAClientMsgKillcamDamageTaken.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAClientMsgKillcamDamageTaken>): CDOTAClientMsgKillcamDamageTaken {
    const message = createBaseCDOTAClientMsgKillcamDamageTaken();
    message.targetEntindex = object.targetEntindex ?? -1;
    message.damageTaken = object.damageTaken ?? 0;
    message.itemType = object.itemType ?? 0;
    message.itemAbilityId = object.itemAbilityId ?? -1;
    message.heroName = object.heroName ?? "";
    message.damageColor = object.damageColor ?? "";
    return message;
  },
};

function createBaseCDOTAClientMsgKillMyHero(): CDOTAClientMsgKillMyHero {
  return {};
}

export const CDOTAClientMsgKillMyHero = {
  encode(_: CDOTAClientMsgKillMyHero, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAClientMsgKillMyHero {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAClientMsgKillMyHero();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CDOTAClientMsgKillMyHero {
    return {};
  },

  toJSON(_: CDOTAClientMsgKillMyHero): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<CDOTAClientMsgKillMyHero>): CDOTAClientMsgKillMyHero {
    return CDOTAClientMsgKillMyHero.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<CDOTAClientMsgKillMyHero>): CDOTAClientMsgKillMyHero {
    const message = createBaseCDOTAClientMsgKillMyHero();
    return message;
  },
};

function createBaseCDOTAClientMsgQuestStatus(): CDOTAClientMsgQuestStatus {
  return { questId: 0, challengeId: 0, progress: 0, goal: 0, query: 0, failGametime: 0, itemAbilityId: -1 };
}

export const CDOTAClientMsgQuestStatus = {
  encode(message: CDOTAClientMsgQuestStatus, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.questId !== undefined && message.questId !== 0) {
      writer.uint32(8).uint32(message.questId);
    }
    if (message.challengeId !== undefined && message.challengeId !== 0) {
      writer.uint32(16).uint32(message.challengeId);
    }
    if (message.progress !== undefined && message.progress !== 0) {
      writer.uint32(24).uint32(message.progress);
    }
    if (message.goal !== undefined && message.goal !== 0) {
      writer.uint32(32).uint32(message.goal);
    }
    if (message.query !== undefined && message.query !== 0) {
      writer.uint32(40).uint32(message.query);
    }
    if (message.failGametime !== undefined && message.failGametime !== 0) {
      writer.uint32(53).float(message.failGametime);
    }
    if (message.itemAbilityId !== undefined && message.itemAbilityId !== -1) {
      writer.uint32(56).int32(message.itemAbilityId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAClientMsgQuestStatus {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAClientMsgQuestStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.questId = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.challengeId = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.progress = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.goal = reader.uint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.query = reader.uint32();
          continue;
        case 6:
          if (tag !== 53) {
            break;
          }

          message.failGametime = reader.float();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.itemAbilityId = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAClientMsgQuestStatus {
    return {
      questId: isSet(object.questId) ? globalThis.Number(object.questId) : 0,
      challengeId: isSet(object.challengeId) ? globalThis.Number(object.challengeId) : 0,
      progress: isSet(object.progress) ? globalThis.Number(object.progress) : 0,
      goal: isSet(object.goal) ? globalThis.Number(object.goal) : 0,
      query: isSet(object.query) ? globalThis.Number(object.query) : 0,
      failGametime: isSet(object.failGametime) ? globalThis.Number(object.failGametime) : 0,
      itemAbilityId: isSet(object.itemAbilityId) ? globalThis.Number(object.itemAbilityId) : -1,
    };
  },

  toJSON(message: CDOTAClientMsgQuestStatus): unknown {
    const obj: any = {};
    if (message.questId !== undefined && message.questId !== 0) {
      obj.questId = Math.round(message.questId);
    }
    if (message.challengeId !== undefined && message.challengeId !== 0) {
      obj.challengeId = Math.round(message.challengeId);
    }
    if (message.progress !== undefined && message.progress !== 0) {
      obj.progress = Math.round(message.progress);
    }
    if (message.goal !== undefined && message.goal !== 0) {
      obj.goal = Math.round(message.goal);
    }
    if (message.query !== undefined && message.query !== 0) {
      obj.query = Math.round(message.query);
    }
    if (message.failGametime !== undefined && message.failGametime !== 0) {
      obj.failGametime = message.failGametime;
    }
    if (message.itemAbilityId !== undefined && message.itemAbilityId !== -1) {
      obj.itemAbilityId = Math.round(message.itemAbilityId);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAClientMsgQuestStatus>): CDOTAClientMsgQuestStatus {
    return CDOTAClientMsgQuestStatus.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAClientMsgQuestStatus>): CDOTAClientMsgQuestStatus {
    const message = createBaseCDOTAClientMsgQuestStatus();
    message.questId = object.questId ?? 0;
    message.challengeId = object.challengeId ?? 0;
    message.progress = object.progress ?? 0;
    message.goal = object.goal ?? 0;
    message.query = object.query ?? 0;
    message.failGametime = object.failGametime ?? 0;
    message.itemAbilityId = object.itemAbilityId ?? -1;
    return message;
  },
};

function createBaseCDOTAClientMsgToggleAutoattack(): CDOTAClientMsgToggleAutoattack {
  return { mode: 0, showMessage: false };
}

export const CDOTAClientMsgToggleAutoattack = {
  encode(message: CDOTAClientMsgToggleAutoattack, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.mode !== undefined && message.mode !== 0) {
      writer.uint32(8).int32(message.mode);
    }
    if (message.showMessage !== undefined && message.showMessage !== false) {
      writer.uint32(16).bool(message.showMessage);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAClientMsgToggleAutoattack {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAClientMsgToggleAutoattack();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.mode = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.showMessage = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAClientMsgToggleAutoattack {
    return {
      mode: isSet(object.mode) ? globalThis.Number(object.mode) : 0,
      showMessage: isSet(object.showMessage) ? globalThis.Boolean(object.showMessage) : false,
    };
  },

  toJSON(message: CDOTAClientMsgToggleAutoattack): unknown {
    const obj: any = {};
    if (message.mode !== undefined && message.mode !== 0) {
      obj.mode = Math.round(message.mode);
    }
    if (message.showMessage !== undefined && message.showMessage !== false) {
      obj.showMessage = message.showMessage;
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAClientMsgToggleAutoattack>): CDOTAClientMsgToggleAutoattack {
    return CDOTAClientMsgToggleAutoattack.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAClientMsgToggleAutoattack>): CDOTAClientMsgToggleAutoattack {
    const message = createBaseCDOTAClientMsgToggleAutoattack();
    message.mode = object.mode ?? 0;
    message.showMessage = object.showMessage ?? false;
    return message;
  },
};

function createBaseCDOTAClientMsgSpecialAbility(): CDOTAClientMsgSpecialAbility {
  return { abilityIndex: 0, targetEntindex: -1 };
}

export const CDOTAClientMsgSpecialAbility = {
  encode(message: CDOTAClientMsgSpecialAbility, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.abilityIndex !== undefined && message.abilityIndex !== 0) {
      writer.uint32(8).uint32(message.abilityIndex);
    }
    if (message.targetEntindex !== undefined && message.targetEntindex !== -1) {
      writer.uint32(16).int32(message.targetEntindex);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAClientMsgSpecialAbility {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAClientMsgSpecialAbility();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.abilityIndex = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.targetEntindex = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAClientMsgSpecialAbility {
    return {
      abilityIndex: isSet(object.abilityIndex) ? globalThis.Number(object.abilityIndex) : 0,
      targetEntindex: isSet(object.targetEntindex) ? globalThis.Number(object.targetEntindex) : -1,
    };
  },

  toJSON(message: CDOTAClientMsgSpecialAbility): unknown {
    const obj: any = {};
    if (message.abilityIndex !== undefined && message.abilityIndex !== 0) {
      obj.abilityIndex = Math.round(message.abilityIndex);
    }
    if (message.targetEntindex !== undefined && message.targetEntindex !== -1) {
      obj.targetEntindex = Math.round(message.targetEntindex);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAClientMsgSpecialAbility>): CDOTAClientMsgSpecialAbility {
    return CDOTAClientMsgSpecialAbility.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAClientMsgSpecialAbility>): CDOTAClientMsgSpecialAbility {
    const message = createBaseCDOTAClientMsgSpecialAbility();
    message.abilityIndex = object.abilityIndex ?? 0;
    message.targetEntindex = object.targetEntindex ?? -1;
    return message;
  },
};

function createBaseCDOTAClientMsgSetEnemyStartingPosition(): CDOTAClientMsgSetEnemyStartingPosition {
  return { enemyPlayerId: -1, enemyStartingPosition: 0 };
}

export const CDOTAClientMsgSetEnemyStartingPosition = {
  encode(message: CDOTAClientMsgSetEnemyStartingPosition, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.enemyPlayerId !== undefined && message.enemyPlayerId !== -1) {
      writer.uint32(8).int32(message.enemyPlayerId);
    }
    if (message.enemyStartingPosition !== undefined && message.enemyStartingPosition !== 0) {
      writer.uint32(16).uint32(message.enemyStartingPosition);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAClientMsgSetEnemyStartingPosition {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAClientMsgSetEnemyStartingPosition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.enemyPlayerId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.enemyStartingPosition = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAClientMsgSetEnemyStartingPosition {
    return {
      enemyPlayerId: isSet(object.enemyPlayerId) ? globalThis.Number(object.enemyPlayerId) : -1,
      enemyStartingPosition: isSet(object.enemyStartingPosition) ? globalThis.Number(object.enemyStartingPosition) : 0,
    };
  },

  toJSON(message: CDOTAClientMsgSetEnemyStartingPosition): unknown {
    const obj: any = {};
    if (message.enemyPlayerId !== undefined && message.enemyPlayerId !== -1) {
      obj.enemyPlayerId = Math.round(message.enemyPlayerId);
    }
    if (message.enemyStartingPosition !== undefined && message.enemyStartingPosition !== 0) {
      obj.enemyStartingPosition = Math.round(message.enemyStartingPosition);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAClientMsgSetEnemyStartingPosition>): CDOTAClientMsgSetEnemyStartingPosition {
    return CDOTAClientMsgSetEnemyStartingPosition.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAClientMsgSetEnemyStartingPosition>): CDOTAClientMsgSetEnemyStartingPosition {
    const message = createBaseCDOTAClientMsgSetEnemyStartingPosition();
    message.enemyPlayerId = object.enemyPlayerId ?? -1;
    message.enemyStartingPosition = object.enemyStartingPosition ?? 0;
    return message;
  },
};

function createBaseCDOTAClientMsgSetDesiredWardPlacement(): CDOTAClientMsgSetDesiredWardPlacement {
  return { wardIndex: 0, wardX: 0, wardY: 0 };
}

export const CDOTAClientMsgSetDesiredWardPlacement = {
  encode(message: CDOTAClientMsgSetDesiredWardPlacement, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.wardIndex !== undefined && message.wardIndex !== 0) {
      writer.uint32(8).uint32(message.wardIndex);
    }
    if (message.wardX !== undefined && message.wardX !== 0) {
      writer.uint32(21).float(message.wardX);
    }
    if (message.wardY !== undefined && message.wardY !== 0) {
      writer.uint32(29).float(message.wardY);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAClientMsgSetDesiredWardPlacement {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAClientMsgSetDesiredWardPlacement();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.wardIndex = reader.uint32();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.wardX = reader.float();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.wardY = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAClientMsgSetDesiredWardPlacement {
    return {
      wardIndex: isSet(object.wardIndex) ? globalThis.Number(object.wardIndex) : 0,
      wardX: isSet(object.wardX) ? globalThis.Number(object.wardX) : 0,
      wardY: isSet(object.wardY) ? globalThis.Number(object.wardY) : 0,
    };
  },

  toJSON(message: CDOTAClientMsgSetDesiredWardPlacement): unknown {
    const obj: any = {};
    if (message.wardIndex !== undefined && message.wardIndex !== 0) {
      obj.wardIndex = Math.round(message.wardIndex);
    }
    if (message.wardX !== undefined && message.wardX !== 0) {
      obj.wardX = message.wardX;
    }
    if (message.wardY !== undefined && message.wardY !== 0) {
      obj.wardY = message.wardY;
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAClientMsgSetDesiredWardPlacement>): CDOTAClientMsgSetDesiredWardPlacement {
    return CDOTAClientMsgSetDesiredWardPlacement.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAClientMsgSetDesiredWardPlacement>): CDOTAClientMsgSetDesiredWardPlacement {
    const message = createBaseCDOTAClientMsgSetDesiredWardPlacement();
    message.wardIndex = object.wardIndex ?? 0;
    message.wardX = object.wardX ?? 0;
    message.wardY = object.wardY ?? 0;
    return message;
  },
};

function createBaseCDOTAClientMsgRollDice(): CDOTAClientMsgRollDice {
  return { channelType: 0, rollMin: 0, rollMax: 0 };
}

export const CDOTAClientMsgRollDice = {
  encode(message: CDOTAClientMsgRollDice, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.channelType !== undefined && message.channelType !== 0) {
      writer.uint32(8).uint32(message.channelType);
    }
    if (message.rollMin !== undefined && message.rollMin !== 0) {
      writer.uint32(16).uint32(message.rollMin);
    }
    if (message.rollMax !== undefined && message.rollMax !== 0) {
      writer.uint32(24).uint32(message.rollMax);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAClientMsgRollDice {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAClientMsgRollDice();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.channelType = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.rollMin = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.rollMax = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAClientMsgRollDice {
    return {
      channelType: isSet(object.channelType) ? globalThis.Number(object.channelType) : 0,
      rollMin: isSet(object.rollMin) ? globalThis.Number(object.rollMin) : 0,
      rollMax: isSet(object.rollMax) ? globalThis.Number(object.rollMax) : 0,
    };
  },

  toJSON(message: CDOTAClientMsgRollDice): unknown {
    const obj: any = {};
    if (message.channelType !== undefined && message.channelType !== 0) {
      obj.channelType = Math.round(message.channelType);
    }
    if (message.rollMin !== undefined && message.rollMin !== 0) {
      obj.rollMin = Math.round(message.rollMin);
    }
    if (message.rollMax !== undefined && message.rollMax !== 0) {
      obj.rollMax = Math.round(message.rollMax);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAClientMsgRollDice>): CDOTAClientMsgRollDice {
    return CDOTAClientMsgRollDice.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAClientMsgRollDice>): CDOTAClientMsgRollDice {
    const message = createBaseCDOTAClientMsgRollDice();
    message.channelType = object.channelType ?? 0;
    message.rollMin = object.rollMin ?? 0;
    message.rollMax = object.rollMax ?? 0;
    return message;
  },
};

function createBaseCDOTAClientMsgFlipCoin(): CDOTAClientMsgFlipCoin {
  return { channelType: 0 };
}

export const CDOTAClientMsgFlipCoin = {
  encode(message: CDOTAClientMsgFlipCoin, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.channelType !== undefined && message.channelType !== 0) {
      writer.uint32(8).uint32(message.channelType);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAClientMsgFlipCoin {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAClientMsgFlipCoin();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.channelType = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAClientMsgFlipCoin {
    return { channelType: isSet(object.channelType) ? globalThis.Number(object.channelType) : 0 };
  },

  toJSON(message: CDOTAClientMsgFlipCoin): unknown {
    const obj: any = {};
    if (message.channelType !== undefined && message.channelType !== 0) {
      obj.channelType = Math.round(message.channelType);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAClientMsgFlipCoin>): CDOTAClientMsgFlipCoin {
    return CDOTAClientMsgFlipCoin.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAClientMsgFlipCoin>): CDOTAClientMsgFlipCoin {
    const message = createBaseCDOTAClientMsgFlipCoin();
    message.channelType = object.channelType ?? 0;
    return message;
  },
};

function createBaseCDOTAClientMsgRequestItemSuggestions(): CDOTAClientMsgRequestItemSuggestions {
  return {};
}

export const CDOTAClientMsgRequestItemSuggestions = {
  encode(_: CDOTAClientMsgRequestItemSuggestions, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAClientMsgRequestItemSuggestions {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAClientMsgRequestItemSuggestions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CDOTAClientMsgRequestItemSuggestions {
    return {};
  },

  toJSON(_: CDOTAClientMsgRequestItemSuggestions): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<CDOTAClientMsgRequestItemSuggestions>): CDOTAClientMsgRequestItemSuggestions {
    return CDOTAClientMsgRequestItemSuggestions.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<CDOTAClientMsgRequestItemSuggestions>): CDOTAClientMsgRequestItemSuggestions {
    const message = createBaseCDOTAClientMsgRequestItemSuggestions();
    return message;
  },
};

function createBaseCDOTAClientMsgSuggestItemPreference(): CDOTAClientMsgSuggestItemPreference {
  return { itemPreferences: [] };
}

export const CDOTAClientMsgSuggestItemPreference = {
  encode(message: CDOTAClientMsgSuggestItemPreference, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.itemPreferences) {
      CDOTAClientMsgSuggestItemPreference_ItemPreference.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAClientMsgSuggestItemPreference {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAClientMsgSuggestItemPreference();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.itemPreferences.push(
            CDOTAClientMsgSuggestItemPreference_ItemPreference.decode(reader, reader.uint32()),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAClientMsgSuggestItemPreference {
    return {
      itemPreferences: globalThis.Array.isArray(object?.itemPreferences)
        ? object.itemPreferences.map((e: any) => CDOTAClientMsgSuggestItemPreference_ItemPreference.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CDOTAClientMsgSuggestItemPreference): unknown {
    const obj: any = {};
    if (message.itemPreferences?.length) {
      obj.itemPreferences = message.itemPreferences.map((e) =>
        CDOTAClientMsgSuggestItemPreference_ItemPreference.toJSON(e)
      );
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAClientMsgSuggestItemPreference>): CDOTAClientMsgSuggestItemPreference {
    return CDOTAClientMsgSuggestItemPreference.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAClientMsgSuggestItemPreference>): CDOTAClientMsgSuggestItemPreference {
    const message = createBaseCDOTAClientMsgSuggestItemPreference();
    message.itemPreferences =
      object.itemPreferences?.map((e) => CDOTAClientMsgSuggestItemPreference_ItemPreference.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCDOTAClientMsgSuggestItemPreference_ItemPreference(): CDOTAClientMsgSuggestItemPreference_ItemPreference {
  return { itemId: -1, preference: 0 };
}

export const CDOTAClientMsgSuggestItemPreference_ItemPreference = {
  encode(
    message: CDOTAClientMsgSuggestItemPreference_ItemPreference,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.itemId !== undefined && message.itemId !== -1) {
      writer.uint32(8).int32(message.itemId);
    }
    if (message.preference !== undefined && message.preference !== 0) {
      writer.uint32(16).int32(message.preference);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAClientMsgSuggestItemPreference_ItemPreference {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAClientMsgSuggestItemPreference_ItemPreference();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.itemId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.preference = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAClientMsgSuggestItemPreference_ItemPreference {
    return {
      itemId: isSet(object.itemId) ? globalThis.Number(object.itemId) : -1,
      preference: isSet(object.preference) ? eItemSuggestPreferenceFromJSON(object.preference) : 0,
    };
  },

  toJSON(message: CDOTAClientMsgSuggestItemPreference_ItemPreference): unknown {
    const obj: any = {};
    if (message.itemId !== undefined && message.itemId !== -1) {
      obj.itemId = Math.round(message.itemId);
    }
    if (message.preference !== undefined && message.preference !== 0) {
      obj.preference = eItemSuggestPreferenceToJSON(message.preference);
    }
    return obj;
  },

  create(
    base?: DeepPartial<CDOTAClientMsgSuggestItemPreference_ItemPreference>,
  ): CDOTAClientMsgSuggestItemPreference_ItemPreference {
    return CDOTAClientMsgSuggestItemPreference_ItemPreference.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CDOTAClientMsgSuggestItemPreference_ItemPreference>,
  ): CDOTAClientMsgSuggestItemPreference_ItemPreference {
    const message = createBaseCDOTAClientMsgSuggestItemPreference_ItemPreference();
    message.itemId = object.itemId ?? -1;
    message.preference = object.preference ?? 0;
    return message;
  },
};

function createBaseCDOTAClientMsgMakeTeamCaptain(): CDOTAClientMsgMakeTeamCaptain {
  return { playerId: -1 };
}

export const CDOTAClientMsgMakeTeamCaptain = {
  encode(message: CDOTAClientMsgMakeTeamCaptain, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.playerId !== undefined && message.playerId !== -1) {
      writer.uint32(8).int32(message.playerId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAClientMsgMakeTeamCaptain {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAClientMsgMakeTeamCaptain();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.playerId = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAClientMsgMakeTeamCaptain {
    return { playerId: isSet(object.playerId) ? globalThis.Number(object.playerId) : -1 };
  },

  toJSON(message: CDOTAClientMsgMakeTeamCaptain): unknown {
    const obj: any = {};
    if (message.playerId !== undefined && message.playerId !== -1) {
      obj.playerId = Math.round(message.playerId);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAClientMsgMakeTeamCaptain>): CDOTAClientMsgMakeTeamCaptain {
    return CDOTAClientMsgMakeTeamCaptain.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAClientMsgMakeTeamCaptain>): CDOTAClientMsgMakeTeamCaptain {
    const message = createBaseCDOTAClientMsgMakeTeamCaptain();
    message.playerId = object.playerId ?? -1;
    return message;
  },
};

function createBaseCDOTAClientMsgHelpTipSystemStateChanged(): CDOTAClientMsgHelpTipSystemStateChanged {
  return { tipDisplayed: false };
}

export const CDOTAClientMsgHelpTipSystemStateChanged = {
  encode(message: CDOTAClientMsgHelpTipSystemStateChanged, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.tipDisplayed !== undefined && message.tipDisplayed !== false) {
      writer.uint32(8).bool(message.tipDisplayed);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAClientMsgHelpTipSystemStateChanged {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAClientMsgHelpTipSystemStateChanged();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.tipDisplayed = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAClientMsgHelpTipSystemStateChanged {
    return { tipDisplayed: isSet(object.tipDisplayed) ? globalThis.Boolean(object.tipDisplayed) : false };
  },

  toJSON(message: CDOTAClientMsgHelpTipSystemStateChanged): unknown {
    const obj: any = {};
    if (message.tipDisplayed !== undefined && message.tipDisplayed !== false) {
      obj.tipDisplayed = message.tipDisplayed;
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAClientMsgHelpTipSystemStateChanged>): CDOTAClientMsgHelpTipSystemStateChanged {
    return CDOTAClientMsgHelpTipSystemStateChanged.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAClientMsgHelpTipSystemStateChanged>): CDOTAClientMsgHelpTipSystemStateChanged {
    const message = createBaseCDOTAClientMsgHelpTipSystemStateChanged();
    message.tipDisplayed = object.tipDisplayed ?? false;
    return message;
  },
};

function createBaseCDOTAClientMsgRequestBulkCombatLog(): CDOTAClientMsgRequestBulkCombatLog {
  return { gameTime: 0, duration: 0, recentPlayerDeath: false, playerId: -1 };
}

export const CDOTAClientMsgRequestBulkCombatLog = {
  encode(message: CDOTAClientMsgRequestBulkCombatLog, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.gameTime !== undefined && message.gameTime !== 0) {
      writer.uint32(13).float(message.gameTime);
    }
    if (message.duration !== undefined && message.duration !== 0) {
      writer.uint32(21).float(message.duration);
    }
    if (message.recentPlayerDeath !== undefined && message.recentPlayerDeath !== false) {
      writer.uint32(24).bool(message.recentPlayerDeath);
    }
    if (message.playerId !== undefined && message.playerId !== -1) {
      writer.uint32(32).int32(message.playerId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAClientMsgRequestBulkCombatLog {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAClientMsgRequestBulkCombatLog();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.gameTime = reader.float();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.duration = reader.float();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.recentPlayerDeath = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.playerId = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAClientMsgRequestBulkCombatLog {
    return {
      gameTime: isSet(object.gameTime) ? globalThis.Number(object.gameTime) : 0,
      duration: isSet(object.duration) ? globalThis.Number(object.duration) : 0,
      recentPlayerDeath: isSet(object.recentPlayerDeath) ? globalThis.Boolean(object.recentPlayerDeath) : false,
      playerId: isSet(object.playerId) ? globalThis.Number(object.playerId) : -1,
    };
  },

  toJSON(message: CDOTAClientMsgRequestBulkCombatLog): unknown {
    const obj: any = {};
    if (message.gameTime !== undefined && message.gameTime !== 0) {
      obj.gameTime = message.gameTime;
    }
    if (message.duration !== undefined && message.duration !== 0) {
      obj.duration = message.duration;
    }
    if (message.recentPlayerDeath !== undefined && message.recentPlayerDeath !== false) {
      obj.recentPlayerDeath = message.recentPlayerDeath;
    }
    if (message.playerId !== undefined && message.playerId !== -1) {
      obj.playerId = Math.round(message.playerId);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAClientMsgRequestBulkCombatLog>): CDOTAClientMsgRequestBulkCombatLog {
    return CDOTAClientMsgRequestBulkCombatLog.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAClientMsgRequestBulkCombatLog>): CDOTAClientMsgRequestBulkCombatLog {
    const message = createBaseCDOTAClientMsgRequestBulkCombatLog();
    message.gameTime = object.gameTime ?? 0;
    message.duration = object.duration ?? 0;
    message.recentPlayerDeath = object.recentPlayerDeath ?? false;
    message.playerId = object.playerId ?? -1;
    return message;
  },
};

function createBaseCDOTAClientMsgAbilityDraftRequestAbility(): CDOTAClientMsgAbilityDraftRequestAbility {
  return { requestedAbilityId: -1, ctrlIsDown: false, requestedHeroId: 0 };
}

export const CDOTAClientMsgAbilityDraftRequestAbility = {
  encode(message: CDOTAClientMsgAbilityDraftRequestAbility, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.requestedAbilityId !== undefined && message.requestedAbilityId !== -1) {
      writer.uint32(8).int32(message.requestedAbilityId);
    }
    if (message.ctrlIsDown !== undefined && message.ctrlIsDown !== false) {
      writer.uint32(16).bool(message.ctrlIsDown);
    }
    if (message.requestedHeroId !== undefined && message.requestedHeroId !== 0) {
      writer.uint32(24).int32(message.requestedHeroId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAClientMsgAbilityDraftRequestAbility {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAClientMsgAbilityDraftRequestAbility();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.requestedAbilityId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.ctrlIsDown = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.requestedHeroId = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAClientMsgAbilityDraftRequestAbility {
    return {
      requestedAbilityId: isSet(object.requestedAbilityId) ? globalThis.Number(object.requestedAbilityId) : -1,
      ctrlIsDown: isSet(object.ctrlIsDown) ? globalThis.Boolean(object.ctrlIsDown) : false,
      requestedHeroId: isSet(object.requestedHeroId) ? globalThis.Number(object.requestedHeroId) : 0,
    };
  },

  toJSON(message: CDOTAClientMsgAbilityDraftRequestAbility): unknown {
    const obj: any = {};
    if (message.requestedAbilityId !== undefined && message.requestedAbilityId !== -1) {
      obj.requestedAbilityId = Math.round(message.requestedAbilityId);
    }
    if (message.ctrlIsDown !== undefined && message.ctrlIsDown !== false) {
      obj.ctrlIsDown = message.ctrlIsDown;
    }
    if (message.requestedHeroId !== undefined && message.requestedHeroId !== 0) {
      obj.requestedHeroId = Math.round(message.requestedHeroId);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAClientMsgAbilityDraftRequestAbility>): CDOTAClientMsgAbilityDraftRequestAbility {
    return CDOTAClientMsgAbilityDraftRequestAbility.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAClientMsgAbilityDraftRequestAbility>): CDOTAClientMsgAbilityDraftRequestAbility {
    const message = createBaseCDOTAClientMsgAbilityDraftRequestAbility();
    message.requestedAbilityId = object.requestedAbilityId ?? -1;
    message.ctrlIsDown = object.ctrlIsDown ?? false;
    message.requestedHeroId = object.requestedHeroId ?? 0;
    return message;
  },
};

function createBaseCDOTAClientMsgGuideSelectOption(): CDOTAClientMsgGuideSelectOption {
  return { option: 0, forceRecalculate: false };
}

export const CDOTAClientMsgGuideSelectOption = {
  encode(message: CDOTAClientMsgGuideSelectOption, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.option !== undefined && message.option !== 0) {
      writer.uint32(8).uint32(message.option);
    }
    if (message.forceRecalculate !== undefined && message.forceRecalculate !== false) {
      writer.uint32(16).bool(message.forceRecalculate);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAClientMsgGuideSelectOption {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAClientMsgGuideSelectOption();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.option = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.forceRecalculate = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAClientMsgGuideSelectOption {
    return {
      option: isSet(object.option) ? globalThis.Number(object.option) : 0,
      forceRecalculate: isSet(object.forceRecalculate) ? globalThis.Boolean(object.forceRecalculate) : false,
    };
  },

  toJSON(message: CDOTAClientMsgGuideSelectOption): unknown {
    const obj: any = {};
    if (message.option !== undefined && message.option !== 0) {
      obj.option = Math.round(message.option);
    }
    if (message.forceRecalculate !== undefined && message.forceRecalculate !== false) {
      obj.forceRecalculate = message.forceRecalculate;
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAClientMsgGuideSelectOption>): CDOTAClientMsgGuideSelectOption {
    return CDOTAClientMsgGuideSelectOption.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAClientMsgGuideSelectOption>): CDOTAClientMsgGuideSelectOption {
    const message = createBaseCDOTAClientMsgGuideSelectOption();
    message.option = object.option ?? 0;
    message.forceRecalculate = object.forceRecalculate ?? false;
    return message;
  },
};

function createBaseCDOTAClientMsgGuideSelected(): CDOTAClientMsgGuideSelected {
  return { guideWorkshopId: "0", isPlusGuide: false };
}

export const CDOTAClientMsgGuideSelected = {
  encode(message: CDOTAClientMsgGuideSelected, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.guideWorkshopId !== undefined && message.guideWorkshopId !== "0") {
      writer.uint32(8).uint64(message.guideWorkshopId);
    }
    if (message.isPlusGuide !== undefined && message.isPlusGuide !== false) {
      writer.uint32(16).bool(message.isPlusGuide);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAClientMsgGuideSelected {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAClientMsgGuideSelected();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.guideWorkshopId = longToString(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.isPlusGuide = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAClientMsgGuideSelected {
    return {
      guideWorkshopId: isSet(object.guideWorkshopId) ? globalThis.String(object.guideWorkshopId) : "0",
      isPlusGuide: isSet(object.isPlusGuide) ? globalThis.Boolean(object.isPlusGuide) : false,
    };
  },

  toJSON(message: CDOTAClientMsgGuideSelected): unknown {
    const obj: any = {};
    if (message.guideWorkshopId !== undefined && message.guideWorkshopId !== "0") {
      obj.guideWorkshopId = message.guideWorkshopId;
    }
    if (message.isPlusGuide !== undefined && message.isPlusGuide !== false) {
      obj.isPlusGuide = message.isPlusGuide;
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAClientMsgGuideSelected>): CDOTAClientMsgGuideSelected {
    return CDOTAClientMsgGuideSelected.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAClientMsgGuideSelected>): CDOTAClientMsgGuideSelected {
    const message = createBaseCDOTAClientMsgGuideSelected();
    message.guideWorkshopId = object.guideWorkshopId ?? "0";
    message.isPlusGuide = object.isPlusGuide ?? false;
    return message;
  },
};

function createBaseCDOTAClientMsgDamageReport(): CDOTAClientMsgDamageReport {
  return { targetHeroId: 0, sourceHeroId: 0, damageAmount: 0, broadcast: false };
}

export const CDOTAClientMsgDamageReport = {
  encode(message: CDOTAClientMsgDamageReport, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.targetHeroId !== undefined && message.targetHeroId !== 0) {
      writer.uint32(8).int32(message.targetHeroId);
    }
    if (message.sourceHeroId !== undefined && message.sourceHeroId !== 0) {
      writer.uint32(16).int32(message.sourceHeroId);
    }
    if (message.damageAmount !== undefined && message.damageAmount !== 0) {
      writer.uint32(24).int32(message.damageAmount);
    }
    if (message.broadcast !== undefined && message.broadcast !== false) {
      writer.uint32(32).bool(message.broadcast);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAClientMsgDamageReport {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAClientMsgDamageReport();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.targetHeroId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.sourceHeroId = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.damageAmount = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.broadcast = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAClientMsgDamageReport {
    return {
      targetHeroId: isSet(object.targetHeroId) ? globalThis.Number(object.targetHeroId) : 0,
      sourceHeroId: isSet(object.sourceHeroId) ? globalThis.Number(object.sourceHeroId) : 0,
      damageAmount: isSet(object.damageAmount) ? globalThis.Number(object.damageAmount) : 0,
      broadcast: isSet(object.broadcast) ? globalThis.Boolean(object.broadcast) : false,
    };
  },

  toJSON(message: CDOTAClientMsgDamageReport): unknown {
    const obj: any = {};
    if (message.targetHeroId !== undefined && message.targetHeroId !== 0) {
      obj.targetHeroId = Math.round(message.targetHeroId);
    }
    if (message.sourceHeroId !== undefined && message.sourceHeroId !== 0) {
      obj.sourceHeroId = Math.round(message.sourceHeroId);
    }
    if (message.damageAmount !== undefined && message.damageAmount !== 0) {
      obj.damageAmount = Math.round(message.damageAmount);
    }
    if (message.broadcast !== undefined && message.broadcast !== false) {
      obj.broadcast = message.broadcast;
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAClientMsgDamageReport>): CDOTAClientMsgDamageReport {
    return CDOTAClientMsgDamageReport.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAClientMsgDamageReport>): CDOTAClientMsgDamageReport {
    const message = createBaseCDOTAClientMsgDamageReport();
    message.targetHeroId = object.targetHeroId ?? 0;
    message.sourceHeroId = object.sourceHeroId ?? 0;
    message.damageAmount = object.damageAmount ?? 0;
    message.broadcast = object.broadcast ?? false;
    return message;
  },
};

function createBaseCDOTAClientMsgSalutePlayer(): CDOTAClientMsgSalutePlayer {
  return { targetPlayerId: -1, eventId: 0 };
}

export const CDOTAClientMsgSalutePlayer = {
  encode(message: CDOTAClientMsgSalutePlayer, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.targetPlayerId !== undefined && message.targetPlayerId !== -1) {
      writer.uint32(8).int32(message.targetPlayerId);
    }
    if (message.eventId !== undefined && message.eventId !== 0) {
      writer.uint32(16).int32(message.eventId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAClientMsgSalutePlayer {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAClientMsgSalutePlayer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.targetPlayerId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.eventId = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAClientMsgSalutePlayer {
    return {
      targetPlayerId: isSet(object.targetPlayerId) ? globalThis.Number(object.targetPlayerId) : -1,
      eventId: isSet(object.eventId) ? globalThis.Number(object.eventId) : 0,
    };
  },

  toJSON(message: CDOTAClientMsgSalutePlayer): unknown {
    const obj: any = {};
    if (message.targetPlayerId !== undefined && message.targetPlayerId !== -1) {
      obj.targetPlayerId = Math.round(message.targetPlayerId);
    }
    if (message.eventId !== undefined && message.eventId !== 0) {
      obj.eventId = Math.round(message.eventId);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAClientMsgSalutePlayer>): CDOTAClientMsgSalutePlayer {
    return CDOTAClientMsgSalutePlayer.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAClientMsgSalutePlayer>): CDOTAClientMsgSalutePlayer {
    const message = createBaseCDOTAClientMsgSalutePlayer();
    message.targetPlayerId = object.targetPlayerId ?? -1;
    message.eventId = object.eventId ?? 0;
    return message;
  },
};

function createBaseCDOTAClientMsgGiftPlayer(): CDOTAClientMsgGiftPlayer {
  return { targetPlayerId: -1, itemDefIndex: 0 };
}

export const CDOTAClientMsgGiftPlayer = {
  encode(message: CDOTAClientMsgGiftPlayer, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.targetPlayerId !== undefined && message.targetPlayerId !== -1) {
      writer.uint32(8).int32(message.targetPlayerId);
    }
    if (message.itemDefIndex !== undefined && message.itemDefIndex !== 0) {
      writer.uint32(16).uint32(message.itemDefIndex);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAClientMsgGiftPlayer {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAClientMsgGiftPlayer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.targetPlayerId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.itemDefIndex = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAClientMsgGiftPlayer {
    return {
      targetPlayerId: isSet(object.targetPlayerId) ? globalThis.Number(object.targetPlayerId) : -1,
      itemDefIndex: isSet(object.itemDefIndex) ? globalThis.Number(object.itemDefIndex) : 0,
    };
  },

  toJSON(message: CDOTAClientMsgGiftPlayer): unknown {
    const obj: any = {};
    if (message.targetPlayerId !== undefined && message.targetPlayerId !== -1) {
      obj.targetPlayerId = Math.round(message.targetPlayerId);
    }
    if (message.itemDefIndex !== undefined && message.itemDefIndex !== 0) {
      obj.itemDefIndex = Math.round(message.itemDefIndex);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAClientMsgGiftPlayer>): CDOTAClientMsgGiftPlayer {
    return CDOTAClientMsgGiftPlayer.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAClientMsgGiftPlayer>): CDOTAClientMsgGiftPlayer {
    const message = createBaseCDOTAClientMsgGiftPlayer();
    message.targetPlayerId = object.targetPlayerId ?? -1;
    message.itemDefIndex = object.itemDefIndex ?? 0;
    return message;
  },
};

function createBaseCDOTAClientMsgGiftEveryone(): CDOTAClientMsgGiftEveryone {
  return { itemDefIndex: 0 };
}

export const CDOTAClientMsgGiftEveryone = {
  encode(message: CDOTAClientMsgGiftEveryone, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.itemDefIndex !== undefined && message.itemDefIndex !== 0) {
      writer.uint32(8).uint32(message.itemDefIndex);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAClientMsgGiftEveryone {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAClientMsgGiftEveryone();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.itemDefIndex = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAClientMsgGiftEveryone {
    return { itemDefIndex: isSet(object.itemDefIndex) ? globalThis.Number(object.itemDefIndex) : 0 };
  },

  toJSON(message: CDOTAClientMsgGiftEveryone): unknown {
    const obj: any = {};
    if (message.itemDefIndex !== undefined && message.itemDefIndex !== 0) {
      obj.itemDefIndex = Math.round(message.itemDefIndex);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAClientMsgGiftEveryone>): CDOTAClientMsgGiftEveryone {
    return CDOTAClientMsgGiftEveryone.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAClientMsgGiftEveryone>): CDOTAClientMsgGiftEveryone {
    const message = createBaseCDOTAClientMsgGiftEveryone();
    message.itemDefIndex = object.itemDefIndex ?? 0;
    return message;
  },
};

function createBaseCDOTAClientMsgTipAlert(): CDOTAClientMsgTipAlert {
  return { tipText: "" };
}

export const CDOTAClientMsgTipAlert = {
  encode(message: CDOTAClientMsgTipAlert, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.tipText !== undefined && message.tipText !== "") {
      writer.uint32(10).string(message.tipText);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAClientMsgTipAlert {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAClientMsgTipAlert();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.tipText = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAClientMsgTipAlert {
    return { tipText: isSet(object.tipText) ? globalThis.String(object.tipText) : "" };
  },

  toJSON(message: CDOTAClientMsgTipAlert): unknown {
    const obj: any = {};
    if (message.tipText !== undefined && message.tipText !== "") {
      obj.tipText = message.tipText;
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAClientMsgTipAlert>): CDOTAClientMsgTipAlert {
    return CDOTAClientMsgTipAlert.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAClientMsgTipAlert>): CDOTAClientMsgTipAlert {
    const message = createBaseCDOTAClientMsgTipAlert();
    message.tipText = object.tipText ?? "";
    return message;
  },
};

function createBaseCDOTAClientMsgEmptyTeleportAlert(): CDOTAClientMsgEmptyTeleportAlert {
  return { targetEntindex: -1 };
}

export const CDOTAClientMsgEmptyTeleportAlert = {
  encode(message: CDOTAClientMsgEmptyTeleportAlert, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.targetEntindex !== undefined && message.targetEntindex !== -1) {
      writer.uint32(8).int32(message.targetEntindex);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAClientMsgEmptyTeleportAlert {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAClientMsgEmptyTeleportAlert();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.targetEntindex = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAClientMsgEmptyTeleportAlert {
    return { targetEntindex: isSet(object.targetEntindex) ? globalThis.Number(object.targetEntindex) : -1 };
  },

  toJSON(message: CDOTAClientMsgEmptyTeleportAlert): unknown {
    const obj: any = {};
    if (message.targetEntindex !== undefined && message.targetEntindex !== -1) {
      obj.targetEntindex = Math.round(message.targetEntindex);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAClientMsgEmptyTeleportAlert>): CDOTAClientMsgEmptyTeleportAlert {
    return CDOTAClientMsgEmptyTeleportAlert.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAClientMsgEmptyTeleportAlert>): CDOTAClientMsgEmptyTeleportAlert {
    const message = createBaseCDOTAClientMsgEmptyTeleportAlert();
    message.targetEntindex = object.targetEntindex ?? -1;
    return message;
  },
};

function createBaseCDOTAClientMsgSetCavernMapVariant(): CDOTAClientMsgSetCavernMapVariant {
  return { mapVariant: 255 };
}

export const CDOTAClientMsgSetCavernMapVariant = {
  encode(message: CDOTAClientMsgSetCavernMapVariant, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.mapVariant !== undefined && message.mapVariant !== 255) {
      writer.uint32(8).uint32(message.mapVariant);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAClientMsgSetCavernMapVariant {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAClientMsgSetCavernMapVariant();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.mapVariant = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAClientMsgSetCavernMapVariant {
    return { mapVariant: isSet(object.mapVariant) ? globalThis.Number(object.mapVariant) : 255 };
  },

  toJSON(message: CDOTAClientMsgSetCavernMapVariant): unknown {
    const obj: any = {};
    if (message.mapVariant !== undefined && message.mapVariant !== 255) {
      obj.mapVariant = Math.round(message.mapVariant);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAClientMsgSetCavernMapVariant>): CDOTAClientMsgSetCavernMapVariant {
    return CDOTAClientMsgSetCavernMapVariant.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAClientMsgSetCavernMapVariant>): CDOTAClientMsgSetCavernMapVariant {
    const message = createBaseCDOTAClientMsgSetCavernMapVariant();
    message.mapVariant = object.mapVariant ?? 255;
    return message;
  },
};

function createBaseCDOTAClientMsgPauseGameOrder(): CDOTAClientMsgPauseGameOrder {
  return { orderId: 0, data: 0 };
}

export const CDOTAClientMsgPauseGameOrder = {
  encode(message: CDOTAClientMsgPauseGameOrder, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.orderId !== undefined && message.orderId !== 0) {
      writer.uint32(8).int32(message.orderId);
    }
    if (message.data !== undefined && message.data !== 0) {
      writer.uint32(16).int32(message.data);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAClientMsgPauseGameOrder {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAClientMsgPauseGameOrder();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.orderId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.data = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAClientMsgPauseGameOrder {
    return {
      orderId: isSet(object.orderId) ? globalThis.Number(object.orderId) : 0,
      data: isSet(object.data) ? globalThis.Number(object.data) : 0,
    };
  },

  toJSON(message: CDOTAClientMsgPauseGameOrder): unknown {
    const obj: any = {};
    if (message.orderId !== undefined && message.orderId !== 0) {
      obj.orderId = Math.round(message.orderId);
    }
    if (message.data !== undefined && message.data !== 0) {
      obj.data = Math.round(message.data);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAClientMsgPauseGameOrder>): CDOTAClientMsgPauseGameOrder {
    return CDOTAClientMsgPauseGameOrder.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAClientMsgPauseGameOrder>): CDOTAClientMsgPauseGameOrder {
    const message = createBaseCDOTAClientMsgPauseGameOrder();
    message.orderId = object.orderId ?? 0;
    message.data = object.data ?? 0;
    return message;
  },
};

function createBaseCDOTAClientMsgVersusScenePlayerBehavior(): CDOTAClientMsgVersusScenePlayerBehavior {
  return { behavior: 1, playActivity: undefined, chatWheel: undefined, playbackRate: undefined };
}

export const CDOTAClientMsgVersusScenePlayerBehavior = {
  encode(message: CDOTAClientMsgVersusScenePlayerBehavior, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.behavior !== undefined && message.behavior !== 1) {
      writer.uint32(8).int32(message.behavior);
    }
    if (message.playActivity !== undefined) {
      VersusScenePlayActivity.encode(message.playActivity, writer.uint32(18).fork()).ldelim();
    }
    if (message.chatWheel !== undefined) {
      VersusSceneChatWheel.encode(message.chatWheel, writer.uint32(26).fork()).ldelim();
    }
    if (message.playbackRate !== undefined) {
      VersusScenePlaybackRate.encode(message.playbackRate, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAClientMsgVersusScenePlayerBehavior {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAClientMsgVersusScenePlayerBehavior();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.behavior = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.playActivity = VersusScenePlayActivity.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.chatWheel = VersusSceneChatWheel.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.playbackRate = VersusScenePlaybackRate.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAClientMsgVersusScenePlayerBehavior {
    return {
      behavior: isSet(object.behavior) ? eDOTAVersusScenePlayerBehaviorFromJSON(object.behavior) : 1,
      playActivity: isSet(object.playActivity) ? VersusScenePlayActivity.fromJSON(object.playActivity) : undefined,
      chatWheel: isSet(object.chatWheel) ? VersusSceneChatWheel.fromJSON(object.chatWheel) : undefined,
      playbackRate: isSet(object.playbackRate) ? VersusScenePlaybackRate.fromJSON(object.playbackRate) : undefined,
    };
  },

  toJSON(message: CDOTAClientMsgVersusScenePlayerBehavior): unknown {
    const obj: any = {};
    if (message.behavior !== undefined && message.behavior !== 1) {
      obj.behavior = eDOTAVersusScenePlayerBehaviorToJSON(message.behavior);
    }
    if (message.playActivity !== undefined) {
      obj.playActivity = VersusScenePlayActivity.toJSON(message.playActivity);
    }
    if (message.chatWheel !== undefined) {
      obj.chatWheel = VersusSceneChatWheel.toJSON(message.chatWheel);
    }
    if (message.playbackRate !== undefined) {
      obj.playbackRate = VersusScenePlaybackRate.toJSON(message.playbackRate);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAClientMsgVersusScenePlayerBehavior>): CDOTAClientMsgVersusScenePlayerBehavior {
    return CDOTAClientMsgVersusScenePlayerBehavior.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAClientMsgVersusScenePlayerBehavior>): CDOTAClientMsgVersusScenePlayerBehavior {
    const message = createBaseCDOTAClientMsgVersusScenePlayerBehavior();
    message.behavior = object.behavior ?? 1;
    message.playActivity = (object.playActivity !== undefined && object.playActivity !== null)
      ? VersusScenePlayActivity.fromPartial(object.playActivity)
      : undefined;
    message.chatWheel = (object.chatWheel !== undefined && object.chatWheel !== null)
      ? VersusSceneChatWheel.fromPartial(object.chatWheel)
      : undefined;
    message.playbackRate = (object.playbackRate !== undefined && object.playbackRate !== null)
      ? VersusScenePlaybackRate.fromPartial(object.playbackRate)
      : undefined;
    return message;
  },
};

function createBaseCDOTAClientMsgEmptyItemSlotAlert(): CDOTAClientMsgEmptyItemSlotAlert {
  return { targetEntindex: -1, slotIndex: 0 };
}

export const CDOTAClientMsgEmptyItemSlotAlert = {
  encode(message: CDOTAClientMsgEmptyItemSlotAlert, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.targetEntindex !== undefined && message.targetEntindex !== -1) {
      writer.uint32(8).int32(message.targetEntindex);
    }
    if (message.slotIndex !== undefined && message.slotIndex !== 0) {
      writer.uint32(16).int32(message.slotIndex);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAClientMsgEmptyItemSlotAlert {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAClientMsgEmptyItemSlotAlert();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.targetEntindex = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.slotIndex = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAClientMsgEmptyItemSlotAlert {
    return {
      targetEntindex: isSet(object.targetEntindex) ? globalThis.Number(object.targetEntindex) : -1,
      slotIndex: isSet(object.slotIndex) ? globalThis.Number(object.slotIndex) : 0,
    };
  },

  toJSON(message: CDOTAClientMsgEmptyItemSlotAlert): unknown {
    const obj: any = {};
    if (message.targetEntindex !== undefined && message.targetEntindex !== -1) {
      obj.targetEntindex = Math.round(message.targetEntindex);
    }
    if (message.slotIndex !== undefined && message.slotIndex !== 0) {
      obj.slotIndex = Math.round(message.slotIndex);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAClientMsgEmptyItemSlotAlert>): CDOTAClientMsgEmptyItemSlotAlert {
    return CDOTAClientMsgEmptyItemSlotAlert.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAClientMsgEmptyItemSlotAlert>): CDOTAClientMsgEmptyItemSlotAlert {
    const message = createBaseCDOTAClientMsgEmptyItemSlotAlert();
    message.targetEntindex = object.targetEntindex ?? -1;
    message.slotIndex = object.slotIndex ?? 0;
    return message;
  },
};

function createBaseCDOTAClientMsgAddOverwatchReportMarker(): CDOTAClientMsgAddOverwatchReportMarker {
  return { targetPlayerId: -1, reason: 0, secondsAgo: 0 };
}

export const CDOTAClientMsgAddOverwatchReportMarker = {
  encode(message: CDOTAClientMsgAddOverwatchReportMarker, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.targetPlayerId !== undefined && message.targetPlayerId !== -1) {
      writer.uint32(8).int32(message.targetPlayerId);
    }
    if (message.reason !== undefined && message.reason !== 0) {
      writer.uint32(16).int32(message.reason);
    }
    if (message.secondsAgo !== undefined && message.secondsAgo !== 0) {
      writer.uint32(32).uint32(message.secondsAgo);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAClientMsgAddOverwatchReportMarker {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAClientMsgAddOverwatchReportMarker();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.targetPlayerId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.reason = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.secondsAgo = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAClientMsgAddOverwatchReportMarker {
    return {
      targetPlayerId: isSet(object.targetPlayerId) ? globalThis.Number(object.targetPlayerId) : -1,
      reason: isSet(object.reason) ? eOverwatchReportReasonFromJSON(object.reason) : 0,
      secondsAgo: isSet(object.secondsAgo) ? globalThis.Number(object.secondsAgo) : 0,
    };
  },

  toJSON(message: CDOTAClientMsgAddOverwatchReportMarker): unknown {
    const obj: any = {};
    if (message.targetPlayerId !== undefined && message.targetPlayerId !== -1) {
      obj.targetPlayerId = Math.round(message.targetPlayerId);
    }
    if (message.reason !== undefined && message.reason !== 0) {
      obj.reason = eOverwatchReportReasonToJSON(message.reason);
    }
    if (message.secondsAgo !== undefined && message.secondsAgo !== 0) {
      obj.secondsAgo = Math.round(message.secondsAgo);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAClientMsgAddOverwatchReportMarker>): CDOTAClientMsgAddOverwatchReportMarker {
    return CDOTAClientMsgAddOverwatchReportMarker.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAClientMsgAddOverwatchReportMarker>): CDOTAClientMsgAddOverwatchReportMarker {
    const message = createBaseCDOTAClientMsgAddOverwatchReportMarker();
    message.targetPlayerId = object.targetPlayerId ?? -1;
    message.reason = object.reason ?? 0;
    message.secondsAgo = object.secondsAgo ?? 0;
    return message;
  },
};

function createBaseCDOTAClientMsgAddCommunicationsReportMarker(): CDOTAClientMsgAddCommunicationsReportMarker {
  return { targetPlayerId: -1 };
}

export const CDOTAClientMsgAddCommunicationsReportMarker = {
  encode(message: CDOTAClientMsgAddCommunicationsReportMarker, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.targetPlayerId !== undefined && message.targetPlayerId !== -1) {
      writer.uint32(8).int32(message.targetPlayerId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAClientMsgAddCommunicationsReportMarker {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAClientMsgAddCommunicationsReportMarker();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.targetPlayerId = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAClientMsgAddCommunicationsReportMarker {
    return { targetPlayerId: isSet(object.targetPlayerId) ? globalThis.Number(object.targetPlayerId) : -1 };
  },

  toJSON(message: CDOTAClientMsgAddCommunicationsReportMarker): unknown {
    const obj: any = {};
    if (message.targetPlayerId !== undefined && message.targetPlayerId !== -1) {
      obj.targetPlayerId = Math.round(message.targetPlayerId);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAClientMsgAddCommunicationsReportMarker>): CDOTAClientMsgAddCommunicationsReportMarker {
    return CDOTAClientMsgAddCommunicationsReportMarker.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CDOTAClientMsgAddCommunicationsReportMarker>,
  ): CDOTAClientMsgAddCommunicationsReportMarker {
    const message = createBaseCDOTAClientMsgAddCommunicationsReportMarker();
    message.targetPlayerId = object.targetPlayerId ?? -1;
    return message;
  },
};

function createBaseCDOTAClientMsgAddCommunicationsBlockMarker(): CDOTAClientMsgAddCommunicationsBlockMarker {
  return { targetPlayerId: -1 };
}

export const CDOTAClientMsgAddCommunicationsBlockMarker = {
  encode(message: CDOTAClientMsgAddCommunicationsBlockMarker, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.targetPlayerId !== undefined && message.targetPlayerId !== -1) {
      writer.uint32(8).int32(message.targetPlayerId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAClientMsgAddCommunicationsBlockMarker {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAClientMsgAddCommunicationsBlockMarker();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.targetPlayerId = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAClientMsgAddCommunicationsBlockMarker {
    return { targetPlayerId: isSet(object.targetPlayerId) ? globalThis.Number(object.targetPlayerId) : -1 };
  },

  toJSON(message: CDOTAClientMsgAddCommunicationsBlockMarker): unknown {
    const obj: any = {};
    if (message.targetPlayerId !== undefined && message.targetPlayerId !== -1) {
      obj.targetPlayerId = Math.round(message.targetPlayerId);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAClientMsgAddCommunicationsBlockMarker>): CDOTAClientMsgAddCommunicationsBlockMarker {
    return CDOTAClientMsgAddCommunicationsBlockMarker.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CDOTAClientMsgAddCommunicationsBlockMarker>,
  ): CDOTAClientMsgAddCommunicationsBlockMarker {
    const message = createBaseCDOTAClientMsgAddCommunicationsBlockMarker();
    message.targetPlayerId = object.targetPlayerId ?? -1;
    return message;
  },
};

function createBaseCDOTAClientMsgAghsStatusAlert(): CDOTAClientMsgAghsStatusAlert {
  return { sourcePlayerId: -1, targetPlayerId: -1, targetEntindex: -1, alertType: 0 };
}

export const CDOTAClientMsgAghsStatusAlert = {
  encode(message: CDOTAClientMsgAghsStatusAlert, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sourcePlayerId !== undefined && message.sourcePlayerId !== -1) {
      writer.uint32(8).int32(message.sourcePlayerId);
    }
    if (message.targetPlayerId !== undefined && message.targetPlayerId !== -1) {
      writer.uint32(16).int32(message.targetPlayerId);
    }
    if (message.targetEntindex !== undefined && message.targetEntindex !== -1) {
      writer.uint32(24).int32(message.targetEntindex);
    }
    if (message.alertType !== undefined && message.alertType !== 0) {
      writer.uint32(32).uint32(message.alertType);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAClientMsgAghsStatusAlert {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAClientMsgAghsStatusAlert();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.sourcePlayerId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.targetPlayerId = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.targetEntindex = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.alertType = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAClientMsgAghsStatusAlert {
    return {
      sourcePlayerId: isSet(object.sourcePlayerId) ? globalThis.Number(object.sourcePlayerId) : -1,
      targetPlayerId: isSet(object.targetPlayerId) ? globalThis.Number(object.targetPlayerId) : -1,
      targetEntindex: isSet(object.targetEntindex) ? globalThis.Number(object.targetEntindex) : -1,
      alertType: isSet(object.alertType) ? globalThis.Number(object.alertType) : 0,
    };
  },

  toJSON(message: CDOTAClientMsgAghsStatusAlert): unknown {
    const obj: any = {};
    if (message.sourcePlayerId !== undefined && message.sourcePlayerId !== -1) {
      obj.sourcePlayerId = Math.round(message.sourcePlayerId);
    }
    if (message.targetPlayerId !== undefined && message.targetPlayerId !== -1) {
      obj.targetPlayerId = Math.round(message.targetPlayerId);
    }
    if (message.targetEntindex !== undefined && message.targetEntindex !== -1) {
      obj.targetEntindex = Math.round(message.targetEntindex);
    }
    if (message.alertType !== undefined && message.alertType !== 0) {
      obj.alertType = Math.round(message.alertType);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAClientMsgAghsStatusAlert>): CDOTAClientMsgAghsStatusAlert {
    return CDOTAClientMsgAghsStatusAlert.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAClientMsgAghsStatusAlert>): CDOTAClientMsgAghsStatusAlert {
    const message = createBaseCDOTAClientMsgAghsStatusAlert();
    message.sourcePlayerId = object.sourcePlayerId ?? -1;
    message.targetPlayerId = object.targetPlayerId ?? -1;
    message.targetEntindex = object.targetEntindex ?? -1;
    message.alertType = object.alertType ?? 0;
    return message;
  },
};

function createBaseCDOTAClientMsgPerfReport(): CDOTAClientMsgPerfReport {
  return {
    averageFrameTime: 0,
    maxFrameTime: 0,
    averageComputeTime: 0,
    maxComputeTime: 0,
    averageClientTickTime: 0,
    maxClientTickTime: 0,
    averageClientSimulateTime: 0,
    maxClientSimulateTime: 0,
    averageOutputTime: 0,
    maxOutputTime: 0,
    averageWaitForRenderingToCompleteTime: 0,
    maxWaitForRenderingToCompleteTime: 0,
    averageSwapTime: 0,
    maxSwapTime: 0,
    averageFrameUpdateTime: 0,
    maxFrameUpdateTime: 0,
    averageIdleTime: 0,
    maxIdleTime: 0,
    averageInputProcessingTime: 0,
    maxInputProcessingTime: 0,
  };
}

export const CDOTAClientMsgPerfReport = {
  encode(message: CDOTAClientMsgPerfReport, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.averageFrameTime !== undefined && message.averageFrameTime !== 0) {
      writer.uint32(13).float(message.averageFrameTime);
    }
    if (message.maxFrameTime !== undefined && message.maxFrameTime !== 0) {
      writer.uint32(21).float(message.maxFrameTime);
    }
    if (message.averageComputeTime !== undefined && message.averageComputeTime !== 0) {
      writer.uint32(29).float(message.averageComputeTime);
    }
    if (message.maxComputeTime !== undefined && message.maxComputeTime !== 0) {
      writer.uint32(37).float(message.maxComputeTime);
    }
    if (message.averageClientTickTime !== undefined && message.averageClientTickTime !== 0) {
      writer.uint32(45).float(message.averageClientTickTime);
    }
    if (message.maxClientTickTime !== undefined && message.maxClientTickTime !== 0) {
      writer.uint32(53).float(message.maxClientTickTime);
    }
    if (message.averageClientSimulateTime !== undefined && message.averageClientSimulateTime !== 0) {
      writer.uint32(61).float(message.averageClientSimulateTime);
    }
    if (message.maxClientSimulateTime !== undefined && message.maxClientSimulateTime !== 0) {
      writer.uint32(69).float(message.maxClientSimulateTime);
    }
    if (message.averageOutputTime !== undefined && message.averageOutputTime !== 0) {
      writer.uint32(77).float(message.averageOutputTime);
    }
    if (message.maxOutputTime !== undefined && message.maxOutputTime !== 0) {
      writer.uint32(85).float(message.maxOutputTime);
    }
    if (
      message.averageWaitForRenderingToCompleteTime !== undefined && message.averageWaitForRenderingToCompleteTime !== 0
    ) {
      writer.uint32(93).float(message.averageWaitForRenderingToCompleteTime);
    }
    if (message.maxWaitForRenderingToCompleteTime !== undefined && message.maxWaitForRenderingToCompleteTime !== 0) {
      writer.uint32(101).float(message.maxWaitForRenderingToCompleteTime);
    }
    if (message.averageSwapTime !== undefined && message.averageSwapTime !== 0) {
      writer.uint32(109).float(message.averageSwapTime);
    }
    if (message.maxSwapTime !== undefined && message.maxSwapTime !== 0) {
      writer.uint32(117).float(message.maxSwapTime);
    }
    if (message.averageFrameUpdateTime !== undefined && message.averageFrameUpdateTime !== 0) {
      writer.uint32(125).float(message.averageFrameUpdateTime);
    }
    if (message.maxFrameUpdateTime !== undefined && message.maxFrameUpdateTime !== 0) {
      writer.uint32(133).float(message.maxFrameUpdateTime);
    }
    if (message.averageIdleTime !== undefined && message.averageIdleTime !== 0) {
      writer.uint32(141).float(message.averageIdleTime);
    }
    if (message.maxIdleTime !== undefined && message.maxIdleTime !== 0) {
      writer.uint32(149).float(message.maxIdleTime);
    }
    if (message.averageInputProcessingTime !== undefined && message.averageInputProcessingTime !== 0) {
      writer.uint32(157).float(message.averageInputProcessingTime);
    }
    if (message.maxInputProcessingTime !== undefined && message.maxInputProcessingTime !== 0) {
      writer.uint32(165).float(message.maxInputProcessingTime);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAClientMsgPerfReport {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAClientMsgPerfReport();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.averageFrameTime = reader.float();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.maxFrameTime = reader.float();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.averageComputeTime = reader.float();
          continue;
        case 4:
          if (tag !== 37) {
            break;
          }

          message.maxComputeTime = reader.float();
          continue;
        case 5:
          if (tag !== 45) {
            break;
          }

          message.averageClientTickTime = reader.float();
          continue;
        case 6:
          if (tag !== 53) {
            break;
          }

          message.maxClientTickTime = reader.float();
          continue;
        case 7:
          if (tag !== 61) {
            break;
          }

          message.averageClientSimulateTime = reader.float();
          continue;
        case 8:
          if (tag !== 69) {
            break;
          }

          message.maxClientSimulateTime = reader.float();
          continue;
        case 9:
          if (tag !== 77) {
            break;
          }

          message.averageOutputTime = reader.float();
          continue;
        case 10:
          if (tag !== 85) {
            break;
          }

          message.maxOutputTime = reader.float();
          continue;
        case 11:
          if (tag !== 93) {
            break;
          }

          message.averageWaitForRenderingToCompleteTime = reader.float();
          continue;
        case 12:
          if (tag !== 101) {
            break;
          }

          message.maxWaitForRenderingToCompleteTime = reader.float();
          continue;
        case 13:
          if (tag !== 109) {
            break;
          }

          message.averageSwapTime = reader.float();
          continue;
        case 14:
          if (tag !== 117) {
            break;
          }

          message.maxSwapTime = reader.float();
          continue;
        case 15:
          if (tag !== 125) {
            break;
          }

          message.averageFrameUpdateTime = reader.float();
          continue;
        case 16:
          if (tag !== 133) {
            break;
          }

          message.maxFrameUpdateTime = reader.float();
          continue;
        case 17:
          if (tag !== 141) {
            break;
          }

          message.averageIdleTime = reader.float();
          continue;
        case 18:
          if (tag !== 149) {
            break;
          }

          message.maxIdleTime = reader.float();
          continue;
        case 19:
          if (tag !== 157) {
            break;
          }

          message.averageInputProcessingTime = reader.float();
          continue;
        case 20:
          if (tag !== 165) {
            break;
          }

          message.maxInputProcessingTime = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAClientMsgPerfReport {
    return {
      averageFrameTime: isSet(object.averageFrameTime) ? globalThis.Number(object.averageFrameTime) : 0,
      maxFrameTime: isSet(object.maxFrameTime) ? globalThis.Number(object.maxFrameTime) : 0,
      averageComputeTime: isSet(object.averageComputeTime) ? globalThis.Number(object.averageComputeTime) : 0,
      maxComputeTime: isSet(object.maxComputeTime) ? globalThis.Number(object.maxComputeTime) : 0,
      averageClientTickTime: isSet(object.averageClientTickTime) ? globalThis.Number(object.averageClientTickTime) : 0,
      maxClientTickTime: isSet(object.maxClientTickTime) ? globalThis.Number(object.maxClientTickTime) : 0,
      averageClientSimulateTime: isSet(object.averageClientSimulateTime)
        ? globalThis.Number(object.averageClientSimulateTime)
        : 0,
      maxClientSimulateTime: isSet(object.maxClientSimulateTime) ? globalThis.Number(object.maxClientSimulateTime) : 0,
      averageOutputTime: isSet(object.averageOutputTime) ? globalThis.Number(object.averageOutputTime) : 0,
      maxOutputTime: isSet(object.maxOutputTime) ? globalThis.Number(object.maxOutputTime) : 0,
      averageWaitForRenderingToCompleteTime: isSet(object.averageWaitForRenderingToCompleteTime)
        ? globalThis.Number(object.averageWaitForRenderingToCompleteTime)
        : 0,
      maxWaitForRenderingToCompleteTime: isSet(object.maxWaitForRenderingToCompleteTime)
        ? globalThis.Number(object.maxWaitForRenderingToCompleteTime)
        : 0,
      averageSwapTime: isSet(object.averageSwapTime) ? globalThis.Number(object.averageSwapTime) : 0,
      maxSwapTime: isSet(object.maxSwapTime) ? globalThis.Number(object.maxSwapTime) : 0,
      averageFrameUpdateTime: isSet(object.averageFrameUpdateTime)
        ? globalThis.Number(object.averageFrameUpdateTime)
        : 0,
      maxFrameUpdateTime: isSet(object.maxFrameUpdateTime) ? globalThis.Number(object.maxFrameUpdateTime) : 0,
      averageIdleTime: isSet(object.averageIdleTime) ? globalThis.Number(object.averageIdleTime) : 0,
      maxIdleTime: isSet(object.maxIdleTime) ? globalThis.Number(object.maxIdleTime) : 0,
      averageInputProcessingTime: isSet(object.averageInputProcessingTime)
        ? globalThis.Number(object.averageInputProcessingTime)
        : 0,
      maxInputProcessingTime: isSet(object.maxInputProcessingTime)
        ? globalThis.Number(object.maxInputProcessingTime)
        : 0,
    };
  },

  toJSON(message: CDOTAClientMsgPerfReport): unknown {
    const obj: any = {};
    if (message.averageFrameTime !== undefined && message.averageFrameTime !== 0) {
      obj.averageFrameTime = message.averageFrameTime;
    }
    if (message.maxFrameTime !== undefined && message.maxFrameTime !== 0) {
      obj.maxFrameTime = message.maxFrameTime;
    }
    if (message.averageComputeTime !== undefined && message.averageComputeTime !== 0) {
      obj.averageComputeTime = message.averageComputeTime;
    }
    if (message.maxComputeTime !== undefined && message.maxComputeTime !== 0) {
      obj.maxComputeTime = message.maxComputeTime;
    }
    if (message.averageClientTickTime !== undefined && message.averageClientTickTime !== 0) {
      obj.averageClientTickTime = message.averageClientTickTime;
    }
    if (message.maxClientTickTime !== undefined && message.maxClientTickTime !== 0) {
      obj.maxClientTickTime = message.maxClientTickTime;
    }
    if (message.averageClientSimulateTime !== undefined && message.averageClientSimulateTime !== 0) {
      obj.averageClientSimulateTime = message.averageClientSimulateTime;
    }
    if (message.maxClientSimulateTime !== undefined && message.maxClientSimulateTime !== 0) {
      obj.maxClientSimulateTime = message.maxClientSimulateTime;
    }
    if (message.averageOutputTime !== undefined && message.averageOutputTime !== 0) {
      obj.averageOutputTime = message.averageOutputTime;
    }
    if (message.maxOutputTime !== undefined && message.maxOutputTime !== 0) {
      obj.maxOutputTime = message.maxOutputTime;
    }
    if (
      message.averageWaitForRenderingToCompleteTime !== undefined && message.averageWaitForRenderingToCompleteTime !== 0
    ) {
      obj.averageWaitForRenderingToCompleteTime = message.averageWaitForRenderingToCompleteTime;
    }
    if (message.maxWaitForRenderingToCompleteTime !== undefined && message.maxWaitForRenderingToCompleteTime !== 0) {
      obj.maxWaitForRenderingToCompleteTime = message.maxWaitForRenderingToCompleteTime;
    }
    if (message.averageSwapTime !== undefined && message.averageSwapTime !== 0) {
      obj.averageSwapTime = message.averageSwapTime;
    }
    if (message.maxSwapTime !== undefined && message.maxSwapTime !== 0) {
      obj.maxSwapTime = message.maxSwapTime;
    }
    if (message.averageFrameUpdateTime !== undefined && message.averageFrameUpdateTime !== 0) {
      obj.averageFrameUpdateTime = message.averageFrameUpdateTime;
    }
    if (message.maxFrameUpdateTime !== undefined && message.maxFrameUpdateTime !== 0) {
      obj.maxFrameUpdateTime = message.maxFrameUpdateTime;
    }
    if (message.averageIdleTime !== undefined && message.averageIdleTime !== 0) {
      obj.averageIdleTime = message.averageIdleTime;
    }
    if (message.maxIdleTime !== undefined && message.maxIdleTime !== 0) {
      obj.maxIdleTime = message.maxIdleTime;
    }
    if (message.averageInputProcessingTime !== undefined && message.averageInputProcessingTime !== 0) {
      obj.averageInputProcessingTime = message.averageInputProcessingTime;
    }
    if (message.maxInputProcessingTime !== undefined && message.maxInputProcessingTime !== 0) {
      obj.maxInputProcessingTime = message.maxInputProcessingTime;
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAClientMsgPerfReport>): CDOTAClientMsgPerfReport {
    return CDOTAClientMsgPerfReport.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAClientMsgPerfReport>): CDOTAClientMsgPerfReport {
    const message = createBaseCDOTAClientMsgPerfReport();
    message.averageFrameTime = object.averageFrameTime ?? 0;
    message.maxFrameTime = object.maxFrameTime ?? 0;
    message.averageComputeTime = object.averageComputeTime ?? 0;
    message.maxComputeTime = object.maxComputeTime ?? 0;
    message.averageClientTickTime = object.averageClientTickTime ?? 0;
    message.maxClientTickTime = object.maxClientTickTime ?? 0;
    message.averageClientSimulateTime = object.averageClientSimulateTime ?? 0;
    message.maxClientSimulateTime = object.maxClientSimulateTime ?? 0;
    message.averageOutputTime = object.averageOutputTime ?? 0;
    message.maxOutputTime = object.maxOutputTime ?? 0;
    message.averageWaitForRenderingToCompleteTime = object.averageWaitForRenderingToCompleteTime ?? 0;
    message.maxWaitForRenderingToCompleteTime = object.maxWaitForRenderingToCompleteTime ?? 0;
    message.averageSwapTime = object.averageSwapTime ?? 0;
    message.maxSwapTime = object.maxSwapTime ?? 0;
    message.averageFrameUpdateTime = object.averageFrameUpdateTime ?? 0;
    message.maxFrameUpdateTime = object.maxFrameUpdateTime ?? 0;
    message.averageIdleTime = object.averageIdleTime ?? 0;
    message.maxIdleTime = object.maxIdleTime ?? 0;
    message.averageInputProcessingTime = object.averageInputProcessingTime ?? 0;
    message.maxInputProcessingTime = object.maxInputProcessingTime ?? 0;
    return message;
  },
};

function createBaseCDOTAClientMsgContextualTipsSubscribeEntry(): CDOTAClientMsgContextualTipsSubscribeEntry {
  return { unsubscribe: false, tipId: 0, priorDisplayCount: 0, variantsSeen: [] };
}

export const CDOTAClientMsgContextualTipsSubscribeEntry = {
  encode(message: CDOTAClientMsgContextualTipsSubscribeEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.unsubscribe !== undefined && message.unsubscribe !== false) {
      writer.uint32(8).bool(message.unsubscribe);
    }
    if (message.tipId !== undefined && message.tipId !== 0) {
      writer.uint32(16).int32(message.tipId);
    }
    if (message.priorDisplayCount !== undefined && message.priorDisplayCount !== 0) {
      writer.uint32(24).int32(message.priorDisplayCount);
    }
    writer.uint32(34).fork();
    for (const v of message.variantsSeen) {
      writer.int32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAClientMsgContextualTipsSubscribeEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAClientMsgContextualTipsSubscribeEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.unsubscribe = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.tipId = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.priorDisplayCount = reader.int32();
          continue;
        case 4:
          if (tag === 32) {
            message.variantsSeen.push(reader.int32());

            continue;
          }

          if (tag === 34) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.variantsSeen.push(reader.int32());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAClientMsgContextualTipsSubscribeEntry {
    return {
      unsubscribe: isSet(object.unsubscribe) ? globalThis.Boolean(object.unsubscribe) : false,
      tipId: isSet(object.tipId) ? globalThis.Number(object.tipId) : 0,
      priorDisplayCount: isSet(object.priorDisplayCount) ? globalThis.Number(object.priorDisplayCount) : 0,
      variantsSeen: globalThis.Array.isArray(object?.variantsSeen)
        ? object.variantsSeen.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: CDOTAClientMsgContextualTipsSubscribeEntry): unknown {
    const obj: any = {};
    if (message.unsubscribe !== undefined && message.unsubscribe !== false) {
      obj.unsubscribe = message.unsubscribe;
    }
    if (message.tipId !== undefined && message.tipId !== 0) {
      obj.tipId = Math.round(message.tipId);
    }
    if (message.priorDisplayCount !== undefined && message.priorDisplayCount !== 0) {
      obj.priorDisplayCount = Math.round(message.priorDisplayCount);
    }
    if (message.variantsSeen?.length) {
      obj.variantsSeen = message.variantsSeen.map((e) => Math.round(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAClientMsgContextualTipsSubscribeEntry>): CDOTAClientMsgContextualTipsSubscribeEntry {
    return CDOTAClientMsgContextualTipsSubscribeEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CDOTAClientMsgContextualTipsSubscribeEntry>,
  ): CDOTAClientMsgContextualTipsSubscribeEntry {
    const message = createBaseCDOTAClientMsgContextualTipsSubscribeEntry();
    message.unsubscribe = object.unsubscribe ?? false;
    message.tipId = object.tipId ?? 0;
    message.priorDisplayCount = object.priorDisplayCount ?? 0;
    message.variantsSeen = object.variantsSeen?.map((e) => e) || [];
    return message;
  },
};

function createBaseCDOTAClientMsgContextualTipsSubscribe(): CDOTAClientMsgContextualTipsSubscribe {
  return { tips: [] };
}

export const CDOTAClientMsgContextualTipsSubscribe = {
  encode(message: CDOTAClientMsgContextualTipsSubscribe, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.tips) {
      CDOTAClientMsgContextualTipsSubscribeEntry.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAClientMsgContextualTipsSubscribe {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAClientMsgContextualTipsSubscribe();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.tips.push(CDOTAClientMsgContextualTipsSubscribeEntry.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAClientMsgContextualTipsSubscribe {
    return {
      tips: globalThis.Array.isArray(object?.tips)
        ? object.tips.map((e: any) => CDOTAClientMsgContextualTipsSubscribeEntry.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CDOTAClientMsgContextualTipsSubscribe): unknown {
    const obj: any = {};
    if (message.tips?.length) {
      obj.tips = message.tips.map((e) => CDOTAClientMsgContextualTipsSubscribeEntry.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAClientMsgContextualTipsSubscribe>): CDOTAClientMsgContextualTipsSubscribe {
    return CDOTAClientMsgContextualTipsSubscribe.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAClientMsgContextualTipsSubscribe>): CDOTAClientMsgContextualTipsSubscribe {
    const message = createBaseCDOTAClientMsgContextualTipsSubscribe();
    message.tips = object.tips?.map((e) => CDOTAClientMsgContextualTipsSubscribeEntry.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCDOTAClientMsgChatMessage(): CDOTAClientMsgChatMessage {
  return { channelType: 0, messageText: "" };
}

export const CDOTAClientMsgChatMessage = {
  encode(message: CDOTAClientMsgChatMessage, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.channelType !== undefined && message.channelType !== 0) {
      writer.uint32(8).uint32(message.channelType);
    }
    if (message.messageText !== undefined && message.messageText !== "") {
      writer.uint32(18).string(message.messageText);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAClientMsgChatMessage {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAClientMsgChatMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.channelType = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.messageText = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAClientMsgChatMessage {
    return {
      channelType: isSet(object.channelType) ? globalThis.Number(object.channelType) : 0,
      messageText: isSet(object.messageText) ? globalThis.String(object.messageText) : "",
    };
  },

  toJSON(message: CDOTAClientMsgChatMessage): unknown {
    const obj: any = {};
    if (message.channelType !== undefined && message.channelType !== 0) {
      obj.channelType = Math.round(message.channelType);
    }
    if (message.messageText !== undefined && message.messageText !== "") {
      obj.messageText = message.messageText;
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAClientMsgChatMessage>): CDOTAClientMsgChatMessage {
    return CDOTAClientMsgChatMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAClientMsgChatMessage>): CDOTAClientMsgChatMessage {
    const message = createBaseCDOTAClientMsgChatMessage();
    message.channelType = object.channelType ?? 0;
    message.messageText = object.messageText ?? "";
    return message;
  },
};

function createBaseCDOTAClientMsgDuelAccepted(): CDOTAClientMsgDuelAccepted {
  return { challengerPlayerId: -1, accepterPlayerId: -1 };
}

export const CDOTAClientMsgDuelAccepted = {
  encode(message: CDOTAClientMsgDuelAccepted, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.challengerPlayerId !== undefined && message.challengerPlayerId !== -1) {
      writer.uint32(8).int32(message.challengerPlayerId);
    }
    if (message.accepterPlayerId !== undefined && message.accepterPlayerId !== -1) {
      writer.uint32(16).int32(message.accepterPlayerId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAClientMsgDuelAccepted {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAClientMsgDuelAccepted();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.challengerPlayerId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.accepterPlayerId = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAClientMsgDuelAccepted {
    return {
      challengerPlayerId: isSet(object.challengerPlayerId) ? globalThis.Number(object.challengerPlayerId) : -1,
      accepterPlayerId: isSet(object.accepterPlayerId) ? globalThis.Number(object.accepterPlayerId) : -1,
    };
  },

  toJSON(message: CDOTAClientMsgDuelAccepted): unknown {
    const obj: any = {};
    if (message.challengerPlayerId !== undefined && message.challengerPlayerId !== -1) {
      obj.challengerPlayerId = Math.round(message.challengerPlayerId);
    }
    if (message.accepterPlayerId !== undefined && message.accepterPlayerId !== -1) {
      obj.accepterPlayerId = Math.round(message.accepterPlayerId);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAClientMsgDuelAccepted>): CDOTAClientMsgDuelAccepted {
    return CDOTAClientMsgDuelAccepted.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAClientMsgDuelAccepted>): CDOTAClientMsgDuelAccepted {
    const message = createBaseCDOTAClientMsgDuelAccepted();
    message.challengerPlayerId = object.challengerPlayerId ?? -1;
    message.accepterPlayerId = object.accepterPlayerId ?? -1;
    return message;
  },
};

function createBaseCDOTAClientMsgChooseNeutralItem(): CDOTAClientMsgChooseNeutralItem {
  return { neutralItemIndex: 0, targetEntindex: -1, slotIndex: 0 };
}

export const CDOTAClientMsgChooseNeutralItem = {
  encode(message: CDOTAClientMsgChooseNeutralItem, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.neutralItemIndex !== undefined && message.neutralItemIndex !== 0) {
      writer.uint32(8).int32(message.neutralItemIndex);
    }
    if (message.targetEntindex !== undefined && message.targetEntindex !== -1) {
      writer.uint32(16).int32(message.targetEntindex);
    }
    if (message.slotIndex !== undefined && message.slotIndex !== 0) {
      writer.uint32(24).int32(message.slotIndex);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAClientMsgChooseNeutralItem {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAClientMsgChooseNeutralItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.neutralItemIndex = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.targetEntindex = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.slotIndex = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAClientMsgChooseNeutralItem {
    return {
      neutralItemIndex: isSet(object.neutralItemIndex) ? globalThis.Number(object.neutralItemIndex) : 0,
      targetEntindex: isSet(object.targetEntindex) ? globalThis.Number(object.targetEntindex) : -1,
      slotIndex: isSet(object.slotIndex) ? globalThis.Number(object.slotIndex) : 0,
    };
  },

  toJSON(message: CDOTAClientMsgChooseNeutralItem): unknown {
    const obj: any = {};
    if (message.neutralItemIndex !== undefined && message.neutralItemIndex !== 0) {
      obj.neutralItemIndex = Math.round(message.neutralItemIndex);
    }
    if (message.targetEntindex !== undefined && message.targetEntindex !== -1) {
      obj.targetEntindex = Math.round(message.targetEntindex);
    }
    if (message.slotIndex !== undefined && message.slotIndex !== 0) {
      obj.slotIndex = Math.round(message.slotIndex);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAClientMsgChooseNeutralItem>): CDOTAClientMsgChooseNeutralItem {
    return CDOTAClientMsgChooseNeutralItem.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAClientMsgChooseNeutralItem>): CDOTAClientMsgChooseNeutralItem {
    const message = createBaseCDOTAClientMsgChooseNeutralItem();
    message.neutralItemIndex = object.neutralItemIndex ?? 0;
    message.targetEntindex = object.targetEntindex ?? -1;
    message.slotIndex = object.slotIndex ?? 0;
    return message;
  },
};

function createBaseCDOTAClientMsgRerollNeutralItem(): CDOTAClientMsgRerollNeutralItem {
  return { targetEntindex: -1, slotIndex: 0 };
}

export const CDOTAClientMsgRerollNeutralItem = {
  encode(message: CDOTAClientMsgRerollNeutralItem, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.targetEntindex !== undefined && message.targetEntindex !== -1) {
      writer.uint32(8).int32(message.targetEntindex);
    }
    if (message.slotIndex !== undefined && message.slotIndex !== 0) {
      writer.uint32(16).int32(message.slotIndex);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAClientMsgRerollNeutralItem {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAClientMsgRerollNeutralItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.targetEntindex = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.slotIndex = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAClientMsgRerollNeutralItem {
    return {
      targetEntindex: isSet(object.targetEntindex) ? globalThis.Number(object.targetEntindex) : -1,
      slotIndex: isSet(object.slotIndex) ? globalThis.Number(object.slotIndex) : 0,
    };
  },

  toJSON(message: CDOTAClientMsgRerollNeutralItem): unknown {
    const obj: any = {};
    if (message.targetEntindex !== undefined && message.targetEntindex !== -1) {
      obj.targetEntindex = Math.round(message.targetEntindex);
    }
    if (message.slotIndex !== undefined && message.slotIndex !== 0) {
      obj.slotIndex = Math.round(message.slotIndex);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAClientMsgRerollNeutralItem>): CDOTAClientMsgRerollNeutralItem {
    return CDOTAClientMsgRerollNeutralItem.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAClientMsgRerollNeutralItem>): CDOTAClientMsgRerollNeutralItem {
    const message = createBaseCDOTAClientMsgRerollNeutralItem();
    message.targetEntindex = object.targetEntindex ?? -1;
    message.slotIndex = object.slotIndex ?? 0;
    return message;
  },
};

function createBaseCDOTAClientMsgPlayerDraftPick(): CDOTAClientMsgPlayerDraftPick {
  return { playerId: -1 };
}

export const CDOTAClientMsgPlayerDraftPick = {
  encode(message: CDOTAClientMsgPlayerDraftPick, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.playerId !== undefined && message.playerId !== -1) {
      writer.uint32(8).int32(message.playerId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAClientMsgPlayerDraftPick {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAClientMsgPlayerDraftPick();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.playerId = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAClientMsgPlayerDraftPick {
    return { playerId: isSet(object.playerId) ? globalThis.Number(object.playerId) : -1 };
  },

  toJSON(message: CDOTAClientMsgPlayerDraftPick): unknown {
    const obj: any = {};
    if (message.playerId !== undefined && message.playerId !== -1) {
      obj.playerId = Math.round(message.playerId);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAClientMsgPlayerDraftPick>): CDOTAClientMsgPlayerDraftPick {
    return CDOTAClientMsgPlayerDraftPick.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAClientMsgPlayerDraftPick>): CDOTAClientMsgPlayerDraftPick {
    const message = createBaseCDOTAClientMsgPlayerDraftPick();
    message.playerId = object.playerId ?? -1;
    return message;
  },
};

function createBaseCDOTAClientMsgPlayerDraftSuggest(): CDOTAClientMsgPlayerDraftSuggest {
  return { playerId: -1 };
}

export const CDOTAClientMsgPlayerDraftSuggest = {
  encode(message: CDOTAClientMsgPlayerDraftSuggest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.playerId !== undefined && message.playerId !== -1) {
      writer.uint32(8).int32(message.playerId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAClientMsgPlayerDraftSuggest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAClientMsgPlayerDraftSuggest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.playerId = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAClientMsgPlayerDraftSuggest {
    return { playerId: isSet(object.playerId) ? globalThis.Number(object.playerId) : -1 };
  },

  toJSON(message: CDOTAClientMsgPlayerDraftSuggest): unknown {
    const obj: any = {};
    if (message.playerId !== undefined && message.playerId !== -1) {
      obj.playerId = Math.round(message.playerId);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAClientMsgPlayerDraftSuggest>): CDOTAClientMsgPlayerDraftSuggest {
    return CDOTAClientMsgPlayerDraftSuggest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAClientMsgPlayerDraftSuggest>): CDOTAClientMsgPlayerDraftSuggest {
    const message = createBaseCDOTAClientMsgPlayerDraftSuggest();
    message.playerId = object.playerId ?? -1;
    return message;
  },
};

function createBaseCDOTAClientMsgPlayerDraftPreferRole(): CDOTAClientMsgPlayerDraftPreferRole {
  return { roleIdx: 0, desired: false };
}

export const CDOTAClientMsgPlayerDraftPreferRole = {
  encode(message: CDOTAClientMsgPlayerDraftPreferRole, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.roleIdx !== undefined && message.roleIdx !== 0) {
      writer.uint32(8).int32(message.roleIdx);
    }
    if (message.desired !== undefined && message.desired !== false) {
      writer.uint32(16).bool(message.desired);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAClientMsgPlayerDraftPreferRole {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAClientMsgPlayerDraftPreferRole();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.roleIdx = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.desired = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAClientMsgPlayerDraftPreferRole {
    return {
      roleIdx: isSet(object.roleIdx) ? globalThis.Number(object.roleIdx) : 0,
      desired: isSet(object.desired) ? globalThis.Boolean(object.desired) : false,
    };
  },

  toJSON(message: CDOTAClientMsgPlayerDraftPreferRole): unknown {
    const obj: any = {};
    if (message.roleIdx !== undefined && message.roleIdx !== 0) {
      obj.roleIdx = Math.round(message.roleIdx);
    }
    if (message.desired !== undefined && message.desired !== false) {
      obj.desired = message.desired;
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAClientMsgPlayerDraftPreferRole>): CDOTAClientMsgPlayerDraftPreferRole {
    return CDOTAClientMsgPlayerDraftPreferRole.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAClientMsgPlayerDraftPreferRole>): CDOTAClientMsgPlayerDraftPreferRole {
    const message = createBaseCDOTAClientMsgPlayerDraftPreferRole();
    message.roleIdx = object.roleIdx ?? 0;
    message.desired = object.desired ?? false;
    return message;
  },
};

function createBaseCDOTAClientMsgPlayerDraftPreferTeam(): CDOTAClientMsgPlayerDraftPreferTeam {
  return { team: 0 };
}

export const CDOTAClientMsgPlayerDraftPreferTeam = {
  encode(message: CDOTAClientMsgPlayerDraftPreferTeam, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.team !== undefined && message.team !== 0) {
      writer.uint32(8).int32(message.team);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAClientMsgPlayerDraftPreferTeam {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAClientMsgPlayerDraftPreferTeam();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.team = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAClientMsgPlayerDraftPreferTeam {
    return { team: isSet(object.team) ? globalThis.Number(object.team) : 0 };
  },

  toJSON(message: CDOTAClientMsgPlayerDraftPreferTeam): unknown {
    const obj: any = {};
    if (message.team !== undefined && message.team !== 0) {
      obj.team = Math.round(message.team);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAClientMsgPlayerDraftPreferTeam>): CDOTAClientMsgPlayerDraftPreferTeam {
    return CDOTAClientMsgPlayerDraftPreferTeam.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAClientMsgPlayerDraftPreferTeam>): CDOTAClientMsgPlayerDraftPreferTeam {
    const message = createBaseCDOTAClientMsgPlayerDraftPreferTeam();
    message.team = object.team ?? 0;
    return message;
  },
};

function createBaseCDOTAClientMsgAbilityAlert(): CDOTAClientMsgAbilityAlert {
  return {
    abilityEntindex: 16777215,
    ctrlHeld: false,
    ownerEntindex: -1,
    abilityId: -1,
    primaryCharges: 0,
    secondaryCharges: 0,
    reclaimTime: 0,
  };
}

export const CDOTAClientMsgAbilityAlert = {
  encode(message: CDOTAClientMsgAbilityAlert, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.abilityEntindex !== undefined && message.abilityEntindex !== 16777215) {
      writer.uint32(8).uint32(message.abilityEntindex);
    }
    if (message.ctrlHeld !== undefined && message.ctrlHeld !== false) {
      writer.uint32(16).bool(message.ctrlHeld);
    }
    if (message.ownerEntindex !== undefined && message.ownerEntindex !== -1) {
      writer.uint32(24).int32(message.ownerEntindex);
    }
    if (message.abilityId !== undefined && message.abilityId !== -1) {
      writer.uint32(32).int32(message.abilityId);
    }
    if (message.primaryCharges !== undefined && message.primaryCharges !== 0) {
      writer.uint32(40).uint32(message.primaryCharges);
    }
    if (message.secondaryCharges !== undefined && message.secondaryCharges !== 0) {
      writer.uint32(48).uint32(message.secondaryCharges);
    }
    if (message.reclaimTime !== undefined && message.reclaimTime !== 0) {
      writer.uint32(61).float(message.reclaimTime);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAClientMsgAbilityAlert {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAClientMsgAbilityAlert();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.abilityEntindex = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.ctrlHeld = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.ownerEntindex = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.abilityId = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.primaryCharges = reader.uint32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.secondaryCharges = reader.uint32();
          continue;
        case 7:
          if (tag !== 61) {
            break;
          }

          message.reclaimTime = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAClientMsgAbilityAlert {
    return {
      abilityEntindex: isSet(object.abilityEntindex) ? globalThis.Number(object.abilityEntindex) : 16777215,
      ctrlHeld: isSet(object.ctrlHeld) ? globalThis.Boolean(object.ctrlHeld) : false,
      ownerEntindex: isSet(object.ownerEntindex) ? globalThis.Number(object.ownerEntindex) : -1,
      abilityId: isSet(object.abilityId) ? globalThis.Number(object.abilityId) : -1,
      primaryCharges: isSet(object.primaryCharges) ? globalThis.Number(object.primaryCharges) : 0,
      secondaryCharges: isSet(object.secondaryCharges) ? globalThis.Number(object.secondaryCharges) : 0,
      reclaimTime: isSet(object.reclaimTime) ? globalThis.Number(object.reclaimTime) : 0,
    };
  },

  toJSON(message: CDOTAClientMsgAbilityAlert): unknown {
    const obj: any = {};
    if (message.abilityEntindex !== undefined && message.abilityEntindex !== 16777215) {
      obj.abilityEntindex = Math.round(message.abilityEntindex);
    }
    if (message.ctrlHeld !== undefined && message.ctrlHeld !== false) {
      obj.ctrlHeld = message.ctrlHeld;
    }
    if (message.ownerEntindex !== undefined && message.ownerEntindex !== -1) {
      obj.ownerEntindex = Math.round(message.ownerEntindex);
    }
    if (message.abilityId !== undefined && message.abilityId !== -1) {
      obj.abilityId = Math.round(message.abilityId);
    }
    if (message.primaryCharges !== undefined && message.primaryCharges !== 0) {
      obj.primaryCharges = Math.round(message.primaryCharges);
    }
    if (message.secondaryCharges !== undefined && message.secondaryCharges !== 0) {
      obj.secondaryCharges = Math.round(message.secondaryCharges);
    }
    if (message.reclaimTime !== undefined && message.reclaimTime !== 0) {
      obj.reclaimTime = message.reclaimTime;
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAClientMsgAbilityAlert>): CDOTAClientMsgAbilityAlert {
    return CDOTAClientMsgAbilityAlert.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAClientMsgAbilityAlert>): CDOTAClientMsgAbilityAlert {
    const message = createBaseCDOTAClientMsgAbilityAlert();
    message.abilityEntindex = object.abilityEntindex ?? 16777215;
    message.ctrlHeld = object.ctrlHeld ?? false;
    message.ownerEntindex = object.ownerEntindex ?? -1;
    message.abilityId = object.abilityId ?? -1;
    message.primaryCharges = object.primaryCharges ?? 0;
    message.secondaryCharges = object.secondaryCharges ?? 0;
    message.reclaimTime = object.reclaimTime ?? 0;
    return message;
  },
};

function createBaseCDOTAClientMsgSelectOverworldTokenRewards(): CDOTAClientMsgSelectOverworldTokenRewards {
  return { tokenIds: [] };
}

export const CDOTAClientMsgSelectOverworldTokenRewards = {
  encode(message: CDOTAClientMsgSelectOverworldTokenRewards, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.tokenIds) {
      writer.uint32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAClientMsgSelectOverworldTokenRewards {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAClientMsgSelectOverworldTokenRewards();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.tokenIds.push(reader.uint32());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.tokenIds.push(reader.uint32());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAClientMsgSelectOverworldTokenRewards {
    return {
      tokenIds: globalThis.Array.isArray(object?.tokenIds) ? object.tokenIds.map((e: any) => globalThis.Number(e)) : [],
    };
  },

  toJSON(message: CDOTAClientMsgSelectOverworldTokenRewards): unknown {
    const obj: any = {};
    if (message.tokenIds?.length) {
      obj.tokenIds = message.tokenIds.map((e) => Math.round(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAClientMsgSelectOverworldTokenRewards>): CDOTAClientMsgSelectOverworldTokenRewards {
    return CDOTAClientMsgSelectOverworldTokenRewards.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CDOTAClientMsgSelectOverworldTokenRewards>,
  ): CDOTAClientMsgSelectOverworldTokenRewards {
    const message = createBaseCDOTAClientMsgSelectOverworldTokenRewards();
    message.tokenIds = object.tokenIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseCDOTAClientMsgFacetAlert(): CDOTAClientMsgFacetAlert {
  return { facetStrhash: 0, heroEntindex: 16777215, ctrlHeld: false };
}

export const CDOTAClientMsgFacetAlert = {
  encode(message: CDOTAClientMsgFacetAlert, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.facetStrhash !== undefined && message.facetStrhash !== 0) {
      writer.uint32(8).uint32(message.facetStrhash);
    }
    if (message.heroEntindex !== undefined && message.heroEntindex !== 16777215) {
      writer.uint32(16).uint32(message.heroEntindex);
    }
    if (message.ctrlHeld !== undefined && message.ctrlHeld !== false) {
      writer.uint32(24).bool(message.ctrlHeld);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAClientMsgFacetAlert {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAClientMsgFacetAlert();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.facetStrhash = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.heroEntindex = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.ctrlHeld = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAClientMsgFacetAlert {
    return {
      facetStrhash: isSet(object.facetStrhash) ? globalThis.Number(object.facetStrhash) : 0,
      heroEntindex: isSet(object.heroEntindex) ? globalThis.Number(object.heroEntindex) : 16777215,
      ctrlHeld: isSet(object.ctrlHeld) ? globalThis.Boolean(object.ctrlHeld) : false,
    };
  },

  toJSON(message: CDOTAClientMsgFacetAlert): unknown {
    const obj: any = {};
    if (message.facetStrhash !== undefined && message.facetStrhash !== 0) {
      obj.facetStrhash = Math.round(message.facetStrhash);
    }
    if (message.heroEntindex !== undefined && message.heroEntindex !== 16777215) {
      obj.heroEntindex = Math.round(message.heroEntindex);
    }
    if (message.ctrlHeld !== undefined && message.ctrlHeld !== false) {
      obj.ctrlHeld = message.ctrlHeld;
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAClientMsgFacetAlert>): CDOTAClientMsgFacetAlert {
    return CDOTAClientMsgFacetAlert.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAClientMsgFacetAlert>): CDOTAClientMsgFacetAlert {
    const message = createBaseCDOTAClientMsgFacetAlert();
    message.facetStrhash = object.facetStrhash ?? 0;
    message.heroEntindex = object.heroEntindex ?? 16777215;
    message.ctrlHeld = object.ctrlHeld ?? false;
    return message;
  },
};

function createBaseCDOTAClientMsgInnateAlert(): CDOTAClientMsgInnateAlert {
  return { abilityEntindex: 16777215, ctrlHeld: false };
}

export const CDOTAClientMsgInnateAlert = {
  encode(message: CDOTAClientMsgInnateAlert, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.abilityEntindex !== undefined && message.abilityEntindex !== 16777215) {
      writer.uint32(8).uint32(message.abilityEntindex);
    }
    if (message.ctrlHeld !== undefined && message.ctrlHeld !== false) {
      writer.uint32(16).bool(message.ctrlHeld);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAClientMsgInnateAlert {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAClientMsgInnateAlert();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.abilityEntindex = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.ctrlHeld = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAClientMsgInnateAlert {
    return {
      abilityEntindex: isSet(object.abilityEntindex) ? globalThis.Number(object.abilityEntindex) : 16777215,
      ctrlHeld: isSet(object.ctrlHeld) ? globalThis.Boolean(object.ctrlHeld) : false,
    };
  },

  toJSON(message: CDOTAClientMsgInnateAlert): unknown {
    const obj: any = {};
    if (message.abilityEntindex !== undefined && message.abilityEntindex !== 16777215) {
      obj.abilityEntindex = Math.round(message.abilityEntindex);
    }
    if (message.ctrlHeld !== undefined && message.ctrlHeld !== false) {
      obj.ctrlHeld = message.ctrlHeld;
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAClientMsgInnateAlert>): CDOTAClientMsgInnateAlert {
    return CDOTAClientMsgInnateAlert.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAClientMsgInnateAlert>): CDOTAClientMsgInnateAlert {
    const message = createBaseCDOTAClientMsgInnateAlert();
    message.abilityEntindex = object.abilityEntindex ?? 16777215;
    message.ctrlHeld = object.ctrlHeld ?? false;
    return message;
  },
};

function createBaseCDOTAClientMsgSelectOverworldID(): CDOTAClientMsgSelectOverworldID {
  return { overworldId: 0 };
}

export const CDOTAClientMsgSelectOverworldID = {
  encode(message: CDOTAClientMsgSelectOverworldID, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.overworldId !== undefined && message.overworldId !== 0) {
      writer.uint32(8).uint32(message.overworldId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAClientMsgSelectOverworldID {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAClientMsgSelectOverworldID();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.overworldId = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAClientMsgSelectOverworldID {
    return { overworldId: isSet(object.overworldId) ? globalThis.Number(object.overworldId) : 0 };
  },

  toJSON(message: CDOTAClientMsgSelectOverworldID): unknown {
    const obj: any = {};
    if (message.overworldId !== undefined && message.overworldId !== 0) {
      obj.overworldId = Math.round(message.overworldId);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAClientMsgSelectOverworldID>): CDOTAClientMsgSelectOverworldID {
    return CDOTAClientMsgSelectOverworldID.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAClientMsgSelectOverworldID>): CDOTAClientMsgSelectOverworldID {
    const message = createBaseCDOTAClientMsgSelectOverworldID();
    message.overworldId = object.overworldId ?? 0;
    return message;
  },
};

function createBaseCDOTAClientMsgRoshanTimer(): CDOTAClientMsgRoshanTimer {
  return { negative: false };
}

export const CDOTAClientMsgRoshanTimer = {
  encode(message: CDOTAClientMsgRoshanTimer, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.negative !== undefined && message.negative !== false) {
      writer.uint32(8).bool(message.negative);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAClientMsgRoshanTimer {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAClientMsgRoshanTimer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.negative = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAClientMsgRoshanTimer {
    return { negative: isSet(object.negative) ? globalThis.Boolean(object.negative) : false };
  },

  toJSON(message: CDOTAClientMsgRoshanTimer): unknown {
    const obj: any = {};
    if (message.negative !== undefined && message.negative !== false) {
      obj.negative = message.negative;
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAClientMsgRoshanTimer>): CDOTAClientMsgRoshanTimer {
    return CDOTAClientMsgRoshanTimer.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAClientMsgRoshanTimer>): CDOTAClientMsgRoshanTimer {
    const message = createBaseCDOTAClientMsgRoshanTimer();
    message.negative = object.negative ?? false;
    return message;
  },
};

function createBaseCDOTAClientMsgCraftNeutralItem(): CDOTAClientMsgCraftNeutralItem {
  return {};
}

export const CDOTAClientMsgCraftNeutralItem = {
  encode(_: CDOTAClientMsgCraftNeutralItem, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAClientMsgCraftNeutralItem {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAClientMsgCraftNeutralItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CDOTAClientMsgCraftNeutralItem {
    return {};
  },

  toJSON(_: CDOTAClientMsgCraftNeutralItem): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<CDOTAClientMsgCraftNeutralItem>): CDOTAClientMsgCraftNeutralItem {
    return CDOTAClientMsgCraftNeutralItem.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<CDOTAClientMsgCraftNeutralItem>): CDOTAClientMsgCraftNeutralItem {
    const message = createBaseCDOTAClientMsgCraftNeutralItem();
    return message;
  },
};

function createBaseCDOTAClientMsgChooseCraftedNeutralItem(): CDOTAClientMsgChooseCraftedNeutralItem {
  return { neutralItemIndex: 0, itemTier: 0, enhancementIndex: 0 };
}

export const CDOTAClientMsgChooseCraftedNeutralItem = {
  encode(message: CDOTAClientMsgChooseCraftedNeutralItem, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.neutralItemIndex !== undefined && message.neutralItemIndex !== 0) {
      writer.uint32(8).int32(message.neutralItemIndex);
    }
    if (message.itemTier !== undefined && message.itemTier !== 0) {
      writer.uint32(16).int32(message.itemTier);
    }
    if (message.enhancementIndex !== undefined && message.enhancementIndex !== 0) {
      writer.uint32(24).int32(message.enhancementIndex);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAClientMsgChooseCraftedNeutralItem {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAClientMsgChooseCraftedNeutralItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.neutralItemIndex = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.itemTier = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.enhancementIndex = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAClientMsgChooseCraftedNeutralItem {
    return {
      neutralItemIndex: isSet(object.neutralItemIndex) ? globalThis.Number(object.neutralItemIndex) : 0,
      itemTier: isSet(object.itemTier) ? globalThis.Number(object.itemTier) : 0,
      enhancementIndex: isSet(object.enhancementIndex) ? globalThis.Number(object.enhancementIndex) : 0,
    };
  },

  toJSON(message: CDOTAClientMsgChooseCraftedNeutralItem): unknown {
    const obj: any = {};
    if (message.neutralItemIndex !== undefined && message.neutralItemIndex !== 0) {
      obj.neutralItemIndex = Math.round(message.neutralItemIndex);
    }
    if (message.itemTier !== undefined && message.itemTier !== 0) {
      obj.itemTier = Math.round(message.itemTier);
    }
    if (message.enhancementIndex !== undefined && message.enhancementIndex !== 0) {
      obj.enhancementIndex = Math.round(message.enhancementIndex);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAClientMsgChooseCraftedNeutralItem>): CDOTAClientMsgChooseCraftedNeutralItem {
    return CDOTAClientMsgChooseCraftedNeutralItem.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAClientMsgChooseCraftedNeutralItem>): CDOTAClientMsgChooseCraftedNeutralItem {
    const message = createBaseCDOTAClientMsgChooseCraftedNeutralItem();
    message.neutralItemIndex = object.neutralItemIndex ?? 0;
    message.itemTier = object.itemTier ?? 0;
    message.enhancementIndex = object.enhancementIndex ?? 0;
    return message;
  },
};

function createBaseCDOTAClientMsgTimerAlert(): CDOTAClientMsgTimerAlert {
  return { timerAlertType: 1 };
}

export const CDOTAClientMsgTimerAlert = {
  encode(message: CDOTAClientMsgTimerAlert, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.timerAlertType !== undefined && message.timerAlertType !== 1) {
      writer.uint32(8).int32(message.timerAlertType);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAClientMsgTimerAlert {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAClientMsgTimerAlert();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.timerAlertType = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAClientMsgTimerAlert {
    return { timerAlertType: isSet(object.timerAlertType) ? eTimerAlertTypeFromJSON(object.timerAlertType) : 1 };
  },

  toJSON(message: CDOTAClientMsgTimerAlert): unknown {
    const obj: any = {};
    if (message.timerAlertType !== undefined && message.timerAlertType !== 1) {
      obj.timerAlertType = eTimerAlertTypeToJSON(message.timerAlertType);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAClientMsgTimerAlert>): CDOTAClientMsgTimerAlert {
    return CDOTAClientMsgTimerAlert.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAClientMsgTimerAlert>): CDOTAClientMsgTimerAlert {
    const message = createBaseCDOTAClientMsgTimerAlert();
    message.timerAlertType = object.timerAlertType ?? 1;
    return message;
  },
};

function createBaseCDOTAClientMsgMadstoneAlert(): CDOTAClientMsgMadstoneAlert {
  return { targetEntindex: -1 };
}

export const CDOTAClientMsgMadstoneAlert = {
  encode(message: CDOTAClientMsgMadstoneAlert, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.targetEntindex !== undefined && message.targetEntindex !== -1) {
      writer.uint32(8).int32(message.targetEntindex);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAClientMsgMadstoneAlert {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAClientMsgMadstoneAlert();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.targetEntindex = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAClientMsgMadstoneAlert {
    return { targetEntindex: isSet(object.targetEntindex) ? globalThis.Number(object.targetEntindex) : -1 };
  },

  toJSON(message: CDOTAClientMsgMadstoneAlert): unknown {
    const obj: any = {};
    if (message.targetEntindex !== undefined && message.targetEntindex !== -1) {
      obj.targetEntindex = Math.round(message.targetEntindex);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAClientMsgMadstoneAlert>): CDOTAClientMsgMadstoneAlert {
    return CDOTAClientMsgMadstoneAlert.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAClientMsgMadstoneAlert>): CDOTAClientMsgMadstoneAlert {
    const message = createBaseCDOTAClientMsgMadstoneAlert();
    message.targetEntindex = object.targetEntindex ?? -1;
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function longToString(long: Long) {
  return long.toString();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

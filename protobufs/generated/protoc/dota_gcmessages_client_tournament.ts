// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.176.1
//   protoc               v5.26.1
// source: dota_gcmessages_client_tournament.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";
import {
  ETournamentGameState,
  eTournamentGameStateFromJSON,
  eTournamentGameStateToJSON,
  ETournamentNodeState,
  eTournamentNodeStateFromJSON,
  eTournamentNodeStateToJSON,
  ETournamentState,
  eTournamentStateFromJSON,
  eTournamentStateToJSON,
  ETournamentTemplate,
  eTournamentTemplateFromJSON,
  eTournamentTemplateToJSON,
} from "./dota_client_enums";

export enum ETournamentEvent {
  k_ETournamentEvent_None = 0,
  k_ETournamentEvent_TournamentCreated = 1,
  k_ETournamentEvent_TournamentsMerged = 2,
  k_ETournamentEvent_GameOutcome = 3,
  k_ETournamentEvent_TeamGivenBye = 4,
  k_ETournamentEvent_TournamentCanceledByAdmin = 5,
  k_ETournamentEvent_TeamAbandoned = 6,
  k_ETournamentEvent_ScheduledGameStarted = 7,
  k_ETournamentEvent_Canceled = 8,
  k_ETournamentEvent_TeamParticipationTimedOut_EntryFeeRefund = 9,
  k_ETournamentEvent_TeamParticipationTimedOut_EntryFeeForfeit = 10,
  k_ETournamentEvent_TeamParticipationTimedOut_GrantedVictory = 11,
}

export function eTournamentEventFromJSON(object: any): ETournamentEvent {
  switch (object) {
    case 0:
    case "k_ETournamentEvent_None":
      return ETournamentEvent.k_ETournamentEvent_None;
    case 1:
    case "k_ETournamentEvent_TournamentCreated":
      return ETournamentEvent.k_ETournamentEvent_TournamentCreated;
    case 2:
    case "k_ETournamentEvent_TournamentsMerged":
      return ETournamentEvent.k_ETournamentEvent_TournamentsMerged;
    case 3:
    case "k_ETournamentEvent_GameOutcome":
      return ETournamentEvent.k_ETournamentEvent_GameOutcome;
    case 4:
    case "k_ETournamentEvent_TeamGivenBye":
      return ETournamentEvent.k_ETournamentEvent_TeamGivenBye;
    case 5:
    case "k_ETournamentEvent_TournamentCanceledByAdmin":
      return ETournamentEvent.k_ETournamentEvent_TournamentCanceledByAdmin;
    case 6:
    case "k_ETournamentEvent_TeamAbandoned":
      return ETournamentEvent.k_ETournamentEvent_TeamAbandoned;
    case 7:
    case "k_ETournamentEvent_ScheduledGameStarted":
      return ETournamentEvent.k_ETournamentEvent_ScheduledGameStarted;
    case 8:
    case "k_ETournamentEvent_Canceled":
      return ETournamentEvent.k_ETournamentEvent_Canceled;
    case 9:
    case "k_ETournamentEvent_TeamParticipationTimedOut_EntryFeeRefund":
      return ETournamentEvent.k_ETournamentEvent_TeamParticipationTimedOut_EntryFeeRefund;
    case 10:
    case "k_ETournamentEvent_TeamParticipationTimedOut_EntryFeeForfeit":
      return ETournamentEvent.k_ETournamentEvent_TeamParticipationTimedOut_EntryFeeForfeit;
    case 11:
    case "k_ETournamentEvent_TeamParticipationTimedOut_GrantedVictory":
      return ETournamentEvent.k_ETournamentEvent_TeamParticipationTimedOut_GrantedVictory;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ETournamentEvent");
  }
}

export function eTournamentEventToJSON(object: ETournamentEvent): string {
  switch (object) {
    case ETournamentEvent.k_ETournamentEvent_None:
      return "k_ETournamentEvent_None";
    case ETournamentEvent.k_ETournamentEvent_TournamentCreated:
      return "k_ETournamentEvent_TournamentCreated";
    case ETournamentEvent.k_ETournamentEvent_TournamentsMerged:
      return "k_ETournamentEvent_TournamentsMerged";
    case ETournamentEvent.k_ETournamentEvent_GameOutcome:
      return "k_ETournamentEvent_GameOutcome";
    case ETournamentEvent.k_ETournamentEvent_TeamGivenBye:
      return "k_ETournamentEvent_TeamGivenBye";
    case ETournamentEvent.k_ETournamentEvent_TournamentCanceledByAdmin:
      return "k_ETournamentEvent_TournamentCanceledByAdmin";
    case ETournamentEvent.k_ETournamentEvent_TeamAbandoned:
      return "k_ETournamentEvent_TeamAbandoned";
    case ETournamentEvent.k_ETournamentEvent_ScheduledGameStarted:
      return "k_ETournamentEvent_ScheduledGameStarted";
    case ETournamentEvent.k_ETournamentEvent_Canceled:
      return "k_ETournamentEvent_Canceled";
    case ETournamentEvent.k_ETournamentEvent_TeamParticipationTimedOut_EntryFeeRefund:
      return "k_ETournamentEvent_TeamParticipationTimedOut_EntryFeeRefund";
    case ETournamentEvent.k_ETournamentEvent_TeamParticipationTimedOut_EntryFeeForfeit:
      return "k_ETournamentEvent_TeamParticipationTimedOut_EntryFeeForfeit";
    case ETournamentEvent.k_ETournamentEvent_TeamParticipationTimedOut_GrantedVictory:
      return "k_ETournamentEvent_TeamParticipationTimedOut_GrantedVictory";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ETournamentEvent");
  }
}

export interface CMsgRequestWeekendTourneySchedule {}

export interface CMsgWeekendTourneySchedule {
  divisions: CMsgWeekendTourneySchedule_Division[];
}

export interface CMsgWeekendTourneySchedule_Division {
  divisionCode?: number | undefined;
  timeWindowOpen?: number | undefined;
  timeWindowClose?: number | undefined;
  timeWindowOpenNext?: number | undefined;
  trophyId?: number | undefined;
  freeWeekend?: boolean | undefined;
}

export interface CMsgWeekendTourneyOpts {
  participating?: boolean | undefined;
  divisionId?: number | undefined;
  buyin?: number | undefined;
  skillLevel?: number | undefined;
  matchGroups?: number | undefined;
  teamId?: number | undefined;
  pickupTeamName?: string | undefined;
  pickupTeamLogo?: string | undefined;
}

export interface CMsgWeekendTourneyLeave {}

export interface CMsgDOTATournament {
  tournamentId?: number | undefined;
  divisionId?: number | undefined;
  scheduleTime?: number | undefined;
  skillLevel?: number | undefined;
  tournamentTemplate?: ETournamentTemplate | undefined;
  state?: ETournamentState | undefined;
  stateSeqNum?: number | undefined;
  seasonTrophyId?: number | undefined;
  teams: CMsgDOTATournament_Team[];
  games: CMsgDOTATournament_Game[];
  nodes: CMsgDOTATournament_Node[];
}

export interface CMsgDOTATournament_Team {
  teamGid?: string | undefined;
  nodeOrState?: number | undefined;
  players: number[];
  playerBuyin: number[];
  playerSkillLevel: number[];
  matchGroupMask?: number | undefined;
  teamId?: number | undefined;
  teamName?: string | undefined;
  teamBaseLogo?: string | undefined;
  teamUiLogo?: string | undefined;
}

export interface CMsgDOTATournament_Game {
  nodeIdx?: number | undefined;
  lobbyId?: string | undefined;
  matchId?: string | undefined;
  teamAGood?: boolean | undefined;
  state?: ETournamentGameState | undefined;
  startTime?: number | undefined;
}

export interface CMsgDOTATournament_Node {
  nodeId?: number | undefined;
  teamIdxA?: number | undefined;
  teamIdxB?: number | undefined;
  nodeState?: ETournamentNodeState | undefined;
}

export interface CMsgDOTATournamentStateChange {
  newTournamentId?: number | undefined;
  event?: ETournamentEvent | undefined;
  newTournamentState?: ETournamentState | undefined;
  gameChanges: CMsgDOTATournamentStateChange_GameChange[];
  teamChanges: CMsgDOTATournamentStateChange_TeamChange[];
  mergedTournamentIds: number[];
  stateSeqNum?: number | undefined;
}

export interface CMsgDOTATournamentStateChange_GameChange {
  matchId?: string | undefined;
  newState?: ETournamentGameState | undefined;
}

export interface CMsgDOTATournamentStateChange_TeamChange {
  teamGid?: string | undefined;
  newNodeOrState?: number | undefined;
  oldNodeOrState?: number | undefined;
}

export interface CMsgDOTAWeekendTourneyPlayerSkillLevelStats {
  skillLevel?: number | undefined;
  timesWon0?: number | undefined;
  timesWon1?: number | undefined;
  timesWon2?: number | undefined;
  timesWon3?: number | undefined;
  timesByeAndLost?: number | undefined;
  timesByeAndWon?: number | undefined;
  timesUnusualChamp?: number | undefined;
  totalGamesWon?: number | undefined;
  score?: number | undefined;
}

export interface CMsgDOTAWeekendTourneyPlayerStats {
  accountId?: number | undefined;
  seasonTrophyId?: number | undefined;
  skillLevels: CMsgDOTAWeekendTourneyPlayerSkillLevelStats[];
  currentTier?: number | undefined;
}

export interface CMsgDOTAWeekendTourneyPlayerStatsRequest {
  accountId?: number | undefined;
  seasonTrophyId?: number | undefined;
}

export interface CMsgDOTAWeekendTourneyPlayerHistory {
  accountId?: number | undefined;
  tournaments: CMsgDOTAWeekendTourneyPlayerHistory_Tournament[];
}

export interface CMsgDOTAWeekendTourneyPlayerHistory_Tournament {
  tournamentId?: number | undefined;
  startTime?: number | undefined;
  tournamentTier?: number | undefined;
  teamId?: number | undefined;
  teamDate?: number | undefined;
  teamResult?: number | undefined;
  accountId: number[];
  teamName?: string | undefined;
  seasonTrophyId?: number | undefined;
}

export interface CMsgDOTAWeekendTourneyParticipationDetails {
  divisions: CMsgDOTAWeekendTourneyParticipationDetails_Division[];
}

export interface CMsgDOTAWeekendTourneyParticipationDetails_Tier {
  tier?: number | undefined;
  players?: number | undefined;
  teams?: number | undefined;
  winningTeams?: number | undefined;
  playersStreak2?: number | undefined;
  playersStreak3?: number | undefined;
  playersStreak4?: number | undefined;
  playersStreak5?: number | undefined;
}

export interface CMsgDOTAWeekendTourneyParticipationDetails_Division {
  divisionId?: number | undefined;
  scheduleTime?: number | undefined;
  tiers: CMsgDOTAWeekendTourneyParticipationDetails_Tier[];
}

function createBaseCMsgRequestWeekendTourneySchedule(): CMsgRequestWeekendTourneySchedule {
  return {};
}

export const CMsgRequestWeekendTourneySchedule = {
  encode(_: CMsgRequestWeekendTourneySchedule, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgRequestWeekendTourneySchedule {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgRequestWeekendTourneySchedule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CMsgRequestWeekendTourneySchedule {
    return {};
  },

  toJSON(_: CMsgRequestWeekendTourneySchedule): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<CMsgRequestWeekendTourneySchedule>): CMsgRequestWeekendTourneySchedule {
    return CMsgRequestWeekendTourneySchedule.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<CMsgRequestWeekendTourneySchedule>): CMsgRequestWeekendTourneySchedule {
    const message = createBaseCMsgRequestWeekendTourneySchedule();
    return message;
  },
};

function createBaseCMsgWeekendTourneySchedule(): CMsgWeekendTourneySchedule {
  return { divisions: [] };
}

export const CMsgWeekendTourneySchedule = {
  encode(message: CMsgWeekendTourneySchedule, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.divisions) {
      CMsgWeekendTourneySchedule_Division.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgWeekendTourneySchedule {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgWeekendTourneySchedule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.divisions.push(CMsgWeekendTourneySchedule_Division.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgWeekendTourneySchedule {
    return {
      divisions: globalThis.Array.isArray(object?.divisions)
        ? object.divisions.map((e: any) => CMsgWeekendTourneySchedule_Division.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgWeekendTourneySchedule): unknown {
    const obj: any = {};
    if (message.divisions?.length) {
      obj.divisions = message.divisions.map((e) => CMsgWeekendTourneySchedule_Division.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgWeekendTourneySchedule>): CMsgWeekendTourneySchedule {
    return CMsgWeekendTourneySchedule.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgWeekendTourneySchedule>): CMsgWeekendTourneySchedule {
    const message = createBaseCMsgWeekendTourneySchedule();
    message.divisions = object.divisions?.map((e) => CMsgWeekendTourneySchedule_Division.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgWeekendTourneySchedule_Division(): CMsgWeekendTourneySchedule_Division {
  return {
    divisionCode: 0,
    timeWindowOpen: 0,
    timeWindowClose: 0,
    timeWindowOpenNext: 0,
    trophyId: 0,
    freeWeekend: false,
  };
}

export const CMsgWeekendTourneySchedule_Division = {
  encode(message: CMsgWeekendTourneySchedule_Division, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.divisionCode !== undefined && message.divisionCode !== 0) {
      writer.uint32(8).uint32(message.divisionCode);
    }
    if (message.timeWindowOpen !== undefined && message.timeWindowOpen !== 0) {
      writer.uint32(16).uint32(message.timeWindowOpen);
    }
    if (message.timeWindowClose !== undefined && message.timeWindowClose !== 0) {
      writer.uint32(24).uint32(message.timeWindowClose);
    }
    if (message.timeWindowOpenNext !== undefined && message.timeWindowOpenNext !== 0) {
      writer.uint32(32).uint32(message.timeWindowOpenNext);
    }
    if (message.trophyId !== undefined && message.trophyId !== 0) {
      writer.uint32(40).uint32(message.trophyId);
    }
    if (message.freeWeekend !== undefined && message.freeWeekend !== false) {
      writer.uint32(48).bool(message.freeWeekend);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgWeekendTourneySchedule_Division {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgWeekendTourneySchedule_Division();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.divisionCode = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.timeWindowOpen = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.timeWindowClose = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.timeWindowOpenNext = reader.uint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.trophyId = reader.uint32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.freeWeekend = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgWeekendTourneySchedule_Division {
    return {
      divisionCode: isSet(object.divisionCode) ? globalThis.Number(object.divisionCode) : 0,
      timeWindowOpen: isSet(object.timeWindowOpen) ? globalThis.Number(object.timeWindowOpen) : 0,
      timeWindowClose: isSet(object.timeWindowClose) ? globalThis.Number(object.timeWindowClose) : 0,
      timeWindowOpenNext: isSet(object.timeWindowOpenNext) ? globalThis.Number(object.timeWindowOpenNext) : 0,
      trophyId: isSet(object.trophyId) ? globalThis.Number(object.trophyId) : 0,
      freeWeekend: isSet(object.freeWeekend) ? globalThis.Boolean(object.freeWeekend) : false,
    };
  },

  toJSON(message: CMsgWeekendTourneySchedule_Division): unknown {
    const obj: any = {};
    if (message.divisionCode !== undefined && message.divisionCode !== 0) {
      obj.divisionCode = Math.round(message.divisionCode);
    }
    if (message.timeWindowOpen !== undefined && message.timeWindowOpen !== 0) {
      obj.timeWindowOpen = Math.round(message.timeWindowOpen);
    }
    if (message.timeWindowClose !== undefined && message.timeWindowClose !== 0) {
      obj.timeWindowClose = Math.round(message.timeWindowClose);
    }
    if (message.timeWindowOpenNext !== undefined && message.timeWindowOpenNext !== 0) {
      obj.timeWindowOpenNext = Math.round(message.timeWindowOpenNext);
    }
    if (message.trophyId !== undefined && message.trophyId !== 0) {
      obj.trophyId = Math.round(message.trophyId);
    }
    if (message.freeWeekend !== undefined && message.freeWeekend !== false) {
      obj.freeWeekend = message.freeWeekend;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgWeekendTourneySchedule_Division>): CMsgWeekendTourneySchedule_Division {
    return CMsgWeekendTourneySchedule_Division.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgWeekendTourneySchedule_Division>): CMsgWeekendTourneySchedule_Division {
    const message = createBaseCMsgWeekendTourneySchedule_Division();
    message.divisionCode = object.divisionCode ?? 0;
    message.timeWindowOpen = object.timeWindowOpen ?? 0;
    message.timeWindowClose = object.timeWindowClose ?? 0;
    message.timeWindowOpenNext = object.timeWindowOpenNext ?? 0;
    message.trophyId = object.trophyId ?? 0;
    message.freeWeekend = object.freeWeekend ?? false;
    return message;
  },
};

function createBaseCMsgWeekendTourneyOpts(): CMsgWeekendTourneyOpts {
  return {
    participating: false,
    divisionId: 0,
    buyin: 0,
    skillLevel: 0,
    matchGroups: 0,
    teamId: 0,
    pickupTeamName: "",
    pickupTeamLogo: "0",
  };
}

export const CMsgWeekendTourneyOpts = {
  encode(message: CMsgWeekendTourneyOpts, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.participating !== undefined && message.participating !== false) {
      writer.uint32(8).bool(message.participating);
    }
    if (message.divisionId !== undefined && message.divisionId !== 0) {
      writer.uint32(16).uint32(message.divisionId);
    }
    if (message.buyin !== undefined && message.buyin !== 0) {
      writer.uint32(24).uint32(message.buyin);
    }
    if (message.skillLevel !== undefined && message.skillLevel !== 0) {
      writer.uint32(32).uint32(message.skillLevel);
    }
    if (message.matchGroups !== undefined && message.matchGroups !== 0) {
      writer.uint32(40).uint32(message.matchGroups);
    }
    if (message.teamId !== undefined && message.teamId !== 0) {
      writer.uint32(48).uint32(message.teamId);
    }
    if (message.pickupTeamName !== undefined && message.pickupTeamName !== "") {
      writer.uint32(58).string(message.pickupTeamName);
    }
    if (message.pickupTeamLogo !== undefined && message.pickupTeamLogo !== "0") {
      writer.uint32(64).uint64(message.pickupTeamLogo);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgWeekendTourneyOpts {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgWeekendTourneyOpts();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.participating = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.divisionId = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.buyin = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.skillLevel = reader.uint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.matchGroups = reader.uint32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.teamId = reader.uint32();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.pickupTeamName = reader.string();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.pickupTeamLogo = longToString(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgWeekendTourneyOpts {
    return {
      participating: isSet(object.participating) ? globalThis.Boolean(object.participating) : false,
      divisionId: isSet(object.divisionId) ? globalThis.Number(object.divisionId) : 0,
      buyin: isSet(object.buyin) ? globalThis.Number(object.buyin) : 0,
      skillLevel: isSet(object.skillLevel) ? globalThis.Number(object.skillLevel) : 0,
      matchGroups: isSet(object.matchGroups) ? globalThis.Number(object.matchGroups) : 0,
      teamId: isSet(object.teamId) ? globalThis.Number(object.teamId) : 0,
      pickupTeamName: isSet(object.pickupTeamName) ? globalThis.String(object.pickupTeamName) : "",
      pickupTeamLogo: isSet(object.pickupTeamLogo) ? globalThis.String(object.pickupTeamLogo) : "0",
    };
  },

  toJSON(message: CMsgWeekendTourneyOpts): unknown {
    const obj: any = {};
    if (message.participating !== undefined && message.participating !== false) {
      obj.participating = message.participating;
    }
    if (message.divisionId !== undefined && message.divisionId !== 0) {
      obj.divisionId = Math.round(message.divisionId);
    }
    if (message.buyin !== undefined && message.buyin !== 0) {
      obj.buyin = Math.round(message.buyin);
    }
    if (message.skillLevel !== undefined && message.skillLevel !== 0) {
      obj.skillLevel = Math.round(message.skillLevel);
    }
    if (message.matchGroups !== undefined && message.matchGroups !== 0) {
      obj.matchGroups = Math.round(message.matchGroups);
    }
    if (message.teamId !== undefined && message.teamId !== 0) {
      obj.teamId = Math.round(message.teamId);
    }
    if (message.pickupTeamName !== undefined && message.pickupTeamName !== "") {
      obj.pickupTeamName = message.pickupTeamName;
    }
    if (message.pickupTeamLogo !== undefined && message.pickupTeamLogo !== "0") {
      obj.pickupTeamLogo = message.pickupTeamLogo;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgWeekendTourneyOpts>): CMsgWeekendTourneyOpts {
    return CMsgWeekendTourneyOpts.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgWeekendTourneyOpts>): CMsgWeekendTourneyOpts {
    const message = createBaseCMsgWeekendTourneyOpts();
    message.participating = object.participating ?? false;
    message.divisionId = object.divisionId ?? 0;
    message.buyin = object.buyin ?? 0;
    message.skillLevel = object.skillLevel ?? 0;
    message.matchGroups = object.matchGroups ?? 0;
    message.teamId = object.teamId ?? 0;
    message.pickupTeamName = object.pickupTeamName ?? "";
    message.pickupTeamLogo = object.pickupTeamLogo ?? "0";
    return message;
  },
};

function createBaseCMsgWeekendTourneyLeave(): CMsgWeekendTourneyLeave {
  return {};
}

export const CMsgWeekendTourneyLeave = {
  encode(_: CMsgWeekendTourneyLeave, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgWeekendTourneyLeave {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgWeekendTourneyLeave();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CMsgWeekendTourneyLeave {
    return {};
  },

  toJSON(_: CMsgWeekendTourneyLeave): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<CMsgWeekendTourneyLeave>): CMsgWeekendTourneyLeave {
    return CMsgWeekendTourneyLeave.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<CMsgWeekendTourneyLeave>): CMsgWeekendTourneyLeave {
    const message = createBaseCMsgWeekendTourneyLeave();
    return message;
  },
};

function createBaseCMsgDOTATournament(): CMsgDOTATournament {
  return {
    tournamentId: 0,
    divisionId: 0,
    scheduleTime: 0,
    skillLevel: 0,
    tournamentTemplate: 0,
    state: 0,
    stateSeqNum: 0,
    seasonTrophyId: 0,
    teams: [],
    games: [],
    nodes: [],
  };
}

export const CMsgDOTATournament = {
  encode(message: CMsgDOTATournament, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.tournamentId !== undefined && message.tournamentId !== 0) {
      writer.uint32(8).uint32(message.tournamentId);
    }
    if (message.divisionId !== undefined && message.divisionId !== 0) {
      writer.uint32(16).uint32(message.divisionId);
    }
    if (message.scheduleTime !== undefined && message.scheduleTime !== 0) {
      writer.uint32(24).uint32(message.scheduleTime);
    }
    if (message.skillLevel !== undefined && message.skillLevel !== 0) {
      writer.uint32(32).uint32(message.skillLevel);
    }
    if (message.tournamentTemplate !== undefined && message.tournamentTemplate !== 0) {
      writer.uint32(40).int32(message.tournamentTemplate);
    }
    if (message.state !== undefined && message.state !== 0) {
      writer.uint32(48).int32(message.state);
    }
    if (message.stateSeqNum !== undefined && message.stateSeqNum !== 0) {
      writer.uint32(80).uint32(message.stateSeqNum);
    }
    if (message.seasonTrophyId !== undefined && message.seasonTrophyId !== 0) {
      writer.uint32(88).uint32(message.seasonTrophyId);
    }
    for (const v of message.teams) {
      CMsgDOTATournament_Team.encode(v!, writer.uint32(58).fork()).ldelim();
    }
    for (const v of message.games) {
      CMsgDOTATournament_Game.encode(v!, writer.uint32(66).fork()).ldelim();
    }
    for (const v of message.nodes) {
      CMsgDOTATournament_Node.encode(v!, writer.uint32(74).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTATournament {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTATournament();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.tournamentId = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.divisionId = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.scheduleTime = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.skillLevel = reader.uint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.tournamentTemplate = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.stateSeqNum = reader.uint32();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.seasonTrophyId = reader.uint32();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.teams.push(CMsgDOTATournament_Team.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.games.push(CMsgDOTATournament_Game.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.nodes.push(CMsgDOTATournament_Node.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTATournament {
    return {
      tournamentId: isSet(object.tournamentId) ? globalThis.Number(object.tournamentId) : 0,
      divisionId: isSet(object.divisionId) ? globalThis.Number(object.divisionId) : 0,
      scheduleTime: isSet(object.scheduleTime) ? globalThis.Number(object.scheduleTime) : 0,
      skillLevel: isSet(object.skillLevel) ? globalThis.Number(object.skillLevel) : 0,
      tournamentTemplate: isSet(object.tournamentTemplate) ? eTournamentTemplateFromJSON(object.tournamentTemplate) : 0,
      state: isSet(object.state) ? eTournamentStateFromJSON(object.state) : 0,
      stateSeqNum: isSet(object.stateSeqNum) ? globalThis.Number(object.stateSeqNum) : 0,
      seasonTrophyId: isSet(object.seasonTrophyId) ? globalThis.Number(object.seasonTrophyId) : 0,
      teams: globalThis.Array.isArray(object?.teams)
        ? object.teams.map((e: any) => CMsgDOTATournament_Team.fromJSON(e))
        : [],
      games: globalThis.Array.isArray(object?.games)
        ? object.games.map((e: any) => CMsgDOTATournament_Game.fromJSON(e))
        : [],
      nodes: globalThis.Array.isArray(object?.nodes)
        ? object.nodes.map((e: any) => CMsgDOTATournament_Node.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgDOTATournament): unknown {
    const obj: any = {};
    if (message.tournamentId !== undefined && message.tournamentId !== 0) {
      obj.tournamentId = Math.round(message.tournamentId);
    }
    if (message.divisionId !== undefined && message.divisionId !== 0) {
      obj.divisionId = Math.round(message.divisionId);
    }
    if (message.scheduleTime !== undefined && message.scheduleTime !== 0) {
      obj.scheduleTime = Math.round(message.scheduleTime);
    }
    if (message.skillLevel !== undefined && message.skillLevel !== 0) {
      obj.skillLevel = Math.round(message.skillLevel);
    }
    if (message.tournamentTemplate !== undefined && message.tournamentTemplate !== 0) {
      obj.tournamentTemplate = eTournamentTemplateToJSON(message.tournamentTemplate);
    }
    if (message.state !== undefined && message.state !== 0) {
      obj.state = eTournamentStateToJSON(message.state);
    }
    if (message.stateSeqNum !== undefined && message.stateSeqNum !== 0) {
      obj.stateSeqNum = Math.round(message.stateSeqNum);
    }
    if (message.seasonTrophyId !== undefined && message.seasonTrophyId !== 0) {
      obj.seasonTrophyId = Math.round(message.seasonTrophyId);
    }
    if (message.teams?.length) {
      obj.teams = message.teams.map((e) => CMsgDOTATournament_Team.toJSON(e));
    }
    if (message.games?.length) {
      obj.games = message.games.map((e) => CMsgDOTATournament_Game.toJSON(e));
    }
    if (message.nodes?.length) {
      obj.nodes = message.nodes.map((e) => CMsgDOTATournament_Node.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTATournament>): CMsgDOTATournament {
    return CMsgDOTATournament.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTATournament>): CMsgDOTATournament {
    const message = createBaseCMsgDOTATournament();
    message.tournamentId = object.tournamentId ?? 0;
    message.divisionId = object.divisionId ?? 0;
    message.scheduleTime = object.scheduleTime ?? 0;
    message.skillLevel = object.skillLevel ?? 0;
    message.tournamentTemplate = object.tournamentTemplate ?? 0;
    message.state = object.state ?? 0;
    message.stateSeqNum = object.stateSeqNum ?? 0;
    message.seasonTrophyId = object.seasonTrophyId ?? 0;
    message.teams = object.teams?.map((e) => CMsgDOTATournament_Team.fromPartial(e)) || [];
    message.games = object.games?.map((e) => CMsgDOTATournament_Game.fromPartial(e)) || [];
    message.nodes = object.nodes?.map((e) => CMsgDOTATournament_Node.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgDOTATournament_Team(): CMsgDOTATournament_Team {
  return {
    teamGid: "0",
    nodeOrState: 0,
    players: [],
    playerBuyin: [],
    playerSkillLevel: [],
    matchGroupMask: 0,
    teamId: 0,
    teamName: "",
    teamBaseLogo: "0",
    teamUiLogo: "0",
  };
}

export const CMsgDOTATournament_Team = {
  encode(message: CMsgDOTATournament_Team, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.teamGid !== undefined && message.teamGid !== "0") {
      writer.uint32(9).fixed64(message.teamGid);
    }
    if (message.nodeOrState !== undefined && message.nodeOrState !== 0) {
      writer.uint32(16).uint32(message.nodeOrState);
    }
    writer.uint32(26).fork();
    for (const v of message.players) {
      writer.uint32(v);
    }
    writer.ldelim();
    writer.uint32(74).fork();
    for (const v of message.playerBuyin) {
      writer.uint32(v);
    }
    writer.ldelim();
    writer.uint32(82).fork();
    for (const v of message.playerSkillLevel) {
      writer.uint32(v);
    }
    writer.ldelim();
    if (message.matchGroupMask !== undefined && message.matchGroupMask !== 0) {
      writer.uint32(96).uint32(message.matchGroupMask);
    }
    if (message.teamId !== undefined && message.teamId !== 0) {
      writer.uint32(32).uint32(message.teamId);
    }
    if (message.teamName !== undefined && message.teamName !== "") {
      writer.uint32(42).string(message.teamName);
    }
    if (message.teamBaseLogo !== undefined && message.teamBaseLogo !== "0") {
      writer.uint32(56).uint64(message.teamBaseLogo);
    }
    if (message.teamUiLogo !== undefined && message.teamUiLogo !== "0") {
      writer.uint32(64).uint64(message.teamUiLogo);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTATournament_Team {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTATournament_Team();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.teamGid = longToString(reader.fixed64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.nodeOrState = reader.uint32();
          continue;
        case 3:
          if (tag === 24) {
            message.players.push(reader.uint32());

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.players.push(reader.uint32());
            }

            continue;
          }

          break;
        case 9:
          if (tag === 72) {
            message.playerBuyin.push(reader.uint32());

            continue;
          }

          if (tag === 74) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.playerBuyin.push(reader.uint32());
            }

            continue;
          }

          break;
        case 10:
          if (tag === 80) {
            message.playerSkillLevel.push(reader.uint32());

            continue;
          }

          if (tag === 82) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.playerSkillLevel.push(reader.uint32());
            }

            continue;
          }

          break;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.matchGroupMask = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.teamId = reader.uint32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.teamName = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.teamBaseLogo = longToString(reader.uint64() as Long);
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.teamUiLogo = longToString(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTATournament_Team {
    return {
      teamGid: isSet(object.teamGid) ? globalThis.String(object.teamGid) : "0",
      nodeOrState: isSet(object.nodeOrState) ? globalThis.Number(object.nodeOrState) : 0,
      players: globalThis.Array.isArray(object?.players) ? object.players.map((e: any) => globalThis.Number(e)) : [],
      playerBuyin: globalThis.Array.isArray(object?.playerBuyin)
        ? object.playerBuyin.map((e: any) => globalThis.Number(e))
        : [],
      playerSkillLevel: globalThis.Array.isArray(object?.playerSkillLevel)
        ? object.playerSkillLevel.map((e: any) => globalThis.Number(e))
        : [],
      matchGroupMask: isSet(object.matchGroupMask) ? globalThis.Number(object.matchGroupMask) : 0,
      teamId: isSet(object.teamId) ? globalThis.Number(object.teamId) : 0,
      teamName: isSet(object.teamName) ? globalThis.String(object.teamName) : "",
      teamBaseLogo: isSet(object.teamBaseLogo) ? globalThis.String(object.teamBaseLogo) : "0",
      teamUiLogo: isSet(object.teamUiLogo) ? globalThis.String(object.teamUiLogo) : "0",
    };
  },

  toJSON(message: CMsgDOTATournament_Team): unknown {
    const obj: any = {};
    if (message.teamGid !== undefined && message.teamGid !== "0") {
      obj.teamGid = message.teamGid;
    }
    if (message.nodeOrState !== undefined && message.nodeOrState !== 0) {
      obj.nodeOrState = Math.round(message.nodeOrState);
    }
    if (message.players?.length) {
      obj.players = message.players.map((e) => Math.round(e));
    }
    if (message.playerBuyin?.length) {
      obj.playerBuyin = message.playerBuyin.map((e) => Math.round(e));
    }
    if (message.playerSkillLevel?.length) {
      obj.playerSkillLevel = message.playerSkillLevel.map((e) => Math.round(e));
    }
    if (message.matchGroupMask !== undefined && message.matchGroupMask !== 0) {
      obj.matchGroupMask = Math.round(message.matchGroupMask);
    }
    if (message.teamId !== undefined && message.teamId !== 0) {
      obj.teamId = Math.round(message.teamId);
    }
    if (message.teamName !== undefined && message.teamName !== "") {
      obj.teamName = message.teamName;
    }
    if (message.teamBaseLogo !== undefined && message.teamBaseLogo !== "0") {
      obj.teamBaseLogo = message.teamBaseLogo;
    }
    if (message.teamUiLogo !== undefined && message.teamUiLogo !== "0") {
      obj.teamUiLogo = message.teamUiLogo;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTATournament_Team>): CMsgDOTATournament_Team {
    return CMsgDOTATournament_Team.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTATournament_Team>): CMsgDOTATournament_Team {
    const message = createBaseCMsgDOTATournament_Team();
    message.teamGid = object.teamGid ?? "0";
    message.nodeOrState = object.nodeOrState ?? 0;
    message.players = object.players?.map((e) => e) || [];
    message.playerBuyin = object.playerBuyin?.map((e) => e) || [];
    message.playerSkillLevel = object.playerSkillLevel?.map((e) => e) || [];
    message.matchGroupMask = object.matchGroupMask ?? 0;
    message.teamId = object.teamId ?? 0;
    message.teamName = object.teamName ?? "";
    message.teamBaseLogo = object.teamBaseLogo ?? "0";
    message.teamUiLogo = object.teamUiLogo ?? "0";
    return message;
  },
};

function createBaseCMsgDOTATournament_Game(): CMsgDOTATournament_Game {
  return { nodeIdx: 0, lobbyId: "0", matchId: "0", teamAGood: false, state: 0, startTime: 0 };
}

export const CMsgDOTATournament_Game = {
  encode(message: CMsgDOTATournament_Game, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.nodeIdx !== undefined && message.nodeIdx !== 0) {
      writer.uint32(8).uint32(message.nodeIdx);
    }
    if (message.lobbyId !== undefined && message.lobbyId !== "0") {
      writer.uint32(17).fixed64(message.lobbyId);
    }
    if (message.matchId !== undefined && message.matchId !== "0") {
      writer.uint32(24).uint64(message.matchId);
    }
    if (message.teamAGood !== undefined && message.teamAGood !== false) {
      writer.uint32(32).bool(message.teamAGood);
    }
    if (message.state !== undefined && message.state !== 0) {
      writer.uint32(40).int32(message.state);
    }
    if (message.startTime !== undefined && message.startTime !== 0) {
      writer.uint32(48).uint32(message.startTime);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTATournament_Game {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTATournament_Game();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.nodeIdx = reader.uint32();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.lobbyId = longToString(reader.fixed64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.matchId = longToString(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.teamAGood = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.startTime = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTATournament_Game {
    return {
      nodeIdx: isSet(object.nodeIdx) ? globalThis.Number(object.nodeIdx) : 0,
      lobbyId: isSet(object.lobbyId) ? globalThis.String(object.lobbyId) : "0",
      matchId: isSet(object.matchId) ? globalThis.String(object.matchId) : "0",
      teamAGood: isSet(object.teamAGood) ? globalThis.Boolean(object.teamAGood) : false,
      state: isSet(object.state) ? eTournamentGameStateFromJSON(object.state) : 0,
      startTime: isSet(object.startTime) ? globalThis.Number(object.startTime) : 0,
    };
  },

  toJSON(message: CMsgDOTATournament_Game): unknown {
    const obj: any = {};
    if (message.nodeIdx !== undefined && message.nodeIdx !== 0) {
      obj.nodeIdx = Math.round(message.nodeIdx);
    }
    if (message.lobbyId !== undefined && message.lobbyId !== "0") {
      obj.lobbyId = message.lobbyId;
    }
    if (message.matchId !== undefined && message.matchId !== "0") {
      obj.matchId = message.matchId;
    }
    if (message.teamAGood !== undefined && message.teamAGood !== false) {
      obj.teamAGood = message.teamAGood;
    }
    if (message.state !== undefined && message.state !== 0) {
      obj.state = eTournamentGameStateToJSON(message.state);
    }
    if (message.startTime !== undefined && message.startTime !== 0) {
      obj.startTime = Math.round(message.startTime);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTATournament_Game>): CMsgDOTATournament_Game {
    return CMsgDOTATournament_Game.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTATournament_Game>): CMsgDOTATournament_Game {
    const message = createBaseCMsgDOTATournament_Game();
    message.nodeIdx = object.nodeIdx ?? 0;
    message.lobbyId = object.lobbyId ?? "0";
    message.matchId = object.matchId ?? "0";
    message.teamAGood = object.teamAGood ?? false;
    message.state = object.state ?? 0;
    message.startTime = object.startTime ?? 0;
    return message;
  },
};

function createBaseCMsgDOTATournament_Node(): CMsgDOTATournament_Node {
  return { nodeId: 0, teamIdxA: 0, teamIdxB: 0, nodeState: 0 };
}

export const CMsgDOTATournament_Node = {
  encode(message: CMsgDOTATournament_Node, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.nodeId !== undefined && message.nodeId !== 0) {
      writer.uint32(8).uint32(message.nodeId);
    }
    if (message.teamIdxA !== undefined && message.teamIdxA !== 0) {
      writer.uint32(16).uint32(message.teamIdxA);
    }
    if (message.teamIdxB !== undefined && message.teamIdxB !== 0) {
      writer.uint32(24).uint32(message.teamIdxB);
    }
    if (message.nodeState !== undefined && message.nodeState !== 0) {
      writer.uint32(32).int32(message.nodeState);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTATournament_Node {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTATournament_Node();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.nodeId = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.teamIdxA = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.teamIdxB = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.nodeState = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTATournament_Node {
    return {
      nodeId: isSet(object.nodeId) ? globalThis.Number(object.nodeId) : 0,
      teamIdxA: isSet(object.teamIdxA) ? globalThis.Number(object.teamIdxA) : 0,
      teamIdxB: isSet(object.teamIdxB) ? globalThis.Number(object.teamIdxB) : 0,
      nodeState: isSet(object.nodeState) ? eTournamentNodeStateFromJSON(object.nodeState) : 0,
    };
  },

  toJSON(message: CMsgDOTATournament_Node): unknown {
    const obj: any = {};
    if (message.nodeId !== undefined && message.nodeId !== 0) {
      obj.nodeId = Math.round(message.nodeId);
    }
    if (message.teamIdxA !== undefined && message.teamIdxA !== 0) {
      obj.teamIdxA = Math.round(message.teamIdxA);
    }
    if (message.teamIdxB !== undefined && message.teamIdxB !== 0) {
      obj.teamIdxB = Math.round(message.teamIdxB);
    }
    if (message.nodeState !== undefined && message.nodeState !== 0) {
      obj.nodeState = eTournamentNodeStateToJSON(message.nodeState);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTATournament_Node>): CMsgDOTATournament_Node {
    return CMsgDOTATournament_Node.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTATournament_Node>): CMsgDOTATournament_Node {
    const message = createBaseCMsgDOTATournament_Node();
    message.nodeId = object.nodeId ?? 0;
    message.teamIdxA = object.teamIdxA ?? 0;
    message.teamIdxB = object.teamIdxB ?? 0;
    message.nodeState = object.nodeState ?? 0;
    return message;
  },
};

function createBaseCMsgDOTATournamentStateChange(): CMsgDOTATournamentStateChange {
  return {
    newTournamentId: 0,
    event: 0,
    newTournamentState: 0,
    gameChanges: [],
    teamChanges: [],
    mergedTournamentIds: [],
    stateSeqNum: 0,
  };
}

export const CMsgDOTATournamentStateChange = {
  encode(message: CMsgDOTATournamentStateChange, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.newTournamentId !== undefined && message.newTournamentId !== 0) {
      writer.uint32(8).uint32(message.newTournamentId);
    }
    if (message.event !== undefined && message.event !== 0) {
      writer.uint32(16).int32(message.event);
    }
    if (message.newTournamentState !== undefined && message.newTournamentState !== 0) {
      writer.uint32(24).int32(message.newTournamentState);
    }
    for (const v of message.gameChanges) {
      CMsgDOTATournamentStateChange_GameChange.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    for (const v of message.teamChanges) {
      CMsgDOTATournamentStateChange_TeamChange.encode(v!, writer.uint32(42).fork()).ldelim();
    }
    writer.uint32(50).fork();
    for (const v of message.mergedTournamentIds) {
      writer.uint32(v);
    }
    writer.ldelim();
    if (message.stateSeqNum !== undefined && message.stateSeqNum !== 0) {
      writer.uint32(56).uint32(message.stateSeqNum);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTATournamentStateChange {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTATournamentStateChange();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.newTournamentId = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.event = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.newTournamentState = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.gameChanges.push(CMsgDOTATournamentStateChange_GameChange.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.teamChanges.push(CMsgDOTATournamentStateChange_TeamChange.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag === 48) {
            message.mergedTournamentIds.push(reader.uint32());

            continue;
          }

          if (tag === 50) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.mergedTournamentIds.push(reader.uint32());
            }

            continue;
          }

          break;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.stateSeqNum = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTATournamentStateChange {
    return {
      newTournamentId: isSet(object.newTournamentId) ? globalThis.Number(object.newTournamentId) : 0,
      event: isSet(object.event) ? eTournamentEventFromJSON(object.event) : 0,
      newTournamentState: isSet(object.newTournamentState) ? eTournamentStateFromJSON(object.newTournamentState) : 0,
      gameChanges: globalThis.Array.isArray(object?.gameChanges)
        ? object.gameChanges.map((e: any) => CMsgDOTATournamentStateChange_GameChange.fromJSON(e))
        : [],
      teamChanges: globalThis.Array.isArray(object?.teamChanges)
        ? object.teamChanges.map((e: any) => CMsgDOTATournamentStateChange_TeamChange.fromJSON(e))
        : [],
      mergedTournamentIds: globalThis.Array.isArray(object?.mergedTournamentIds)
        ? object.mergedTournamentIds.map((e: any) => globalThis.Number(e))
        : [],
      stateSeqNum: isSet(object.stateSeqNum) ? globalThis.Number(object.stateSeqNum) : 0,
    };
  },

  toJSON(message: CMsgDOTATournamentStateChange): unknown {
    const obj: any = {};
    if (message.newTournamentId !== undefined && message.newTournamentId !== 0) {
      obj.newTournamentId = Math.round(message.newTournamentId);
    }
    if (message.event !== undefined && message.event !== 0) {
      obj.event = eTournamentEventToJSON(message.event);
    }
    if (message.newTournamentState !== undefined && message.newTournamentState !== 0) {
      obj.newTournamentState = eTournamentStateToJSON(message.newTournamentState);
    }
    if (message.gameChanges?.length) {
      obj.gameChanges = message.gameChanges.map((e) => CMsgDOTATournamentStateChange_GameChange.toJSON(e));
    }
    if (message.teamChanges?.length) {
      obj.teamChanges = message.teamChanges.map((e) => CMsgDOTATournamentStateChange_TeamChange.toJSON(e));
    }
    if (message.mergedTournamentIds?.length) {
      obj.mergedTournamentIds = message.mergedTournamentIds.map((e) => Math.round(e));
    }
    if (message.stateSeqNum !== undefined && message.stateSeqNum !== 0) {
      obj.stateSeqNum = Math.round(message.stateSeqNum);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTATournamentStateChange>): CMsgDOTATournamentStateChange {
    return CMsgDOTATournamentStateChange.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTATournamentStateChange>): CMsgDOTATournamentStateChange {
    const message = createBaseCMsgDOTATournamentStateChange();
    message.newTournamentId = object.newTournamentId ?? 0;
    message.event = object.event ?? 0;
    message.newTournamentState = object.newTournamentState ?? 0;
    message.gameChanges = object.gameChanges?.map((e) => CMsgDOTATournamentStateChange_GameChange.fromPartial(e)) || [];
    message.teamChanges = object.teamChanges?.map((e) => CMsgDOTATournamentStateChange_TeamChange.fromPartial(e)) || [];
    message.mergedTournamentIds = object.mergedTournamentIds?.map((e) => e) || [];
    message.stateSeqNum = object.stateSeqNum ?? 0;
    return message;
  },
};

function createBaseCMsgDOTATournamentStateChange_GameChange(): CMsgDOTATournamentStateChange_GameChange {
  return { matchId: "0", newState: 0 };
}

export const CMsgDOTATournamentStateChange_GameChange = {
  encode(message: CMsgDOTATournamentStateChange_GameChange, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.matchId !== undefined && message.matchId !== "0") {
      writer.uint32(8).uint64(message.matchId);
    }
    if (message.newState !== undefined && message.newState !== 0) {
      writer.uint32(16).int32(message.newState);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTATournamentStateChange_GameChange {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTATournamentStateChange_GameChange();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.matchId = longToString(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.newState = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTATournamentStateChange_GameChange {
    return {
      matchId: isSet(object.matchId) ? globalThis.String(object.matchId) : "0",
      newState: isSet(object.newState) ? eTournamentGameStateFromJSON(object.newState) : 0,
    };
  },

  toJSON(message: CMsgDOTATournamentStateChange_GameChange): unknown {
    const obj: any = {};
    if (message.matchId !== undefined && message.matchId !== "0") {
      obj.matchId = message.matchId;
    }
    if (message.newState !== undefined && message.newState !== 0) {
      obj.newState = eTournamentGameStateToJSON(message.newState);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTATournamentStateChange_GameChange>): CMsgDOTATournamentStateChange_GameChange {
    return CMsgDOTATournamentStateChange_GameChange.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTATournamentStateChange_GameChange>): CMsgDOTATournamentStateChange_GameChange {
    const message = createBaseCMsgDOTATournamentStateChange_GameChange();
    message.matchId = object.matchId ?? "0";
    message.newState = object.newState ?? 0;
    return message;
  },
};

function createBaseCMsgDOTATournamentStateChange_TeamChange(): CMsgDOTATournamentStateChange_TeamChange {
  return { teamGid: "0", newNodeOrState: 0, oldNodeOrState: 0 };
}

export const CMsgDOTATournamentStateChange_TeamChange = {
  encode(message: CMsgDOTATournamentStateChange_TeamChange, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.teamGid !== undefined && message.teamGid !== "0") {
      writer.uint32(8).uint64(message.teamGid);
    }
    if (message.newNodeOrState !== undefined && message.newNodeOrState !== 0) {
      writer.uint32(16).uint32(message.newNodeOrState);
    }
    if (message.oldNodeOrState !== undefined && message.oldNodeOrState !== 0) {
      writer.uint32(24).uint32(message.oldNodeOrState);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTATournamentStateChange_TeamChange {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTATournamentStateChange_TeamChange();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.teamGid = longToString(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.newNodeOrState = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.oldNodeOrState = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTATournamentStateChange_TeamChange {
    return {
      teamGid: isSet(object.teamGid) ? globalThis.String(object.teamGid) : "0",
      newNodeOrState: isSet(object.newNodeOrState) ? globalThis.Number(object.newNodeOrState) : 0,
      oldNodeOrState: isSet(object.oldNodeOrState) ? globalThis.Number(object.oldNodeOrState) : 0,
    };
  },

  toJSON(message: CMsgDOTATournamentStateChange_TeamChange): unknown {
    const obj: any = {};
    if (message.teamGid !== undefined && message.teamGid !== "0") {
      obj.teamGid = message.teamGid;
    }
    if (message.newNodeOrState !== undefined && message.newNodeOrState !== 0) {
      obj.newNodeOrState = Math.round(message.newNodeOrState);
    }
    if (message.oldNodeOrState !== undefined && message.oldNodeOrState !== 0) {
      obj.oldNodeOrState = Math.round(message.oldNodeOrState);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTATournamentStateChange_TeamChange>): CMsgDOTATournamentStateChange_TeamChange {
    return CMsgDOTATournamentStateChange_TeamChange.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTATournamentStateChange_TeamChange>): CMsgDOTATournamentStateChange_TeamChange {
    const message = createBaseCMsgDOTATournamentStateChange_TeamChange();
    message.teamGid = object.teamGid ?? "0";
    message.newNodeOrState = object.newNodeOrState ?? 0;
    message.oldNodeOrState = object.oldNodeOrState ?? 0;
    return message;
  },
};

function createBaseCMsgDOTAWeekendTourneyPlayerSkillLevelStats(): CMsgDOTAWeekendTourneyPlayerSkillLevelStats {
  return {
    skillLevel: 0,
    timesWon0: 0,
    timesWon1: 0,
    timesWon2: 0,
    timesWon3: 0,
    timesByeAndLost: 0,
    timesByeAndWon: 0,
    timesUnusualChamp: 0,
    totalGamesWon: 0,
    score: 0,
  };
}

export const CMsgDOTAWeekendTourneyPlayerSkillLevelStats = {
  encode(message: CMsgDOTAWeekendTourneyPlayerSkillLevelStats, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.skillLevel !== undefined && message.skillLevel !== 0) {
      writer.uint32(8).uint32(message.skillLevel);
    }
    if (message.timesWon0 !== undefined && message.timesWon0 !== 0) {
      writer.uint32(16).uint32(message.timesWon0);
    }
    if (message.timesWon1 !== undefined && message.timesWon1 !== 0) {
      writer.uint32(24).uint32(message.timesWon1);
    }
    if (message.timesWon2 !== undefined && message.timesWon2 !== 0) {
      writer.uint32(32).uint32(message.timesWon2);
    }
    if (message.timesWon3 !== undefined && message.timesWon3 !== 0) {
      writer.uint32(40).uint32(message.timesWon3);
    }
    if (message.timesByeAndLost !== undefined && message.timesByeAndLost !== 0) {
      writer.uint32(48).uint32(message.timesByeAndLost);
    }
    if (message.timesByeAndWon !== undefined && message.timesByeAndWon !== 0) {
      writer.uint32(56).uint32(message.timesByeAndWon);
    }
    if (message.timesUnusualChamp !== undefined && message.timesUnusualChamp !== 0) {
      writer.uint32(80).uint32(message.timesUnusualChamp);
    }
    if (message.totalGamesWon !== undefined && message.totalGamesWon !== 0) {
      writer.uint32(64).uint32(message.totalGamesWon);
    }
    if (message.score !== undefined && message.score !== 0) {
      writer.uint32(72).uint32(message.score);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTAWeekendTourneyPlayerSkillLevelStats {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAWeekendTourneyPlayerSkillLevelStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.skillLevel = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.timesWon0 = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.timesWon1 = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.timesWon2 = reader.uint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.timesWon3 = reader.uint32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.timesByeAndLost = reader.uint32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.timesByeAndWon = reader.uint32();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.timesUnusualChamp = reader.uint32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.totalGamesWon = reader.uint32();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.score = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAWeekendTourneyPlayerSkillLevelStats {
    return {
      skillLevel: isSet(object.skillLevel) ? globalThis.Number(object.skillLevel) : 0,
      timesWon0: isSet(object.timesWon0) ? globalThis.Number(object.timesWon0) : 0,
      timesWon1: isSet(object.timesWon1) ? globalThis.Number(object.timesWon1) : 0,
      timesWon2: isSet(object.timesWon2) ? globalThis.Number(object.timesWon2) : 0,
      timesWon3: isSet(object.timesWon3) ? globalThis.Number(object.timesWon3) : 0,
      timesByeAndLost: isSet(object.timesByeAndLost) ? globalThis.Number(object.timesByeAndLost) : 0,
      timesByeAndWon: isSet(object.timesByeAndWon) ? globalThis.Number(object.timesByeAndWon) : 0,
      timesUnusualChamp: isSet(object.timesUnusualChamp) ? globalThis.Number(object.timesUnusualChamp) : 0,
      totalGamesWon: isSet(object.totalGamesWon) ? globalThis.Number(object.totalGamesWon) : 0,
      score: isSet(object.score) ? globalThis.Number(object.score) : 0,
    };
  },

  toJSON(message: CMsgDOTAWeekendTourneyPlayerSkillLevelStats): unknown {
    const obj: any = {};
    if (message.skillLevel !== undefined && message.skillLevel !== 0) {
      obj.skillLevel = Math.round(message.skillLevel);
    }
    if (message.timesWon0 !== undefined && message.timesWon0 !== 0) {
      obj.timesWon0 = Math.round(message.timesWon0);
    }
    if (message.timesWon1 !== undefined && message.timesWon1 !== 0) {
      obj.timesWon1 = Math.round(message.timesWon1);
    }
    if (message.timesWon2 !== undefined && message.timesWon2 !== 0) {
      obj.timesWon2 = Math.round(message.timesWon2);
    }
    if (message.timesWon3 !== undefined && message.timesWon3 !== 0) {
      obj.timesWon3 = Math.round(message.timesWon3);
    }
    if (message.timesByeAndLost !== undefined && message.timesByeAndLost !== 0) {
      obj.timesByeAndLost = Math.round(message.timesByeAndLost);
    }
    if (message.timesByeAndWon !== undefined && message.timesByeAndWon !== 0) {
      obj.timesByeAndWon = Math.round(message.timesByeAndWon);
    }
    if (message.timesUnusualChamp !== undefined && message.timesUnusualChamp !== 0) {
      obj.timesUnusualChamp = Math.round(message.timesUnusualChamp);
    }
    if (message.totalGamesWon !== undefined && message.totalGamesWon !== 0) {
      obj.totalGamesWon = Math.round(message.totalGamesWon);
    }
    if (message.score !== undefined && message.score !== 0) {
      obj.score = Math.round(message.score);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTAWeekendTourneyPlayerSkillLevelStats>): CMsgDOTAWeekendTourneyPlayerSkillLevelStats {
    return CMsgDOTAWeekendTourneyPlayerSkillLevelStats.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgDOTAWeekendTourneyPlayerSkillLevelStats>,
  ): CMsgDOTAWeekendTourneyPlayerSkillLevelStats {
    const message = createBaseCMsgDOTAWeekendTourneyPlayerSkillLevelStats();
    message.skillLevel = object.skillLevel ?? 0;
    message.timesWon0 = object.timesWon0 ?? 0;
    message.timesWon1 = object.timesWon1 ?? 0;
    message.timesWon2 = object.timesWon2 ?? 0;
    message.timesWon3 = object.timesWon3 ?? 0;
    message.timesByeAndLost = object.timesByeAndLost ?? 0;
    message.timesByeAndWon = object.timesByeAndWon ?? 0;
    message.timesUnusualChamp = object.timesUnusualChamp ?? 0;
    message.totalGamesWon = object.totalGamesWon ?? 0;
    message.score = object.score ?? 0;
    return message;
  },
};

function createBaseCMsgDOTAWeekendTourneyPlayerStats(): CMsgDOTAWeekendTourneyPlayerStats {
  return { accountId: 0, seasonTrophyId: 0, skillLevels: [], currentTier: 0 };
}

export const CMsgDOTAWeekendTourneyPlayerStats = {
  encode(message: CMsgDOTAWeekendTourneyPlayerStats, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.accountId !== undefined && message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    if (message.seasonTrophyId !== undefined && message.seasonTrophyId !== 0) {
      writer.uint32(16).uint32(message.seasonTrophyId);
    }
    for (const v of message.skillLevels) {
      CMsgDOTAWeekendTourneyPlayerSkillLevelStats.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    if (message.currentTier !== undefined && message.currentTier !== 0) {
      writer.uint32(32).uint32(message.currentTier);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTAWeekendTourneyPlayerStats {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAWeekendTourneyPlayerStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.seasonTrophyId = reader.uint32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.skillLevels.push(CMsgDOTAWeekendTourneyPlayerSkillLevelStats.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.currentTier = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAWeekendTourneyPlayerStats {
    return {
      accountId: isSet(object.accountId) ? globalThis.Number(object.accountId) : 0,
      seasonTrophyId: isSet(object.seasonTrophyId) ? globalThis.Number(object.seasonTrophyId) : 0,
      skillLevels: globalThis.Array.isArray(object?.skillLevels)
        ? object.skillLevels.map((e: any) => CMsgDOTAWeekendTourneyPlayerSkillLevelStats.fromJSON(e))
        : [],
      currentTier: isSet(object.currentTier) ? globalThis.Number(object.currentTier) : 0,
    };
  },

  toJSON(message: CMsgDOTAWeekendTourneyPlayerStats): unknown {
    const obj: any = {};
    if (message.accountId !== undefined && message.accountId !== 0) {
      obj.accountId = Math.round(message.accountId);
    }
    if (message.seasonTrophyId !== undefined && message.seasonTrophyId !== 0) {
      obj.seasonTrophyId = Math.round(message.seasonTrophyId);
    }
    if (message.skillLevels?.length) {
      obj.skillLevels = message.skillLevels.map((e) => CMsgDOTAWeekendTourneyPlayerSkillLevelStats.toJSON(e));
    }
    if (message.currentTier !== undefined && message.currentTier !== 0) {
      obj.currentTier = Math.round(message.currentTier);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTAWeekendTourneyPlayerStats>): CMsgDOTAWeekendTourneyPlayerStats {
    return CMsgDOTAWeekendTourneyPlayerStats.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTAWeekendTourneyPlayerStats>): CMsgDOTAWeekendTourneyPlayerStats {
    const message = createBaseCMsgDOTAWeekendTourneyPlayerStats();
    message.accountId = object.accountId ?? 0;
    message.seasonTrophyId = object.seasonTrophyId ?? 0;
    message.skillLevels =
      object.skillLevels?.map((e) => CMsgDOTAWeekendTourneyPlayerSkillLevelStats.fromPartial(e)) || [];
    message.currentTier = object.currentTier ?? 0;
    return message;
  },
};

function createBaseCMsgDOTAWeekendTourneyPlayerStatsRequest(): CMsgDOTAWeekendTourneyPlayerStatsRequest {
  return { accountId: 0, seasonTrophyId: 0 };
}

export const CMsgDOTAWeekendTourneyPlayerStatsRequest = {
  encode(message: CMsgDOTAWeekendTourneyPlayerStatsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.accountId !== undefined && message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    if (message.seasonTrophyId !== undefined && message.seasonTrophyId !== 0) {
      writer.uint32(16).uint32(message.seasonTrophyId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTAWeekendTourneyPlayerStatsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAWeekendTourneyPlayerStatsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.seasonTrophyId = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAWeekendTourneyPlayerStatsRequest {
    return {
      accountId: isSet(object.accountId) ? globalThis.Number(object.accountId) : 0,
      seasonTrophyId: isSet(object.seasonTrophyId) ? globalThis.Number(object.seasonTrophyId) : 0,
    };
  },

  toJSON(message: CMsgDOTAWeekendTourneyPlayerStatsRequest): unknown {
    const obj: any = {};
    if (message.accountId !== undefined && message.accountId !== 0) {
      obj.accountId = Math.round(message.accountId);
    }
    if (message.seasonTrophyId !== undefined && message.seasonTrophyId !== 0) {
      obj.seasonTrophyId = Math.round(message.seasonTrophyId);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTAWeekendTourneyPlayerStatsRequest>): CMsgDOTAWeekendTourneyPlayerStatsRequest {
    return CMsgDOTAWeekendTourneyPlayerStatsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTAWeekendTourneyPlayerStatsRequest>): CMsgDOTAWeekendTourneyPlayerStatsRequest {
    const message = createBaseCMsgDOTAWeekendTourneyPlayerStatsRequest();
    message.accountId = object.accountId ?? 0;
    message.seasonTrophyId = object.seasonTrophyId ?? 0;
    return message;
  },
};

function createBaseCMsgDOTAWeekendTourneyPlayerHistory(): CMsgDOTAWeekendTourneyPlayerHistory {
  return { accountId: 0, tournaments: [] };
}

export const CMsgDOTAWeekendTourneyPlayerHistory = {
  encode(message: CMsgDOTAWeekendTourneyPlayerHistory, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.accountId !== undefined && message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    for (const v of message.tournaments) {
      CMsgDOTAWeekendTourneyPlayerHistory_Tournament.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTAWeekendTourneyPlayerHistory {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAWeekendTourneyPlayerHistory();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.tournaments.push(CMsgDOTAWeekendTourneyPlayerHistory_Tournament.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAWeekendTourneyPlayerHistory {
    return {
      accountId: isSet(object.accountId) ? globalThis.Number(object.accountId) : 0,
      tournaments: globalThis.Array.isArray(object?.tournaments)
        ? object.tournaments.map((e: any) => CMsgDOTAWeekendTourneyPlayerHistory_Tournament.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgDOTAWeekendTourneyPlayerHistory): unknown {
    const obj: any = {};
    if (message.accountId !== undefined && message.accountId !== 0) {
      obj.accountId = Math.round(message.accountId);
    }
    if (message.tournaments?.length) {
      obj.tournaments = message.tournaments.map((e) => CMsgDOTAWeekendTourneyPlayerHistory_Tournament.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTAWeekendTourneyPlayerHistory>): CMsgDOTAWeekendTourneyPlayerHistory {
    return CMsgDOTAWeekendTourneyPlayerHistory.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTAWeekendTourneyPlayerHistory>): CMsgDOTAWeekendTourneyPlayerHistory {
    const message = createBaseCMsgDOTAWeekendTourneyPlayerHistory();
    message.accountId = object.accountId ?? 0;
    message.tournaments =
      object.tournaments?.map((e) => CMsgDOTAWeekendTourneyPlayerHistory_Tournament.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgDOTAWeekendTourneyPlayerHistory_Tournament(): CMsgDOTAWeekendTourneyPlayerHistory_Tournament {
  return {
    tournamentId: 0,
    startTime: 0,
    tournamentTier: 0,
    teamId: 0,
    teamDate: 0,
    teamResult: 0,
    accountId: [],
    teamName: "",
    seasonTrophyId: 0,
  };
}

export const CMsgDOTAWeekendTourneyPlayerHistory_Tournament = {
  encode(
    message: CMsgDOTAWeekendTourneyPlayerHistory_Tournament,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.tournamentId !== undefined && message.tournamentId !== 0) {
      writer.uint32(8).uint32(message.tournamentId);
    }
    if (message.startTime !== undefined && message.startTime !== 0) {
      writer.uint32(16).uint32(message.startTime);
    }
    if (message.tournamentTier !== undefined && message.tournamentTier !== 0) {
      writer.uint32(24).uint32(message.tournamentTier);
    }
    if (message.teamId !== undefined && message.teamId !== 0) {
      writer.uint32(32).uint32(message.teamId);
    }
    if (message.teamDate !== undefined && message.teamDate !== 0) {
      writer.uint32(40).uint32(message.teamDate);
    }
    if (message.teamResult !== undefined && message.teamResult !== 0) {
      writer.uint32(48).uint32(message.teamResult);
    }
    writer.uint32(58).fork();
    for (const v of message.accountId) {
      writer.uint32(v);
    }
    writer.ldelim();
    if (message.teamName !== undefined && message.teamName !== "") {
      writer.uint32(66).string(message.teamName);
    }
    if (message.seasonTrophyId !== undefined && message.seasonTrophyId !== 0) {
      writer.uint32(72).uint32(message.seasonTrophyId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTAWeekendTourneyPlayerHistory_Tournament {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAWeekendTourneyPlayerHistory_Tournament();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.tournamentId = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.startTime = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.tournamentTier = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.teamId = reader.uint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.teamDate = reader.uint32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.teamResult = reader.uint32();
          continue;
        case 7:
          if (tag === 56) {
            message.accountId.push(reader.uint32());

            continue;
          }

          if (tag === 58) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.accountId.push(reader.uint32());
            }

            continue;
          }

          break;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.teamName = reader.string();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.seasonTrophyId = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAWeekendTourneyPlayerHistory_Tournament {
    return {
      tournamentId: isSet(object.tournamentId) ? globalThis.Number(object.tournamentId) : 0,
      startTime: isSet(object.startTime) ? globalThis.Number(object.startTime) : 0,
      tournamentTier: isSet(object.tournamentTier) ? globalThis.Number(object.tournamentTier) : 0,
      teamId: isSet(object.teamId) ? globalThis.Number(object.teamId) : 0,
      teamDate: isSet(object.teamDate) ? globalThis.Number(object.teamDate) : 0,
      teamResult: isSet(object.teamResult) ? globalThis.Number(object.teamResult) : 0,
      accountId: globalThis.Array.isArray(object?.accountId)
        ? object.accountId.map((e: any) => globalThis.Number(e))
        : [],
      teamName: isSet(object.teamName) ? globalThis.String(object.teamName) : "",
      seasonTrophyId: isSet(object.seasonTrophyId) ? globalThis.Number(object.seasonTrophyId) : 0,
    };
  },

  toJSON(message: CMsgDOTAWeekendTourneyPlayerHistory_Tournament): unknown {
    const obj: any = {};
    if (message.tournamentId !== undefined && message.tournamentId !== 0) {
      obj.tournamentId = Math.round(message.tournamentId);
    }
    if (message.startTime !== undefined && message.startTime !== 0) {
      obj.startTime = Math.round(message.startTime);
    }
    if (message.tournamentTier !== undefined && message.tournamentTier !== 0) {
      obj.tournamentTier = Math.round(message.tournamentTier);
    }
    if (message.teamId !== undefined && message.teamId !== 0) {
      obj.teamId = Math.round(message.teamId);
    }
    if (message.teamDate !== undefined && message.teamDate !== 0) {
      obj.teamDate = Math.round(message.teamDate);
    }
    if (message.teamResult !== undefined && message.teamResult !== 0) {
      obj.teamResult = Math.round(message.teamResult);
    }
    if (message.accountId?.length) {
      obj.accountId = message.accountId.map((e) => Math.round(e));
    }
    if (message.teamName !== undefined && message.teamName !== "") {
      obj.teamName = message.teamName;
    }
    if (message.seasonTrophyId !== undefined && message.seasonTrophyId !== 0) {
      obj.seasonTrophyId = Math.round(message.seasonTrophyId);
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgDOTAWeekendTourneyPlayerHistory_Tournament>,
  ): CMsgDOTAWeekendTourneyPlayerHistory_Tournament {
    return CMsgDOTAWeekendTourneyPlayerHistory_Tournament.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgDOTAWeekendTourneyPlayerHistory_Tournament>,
  ): CMsgDOTAWeekendTourneyPlayerHistory_Tournament {
    const message = createBaseCMsgDOTAWeekendTourneyPlayerHistory_Tournament();
    message.tournamentId = object.tournamentId ?? 0;
    message.startTime = object.startTime ?? 0;
    message.tournamentTier = object.tournamentTier ?? 0;
    message.teamId = object.teamId ?? 0;
    message.teamDate = object.teamDate ?? 0;
    message.teamResult = object.teamResult ?? 0;
    message.accountId = object.accountId?.map((e) => e) || [];
    message.teamName = object.teamName ?? "";
    message.seasonTrophyId = object.seasonTrophyId ?? 0;
    return message;
  },
};

function createBaseCMsgDOTAWeekendTourneyParticipationDetails(): CMsgDOTAWeekendTourneyParticipationDetails {
  return { divisions: [] };
}

export const CMsgDOTAWeekendTourneyParticipationDetails = {
  encode(message: CMsgDOTAWeekendTourneyParticipationDetails, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.divisions) {
      CMsgDOTAWeekendTourneyParticipationDetails_Division.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTAWeekendTourneyParticipationDetails {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAWeekendTourneyParticipationDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.divisions.push(CMsgDOTAWeekendTourneyParticipationDetails_Division.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAWeekendTourneyParticipationDetails {
    return {
      divisions: globalThis.Array.isArray(object?.divisions)
        ? object.divisions.map((e: any) => CMsgDOTAWeekendTourneyParticipationDetails_Division.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgDOTAWeekendTourneyParticipationDetails): unknown {
    const obj: any = {};
    if (message.divisions?.length) {
      obj.divisions = message.divisions.map((e) => CMsgDOTAWeekendTourneyParticipationDetails_Division.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTAWeekendTourneyParticipationDetails>): CMsgDOTAWeekendTourneyParticipationDetails {
    return CMsgDOTAWeekendTourneyParticipationDetails.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgDOTAWeekendTourneyParticipationDetails>,
  ): CMsgDOTAWeekendTourneyParticipationDetails {
    const message = createBaseCMsgDOTAWeekendTourneyParticipationDetails();
    message.divisions =
      object.divisions?.map((e) => CMsgDOTAWeekendTourneyParticipationDetails_Division.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgDOTAWeekendTourneyParticipationDetails_Tier(): CMsgDOTAWeekendTourneyParticipationDetails_Tier {
  return {
    tier: 0,
    players: 0,
    teams: 0,
    winningTeams: 0,
    playersStreak2: 0,
    playersStreak3: 0,
    playersStreak4: 0,
    playersStreak5: 0,
  };
}

export const CMsgDOTAWeekendTourneyParticipationDetails_Tier = {
  encode(
    message: CMsgDOTAWeekendTourneyParticipationDetails_Tier,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.tier !== undefined && message.tier !== 0) {
      writer.uint32(8).uint32(message.tier);
    }
    if (message.players !== undefined && message.players !== 0) {
      writer.uint32(16).uint32(message.players);
    }
    if (message.teams !== undefined && message.teams !== 0) {
      writer.uint32(24).uint32(message.teams);
    }
    if (message.winningTeams !== undefined && message.winningTeams !== 0) {
      writer.uint32(32).uint32(message.winningTeams);
    }
    if (message.playersStreak2 !== undefined && message.playersStreak2 !== 0) {
      writer.uint32(40).uint32(message.playersStreak2);
    }
    if (message.playersStreak3 !== undefined && message.playersStreak3 !== 0) {
      writer.uint32(48).uint32(message.playersStreak3);
    }
    if (message.playersStreak4 !== undefined && message.playersStreak4 !== 0) {
      writer.uint32(56).uint32(message.playersStreak4);
    }
    if (message.playersStreak5 !== undefined && message.playersStreak5 !== 0) {
      writer.uint32(64).uint32(message.playersStreak5);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTAWeekendTourneyParticipationDetails_Tier {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAWeekendTourneyParticipationDetails_Tier();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.tier = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.players = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.teams = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.winningTeams = reader.uint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.playersStreak2 = reader.uint32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.playersStreak3 = reader.uint32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.playersStreak4 = reader.uint32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.playersStreak5 = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAWeekendTourneyParticipationDetails_Tier {
    return {
      tier: isSet(object.tier) ? globalThis.Number(object.tier) : 0,
      players: isSet(object.players) ? globalThis.Number(object.players) : 0,
      teams: isSet(object.teams) ? globalThis.Number(object.teams) : 0,
      winningTeams: isSet(object.winningTeams) ? globalThis.Number(object.winningTeams) : 0,
      playersStreak2: isSet(object.playersStreak2) ? globalThis.Number(object.playersStreak2) : 0,
      playersStreak3: isSet(object.playersStreak3) ? globalThis.Number(object.playersStreak3) : 0,
      playersStreak4: isSet(object.playersStreak4) ? globalThis.Number(object.playersStreak4) : 0,
      playersStreak5: isSet(object.playersStreak5) ? globalThis.Number(object.playersStreak5) : 0,
    };
  },

  toJSON(message: CMsgDOTAWeekendTourneyParticipationDetails_Tier): unknown {
    const obj: any = {};
    if (message.tier !== undefined && message.tier !== 0) {
      obj.tier = Math.round(message.tier);
    }
    if (message.players !== undefined && message.players !== 0) {
      obj.players = Math.round(message.players);
    }
    if (message.teams !== undefined && message.teams !== 0) {
      obj.teams = Math.round(message.teams);
    }
    if (message.winningTeams !== undefined && message.winningTeams !== 0) {
      obj.winningTeams = Math.round(message.winningTeams);
    }
    if (message.playersStreak2 !== undefined && message.playersStreak2 !== 0) {
      obj.playersStreak2 = Math.round(message.playersStreak2);
    }
    if (message.playersStreak3 !== undefined && message.playersStreak3 !== 0) {
      obj.playersStreak3 = Math.round(message.playersStreak3);
    }
    if (message.playersStreak4 !== undefined && message.playersStreak4 !== 0) {
      obj.playersStreak4 = Math.round(message.playersStreak4);
    }
    if (message.playersStreak5 !== undefined && message.playersStreak5 !== 0) {
      obj.playersStreak5 = Math.round(message.playersStreak5);
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgDOTAWeekendTourneyParticipationDetails_Tier>,
  ): CMsgDOTAWeekendTourneyParticipationDetails_Tier {
    return CMsgDOTAWeekendTourneyParticipationDetails_Tier.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgDOTAWeekendTourneyParticipationDetails_Tier>,
  ): CMsgDOTAWeekendTourneyParticipationDetails_Tier {
    const message = createBaseCMsgDOTAWeekendTourneyParticipationDetails_Tier();
    message.tier = object.tier ?? 0;
    message.players = object.players ?? 0;
    message.teams = object.teams ?? 0;
    message.winningTeams = object.winningTeams ?? 0;
    message.playersStreak2 = object.playersStreak2 ?? 0;
    message.playersStreak3 = object.playersStreak3 ?? 0;
    message.playersStreak4 = object.playersStreak4 ?? 0;
    message.playersStreak5 = object.playersStreak5 ?? 0;
    return message;
  },
};

function createBaseCMsgDOTAWeekendTourneyParticipationDetails_Division(): CMsgDOTAWeekendTourneyParticipationDetails_Division {
  return { divisionId: 0, scheduleTime: 0, tiers: [] };
}

export const CMsgDOTAWeekendTourneyParticipationDetails_Division = {
  encode(
    message: CMsgDOTAWeekendTourneyParticipationDetails_Division,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.divisionId !== undefined && message.divisionId !== 0) {
      writer.uint32(8).uint32(message.divisionId);
    }
    if (message.scheduleTime !== undefined && message.scheduleTime !== 0) {
      writer.uint32(16).uint32(message.scheduleTime);
    }
    for (const v of message.tiers) {
      CMsgDOTAWeekendTourneyParticipationDetails_Tier.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTAWeekendTourneyParticipationDetails_Division {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTAWeekendTourneyParticipationDetails_Division();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.divisionId = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.scheduleTime = reader.uint32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.tiers.push(CMsgDOTAWeekendTourneyParticipationDetails_Tier.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTAWeekendTourneyParticipationDetails_Division {
    return {
      divisionId: isSet(object.divisionId) ? globalThis.Number(object.divisionId) : 0,
      scheduleTime: isSet(object.scheduleTime) ? globalThis.Number(object.scheduleTime) : 0,
      tiers: globalThis.Array.isArray(object?.tiers)
        ? object.tiers.map((e: any) => CMsgDOTAWeekendTourneyParticipationDetails_Tier.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgDOTAWeekendTourneyParticipationDetails_Division): unknown {
    const obj: any = {};
    if (message.divisionId !== undefined && message.divisionId !== 0) {
      obj.divisionId = Math.round(message.divisionId);
    }
    if (message.scheduleTime !== undefined && message.scheduleTime !== 0) {
      obj.scheduleTime = Math.round(message.scheduleTime);
    }
    if (message.tiers?.length) {
      obj.tiers = message.tiers.map((e) => CMsgDOTAWeekendTourneyParticipationDetails_Tier.toJSON(e));
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgDOTAWeekendTourneyParticipationDetails_Division>,
  ): CMsgDOTAWeekendTourneyParticipationDetails_Division {
    return CMsgDOTAWeekendTourneyParticipationDetails_Division.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgDOTAWeekendTourneyParticipationDetails_Division>,
  ): CMsgDOTAWeekendTourneyParticipationDetails_Division {
    const message = createBaseCMsgDOTAWeekendTourneyParticipationDetails_Division();
    message.divisionId = object.divisionId ?? 0;
    message.scheduleTime = object.scheduleTime ?? 0;
    message.tiers = object.tiers?.map((e) => CMsgDOTAWeekendTourneyParticipationDetails_Tier.fromPartial(e)) || [];
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin
  ? T
  : T extends globalThis.Array<infer U>
    ? globalThis.Array<DeepPartial<U>>
    : T extends ReadonlyArray<infer U>
      ? ReadonlyArray<DeepPartial<U>>
      : T extends {}
        ? { [K in keyof T]?: DeepPartial<T[K]> }
        : Partial<T>;

function longToString(long: Long) {
  return long.toString();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

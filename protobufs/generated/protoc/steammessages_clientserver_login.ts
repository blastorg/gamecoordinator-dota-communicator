// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.176.1
//   protoc               v5.26.1
// source: steammessages_clientserver_login.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";
import { CMsgIPAddress } from "./steammessages_base";

export interface CMsgClientHeartBeat {}

export interface CMsgClientServerTimestampRequest {
  clientRequestTimestamp?: string | undefined;
}

export interface CMsgClientServerTimestampResponse {
  clientRequestTimestamp?: string | undefined;
  serverTimestampMs?: string | undefined;
}

export interface CMsgClientSecret {
  version?: number | undefined;
  appid?: number | undefined;
  deviceid?: number | undefined;
  nonce?: string | undefined;
  hmac?: Buffer | undefined;
}

export interface CMsgClientLogon {
  protocolVersion?: number | undefined;
  deprecatedObfustucatedPrivateIp?: number | undefined;
  cellId?: number | undefined;
  lastSessionId?: number | undefined;
  clientPackageVersion?: number | undefined;
  clientLanguage?: string | undefined;
  clientOsType?: number | undefined;
  shouldRememberPassword?: boolean | undefined;
  wineVersion?: string | undefined;
  deprecated10?: number | undefined;
  obfuscatedPrivateIp?: CMsgIPAddress | undefined;
  deprecatedPublicIp?: number | undefined;
  qosLevel?: number | undefined;
  clientSuppliedSteamId?: string | undefined;
  publicIp?: CMsgIPAddress | undefined;
  machineId?: Buffer | undefined;
  launcherType?: number | undefined;
  uiMode?: number | undefined;
  chatMode?: number | undefined;
  steam2AuthTicket?: Buffer | undefined;
  emailAddress?: string | undefined;
  rtime32AccountCreation?: number | undefined;
  accountName?: string | undefined;
  password?: string | undefined;
  gameServerToken?: string | undefined;
  loginKey?: string | undefined;
  wasConvertedDeprecatedMsg?: boolean | undefined;
  anonUserTargetAccountName?: string | undefined;
  resolvedUserSteamId?: string | undefined;
  eresultSentryfile?: number | undefined;
  shaSentryfile?: Buffer | undefined;
  authCode?: string | undefined;
  otpType?: number | undefined;
  otpValue?: number | undefined;
  otpIdentifier?: string | undefined;
  steam2TicketRequest?: boolean | undefined;
  sonyPsnTicket?: Buffer | undefined;
  sonyPsnServiceId?: string | undefined;
  createNewPsnLinkedAccountIfNeeded?: boolean | undefined;
  sonyPsnName?: string | undefined;
  gameServerAppId?: number | undefined;
  steamguardDontRememberComputer?: boolean | undefined;
  machineName?: string | undefined;
  machineNameUserchosen?: string | undefined;
  countryOverride?: string | undefined;
  isSteamBox?: boolean | undefined;
  clientInstanceId?: string | undefined;
  twoFactorCode?: string | undefined;
  supportsRateLimitResponse?: boolean | undefined;
  webLogonNonce?: string | undefined;
  priorityReason?: number | undefined;
  embeddedClientSecret?: CMsgClientSecret | undefined;
}

export interface CMsgClientLogonResponse {
  eresult?: number | undefined;
  outOfGameHeartbeatSeconds?: number | undefined;
  inGameHeartbeatSeconds?: number | undefined;
  deprecatedPublicIp?: number | undefined;
  rtime32ServerTime?: number | undefined;
  accountFlags?: number | undefined;
  cellId?: number | undefined;
  emailDomain?: string | undefined;
  steam2Ticket?: Buffer | undefined;
  eresultExtended?: number | undefined;
  webapiAuthenticateUserNonce?: string | undefined;
  cellIdPingThreshold?: number | undefined;
  usePics?: boolean | undefined;
  vanityUrl?: string | undefined;
  publicIp?: CMsgIPAddress | undefined;
  clientSuppliedSteamid?: string | undefined;
  ipCountryCode?: string | undefined;
  parentalSettings?: Buffer | undefined;
  parentalSettingSignature?: Buffer | undefined;
  countLoginfailuresToMigrate?: number | undefined;
  countDisconnectsToMigrate?: number | undefined;
  ogsDataReportTimeWindow?: number | undefined;
  clientInstanceId?: string | undefined;
  forceClientUpdateCheck?: boolean | undefined;
}

export interface CMsgClientRequestWebAPIAuthenticateUserNonce {
  tokenType?: number | undefined;
}

export interface CMsgClientRequestWebAPIAuthenticateUserNonceResponse {
  eresult?: number | undefined;
  webapiAuthenticateUserNonce?: string | undefined;
  tokenType?: number | undefined;
}

export interface CMsgClientLogOff {}

export interface CMsgClientLoggedOff {
  eresult?: number | undefined;
}

export interface CMsgClientNewLoginKey {
  uniqueId?: number | undefined;
  loginKey?: string | undefined;
}

export interface CMsgClientNewLoginKeyAccepted {
  uniqueId?: number | undefined;
}

export interface CMsgClientAccountInfo {
  personaName?: string | undefined;
  ipCountry?: string | undefined;
  countAuthedComputers?: number | undefined;
  accountFlags?: number | undefined;
  facebookId?: string | undefined;
  facebookName?: string | undefined;
  steamguardNotifyNewmachines?: boolean | undefined;
  steamguardMachineNameUserChosen?: string | undefined;
  isPhoneVerified?: boolean | undefined;
  twoFactorState?: number | undefined;
  isPhoneIdentifying?: boolean | undefined;
  isPhoneNeedingReverify?: boolean | undefined;
}

export interface CMsgClientChallengeRequest {
  steamid?: string | undefined;
}

export interface CMsgClientChallengeResponse {
  challenge?: string | undefined;
}

function createBaseCMsgClientHeartBeat(): CMsgClientHeartBeat {
  return {};
}

export const CMsgClientHeartBeat = {
  encode(_: CMsgClientHeartBeat, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientHeartBeat {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientHeartBeat();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CMsgClientHeartBeat {
    return {};
  },

  toJSON(_: CMsgClientHeartBeat): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<CMsgClientHeartBeat>): CMsgClientHeartBeat {
    return CMsgClientHeartBeat.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<CMsgClientHeartBeat>): CMsgClientHeartBeat {
    const message = createBaseCMsgClientHeartBeat();
    return message;
  },
};

function createBaseCMsgClientServerTimestampRequest(): CMsgClientServerTimestampRequest {
  return { clientRequestTimestamp: "0" };
}

export const CMsgClientServerTimestampRequest = {
  encode(message: CMsgClientServerTimestampRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.clientRequestTimestamp !== undefined && message.clientRequestTimestamp !== "0") {
      writer.uint32(8).uint64(message.clientRequestTimestamp);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientServerTimestampRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientServerTimestampRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.clientRequestTimestamp = longToString(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientServerTimestampRequest {
    return {
      clientRequestTimestamp: isSet(object.clientRequestTimestamp)
        ? globalThis.String(object.clientRequestTimestamp)
        : "0",
    };
  },

  toJSON(message: CMsgClientServerTimestampRequest): unknown {
    const obj: any = {};
    if (message.clientRequestTimestamp !== undefined && message.clientRequestTimestamp !== "0") {
      obj.clientRequestTimestamp = message.clientRequestTimestamp;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgClientServerTimestampRequest>): CMsgClientServerTimestampRequest {
    return CMsgClientServerTimestampRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgClientServerTimestampRequest>): CMsgClientServerTimestampRequest {
    const message = createBaseCMsgClientServerTimestampRequest();
    message.clientRequestTimestamp = object.clientRequestTimestamp ?? "0";
    return message;
  },
};

function createBaseCMsgClientServerTimestampResponse(): CMsgClientServerTimestampResponse {
  return { clientRequestTimestamp: "0", serverTimestampMs: "0" };
}

export const CMsgClientServerTimestampResponse = {
  encode(message: CMsgClientServerTimestampResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.clientRequestTimestamp !== undefined && message.clientRequestTimestamp !== "0") {
      writer.uint32(8).uint64(message.clientRequestTimestamp);
    }
    if (message.serverTimestampMs !== undefined && message.serverTimestampMs !== "0") {
      writer.uint32(16).uint64(message.serverTimestampMs);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientServerTimestampResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientServerTimestampResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.clientRequestTimestamp = longToString(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.serverTimestampMs = longToString(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientServerTimestampResponse {
    return {
      clientRequestTimestamp: isSet(object.clientRequestTimestamp)
        ? globalThis.String(object.clientRequestTimestamp)
        : "0",
      serverTimestampMs: isSet(object.serverTimestampMs) ? globalThis.String(object.serverTimestampMs) : "0",
    };
  },

  toJSON(message: CMsgClientServerTimestampResponse): unknown {
    const obj: any = {};
    if (message.clientRequestTimestamp !== undefined && message.clientRequestTimestamp !== "0") {
      obj.clientRequestTimestamp = message.clientRequestTimestamp;
    }
    if (message.serverTimestampMs !== undefined && message.serverTimestampMs !== "0") {
      obj.serverTimestampMs = message.serverTimestampMs;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgClientServerTimestampResponse>): CMsgClientServerTimestampResponse {
    return CMsgClientServerTimestampResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgClientServerTimestampResponse>): CMsgClientServerTimestampResponse {
    const message = createBaseCMsgClientServerTimestampResponse();
    message.clientRequestTimestamp = object.clientRequestTimestamp ?? "0";
    message.serverTimestampMs = object.serverTimestampMs ?? "0";
    return message;
  },
};

function createBaseCMsgClientSecret(): CMsgClientSecret {
  return { version: 0, appid: 0, deviceid: 0, nonce: "0", hmac: Buffer.alloc(0) };
}

export const CMsgClientSecret = {
  encode(message: CMsgClientSecret, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.version !== undefined && message.version !== 0) {
      writer.uint32(8).uint32(message.version);
    }
    if (message.appid !== undefined && message.appid !== 0) {
      writer.uint32(16).uint32(message.appid);
    }
    if (message.deviceid !== undefined && message.deviceid !== 0) {
      writer.uint32(24).uint32(message.deviceid);
    }
    if (message.nonce !== undefined && message.nonce !== "0") {
      writer.uint32(33).fixed64(message.nonce);
    }
    if (message.hmac !== undefined && message.hmac.length !== 0) {
      writer.uint32(42).bytes(message.hmac);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientSecret {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientSecret();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.version = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.appid = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.deviceid = reader.uint32();
          continue;
        case 4:
          if (tag !== 33) {
            break;
          }

          message.nonce = longToString(reader.fixed64() as Long);
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.hmac = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientSecret {
    return {
      version: isSet(object.version) ? globalThis.Number(object.version) : 0,
      appid: isSet(object.appid) ? globalThis.Number(object.appid) : 0,
      deviceid: isSet(object.deviceid) ? globalThis.Number(object.deviceid) : 0,
      nonce: isSet(object.nonce) ? globalThis.String(object.nonce) : "0",
      hmac: isSet(object.hmac) ? Buffer.from(bytesFromBase64(object.hmac)) : Buffer.alloc(0),
    };
  },

  toJSON(message: CMsgClientSecret): unknown {
    const obj: any = {};
    if (message.version !== undefined && message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    if (message.appid !== undefined && message.appid !== 0) {
      obj.appid = Math.round(message.appid);
    }
    if (message.deviceid !== undefined && message.deviceid !== 0) {
      obj.deviceid = Math.round(message.deviceid);
    }
    if (message.nonce !== undefined && message.nonce !== "0") {
      obj.nonce = message.nonce;
    }
    if (message.hmac !== undefined && message.hmac.length !== 0) {
      obj.hmac = base64FromBytes(message.hmac);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgClientSecret>): CMsgClientSecret {
    return CMsgClientSecret.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgClientSecret>): CMsgClientSecret {
    const message = createBaseCMsgClientSecret();
    message.version = object.version ?? 0;
    message.appid = object.appid ?? 0;
    message.deviceid = object.deviceid ?? 0;
    message.nonce = object.nonce ?? "0";
    message.hmac = object.hmac ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseCMsgClientLogon(): CMsgClientLogon {
  return {
    protocolVersion: 0,
    deprecatedObfustucatedPrivateIp: 0,
    cellId: 0,
    lastSessionId: 0,
    clientPackageVersion: 0,
    clientLanguage: "",
    clientOsType: 0,
    shouldRememberPassword: false,
    wineVersion: "",
    deprecated10: 0,
    obfuscatedPrivateIp: undefined,
    deprecatedPublicIp: 0,
    qosLevel: 0,
    clientSuppliedSteamId: "0",
    publicIp: undefined,
    machineId: Buffer.alloc(0),
    launcherType: 0,
    uiMode: 0,
    chatMode: 0,
    steam2AuthTicket: Buffer.alloc(0),
    emailAddress: "",
    rtime32AccountCreation: 0,
    accountName: "",
    password: "",
    gameServerToken: "",
    loginKey: "",
    wasConvertedDeprecatedMsg: false,
    anonUserTargetAccountName: "",
    resolvedUserSteamId: "0",
    eresultSentryfile: 0,
    shaSentryfile: Buffer.alloc(0),
    authCode: "",
    otpType: 0,
    otpValue: 0,
    otpIdentifier: "",
    steam2TicketRequest: false,
    sonyPsnTicket: Buffer.alloc(0),
    sonyPsnServiceId: "",
    createNewPsnLinkedAccountIfNeeded: false,
    sonyPsnName: "",
    gameServerAppId: 0,
    steamguardDontRememberComputer: false,
    machineName: "",
    machineNameUserchosen: "",
    countryOverride: "",
    isSteamBox: false,
    clientInstanceId: "0",
    twoFactorCode: "",
    supportsRateLimitResponse: false,
    webLogonNonce: "",
    priorityReason: 0,
    embeddedClientSecret: undefined,
  };
}

export const CMsgClientLogon = {
  encode(message: CMsgClientLogon, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.protocolVersion !== undefined && message.protocolVersion !== 0) {
      writer.uint32(8).uint32(message.protocolVersion);
    }
    if (message.deprecatedObfustucatedPrivateIp !== undefined && message.deprecatedObfustucatedPrivateIp !== 0) {
      writer.uint32(16).uint32(message.deprecatedObfustucatedPrivateIp);
    }
    if (message.cellId !== undefined && message.cellId !== 0) {
      writer.uint32(24).uint32(message.cellId);
    }
    if (message.lastSessionId !== undefined && message.lastSessionId !== 0) {
      writer.uint32(32).uint32(message.lastSessionId);
    }
    if (message.clientPackageVersion !== undefined && message.clientPackageVersion !== 0) {
      writer.uint32(40).uint32(message.clientPackageVersion);
    }
    if (message.clientLanguage !== undefined && message.clientLanguage !== "") {
      writer.uint32(50).string(message.clientLanguage);
    }
    if (message.clientOsType !== undefined && message.clientOsType !== 0) {
      writer.uint32(56).uint32(message.clientOsType);
    }
    if (message.shouldRememberPassword !== undefined && message.shouldRememberPassword !== false) {
      writer.uint32(64).bool(message.shouldRememberPassword);
    }
    if (message.wineVersion !== undefined && message.wineVersion !== "") {
      writer.uint32(74).string(message.wineVersion);
    }
    if (message.deprecated10 !== undefined && message.deprecated10 !== 0) {
      writer.uint32(80).uint32(message.deprecated10);
    }
    if (message.obfuscatedPrivateIp !== undefined) {
      CMsgIPAddress.encode(message.obfuscatedPrivateIp, writer.uint32(90).fork()).ldelim();
    }
    if (message.deprecatedPublicIp !== undefined && message.deprecatedPublicIp !== 0) {
      writer.uint32(160).uint32(message.deprecatedPublicIp);
    }
    if (message.qosLevel !== undefined && message.qosLevel !== 0) {
      writer.uint32(168).uint32(message.qosLevel);
    }
    if (message.clientSuppliedSteamId !== undefined && message.clientSuppliedSteamId !== "0") {
      writer.uint32(177).fixed64(message.clientSuppliedSteamId);
    }
    if (message.publicIp !== undefined) {
      CMsgIPAddress.encode(message.publicIp, writer.uint32(186).fork()).ldelim();
    }
    if (message.machineId !== undefined && message.machineId.length !== 0) {
      writer.uint32(242).bytes(message.machineId);
    }
    if (message.launcherType !== undefined && message.launcherType !== 0) {
      writer.uint32(248).uint32(message.launcherType);
    }
    if (message.uiMode !== undefined && message.uiMode !== 0) {
      writer.uint32(256).uint32(message.uiMode);
    }
    if (message.chatMode !== undefined && message.chatMode !== 0) {
      writer.uint32(264).uint32(message.chatMode);
    }
    if (message.steam2AuthTicket !== undefined && message.steam2AuthTicket.length !== 0) {
      writer.uint32(330).bytes(message.steam2AuthTicket);
    }
    if (message.emailAddress !== undefined && message.emailAddress !== "") {
      writer.uint32(338).string(message.emailAddress);
    }
    if (message.rtime32AccountCreation !== undefined && message.rtime32AccountCreation !== 0) {
      writer.uint32(349).fixed32(message.rtime32AccountCreation);
    }
    if (message.accountName !== undefined && message.accountName !== "") {
      writer.uint32(402).string(message.accountName);
    }
    if (message.password !== undefined && message.password !== "") {
      writer.uint32(410).string(message.password);
    }
    if (message.gameServerToken !== undefined && message.gameServerToken !== "") {
      writer.uint32(418).string(message.gameServerToken);
    }
    if (message.loginKey !== undefined && message.loginKey !== "") {
      writer.uint32(482).string(message.loginKey);
    }
    if (message.wasConvertedDeprecatedMsg !== undefined && message.wasConvertedDeprecatedMsg !== false) {
      writer.uint32(560).bool(message.wasConvertedDeprecatedMsg);
    }
    if (message.anonUserTargetAccountName !== undefined && message.anonUserTargetAccountName !== "") {
      writer.uint32(642).string(message.anonUserTargetAccountName);
    }
    if (message.resolvedUserSteamId !== undefined && message.resolvedUserSteamId !== "0") {
      writer.uint32(649).fixed64(message.resolvedUserSteamId);
    }
    if (message.eresultSentryfile !== undefined && message.eresultSentryfile !== 0) {
      writer.uint32(656).int32(message.eresultSentryfile);
    }
    if (message.shaSentryfile !== undefined && message.shaSentryfile.length !== 0) {
      writer.uint32(666).bytes(message.shaSentryfile);
    }
    if (message.authCode !== undefined && message.authCode !== "") {
      writer.uint32(674).string(message.authCode);
    }
    if (message.otpType !== undefined && message.otpType !== 0) {
      writer.uint32(680).int32(message.otpType);
    }
    if (message.otpValue !== undefined && message.otpValue !== 0) {
      writer.uint32(688).uint32(message.otpValue);
    }
    if (message.otpIdentifier !== undefined && message.otpIdentifier !== "") {
      writer.uint32(698).string(message.otpIdentifier);
    }
    if (message.steam2TicketRequest !== undefined && message.steam2TicketRequest !== false) {
      writer.uint32(704).bool(message.steam2TicketRequest);
    }
    if (message.sonyPsnTicket !== undefined && message.sonyPsnTicket.length !== 0) {
      writer.uint32(722).bytes(message.sonyPsnTicket);
    }
    if (message.sonyPsnServiceId !== undefined && message.sonyPsnServiceId !== "") {
      writer.uint32(730).string(message.sonyPsnServiceId);
    }
    if (
      message.createNewPsnLinkedAccountIfNeeded !== undefined &&
      message.createNewPsnLinkedAccountIfNeeded !== false
    ) {
      writer.uint32(736).bool(message.createNewPsnLinkedAccountIfNeeded);
    }
    if (message.sonyPsnName !== undefined && message.sonyPsnName !== "") {
      writer.uint32(746).string(message.sonyPsnName);
    }
    if (message.gameServerAppId !== undefined && message.gameServerAppId !== 0) {
      writer.uint32(752).int32(message.gameServerAppId);
    }
    if (message.steamguardDontRememberComputer !== undefined && message.steamguardDontRememberComputer !== false) {
      writer.uint32(760).bool(message.steamguardDontRememberComputer);
    }
    if (message.machineName !== undefined && message.machineName !== "") {
      writer.uint32(770).string(message.machineName);
    }
    if (message.machineNameUserchosen !== undefined && message.machineNameUserchosen !== "") {
      writer.uint32(778).string(message.machineNameUserchosen);
    }
    if (message.countryOverride !== undefined && message.countryOverride !== "") {
      writer.uint32(786).string(message.countryOverride);
    }
    if (message.isSteamBox !== undefined && message.isSteamBox !== false) {
      writer.uint32(792).bool(message.isSteamBox);
    }
    if (message.clientInstanceId !== undefined && message.clientInstanceId !== "0") {
      writer.uint32(800).uint64(message.clientInstanceId);
    }
    if (message.twoFactorCode !== undefined && message.twoFactorCode !== "") {
      writer.uint32(810).string(message.twoFactorCode);
    }
    if (message.supportsRateLimitResponse !== undefined && message.supportsRateLimitResponse !== false) {
      writer.uint32(816).bool(message.supportsRateLimitResponse);
    }
    if (message.webLogonNonce !== undefined && message.webLogonNonce !== "") {
      writer.uint32(826).string(message.webLogonNonce);
    }
    if (message.priorityReason !== undefined && message.priorityReason !== 0) {
      writer.uint32(832).int32(message.priorityReason);
    }
    if (message.embeddedClientSecret !== undefined) {
      CMsgClientSecret.encode(message.embeddedClientSecret, writer.uint32(842).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientLogon {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientLogon();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.protocolVersion = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.deprecatedObfustucatedPrivateIp = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.cellId = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.lastSessionId = reader.uint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.clientPackageVersion = reader.uint32();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.clientLanguage = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.clientOsType = reader.uint32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.shouldRememberPassword = reader.bool();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.wineVersion = reader.string();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.deprecated10 = reader.uint32();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.obfuscatedPrivateIp = CMsgIPAddress.decode(reader, reader.uint32());
          continue;
        case 20:
          if (tag !== 160) {
            break;
          }

          message.deprecatedPublicIp = reader.uint32();
          continue;
        case 21:
          if (tag !== 168) {
            break;
          }

          message.qosLevel = reader.uint32();
          continue;
        case 22:
          if (tag !== 177) {
            break;
          }

          message.clientSuppliedSteamId = longToString(reader.fixed64() as Long);
          continue;
        case 23:
          if (tag !== 186) {
            break;
          }

          message.publicIp = CMsgIPAddress.decode(reader, reader.uint32());
          continue;
        case 30:
          if (tag !== 242) {
            break;
          }

          message.machineId = reader.bytes() as Buffer;
          continue;
        case 31:
          if (tag !== 248) {
            break;
          }

          message.launcherType = reader.uint32();
          continue;
        case 32:
          if (tag !== 256) {
            break;
          }

          message.uiMode = reader.uint32();
          continue;
        case 33:
          if (tag !== 264) {
            break;
          }

          message.chatMode = reader.uint32();
          continue;
        case 41:
          if (tag !== 330) {
            break;
          }

          message.steam2AuthTicket = reader.bytes() as Buffer;
          continue;
        case 42:
          if (tag !== 338) {
            break;
          }

          message.emailAddress = reader.string();
          continue;
        case 43:
          if (tag !== 349) {
            break;
          }

          message.rtime32AccountCreation = reader.fixed32();
          continue;
        case 50:
          if (tag !== 402) {
            break;
          }

          message.accountName = reader.string();
          continue;
        case 51:
          if (tag !== 410) {
            break;
          }

          message.password = reader.string();
          continue;
        case 52:
          if (tag !== 418) {
            break;
          }

          message.gameServerToken = reader.string();
          continue;
        case 60:
          if (tag !== 482) {
            break;
          }

          message.loginKey = reader.string();
          continue;
        case 70:
          if (tag !== 560) {
            break;
          }

          message.wasConvertedDeprecatedMsg = reader.bool();
          continue;
        case 80:
          if (tag !== 642) {
            break;
          }

          message.anonUserTargetAccountName = reader.string();
          continue;
        case 81:
          if (tag !== 649) {
            break;
          }

          message.resolvedUserSteamId = longToString(reader.fixed64() as Long);
          continue;
        case 82:
          if (tag !== 656) {
            break;
          }

          message.eresultSentryfile = reader.int32();
          continue;
        case 83:
          if (tag !== 666) {
            break;
          }

          message.shaSentryfile = reader.bytes() as Buffer;
          continue;
        case 84:
          if (tag !== 674) {
            break;
          }

          message.authCode = reader.string();
          continue;
        case 85:
          if (tag !== 680) {
            break;
          }

          message.otpType = reader.int32();
          continue;
        case 86:
          if (tag !== 688) {
            break;
          }

          message.otpValue = reader.uint32();
          continue;
        case 87:
          if (tag !== 698) {
            break;
          }

          message.otpIdentifier = reader.string();
          continue;
        case 88:
          if (tag !== 704) {
            break;
          }

          message.steam2TicketRequest = reader.bool();
          continue;
        case 90:
          if (tag !== 722) {
            break;
          }

          message.sonyPsnTicket = reader.bytes() as Buffer;
          continue;
        case 91:
          if (tag !== 730) {
            break;
          }

          message.sonyPsnServiceId = reader.string();
          continue;
        case 92:
          if (tag !== 736) {
            break;
          }

          message.createNewPsnLinkedAccountIfNeeded = reader.bool();
          continue;
        case 93:
          if (tag !== 746) {
            break;
          }

          message.sonyPsnName = reader.string();
          continue;
        case 94:
          if (tag !== 752) {
            break;
          }

          message.gameServerAppId = reader.int32();
          continue;
        case 95:
          if (tag !== 760) {
            break;
          }

          message.steamguardDontRememberComputer = reader.bool();
          continue;
        case 96:
          if (tag !== 770) {
            break;
          }

          message.machineName = reader.string();
          continue;
        case 97:
          if (tag !== 778) {
            break;
          }

          message.machineNameUserchosen = reader.string();
          continue;
        case 98:
          if (tag !== 786) {
            break;
          }

          message.countryOverride = reader.string();
          continue;
        case 99:
          if (tag !== 792) {
            break;
          }

          message.isSteamBox = reader.bool();
          continue;
        case 100:
          if (tag !== 800) {
            break;
          }

          message.clientInstanceId = longToString(reader.uint64() as Long);
          continue;
        case 101:
          if (tag !== 810) {
            break;
          }

          message.twoFactorCode = reader.string();
          continue;
        case 102:
          if (tag !== 816) {
            break;
          }

          message.supportsRateLimitResponse = reader.bool();
          continue;
        case 103:
          if (tag !== 826) {
            break;
          }

          message.webLogonNonce = reader.string();
          continue;
        case 104:
          if (tag !== 832) {
            break;
          }

          message.priorityReason = reader.int32();
          continue;
        case 105:
          if (tag !== 842) {
            break;
          }

          message.embeddedClientSecret = CMsgClientSecret.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientLogon {
    return {
      protocolVersion: isSet(object.protocolVersion) ? globalThis.Number(object.protocolVersion) : 0,
      deprecatedObfustucatedPrivateIp: isSet(object.deprecatedObfustucatedPrivateIp)
        ? globalThis.Number(object.deprecatedObfustucatedPrivateIp)
        : 0,
      cellId: isSet(object.cellId) ? globalThis.Number(object.cellId) : 0,
      lastSessionId: isSet(object.lastSessionId) ? globalThis.Number(object.lastSessionId) : 0,
      clientPackageVersion: isSet(object.clientPackageVersion) ? globalThis.Number(object.clientPackageVersion) : 0,
      clientLanguage: isSet(object.clientLanguage) ? globalThis.String(object.clientLanguage) : "",
      clientOsType: isSet(object.clientOsType) ? globalThis.Number(object.clientOsType) : 0,
      shouldRememberPassword: isSet(object.shouldRememberPassword)
        ? globalThis.Boolean(object.shouldRememberPassword)
        : false,
      wineVersion: isSet(object.wineVersion) ? globalThis.String(object.wineVersion) : "",
      deprecated10: isSet(object.deprecated10) ? globalThis.Number(object.deprecated10) : 0,
      obfuscatedPrivateIp: isSet(object.obfuscatedPrivateIp)
        ? CMsgIPAddress.fromJSON(object.obfuscatedPrivateIp)
        : undefined,
      deprecatedPublicIp: isSet(object.deprecatedPublicIp) ? globalThis.Number(object.deprecatedPublicIp) : 0,
      qosLevel: isSet(object.qosLevel) ? globalThis.Number(object.qosLevel) : 0,
      clientSuppliedSteamId: isSet(object.clientSuppliedSteamId)
        ? globalThis.String(object.clientSuppliedSteamId)
        : "0",
      publicIp: isSet(object.publicIp) ? CMsgIPAddress.fromJSON(object.publicIp) : undefined,
      machineId: isSet(object.machineId) ? Buffer.from(bytesFromBase64(object.machineId)) : Buffer.alloc(0),
      launcherType: isSet(object.launcherType) ? globalThis.Number(object.launcherType) : 0,
      uiMode: isSet(object.uiMode) ? globalThis.Number(object.uiMode) : 0,
      chatMode: isSet(object.chatMode) ? globalThis.Number(object.chatMode) : 0,
      steam2AuthTicket: isSet(object.steam2AuthTicket)
        ? Buffer.from(bytesFromBase64(object.steam2AuthTicket))
        : Buffer.alloc(0),
      emailAddress: isSet(object.emailAddress) ? globalThis.String(object.emailAddress) : "",
      rtime32AccountCreation: isSet(object.rtime32AccountCreation)
        ? globalThis.Number(object.rtime32AccountCreation)
        : 0,
      accountName: isSet(object.accountName) ? globalThis.String(object.accountName) : "",
      password: isSet(object.password) ? globalThis.String(object.password) : "",
      gameServerToken: isSet(object.gameServerToken) ? globalThis.String(object.gameServerToken) : "",
      loginKey: isSet(object.loginKey) ? globalThis.String(object.loginKey) : "",
      wasConvertedDeprecatedMsg: isSet(object.wasConvertedDeprecatedMsg)
        ? globalThis.Boolean(object.wasConvertedDeprecatedMsg)
        : false,
      anonUserTargetAccountName: isSet(object.anonUserTargetAccountName)
        ? globalThis.String(object.anonUserTargetAccountName)
        : "",
      resolvedUserSteamId: isSet(object.resolvedUserSteamId) ? globalThis.String(object.resolvedUserSteamId) : "0",
      eresultSentryfile: isSet(object.eresultSentryfile) ? globalThis.Number(object.eresultSentryfile) : 0,
      shaSentryfile: isSet(object.shaSentryfile) ? Buffer.from(bytesFromBase64(object.shaSentryfile)) : Buffer.alloc(0),
      authCode: isSet(object.authCode) ? globalThis.String(object.authCode) : "",
      otpType: isSet(object.otpType) ? globalThis.Number(object.otpType) : 0,
      otpValue: isSet(object.otpValue) ? globalThis.Number(object.otpValue) : 0,
      otpIdentifier: isSet(object.otpIdentifier) ? globalThis.String(object.otpIdentifier) : "",
      steam2TicketRequest: isSet(object.steam2TicketRequest) ? globalThis.Boolean(object.steam2TicketRequest) : false,
      sonyPsnTicket: isSet(object.sonyPsnTicket) ? Buffer.from(bytesFromBase64(object.sonyPsnTicket)) : Buffer.alloc(0),
      sonyPsnServiceId: isSet(object.sonyPsnServiceId) ? globalThis.String(object.sonyPsnServiceId) : "",
      createNewPsnLinkedAccountIfNeeded: isSet(object.createNewPsnLinkedAccountIfNeeded)
        ? globalThis.Boolean(object.createNewPsnLinkedAccountIfNeeded)
        : false,
      sonyPsnName: isSet(object.sonyPsnName) ? globalThis.String(object.sonyPsnName) : "",
      gameServerAppId: isSet(object.gameServerAppId) ? globalThis.Number(object.gameServerAppId) : 0,
      steamguardDontRememberComputer: isSet(object.steamguardDontRememberComputer)
        ? globalThis.Boolean(object.steamguardDontRememberComputer)
        : false,
      machineName: isSet(object.machineName) ? globalThis.String(object.machineName) : "",
      machineNameUserchosen: isSet(object.machineNameUserchosen) ? globalThis.String(object.machineNameUserchosen) : "",
      countryOverride: isSet(object.countryOverride) ? globalThis.String(object.countryOverride) : "",
      isSteamBox: isSet(object.isSteamBox) ? globalThis.Boolean(object.isSteamBox) : false,
      clientInstanceId: isSet(object.clientInstanceId) ? globalThis.String(object.clientInstanceId) : "0",
      twoFactorCode: isSet(object.twoFactorCode) ? globalThis.String(object.twoFactorCode) : "",
      supportsRateLimitResponse: isSet(object.supportsRateLimitResponse)
        ? globalThis.Boolean(object.supportsRateLimitResponse)
        : false,
      webLogonNonce: isSet(object.webLogonNonce) ? globalThis.String(object.webLogonNonce) : "",
      priorityReason: isSet(object.priorityReason) ? globalThis.Number(object.priorityReason) : 0,
      embeddedClientSecret: isSet(object.embeddedClientSecret)
        ? CMsgClientSecret.fromJSON(object.embeddedClientSecret)
        : undefined,
    };
  },

  toJSON(message: CMsgClientLogon): unknown {
    const obj: any = {};
    if (message.protocolVersion !== undefined && message.protocolVersion !== 0) {
      obj.protocolVersion = Math.round(message.protocolVersion);
    }
    if (message.deprecatedObfustucatedPrivateIp !== undefined && message.deprecatedObfustucatedPrivateIp !== 0) {
      obj.deprecatedObfustucatedPrivateIp = Math.round(message.deprecatedObfustucatedPrivateIp);
    }
    if (message.cellId !== undefined && message.cellId !== 0) {
      obj.cellId = Math.round(message.cellId);
    }
    if (message.lastSessionId !== undefined && message.lastSessionId !== 0) {
      obj.lastSessionId = Math.round(message.lastSessionId);
    }
    if (message.clientPackageVersion !== undefined && message.clientPackageVersion !== 0) {
      obj.clientPackageVersion = Math.round(message.clientPackageVersion);
    }
    if (message.clientLanguage !== undefined && message.clientLanguage !== "") {
      obj.clientLanguage = message.clientLanguage;
    }
    if (message.clientOsType !== undefined && message.clientOsType !== 0) {
      obj.clientOsType = Math.round(message.clientOsType);
    }
    if (message.shouldRememberPassword !== undefined && message.shouldRememberPassword !== false) {
      obj.shouldRememberPassword = message.shouldRememberPassword;
    }
    if (message.wineVersion !== undefined && message.wineVersion !== "") {
      obj.wineVersion = message.wineVersion;
    }
    if (message.deprecated10 !== undefined && message.deprecated10 !== 0) {
      obj.deprecated10 = Math.round(message.deprecated10);
    }
    if (message.obfuscatedPrivateIp !== undefined) {
      obj.obfuscatedPrivateIp = CMsgIPAddress.toJSON(message.obfuscatedPrivateIp);
    }
    if (message.deprecatedPublicIp !== undefined && message.deprecatedPublicIp !== 0) {
      obj.deprecatedPublicIp = Math.round(message.deprecatedPublicIp);
    }
    if (message.qosLevel !== undefined && message.qosLevel !== 0) {
      obj.qosLevel = Math.round(message.qosLevel);
    }
    if (message.clientSuppliedSteamId !== undefined && message.clientSuppliedSteamId !== "0") {
      obj.clientSuppliedSteamId = message.clientSuppliedSteamId;
    }
    if (message.publicIp !== undefined) {
      obj.publicIp = CMsgIPAddress.toJSON(message.publicIp);
    }
    if (message.machineId !== undefined && message.machineId.length !== 0) {
      obj.machineId = base64FromBytes(message.machineId);
    }
    if (message.launcherType !== undefined && message.launcherType !== 0) {
      obj.launcherType = Math.round(message.launcherType);
    }
    if (message.uiMode !== undefined && message.uiMode !== 0) {
      obj.uiMode = Math.round(message.uiMode);
    }
    if (message.chatMode !== undefined && message.chatMode !== 0) {
      obj.chatMode = Math.round(message.chatMode);
    }
    if (message.steam2AuthTicket !== undefined && message.steam2AuthTicket.length !== 0) {
      obj.steam2AuthTicket = base64FromBytes(message.steam2AuthTicket);
    }
    if (message.emailAddress !== undefined && message.emailAddress !== "") {
      obj.emailAddress = message.emailAddress;
    }
    if (message.rtime32AccountCreation !== undefined && message.rtime32AccountCreation !== 0) {
      obj.rtime32AccountCreation = Math.round(message.rtime32AccountCreation);
    }
    if (message.accountName !== undefined && message.accountName !== "") {
      obj.accountName = message.accountName;
    }
    if (message.password !== undefined && message.password !== "") {
      obj.password = message.password;
    }
    if (message.gameServerToken !== undefined && message.gameServerToken !== "") {
      obj.gameServerToken = message.gameServerToken;
    }
    if (message.loginKey !== undefined && message.loginKey !== "") {
      obj.loginKey = message.loginKey;
    }
    if (message.wasConvertedDeprecatedMsg !== undefined && message.wasConvertedDeprecatedMsg !== false) {
      obj.wasConvertedDeprecatedMsg = message.wasConvertedDeprecatedMsg;
    }
    if (message.anonUserTargetAccountName !== undefined && message.anonUserTargetAccountName !== "") {
      obj.anonUserTargetAccountName = message.anonUserTargetAccountName;
    }
    if (message.resolvedUserSteamId !== undefined && message.resolvedUserSteamId !== "0") {
      obj.resolvedUserSteamId = message.resolvedUserSteamId;
    }
    if (message.eresultSentryfile !== undefined && message.eresultSentryfile !== 0) {
      obj.eresultSentryfile = Math.round(message.eresultSentryfile);
    }
    if (message.shaSentryfile !== undefined && message.shaSentryfile.length !== 0) {
      obj.shaSentryfile = base64FromBytes(message.shaSentryfile);
    }
    if (message.authCode !== undefined && message.authCode !== "") {
      obj.authCode = message.authCode;
    }
    if (message.otpType !== undefined && message.otpType !== 0) {
      obj.otpType = Math.round(message.otpType);
    }
    if (message.otpValue !== undefined && message.otpValue !== 0) {
      obj.otpValue = Math.round(message.otpValue);
    }
    if (message.otpIdentifier !== undefined && message.otpIdentifier !== "") {
      obj.otpIdentifier = message.otpIdentifier;
    }
    if (message.steam2TicketRequest !== undefined && message.steam2TicketRequest !== false) {
      obj.steam2TicketRequest = message.steam2TicketRequest;
    }
    if (message.sonyPsnTicket !== undefined && message.sonyPsnTicket.length !== 0) {
      obj.sonyPsnTicket = base64FromBytes(message.sonyPsnTicket);
    }
    if (message.sonyPsnServiceId !== undefined && message.sonyPsnServiceId !== "") {
      obj.sonyPsnServiceId = message.sonyPsnServiceId;
    }
    if (
      message.createNewPsnLinkedAccountIfNeeded !== undefined &&
      message.createNewPsnLinkedAccountIfNeeded !== false
    ) {
      obj.createNewPsnLinkedAccountIfNeeded = message.createNewPsnLinkedAccountIfNeeded;
    }
    if (message.sonyPsnName !== undefined && message.sonyPsnName !== "") {
      obj.sonyPsnName = message.sonyPsnName;
    }
    if (message.gameServerAppId !== undefined && message.gameServerAppId !== 0) {
      obj.gameServerAppId = Math.round(message.gameServerAppId);
    }
    if (message.steamguardDontRememberComputer !== undefined && message.steamguardDontRememberComputer !== false) {
      obj.steamguardDontRememberComputer = message.steamguardDontRememberComputer;
    }
    if (message.machineName !== undefined && message.machineName !== "") {
      obj.machineName = message.machineName;
    }
    if (message.machineNameUserchosen !== undefined && message.machineNameUserchosen !== "") {
      obj.machineNameUserchosen = message.machineNameUserchosen;
    }
    if (message.countryOverride !== undefined && message.countryOverride !== "") {
      obj.countryOverride = message.countryOverride;
    }
    if (message.isSteamBox !== undefined && message.isSteamBox !== false) {
      obj.isSteamBox = message.isSteamBox;
    }
    if (message.clientInstanceId !== undefined && message.clientInstanceId !== "0") {
      obj.clientInstanceId = message.clientInstanceId;
    }
    if (message.twoFactorCode !== undefined && message.twoFactorCode !== "") {
      obj.twoFactorCode = message.twoFactorCode;
    }
    if (message.supportsRateLimitResponse !== undefined && message.supportsRateLimitResponse !== false) {
      obj.supportsRateLimitResponse = message.supportsRateLimitResponse;
    }
    if (message.webLogonNonce !== undefined && message.webLogonNonce !== "") {
      obj.webLogonNonce = message.webLogonNonce;
    }
    if (message.priorityReason !== undefined && message.priorityReason !== 0) {
      obj.priorityReason = Math.round(message.priorityReason);
    }
    if (message.embeddedClientSecret !== undefined) {
      obj.embeddedClientSecret = CMsgClientSecret.toJSON(message.embeddedClientSecret);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgClientLogon>): CMsgClientLogon {
    return CMsgClientLogon.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgClientLogon>): CMsgClientLogon {
    const message = createBaseCMsgClientLogon();
    message.protocolVersion = object.protocolVersion ?? 0;
    message.deprecatedObfustucatedPrivateIp = object.deprecatedObfustucatedPrivateIp ?? 0;
    message.cellId = object.cellId ?? 0;
    message.lastSessionId = object.lastSessionId ?? 0;
    message.clientPackageVersion = object.clientPackageVersion ?? 0;
    message.clientLanguage = object.clientLanguage ?? "";
    message.clientOsType = object.clientOsType ?? 0;
    message.shouldRememberPassword = object.shouldRememberPassword ?? false;
    message.wineVersion = object.wineVersion ?? "";
    message.deprecated10 = object.deprecated10 ?? 0;
    message.obfuscatedPrivateIp =
      object.obfuscatedPrivateIp !== undefined && object.obfuscatedPrivateIp !== null
        ? CMsgIPAddress.fromPartial(object.obfuscatedPrivateIp)
        : undefined;
    message.deprecatedPublicIp = object.deprecatedPublicIp ?? 0;
    message.qosLevel = object.qosLevel ?? 0;
    message.clientSuppliedSteamId = object.clientSuppliedSteamId ?? "0";
    message.publicIp =
      object.publicIp !== undefined && object.publicIp !== null
        ? CMsgIPAddress.fromPartial(object.publicIp)
        : undefined;
    message.machineId = object.machineId ?? Buffer.alloc(0);
    message.launcherType = object.launcherType ?? 0;
    message.uiMode = object.uiMode ?? 0;
    message.chatMode = object.chatMode ?? 0;
    message.steam2AuthTicket = object.steam2AuthTicket ?? Buffer.alloc(0);
    message.emailAddress = object.emailAddress ?? "";
    message.rtime32AccountCreation = object.rtime32AccountCreation ?? 0;
    message.accountName = object.accountName ?? "";
    message.password = object.password ?? "";
    message.gameServerToken = object.gameServerToken ?? "";
    message.loginKey = object.loginKey ?? "";
    message.wasConvertedDeprecatedMsg = object.wasConvertedDeprecatedMsg ?? false;
    message.anonUserTargetAccountName = object.anonUserTargetAccountName ?? "";
    message.resolvedUserSteamId = object.resolvedUserSteamId ?? "0";
    message.eresultSentryfile = object.eresultSentryfile ?? 0;
    message.shaSentryfile = object.shaSentryfile ?? Buffer.alloc(0);
    message.authCode = object.authCode ?? "";
    message.otpType = object.otpType ?? 0;
    message.otpValue = object.otpValue ?? 0;
    message.otpIdentifier = object.otpIdentifier ?? "";
    message.steam2TicketRequest = object.steam2TicketRequest ?? false;
    message.sonyPsnTicket = object.sonyPsnTicket ?? Buffer.alloc(0);
    message.sonyPsnServiceId = object.sonyPsnServiceId ?? "";
    message.createNewPsnLinkedAccountIfNeeded = object.createNewPsnLinkedAccountIfNeeded ?? false;
    message.sonyPsnName = object.sonyPsnName ?? "";
    message.gameServerAppId = object.gameServerAppId ?? 0;
    message.steamguardDontRememberComputer = object.steamguardDontRememberComputer ?? false;
    message.machineName = object.machineName ?? "";
    message.machineNameUserchosen = object.machineNameUserchosen ?? "";
    message.countryOverride = object.countryOverride ?? "";
    message.isSteamBox = object.isSteamBox ?? false;
    message.clientInstanceId = object.clientInstanceId ?? "0";
    message.twoFactorCode = object.twoFactorCode ?? "";
    message.supportsRateLimitResponse = object.supportsRateLimitResponse ?? false;
    message.webLogonNonce = object.webLogonNonce ?? "";
    message.priorityReason = object.priorityReason ?? 0;
    message.embeddedClientSecret =
      object.embeddedClientSecret !== undefined && object.embeddedClientSecret !== null
        ? CMsgClientSecret.fromPartial(object.embeddedClientSecret)
        : undefined;
    return message;
  },
};

function createBaseCMsgClientLogonResponse(): CMsgClientLogonResponse {
  return {
    eresult: 2,
    outOfGameHeartbeatSeconds: 0,
    inGameHeartbeatSeconds: 0,
    deprecatedPublicIp: 0,
    rtime32ServerTime: 0,
    accountFlags: 0,
    cellId: 0,
    emailDomain: "",
    steam2Ticket: Buffer.alloc(0),
    eresultExtended: 0,
    webapiAuthenticateUserNonce: "",
    cellIdPingThreshold: 0,
    usePics: false,
    vanityUrl: "",
    publicIp: undefined,
    clientSuppliedSteamid: "0",
    ipCountryCode: "",
    parentalSettings: Buffer.alloc(0),
    parentalSettingSignature: Buffer.alloc(0),
    countLoginfailuresToMigrate: 0,
    countDisconnectsToMigrate: 0,
    ogsDataReportTimeWindow: 0,
    clientInstanceId: "0",
    forceClientUpdateCheck: false,
  };
}

export const CMsgClientLogonResponse = {
  encode(message: CMsgClientLogonResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.eresult !== undefined && message.eresult !== 2) {
      writer.uint32(8).int32(message.eresult);
    }
    if (message.outOfGameHeartbeatSeconds !== undefined && message.outOfGameHeartbeatSeconds !== 0) {
      writer.uint32(16).int32(message.outOfGameHeartbeatSeconds);
    }
    if (message.inGameHeartbeatSeconds !== undefined && message.inGameHeartbeatSeconds !== 0) {
      writer.uint32(24).int32(message.inGameHeartbeatSeconds);
    }
    if (message.deprecatedPublicIp !== undefined && message.deprecatedPublicIp !== 0) {
      writer.uint32(32).uint32(message.deprecatedPublicIp);
    }
    if (message.rtime32ServerTime !== undefined && message.rtime32ServerTime !== 0) {
      writer.uint32(45).fixed32(message.rtime32ServerTime);
    }
    if (message.accountFlags !== undefined && message.accountFlags !== 0) {
      writer.uint32(48).uint32(message.accountFlags);
    }
    if (message.cellId !== undefined && message.cellId !== 0) {
      writer.uint32(56).uint32(message.cellId);
    }
    if (message.emailDomain !== undefined && message.emailDomain !== "") {
      writer.uint32(66).string(message.emailDomain);
    }
    if (message.steam2Ticket !== undefined && message.steam2Ticket.length !== 0) {
      writer.uint32(74).bytes(message.steam2Ticket);
    }
    if (message.eresultExtended !== undefined && message.eresultExtended !== 0) {
      writer.uint32(80).int32(message.eresultExtended);
    }
    if (message.webapiAuthenticateUserNonce !== undefined && message.webapiAuthenticateUserNonce !== "") {
      writer.uint32(90).string(message.webapiAuthenticateUserNonce);
    }
    if (message.cellIdPingThreshold !== undefined && message.cellIdPingThreshold !== 0) {
      writer.uint32(96).uint32(message.cellIdPingThreshold);
    }
    if (message.usePics !== undefined && message.usePics !== false) {
      writer.uint32(104).bool(message.usePics);
    }
    if (message.vanityUrl !== undefined && message.vanityUrl !== "") {
      writer.uint32(114).string(message.vanityUrl);
    }
    if (message.publicIp !== undefined) {
      CMsgIPAddress.encode(message.publicIp, writer.uint32(122).fork()).ldelim();
    }
    if (message.clientSuppliedSteamid !== undefined && message.clientSuppliedSteamid !== "0") {
      writer.uint32(161).fixed64(message.clientSuppliedSteamid);
    }
    if (message.ipCountryCode !== undefined && message.ipCountryCode !== "") {
      writer.uint32(170).string(message.ipCountryCode);
    }
    if (message.parentalSettings !== undefined && message.parentalSettings.length !== 0) {
      writer.uint32(178).bytes(message.parentalSettings);
    }
    if (message.parentalSettingSignature !== undefined && message.parentalSettingSignature.length !== 0) {
      writer.uint32(186).bytes(message.parentalSettingSignature);
    }
    if (message.countLoginfailuresToMigrate !== undefined && message.countLoginfailuresToMigrate !== 0) {
      writer.uint32(192).int32(message.countLoginfailuresToMigrate);
    }
    if (message.countDisconnectsToMigrate !== undefined && message.countDisconnectsToMigrate !== 0) {
      writer.uint32(200).int32(message.countDisconnectsToMigrate);
    }
    if (message.ogsDataReportTimeWindow !== undefined && message.ogsDataReportTimeWindow !== 0) {
      writer.uint32(208).int32(message.ogsDataReportTimeWindow);
    }
    if (message.clientInstanceId !== undefined && message.clientInstanceId !== "0") {
      writer.uint32(216).uint64(message.clientInstanceId);
    }
    if (message.forceClientUpdateCheck !== undefined && message.forceClientUpdateCheck !== false) {
      writer.uint32(224).bool(message.forceClientUpdateCheck);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientLogonResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientLogonResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.eresult = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.outOfGameHeartbeatSeconds = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.inGameHeartbeatSeconds = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.deprecatedPublicIp = reader.uint32();
          continue;
        case 5:
          if (tag !== 45) {
            break;
          }

          message.rtime32ServerTime = reader.fixed32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.accountFlags = reader.uint32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.cellId = reader.uint32();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.emailDomain = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.steam2Ticket = reader.bytes() as Buffer;
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.eresultExtended = reader.int32();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.webapiAuthenticateUserNonce = reader.string();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.cellIdPingThreshold = reader.uint32();
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.usePics = reader.bool();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.vanityUrl = reader.string();
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.publicIp = CMsgIPAddress.decode(reader, reader.uint32());
          continue;
        case 20:
          if (tag !== 161) {
            break;
          }

          message.clientSuppliedSteamid = longToString(reader.fixed64() as Long);
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }

          message.ipCountryCode = reader.string();
          continue;
        case 22:
          if (tag !== 178) {
            break;
          }

          message.parentalSettings = reader.bytes() as Buffer;
          continue;
        case 23:
          if (tag !== 186) {
            break;
          }

          message.parentalSettingSignature = reader.bytes() as Buffer;
          continue;
        case 24:
          if (tag !== 192) {
            break;
          }

          message.countLoginfailuresToMigrate = reader.int32();
          continue;
        case 25:
          if (tag !== 200) {
            break;
          }

          message.countDisconnectsToMigrate = reader.int32();
          continue;
        case 26:
          if (tag !== 208) {
            break;
          }

          message.ogsDataReportTimeWindow = reader.int32();
          continue;
        case 27:
          if (tag !== 216) {
            break;
          }

          message.clientInstanceId = longToString(reader.uint64() as Long);
          continue;
        case 28:
          if (tag !== 224) {
            break;
          }

          message.forceClientUpdateCheck = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientLogonResponse {
    return {
      eresult: isSet(object.eresult) ? globalThis.Number(object.eresult) : 2,
      outOfGameHeartbeatSeconds: isSet(object.outOfGameHeartbeatSeconds)
        ? globalThis.Number(object.outOfGameHeartbeatSeconds)
        : 0,
      inGameHeartbeatSeconds: isSet(object.inGameHeartbeatSeconds)
        ? globalThis.Number(object.inGameHeartbeatSeconds)
        : 0,
      deprecatedPublicIp: isSet(object.deprecatedPublicIp) ? globalThis.Number(object.deprecatedPublicIp) : 0,
      rtime32ServerTime: isSet(object.rtime32ServerTime) ? globalThis.Number(object.rtime32ServerTime) : 0,
      accountFlags: isSet(object.accountFlags) ? globalThis.Number(object.accountFlags) : 0,
      cellId: isSet(object.cellId) ? globalThis.Number(object.cellId) : 0,
      emailDomain: isSet(object.emailDomain) ? globalThis.String(object.emailDomain) : "",
      steam2Ticket: isSet(object.steam2Ticket) ? Buffer.from(bytesFromBase64(object.steam2Ticket)) : Buffer.alloc(0),
      eresultExtended: isSet(object.eresultExtended) ? globalThis.Number(object.eresultExtended) : 0,
      webapiAuthenticateUserNonce: isSet(object.webapiAuthenticateUserNonce)
        ? globalThis.String(object.webapiAuthenticateUserNonce)
        : "",
      cellIdPingThreshold: isSet(object.cellIdPingThreshold) ? globalThis.Number(object.cellIdPingThreshold) : 0,
      usePics: isSet(object.usePics) ? globalThis.Boolean(object.usePics) : false,
      vanityUrl: isSet(object.vanityUrl) ? globalThis.String(object.vanityUrl) : "",
      publicIp: isSet(object.publicIp) ? CMsgIPAddress.fromJSON(object.publicIp) : undefined,
      clientSuppliedSteamid: isSet(object.clientSuppliedSteamid)
        ? globalThis.String(object.clientSuppliedSteamid)
        : "0",
      ipCountryCode: isSet(object.ipCountryCode) ? globalThis.String(object.ipCountryCode) : "",
      parentalSettings: isSet(object.parentalSettings)
        ? Buffer.from(bytesFromBase64(object.parentalSettings))
        : Buffer.alloc(0),
      parentalSettingSignature: isSet(object.parentalSettingSignature)
        ? Buffer.from(bytesFromBase64(object.parentalSettingSignature))
        : Buffer.alloc(0),
      countLoginfailuresToMigrate: isSet(object.countLoginfailuresToMigrate)
        ? globalThis.Number(object.countLoginfailuresToMigrate)
        : 0,
      countDisconnectsToMigrate: isSet(object.countDisconnectsToMigrate)
        ? globalThis.Number(object.countDisconnectsToMigrate)
        : 0,
      ogsDataReportTimeWindow: isSet(object.ogsDataReportTimeWindow)
        ? globalThis.Number(object.ogsDataReportTimeWindow)
        : 0,
      clientInstanceId: isSet(object.clientInstanceId) ? globalThis.String(object.clientInstanceId) : "0",
      forceClientUpdateCheck: isSet(object.forceClientUpdateCheck)
        ? globalThis.Boolean(object.forceClientUpdateCheck)
        : false,
    };
  },

  toJSON(message: CMsgClientLogonResponse): unknown {
    const obj: any = {};
    if (message.eresult !== undefined && message.eresult !== 2) {
      obj.eresult = Math.round(message.eresult);
    }
    if (message.outOfGameHeartbeatSeconds !== undefined && message.outOfGameHeartbeatSeconds !== 0) {
      obj.outOfGameHeartbeatSeconds = Math.round(message.outOfGameHeartbeatSeconds);
    }
    if (message.inGameHeartbeatSeconds !== undefined && message.inGameHeartbeatSeconds !== 0) {
      obj.inGameHeartbeatSeconds = Math.round(message.inGameHeartbeatSeconds);
    }
    if (message.deprecatedPublicIp !== undefined && message.deprecatedPublicIp !== 0) {
      obj.deprecatedPublicIp = Math.round(message.deprecatedPublicIp);
    }
    if (message.rtime32ServerTime !== undefined && message.rtime32ServerTime !== 0) {
      obj.rtime32ServerTime = Math.round(message.rtime32ServerTime);
    }
    if (message.accountFlags !== undefined && message.accountFlags !== 0) {
      obj.accountFlags = Math.round(message.accountFlags);
    }
    if (message.cellId !== undefined && message.cellId !== 0) {
      obj.cellId = Math.round(message.cellId);
    }
    if (message.emailDomain !== undefined && message.emailDomain !== "") {
      obj.emailDomain = message.emailDomain;
    }
    if (message.steam2Ticket !== undefined && message.steam2Ticket.length !== 0) {
      obj.steam2Ticket = base64FromBytes(message.steam2Ticket);
    }
    if (message.eresultExtended !== undefined && message.eresultExtended !== 0) {
      obj.eresultExtended = Math.round(message.eresultExtended);
    }
    if (message.webapiAuthenticateUserNonce !== undefined && message.webapiAuthenticateUserNonce !== "") {
      obj.webapiAuthenticateUserNonce = message.webapiAuthenticateUserNonce;
    }
    if (message.cellIdPingThreshold !== undefined && message.cellIdPingThreshold !== 0) {
      obj.cellIdPingThreshold = Math.round(message.cellIdPingThreshold);
    }
    if (message.usePics !== undefined && message.usePics !== false) {
      obj.usePics = message.usePics;
    }
    if (message.vanityUrl !== undefined && message.vanityUrl !== "") {
      obj.vanityUrl = message.vanityUrl;
    }
    if (message.publicIp !== undefined) {
      obj.publicIp = CMsgIPAddress.toJSON(message.publicIp);
    }
    if (message.clientSuppliedSteamid !== undefined && message.clientSuppliedSteamid !== "0") {
      obj.clientSuppliedSteamid = message.clientSuppliedSteamid;
    }
    if (message.ipCountryCode !== undefined && message.ipCountryCode !== "") {
      obj.ipCountryCode = message.ipCountryCode;
    }
    if (message.parentalSettings !== undefined && message.parentalSettings.length !== 0) {
      obj.parentalSettings = base64FromBytes(message.parentalSettings);
    }
    if (message.parentalSettingSignature !== undefined && message.parentalSettingSignature.length !== 0) {
      obj.parentalSettingSignature = base64FromBytes(message.parentalSettingSignature);
    }
    if (message.countLoginfailuresToMigrate !== undefined && message.countLoginfailuresToMigrate !== 0) {
      obj.countLoginfailuresToMigrate = Math.round(message.countLoginfailuresToMigrate);
    }
    if (message.countDisconnectsToMigrate !== undefined && message.countDisconnectsToMigrate !== 0) {
      obj.countDisconnectsToMigrate = Math.round(message.countDisconnectsToMigrate);
    }
    if (message.ogsDataReportTimeWindow !== undefined && message.ogsDataReportTimeWindow !== 0) {
      obj.ogsDataReportTimeWindow = Math.round(message.ogsDataReportTimeWindow);
    }
    if (message.clientInstanceId !== undefined && message.clientInstanceId !== "0") {
      obj.clientInstanceId = message.clientInstanceId;
    }
    if (message.forceClientUpdateCheck !== undefined && message.forceClientUpdateCheck !== false) {
      obj.forceClientUpdateCheck = message.forceClientUpdateCheck;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgClientLogonResponse>): CMsgClientLogonResponse {
    return CMsgClientLogonResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgClientLogonResponse>): CMsgClientLogonResponse {
    const message = createBaseCMsgClientLogonResponse();
    message.eresult = object.eresult ?? 2;
    message.outOfGameHeartbeatSeconds = object.outOfGameHeartbeatSeconds ?? 0;
    message.inGameHeartbeatSeconds = object.inGameHeartbeatSeconds ?? 0;
    message.deprecatedPublicIp = object.deprecatedPublicIp ?? 0;
    message.rtime32ServerTime = object.rtime32ServerTime ?? 0;
    message.accountFlags = object.accountFlags ?? 0;
    message.cellId = object.cellId ?? 0;
    message.emailDomain = object.emailDomain ?? "";
    message.steam2Ticket = object.steam2Ticket ?? Buffer.alloc(0);
    message.eresultExtended = object.eresultExtended ?? 0;
    message.webapiAuthenticateUserNonce = object.webapiAuthenticateUserNonce ?? "";
    message.cellIdPingThreshold = object.cellIdPingThreshold ?? 0;
    message.usePics = object.usePics ?? false;
    message.vanityUrl = object.vanityUrl ?? "";
    message.publicIp =
      object.publicIp !== undefined && object.publicIp !== null
        ? CMsgIPAddress.fromPartial(object.publicIp)
        : undefined;
    message.clientSuppliedSteamid = object.clientSuppliedSteamid ?? "0";
    message.ipCountryCode = object.ipCountryCode ?? "";
    message.parentalSettings = object.parentalSettings ?? Buffer.alloc(0);
    message.parentalSettingSignature = object.parentalSettingSignature ?? Buffer.alloc(0);
    message.countLoginfailuresToMigrate = object.countLoginfailuresToMigrate ?? 0;
    message.countDisconnectsToMigrate = object.countDisconnectsToMigrate ?? 0;
    message.ogsDataReportTimeWindow = object.ogsDataReportTimeWindow ?? 0;
    message.clientInstanceId = object.clientInstanceId ?? "0";
    message.forceClientUpdateCheck = object.forceClientUpdateCheck ?? false;
    return message;
  },
};

function createBaseCMsgClientRequestWebAPIAuthenticateUserNonce(): CMsgClientRequestWebAPIAuthenticateUserNonce {
  return { tokenType: -1 };
}

export const CMsgClientRequestWebAPIAuthenticateUserNonce = {
  encode(message: CMsgClientRequestWebAPIAuthenticateUserNonce, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.tokenType !== undefined && message.tokenType !== -1) {
      writer.uint32(8).int32(message.tokenType);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientRequestWebAPIAuthenticateUserNonce {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientRequestWebAPIAuthenticateUserNonce();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.tokenType = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientRequestWebAPIAuthenticateUserNonce {
    return { tokenType: isSet(object.tokenType) ? globalThis.Number(object.tokenType) : -1 };
  },

  toJSON(message: CMsgClientRequestWebAPIAuthenticateUserNonce): unknown {
    const obj: any = {};
    if (message.tokenType !== undefined && message.tokenType !== -1) {
      obj.tokenType = Math.round(message.tokenType);
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgClientRequestWebAPIAuthenticateUserNonce>,
  ): CMsgClientRequestWebAPIAuthenticateUserNonce {
    return CMsgClientRequestWebAPIAuthenticateUserNonce.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgClientRequestWebAPIAuthenticateUserNonce>,
  ): CMsgClientRequestWebAPIAuthenticateUserNonce {
    const message = createBaseCMsgClientRequestWebAPIAuthenticateUserNonce();
    message.tokenType = object.tokenType ?? -1;
    return message;
  },
};

function createBaseCMsgClientRequestWebAPIAuthenticateUserNonceResponse(): CMsgClientRequestWebAPIAuthenticateUserNonceResponse {
  return { eresult: 2, webapiAuthenticateUserNonce: "", tokenType: -1 };
}

export const CMsgClientRequestWebAPIAuthenticateUserNonceResponse = {
  encode(
    message: CMsgClientRequestWebAPIAuthenticateUserNonceResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.eresult !== undefined && message.eresult !== 2) {
      writer.uint32(8).int32(message.eresult);
    }
    if (message.webapiAuthenticateUserNonce !== undefined && message.webapiAuthenticateUserNonce !== "") {
      writer.uint32(90).string(message.webapiAuthenticateUserNonce);
    }
    if (message.tokenType !== undefined && message.tokenType !== -1) {
      writer.uint32(24).int32(message.tokenType);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientRequestWebAPIAuthenticateUserNonceResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientRequestWebAPIAuthenticateUserNonceResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.eresult = reader.int32();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.webapiAuthenticateUserNonce = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.tokenType = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientRequestWebAPIAuthenticateUserNonceResponse {
    return {
      eresult: isSet(object.eresult) ? globalThis.Number(object.eresult) : 2,
      webapiAuthenticateUserNonce: isSet(object.webapiAuthenticateUserNonce)
        ? globalThis.String(object.webapiAuthenticateUserNonce)
        : "",
      tokenType: isSet(object.tokenType) ? globalThis.Number(object.tokenType) : -1,
    };
  },

  toJSON(message: CMsgClientRequestWebAPIAuthenticateUserNonceResponse): unknown {
    const obj: any = {};
    if (message.eresult !== undefined && message.eresult !== 2) {
      obj.eresult = Math.round(message.eresult);
    }
    if (message.webapiAuthenticateUserNonce !== undefined && message.webapiAuthenticateUserNonce !== "") {
      obj.webapiAuthenticateUserNonce = message.webapiAuthenticateUserNonce;
    }
    if (message.tokenType !== undefined && message.tokenType !== -1) {
      obj.tokenType = Math.round(message.tokenType);
    }
    return obj;
  },

  create(
    base?: DeepPartial<CMsgClientRequestWebAPIAuthenticateUserNonceResponse>,
  ): CMsgClientRequestWebAPIAuthenticateUserNonceResponse {
    return CMsgClientRequestWebAPIAuthenticateUserNonceResponse.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgClientRequestWebAPIAuthenticateUserNonceResponse>,
  ): CMsgClientRequestWebAPIAuthenticateUserNonceResponse {
    const message = createBaseCMsgClientRequestWebAPIAuthenticateUserNonceResponse();
    message.eresult = object.eresult ?? 2;
    message.webapiAuthenticateUserNonce = object.webapiAuthenticateUserNonce ?? "";
    message.tokenType = object.tokenType ?? -1;
    return message;
  },
};

function createBaseCMsgClientLogOff(): CMsgClientLogOff {
  return {};
}

export const CMsgClientLogOff = {
  encode(_: CMsgClientLogOff, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientLogOff {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientLogOff();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CMsgClientLogOff {
    return {};
  },

  toJSON(_: CMsgClientLogOff): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<CMsgClientLogOff>): CMsgClientLogOff {
    return CMsgClientLogOff.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<CMsgClientLogOff>): CMsgClientLogOff {
    const message = createBaseCMsgClientLogOff();
    return message;
  },
};

function createBaseCMsgClientLoggedOff(): CMsgClientLoggedOff {
  return { eresult: 2 };
}

export const CMsgClientLoggedOff = {
  encode(message: CMsgClientLoggedOff, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.eresult !== undefined && message.eresult !== 2) {
      writer.uint32(8).int32(message.eresult);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientLoggedOff {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientLoggedOff();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.eresult = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientLoggedOff {
    return { eresult: isSet(object.eresult) ? globalThis.Number(object.eresult) : 2 };
  },

  toJSON(message: CMsgClientLoggedOff): unknown {
    const obj: any = {};
    if (message.eresult !== undefined && message.eresult !== 2) {
      obj.eresult = Math.round(message.eresult);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgClientLoggedOff>): CMsgClientLoggedOff {
    return CMsgClientLoggedOff.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgClientLoggedOff>): CMsgClientLoggedOff {
    const message = createBaseCMsgClientLoggedOff();
    message.eresult = object.eresult ?? 2;
    return message;
  },
};

function createBaseCMsgClientNewLoginKey(): CMsgClientNewLoginKey {
  return { uniqueId: 0, loginKey: "" };
}

export const CMsgClientNewLoginKey = {
  encode(message: CMsgClientNewLoginKey, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.uniqueId !== undefined && message.uniqueId !== 0) {
      writer.uint32(8).uint32(message.uniqueId);
    }
    if (message.loginKey !== undefined && message.loginKey !== "") {
      writer.uint32(18).string(message.loginKey);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientNewLoginKey {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientNewLoginKey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.uniqueId = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.loginKey = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientNewLoginKey {
    return {
      uniqueId: isSet(object.uniqueId) ? globalThis.Number(object.uniqueId) : 0,
      loginKey: isSet(object.loginKey) ? globalThis.String(object.loginKey) : "",
    };
  },

  toJSON(message: CMsgClientNewLoginKey): unknown {
    const obj: any = {};
    if (message.uniqueId !== undefined && message.uniqueId !== 0) {
      obj.uniqueId = Math.round(message.uniqueId);
    }
    if (message.loginKey !== undefined && message.loginKey !== "") {
      obj.loginKey = message.loginKey;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgClientNewLoginKey>): CMsgClientNewLoginKey {
    return CMsgClientNewLoginKey.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgClientNewLoginKey>): CMsgClientNewLoginKey {
    const message = createBaseCMsgClientNewLoginKey();
    message.uniqueId = object.uniqueId ?? 0;
    message.loginKey = object.loginKey ?? "";
    return message;
  },
};

function createBaseCMsgClientNewLoginKeyAccepted(): CMsgClientNewLoginKeyAccepted {
  return { uniqueId: 0 };
}

export const CMsgClientNewLoginKeyAccepted = {
  encode(message: CMsgClientNewLoginKeyAccepted, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.uniqueId !== undefined && message.uniqueId !== 0) {
      writer.uint32(8).uint32(message.uniqueId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientNewLoginKeyAccepted {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientNewLoginKeyAccepted();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.uniqueId = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientNewLoginKeyAccepted {
    return { uniqueId: isSet(object.uniqueId) ? globalThis.Number(object.uniqueId) : 0 };
  },

  toJSON(message: CMsgClientNewLoginKeyAccepted): unknown {
    const obj: any = {};
    if (message.uniqueId !== undefined && message.uniqueId !== 0) {
      obj.uniqueId = Math.round(message.uniqueId);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgClientNewLoginKeyAccepted>): CMsgClientNewLoginKeyAccepted {
    return CMsgClientNewLoginKeyAccepted.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgClientNewLoginKeyAccepted>): CMsgClientNewLoginKeyAccepted {
    const message = createBaseCMsgClientNewLoginKeyAccepted();
    message.uniqueId = object.uniqueId ?? 0;
    return message;
  },
};

function createBaseCMsgClientAccountInfo(): CMsgClientAccountInfo {
  return {
    personaName: "",
    ipCountry: "",
    countAuthedComputers: 0,
    accountFlags: 0,
    facebookId: "0",
    facebookName: "",
    steamguardNotifyNewmachines: false,
    steamguardMachineNameUserChosen: "",
    isPhoneVerified: false,
    twoFactorState: 0,
    isPhoneIdentifying: false,
    isPhoneNeedingReverify: false,
  };
}

export const CMsgClientAccountInfo = {
  encode(message: CMsgClientAccountInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.personaName !== undefined && message.personaName !== "") {
      writer.uint32(10).string(message.personaName);
    }
    if (message.ipCountry !== undefined && message.ipCountry !== "") {
      writer.uint32(18).string(message.ipCountry);
    }
    if (message.countAuthedComputers !== undefined && message.countAuthedComputers !== 0) {
      writer.uint32(40).int32(message.countAuthedComputers);
    }
    if (message.accountFlags !== undefined && message.accountFlags !== 0) {
      writer.uint32(56).uint32(message.accountFlags);
    }
    if (message.facebookId !== undefined && message.facebookId !== "0") {
      writer.uint32(64).uint64(message.facebookId);
    }
    if (message.facebookName !== undefined && message.facebookName !== "") {
      writer.uint32(74).string(message.facebookName);
    }
    if (message.steamguardNotifyNewmachines !== undefined && message.steamguardNotifyNewmachines !== false) {
      writer.uint32(112).bool(message.steamguardNotifyNewmachines);
    }
    if (message.steamguardMachineNameUserChosen !== undefined && message.steamguardMachineNameUserChosen !== "") {
      writer.uint32(122).string(message.steamguardMachineNameUserChosen);
    }
    if (message.isPhoneVerified !== undefined && message.isPhoneVerified !== false) {
      writer.uint32(128).bool(message.isPhoneVerified);
    }
    if (message.twoFactorState !== undefined && message.twoFactorState !== 0) {
      writer.uint32(136).uint32(message.twoFactorState);
    }
    if (message.isPhoneIdentifying !== undefined && message.isPhoneIdentifying !== false) {
      writer.uint32(144).bool(message.isPhoneIdentifying);
    }
    if (message.isPhoneNeedingReverify !== undefined && message.isPhoneNeedingReverify !== false) {
      writer.uint32(152).bool(message.isPhoneNeedingReverify);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientAccountInfo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientAccountInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.personaName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.ipCountry = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.countAuthedComputers = reader.int32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.accountFlags = reader.uint32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.facebookId = longToString(reader.uint64() as Long);
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.facebookName = reader.string();
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.steamguardNotifyNewmachines = reader.bool();
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.steamguardMachineNameUserChosen = reader.string();
          continue;
        case 16:
          if (tag !== 128) {
            break;
          }

          message.isPhoneVerified = reader.bool();
          continue;
        case 17:
          if (tag !== 136) {
            break;
          }

          message.twoFactorState = reader.uint32();
          continue;
        case 18:
          if (tag !== 144) {
            break;
          }

          message.isPhoneIdentifying = reader.bool();
          continue;
        case 19:
          if (tag !== 152) {
            break;
          }

          message.isPhoneNeedingReverify = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientAccountInfo {
    return {
      personaName: isSet(object.personaName) ? globalThis.String(object.personaName) : "",
      ipCountry: isSet(object.ipCountry) ? globalThis.String(object.ipCountry) : "",
      countAuthedComputers: isSet(object.countAuthedComputers) ? globalThis.Number(object.countAuthedComputers) : 0,
      accountFlags: isSet(object.accountFlags) ? globalThis.Number(object.accountFlags) : 0,
      facebookId: isSet(object.facebookId) ? globalThis.String(object.facebookId) : "0",
      facebookName: isSet(object.facebookName) ? globalThis.String(object.facebookName) : "",
      steamguardNotifyNewmachines: isSet(object.steamguardNotifyNewmachines)
        ? globalThis.Boolean(object.steamguardNotifyNewmachines)
        : false,
      steamguardMachineNameUserChosen: isSet(object.steamguardMachineNameUserChosen)
        ? globalThis.String(object.steamguardMachineNameUserChosen)
        : "",
      isPhoneVerified: isSet(object.isPhoneVerified) ? globalThis.Boolean(object.isPhoneVerified) : false,
      twoFactorState: isSet(object.twoFactorState) ? globalThis.Number(object.twoFactorState) : 0,
      isPhoneIdentifying: isSet(object.isPhoneIdentifying) ? globalThis.Boolean(object.isPhoneIdentifying) : false,
      isPhoneNeedingReverify: isSet(object.isPhoneNeedingReverify)
        ? globalThis.Boolean(object.isPhoneNeedingReverify)
        : false,
    };
  },

  toJSON(message: CMsgClientAccountInfo): unknown {
    const obj: any = {};
    if (message.personaName !== undefined && message.personaName !== "") {
      obj.personaName = message.personaName;
    }
    if (message.ipCountry !== undefined && message.ipCountry !== "") {
      obj.ipCountry = message.ipCountry;
    }
    if (message.countAuthedComputers !== undefined && message.countAuthedComputers !== 0) {
      obj.countAuthedComputers = Math.round(message.countAuthedComputers);
    }
    if (message.accountFlags !== undefined && message.accountFlags !== 0) {
      obj.accountFlags = Math.round(message.accountFlags);
    }
    if (message.facebookId !== undefined && message.facebookId !== "0") {
      obj.facebookId = message.facebookId;
    }
    if (message.facebookName !== undefined && message.facebookName !== "") {
      obj.facebookName = message.facebookName;
    }
    if (message.steamguardNotifyNewmachines !== undefined && message.steamguardNotifyNewmachines !== false) {
      obj.steamguardNotifyNewmachines = message.steamguardNotifyNewmachines;
    }
    if (message.steamguardMachineNameUserChosen !== undefined && message.steamguardMachineNameUserChosen !== "") {
      obj.steamguardMachineNameUserChosen = message.steamguardMachineNameUserChosen;
    }
    if (message.isPhoneVerified !== undefined && message.isPhoneVerified !== false) {
      obj.isPhoneVerified = message.isPhoneVerified;
    }
    if (message.twoFactorState !== undefined && message.twoFactorState !== 0) {
      obj.twoFactorState = Math.round(message.twoFactorState);
    }
    if (message.isPhoneIdentifying !== undefined && message.isPhoneIdentifying !== false) {
      obj.isPhoneIdentifying = message.isPhoneIdentifying;
    }
    if (message.isPhoneNeedingReverify !== undefined && message.isPhoneNeedingReverify !== false) {
      obj.isPhoneNeedingReverify = message.isPhoneNeedingReverify;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgClientAccountInfo>): CMsgClientAccountInfo {
    return CMsgClientAccountInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgClientAccountInfo>): CMsgClientAccountInfo {
    const message = createBaseCMsgClientAccountInfo();
    message.personaName = object.personaName ?? "";
    message.ipCountry = object.ipCountry ?? "";
    message.countAuthedComputers = object.countAuthedComputers ?? 0;
    message.accountFlags = object.accountFlags ?? 0;
    message.facebookId = object.facebookId ?? "0";
    message.facebookName = object.facebookName ?? "";
    message.steamguardNotifyNewmachines = object.steamguardNotifyNewmachines ?? false;
    message.steamguardMachineNameUserChosen = object.steamguardMachineNameUserChosen ?? "";
    message.isPhoneVerified = object.isPhoneVerified ?? false;
    message.twoFactorState = object.twoFactorState ?? 0;
    message.isPhoneIdentifying = object.isPhoneIdentifying ?? false;
    message.isPhoneNeedingReverify = object.isPhoneNeedingReverify ?? false;
    return message;
  },
};

function createBaseCMsgClientChallengeRequest(): CMsgClientChallengeRequest {
  return { steamid: "0" };
}

export const CMsgClientChallengeRequest = {
  encode(message: CMsgClientChallengeRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.steamid !== undefined && message.steamid !== "0") {
      writer.uint32(9).fixed64(message.steamid);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientChallengeRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientChallengeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.steamid = longToString(reader.fixed64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientChallengeRequest {
    return { steamid: isSet(object.steamid) ? globalThis.String(object.steamid) : "0" };
  },

  toJSON(message: CMsgClientChallengeRequest): unknown {
    const obj: any = {};
    if (message.steamid !== undefined && message.steamid !== "0") {
      obj.steamid = message.steamid;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgClientChallengeRequest>): CMsgClientChallengeRequest {
    return CMsgClientChallengeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgClientChallengeRequest>): CMsgClientChallengeRequest {
    const message = createBaseCMsgClientChallengeRequest();
    message.steamid = object.steamid ?? "0";
    return message;
  },
};

function createBaseCMsgClientChallengeResponse(): CMsgClientChallengeResponse {
  return { challenge: "0" };
}

export const CMsgClientChallengeResponse = {
  encode(message: CMsgClientChallengeResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.challenge !== undefined && message.challenge !== "0") {
      writer.uint32(9).fixed64(message.challenge);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientChallengeResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientChallengeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.challenge = longToString(reader.fixed64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgClientChallengeResponse {
    return { challenge: isSet(object.challenge) ? globalThis.String(object.challenge) : "0" };
  },

  toJSON(message: CMsgClientChallengeResponse): unknown {
    const obj: any = {};
    if (message.challenge !== undefined && message.challenge !== "0") {
      obj.challenge = message.challenge;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgClientChallengeResponse>): CMsgClientChallengeResponse {
    return CMsgClientChallengeResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgClientChallengeResponse>): CMsgClientChallengeResponse {
    const message = createBaseCMsgClientChallengeResponse();
    message.challenge = object.challenge ?? "0";
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin
  ? T
  : T extends globalThis.Array<infer U>
    ? globalThis.Array<DeepPartial<U>>
    : T extends ReadonlyArray<infer U>
      ? ReadonlyArray<DeepPartial<U>>
      : T extends {}
        ? { [K in keyof T]?: DeepPartial<T[K]> }
        : Partial<T>;

function longToString(long: Long) {
  return long.toString();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

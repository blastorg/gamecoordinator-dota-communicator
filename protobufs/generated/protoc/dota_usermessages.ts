// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.176.1
//   protoc               v5.26.1
// source: dota_usermessages.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";
import {
  CDOTAMsgCoachHUDPing,
  CDOTAMsgDismissAllStatPopups,
  CDOTAMsgItemAlert,
  CDOTAMsgLocationPing,
  CDOTAMsgMapLine,
  CDOTAMsgSendStatPopup,
  CDOTAMsgWorldLine,
  EDOTAVersusScenePlayerBehavior,
  eDOTAVersusScenePlayerBehaviorFromJSON,
  eDOTAVersusScenePlayerBehaviorToJSON,
  VersusSceneChatWheel,
  VersusScenePlayActivity,
  VersusScenePlaybackRate,
} from "./dota_commonmessages";
import { CMsgDOTACombatLogEntry } from "./dota_shared_enums";
import { CEntityMsg, CMsgVector, CMsgVector2D } from "./networkbasetypes";

export enum EDotaUserMessages {
  DOTA_UM_AddUnitToSelection = 464,
  DOTA_UM_AIDebugLine = 465,
  DOTA_UM_ChatEvent = 466,
  DOTA_UM_CombatHeroPositions = 467,
  DOTA_UM_CombatLogData = 468,
  DOTA_UM_CombatLogBulkData = 470,
  DOTA_UM_CreateLinearProjectile = 471,
  DOTA_UM_DestroyLinearProjectile = 472,
  DOTA_UM_DodgeTrackingProjectiles = 473,
  DOTA_UM_GlobalLightColor = 474,
  DOTA_UM_GlobalLightDirection = 475,
  DOTA_UM_InvalidCommand = 476,
  DOTA_UM_LocationPing = 477,
  DOTA_UM_MapLine = 478,
  DOTA_UM_MiniKillCamInfo = 479,
  DOTA_UM_MinimapDebugPoint = 480,
  DOTA_UM_MinimapEvent = 481,
  DOTA_UM_NevermoreRequiem = 482,
  DOTA_UM_OverheadEvent = 483,
  DOTA_UM_SetNextAutobuyItem = 484,
  DOTA_UM_SharedCooldown = 485,
  DOTA_UM_SpectatorPlayerClick = 486,
  DOTA_UM_TutorialTipInfo = 487,
  DOTA_UM_UnitEvent = 488,
  DOTA_UM_ParticleManager = 489,
  DOTA_UM_BotChat = 490,
  DOTA_UM_HudError = 491,
  DOTA_UM_ItemPurchased = 492,
  DOTA_UM_Ping = 493,
  DOTA_UM_ItemFound = 494,
  DOTA_UM_CharacterSpeakConcept = 495,
  DOTA_UM_SwapVerify = 496,
  DOTA_UM_WorldLine = 497,
  DOTA_UM_TournamentDrop = 498,
  DOTA_UM_ItemAlert = 499,
  DOTA_UM_HalloweenDrops = 500,
  DOTA_UM_ChatWheel = 501,
  DOTA_UM_ReceivedXmasGift = 502,
  DOTA_UM_UpdateSharedContent = 503,
  DOTA_UM_TutorialRequestExp = 504,
  DOTA_UM_TutorialPingMinimap = 505,
  DOTA_UM_GamerulesStateChanged = 506,
  DOTA_UM_ShowSurvey = 507,
  DOTA_UM_TutorialFade = 508,
  DOTA_UM_AddQuestLogEntry = 509,
  DOTA_UM_SendStatPopup = 510,
  DOTA_UM_TutorialFinish = 511,
  DOTA_UM_SendRoshanPopup = 512,
  DOTA_UM_SendGenericToolTip = 513,
  DOTA_UM_SendFinalGold = 514,
  DOTA_UM_CustomMsg = 515,
  DOTA_UM_CoachHUDPing = 516,
  DOTA_UM_ClientLoadGridNav = 517,
  DOTA_UM_TE_Projectile = 518,
  DOTA_UM_TE_ProjectileLoc = 519,
  DOTA_UM_TE_DotaBloodImpact = 520,
  DOTA_UM_TE_UnitAnimation = 521,
  DOTA_UM_TE_UnitAnimationEnd = 522,
  DOTA_UM_AbilityPing = 523,
  DOTA_UM_ShowGenericPopup = 524,
  DOTA_UM_VoteStart = 525,
  DOTA_UM_VoteUpdate = 526,
  DOTA_UM_VoteEnd = 527,
  DOTA_UM_BoosterState = 528,
  DOTA_UM_WillPurchaseAlert = 529,
  DOTA_UM_TutorialMinimapPosition = 530,
  DOTA_UM_PlayerMMR = 531,
  DOTA_UM_AbilitySteal = 532,
  DOTA_UM_CourierKilledAlert = 533,
  DOTA_UM_EnemyItemAlert = 534,
  DOTA_UM_StatsMatchDetails = 535,
  DOTA_UM_MiniTaunt = 536,
  DOTA_UM_BuyBackStateAlert = 537,
  DOTA_UM_SpeechBubble = 538,
  DOTA_UM_CustomHeaderMessage = 539,
  DOTA_UM_QuickBuyAlert = 540,
  DOTA_UM_StatsHeroDetails = 541,
  DOTA_UM_PredictionResult = 542,
  DOTA_UM_ModifierAlert = 543,
  DOTA_UM_HPManaAlert = 544,
  DOTA_UM_GlyphAlert = 545,
  DOTA_UM_BeastChat = 546,
  DOTA_UM_SpectatorPlayerUnitOrders = 547,
  DOTA_UM_CustomHudElement_Create = 548,
  DOTA_UM_CustomHudElement_Modify = 549,
  DOTA_UM_CustomHudElement_Destroy = 550,
  DOTA_UM_CompendiumState = 551,
  DOTA_UM_ProjectionAbility = 552,
  DOTA_UM_ProjectionEvent = 553,
  DOTA_UM_CombatLogDataHLTV = 554,
  DOTA_UM_XPAlert = 555,
  DOTA_UM_UpdateQuestProgress = 556,
  DOTA_UM_MatchMetadata = 557,
  DOTA_UM_MatchDetails = 558,
  DOTA_UM_QuestStatus = 559,
  DOTA_UM_SuggestHeroPick = 560,
  DOTA_UM_SuggestHeroRole = 561,
  DOTA_UM_KillcamDamageTaken = 562,
  DOTA_UM_SelectPenaltyGold = 563,
  DOTA_UM_RollDiceResult = 564,
  DOTA_UM_FlipCoinResult = 565,
  DOTA_UM_RequestItemSuggestions = 566,
  DOTA_UM_TeamCaptainChanged = 567,
  DOTA_UM_SendRoshanSpectatorPhase = 568,
  DOTA_UM_ChatWheelCooldown = 569,
  DOTA_UM_DismissAllStatPopups = 570,
  DOTA_UM_TE_DestroyProjectile = 571,
  DOTA_UM_HeroRelicProgress = 572,
  DOTA_UM_AbilityDraftRequestAbility = 573,
  DOTA_UM_ItemSold = 574,
  DOTA_UM_DamageReport = 575,
  DOTA_UM_SalutePlayer = 576,
  DOTA_UM_TipAlert = 577,
  DOTA_UM_ReplaceQueryUnit = 578,
  DOTA_UM_EmptyTeleportAlert = 579,
  DOTA_UM_MarsArenaOfBloodAttack = 580,
  DOTA_UM_ESArcanaCombo = 581,
  DOTA_UM_ESArcanaComboSummary = 582,
  DOTA_UM_HighFiveLeftHanging = 583,
  DOTA_UM_HighFiveCompleted = 584,
  DOTA_UM_ShovelUnearth = 585,
  DOTA_EM_InvokerSpellCast = 586,
  DOTA_UM_RadarAlert = 587,
  DOTA_UM_AllStarEvent = 588,
  DOTA_UM_TalentTreeAlert = 589,
  DOTA_UM_QueuedOrderRemoved = 590,
  DOTA_UM_DebugChallenge = 591,
  DOTA_UM_OMArcanaCombo = 592,
  DOTA_UM_FoundNeutralItem = 593,
  DOTA_UM_OutpostCaptured = 594,
  DOTA_UM_OutpostGrantedXP = 595,
  DOTA_UM_MoveCameraToUnit = 596,
  DOTA_UM_PauseMinigameData = 597,
  DOTA_UM_VersusScene_PlayerBehavior = 598,
  DOTA_UM_QoP_ArcanaSummary = 600,
  DOTA_UM_HotPotato_Created = 601,
  DOTA_UM_HotPotato_Exploded = 602,
  DOTA_UM_WK_Arcana_Progress = 603,
  DOTA_UM_GuildChallenge_Progress = 604,
  DOTA_UM_WRArcanaProgress = 605,
  DOTA_UM_WRArcanaSummary = 606,
  DOTA_UM_EmptyItemSlotAlert = 607,
  DOTA_UM_AghsStatusAlert = 608,
  DOTA_UM_PingConfirmation = 609,
  DOTA_UM_MutedPlayers = 610,
  DOTA_UM_ContextualTip = 611,
  DOTA_UM_ChatMessage = 612,
  DOTA_UM_NeutralCampAlert = 613,
  DOTA_UM_RockPaperScissorsStarted = 614,
  DOTA_UM_RockPaperScissorsFinished = 615,
  DOTA_UM_DuelOpponentKilled = 616,
  DOTA_UM_DuelAccepted = 617,
  DOTA_UM_DuelRequested = 618,
  DOTA_UM_MuertaReleaseEvent_AssignedTargetKilled = 619,
  DOTA_UM_PlayerDraftSuggestPick = 620,
  DOTA_UM_PlayerDraftPick = 621,
  DOTA_UM_UpdateLinearProjectileCPData = 622,
  DOTA_UM_GiftPlayer = 623,
  DOTA_UM_FacetPing = 624,
  DOTA_UM_InnatePing = 625,
}

export function eDotaUserMessagesFromJSON(object: any): EDotaUserMessages {
  switch (object) {
    case 464:
    case "DOTA_UM_AddUnitToSelection":
      return EDotaUserMessages.DOTA_UM_AddUnitToSelection;
    case 465:
    case "DOTA_UM_AIDebugLine":
      return EDotaUserMessages.DOTA_UM_AIDebugLine;
    case 466:
    case "DOTA_UM_ChatEvent":
      return EDotaUserMessages.DOTA_UM_ChatEvent;
    case 467:
    case "DOTA_UM_CombatHeroPositions":
      return EDotaUserMessages.DOTA_UM_CombatHeroPositions;
    case 468:
    case "DOTA_UM_CombatLogData":
      return EDotaUserMessages.DOTA_UM_CombatLogData;
    case 470:
    case "DOTA_UM_CombatLogBulkData":
      return EDotaUserMessages.DOTA_UM_CombatLogBulkData;
    case 471:
    case "DOTA_UM_CreateLinearProjectile":
      return EDotaUserMessages.DOTA_UM_CreateLinearProjectile;
    case 472:
    case "DOTA_UM_DestroyLinearProjectile":
      return EDotaUserMessages.DOTA_UM_DestroyLinearProjectile;
    case 473:
    case "DOTA_UM_DodgeTrackingProjectiles":
      return EDotaUserMessages.DOTA_UM_DodgeTrackingProjectiles;
    case 474:
    case "DOTA_UM_GlobalLightColor":
      return EDotaUserMessages.DOTA_UM_GlobalLightColor;
    case 475:
    case "DOTA_UM_GlobalLightDirection":
      return EDotaUserMessages.DOTA_UM_GlobalLightDirection;
    case 476:
    case "DOTA_UM_InvalidCommand":
      return EDotaUserMessages.DOTA_UM_InvalidCommand;
    case 477:
    case "DOTA_UM_LocationPing":
      return EDotaUserMessages.DOTA_UM_LocationPing;
    case 478:
    case "DOTA_UM_MapLine":
      return EDotaUserMessages.DOTA_UM_MapLine;
    case 479:
    case "DOTA_UM_MiniKillCamInfo":
      return EDotaUserMessages.DOTA_UM_MiniKillCamInfo;
    case 480:
    case "DOTA_UM_MinimapDebugPoint":
      return EDotaUserMessages.DOTA_UM_MinimapDebugPoint;
    case 481:
    case "DOTA_UM_MinimapEvent":
      return EDotaUserMessages.DOTA_UM_MinimapEvent;
    case 482:
    case "DOTA_UM_NevermoreRequiem":
      return EDotaUserMessages.DOTA_UM_NevermoreRequiem;
    case 483:
    case "DOTA_UM_OverheadEvent":
      return EDotaUserMessages.DOTA_UM_OverheadEvent;
    case 484:
    case "DOTA_UM_SetNextAutobuyItem":
      return EDotaUserMessages.DOTA_UM_SetNextAutobuyItem;
    case 485:
    case "DOTA_UM_SharedCooldown":
      return EDotaUserMessages.DOTA_UM_SharedCooldown;
    case 486:
    case "DOTA_UM_SpectatorPlayerClick":
      return EDotaUserMessages.DOTA_UM_SpectatorPlayerClick;
    case 487:
    case "DOTA_UM_TutorialTipInfo":
      return EDotaUserMessages.DOTA_UM_TutorialTipInfo;
    case 488:
    case "DOTA_UM_UnitEvent":
      return EDotaUserMessages.DOTA_UM_UnitEvent;
    case 489:
    case "DOTA_UM_ParticleManager":
      return EDotaUserMessages.DOTA_UM_ParticleManager;
    case 490:
    case "DOTA_UM_BotChat":
      return EDotaUserMessages.DOTA_UM_BotChat;
    case 491:
    case "DOTA_UM_HudError":
      return EDotaUserMessages.DOTA_UM_HudError;
    case 492:
    case "DOTA_UM_ItemPurchased":
      return EDotaUserMessages.DOTA_UM_ItemPurchased;
    case 493:
    case "DOTA_UM_Ping":
      return EDotaUserMessages.DOTA_UM_Ping;
    case 494:
    case "DOTA_UM_ItemFound":
      return EDotaUserMessages.DOTA_UM_ItemFound;
    case 495:
    case "DOTA_UM_CharacterSpeakConcept":
      return EDotaUserMessages.DOTA_UM_CharacterSpeakConcept;
    case 496:
    case "DOTA_UM_SwapVerify":
      return EDotaUserMessages.DOTA_UM_SwapVerify;
    case 497:
    case "DOTA_UM_WorldLine":
      return EDotaUserMessages.DOTA_UM_WorldLine;
    case 498:
    case "DOTA_UM_TournamentDrop":
      return EDotaUserMessages.DOTA_UM_TournamentDrop;
    case 499:
    case "DOTA_UM_ItemAlert":
      return EDotaUserMessages.DOTA_UM_ItemAlert;
    case 500:
    case "DOTA_UM_HalloweenDrops":
      return EDotaUserMessages.DOTA_UM_HalloweenDrops;
    case 501:
    case "DOTA_UM_ChatWheel":
      return EDotaUserMessages.DOTA_UM_ChatWheel;
    case 502:
    case "DOTA_UM_ReceivedXmasGift":
      return EDotaUserMessages.DOTA_UM_ReceivedXmasGift;
    case 503:
    case "DOTA_UM_UpdateSharedContent":
      return EDotaUserMessages.DOTA_UM_UpdateSharedContent;
    case 504:
    case "DOTA_UM_TutorialRequestExp":
      return EDotaUserMessages.DOTA_UM_TutorialRequestExp;
    case 505:
    case "DOTA_UM_TutorialPingMinimap":
      return EDotaUserMessages.DOTA_UM_TutorialPingMinimap;
    case 506:
    case "DOTA_UM_GamerulesStateChanged":
      return EDotaUserMessages.DOTA_UM_GamerulesStateChanged;
    case 507:
    case "DOTA_UM_ShowSurvey":
      return EDotaUserMessages.DOTA_UM_ShowSurvey;
    case 508:
    case "DOTA_UM_TutorialFade":
      return EDotaUserMessages.DOTA_UM_TutorialFade;
    case 509:
    case "DOTA_UM_AddQuestLogEntry":
      return EDotaUserMessages.DOTA_UM_AddQuestLogEntry;
    case 510:
    case "DOTA_UM_SendStatPopup":
      return EDotaUserMessages.DOTA_UM_SendStatPopup;
    case 511:
    case "DOTA_UM_TutorialFinish":
      return EDotaUserMessages.DOTA_UM_TutorialFinish;
    case 512:
    case "DOTA_UM_SendRoshanPopup":
      return EDotaUserMessages.DOTA_UM_SendRoshanPopup;
    case 513:
    case "DOTA_UM_SendGenericToolTip":
      return EDotaUserMessages.DOTA_UM_SendGenericToolTip;
    case 514:
    case "DOTA_UM_SendFinalGold":
      return EDotaUserMessages.DOTA_UM_SendFinalGold;
    case 515:
    case "DOTA_UM_CustomMsg":
      return EDotaUserMessages.DOTA_UM_CustomMsg;
    case 516:
    case "DOTA_UM_CoachHUDPing":
      return EDotaUserMessages.DOTA_UM_CoachHUDPing;
    case 517:
    case "DOTA_UM_ClientLoadGridNav":
      return EDotaUserMessages.DOTA_UM_ClientLoadGridNav;
    case 518:
    case "DOTA_UM_TE_Projectile":
      return EDotaUserMessages.DOTA_UM_TE_Projectile;
    case 519:
    case "DOTA_UM_TE_ProjectileLoc":
      return EDotaUserMessages.DOTA_UM_TE_ProjectileLoc;
    case 520:
    case "DOTA_UM_TE_DotaBloodImpact":
      return EDotaUserMessages.DOTA_UM_TE_DotaBloodImpact;
    case 521:
    case "DOTA_UM_TE_UnitAnimation":
      return EDotaUserMessages.DOTA_UM_TE_UnitAnimation;
    case 522:
    case "DOTA_UM_TE_UnitAnimationEnd":
      return EDotaUserMessages.DOTA_UM_TE_UnitAnimationEnd;
    case 523:
    case "DOTA_UM_AbilityPing":
      return EDotaUserMessages.DOTA_UM_AbilityPing;
    case 524:
    case "DOTA_UM_ShowGenericPopup":
      return EDotaUserMessages.DOTA_UM_ShowGenericPopup;
    case 525:
    case "DOTA_UM_VoteStart":
      return EDotaUserMessages.DOTA_UM_VoteStart;
    case 526:
    case "DOTA_UM_VoteUpdate":
      return EDotaUserMessages.DOTA_UM_VoteUpdate;
    case 527:
    case "DOTA_UM_VoteEnd":
      return EDotaUserMessages.DOTA_UM_VoteEnd;
    case 528:
    case "DOTA_UM_BoosterState":
      return EDotaUserMessages.DOTA_UM_BoosterState;
    case 529:
    case "DOTA_UM_WillPurchaseAlert":
      return EDotaUserMessages.DOTA_UM_WillPurchaseAlert;
    case 530:
    case "DOTA_UM_TutorialMinimapPosition":
      return EDotaUserMessages.DOTA_UM_TutorialMinimapPosition;
    case 531:
    case "DOTA_UM_PlayerMMR":
      return EDotaUserMessages.DOTA_UM_PlayerMMR;
    case 532:
    case "DOTA_UM_AbilitySteal":
      return EDotaUserMessages.DOTA_UM_AbilitySteal;
    case 533:
    case "DOTA_UM_CourierKilledAlert":
      return EDotaUserMessages.DOTA_UM_CourierKilledAlert;
    case 534:
    case "DOTA_UM_EnemyItemAlert":
      return EDotaUserMessages.DOTA_UM_EnemyItemAlert;
    case 535:
    case "DOTA_UM_StatsMatchDetails":
      return EDotaUserMessages.DOTA_UM_StatsMatchDetails;
    case 536:
    case "DOTA_UM_MiniTaunt":
      return EDotaUserMessages.DOTA_UM_MiniTaunt;
    case 537:
    case "DOTA_UM_BuyBackStateAlert":
      return EDotaUserMessages.DOTA_UM_BuyBackStateAlert;
    case 538:
    case "DOTA_UM_SpeechBubble":
      return EDotaUserMessages.DOTA_UM_SpeechBubble;
    case 539:
    case "DOTA_UM_CustomHeaderMessage":
      return EDotaUserMessages.DOTA_UM_CustomHeaderMessage;
    case 540:
    case "DOTA_UM_QuickBuyAlert":
      return EDotaUserMessages.DOTA_UM_QuickBuyAlert;
    case 541:
    case "DOTA_UM_StatsHeroDetails":
      return EDotaUserMessages.DOTA_UM_StatsHeroDetails;
    case 542:
    case "DOTA_UM_PredictionResult":
      return EDotaUserMessages.DOTA_UM_PredictionResult;
    case 543:
    case "DOTA_UM_ModifierAlert":
      return EDotaUserMessages.DOTA_UM_ModifierAlert;
    case 544:
    case "DOTA_UM_HPManaAlert":
      return EDotaUserMessages.DOTA_UM_HPManaAlert;
    case 545:
    case "DOTA_UM_GlyphAlert":
      return EDotaUserMessages.DOTA_UM_GlyphAlert;
    case 546:
    case "DOTA_UM_BeastChat":
      return EDotaUserMessages.DOTA_UM_BeastChat;
    case 547:
    case "DOTA_UM_SpectatorPlayerUnitOrders":
      return EDotaUserMessages.DOTA_UM_SpectatorPlayerUnitOrders;
    case 548:
    case "DOTA_UM_CustomHudElement_Create":
      return EDotaUserMessages.DOTA_UM_CustomHudElement_Create;
    case 549:
    case "DOTA_UM_CustomHudElement_Modify":
      return EDotaUserMessages.DOTA_UM_CustomHudElement_Modify;
    case 550:
    case "DOTA_UM_CustomHudElement_Destroy":
      return EDotaUserMessages.DOTA_UM_CustomHudElement_Destroy;
    case 551:
    case "DOTA_UM_CompendiumState":
      return EDotaUserMessages.DOTA_UM_CompendiumState;
    case 552:
    case "DOTA_UM_ProjectionAbility":
      return EDotaUserMessages.DOTA_UM_ProjectionAbility;
    case 553:
    case "DOTA_UM_ProjectionEvent":
      return EDotaUserMessages.DOTA_UM_ProjectionEvent;
    case 554:
    case "DOTA_UM_CombatLogDataHLTV":
      return EDotaUserMessages.DOTA_UM_CombatLogDataHLTV;
    case 555:
    case "DOTA_UM_XPAlert":
      return EDotaUserMessages.DOTA_UM_XPAlert;
    case 556:
    case "DOTA_UM_UpdateQuestProgress":
      return EDotaUserMessages.DOTA_UM_UpdateQuestProgress;
    case 557:
    case "DOTA_UM_MatchMetadata":
      return EDotaUserMessages.DOTA_UM_MatchMetadata;
    case 558:
    case "DOTA_UM_MatchDetails":
      return EDotaUserMessages.DOTA_UM_MatchDetails;
    case 559:
    case "DOTA_UM_QuestStatus":
      return EDotaUserMessages.DOTA_UM_QuestStatus;
    case 560:
    case "DOTA_UM_SuggestHeroPick":
      return EDotaUserMessages.DOTA_UM_SuggestHeroPick;
    case 561:
    case "DOTA_UM_SuggestHeroRole":
      return EDotaUserMessages.DOTA_UM_SuggestHeroRole;
    case 562:
    case "DOTA_UM_KillcamDamageTaken":
      return EDotaUserMessages.DOTA_UM_KillcamDamageTaken;
    case 563:
    case "DOTA_UM_SelectPenaltyGold":
      return EDotaUserMessages.DOTA_UM_SelectPenaltyGold;
    case 564:
    case "DOTA_UM_RollDiceResult":
      return EDotaUserMessages.DOTA_UM_RollDiceResult;
    case 565:
    case "DOTA_UM_FlipCoinResult":
      return EDotaUserMessages.DOTA_UM_FlipCoinResult;
    case 566:
    case "DOTA_UM_RequestItemSuggestions":
      return EDotaUserMessages.DOTA_UM_RequestItemSuggestions;
    case 567:
    case "DOTA_UM_TeamCaptainChanged":
      return EDotaUserMessages.DOTA_UM_TeamCaptainChanged;
    case 568:
    case "DOTA_UM_SendRoshanSpectatorPhase":
      return EDotaUserMessages.DOTA_UM_SendRoshanSpectatorPhase;
    case 569:
    case "DOTA_UM_ChatWheelCooldown":
      return EDotaUserMessages.DOTA_UM_ChatWheelCooldown;
    case 570:
    case "DOTA_UM_DismissAllStatPopups":
      return EDotaUserMessages.DOTA_UM_DismissAllStatPopups;
    case 571:
    case "DOTA_UM_TE_DestroyProjectile":
      return EDotaUserMessages.DOTA_UM_TE_DestroyProjectile;
    case 572:
    case "DOTA_UM_HeroRelicProgress":
      return EDotaUserMessages.DOTA_UM_HeroRelicProgress;
    case 573:
    case "DOTA_UM_AbilityDraftRequestAbility":
      return EDotaUserMessages.DOTA_UM_AbilityDraftRequestAbility;
    case 574:
    case "DOTA_UM_ItemSold":
      return EDotaUserMessages.DOTA_UM_ItemSold;
    case 575:
    case "DOTA_UM_DamageReport":
      return EDotaUserMessages.DOTA_UM_DamageReport;
    case 576:
    case "DOTA_UM_SalutePlayer":
      return EDotaUserMessages.DOTA_UM_SalutePlayer;
    case 577:
    case "DOTA_UM_TipAlert":
      return EDotaUserMessages.DOTA_UM_TipAlert;
    case 578:
    case "DOTA_UM_ReplaceQueryUnit":
      return EDotaUserMessages.DOTA_UM_ReplaceQueryUnit;
    case 579:
    case "DOTA_UM_EmptyTeleportAlert":
      return EDotaUserMessages.DOTA_UM_EmptyTeleportAlert;
    case 580:
    case "DOTA_UM_MarsArenaOfBloodAttack":
      return EDotaUserMessages.DOTA_UM_MarsArenaOfBloodAttack;
    case 581:
    case "DOTA_UM_ESArcanaCombo":
      return EDotaUserMessages.DOTA_UM_ESArcanaCombo;
    case 582:
    case "DOTA_UM_ESArcanaComboSummary":
      return EDotaUserMessages.DOTA_UM_ESArcanaComboSummary;
    case 583:
    case "DOTA_UM_HighFiveLeftHanging":
      return EDotaUserMessages.DOTA_UM_HighFiveLeftHanging;
    case 584:
    case "DOTA_UM_HighFiveCompleted":
      return EDotaUserMessages.DOTA_UM_HighFiveCompleted;
    case 585:
    case "DOTA_UM_ShovelUnearth":
      return EDotaUserMessages.DOTA_UM_ShovelUnearth;
    case 586:
    case "DOTA_EM_InvokerSpellCast":
      return EDotaUserMessages.DOTA_EM_InvokerSpellCast;
    case 587:
    case "DOTA_UM_RadarAlert":
      return EDotaUserMessages.DOTA_UM_RadarAlert;
    case 588:
    case "DOTA_UM_AllStarEvent":
      return EDotaUserMessages.DOTA_UM_AllStarEvent;
    case 589:
    case "DOTA_UM_TalentTreeAlert":
      return EDotaUserMessages.DOTA_UM_TalentTreeAlert;
    case 590:
    case "DOTA_UM_QueuedOrderRemoved":
      return EDotaUserMessages.DOTA_UM_QueuedOrderRemoved;
    case 591:
    case "DOTA_UM_DebugChallenge":
      return EDotaUserMessages.DOTA_UM_DebugChallenge;
    case 592:
    case "DOTA_UM_OMArcanaCombo":
      return EDotaUserMessages.DOTA_UM_OMArcanaCombo;
    case 593:
    case "DOTA_UM_FoundNeutralItem":
      return EDotaUserMessages.DOTA_UM_FoundNeutralItem;
    case 594:
    case "DOTA_UM_OutpostCaptured":
      return EDotaUserMessages.DOTA_UM_OutpostCaptured;
    case 595:
    case "DOTA_UM_OutpostGrantedXP":
      return EDotaUserMessages.DOTA_UM_OutpostGrantedXP;
    case 596:
    case "DOTA_UM_MoveCameraToUnit":
      return EDotaUserMessages.DOTA_UM_MoveCameraToUnit;
    case 597:
    case "DOTA_UM_PauseMinigameData":
      return EDotaUserMessages.DOTA_UM_PauseMinigameData;
    case 598:
    case "DOTA_UM_VersusScene_PlayerBehavior":
      return EDotaUserMessages.DOTA_UM_VersusScene_PlayerBehavior;
    case 600:
    case "DOTA_UM_QoP_ArcanaSummary":
      return EDotaUserMessages.DOTA_UM_QoP_ArcanaSummary;
    case 601:
    case "DOTA_UM_HotPotato_Created":
      return EDotaUserMessages.DOTA_UM_HotPotato_Created;
    case 602:
    case "DOTA_UM_HotPotato_Exploded":
      return EDotaUserMessages.DOTA_UM_HotPotato_Exploded;
    case 603:
    case "DOTA_UM_WK_Arcana_Progress":
      return EDotaUserMessages.DOTA_UM_WK_Arcana_Progress;
    case 604:
    case "DOTA_UM_GuildChallenge_Progress":
      return EDotaUserMessages.DOTA_UM_GuildChallenge_Progress;
    case 605:
    case "DOTA_UM_WRArcanaProgress":
      return EDotaUserMessages.DOTA_UM_WRArcanaProgress;
    case 606:
    case "DOTA_UM_WRArcanaSummary":
      return EDotaUserMessages.DOTA_UM_WRArcanaSummary;
    case 607:
    case "DOTA_UM_EmptyItemSlotAlert":
      return EDotaUserMessages.DOTA_UM_EmptyItemSlotAlert;
    case 608:
    case "DOTA_UM_AghsStatusAlert":
      return EDotaUserMessages.DOTA_UM_AghsStatusAlert;
    case 609:
    case "DOTA_UM_PingConfirmation":
      return EDotaUserMessages.DOTA_UM_PingConfirmation;
    case 610:
    case "DOTA_UM_MutedPlayers":
      return EDotaUserMessages.DOTA_UM_MutedPlayers;
    case 611:
    case "DOTA_UM_ContextualTip":
      return EDotaUserMessages.DOTA_UM_ContextualTip;
    case 612:
    case "DOTA_UM_ChatMessage":
      return EDotaUserMessages.DOTA_UM_ChatMessage;
    case 613:
    case "DOTA_UM_NeutralCampAlert":
      return EDotaUserMessages.DOTA_UM_NeutralCampAlert;
    case 614:
    case "DOTA_UM_RockPaperScissorsStarted":
      return EDotaUserMessages.DOTA_UM_RockPaperScissorsStarted;
    case 615:
    case "DOTA_UM_RockPaperScissorsFinished":
      return EDotaUserMessages.DOTA_UM_RockPaperScissorsFinished;
    case 616:
    case "DOTA_UM_DuelOpponentKilled":
      return EDotaUserMessages.DOTA_UM_DuelOpponentKilled;
    case 617:
    case "DOTA_UM_DuelAccepted":
      return EDotaUserMessages.DOTA_UM_DuelAccepted;
    case 618:
    case "DOTA_UM_DuelRequested":
      return EDotaUserMessages.DOTA_UM_DuelRequested;
    case 619:
    case "DOTA_UM_MuertaReleaseEvent_AssignedTargetKilled":
      return EDotaUserMessages.DOTA_UM_MuertaReleaseEvent_AssignedTargetKilled;
    case 620:
    case "DOTA_UM_PlayerDraftSuggestPick":
      return EDotaUserMessages.DOTA_UM_PlayerDraftSuggestPick;
    case 621:
    case "DOTA_UM_PlayerDraftPick":
      return EDotaUserMessages.DOTA_UM_PlayerDraftPick;
    case 622:
    case "DOTA_UM_UpdateLinearProjectileCPData":
      return EDotaUserMessages.DOTA_UM_UpdateLinearProjectileCPData;
    case 623:
    case "DOTA_UM_GiftPlayer":
      return EDotaUserMessages.DOTA_UM_GiftPlayer;
    case 624:
    case "DOTA_UM_FacetPing":
      return EDotaUserMessages.DOTA_UM_FacetPing;
    case 625:
    case "DOTA_UM_InnatePing":
      return EDotaUserMessages.DOTA_UM_InnatePing;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum EDotaUserMessages");
  }
}

export function eDotaUserMessagesToJSON(object: EDotaUserMessages): string {
  switch (object) {
    case EDotaUserMessages.DOTA_UM_AddUnitToSelection:
      return "DOTA_UM_AddUnitToSelection";
    case EDotaUserMessages.DOTA_UM_AIDebugLine:
      return "DOTA_UM_AIDebugLine";
    case EDotaUserMessages.DOTA_UM_ChatEvent:
      return "DOTA_UM_ChatEvent";
    case EDotaUserMessages.DOTA_UM_CombatHeroPositions:
      return "DOTA_UM_CombatHeroPositions";
    case EDotaUserMessages.DOTA_UM_CombatLogData:
      return "DOTA_UM_CombatLogData";
    case EDotaUserMessages.DOTA_UM_CombatLogBulkData:
      return "DOTA_UM_CombatLogBulkData";
    case EDotaUserMessages.DOTA_UM_CreateLinearProjectile:
      return "DOTA_UM_CreateLinearProjectile";
    case EDotaUserMessages.DOTA_UM_DestroyLinearProjectile:
      return "DOTA_UM_DestroyLinearProjectile";
    case EDotaUserMessages.DOTA_UM_DodgeTrackingProjectiles:
      return "DOTA_UM_DodgeTrackingProjectiles";
    case EDotaUserMessages.DOTA_UM_GlobalLightColor:
      return "DOTA_UM_GlobalLightColor";
    case EDotaUserMessages.DOTA_UM_GlobalLightDirection:
      return "DOTA_UM_GlobalLightDirection";
    case EDotaUserMessages.DOTA_UM_InvalidCommand:
      return "DOTA_UM_InvalidCommand";
    case EDotaUserMessages.DOTA_UM_LocationPing:
      return "DOTA_UM_LocationPing";
    case EDotaUserMessages.DOTA_UM_MapLine:
      return "DOTA_UM_MapLine";
    case EDotaUserMessages.DOTA_UM_MiniKillCamInfo:
      return "DOTA_UM_MiniKillCamInfo";
    case EDotaUserMessages.DOTA_UM_MinimapDebugPoint:
      return "DOTA_UM_MinimapDebugPoint";
    case EDotaUserMessages.DOTA_UM_MinimapEvent:
      return "DOTA_UM_MinimapEvent";
    case EDotaUserMessages.DOTA_UM_NevermoreRequiem:
      return "DOTA_UM_NevermoreRequiem";
    case EDotaUserMessages.DOTA_UM_OverheadEvent:
      return "DOTA_UM_OverheadEvent";
    case EDotaUserMessages.DOTA_UM_SetNextAutobuyItem:
      return "DOTA_UM_SetNextAutobuyItem";
    case EDotaUserMessages.DOTA_UM_SharedCooldown:
      return "DOTA_UM_SharedCooldown";
    case EDotaUserMessages.DOTA_UM_SpectatorPlayerClick:
      return "DOTA_UM_SpectatorPlayerClick";
    case EDotaUserMessages.DOTA_UM_TutorialTipInfo:
      return "DOTA_UM_TutorialTipInfo";
    case EDotaUserMessages.DOTA_UM_UnitEvent:
      return "DOTA_UM_UnitEvent";
    case EDotaUserMessages.DOTA_UM_ParticleManager:
      return "DOTA_UM_ParticleManager";
    case EDotaUserMessages.DOTA_UM_BotChat:
      return "DOTA_UM_BotChat";
    case EDotaUserMessages.DOTA_UM_HudError:
      return "DOTA_UM_HudError";
    case EDotaUserMessages.DOTA_UM_ItemPurchased:
      return "DOTA_UM_ItemPurchased";
    case EDotaUserMessages.DOTA_UM_Ping:
      return "DOTA_UM_Ping";
    case EDotaUserMessages.DOTA_UM_ItemFound:
      return "DOTA_UM_ItemFound";
    case EDotaUserMessages.DOTA_UM_CharacterSpeakConcept:
      return "DOTA_UM_CharacterSpeakConcept";
    case EDotaUserMessages.DOTA_UM_SwapVerify:
      return "DOTA_UM_SwapVerify";
    case EDotaUserMessages.DOTA_UM_WorldLine:
      return "DOTA_UM_WorldLine";
    case EDotaUserMessages.DOTA_UM_TournamentDrop:
      return "DOTA_UM_TournamentDrop";
    case EDotaUserMessages.DOTA_UM_ItemAlert:
      return "DOTA_UM_ItemAlert";
    case EDotaUserMessages.DOTA_UM_HalloweenDrops:
      return "DOTA_UM_HalloweenDrops";
    case EDotaUserMessages.DOTA_UM_ChatWheel:
      return "DOTA_UM_ChatWheel";
    case EDotaUserMessages.DOTA_UM_ReceivedXmasGift:
      return "DOTA_UM_ReceivedXmasGift";
    case EDotaUserMessages.DOTA_UM_UpdateSharedContent:
      return "DOTA_UM_UpdateSharedContent";
    case EDotaUserMessages.DOTA_UM_TutorialRequestExp:
      return "DOTA_UM_TutorialRequestExp";
    case EDotaUserMessages.DOTA_UM_TutorialPingMinimap:
      return "DOTA_UM_TutorialPingMinimap";
    case EDotaUserMessages.DOTA_UM_GamerulesStateChanged:
      return "DOTA_UM_GamerulesStateChanged";
    case EDotaUserMessages.DOTA_UM_ShowSurvey:
      return "DOTA_UM_ShowSurvey";
    case EDotaUserMessages.DOTA_UM_TutorialFade:
      return "DOTA_UM_TutorialFade";
    case EDotaUserMessages.DOTA_UM_AddQuestLogEntry:
      return "DOTA_UM_AddQuestLogEntry";
    case EDotaUserMessages.DOTA_UM_SendStatPopup:
      return "DOTA_UM_SendStatPopup";
    case EDotaUserMessages.DOTA_UM_TutorialFinish:
      return "DOTA_UM_TutorialFinish";
    case EDotaUserMessages.DOTA_UM_SendRoshanPopup:
      return "DOTA_UM_SendRoshanPopup";
    case EDotaUserMessages.DOTA_UM_SendGenericToolTip:
      return "DOTA_UM_SendGenericToolTip";
    case EDotaUserMessages.DOTA_UM_SendFinalGold:
      return "DOTA_UM_SendFinalGold";
    case EDotaUserMessages.DOTA_UM_CustomMsg:
      return "DOTA_UM_CustomMsg";
    case EDotaUserMessages.DOTA_UM_CoachHUDPing:
      return "DOTA_UM_CoachHUDPing";
    case EDotaUserMessages.DOTA_UM_ClientLoadGridNav:
      return "DOTA_UM_ClientLoadGridNav";
    case EDotaUserMessages.DOTA_UM_TE_Projectile:
      return "DOTA_UM_TE_Projectile";
    case EDotaUserMessages.DOTA_UM_TE_ProjectileLoc:
      return "DOTA_UM_TE_ProjectileLoc";
    case EDotaUserMessages.DOTA_UM_TE_DotaBloodImpact:
      return "DOTA_UM_TE_DotaBloodImpact";
    case EDotaUserMessages.DOTA_UM_TE_UnitAnimation:
      return "DOTA_UM_TE_UnitAnimation";
    case EDotaUserMessages.DOTA_UM_TE_UnitAnimationEnd:
      return "DOTA_UM_TE_UnitAnimationEnd";
    case EDotaUserMessages.DOTA_UM_AbilityPing:
      return "DOTA_UM_AbilityPing";
    case EDotaUserMessages.DOTA_UM_ShowGenericPopup:
      return "DOTA_UM_ShowGenericPopup";
    case EDotaUserMessages.DOTA_UM_VoteStart:
      return "DOTA_UM_VoteStart";
    case EDotaUserMessages.DOTA_UM_VoteUpdate:
      return "DOTA_UM_VoteUpdate";
    case EDotaUserMessages.DOTA_UM_VoteEnd:
      return "DOTA_UM_VoteEnd";
    case EDotaUserMessages.DOTA_UM_BoosterState:
      return "DOTA_UM_BoosterState";
    case EDotaUserMessages.DOTA_UM_WillPurchaseAlert:
      return "DOTA_UM_WillPurchaseAlert";
    case EDotaUserMessages.DOTA_UM_TutorialMinimapPosition:
      return "DOTA_UM_TutorialMinimapPosition";
    case EDotaUserMessages.DOTA_UM_PlayerMMR:
      return "DOTA_UM_PlayerMMR";
    case EDotaUserMessages.DOTA_UM_AbilitySteal:
      return "DOTA_UM_AbilitySteal";
    case EDotaUserMessages.DOTA_UM_CourierKilledAlert:
      return "DOTA_UM_CourierKilledAlert";
    case EDotaUserMessages.DOTA_UM_EnemyItemAlert:
      return "DOTA_UM_EnemyItemAlert";
    case EDotaUserMessages.DOTA_UM_StatsMatchDetails:
      return "DOTA_UM_StatsMatchDetails";
    case EDotaUserMessages.DOTA_UM_MiniTaunt:
      return "DOTA_UM_MiniTaunt";
    case EDotaUserMessages.DOTA_UM_BuyBackStateAlert:
      return "DOTA_UM_BuyBackStateAlert";
    case EDotaUserMessages.DOTA_UM_SpeechBubble:
      return "DOTA_UM_SpeechBubble";
    case EDotaUserMessages.DOTA_UM_CustomHeaderMessage:
      return "DOTA_UM_CustomHeaderMessage";
    case EDotaUserMessages.DOTA_UM_QuickBuyAlert:
      return "DOTA_UM_QuickBuyAlert";
    case EDotaUserMessages.DOTA_UM_StatsHeroDetails:
      return "DOTA_UM_StatsHeroDetails";
    case EDotaUserMessages.DOTA_UM_PredictionResult:
      return "DOTA_UM_PredictionResult";
    case EDotaUserMessages.DOTA_UM_ModifierAlert:
      return "DOTA_UM_ModifierAlert";
    case EDotaUserMessages.DOTA_UM_HPManaAlert:
      return "DOTA_UM_HPManaAlert";
    case EDotaUserMessages.DOTA_UM_GlyphAlert:
      return "DOTA_UM_GlyphAlert";
    case EDotaUserMessages.DOTA_UM_BeastChat:
      return "DOTA_UM_BeastChat";
    case EDotaUserMessages.DOTA_UM_SpectatorPlayerUnitOrders:
      return "DOTA_UM_SpectatorPlayerUnitOrders";
    case EDotaUserMessages.DOTA_UM_CustomHudElement_Create:
      return "DOTA_UM_CustomHudElement_Create";
    case EDotaUserMessages.DOTA_UM_CustomHudElement_Modify:
      return "DOTA_UM_CustomHudElement_Modify";
    case EDotaUserMessages.DOTA_UM_CustomHudElement_Destroy:
      return "DOTA_UM_CustomHudElement_Destroy";
    case EDotaUserMessages.DOTA_UM_CompendiumState:
      return "DOTA_UM_CompendiumState";
    case EDotaUserMessages.DOTA_UM_ProjectionAbility:
      return "DOTA_UM_ProjectionAbility";
    case EDotaUserMessages.DOTA_UM_ProjectionEvent:
      return "DOTA_UM_ProjectionEvent";
    case EDotaUserMessages.DOTA_UM_CombatLogDataHLTV:
      return "DOTA_UM_CombatLogDataHLTV";
    case EDotaUserMessages.DOTA_UM_XPAlert:
      return "DOTA_UM_XPAlert";
    case EDotaUserMessages.DOTA_UM_UpdateQuestProgress:
      return "DOTA_UM_UpdateQuestProgress";
    case EDotaUserMessages.DOTA_UM_MatchMetadata:
      return "DOTA_UM_MatchMetadata";
    case EDotaUserMessages.DOTA_UM_MatchDetails:
      return "DOTA_UM_MatchDetails";
    case EDotaUserMessages.DOTA_UM_QuestStatus:
      return "DOTA_UM_QuestStatus";
    case EDotaUserMessages.DOTA_UM_SuggestHeroPick:
      return "DOTA_UM_SuggestHeroPick";
    case EDotaUserMessages.DOTA_UM_SuggestHeroRole:
      return "DOTA_UM_SuggestHeroRole";
    case EDotaUserMessages.DOTA_UM_KillcamDamageTaken:
      return "DOTA_UM_KillcamDamageTaken";
    case EDotaUserMessages.DOTA_UM_SelectPenaltyGold:
      return "DOTA_UM_SelectPenaltyGold";
    case EDotaUserMessages.DOTA_UM_RollDiceResult:
      return "DOTA_UM_RollDiceResult";
    case EDotaUserMessages.DOTA_UM_FlipCoinResult:
      return "DOTA_UM_FlipCoinResult";
    case EDotaUserMessages.DOTA_UM_RequestItemSuggestions:
      return "DOTA_UM_RequestItemSuggestions";
    case EDotaUserMessages.DOTA_UM_TeamCaptainChanged:
      return "DOTA_UM_TeamCaptainChanged";
    case EDotaUserMessages.DOTA_UM_SendRoshanSpectatorPhase:
      return "DOTA_UM_SendRoshanSpectatorPhase";
    case EDotaUserMessages.DOTA_UM_ChatWheelCooldown:
      return "DOTA_UM_ChatWheelCooldown";
    case EDotaUserMessages.DOTA_UM_DismissAllStatPopups:
      return "DOTA_UM_DismissAllStatPopups";
    case EDotaUserMessages.DOTA_UM_TE_DestroyProjectile:
      return "DOTA_UM_TE_DestroyProjectile";
    case EDotaUserMessages.DOTA_UM_HeroRelicProgress:
      return "DOTA_UM_HeroRelicProgress";
    case EDotaUserMessages.DOTA_UM_AbilityDraftRequestAbility:
      return "DOTA_UM_AbilityDraftRequestAbility";
    case EDotaUserMessages.DOTA_UM_ItemSold:
      return "DOTA_UM_ItemSold";
    case EDotaUserMessages.DOTA_UM_DamageReport:
      return "DOTA_UM_DamageReport";
    case EDotaUserMessages.DOTA_UM_SalutePlayer:
      return "DOTA_UM_SalutePlayer";
    case EDotaUserMessages.DOTA_UM_TipAlert:
      return "DOTA_UM_TipAlert";
    case EDotaUserMessages.DOTA_UM_ReplaceQueryUnit:
      return "DOTA_UM_ReplaceQueryUnit";
    case EDotaUserMessages.DOTA_UM_EmptyTeleportAlert:
      return "DOTA_UM_EmptyTeleportAlert";
    case EDotaUserMessages.DOTA_UM_MarsArenaOfBloodAttack:
      return "DOTA_UM_MarsArenaOfBloodAttack";
    case EDotaUserMessages.DOTA_UM_ESArcanaCombo:
      return "DOTA_UM_ESArcanaCombo";
    case EDotaUserMessages.DOTA_UM_ESArcanaComboSummary:
      return "DOTA_UM_ESArcanaComboSummary";
    case EDotaUserMessages.DOTA_UM_HighFiveLeftHanging:
      return "DOTA_UM_HighFiveLeftHanging";
    case EDotaUserMessages.DOTA_UM_HighFiveCompleted:
      return "DOTA_UM_HighFiveCompleted";
    case EDotaUserMessages.DOTA_UM_ShovelUnearth:
      return "DOTA_UM_ShovelUnearth";
    case EDotaUserMessages.DOTA_EM_InvokerSpellCast:
      return "DOTA_EM_InvokerSpellCast";
    case EDotaUserMessages.DOTA_UM_RadarAlert:
      return "DOTA_UM_RadarAlert";
    case EDotaUserMessages.DOTA_UM_AllStarEvent:
      return "DOTA_UM_AllStarEvent";
    case EDotaUserMessages.DOTA_UM_TalentTreeAlert:
      return "DOTA_UM_TalentTreeAlert";
    case EDotaUserMessages.DOTA_UM_QueuedOrderRemoved:
      return "DOTA_UM_QueuedOrderRemoved";
    case EDotaUserMessages.DOTA_UM_DebugChallenge:
      return "DOTA_UM_DebugChallenge";
    case EDotaUserMessages.DOTA_UM_OMArcanaCombo:
      return "DOTA_UM_OMArcanaCombo";
    case EDotaUserMessages.DOTA_UM_FoundNeutralItem:
      return "DOTA_UM_FoundNeutralItem";
    case EDotaUserMessages.DOTA_UM_OutpostCaptured:
      return "DOTA_UM_OutpostCaptured";
    case EDotaUserMessages.DOTA_UM_OutpostGrantedXP:
      return "DOTA_UM_OutpostGrantedXP";
    case EDotaUserMessages.DOTA_UM_MoveCameraToUnit:
      return "DOTA_UM_MoveCameraToUnit";
    case EDotaUserMessages.DOTA_UM_PauseMinigameData:
      return "DOTA_UM_PauseMinigameData";
    case EDotaUserMessages.DOTA_UM_VersusScene_PlayerBehavior:
      return "DOTA_UM_VersusScene_PlayerBehavior";
    case EDotaUserMessages.DOTA_UM_QoP_ArcanaSummary:
      return "DOTA_UM_QoP_ArcanaSummary";
    case EDotaUserMessages.DOTA_UM_HotPotato_Created:
      return "DOTA_UM_HotPotato_Created";
    case EDotaUserMessages.DOTA_UM_HotPotato_Exploded:
      return "DOTA_UM_HotPotato_Exploded";
    case EDotaUserMessages.DOTA_UM_WK_Arcana_Progress:
      return "DOTA_UM_WK_Arcana_Progress";
    case EDotaUserMessages.DOTA_UM_GuildChallenge_Progress:
      return "DOTA_UM_GuildChallenge_Progress";
    case EDotaUserMessages.DOTA_UM_WRArcanaProgress:
      return "DOTA_UM_WRArcanaProgress";
    case EDotaUserMessages.DOTA_UM_WRArcanaSummary:
      return "DOTA_UM_WRArcanaSummary";
    case EDotaUserMessages.DOTA_UM_EmptyItemSlotAlert:
      return "DOTA_UM_EmptyItemSlotAlert";
    case EDotaUserMessages.DOTA_UM_AghsStatusAlert:
      return "DOTA_UM_AghsStatusAlert";
    case EDotaUserMessages.DOTA_UM_PingConfirmation:
      return "DOTA_UM_PingConfirmation";
    case EDotaUserMessages.DOTA_UM_MutedPlayers:
      return "DOTA_UM_MutedPlayers";
    case EDotaUserMessages.DOTA_UM_ContextualTip:
      return "DOTA_UM_ContextualTip";
    case EDotaUserMessages.DOTA_UM_ChatMessage:
      return "DOTA_UM_ChatMessage";
    case EDotaUserMessages.DOTA_UM_NeutralCampAlert:
      return "DOTA_UM_NeutralCampAlert";
    case EDotaUserMessages.DOTA_UM_RockPaperScissorsStarted:
      return "DOTA_UM_RockPaperScissorsStarted";
    case EDotaUserMessages.DOTA_UM_RockPaperScissorsFinished:
      return "DOTA_UM_RockPaperScissorsFinished";
    case EDotaUserMessages.DOTA_UM_DuelOpponentKilled:
      return "DOTA_UM_DuelOpponentKilled";
    case EDotaUserMessages.DOTA_UM_DuelAccepted:
      return "DOTA_UM_DuelAccepted";
    case EDotaUserMessages.DOTA_UM_DuelRequested:
      return "DOTA_UM_DuelRequested";
    case EDotaUserMessages.DOTA_UM_MuertaReleaseEvent_AssignedTargetKilled:
      return "DOTA_UM_MuertaReleaseEvent_AssignedTargetKilled";
    case EDotaUserMessages.DOTA_UM_PlayerDraftSuggestPick:
      return "DOTA_UM_PlayerDraftSuggestPick";
    case EDotaUserMessages.DOTA_UM_PlayerDraftPick:
      return "DOTA_UM_PlayerDraftPick";
    case EDotaUserMessages.DOTA_UM_UpdateLinearProjectileCPData:
      return "DOTA_UM_UpdateLinearProjectileCPData";
    case EDotaUserMessages.DOTA_UM_GiftPlayer:
      return "DOTA_UM_GiftPlayer";
    case EDotaUserMessages.DOTA_UM_FacetPing:
      return "DOTA_UM_FacetPing";
    case EDotaUserMessages.DOTA_UM_InnatePing:
      return "DOTA_UM_InnatePing";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum EDotaUserMessages");
  }
}

export enum dotaChatMessage {
  CHAT_MESSAGE_INVALID = -1,
  CHAT_MESSAGE_HERO_KILL = 0,
  CHAT_MESSAGE_HERO_DENY = 1,
  CHAT_MESSAGE_BARRACKS_KILL = 2,
  CHAT_MESSAGE_TOWER_KILL = 3,
  CHAT_MESSAGE_TOWER_DENY = 4,
  CHAT_MESSAGE_FIRSTBLOOD = 5,
  CHAT_MESSAGE_STREAK_KILL = 6,
  CHAT_MESSAGE_BUYBACK = 7,
  CHAT_MESSAGE_AEGIS = 8,
  CHAT_MESSAGE_ROSHAN_KILL = 9,
  CHAT_MESSAGE_COURIER_LOST = 10,
  CHAT_MESSAGE_COURIER_RESPAWNED = 11,
  CHAT_MESSAGE_GLYPH_USED = 12,
  CHAT_MESSAGE_ITEM_PURCHASE = 13,
  CHAT_MESSAGE_CONNECT = 14,
  CHAT_MESSAGE_DISCONNECT = 15,
  CHAT_MESSAGE_DISCONNECT_WAIT_FOR_RECONNECT = 16,
  CHAT_MESSAGE_DISCONNECT_TIME_REMAINING = 17,
  CHAT_MESSAGE_DISCONNECT_TIME_REMAINING_PLURAL = 18,
  CHAT_MESSAGE_RECONNECT = 19,
  CHAT_MESSAGE_PLAYER_LEFT = 20,
  CHAT_MESSAGE_SAFE_TO_LEAVE = 21,
  CHAT_MESSAGE_RUNE_PICKUP = 22,
  CHAT_MESSAGE_RUNE_BOTTLE = 23,
  CHAT_MESSAGE_RUNE_DENY = 114,
  CHAT_MESSAGE_INTHEBAG = 24,
  CHAT_MESSAGE_SECRETSHOP = 25,
  CHAT_MESSAGE_ITEM_AUTOPURCHASED = 26,
  CHAT_MESSAGE_ITEMS_COMBINED = 27,
  CHAT_MESSAGE_SUPER_CREEPS = 28,
  CHAT_MESSAGE_CANT_USE_ACTION_ITEM = 29,
  CHAT_MESSAGE_CANTPAUSE = 31,
  CHAT_MESSAGE_NOPAUSESLEFT = 32,
  CHAT_MESSAGE_CANTPAUSEYET = 33,
  CHAT_MESSAGE_PAUSED = 34,
  CHAT_MESSAGE_UNPAUSE_COUNTDOWN = 35,
  CHAT_MESSAGE_UNPAUSED = 36,
  CHAT_MESSAGE_AUTO_UNPAUSED = 37,
  CHAT_MESSAGE_YOUPAUSED = 38,
  CHAT_MESSAGE_CANTUNPAUSETEAM = 39,
  CHAT_MESSAGE_VOICE_TEXT_BANNED = 41,
  CHAT_MESSAGE_SPECTATORS_WATCHING_THIS_GAME = 42,
  CHAT_MESSAGE_REPORT_REMINDER = 43,
  CHAT_MESSAGE_ECON_ITEM = 44,
  CHAT_MESSAGE_TAUNT = 45,
  CHAT_MESSAGE_RANDOM = 46,
  CHAT_MESSAGE_RD_TURN = 47,
  CHAT_MESSAGE_DROP_RATE_BONUS = 49,
  CHAT_MESSAGE_NO_BATTLE_POINTS = 50,
  CHAT_MESSAGE_DENIED_AEGIS = 51,
  CHAT_MESSAGE_INFORMATIONAL = 52,
  CHAT_MESSAGE_AEGIS_STOLEN = 53,
  CHAT_MESSAGE_ROSHAN_CANDY = 54,
  CHAT_MESSAGE_ITEM_GIFTED = 55,
  CHAT_MESSAGE_HERO_KILL_WITH_GREEVIL = 56,
  CHAT_MESSAGE_HOLDOUT_TOWER_DESTROYED = 57,
  CHAT_MESSAGE_HOLDOUT_WALL_DESTROYED = 58,
  CHAT_MESSAGE_HOLDOUT_WALL_FINISHED = 59,
  CHAT_MESSAGE_PLAYER_LEFT_LIMITED_HERO = 62,
  CHAT_MESSAGE_ABANDON_LIMITED_HERO_EXPLANATION = 63,
  CHAT_MESSAGE_DISCONNECT_LIMITED_HERO = 64,
  CHAT_MESSAGE_LOW_PRIORITY_COMPLETED_EXPLANATION = 65,
  CHAT_MESSAGE_RECRUITMENT_DROP_RATE_BONUS = 66,
  CHAT_MESSAGE_FROSTIVUS_SHINING_BOOSTER_ACTIVE = 67,
  CHAT_MESSAGE_PLAYER_LEFT_AFK = 73,
  CHAT_MESSAGE_PLAYER_LEFT_DISCONNECTED_TOO_LONG = 74,
  CHAT_MESSAGE_PLAYER_ABANDONED = 75,
  CHAT_MESSAGE_PLAYER_ABANDONED_AFK = 76,
  CHAT_MESSAGE_PLAYER_ABANDONED_DISCONNECTED_TOO_LONG = 77,
  CHAT_MESSAGE_WILL_NOT_BE_SCORED = 78,
  CHAT_MESSAGE_WILL_NOT_BE_SCORED_RANKED = 79,
  CHAT_MESSAGE_WILL_NOT_BE_SCORED_NETWORK = 80,
  CHAT_MESSAGE_WILL_NOT_BE_SCORED_NETWORK_RANKED = 81,
  CHAT_MESSAGE_CAN_QUIT_WITHOUT_ABANDON = 82,
  CHAT_MESSAGE_RANKED_GAME_STILL_SCORED_LEAVERS_GET_LOSS = 83,
  CHAT_MESSAGE_ABANDON_RANKED_BEFORE_FIRST_BLOOD_PARTY = 84,
  CHAT_MESSAGE_COMPENDIUM_LEVEL = 85,
  CHAT_MESSAGE_VICTORY_PREDICTION_STREAK = 86,
  CHAT_MESSAGE_ASSASSIN_ANNOUNCE = 87,
  CHAT_MESSAGE_ASSASSIN_SUCCESS = 88,
  CHAT_MESSAGE_ASSASSIN_DENIED = 89,
  CHAT_MESSAGE_VICTORY_PREDICTION_SINGLE_USER_CONFIRM = 90,
  CHAT_MESSAGE_EFFIGY_KILL = 91,
  CHAT_MESSAGE_VOICE_TEXT_BANNED_OVERFLOW = 92,
  CHAT_MESSAGE_YEAR_BEAST_KILLED = 93,
  CHAT_MESSAGE_PAUSE_COUNTDOWN = 94,
  CHAT_MESSAGE_COINS_WAGERED = 95,
  CHAT_MESSAGE_HERO_NOMINATED_BAN = 96,
  CHAT_MESSAGE_HERO_BANNED = 97,
  CHAT_MESSAGE_HERO_BAN_COUNT = 98,
  CHAT_MESSAGE_RIVER_PAINTED = 99,
  CHAT_MESSAGE_SCAN_USED = 100,
  CHAT_MESSAGE_SHRINE_KILLED = 101,
  CHAT_MESSAGE_WAGER_TOKEN_SPENT = 102,
  CHAT_MESSAGE_RANK_WAGER = 103,
  CHAT_MESSAGE_NEW_PLAYER_REMINDER = 104,
  CHAT_MESSAGE_OBSERVER_WARD_KILLED = 105,
  CHAT_MESSAGE_SENTRY_WARD_KILLED = 106,
  CHAT_MESSAGE_ITEM_PLACED_IN_NEUTRAL_STASH = 107,
  CHAT_MESSAGE_HERO_CHOICE_INVALID = 108,
  CHAT_MESSAGE_BOUNTY = 109,
  CHAT_MESSAGE_ABILITY_DRAFT_START = 110,
  CHAT_MESSAGE_HERO_FOUND_CANDY = 111,
  CHAT_MESSAGE_ABILITY_DRAFT_RANDOMED = 112,
  CHAT_MESSAGE_PRIVATE_COACH_CONNECTED = 113,
  CHAT_MESSAGE_CANT_PAUSE_TOO_EARLY = 115,
  CHAT_MESSAGE_HERO_KILL_WITH_PENGUIN = 116,
  CHAT_MESSAGE_MINIBOSS_KILL = 117,
  CHAT_MESSAGE_PLAYER_IN_GAME_BAN_TEXT = 118,
  CHAT_MESSAGE_BANNER_PLANTED = 119,
}

export function dotaChatMessageFromJSON(object: any): dotaChatMessage {
  switch (object) {
    case -1:
    case "CHAT_MESSAGE_INVALID":
      return dotaChatMessage.CHAT_MESSAGE_INVALID;
    case 0:
    case "CHAT_MESSAGE_HERO_KILL":
      return dotaChatMessage.CHAT_MESSAGE_HERO_KILL;
    case 1:
    case "CHAT_MESSAGE_HERO_DENY":
      return dotaChatMessage.CHAT_MESSAGE_HERO_DENY;
    case 2:
    case "CHAT_MESSAGE_BARRACKS_KILL":
      return dotaChatMessage.CHAT_MESSAGE_BARRACKS_KILL;
    case 3:
    case "CHAT_MESSAGE_TOWER_KILL":
      return dotaChatMessage.CHAT_MESSAGE_TOWER_KILL;
    case 4:
    case "CHAT_MESSAGE_TOWER_DENY":
      return dotaChatMessage.CHAT_MESSAGE_TOWER_DENY;
    case 5:
    case "CHAT_MESSAGE_FIRSTBLOOD":
      return dotaChatMessage.CHAT_MESSAGE_FIRSTBLOOD;
    case 6:
    case "CHAT_MESSAGE_STREAK_KILL":
      return dotaChatMessage.CHAT_MESSAGE_STREAK_KILL;
    case 7:
    case "CHAT_MESSAGE_BUYBACK":
      return dotaChatMessage.CHAT_MESSAGE_BUYBACK;
    case 8:
    case "CHAT_MESSAGE_AEGIS":
      return dotaChatMessage.CHAT_MESSAGE_AEGIS;
    case 9:
    case "CHAT_MESSAGE_ROSHAN_KILL":
      return dotaChatMessage.CHAT_MESSAGE_ROSHAN_KILL;
    case 10:
    case "CHAT_MESSAGE_COURIER_LOST":
      return dotaChatMessage.CHAT_MESSAGE_COURIER_LOST;
    case 11:
    case "CHAT_MESSAGE_COURIER_RESPAWNED":
      return dotaChatMessage.CHAT_MESSAGE_COURIER_RESPAWNED;
    case 12:
    case "CHAT_MESSAGE_GLYPH_USED":
      return dotaChatMessage.CHAT_MESSAGE_GLYPH_USED;
    case 13:
    case "CHAT_MESSAGE_ITEM_PURCHASE":
      return dotaChatMessage.CHAT_MESSAGE_ITEM_PURCHASE;
    case 14:
    case "CHAT_MESSAGE_CONNECT":
      return dotaChatMessage.CHAT_MESSAGE_CONNECT;
    case 15:
    case "CHAT_MESSAGE_DISCONNECT":
      return dotaChatMessage.CHAT_MESSAGE_DISCONNECT;
    case 16:
    case "CHAT_MESSAGE_DISCONNECT_WAIT_FOR_RECONNECT":
      return dotaChatMessage.CHAT_MESSAGE_DISCONNECT_WAIT_FOR_RECONNECT;
    case 17:
    case "CHAT_MESSAGE_DISCONNECT_TIME_REMAINING":
      return dotaChatMessage.CHAT_MESSAGE_DISCONNECT_TIME_REMAINING;
    case 18:
    case "CHAT_MESSAGE_DISCONNECT_TIME_REMAINING_PLURAL":
      return dotaChatMessage.CHAT_MESSAGE_DISCONNECT_TIME_REMAINING_PLURAL;
    case 19:
    case "CHAT_MESSAGE_RECONNECT":
      return dotaChatMessage.CHAT_MESSAGE_RECONNECT;
    case 20:
    case "CHAT_MESSAGE_PLAYER_LEFT":
      return dotaChatMessage.CHAT_MESSAGE_PLAYER_LEFT;
    case 21:
    case "CHAT_MESSAGE_SAFE_TO_LEAVE":
      return dotaChatMessage.CHAT_MESSAGE_SAFE_TO_LEAVE;
    case 22:
    case "CHAT_MESSAGE_RUNE_PICKUP":
      return dotaChatMessage.CHAT_MESSAGE_RUNE_PICKUP;
    case 23:
    case "CHAT_MESSAGE_RUNE_BOTTLE":
      return dotaChatMessage.CHAT_MESSAGE_RUNE_BOTTLE;
    case 114:
    case "CHAT_MESSAGE_RUNE_DENY":
      return dotaChatMessage.CHAT_MESSAGE_RUNE_DENY;
    case 24:
    case "CHAT_MESSAGE_INTHEBAG":
      return dotaChatMessage.CHAT_MESSAGE_INTHEBAG;
    case 25:
    case "CHAT_MESSAGE_SECRETSHOP":
      return dotaChatMessage.CHAT_MESSAGE_SECRETSHOP;
    case 26:
    case "CHAT_MESSAGE_ITEM_AUTOPURCHASED":
      return dotaChatMessage.CHAT_MESSAGE_ITEM_AUTOPURCHASED;
    case 27:
    case "CHAT_MESSAGE_ITEMS_COMBINED":
      return dotaChatMessage.CHAT_MESSAGE_ITEMS_COMBINED;
    case 28:
    case "CHAT_MESSAGE_SUPER_CREEPS":
      return dotaChatMessage.CHAT_MESSAGE_SUPER_CREEPS;
    case 29:
    case "CHAT_MESSAGE_CANT_USE_ACTION_ITEM":
      return dotaChatMessage.CHAT_MESSAGE_CANT_USE_ACTION_ITEM;
    case 31:
    case "CHAT_MESSAGE_CANTPAUSE":
      return dotaChatMessage.CHAT_MESSAGE_CANTPAUSE;
    case 32:
    case "CHAT_MESSAGE_NOPAUSESLEFT":
      return dotaChatMessage.CHAT_MESSAGE_NOPAUSESLEFT;
    case 33:
    case "CHAT_MESSAGE_CANTPAUSEYET":
      return dotaChatMessage.CHAT_MESSAGE_CANTPAUSEYET;
    case 34:
    case "CHAT_MESSAGE_PAUSED":
      return dotaChatMessage.CHAT_MESSAGE_PAUSED;
    case 35:
    case "CHAT_MESSAGE_UNPAUSE_COUNTDOWN":
      return dotaChatMessage.CHAT_MESSAGE_UNPAUSE_COUNTDOWN;
    case 36:
    case "CHAT_MESSAGE_UNPAUSED":
      return dotaChatMessage.CHAT_MESSAGE_UNPAUSED;
    case 37:
    case "CHAT_MESSAGE_AUTO_UNPAUSED":
      return dotaChatMessage.CHAT_MESSAGE_AUTO_UNPAUSED;
    case 38:
    case "CHAT_MESSAGE_YOUPAUSED":
      return dotaChatMessage.CHAT_MESSAGE_YOUPAUSED;
    case 39:
    case "CHAT_MESSAGE_CANTUNPAUSETEAM":
      return dotaChatMessage.CHAT_MESSAGE_CANTUNPAUSETEAM;
    case 41:
    case "CHAT_MESSAGE_VOICE_TEXT_BANNED":
      return dotaChatMessage.CHAT_MESSAGE_VOICE_TEXT_BANNED;
    case 42:
    case "CHAT_MESSAGE_SPECTATORS_WATCHING_THIS_GAME":
      return dotaChatMessage.CHAT_MESSAGE_SPECTATORS_WATCHING_THIS_GAME;
    case 43:
    case "CHAT_MESSAGE_REPORT_REMINDER":
      return dotaChatMessage.CHAT_MESSAGE_REPORT_REMINDER;
    case 44:
    case "CHAT_MESSAGE_ECON_ITEM":
      return dotaChatMessage.CHAT_MESSAGE_ECON_ITEM;
    case 45:
    case "CHAT_MESSAGE_TAUNT":
      return dotaChatMessage.CHAT_MESSAGE_TAUNT;
    case 46:
    case "CHAT_MESSAGE_RANDOM":
      return dotaChatMessage.CHAT_MESSAGE_RANDOM;
    case 47:
    case "CHAT_MESSAGE_RD_TURN":
      return dotaChatMessage.CHAT_MESSAGE_RD_TURN;
    case 49:
    case "CHAT_MESSAGE_DROP_RATE_BONUS":
      return dotaChatMessage.CHAT_MESSAGE_DROP_RATE_BONUS;
    case 50:
    case "CHAT_MESSAGE_NO_BATTLE_POINTS":
      return dotaChatMessage.CHAT_MESSAGE_NO_BATTLE_POINTS;
    case 51:
    case "CHAT_MESSAGE_DENIED_AEGIS":
      return dotaChatMessage.CHAT_MESSAGE_DENIED_AEGIS;
    case 52:
    case "CHAT_MESSAGE_INFORMATIONAL":
      return dotaChatMessage.CHAT_MESSAGE_INFORMATIONAL;
    case 53:
    case "CHAT_MESSAGE_AEGIS_STOLEN":
      return dotaChatMessage.CHAT_MESSAGE_AEGIS_STOLEN;
    case 54:
    case "CHAT_MESSAGE_ROSHAN_CANDY":
      return dotaChatMessage.CHAT_MESSAGE_ROSHAN_CANDY;
    case 55:
    case "CHAT_MESSAGE_ITEM_GIFTED":
      return dotaChatMessage.CHAT_MESSAGE_ITEM_GIFTED;
    case 56:
    case "CHAT_MESSAGE_HERO_KILL_WITH_GREEVIL":
      return dotaChatMessage.CHAT_MESSAGE_HERO_KILL_WITH_GREEVIL;
    case 57:
    case "CHAT_MESSAGE_HOLDOUT_TOWER_DESTROYED":
      return dotaChatMessage.CHAT_MESSAGE_HOLDOUT_TOWER_DESTROYED;
    case 58:
    case "CHAT_MESSAGE_HOLDOUT_WALL_DESTROYED":
      return dotaChatMessage.CHAT_MESSAGE_HOLDOUT_WALL_DESTROYED;
    case 59:
    case "CHAT_MESSAGE_HOLDOUT_WALL_FINISHED":
      return dotaChatMessage.CHAT_MESSAGE_HOLDOUT_WALL_FINISHED;
    case 62:
    case "CHAT_MESSAGE_PLAYER_LEFT_LIMITED_HERO":
      return dotaChatMessage.CHAT_MESSAGE_PLAYER_LEFT_LIMITED_HERO;
    case 63:
    case "CHAT_MESSAGE_ABANDON_LIMITED_HERO_EXPLANATION":
      return dotaChatMessage.CHAT_MESSAGE_ABANDON_LIMITED_HERO_EXPLANATION;
    case 64:
    case "CHAT_MESSAGE_DISCONNECT_LIMITED_HERO":
      return dotaChatMessage.CHAT_MESSAGE_DISCONNECT_LIMITED_HERO;
    case 65:
    case "CHAT_MESSAGE_LOW_PRIORITY_COMPLETED_EXPLANATION":
      return dotaChatMessage.CHAT_MESSAGE_LOW_PRIORITY_COMPLETED_EXPLANATION;
    case 66:
    case "CHAT_MESSAGE_RECRUITMENT_DROP_RATE_BONUS":
      return dotaChatMessage.CHAT_MESSAGE_RECRUITMENT_DROP_RATE_BONUS;
    case 67:
    case "CHAT_MESSAGE_FROSTIVUS_SHINING_BOOSTER_ACTIVE":
      return dotaChatMessage.CHAT_MESSAGE_FROSTIVUS_SHINING_BOOSTER_ACTIVE;
    case 73:
    case "CHAT_MESSAGE_PLAYER_LEFT_AFK":
      return dotaChatMessage.CHAT_MESSAGE_PLAYER_LEFT_AFK;
    case 74:
    case "CHAT_MESSAGE_PLAYER_LEFT_DISCONNECTED_TOO_LONG":
      return dotaChatMessage.CHAT_MESSAGE_PLAYER_LEFT_DISCONNECTED_TOO_LONG;
    case 75:
    case "CHAT_MESSAGE_PLAYER_ABANDONED":
      return dotaChatMessage.CHAT_MESSAGE_PLAYER_ABANDONED;
    case 76:
    case "CHAT_MESSAGE_PLAYER_ABANDONED_AFK":
      return dotaChatMessage.CHAT_MESSAGE_PLAYER_ABANDONED_AFK;
    case 77:
    case "CHAT_MESSAGE_PLAYER_ABANDONED_DISCONNECTED_TOO_LONG":
      return dotaChatMessage.CHAT_MESSAGE_PLAYER_ABANDONED_DISCONNECTED_TOO_LONG;
    case 78:
    case "CHAT_MESSAGE_WILL_NOT_BE_SCORED":
      return dotaChatMessage.CHAT_MESSAGE_WILL_NOT_BE_SCORED;
    case 79:
    case "CHAT_MESSAGE_WILL_NOT_BE_SCORED_RANKED":
      return dotaChatMessage.CHAT_MESSAGE_WILL_NOT_BE_SCORED_RANKED;
    case 80:
    case "CHAT_MESSAGE_WILL_NOT_BE_SCORED_NETWORK":
      return dotaChatMessage.CHAT_MESSAGE_WILL_NOT_BE_SCORED_NETWORK;
    case 81:
    case "CHAT_MESSAGE_WILL_NOT_BE_SCORED_NETWORK_RANKED":
      return dotaChatMessage.CHAT_MESSAGE_WILL_NOT_BE_SCORED_NETWORK_RANKED;
    case 82:
    case "CHAT_MESSAGE_CAN_QUIT_WITHOUT_ABANDON":
      return dotaChatMessage.CHAT_MESSAGE_CAN_QUIT_WITHOUT_ABANDON;
    case 83:
    case "CHAT_MESSAGE_RANKED_GAME_STILL_SCORED_LEAVERS_GET_LOSS":
      return dotaChatMessage.CHAT_MESSAGE_RANKED_GAME_STILL_SCORED_LEAVERS_GET_LOSS;
    case 84:
    case "CHAT_MESSAGE_ABANDON_RANKED_BEFORE_FIRST_BLOOD_PARTY":
      return dotaChatMessage.CHAT_MESSAGE_ABANDON_RANKED_BEFORE_FIRST_BLOOD_PARTY;
    case 85:
    case "CHAT_MESSAGE_COMPENDIUM_LEVEL":
      return dotaChatMessage.CHAT_MESSAGE_COMPENDIUM_LEVEL;
    case 86:
    case "CHAT_MESSAGE_VICTORY_PREDICTION_STREAK":
      return dotaChatMessage.CHAT_MESSAGE_VICTORY_PREDICTION_STREAK;
    case 87:
    case "CHAT_MESSAGE_ASSASSIN_ANNOUNCE":
      return dotaChatMessage.CHAT_MESSAGE_ASSASSIN_ANNOUNCE;
    case 88:
    case "CHAT_MESSAGE_ASSASSIN_SUCCESS":
      return dotaChatMessage.CHAT_MESSAGE_ASSASSIN_SUCCESS;
    case 89:
    case "CHAT_MESSAGE_ASSASSIN_DENIED":
      return dotaChatMessage.CHAT_MESSAGE_ASSASSIN_DENIED;
    case 90:
    case "CHAT_MESSAGE_VICTORY_PREDICTION_SINGLE_USER_CONFIRM":
      return dotaChatMessage.CHAT_MESSAGE_VICTORY_PREDICTION_SINGLE_USER_CONFIRM;
    case 91:
    case "CHAT_MESSAGE_EFFIGY_KILL":
      return dotaChatMessage.CHAT_MESSAGE_EFFIGY_KILL;
    case 92:
    case "CHAT_MESSAGE_VOICE_TEXT_BANNED_OVERFLOW":
      return dotaChatMessage.CHAT_MESSAGE_VOICE_TEXT_BANNED_OVERFLOW;
    case 93:
    case "CHAT_MESSAGE_YEAR_BEAST_KILLED":
      return dotaChatMessage.CHAT_MESSAGE_YEAR_BEAST_KILLED;
    case 94:
    case "CHAT_MESSAGE_PAUSE_COUNTDOWN":
      return dotaChatMessage.CHAT_MESSAGE_PAUSE_COUNTDOWN;
    case 95:
    case "CHAT_MESSAGE_COINS_WAGERED":
      return dotaChatMessage.CHAT_MESSAGE_COINS_WAGERED;
    case 96:
    case "CHAT_MESSAGE_HERO_NOMINATED_BAN":
      return dotaChatMessage.CHAT_MESSAGE_HERO_NOMINATED_BAN;
    case 97:
    case "CHAT_MESSAGE_HERO_BANNED":
      return dotaChatMessage.CHAT_MESSAGE_HERO_BANNED;
    case 98:
    case "CHAT_MESSAGE_HERO_BAN_COUNT":
      return dotaChatMessage.CHAT_MESSAGE_HERO_BAN_COUNT;
    case 99:
    case "CHAT_MESSAGE_RIVER_PAINTED":
      return dotaChatMessage.CHAT_MESSAGE_RIVER_PAINTED;
    case 100:
    case "CHAT_MESSAGE_SCAN_USED":
      return dotaChatMessage.CHAT_MESSAGE_SCAN_USED;
    case 101:
    case "CHAT_MESSAGE_SHRINE_KILLED":
      return dotaChatMessage.CHAT_MESSAGE_SHRINE_KILLED;
    case 102:
    case "CHAT_MESSAGE_WAGER_TOKEN_SPENT":
      return dotaChatMessage.CHAT_MESSAGE_WAGER_TOKEN_SPENT;
    case 103:
    case "CHAT_MESSAGE_RANK_WAGER":
      return dotaChatMessage.CHAT_MESSAGE_RANK_WAGER;
    case 104:
    case "CHAT_MESSAGE_NEW_PLAYER_REMINDER":
      return dotaChatMessage.CHAT_MESSAGE_NEW_PLAYER_REMINDER;
    case 105:
    case "CHAT_MESSAGE_OBSERVER_WARD_KILLED":
      return dotaChatMessage.CHAT_MESSAGE_OBSERVER_WARD_KILLED;
    case 106:
    case "CHAT_MESSAGE_SENTRY_WARD_KILLED":
      return dotaChatMessage.CHAT_MESSAGE_SENTRY_WARD_KILLED;
    case 107:
    case "CHAT_MESSAGE_ITEM_PLACED_IN_NEUTRAL_STASH":
      return dotaChatMessage.CHAT_MESSAGE_ITEM_PLACED_IN_NEUTRAL_STASH;
    case 108:
    case "CHAT_MESSAGE_HERO_CHOICE_INVALID":
      return dotaChatMessage.CHAT_MESSAGE_HERO_CHOICE_INVALID;
    case 109:
    case "CHAT_MESSAGE_BOUNTY":
      return dotaChatMessage.CHAT_MESSAGE_BOUNTY;
    case 110:
    case "CHAT_MESSAGE_ABILITY_DRAFT_START":
      return dotaChatMessage.CHAT_MESSAGE_ABILITY_DRAFT_START;
    case 111:
    case "CHAT_MESSAGE_HERO_FOUND_CANDY":
      return dotaChatMessage.CHAT_MESSAGE_HERO_FOUND_CANDY;
    case 112:
    case "CHAT_MESSAGE_ABILITY_DRAFT_RANDOMED":
      return dotaChatMessage.CHAT_MESSAGE_ABILITY_DRAFT_RANDOMED;
    case 113:
    case "CHAT_MESSAGE_PRIVATE_COACH_CONNECTED":
      return dotaChatMessage.CHAT_MESSAGE_PRIVATE_COACH_CONNECTED;
    case 115:
    case "CHAT_MESSAGE_CANT_PAUSE_TOO_EARLY":
      return dotaChatMessage.CHAT_MESSAGE_CANT_PAUSE_TOO_EARLY;
    case 116:
    case "CHAT_MESSAGE_HERO_KILL_WITH_PENGUIN":
      return dotaChatMessage.CHAT_MESSAGE_HERO_KILL_WITH_PENGUIN;
    case 117:
    case "CHAT_MESSAGE_MINIBOSS_KILL":
      return dotaChatMessage.CHAT_MESSAGE_MINIBOSS_KILL;
    case 118:
    case "CHAT_MESSAGE_PLAYER_IN_GAME_BAN_TEXT":
      return dotaChatMessage.CHAT_MESSAGE_PLAYER_IN_GAME_BAN_TEXT;
    case 119:
    case "CHAT_MESSAGE_BANNER_PLANTED":
      return dotaChatMessage.CHAT_MESSAGE_BANNER_PLANTED;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum dotaChatMessage");
  }
}

export function dotaChatMessageToJSON(object: dotaChatMessage): string {
  switch (object) {
    case dotaChatMessage.CHAT_MESSAGE_INVALID:
      return "CHAT_MESSAGE_INVALID";
    case dotaChatMessage.CHAT_MESSAGE_HERO_KILL:
      return "CHAT_MESSAGE_HERO_KILL";
    case dotaChatMessage.CHAT_MESSAGE_HERO_DENY:
      return "CHAT_MESSAGE_HERO_DENY";
    case dotaChatMessage.CHAT_MESSAGE_BARRACKS_KILL:
      return "CHAT_MESSAGE_BARRACKS_KILL";
    case dotaChatMessage.CHAT_MESSAGE_TOWER_KILL:
      return "CHAT_MESSAGE_TOWER_KILL";
    case dotaChatMessage.CHAT_MESSAGE_TOWER_DENY:
      return "CHAT_MESSAGE_TOWER_DENY";
    case dotaChatMessage.CHAT_MESSAGE_FIRSTBLOOD:
      return "CHAT_MESSAGE_FIRSTBLOOD";
    case dotaChatMessage.CHAT_MESSAGE_STREAK_KILL:
      return "CHAT_MESSAGE_STREAK_KILL";
    case dotaChatMessage.CHAT_MESSAGE_BUYBACK:
      return "CHAT_MESSAGE_BUYBACK";
    case dotaChatMessage.CHAT_MESSAGE_AEGIS:
      return "CHAT_MESSAGE_AEGIS";
    case dotaChatMessage.CHAT_MESSAGE_ROSHAN_KILL:
      return "CHAT_MESSAGE_ROSHAN_KILL";
    case dotaChatMessage.CHAT_MESSAGE_COURIER_LOST:
      return "CHAT_MESSAGE_COURIER_LOST";
    case dotaChatMessage.CHAT_MESSAGE_COURIER_RESPAWNED:
      return "CHAT_MESSAGE_COURIER_RESPAWNED";
    case dotaChatMessage.CHAT_MESSAGE_GLYPH_USED:
      return "CHAT_MESSAGE_GLYPH_USED";
    case dotaChatMessage.CHAT_MESSAGE_ITEM_PURCHASE:
      return "CHAT_MESSAGE_ITEM_PURCHASE";
    case dotaChatMessage.CHAT_MESSAGE_CONNECT:
      return "CHAT_MESSAGE_CONNECT";
    case dotaChatMessage.CHAT_MESSAGE_DISCONNECT:
      return "CHAT_MESSAGE_DISCONNECT";
    case dotaChatMessage.CHAT_MESSAGE_DISCONNECT_WAIT_FOR_RECONNECT:
      return "CHAT_MESSAGE_DISCONNECT_WAIT_FOR_RECONNECT";
    case dotaChatMessage.CHAT_MESSAGE_DISCONNECT_TIME_REMAINING:
      return "CHAT_MESSAGE_DISCONNECT_TIME_REMAINING";
    case dotaChatMessage.CHAT_MESSAGE_DISCONNECT_TIME_REMAINING_PLURAL:
      return "CHAT_MESSAGE_DISCONNECT_TIME_REMAINING_PLURAL";
    case dotaChatMessage.CHAT_MESSAGE_RECONNECT:
      return "CHAT_MESSAGE_RECONNECT";
    case dotaChatMessage.CHAT_MESSAGE_PLAYER_LEFT:
      return "CHAT_MESSAGE_PLAYER_LEFT";
    case dotaChatMessage.CHAT_MESSAGE_SAFE_TO_LEAVE:
      return "CHAT_MESSAGE_SAFE_TO_LEAVE";
    case dotaChatMessage.CHAT_MESSAGE_RUNE_PICKUP:
      return "CHAT_MESSAGE_RUNE_PICKUP";
    case dotaChatMessage.CHAT_MESSAGE_RUNE_BOTTLE:
      return "CHAT_MESSAGE_RUNE_BOTTLE";
    case dotaChatMessage.CHAT_MESSAGE_RUNE_DENY:
      return "CHAT_MESSAGE_RUNE_DENY";
    case dotaChatMessage.CHAT_MESSAGE_INTHEBAG:
      return "CHAT_MESSAGE_INTHEBAG";
    case dotaChatMessage.CHAT_MESSAGE_SECRETSHOP:
      return "CHAT_MESSAGE_SECRETSHOP";
    case dotaChatMessage.CHAT_MESSAGE_ITEM_AUTOPURCHASED:
      return "CHAT_MESSAGE_ITEM_AUTOPURCHASED";
    case dotaChatMessage.CHAT_MESSAGE_ITEMS_COMBINED:
      return "CHAT_MESSAGE_ITEMS_COMBINED";
    case dotaChatMessage.CHAT_MESSAGE_SUPER_CREEPS:
      return "CHAT_MESSAGE_SUPER_CREEPS";
    case dotaChatMessage.CHAT_MESSAGE_CANT_USE_ACTION_ITEM:
      return "CHAT_MESSAGE_CANT_USE_ACTION_ITEM";
    case dotaChatMessage.CHAT_MESSAGE_CANTPAUSE:
      return "CHAT_MESSAGE_CANTPAUSE";
    case dotaChatMessage.CHAT_MESSAGE_NOPAUSESLEFT:
      return "CHAT_MESSAGE_NOPAUSESLEFT";
    case dotaChatMessage.CHAT_MESSAGE_CANTPAUSEYET:
      return "CHAT_MESSAGE_CANTPAUSEYET";
    case dotaChatMessage.CHAT_MESSAGE_PAUSED:
      return "CHAT_MESSAGE_PAUSED";
    case dotaChatMessage.CHAT_MESSAGE_UNPAUSE_COUNTDOWN:
      return "CHAT_MESSAGE_UNPAUSE_COUNTDOWN";
    case dotaChatMessage.CHAT_MESSAGE_UNPAUSED:
      return "CHAT_MESSAGE_UNPAUSED";
    case dotaChatMessage.CHAT_MESSAGE_AUTO_UNPAUSED:
      return "CHAT_MESSAGE_AUTO_UNPAUSED";
    case dotaChatMessage.CHAT_MESSAGE_YOUPAUSED:
      return "CHAT_MESSAGE_YOUPAUSED";
    case dotaChatMessage.CHAT_MESSAGE_CANTUNPAUSETEAM:
      return "CHAT_MESSAGE_CANTUNPAUSETEAM";
    case dotaChatMessage.CHAT_MESSAGE_VOICE_TEXT_BANNED:
      return "CHAT_MESSAGE_VOICE_TEXT_BANNED";
    case dotaChatMessage.CHAT_MESSAGE_SPECTATORS_WATCHING_THIS_GAME:
      return "CHAT_MESSAGE_SPECTATORS_WATCHING_THIS_GAME";
    case dotaChatMessage.CHAT_MESSAGE_REPORT_REMINDER:
      return "CHAT_MESSAGE_REPORT_REMINDER";
    case dotaChatMessage.CHAT_MESSAGE_ECON_ITEM:
      return "CHAT_MESSAGE_ECON_ITEM";
    case dotaChatMessage.CHAT_MESSAGE_TAUNT:
      return "CHAT_MESSAGE_TAUNT";
    case dotaChatMessage.CHAT_MESSAGE_RANDOM:
      return "CHAT_MESSAGE_RANDOM";
    case dotaChatMessage.CHAT_MESSAGE_RD_TURN:
      return "CHAT_MESSAGE_RD_TURN";
    case dotaChatMessage.CHAT_MESSAGE_DROP_RATE_BONUS:
      return "CHAT_MESSAGE_DROP_RATE_BONUS";
    case dotaChatMessage.CHAT_MESSAGE_NO_BATTLE_POINTS:
      return "CHAT_MESSAGE_NO_BATTLE_POINTS";
    case dotaChatMessage.CHAT_MESSAGE_DENIED_AEGIS:
      return "CHAT_MESSAGE_DENIED_AEGIS";
    case dotaChatMessage.CHAT_MESSAGE_INFORMATIONAL:
      return "CHAT_MESSAGE_INFORMATIONAL";
    case dotaChatMessage.CHAT_MESSAGE_AEGIS_STOLEN:
      return "CHAT_MESSAGE_AEGIS_STOLEN";
    case dotaChatMessage.CHAT_MESSAGE_ROSHAN_CANDY:
      return "CHAT_MESSAGE_ROSHAN_CANDY";
    case dotaChatMessage.CHAT_MESSAGE_ITEM_GIFTED:
      return "CHAT_MESSAGE_ITEM_GIFTED";
    case dotaChatMessage.CHAT_MESSAGE_HERO_KILL_WITH_GREEVIL:
      return "CHAT_MESSAGE_HERO_KILL_WITH_GREEVIL";
    case dotaChatMessage.CHAT_MESSAGE_HOLDOUT_TOWER_DESTROYED:
      return "CHAT_MESSAGE_HOLDOUT_TOWER_DESTROYED";
    case dotaChatMessage.CHAT_MESSAGE_HOLDOUT_WALL_DESTROYED:
      return "CHAT_MESSAGE_HOLDOUT_WALL_DESTROYED";
    case dotaChatMessage.CHAT_MESSAGE_HOLDOUT_WALL_FINISHED:
      return "CHAT_MESSAGE_HOLDOUT_WALL_FINISHED";
    case dotaChatMessage.CHAT_MESSAGE_PLAYER_LEFT_LIMITED_HERO:
      return "CHAT_MESSAGE_PLAYER_LEFT_LIMITED_HERO";
    case dotaChatMessage.CHAT_MESSAGE_ABANDON_LIMITED_HERO_EXPLANATION:
      return "CHAT_MESSAGE_ABANDON_LIMITED_HERO_EXPLANATION";
    case dotaChatMessage.CHAT_MESSAGE_DISCONNECT_LIMITED_HERO:
      return "CHAT_MESSAGE_DISCONNECT_LIMITED_HERO";
    case dotaChatMessage.CHAT_MESSAGE_LOW_PRIORITY_COMPLETED_EXPLANATION:
      return "CHAT_MESSAGE_LOW_PRIORITY_COMPLETED_EXPLANATION";
    case dotaChatMessage.CHAT_MESSAGE_RECRUITMENT_DROP_RATE_BONUS:
      return "CHAT_MESSAGE_RECRUITMENT_DROP_RATE_BONUS";
    case dotaChatMessage.CHAT_MESSAGE_FROSTIVUS_SHINING_BOOSTER_ACTIVE:
      return "CHAT_MESSAGE_FROSTIVUS_SHINING_BOOSTER_ACTIVE";
    case dotaChatMessage.CHAT_MESSAGE_PLAYER_LEFT_AFK:
      return "CHAT_MESSAGE_PLAYER_LEFT_AFK";
    case dotaChatMessage.CHAT_MESSAGE_PLAYER_LEFT_DISCONNECTED_TOO_LONG:
      return "CHAT_MESSAGE_PLAYER_LEFT_DISCONNECTED_TOO_LONG";
    case dotaChatMessage.CHAT_MESSAGE_PLAYER_ABANDONED:
      return "CHAT_MESSAGE_PLAYER_ABANDONED";
    case dotaChatMessage.CHAT_MESSAGE_PLAYER_ABANDONED_AFK:
      return "CHAT_MESSAGE_PLAYER_ABANDONED_AFK";
    case dotaChatMessage.CHAT_MESSAGE_PLAYER_ABANDONED_DISCONNECTED_TOO_LONG:
      return "CHAT_MESSAGE_PLAYER_ABANDONED_DISCONNECTED_TOO_LONG";
    case dotaChatMessage.CHAT_MESSAGE_WILL_NOT_BE_SCORED:
      return "CHAT_MESSAGE_WILL_NOT_BE_SCORED";
    case dotaChatMessage.CHAT_MESSAGE_WILL_NOT_BE_SCORED_RANKED:
      return "CHAT_MESSAGE_WILL_NOT_BE_SCORED_RANKED";
    case dotaChatMessage.CHAT_MESSAGE_WILL_NOT_BE_SCORED_NETWORK:
      return "CHAT_MESSAGE_WILL_NOT_BE_SCORED_NETWORK";
    case dotaChatMessage.CHAT_MESSAGE_WILL_NOT_BE_SCORED_NETWORK_RANKED:
      return "CHAT_MESSAGE_WILL_NOT_BE_SCORED_NETWORK_RANKED";
    case dotaChatMessage.CHAT_MESSAGE_CAN_QUIT_WITHOUT_ABANDON:
      return "CHAT_MESSAGE_CAN_QUIT_WITHOUT_ABANDON";
    case dotaChatMessage.CHAT_MESSAGE_RANKED_GAME_STILL_SCORED_LEAVERS_GET_LOSS:
      return "CHAT_MESSAGE_RANKED_GAME_STILL_SCORED_LEAVERS_GET_LOSS";
    case dotaChatMessage.CHAT_MESSAGE_ABANDON_RANKED_BEFORE_FIRST_BLOOD_PARTY:
      return "CHAT_MESSAGE_ABANDON_RANKED_BEFORE_FIRST_BLOOD_PARTY";
    case dotaChatMessage.CHAT_MESSAGE_COMPENDIUM_LEVEL:
      return "CHAT_MESSAGE_COMPENDIUM_LEVEL";
    case dotaChatMessage.CHAT_MESSAGE_VICTORY_PREDICTION_STREAK:
      return "CHAT_MESSAGE_VICTORY_PREDICTION_STREAK";
    case dotaChatMessage.CHAT_MESSAGE_ASSASSIN_ANNOUNCE:
      return "CHAT_MESSAGE_ASSASSIN_ANNOUNCE";
    case dotaChatMessage.CHAT_MESSAGE_ASSASSIN_SUCCESS:
      return "CHAT_MESSAGE_ASSASSIN_SUCCESS";
    case dotaChatMessage.CHAT_MESSAGE_ASSASSIN_DENIED:
      return "CHAT_MESSAGE_ASSASSIN_DENIED";
    case dotaChatMessage.CHAT_MESSAGE_VICTORY_PREDICTION_SINGLE_USER_CONFIRM:
      return "CHAT_MESSAGE_VICTORY_PREDICTION_SINGLE_USER_CONFIRM";
    case dotaChatMessage.CHAT_MESSAGE_EFFIGY_KILL:
      return "CHAT_MESSAGE_EFFIGY_KILL";
    case dotaChatMessage.CHAT_MESSAGE_VOICE_TEXT_BANNED_OVERFLOW:
      return "CHAT_MESSAGE_VOICE_TEXT_BANNED_OVERFLOW";
    case dotaChatMessage.CHAT_MESSAGE_YEAR_BEAST_KILLED:
      return "CHAT_MESSAGE_YEAR_BEAST_KILLED";
    case dotaChatMessage.CHAT_MESSAGE_PAUSE_COUNTDOWN:
      return "CHAT_MESSAGE_PAUSE_COUNTDOWN";
    case dotaChatMessage.CHAT_MESSAGE_COINS_WAGERED:
      return "CHAT_MESSAGE_COINS_WAGERED";
    case dotaChatMessage.CHAT_MESSAGE_HERO_NOMINATED_BAN:
      return "CHAT_MESSAGE_HERO_NOMINATED_BAN";
    case dotaChatMessage.CHAT_MESSAGE_HERO_BANNED:
      return "CHAT_MESSAGE_HERO_BANNED";
    case dotaChatMessage.CHAT_MESSAGE_HERO_BAN_COUNT:
      return "CHAT_MESSAGE_HERO_BAN_COUNT";
    case dotaChatMessage.CHAT_MESSAGE_RIVER_PAINTED:
      return "CHAT_MESSAGE_RIVER_PAINTED";
    case dotaChatMessage.CHAT_MESSAGE_SCAN_USED:
      return "CHAT_MESSAGE_SCAN_USED";
    case dotaChatMessage.CHAT_MESSAGE_SHRINE_KILLED:
      return "CHAT_MESSAGE_SHRINE_KILLED";
    case dotaChatMessage.CHAT_MESSAGE_WAGER_TOKEN_SPENT:
      return "CHAT_MESSAGE_WAGER_TOKEN_SPENT";
    case dotaChatMessage.CHAT_MESSAGE_RANK_WAGER:
      return "CHAT_MESSAGE_RANK_WAGER";
    case dotaChatMessage.CHAT_MESSAGE_NEW_PLAYER_REMINDER:
      return "CHAT_MESSAGE_NEW_PLAYER_REMINDER";
    case dotaChatMessage.CHAT_MESSAGE_OBSERVER_WARD_KILLED:
      return "CHAT_MESSAGE_OBSERVER_WARD_KILLED";
    case dotaChatMessage.CHAT_MESSAGE_SENTRY_WARD_KILLED:
      return "CHAT_MESSAGE_SENTRY_WARD_KILLED";
    case dotaChatMessage.CHAT_MESSAGE_ITEM_PLACED_IN_NEUTRAL_STASH:
      return "CHAT_MESSAGE_ITEM_PLACED_IN_NEUTRAL_STASH";
    case dotaChatMessage.CHAT_MESSAGE_HERO_CHOICE_INVALID:
      return "CHAT_MESSAGE_HERO_CHOICE_INVALID";
    case dotaChatMessage.CHAT_MESSAGE_BOUNTY:
      return "CHAT_MESSAGE_BOUNTY";
    case dotaChatMessage.CHAT_MESSAGE_ABILITY_DRAFT_START:
      return "CHAT_MESSAGE_ABILITY_DRAFT_START";
    case dotaChatMessage.CHAT_MESSAGE_HERO_FOUND_CANDY:
      return "CHAT_MESSAGE_HERO_FOUND_CANDY";
    case dotaChatMessage.CHAT_MESSAGE_ABILITY_DRAFT_RANDOMED:
      return "CHAT_MESSAGE_ABILITY_DRAFT_RANDOMED";
    case dotaChatMessage.CHAT_MESSAGE_PRIVATE_COACH_CONNECTED:
      return "CHAT_MESSAGE_PRIVATE_COACH_CONNECTED";
    case dotaChatMessage.CHAT_MESSAGE_CANT_PAUSE_TOO_EARLY:
      return "CHAT_MESSAGE_CANT_PAUSE_TOO_EARLY";
    case dotaChatMessage.CHAT_MESSAGE_HERO_KILL_WITH_PENGUIN:
      return "CHAT_MESSAGE_HERO_KILL_WITH_PENGUIN";
    case dotaChatMessage.CHAT_MESSAGE_MINIBOSS_KILL:
      return "CHAT_MESSAGE_MINIBOSS_KILL";
    case dotaChatMessage.CHAT_MESSAGE_PLAYER_IN_GAME_BAN_TEXT:
      return "CHAT_MESSAGE_PLAYER_IN_GAME_BAN_TEXT";
    case dotaChatMessage.CHAT_MESSAGE_BANNER_PLANTED:
      return "CHAT_MESSAGE_BANNER_PLANTED";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum dotaChatMessage");
  }
}

export enum dotaNoBattlePointsReasons {
  NO_BATTLE_POINTS_WRONG_LOBBY_TYPE = 1,
  NO_BATTLE_POINTS_PRACTICE_BOTS = 2,
  NO_BATTLE_POINTS_CHEATS_ENABLED = 3,
  NO_BATTLE_POINTS_LOW_PRIORITY = 4,
}

export function dotaNoBattlePointsReasonsFromJSON(object: any): dotaNoBattlePointsReasons {
  switch (object) {
    case 1:
    case "NO_BATTLE_POINTS_WRONG_LOBBY_TYPE":
      return dotaNoBattlePointsReasons.NO_BATTLE_POINTS_WRONG_LOBBY_TYPE;
    case 2:
    case "NO_BATTLE_POINTS_PRACTICE_BOTS":
      return dotaNoBattlePointsReasons.NO_BATTLE_POINTS_PRACTICE_BOTS;
    case 3:
    case "NO_BATTLE_POINTS_CHEATS_ENABLED":
      return dotaNoBattlePointsReasons.NO_BATTLE_POINTS_CHEATS_ENABLED;
    case 4:
    case "NO_BATTLE_POINTS_LOW_PRIORITY":
      return dotaNoBattlePointsReasons.NO_BATTLE_POINTS_LOW_PRIORITY;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum dotaNoBattlePointsReasons");
  }
}

export function dotaNoBattlePointsReasonsToJSON(object: dotaNoBattlePointsReasons): string {
  switch (object) {
    case dotaNoBattlePointsReasons.NO_BATTLE_POINTS_WRONG_LOBBY_TYPE:
      return "NO_BATTLE_POINTS_WRONG_LOBBY_TYPE";
    case dotaNoBattlePointsReasons.NO_BATTLE_POINTS_PRACTICE_BOTS:
      return "NO_BATTLE_POINTS_PRACTICE_BOTS";
    case dotaNoBattlePointsReasons.NO_BATTLE_POINTS_CHEATS_ENABLED:
      return "NO_BATTLE_POINTS_CHEATS_ENABLED";
    case dotaNoBattlePointsReasons.NO_BATTLE_POINTS_LOW_PRIORITY:
      return "NO_BATTLE_POINTS_LOW_PRIORITY";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum dotaNoBattlePointsReasons");
  }
}

export enum dotaChatInformational {
  INFO_COOP_BATTLE_POINTS_RULES = 1,
  INFO_FROSTIVUS_ABANDON_REMINDER = 2,
  INFO_RANKED_REMINDER = 3,
  INFO_COOP_LOW_PRIORITY_PASSIVE_REMINDER = 4,
  INFO_CUSTOM_GAME_PENALTY_REMINDER = 5,
}

export function dotaChatInformationalFromJSON(object: any): dotaChatInformational {
  switch (object) {
    case 1:
    case "INFO_COOP_BATTLE_POINTS_RULES":
      return dotaChatInformational.INFO_COOP_BATTLE_POINTS_RULES;
    case 2:
    case "INFO_FROSTIVUS_ABANDON_REMINDER":
      return dotaChatInformational.INFO_FROSTIVUS_ABANDON_REMINDER;
    case 3:
    case "INFO_RANKED_REMINDER":
      return dotaChatInformational.INFO_RANKED_REMINDER;
    case 4:
    case "INFO_COOP_LOW_PRIORITY_PASSIVE_REMINDER":
      return dotaChatInformational.INFO_COOP_LOW_PRIORITY_PASSIVE_REMINDER;
    case 5:
    case "INFO_CUSTOM_GAME_PENALTY_REMINDER":
      return dotaChatInformational.INFO_CUSTOM_GAME_PENALTY_REMINDER;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum dotaChatInformational");
  }
}

export function dotaChatInformationalToJSON(object: dotaChatInformational): string {
  switch (object) {
    case dotaChatInformational.INFO_COOP_BATTLE_POINTS_RULES:
      return "INFO_COOP_BATTLE_POINTS_RULES";
    case dotaChatInformational.INFO_FROSTIVUS_ABANDON_REMINDER:
      return "INFO_FROSTIVUS_ABANDON_REMINDER";
    case dotaChatInformational.INFO_RANKED_REMINDER:
      return "INFO_RANKED_REMINDER";
    case dotaChatInformational.INFO_COOP_LOW_PRIORITY_PASSIVE_REMINDER:
      return "INFO_COOP_LOW_PRIORITY_PASSIVE_REMINDER";
    case dotaChatInformational.INFO_CUSTOM_GAME_PENALTY_REMINDER:
      return "INFO_CUSTOM_GAME_PENALTY_REMINDER";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum dotaChatInformational");
  }
}

export enum dotaAbilityPingType {
  ABILITY_PING_READY = 1,
  ABILITY_PING_MANA = 2,
  ABILITY_PING_COOLDOWN = 3,
  ABILITY_PING_ENEMY = 4,
  ABILITY_PING_UNLEARNED = 5,
  ABILITY_PING_INBACKPACK = 6,
  ABILITY_PING_INSTASH = 7,
  ABILITY_PING_ONCOURIER = 8,
  ABILITY_PING_ALLY = 9,
  ABILITY_PING_LEARN_READY = 10,
  ABILITY_PING_WILL_LEARN = 11,
  ABILITY_PING_FUTURE_LEARN = 12,
  ABILITY_PING_NEUTRAL_OFFER = 13,
  ABILITY_PING_NEUTRAL_REQUEST = 14,
  ABILITY_PING_NEUTRAL_EQUIP = 15,
  ABILITY_PING_INCOURIERBACKPACK = 16,
}

export function dotaAbilityPingTypeFromJSON(object: any): dotaAbilityPingType {
  switch (object) {
    case 1:
    case "ABILITY_PING_READY":
      return dotaAbilityPingType.ABILITY_PING_READY;
    case 2:
    case "ABILITY_PING_MANA":
      return dotaAbilityPingType.ABILITY_PING_MANA;
    case 3:
    case "ABILITY_PING_COOLDOWN":
      return dotaAbilityPingType.ABILITY_PING_COOLDOWN;
    case 4:
    case "ABILITY_PING_ENEMY":
      return dotaAbilityPingType.ABILITY_PING_ENEMY;
    case 5:
    case "ABILITY_PING_UNLEARNED":
      return dotaAbilityPingType.ABILITY_PING_UNLEARNED;
    case 6:
    case "ABILITY_PING_INBACKPACK":
      return dotaAbilityPingType.ABILITY_PING_INBACKPACK;
    case 7:
    case "ABILITY_PING_INSTASH":
      return dotaAbilityPingType.ABILITY_PING_INSTASH;
    case 8:
    case "ABILITY_PING_ONCOURIER":
      return dotaAbilityPingType.ABILITY_PING_ONCOURIER;
    case 9:
    case "ABILITY_PING_ALLY":
      return dotaAbilityPingType.ABILITY_PING_ALLY;
    case 10:
    case "ABILITY_PING_LEARN_READY":
      return dotaAbilityPingType.ABILITY_PING_LEARN_READY;
    case 11:
    case "ABILITY_PING_WILL_LEARN":
      return dotaAbilityPingType.ABILITY_PING_WILL_LEARN;
    case 12:
    case "ABILITY_PING_FUTURE_LEARN":
      return dotaAbilityPingType.ABILITY_PING_FUTURE_LEARN;
    case 13:
    case "ABILITY_PING_NEUTRAL_OFFER":
      return dotaAbilityPingType.ABILITY_PING_NEUTRAL_OFFER;
    case 14:
    case "ABILITY_PING_NEUTRAL_REQUEST":
      return dotaAbilityPingType.ABILITY_PING_NEUTRAL_REQUEST;
    case 15:
    case "ABILITY_PING_NEUTRAL_EQUIP":
      return dotaAbilityPingType.ABILITY_PING_NEUTRAL_EQUIP;
    case 16:
    case "ABILITY_PING_INCOURIERBACKPACK":
      return dotaAbilityPingType.ABILITY_PING_INCOURIERBACKPACK;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum dotaAbilityPingType");
  }
}

export function dotaAbilityPingTypeToJSON(object: dotaAbilityPingType): string {
  switch (object) {
    case dotaAbilityPingType.ABILITY_PING_READY:
      return "ABILITY_PING_READY";
    case dotaAbilityPingType.ABILITY_PING_MANA:
      return "ABILITY_PING_MANA";
    case dotaAbilityPingType.ABILITY_PING_COOLDOWN:
      return "ABILITY_PING_COOLDOWN";
    case dotaAbilityPingType.ABILITY_PING_ENEMY:
      return "ABILITY_PING_ENEMY";
    case dotaAbilityPingType.ABILITY_PING_UNLEARNED:
      return "ABILITY_PING_UNLEARNED";
    case dotaAbilityPingType.ABILITY_PING_INBACKPACK:
      return "ABILITY_PING_INBACKPACK";
    case dotaAbilityPingType.ABILITY_PING_INSTASH:
      return "ABILITY_PING_INSTASH";
    case dotaAbilityPingType.ABILITY_PING_ONCOURIER:
      return "ABILITY_PING_ONCOURIER";
    case dotaAbilityPingType.ABILITY_PING_ALLY:
      return "ABILITY_PING_ALLY";
    case dotaAbilityPingType.ABILITY_PING_LEARN_READY:
      return "ABILITY_PING_LEARN_READY";
    case dotaAbilityPingType.ABILITY_PING_WILL_LEARN:
      return "ABILITY_PING_WILL_LEARN";
    case dotaAbilityPingType.ABILITY_PING_FUTURE_LEARN:
      return "ABILITY_PING_FUTURE_LEARN";
    case dotaAbilityPingType.ABILITY_PING_NEUTRAL_OFFER:
      return "ABILITY_PING_NEUTRAL_OFFER";
    case dotaAbilityPingType.ABILITY_PING_NEUTRAL_REQUEST:
      return "ABILITY_PING_NEUTRAL_REQUEST";
    case dotaAbilityPingType.ABILITY_PING_NEUTRAL_EQUIP:
      return "ABILITY_PING_NEUTRAL_EQUIP";
    case dotaAbilityPingType.ABILITY_PING_INCOURIERBACKPACK:
      return "ABILITY_PING_INCOURIERBACKPACK";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum dotaAbilityPingType");
  }
}

export enum dotaReplayStateEvent {
  DOTA_REPLAY_STATE_EVENT_GAME_START = 1,
  DOTA_REPLAY_STATE_EVENT_STARTING_HORN = 2,
  DOTA_REPLAY_STATE_EVENT_FIRST_BLOOD = 3,
  DOTA_REPLAY_STATE_EVENT_SHOWCASE = 4,
  DOTA_REPLAY_STATE_EVENT_POST_GAME = 5,
  DOTA_REPLAY_STATE_EVENT_WAIT_FOR_MAP = 6,
}

export function dotaReplayStateEventFromJSON(object: any): dotaReplayStateEvent {
  switch (object) {
    case 1:
    case "DOTA_REPLAY_STATE_EVENT_GAME_START":
      return dotaReplayStateEvent.DOTA_REPLAY_STATE_EVENT_GAME_START;
    case 2:
    case "DOTA_REPLAY_STATE_EVENT_STARTING_HORN":
      return dotaReplayStateEvent.DOTA_REPLAY_STATE_EVENT_STARTING_HORN;
    case 3:
    case "DOTA_REPLAY_STATE_EVENT_FIRST_BLOOD":
      return dotaReplayStateEvent.DOTA_REPLAY_STATE_EVENT_FIRST_BLOOD;
    case 4:
    case "DOTA_REPLAY_STATE_EVENT_SHOWCASE":
      return dotaReplayStateEvent.DOTA_REPLAY_STATE_EVENT_SHOWCASE;
    case 5:
    case "DOTA_REPLAY_STATE_EVENT_POST_GAME":
      return dotaReplayStateEvent.DOTA_REPLAY_STATE_EVENT_POST_GAME;
    case 6:
    case "DOTA_REPLAY_STATE_EVENT_WAIT_FOR_MAP":
      return dotaReplayStateEvent.DOTA_REPLAY_STATE_EVENT_WAIT_FOR_MAP;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum dotaReplayStateEvent");
  }
}

export function dotaReplayStateEventToJSON(object: dotaReplayStateEvent): string {
  switch (object) {
    case dotaReplayStateEvent.DOTA_REPLAY_STATE_EVENT_GAME_START:
      return "DOTA_REPLAY_STATE_EVENT_GAME_START";
    case dotaReplayStateEvent.DOTA_REPLAY_STATE_EVENT_STARTING_HORN:
      return "DOTA_REPLAY_STATE_EVENT_STARTING_HORN";
    case dotaReplayStateEvent.DOTA_REPLAY_STATE_EVENT_FIRST_BLOOD:
      return "DOTA_REPLAY_STATE_EVENT_FIRST_BLOOD";
    case dotaReplayStateEvent.DOTA_REPLAY_STATE_EVENT_SHOWCASE:
      return "DOTA_REPLAY_STATE_EVENT_SHOWCASE";
    case dotaReplayStateEvent.DOTA_REPLAY_STATE_EVENT_POST_GAME:
      return "DOTA_REPLAY_STATE_EVENT_POST_GAME";
    case dotaReplayStateEvent.DOTA_REPLAY_STATE_EVENT_WAIT_FOR_MAP:
      return "DOTA_REPLAY_STATE_EVENT_WAIT_FOR_MAP";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum dotaReplayStateEvent");
  }
}

export enum EDotaEntityMessages {
  DOTA_UNIT_SPEECH = 0,
  DOTA_UNIT_SPEECH_MUTE = 1,
  DOTA_UNIT_ADD_GESTURE = 2,
  DOTA_UNIT_REMOVE_GESTURE = 3,
  DOTA_UNIT_REMOVE_ALL_GESTURES = 4,
  DOTA_UNIT_FADE_GESTURE = 6,
  DOTA_UNIT_SPEECH_CLIENTSIDE_RULES = 7,
}

export function eDotaEntityMessagesFromJSON(object: any): EDotaEntityMessages {
  switch (object) {
    case 0:
    case "DOTA_UNIT_SPEECH":
      return EDotaEntityMessages.DOTA_UNIT_SPEECH;
    case 1:
    case "DOTA_UNIT_SPEECH_MUTE":
      return EDotaEntityMessages.DOTA_UNIT_SPEECH_MUTE;
    case 2:
    case "DOTA_UNIT_ADD_GESTURE":
      return EDotaEntityMessages.DOTA_UNIT_ADD_GESTURE;
    case 3:
    case "DOTA_UNIT_REMOVE_GESTURE":
      return EDotaEntityMessages.DOTA_UNIT_REMOVE_GESTURE;
    case 4:
    case "DOTA_UNIT_REMOVE_ALL_GESTURES":
      return EDotaEntityMessages.DOTA_UNIT_REMOVE_ALL_GESTURES;
    case 6:
    case "DOTA_UNIT_FADE_GESTURE":
      return EDotaEntityMessages.DOTA_UNIT_FADE_GESTURE;
    case 7:
    case "DOTA_UNIT_SPEECH_CLIENTSIDE_RULES":
      return EDotaEntityMessages.DOTA_UNIT_SPEECH_CLIENTSIDE_RULES;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum EDotaEntityMessages");
  }
}

export function eDotaEntityMessagesToJSON(object: EDotaEntityMessages): string {
  switch (object) {
    case EDotaEntityMessages.DOTA_UNIT_SPEECH:
      return "DOTA_UNIT_SPEECH";
    case EDotaEntityMessages.DOTA_UNIT_SPEECH_MUTE:
      return "DOTA_UNIT_SPEECH_MUTE";
    case EDotaEntityMessages.DOTA_UNIT_ADD_GESTURE:
      return "DOTA_UNIT_ADD_GESTURE";
    case EDotaEntityMessages.DOTA_UNIT_REMOVE_GESTURE:
      return "DOTA_UNIT_REMOVE_GESTURE";
    case EDotaEntityMessages.DOTA_UNIT_REMOVE_ALL_GESTURES:
      return "DOTA_UNIT_REMOVE_ALL_GESTURES";
    case EDotaEntityMessages.DOTA_UNIT_FADE_GESTURE:
      return "DOTA_UNIT_FADE_GESTURE";
    case EDotaEntityMessages.DOTA_UNIT_SPEECH_CLIENTSIDE_RULES:
      return "DOTA_UNIT_SPEECH_CLIENTSIDE_RULES";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum EDotaEntityMessages");
  }
}

export enum dotaOverheadAlert {
  OVERHEAD_ALERT_GOLD = 0,
  OVERHEAD_ALERT_DENY = 1,
  OVERHEAD_ALERT_CRITICAL = 2,
  OVERHEAD_ALERT_XP = 3,
  OVERHEAD_ALERT_BONUS_SPELL_DAMAGE = 4,
  OVERHEAD_ALERT_MISS = 5,
  OVERHEAD_ALERT_DAMAGE = 6,
  OVERHEAD_ALERT_EVADE = 7,
  OVERHEAD_ALERT_BLOCK = 8,
  OVERHEAD_ALERT_BONUS_POISON_DAMAGE = 9,
  OVERHEAD_ALERT_HEAL = 10,
  OVERHEAD_ALERT_MANA_ADD = 11,
  OVERHEAD_ALERT_MANA_LOSS = 12,
  OVERHEAD_ALERT_LAST_HIT_EARLY = 13,
  OVERHEAD_ALERT_LAST_HIT_CLOSE = 14,
  OVERHEAD_ALERT_LAST_HIT_MISS = 15,
  OVERHEAD_ALERT_MAGICAL_BLOCK = 16,
  OVERHEAD_ALERT_INCOMING_DAMAGE = 17,
  OVERHEAD_ALERT_OUTGOING_DAMAGE = 18,
  OVERHEAD_ALERT_DISABLE_RESIST = 19,
  OVERHEAD_ALERT_DEATH = 20,
  OVERHEAD_ALERT_BLOCKED = 21,
  OVERHEAD_ALERT_ITEM_RECEIVED = 22,
  OVERHEAD_ALERT_SHARD = 23,
  OVERHEAD_ALERT_DEADLY_BLOW = 24,
  OVERHEAD_ALERT_FORCE_MISS = 25,
}

export function dotaOverheadAlertFromJSON(object: any): dotaOverheadAlert {
  switch (object) {
    case 0:
    case "OVERHEAD_ALERT_GOLD":
      return dotaOverheadAlert.OVERHEAD_ALERT_GOLD;
    case 1:
    case "OVERHEAD_ALERT_DENY":
      return dotaOverheadAlert.OVERHEAD_ALERT_DENY;
    case 2:
    case "OVERHEAD_ALERT_CRITICAL":
      return dotaOverheadAlert.OVERHEAD_ALERT_CRITICAL;
    case 3:
    case "OVERHEAD_ALERT_XP":
      return dotaOverheadAlert.OVERHEAD_ALERT_XP;
    case 4:
    case "OVERHEAD_ALERT_BONUS_SPELL_DAMAGE":
      return dotaOverheadAlert.OVERHEAD_ALERT_BONUS_SPELL_DAMAGE;
    case 5:
    case "OVERHEAD_ALERT_MISS":
      return dotaOverheadAlert.OVERHEAD_ALERT_MISS;
    case 6:
    case "OVERHEAD_ALERT_DAMAGE":
      return dotaOverheadAlert.OVERHEAD_ALERT_DAMAGE;
    case 7:
    case "OVERHEAD_ALERT_EVADE":
      return dotaOverheadAlert.OVERHEAD_ALERT_EVADE;
    case 8:
    case "OVERHEAD_ALERT_BLOCK":
      return dotaOverheadAlert.OVERHEAD_ALERT_BLOCK;
    case 9:
    case "OVERHEAD_ALERT_BONUS_POISON_DAMAGE":
      return dotaOverheadAlert.OVERHEAD_ALERT_BONUS_POISON_DAMAGE;
    case 10:
    case "OVERHEAD_ALERT_HEAL":
      return dotaOverheadAlert.OVERHEAD_ALERT_HEAL;
    case 11:
    case "OVERHEAD_ALERT_MANA_ADD":
      return dotaOverheadAlert.OVERHEAD_ALERT_MANA_ADD;
    case 12:
    case "OVERHEAD_ALERT_MANA_LOSS":
      return dotaOverheadAlert.OVERHEAD_ALERT_MANA_LOSS;
    case 13:
    case "OVERHEAD_ALERT_LAST_HIT_EARLY":
      return dotaOverheadAlert.OVERHEAD_ALERT_LAST_HIT_EARLY;
    case 14:
    case "OVERHEAD_ALERT_LAST_HIT_CLOSE":
      return dotaOverheadAlert.OVERHEAD_ALERT_LAST_HIT_CLOSE;
    case 15:
    case "OVERHEAD_ALERT_LAST_HIT_MISS":
      return dotaOverheadAlert.OVERHEAD_ALERT_LAST_HIT_MISS;
    case 16:
    case "OVERHEAD_ALERT_MAGICAL_BLOCK":
      return dotaOverheadAlert.OVERHEAD_ALERT_MAGICAL_BLOCK;
    case 17:
    case "OVERHEAD_ALERT_INCOMING_DAMAGE":
      return dotaOverheadAlert.OVERHEAD_ALERT_INCOMING_DAMAGE;
    case 18:
    case "OVERHEAD_ALERT_OUTGOING_DAMAGE":
      return dotaOverheadAlert.OVERHEAD_ALERT_OUTGOING_DAMAGE;
    case 19:
    case "OVERHEAD_ALERT_DISABLE_RESIST":
      return dotaOverheadAlert.OVERHEAD_ALERT_DISABLE_RESIST;
    case 20:
    case "OVERHEAD_ALERT_DEATH":
      return dotaOverheadAlert.OVERHEAD_ALERT_DEATH;
    case 21:
    case "OVERHEAD_ALERT_BLOCKED":
      return dotaOverheadAlert.OVERHEAD_ALERT_BLOCKED;
    case 22:
    case "OVERHEAD_ALERT_ITEM_RECEIVED":
      return dotaOverheadAlert.OVERHEAD_ALERT_ITEM_RECEIVED;
    case 23:
    case "OVERHEAD_ALERT_SHARD":
      return dotaOverheadAlert.OVERHEAD_ALERT_SHARD;
    case 24:
    case "OVERHEAD_ALERT_DEADLY_BLOW":
      return dotaOverheadAlert.OVERHEAD_ALERT_DEADLY_BLOW;
    case 25:
    case "OVERHEAD_ALERT_FORCE_MISS":
      return dotaOverheadAlert.OVERHEAD_ALERT_FORCE_MISS;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum dotaOverheadAlert");
  }
}

export function dotaOverheadAlertToJSON(object: dotaOverheadAlert): string {
  switch (object) {
    case dotaOverheadAlert.OVERHEAD_ALERT_GOLD:
      return "OVERHEAD_ALERT_GOLD";
    case dotaOverheadAlert.OVERHEAD_ALERT_DENY:
      return "OVERHEAD_ALERT_DENY";
    case dotaOverheadAlert.OVERHEAD_ALERT_CRITICAL:
      return "OVERHEAD_ALERT_CRITICAL";
    case dotaOverheadAlert.OVERHEAD_ALERT_XP:
      return "OVERHEAD_ALERT_XP";
    case dotaOverheadAlert.OVERHEAD_ALERT_BONUS_SPELL_DAMAGE:
      return "OVERHEAD_ALERT_BONUS_SPELL_DAMAGE";
    case dotaOverheadAlert.OVERHEAD_ALERT_MISS:
      return "OVERHEAD_ALERT_MISS";
    case dotaOverheadAlert.OVERHEAD_ALERT_DAMAGE:
      return "OVERHEAD_ALERT_DAMAGE";
    case dotaOverheadAlert.OVERHEAD_ALERT_EVADE:
      return "OVERHEAD_ALERT_EVADE";
    case dotaOverheadAlert.OVERHEAD_ALERT_BLOCK:
      return "OVERHEAD_ALERT_BLOCK";
    case dotaOverheadAlert.OVERHEAD_ALERT_BONUS_POISON_DAMAGE:
      return "OVERHEAD_ALERT_BONUS_POISON_DAMAGE";
    case dotaOverheadAlert.OVERHEAD_ALERT_HEAL:
      return "OVERHEAD_ALERT_HEAL";
    case dotaOverheadAlert.OVERHEAD_ALERT_MANA_ADD:
      return "OVERHEAD_ALERT_MANA_ADD";
    case dotaOverheadAlert.OVERHEAD_ALERT_MANA_LOSS:
      return "OVERHEAD_ALERT_MANA_LOSS";
    case dotaOverheadAlert.OVERHEAD_ALERT_LAST_HIT_EARLY:
      return "OVERHEAD_ALERT_LAST_HIT_EARLY";
    case dotaOverheadAlert.OVERHEAD_ALERT_LAST_HIT_CLOSE:
      return "OVERHEAD_ALERT_LAST_HIT_CLOSE";
    case dotaOverheadAlert.OVERHEAD_ALERT_LAST_HIT_MISS:
      return "OVERHEAD_ALERT_LAST_HIT_MISS";
    case dotaOverheadAlert.OVERHEAD_ALERT_MAGICAL_BLOCK:
      return "OVERHEAD_ALERT_MAGICAL_BLOCK";
    case dotaOverheadAlert.OVERHEAD_ALERT_INCOMING_DAMAGE:
      return "OVERHEAD_ALERT_INCOMING_DAMAGE";
    case dotaOverheadAlert.OVERHEAD_ALERT_OUTGOING_DAMAGE:
      return "OVERHEAD_ALERT_OUTGOING_DAMAGE";
    case dotaOverheadAlert.OVERHEAD_ALERT_DISABLE_RESIST:
      return "OVERHEAD_ALERT_DISABLE_RESIST";
    case dotaOverheadAlert.OVERHEAD_ALERT_DEATH:
      return "OVERHEAD_ALERT_DEATH";
    case dotaOverheadAlert.OVERHEAD_ALERT_BLOCKED:
      return "OVERHEAD_ALERT_BLOCKED";
    case dotaOverheadAlert.OVERHEAD_ALERT_ITEM_RECEIVED:
      return "OVERHEAD_ALERT_ITEM_RECEIVED";
    case dotaOverheadAlert.OVERHEAD_ALERT_SHARD:
      return "OVERHEAD_ALERT_SHARD";
    case dotaOverheadAlert.OVERHEAD_ALERT_DEADLY_BLOW:
      return "OVERHEAD_ALERT_DEADLY_BLOW";
    case dotaOverheadAlert.OVERHEAD_ALERT_FORCE_MISS:
      return "OVERHEAD_ALERT_FORCE_MISS";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum dotaOverheadAlert");
  }
}

export enum dotaRoshanPhase {
  k_SRSP_ROSHAN_ALIVE = 0,
  k_SRSP_ROSHAN_BASE_TIMER = 1,
  k_SRSP_ROSHAN_VISIBLE_TIMER = 2,
}

export function dotaRoshanPhaseFromJSON(object: any): dotaRoshanPhase {
  switch (object) {
    case 0:
    case "k_SRSP_ROSHAN_ALIVE":
      return dotaRoshanPhase.k_SRSP_ROSHAN_ALIVE;
    case 1:
    case "k_SRSP_ROSHAN_BASE_TIMER":
      return dotaRoshanPhase.k_SRSP_ROSHAN_BASE_TIMER;
    case 2:
    case "k_SRSP_ROSHAN_VISIBLE_TIMER":
      return dotaRoshanPhase.k_SRSP_ROSHAN_VISIBLE_TIMER;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum dotaRoshanPhase");
  }
}

export function dotaRoshanPhaseToJSON(object: dotaRoshanPhase): string {
  switch (object) {
    case dotaRoshanPhase.k_SRSP_ROSHAN_ALIVE:
      return "k_SRSP_ROSHAN_ALIVE";
    case dotaRoshanPhase.k_SRSP_ROSHAN_BASE_TIMER:
      return "k_SRSP_ROSHAN_BASE_TIMER";
    case dotaRoshanPhase.k_SRSP_ROSHAN_VISIBLE_TIMER:
      return "k_SRSP_ROSHAN_VISIBLE_TIMER";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum dotaRoshanPhase");
  }
}

export enum dotaPositionCategory {
  DOTA_POSITION_NONE = 0,
  DOTA_POSITION_BOTTOM_LANE = 1,
  DOTA_POSITION_MID_LANE = 2,
  DOTA_POSITION_TOP_LANE = 3,
  DOTA_POSITION_RADIANT_JUNGLE = 4,
  DOTA_POSITION_DIRE_JUNGLE = 5,
  DOTA_POSITION_RADIANT_ANCIENTS = 6,
  DOTA_POSITION_DIRE_ANCIENTS = 7,
  DOTA_POSITION_RADIANT_SECRET_SHOP = 8,
  DOTA_POSITION_DIRE_SECRET_SHOP = 9,
  DOTA_POSITION_RIVER = 10,
  DOTA_POSITION_ROSHAN_PIT = 11,
  DOTA_POSITION_RADIANT_BASE = 12,
  DOTA_POSITION_DIRE_BASE = 13,
  DOTA_POSITION_FOUNTAIN = 14,
  DOTA_POSITION_OTHER = 15,
}

export function dotaPositionCategoryFromJSON(object: any): dotaPositionCategory {
  switch (object) {
    case 0:
    case "DOTA_POSITION_NONE":
      return dotaPositionCategory.DOTA_POSITION_NONE;
    case 1:
    case "DOTA_POSITION_BOTTOM_LANE":
      return dotaPositionCategory.DOTA_POSITION_BOTTOM_LANE;
    case 2:
    case "DOTA_POSITION_MID_LANE":
      return dotaPositionCategory.DOTA_POSITION_MID_LANE;
    case 3:
    case "DOTA_POSITION_TOP_LANE":
      return dotaPositionCategory.DOTA_POSITION_TOP_LANE;
    case 4:
    case "DOTA_POSITION_RADIANT_JUNGLE":
      return dotaPositionCategory.DOTA_POSITION_RADIANT_JUNGLE;
    case 5:
    case "DOTA_POSITION_DIRE_JUNGLE":
      return dotaPositionCategory.DOTA_POSITION_DIRE_JUNGLE;
    case 6:
    case "DOTA_POSITION_RADIANT_ANCIENTS":
      return dotaPositionCategory.DOTA_POSITION_RADIANT_ANCIENTS;
    case 7:
    case "DOTA_POSITION_DIRE_ANCIENTS":
      return dotaPositionCategory.DOTA_POSITION_DIRE_ANCIENTS;
    case 8:
    case "DOTA_POSITION_RADIANT_SECRET_SHOP":
      return dotaPositionCategory.DOTA_POSITION_RADIANT_SECRET_SHOP;
    case 9:
    case "DOTA_POSITION_DIRE_SECRET_SHOP":
      return dotaPositionCategory.DOTA_POSITION_DIRE_SECRET_SHOP;
    case 10:
    case "DOTA_POSITION_RIVER":
      return dotaPositionCategory.DOTA_POSITION_RIVER;
    case 11:
    case "DOTA_POSITION_ROSHAN_PIT":
      return dotaPositionCategory.DOTA_POSITION_ROSHAN_PIT;
    case 12:
    case "DOTA_POSITION_RADIANT_BASE":
      return dotaPositionCategory.DOTA_POSITION_RADIANT_BASE;
    case 13:
    case "DOTA_POSITION_DIRE_BASE":
      return dotaPositionCategory.DOTA_POSITION_DIRE_BASE;
    case 14:
    case "DOTA_POSITION_FOUNTAIN":
      return dotaPositionCategory.DOTA_POSITION_FOUNTAIN;
    case 15:
    case "DOTA_POSITION_OTHER":
      return dotaPositionCategory.DOTA_POSITION_OTHER;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum dotaPositionCategory");
  }
}

export function dotaPositionCategoryToJSON(object: dotaPositionCategory): string {
  switch (object) {
    case dotaPositionCategory.DOTA_POSITION_NONE:
      return "DOTA_POSITION_NONE";
    case dotaPositionCategory.DOTA_POSITION_BOTTOM_LANE:
      return "DOTA_POSITION_BOTTOM_LANE";
    case dotaPositionCategory.DOTA_POSITION_MID_LANE:
      return "DOTA_POSITION_MID_LANE";
    case dotaPositionCategory.DOTA_POSITION_TOP_LANE:
      return "DOTA_POSITION_TOP_LANE";
    case dotaPositionCategory.DOTA_POSITION_RADIANT_JUNGLE:
      return "DOTA_POSITION_RADIANT_JUNGLE";
    case dotaPositionCategory.DOTA_POSITION_DIRE_JUNGLE:
      return "DOTA_POSITION_DIRE_JUNGLE";
    case dotaPositionCategory.DOTA_POSITION_RADIANT_ANCIENTS:
      return "DOTA_POSITION_RADIANT_ANCIENTS";
    case dotaPositionCategory.DOTA_POSITION_DIRE_ANCIENTS:
      return "DOTA_POSITION_DIRE_ANCIENTS";
    case dotaPositionCategory.DOTA_POSITION_RADIANT_SECRET_SHOP:
      return "DOTA_POSITION_RADIANT_SECRET_SHOP";
    case dotaPositionCategory.DOTA_POSITION_DIRE_SECRET_SHOP:
      return "DOTA_POSITION_DIRE_SECRET_SHOP";
    case dotaPositionCategory.DOTA_POSITION_RIVER:
      return "DOTA_POSITION_RIVER";
    case dotaPositionCategory.DOTA_POSITION_ROSHAN_PIT:
      return "DOTA_POSITION_ROSHAN_PIT";
    case dotaPositionCategory.DOTA_POSITION_RADIANT_BASE:
      return "DOTA_POSITION_RADIANT_BASE";
    case dotaPositionCategory.DOTA_POSITION_DIRE_BASE:
      return "DOTA_POSITION_DIRE_BASE";
    case dotaPositionCategory.DOTA_POSITION_FOUNTAIN:
      return "DOTA_POSITION_FOUNTAIN";
    case dotaPositionCategory.DOTA_POSITION_OTHER:
      return "DOTA_POSITION_OTHER";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum dotaPositionCategory");
  }
}

export enum dotaAbilityTargetType {
  DOTA_ABILITY_TARGET_NONE = 0,
  DOTA_ABILITY_TARGET_SELF = 1,
  DOTA_ABILITY_TARGET_ALLY_HERO = 2,
  DOTA_ABILITY_TARGET_ALLY_CREEP = 3,
  DOTA_ABILITY_TARGET_ENEMY_HERO = 4,
  DOTA_ABILITY_TARGET_ENEMY_CREEP = 5,
}

export function dotaAbilityTargetTypeFromJSON(object: any): dotaAbilityTargetType {
  switch (object) {
    case 0:
    case "DOTA_ABILITY_TARGET_NONE":
      return dotaAbilityTargetType.DOTA_ABILITY_TARGET_NONE;
    case 1:
    case "DOTA_ABILITY_TARGET_SELF":
      return dotaAbilityTargetType.DOTA_ABILITY_TARGET_SELF;
    case 2:
    case "DOTA_ABILITY_TARGET_ALLY_HERO":
      return dotaAbilityTargetType.DOTA_ABILITY_TARGET_ALLY_HERO;
    case 3:
    case "DOTA_ABILITY_TARGET_ALLY_CREEP":
      return dotaAbilityTargetType.DOTA_ABILITY_TARGET_ALLY_CREEP;
    case 4:
    case "DOTA_ABILITY_TARGET_ENEMY_HERO":
      return dotaAbilityTargetType.DOTA_ABILITY_TARGET_ENEMY_HERO;
    case 5:
    case "DOTA_ABILITY_TARGET_ENEMY_CREEP":
      return dotaAbilityTargetType.DOTA_ABILITY_TARGET_ENEMY_CREEP;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum dotaAbilityTargetType");
  }
}

export function dotaAbilityTargetTypeToJSON(object: dotaAbilityTargetType): string {
  switch (object) {
    case dotaAbilityTargetType.DOTA_ABILITY_TARGET_NONE:
      return "DOTA_ABILITY_TARGET_NONE";
    case dotaAbilityTargetType.DOTA_ABILITY_TARGET_SELF:
      return "DOTA_ABILITY_TARGET_SELF";
    case dotaAbilityTargetType.DOTA_ABILITY_TARGET_ALLY_HERO:
      return "DOTA_ABILITY_TARGET_ALLY_HERO";
    case dotaAbilityTargetType.DOTA_ABILITY_TARGET_ALLY_CREEP:
      return "DOTA_ABILITY_TARGET_ALLY_CREEP";
    case dotaAbilityTargetType.DOTA_ABILITY_TARGET_ENEMY_HERO:
      return "DOTA_ABILITY_TARGET_ENEMY_HERO";
    case dotaAbilityTargetType.DOTA_ABILITY_TARGET_ENEMY_CREEP:
      return "DOTA_ABILITY_TARGET_ENEMY_CREEP";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum dotaAbilityTargetType");
  }
}

export enum EHeroStatType {
  k_EHeroStatType_None = 0,
  k_EHeroStatType_AxeTotalDamage = 2000,
  k_EHeroStatType_BattleHungerDamage = 2001,
  k_EHeroStatType_CounterHelixDamage = 2002,
  k_EHeroStatType_CullingBladeDamage = 2003,
  k_EHeroStatType_BerserkersCallCastCount = 2004,
  k_EHeroStatType_BerserkersCallHeroesHitAverage = 2005,
  k_EHeroStatType_BerserkersCallOtherUnitsHit = 2006,
  k_EHeroStatType_BerserkersCallHeroAttacksTaken = 2007,
  k_EHeroStatType_BerserkersCallOtherAttacksTaken = 2008,
  k_EHeroStatType_BattleHungerCastCount = 2009,
  k_EHeroStatType_BattleHungerPotentialDuration = 2010,
  k_EHeroStatType_BattleHungerAverageDuration = 2011,
  k_EHeroStatType_CounterHelixProcCount = 2012,
  k_EHeroStatType_CounterHelixHeroProcCount = 2013,
  k_EHeroStatType_CounterHelixHeroesHitAverage = 2014,
  k_EHeroStatType_CounterHelixOtherUnitsHitCount = 2015,
  k_EHeroStatType_CullingBladeCastCount = 2016,
  k_EHeroStatType_CullingBladeKillCount = 2017,
  k_EHeroStatType_CullingBladeAverageHealthCulled = 2018,
  k_EHeroStatType_CullingBladeAverageDamageAvailable = 2019,
  k_EHeroStatType_CullingBladeHeroBuffAverage = 2020,
}

export function eHeroStatTypeFromJSON(object: any): EHeroStatType {
  switch (object) {
    case 0:
    case "k_EHeroStatType_None":
      return EHeroStatType.k_EHeroStatType_None;
    case 2000:
    case "k_EHeroStatType_AxeTotalDamage":
      return EHeroStatType.k_EHeroStatType_AxeTotalDamage;
    case 2001:
    case "k_EHeroStatType_BattleHungerDamage":
      return EHeroStatType.k_EHeroStatType_BattleHungerDamage;
    case 2002:
    case "k_EHeroStatType_CounterHelixDamage":
      return EHeroStatType.k_EHeroStatType_CounterHelixDamage;
    case 2003:
    case "k_EHeroStatType_CullingBladeDamage":
      return EHeroStatType.k_EHeroStatType_CullingBladeDamage;
    case 2004:
    case "k_EHeroStatType_BerserkersCallCastCount":
      return EHeroStatType.k_EHeroStatType_BerserkersCallCastCount;
    case 2005:
    case "k_EHeroStatType_BerserkersCallHeroesHitAverage":
      return EHeroStatType.k_EHeroStatType_BerserkersCallHeroesHitAverage;
    case 2006:
    case "k_EHeroStatType_BerserkersCallOtherUnitsHit":
      return EHeroStatType.k_EHeroStatType_BerserkersCallOtherUnitsHit;
    case 2007:
    case "k_EHeroStatType_BerserkersCallHeroAttacksTaken":
      return EHeroStatType.k_EHeroStatType_BerserkersCallHeroAttacksTaken;
    case 2008:
    case "k_EHeroStatType_BerserkersCallOtherAttacksTaken":
      return EHeroStatType.k_EHeroStatType_BerserkersCallOtherAttacksTaken;
    case 2009:
    case "k_EHeroStatType_BattleHungerCastCount":
      return EHeroStatType.k_EHeroStatType_BattleHungerCastCount;
    case 2010:
    case "k_EHeroStatType_BattleHungerPotentialDuration":
      return EHeroStatType.k_EHeroStatType_BattleHungerPotentialDuration;
    case 2011:
    case "k_EHeroStatType_BattleHungerAverageDuration":
      return EHeroStatType.k_EHeroStatType_BattleHungerAverageDuration;
    case 2012:
    case "k_EHeroStatType_CounterHelixProcCount":
      return EHeroStatType.k_EHeroStatType_CounterHelixProcCount;
    case 2013:
    case "k_EHeroStatType_CounterHelixHeroProcCount":
      return EHeroStatType.k_EHeroStatType_CounterHelixHeroProcCount;
    case 2014:
    case "k_EHeroStatType_CounterHelixHeroesHitAverage":
      return EHeroStatType.k_EHeroStatType_CounterHelixHeroesHitAverage;
    case 2015:
    case "k_EHeroStatType_CounterHelixOtherUnitsHitCount":
      return EHeroStatType.k_EHeroStatType_CounterHelixOtherUnitsHitCount;
    case 2016:
    case "k_EHeroStatType_CullingBladeCastCount":
      return EHeroStatType.k_EHeroStatType_CullingBladeCastCount;
    case 2017:
    case "k_EHeroStatType_CullingBladeKillCount":
      return EHeroStatType.k_EHeroStatType_CullingBladeKillCount;
    case 2018:
    case "k_EHeroStatType_CullingBladeAverageHealthCulled":
      return EHeroStatType.k_EHeroStatType_CullingBladeAverageHealthCulled;
    case 2019:
    case "k_EHeroStatType_CullingBladeAverageDamageAvailable":
      return EHeroStatType.k_EHeroStatType_CullingBladeAverageDamageAvailable;
    case 2020:
    case "k_EHeroStatType_CullingBladeHeroBuffAverage":
      return EHeroStatType.k_EHeroStatType_CullingBladeHeroBuffAverage;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum EHeroStatType");
  }
}

export function eHeroStatTypeToJSON(object: EHeroStatType): string {
  switch (object) {
    case EHeroStatType.k_EHeroStatType_None:
      return "k_EHeroStatType_None";
    case EHeroStatType.k_EHeroStatType_AxeTotalDamage:
      return "k_EHeroStatType_AxeTotalDamage";
    case EHeroStatType.k_EHeroStatType_BattleHungerDamage:
      return "k_EHeroStatType_BattleHungerDamage";
    case EHeroStatType.k_EHeroStatType_CounterHelixDamage:
      return "k_EHeroStatType_CounterHelixDamage";
    case EHeroStatType.k_EHeroStatType_CullingBladeDamage:
      return "k_EHeroStatType_CullingBladeDamage";
    case EHeroStatType.k_EHeroStatType_BerserkersCallCastCount:
      return "k_EHeroStatType_BerserkersCallCastCount";
    case EHeroStatType.k_EHeroStatType_BerserkersCallHeroesHitAverage:
      return "k_EHeroStatType_BerserkersCallHeroesHitAverage";
    case EHeroStatType.k_EHeroStatType_BerserkersCallOtherUnitsHit:
      return "k_EHeroStatType_BerserkersCallOtherUnitsHit";
    case EHeroStatType.k_EHeroStatType_BerserkersCallHeroAttacksTaken:
      return "k_EHeroStatType_BerserkersCallHeroAttacksTaken";
    case EHeroStatType.k_EHeroStatType_BerserkersCallOtherAttacksTaken:
      return "k_EHeroStatType_BerserkersCallOtherAttacksTaken";
    case EHeroStatType.k_EHeroStatType_BattleHungerCastCount:
      return "k_EHeroStatType_BattleHungerCastCount";
    case EHeroStatType.k_EHeroStatType_BattleHungerPotentialDuration:
      return "k_EHeroStatType_BattleHungerPotentialDuration";
    case EHeroStatType.k_EHeroStatType_BattleHungerAverageDuration:
      return "k_EHeroStatType_BattleHungerAverageDuration";
    case EHeroStatType.k_EHeroStatType_CounterHelixProcCount:
      return "k_EHeroStatType_CounterHelixProcCount";
    case EHeroStatType.k_EHeroStatType_CounterHelixHeroProcCount:
      return "k_EHeroStatType_CounterHelixHeroProcCount";
    case EHeroStatType.k_EHeroStatType_CounterHelixHeroesHitAverage:
      return "k_EHeroStatType_CounterHelixHeroesHitAverage";
    case EHeroStatType.k_EHeroStatType_CounterHelixOtherUnitsHitCount:
      return "k_EHeroStatType_CounterHelixOtherUnitsHitCount";
    case EHeroStatType.k_EHeroStatType_CullingBladeCastCount:
      return "k_EHeroStatType_CullingBladeCastCount";
    case EHeroStatType.k_EHeroStatType_CullingBladeKillCount:
      return "k_EHeroStatType_CullingBladeKillCount";
    case EHeroStatType.k_EHeroStatType_CullingBladeAverageHealthCulled:
      return "k_EHeroStatType_CullingBladeAverageHealthCulled";
    case EHeroStatType.k_EHeroStatType_CullingBladeAverageDamageAvailable:
      return "k_EHeroStatType_CullingBladeAverageDamageAvailable";
    case EHeroStatType.k_EHeroStatType_CullingBladeHeroBuffAverage:
      return "k_EHeroStatType_CullingBladeHeroBuffAverage";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum EHeroStatType");
  }
}

export enum EPlayerVoiceListenState {
  kPVLS_None = 0,
  kPVLS_DeniedChatBanned = 1,
  kPVLS_DeniedPartner = 2,
  kPVLS_DeniedHLTVTalkerNotSpectator = 3,
  kPVLS_DeniedHLTVNoTalkerPlayerID = 4,
  kPVLS_DeniedHLTVTalkerNotBroadcaster = 5,
  kPVLS_DeniedTeamSpectator = 6,
  kPVLS_DeniedStudent = 8,
  kPVLS_DeniedPrivateCoach = 9,
  kPVLS_Denied = 64,
  kPVLS_AllowHLTVTalkerIsBroadcaster = 65,
  kPVLS_AllowCoBroadcaster = 66,
  kPVLS_AllowAllChat = 67,
  kPVLS_AllowStudentToCoach = 68,
  kPVLS_AllowFellowStudent = 69,
  kPVLS_AllowTalkerIsCoach = 70,
  kPVLS_AllowCoachHearTeam = 71,
  kPVLS_AllowSameTeam = 72,
  kPVLS_AllowShowcase = 73,
  kPVLS_AllowPrivateCoach = 74,
}

export function ePlayerVoiceListenStateFromJSON(object: any): EPlayerVoiceListenState {
  switch (object) {
    case 0:
    case "kPVLS_None":
      return EPlayerVoiceListenState.kPVLS_None;
    case 1:
    case "kPVLS_DeniedChatBanned":
      return EPlayerVoiceListenState.kPVLS_DeniedChatBanned;
    case 2:
    case "kPVLS_DeniedPartner":
      return EPlayerVoiceListenState.kPVLS_DeniedPartner;
    case 3:
    case "kPVLS_DeniedHLTVTalkerNotSpectator":
      return EPlayerVoiceListenState.kPVLS_DeniedHLTVTalkerNotSpectator;
    case 4:
    case "kPVLS_DeniedHLTVNoTalkerPlayerID":
      return EPlayerVoiceListenState.kPVLS_DeniedHLTVNoTalkerPlayerID;
    case 5:
    case "kPVLS_DeniedHLTVTalkerNotBroadcaster":
      return EPlayerVoiceListenState.kPVLS_DeniedHLTVTalkerNotBroadcaster;
    case 6:
    case "kPVLS_DeniedTeamSpectator":
      return EPlayerVoiceListenState.kPVLS_DeniedTeamSpectator;
    case 8:
    case "kPVLS_DeniedStudent":
      return EPlayerVoiceListenState.kPVLS_DeniedStudent;
    case 9:
    case "kPVLS_DeniedPrivateCoach":
      return EPlayerVoiceListenState.kPVLS_DeniedPrivateCoach;
    case 64:
    case "kPVLS_Denied":
      return EPlayerVoiceListenState.kPVLS_Denied;
    case 65:
    case "kPVLS_AllowHLTVTalkerIsBroadcaster":
      return EPlayerVoiceListenState.kPVLS_AllowHLTVTalkerIsBroadcaster;
    case 66:
    case "kPVLS_AllowCoBroadcaster":
      return EPlayerVoiceListenState.kPVLS_AllowCoBroadcaster;
    case 67:
    case "kPVLS_AllowAllChat":
      return EPlayerVoiceListenState.kPVLS_AllowAllChat;
    case 68:
    case "kPVLS_AllowStudentToCoach":
      return EPlayerVoiceListenState.kPVLS_AllowStudentToCoach;
    case 69:
    case "kPVLS_AllowFellowStudent":
      return EPlayerVoiceListenState.kPVLS_AllowFellowStudent;
    case 70:
    case "kPVLS_AllowTalkerIsCoach":
      return EPlayerVoiceListenState.kPVLS_AllowTalkerIsCoach;
    case 71:
    case "kPVLS_AllowCoachHearTeam":
      return EPlayerVoiceListenState.kPVLS_AllowCoachHearTeam;
    case 72:
    case "kPVLS_AllowSameTeam":
      return EPlayerVoiceListenState.kPVLS_AllowSameTeam;
    case 73:
    case "kPVLS_AllowShowcase":
      return EPlayerVoiceListenState.kPVLS_AllowShowcase;
    case 74:
    case "kPVLS_AllowPrivateCoach":
      return EPlayerVoiceListenState.kPVLS_AllowPrivateCoach;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum EPlayerVoiceListenState");
  }
}

export function ePlayerVoiceListenStateToJSON(object: EPlayerVoiceListenState): string {
  switch (object) {
    case EPlayerVoiceListenState.kPVLS_None:
      return "kPVLS_None";
    case EPlayerVoiceListenState.kPVLS_DeniedChatBanned:
      return "kPVLS_DeniedChatBanned";
    case EPlayerVoiceListenState.kPVLS_DeniedPartner:
      return "kPVLS_DeniedPartner";
    case EPlayerVoiceListenState.kPVLS_DeniedHLTVTalkerNotSpectator:
      return "kPVLS_DeniedHLTVTalkerNotSpectator";
    case EPlayerVoiceListenState.kPVLS_DeniedHLTVNoTalkerPlayerID:
      return "kPVLS_DeniedHLTVNoTalkerPlayerID";
    case EPlayerVoiceListenState.kPVLS_DeniedHLTVTalkerNotBroadcaster:
      return "kPVLS_DeniedHLTVTalkerNotBroadcaster";
    case EPlayerVoiceListenState.kPVLS_DeniedTeamSpectator:
      return "kPVLS_DeniedTeamSpectator";
    case EPlayerVoiceListenState.kPVLS_DeniedStudent:
      return "kPVLS_DeniedStudent";
    case EPlayerVoiceListenState.kPVLS_DeniedPrivateCoach:
      return "kPVLS_DeniedPrivateCoach";
    case EPlayerVoiceListenState.kPVLS_Denied:
      return "kPVLS_Denied";
    case EPlayerVoiceListenState.kPVLS_AllowHLTVTalkerIsBroadcaster:
      return "kPVLS_AllowHLTVTalkerIsBroadcaster";
    case EPlayerVoiceListenState.kPVLS_AllowCoBroadcaster:
      return "kPVLS_AllowCoBroadcaster";
    case EPlayerVoiceListenState.kPVLS_AllowAllChat:
      return "kPVLS_AllowAllChat";
    case EPlayerVoiceListenState.kPVLS_AllowStudentToCoach:
      return "kPVLS_AllowStudentToCoach";
    case EPlayerVoiceListenState.kPVLS_AllowFellowStudent:
      return "kPVLS_AllowFellowStudent";
    case EPlayerVoiceListenState.kPVLS_AllowTalkerIsCoach:
      return "kPVLS_AllowTalkerIsCoach";
    case EPlayerVoiceListenState.kPVLS_AllowCoachHearTeam:
      return "kPVLS_AllowCoachHearTeam";
    case EPlayerVoiceListenState.kPVLS_AllowSameTeam:
      return "kPVLS_AllowSameTeam";
    case EPlayerVoiceListenState.kPVLS_AllowShowcase:
      return "kPVLS_AllowShowcase";
    case EPlayerVoiceListenState.kPVLS_AllowPrivateCoach:
      return "kPVLS_AllowPrivateCoach";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum EPlayerVoiceListenState");
  }
}

export enum EProjectionEvent {
  ePE_FirstBlood = 0,
  ePE_Killstreak_godlike = 1,
}

export function eProjectionEventFromJSON(object: any): EProjectionEvent {
  switch (object) {
    case 0:
    case "ePE_FirstBlood":
      return EProjectionEvent.ePE_FirstBlood;
    case 1:
    case "ePE_Killstreak_godlike":
      return EProjectionEvent.ePE_Killstreak_godlike;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum EProjectionEvent");
  }
}

export function eProjectionEventToJSON(object: EProjectionEvent): string {
  switch (object) {
    case EProjectionEvent.ePE_FirstBlood:
      return "ePE_FirstBlood";
    case EProjectionEvent.ePE_Killstreak_godlike:
      return "ePE_Killstreak_godlike";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum EProjectionEvent");
  }
}

export interface CDOTAUserMsgAIDebugLine {
  message?: string | undefined;
}

export interface CDOTAUserMsgPing {
  ping?: number | undefined;
  loss?: number | undefined;
}

export interface CDOTAUserMsgSwapVerify {
  playerId?: number | undefined;
}

export interface CDOTAUserMsgChatEvent {
  type: dotaChatMessage;
  value?: number | undefined;
  playerid1?: number | undefined;
  playerid2?: number | undefined;
  playerid3?: number | undefined;
  playerid4?: number | undefined;
  playerid5?: number | undefined;
  playerid6?: number | undefined;
  value2?: number | undefined;
  value3?: number | undefined;
}

export interface CDOTAUserMsgBotChat {
  playerId?: number | undefined;
  message?: string | undefined;
  target?: string | undefined;
  teamOnly?: boolean | undefined;
}

export interface CDOTAUserMsgCombatHeroPositions {
  index?: number | undefined;
  time?: number | undefined;
  worldPos?: CMsgVector2D | undefined;
  health?: number | undefined;
}

export interface CDOTAUserMsgCombatLogBulkData {
  combatEntries: CMsgDOTACombatLogEntry[];
  timestamp?: number | undefined;
  duration?: number | undefined;
  playerId?: number | undefined;
  requestTime?: number | undefined;
}

export interface CDOTAUserMsgProjectileParticleCPData {
  controlPoint?: number | undefined;
  vector?: CMsgVector | undefined;
}

export interface CDOTAUserMsgUpdateLinearProjectileCPData {
  handle?: number | undefined;
  controlPoint?: number | undefined;
  vector?: CMsgVector | undefined;
}

export interface CDOTAUserMsgMiniKillCamInfo {
  attackers: CDOTAUserMsgMiniKillCamInfo_Attacker[];
}

export interface CDOTAUserMsgMiniKillCamInfo_Attacker {
  attacker?: number | undefined;
  totalDamage?: number | undefined;
  abilities: CDOTAUserMsgMiniKillCamInfo_Attacker_Ability[];
  attackerName?: string | undefined;
}

export interface CDOTAUserMsgMiniKillCamInfo_Attacker_Ability {
  abilityId?: number | undefined;
  damage?: number | undefined;
}

export interface CDOTAUserMsgGlobalLightColor {
  color?: number | undefined;
  duration?: number | undefined;
}

export interface CDOTAUserMsgGlobalLightDirection {
  direction?: CMsgVector | undefined;
  duration?: number | undefined;
}

export interface CDOTAUserMsgLocationPing {
  playerId?: number | undefined;
  locationPing?: CDOTAMsgLocationPing | undefined;
}

export interface CDOTAUserMsgPingConfirmation {
  playerIdOfOriginalPinger?: number | undefined;
  entityIndex?: number | undefined;
  iconType?: number | undefined;
  location?: CMsgVector | undefined;
}

export interface CDOTAUserMsgItemAlert {
  playerId?: number | undefined;
  itemAlert?: CDOTAMsgItemAlert | undefined;
}

export interface CDOTAUserMsgEnemyItemAlert {
  playerId?: number | undefined;
  targetPlayerId?: number | undefined;
  itemAbilityId?: number | undefined;
  runeType?: number | undefined;
  entityId?: number | undefined;
  itemLevel?: number | undefined;
  primaryCharges?: number | undefined;
  secondaryCharges?: number | undefined;
}

export interface CDOTAUserMsgModifierAlert {
  playerId?: number | undefined;
  className?: string | undefined;
  stackCount?: number | undefined;
  isDebuff?: boolean | undefined;
  targetEntindex?: number | undefined;
  secondsRemaining?: number | undefined;
}

export interface CDOTAUserMsgHPManaAlert {
  playerId?: number | undefined;
  targetEntindex?: number | undefined;
  showRawValues?: boolean | undefined;
}

export interface CDOTAUserMsgNeutralCampAlert {
  playerId?: number | undefined;
  spawnerEntindex?: number | undefined;
  unitEntindex?: number | undefined;
  stackCount?: number | undefined;
  campType?: number | undefined;
  stackRequest?: boolean | undefined;
  stackIntention?: boolean | undefined;
}

export interface CDOTAUserMsgGlyphAlert {
  playerId?: number | undefined;
  negative?: boolean | undefined;
}

export interface CDOTAUserMsgRadarAlert {
  playerId?: number | undefined;
  negative?: boolean | undefined;
}

export interface CDOTAUserMsgWillPurchaseAlert {
  itemAbilityId?: number | undefined;
  playerId?: number | undefined;
  goldRemaining?: number | undefined;
  suggestionPlayerId?: number | undefined;
}

export interface CDOTAUserMsgEmptyTeleportAlert {
  sourcePlayerId?: number | undefined;
  targetPlayerId?: number | undefined;
  cooldownSeconds?: number | undefined;
}

export interface CDOTAUserMsgMarsArenaOfBloodAttack {
  sourceEhandle?: number | undefined;
  targetEhandle?: number | undefined;
  warriorIndex?: number | undefined;
}

export interface CDOTAEntityMsgInvokerSpellCast {
  entityMsg?: CEntityMsg | undefined;
  castActivity?: number | undefined;
}

export interface CDOTAUserMsgBuyBackStateAlert {
  playerId?: number | undefined;
}

export interface CDOTAUserMsgQuickBuyAlert {
  playerId?: number | undefined;
  itemAbilityId?: number | undefined;
  goldCost?: number | undefined;
  itemCooldownSeconds?: number | undefined;
  showBuyback?: boolean | undefined;
}

export interface CDOTAUserMsgCourierKilledAlert {
  team?: number | undefined;
  goldValue?: number | undefined;
  entityHandle?: number | undefined;
  timestamp?: number | undefined;
  lostItems: CDOTAUserMsgCourierKilledAlert_LostItem[];
  killerPlayerId?: number | undefined;
  owningPlayerId?: number | undefined;
}

export interface CDOTAUserMsgCourierKilledAlert_LostItem {
  itemAbilityId?: number | undefined;
  quantity?: number | undefined;
}

export interface CDOTAUserMsgMinimapEvent {
  eventType?: number | undefined;
  entityHandle?: number | undefined;
  x?: number | undefined;
  y?: number | undefined;
  duration?: number | undefined;
  targetEntityHandle?: number | undefined;
}

export interface CDOTAUserMsgMapLine {
  playerId?: number | undefined;
  mapline?: CDOTAMsgMapLine | undefined;
}

export interface CDOTAUserMsgMinimapDebugPoint {
  location?: CMsgVector | undefined;
  color?: number | undefined;
  size?: number | undefined;
  duration?: number | undefined;
  index?: number | undefined;
}

export interface CDOTAUserMsgCreateLinearProjectile {
  origin?: CMsgVector | undefined;
  velocity?: CMsgVector2D | undefined;
  entindex?: number | undefined;
  particleIndex?: string | undefined;
  handle?: number | undefined;
  acceleration?: CMsgVector2D | undefined;
  maxSpeed?: number | undefined;
  fowRadius?: number | undefined;
  stickyFowReveal?: boolean | undefined;
  distance?: number | undefined;
  colorgemcolor?: number | undefined;
  particleCpData: CDOTAUserMsgProjectileParticleCPData[];
}

export interface CDOTAUserMsgDestroyLinearProjectile {
  handle?: number | undefined;
}

export interface CDOTAUserMsgDodgeTrackingProjectiles {
  entindex: number;
  attacksOnly?: boolean | undefined;
}

export interface CDOTAUserMsgSpectatorPlayerClick {
  entindex: number;
  orderType?: number | undefined;
  targetIndex?: number | undefined;
}

export interface CDOTAUserMsgSpectatorPlayerUnitOrders {
  entindex?: number | undefined;
  orderType?: number | undefined;
  units: number[];
  targetIndex?: number | undefined;
  abilityId?: number | undefined;
  position?: CMsgVector | undefined;
  queue?: boolean | undefined;
  sequenceNumber?: number | undefined;
  flags?: number | undefined;
}

export interface CDOTAUserMsgNevermoreRequiem {
  entityHandle?: number | undefined;
  lines?: number | undefined;
  origin?: CMsgVector | undefined;
  reverse?: boolean | undefined;
}

export interface CDOTAUserMsgInvalidCommand {
  message?: string | undefined;
  sequenceNumber?: number | undefined;
}

export interface CDOTAUserMsgHudError {
  orderId?: number | undefined;
  sequenceNumber?: number | undefined;
}

export interface CDOTAUserMsgSharedCooldown {
  entindex?: number | undefined;
  name?: string | undefined;
  cooldown?: number | undefined;
  nameIndex?: number | undefined;
}

export interface CDOTAUserMsgSetNextAutobuyItem {
  name?: string | undefined;
}

export interface CDOTAUserMsgHalloweenDrops {
  itemDefs: number[];
  playerIds: number[];
  prizeList?: number | undefined;
}

export interface CDOTAUserMsgPredictionResult {
  accountId?: number | undefined;
  matchId?: string | undefined;
  correct?: boolean | undefined;
  predictions: CDOTAUserMsgPredictionResult_Prediction[];
}

export interface CDOTAUserMsgPredictionResult_Prediction {
  itemDef?: number | undefined;
  numCorrect?: number | undefined;
  numFails?: number | undefined;
  result?: CDOTAUserMsgPredictionResult_Prediction_EResult | undefined;
  grantedItemDefs: number[];
}

export enum CDOTAUserMsgPredictionResult_Prediction_EResult {
  k_eResult_ItemGranted = 1,
  k_eResult_Destroyed = 2,
}

export function cDOTAUserMsgPredictionResult_Prediction_EResultFromJSON(
  object: any,
): CDOTAUserMsgPredictionResult_Prediction_EResult {
  switch (object) {
    case 1:
    case "k_eResult_ItemGranted":
      return CDOTAUserMsgPredictionResult_Prediction_EResult.k_eResult_ItemGranted;
    case 2:
    case "k_eResult_Destroyed":
      return CDOTAUserMsgPredictionResult_Prediction_EResult.k_eResult_Destroyed;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum CDOTAUserMsgPredictionResult_Prediction_EResult",
      );
  }
}

export function cDOTAUserMsgPredictionResult_Prediction_EResultToJSON(
  object: CDOTAUserMsgPredictionResult_Prediction_EResult,
): string {
  switch (object) {
    case CDOTAUserMsgPredictionResult_Prediction_EResult.k_eResult_ItemGranted:
      return "k_eResult_ItemGranted";
    case CDOTAUserMsgPredictionResult_Prediction_EResult.k_eResult_Destroyed:
      return "k_eResult_Destroyed";
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum CDOTAUserMsgPredictionResult_Prediction_EResult",
      );
  }
}

export interface CDOTAResponseQuerySerialized {
  facts: CDOTAResponseQuerySerialized_Fact[];
}

export interface CDOTAResponseQuerySerialized_Fact {
  key: number;
  valtype: CDOTAResponseQuerySerialized_Fact_ValueType;
  valNumeric?: number | undefined;
  valString?: string | undefined;
  valStringtableIndex?: number | undefined;
  valIntNumeric?: number | undefined;
}

export enum CDOTAResponseQuerySerialized_Fact_ValueType {
  NUMERIC = 1,
  STRING = 2,
  STRINGTABLE_INDEX = 3,
  INT_NUMERIC = 4,
}

export function cDOTAResponseQuerySerialized_Fact_ValueTypeFromJSON(
  object: any,
): CDOTAResponseQuerySerialized_Fact_ValueType {
  switch (object) {
    case 1:
    case "NUMERIC":
      return CDOTAResponseQuerySerialized_Fact_ValueType.NUMERIC;
    case 2:
    case "STRING":
      return CDOTAResponseQuerySerialized_Fact_ValueType.STRING;
    case 3:
    case "STRINGTABLE_INDEX":
      return CDOTAResponseQuerySerialized_Fact_ValueType.STRINGTABLE_INDEX;
    case 4:
    case "INT_NUMERIC":
      return CDOTAResponseQuerySerialized_Fact_ValueType.INT_NUMERIC;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum CDOTAResponseQuerySerialized_Fact_ValueType",
      );
  }
}

export function cDOTAResponseQuerySerialized_Fact_ValueTypeToJSON(
  object: CDOTAResponseQuerySerialized_Fact_ValueType,
): string {
  switch (object) {
    case CDOTAResponseQuerySerialized_Fact_ValueType.NUMERIC:
      return "NUMERIC";
    case CDOTAResponseQuerySerialized_Fact_ValueType.STRING:
      return "STRING";
    case CDOTAResponseQuerySerialized_Fact_ValueType.STRINGTABLE_INDEX:
      return "STRINGTABLE_INDEX";
    case CDOTAResponseQuerySerialized_Fact_ValueType.INT_NUMERIC:
      return "INT_NUMERIC";
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum CDOTAResponseQuerySerialized_Fact_ValueType",
      );
  }
}

export interface CDOTASpeechMatchOnClient {
  speechConcept?: number | undefined;
  recipientType?: number | undefined;
  responsequery?: CDOTAResponseQuerySerialized | undefined;
  randomseed?: number | undefined;
}

export interface CDOTAUserMsgUnitEvent {
  msgType: EDotaEntityMessages;
  entityIndex: number;
  speech?: CDOTAUserMsgUnitEvent_Speech | undefined;
  speechMute?: CDOTAUserMsgUnitEvent_SpeechMute | undefined;
  addGesture?: CDOTAUserMsgUnitEvent_AddGesture | undefined;
  removeGesture?: CDOTAUserMsgUnitEvent_RemoveGesture | undefined;
  bloodImpact?: CDOTAUserMsgUnitEvent_BloodImpact | undefined;
  fadeGesture?: CDOTAUserMsgUnitEvent_FadeGesture | undefined;
  speechMatchOnClient?: CDOTASpeechMatchOnClient | undefined;
}

export interface CDOTAUserMsgUnitEvent_Interval {
  start?: number | undefined;
  range?: number | undefined;
}

export interface CDOTAUserMsgUnitEvent_Speech {
  speechConcept?: number | undefined;
  response?: string | undefined;
  recipientType?: number | undefined;
  muteable?: boolean | undefined;
  predelay?: CDOTAUserMsgUnitEvent_Interval | undefined;
  flags?: number | undefined;
}

export interface CDOTAUserMsgUnitEvent_SpeechMute {
  delay?: number | undefined;
}

export interface CDOTAUserMsgUnitEvent_AddGesture {
  activity?: number | undefined;
  slot?: number | undefined;
  fadeIn?: number | undefined;
  fadeOut?: number | undefined;
  playbackRate?: number | undefined;
  sequenceVariant?: number | undefined;
}

export interface CDOTAUserMsgUnitEvent_RemoveGesture {
  activity?: number | undefined;
}

export interface CDOTAUserMsgUnitEvent_BloodImpact {
  scale?: number | undefined;
  xNormal?: number | undefined;
  yNormal?: number | undefined;
}

export interface CDOTAUserMsgUnitEvent_FadeGesture {
  activity?: number | undefined;
}

export interface CDOTAUserMsgItemPurchased {
  itemAbilityId?: number | undefined;
}

export interface CDOTAUserMsgItemSold {
  itemAbilityId?: number | undefined;
}

export interface CDOTAUserMsgItemFound {
  player?: number | undefined;
  quality?: number | undefined;
  rarity?: number | undefined;
  method?: number | undefined;
  itemdef?: number | undefined;
}

export interface CDOTAUserMsgOverheadEvent {
  messageType: dotaOverheadAlert;
  value?: number | undefined;
  targetPlayerEntindex?: number | undefined;
  targetEntindex?: number | undefined;
  sourcePlayerEntindex?: number | undefined;
}

export interface CDOTAUserMsgTutorialTipInfo {
  name?: string | undefined;
  progress?: number | undefined;
}

export interface CDOTAUserMsgTutorialFinish {
  heading?: string | undefined;
  emblem?: string | undefined;
  body?: string | undefined;
  success?: boolean | undefined;
}

export interface CDOTAUserMsgTutorialMinimapPosition {}

export interface CDOTAUserMsgSendGenericToolTip {
  title?: string | undefined;
  text?: string | undefined;
  entindex?: number | undefined;
  close?: boolean | undefined;
}

export interface CDOTAUserMsgWorldLine {
  playerId?: number | undefined;
  worldline?: CDOTAMsgWorldLine | undefined;
}

export interface CDOTAUserMsgChatWheel {
  chatMessageId?: number | undefined;
  playerId?: number | undefined;
  accountId?: number | undefined;
  paramHeroId?: number | undefined;
  emoticonId?: number | undefined;
}

export interface CDOTAUserMsgReceivedXmasGift {
  playerId?: number | undefined;
  itemName?: string | undefined;
  inventorySlot?: number | undefined;
}

export interface CDOTAUserMsgShowSurvey {
  surveyId?: number | undefined;
  matchId?: string | undefined;
  responseStyle?: string | undefined;
  teammateHeroId?: number | undefined;
  teammateName?: string | undefined;
  teammateAccountId?: number | undefined;
}

export interface CDOTAUserMsgUpdateSharedContent {
  slotType?: number | undefined;
}

export interface CDOTAUserMsgTutorialRequestExp {}

export interface CDOTAUserMsgTutorialFade {
  tgtAlpha?: number | undefined;
}

export interface CDOTAUserMsgTutorialPingMinimap {
  playerId?: number | undefined;
  posX?: number | undefined;
  posY?: number | undefined;
  posZ?: number | undefined;
  entityIndex?: number | undefined;
}

export interface CDOTAUserMsgGamerulesStateChanged {
  state?: number | undefined;
}

export interface CDOTAUserMsgAddQuestLogEntry {
  npcName?: string | undefined;
  npcDialog?: string | undefined;
}

export interface CDOTAUserMsgSendStatPopup {
  playerId?: number | undefined;
  statpopup?: CDOTAMsgSendStatPopup | undefined;
}

export interface CDOTAUserMsgDismissAllStatPopups {
  dismissallmsg?: CDOTAMsgDismissAllStatPopups | undefined;
}

export interface CDOTAUserMsgSendRoshanSpectatorPhase {
  phase?: dotaRoshanPhase | undefined;
  phaseStartTime?: number | undefined;
  phaseLength?: number | undefined;
}

export interface CDOTAUserMsgSendRoshanPopup {
  reclaimed?: boolean | undefined;
  gametime?: number | undefined;
}

export interface CDOTAUserMsgSendFinalGold {
  reliableGold: number[];
  unreliableGold: number[];
}

export interface CDOTAUserMsgCustomMsg {
  message?: string | undefined;
  playerId?: number | undefined;
  value?: number | undefined;
}

export interface CDOTAUserMsgCoachHUDPing {
  playerId?: number | undefined;
  hudPing?: CDOTAMsgCoachHUDPing | undefined;
}

export interface CDOTAUserMsgClientLoadGridNav {}

export interface CDOTAUserMsgTEProjectile {
  source?: number | undefined;
  target?: number | undefined;
  moveSpeed?: number | undefined;
  sourceAttachment?: number | undefined;
  particleSystemHandle?: string | undefined;
  dodgeable?: boolean | undefined;
  isAttack?: boolean | undefined;
  expireTime?: number | undefined;
  maximpacttime?: number | undefined;
  colorgemcolor?: number | undefined;
  launchTick?: number | undefined;
  handle?: number | undefined;
  targetLoc?: CMsgVector | undefined;
  particleCpData: CDOTAUserMsgProjectileParticleCPData[];
  additionalParticleSystemHandle?: string | undefined;
  originalMoveSpeed?: number | undefined;
  ability?: number | undefined;
}

export interface CDOTAUserMsgTEProjectileLoc {
  sourceLoc?: CMsgVector | undefined;
  target?: number | undefined;
  moveSpeed?: number | undefined;
  particleSystemHandle?: string | undefined;
  dodgeable?: boolean | undefined;
  isAttack?: boolean | undefined;
  expireTime?: number | undefined;
  targetLoc?: CMsgVector | undefined;
  colorgemcolor?: number | undefined;
  launchTick?: number | undefined;
  handle?: number | undefined;
  source?: number | undefined;
  sourceAttachment?: number | undefined;
  particleCpData: CDOTAUserMsgProjectileParticleCPData[];
  additionalParticleSystemHandle?: string | undefined;
  originalMoveSpeed?: number | undefined;
}

export interface CDOTAUserMsgTEDestroyProjectile {
  handle?: number | undefined;
}

export interface CDOTAUserMsgTEDotaBloodImpact {
  entity?: number | undefined;
  scale?: number | undefined;
  xnormal?: number | undefined;
  ynormal?: number | undefined;
}

export interface CDOTAUserMsgAbilityPing {
  playerId?: number | undefined;
  abilityId?: number | undefined;
  type?: dotaAbilityPingType | undefined;
  cooldownSeconds?: number | undefined;
  level?: number | undefined;
  passive?: boolean | undefined;
  manaNeeded?: number | undefined;
  entityId?: number | undefined;
  primaryCharges?: number | undefined;
  secondaryCharges?: number | undefined;
  ctrlHeld?: boolean | undefined;
  reclaimTime?: number | undefined;
  ownerEntity?: number | undefined;
}

export interface CDOTAUserMsgTEUnitAnimation {
  entity?: number | undefined;
  sequenceVariant?: number | undefined;
  playbackrate?: number | undefined;
  castpoint?: number | undefined;
  type?: number | undefined;
  activity?: number | undefined;
  lagCompensationTime?: number | undefined;
}

export interface CDOTAUserMsgTEUnitAnimationEnd {
  entity?: number | undefined;
  snap?: boolean | undefined;
}

export interface CDOTAUserMsgShowGenericPopup {
  header: string;
  body: string;
  param1?: string | undefined;
  param2?: string | undefined;
  tintScreen?: boolean | undefined;
  showNoOtherDialogs?: boolean | undefined;
}

export interface CDOTAUserMsgVoteStart {
  title?: string | undefined;
  duration?: number | undefined;
  choiceCount?: number | undefined;
  choices: string[];
}

export interface CDOTAUserMsgVoteUpdate {
  choiceCounts: number[];
}

export interface CDOTAUserMsgVoteEnd {
  selectedChoice?: number | undefined;
}

export interface CDOTAUserMsgBoosterStatePlayer {
  playerId?: number | undefined;
  bonus?: number | undefined;
  eventBonus?: number | undefined;
  bonusItemId?: number | undefined;
  eventBonusItemId?: number | undefined;
}

export interface CDOTAUserMsgBoosterState {
  boostedPlayers: CDOTAUserMsgBoosterStatePlayer[];
}

export interface CDOTAUserMsgPlayerMMR {
  mmr: number[];
}

export interface CDOTAUserMsgAbilitySteal {
  playerId?: number | undefined;
  abilityId?: number | undefined;
  abilityLevel?: number | undefined;
}

export interface CDOTAUserMsgStatsHeroLookup {
  playerId?: number | undefined;
  heroId?: number | undefined;
  heroName?: string | undefined;
  persona?: string | undefined;
}

export interface CDOTAUserMsgStatsHeroPositionInfo {
  averagePosition?: number | undefined;
  positionDetails: CDOTAUserMsgStatsHeroPositionInfo_PositionPair[];
}

export interface CDOTAUserMsgStatsHeroPositionInfo_PositionPair {
  positionCategory?: dotaPositionCategory | undefined;
  positionCount?: number | undefined;
}

export interface CDOTAUserMsgStatsHeroMinuteDetails {
  lastHits?: number | undefined;
  heroKills?: number | undefined;
  heroDamage?: number | undefined;
  towerDamage?: number | undefined;
  positionInfo?: CDOTAUserMsgStatsHeroPositionInfo | undefined;
  totalXp?: number | undefined;
  netWorth?: number | undefined;
  harvestedCreepGold?: number | undefined;
  claimedFarm?: number | undefined;
  wardsPlaced?: number | undefined;
  runesCollected?: number | undefined;
  tpsUsed?: number | undefined;
  manaSpent: number[];
  damageAbsorbed: number[];
  damageDone: number[];
}

export interface CDOTAUserMsgStatsTeamMinuteDetails {
  playerStats: CDOTAUserMsgStatsHeroMinuteDetails[];
  towerKills?: number | undefined;
  barrackKills?: number | undefined;
  availableLaneCreepGold?: number | undefined;
  balanceKillValue?: number | undefined;
  balanceTowerValue?: number | undefined;
  balanceBarracksValue?: number | undefined;
  balanceGoldValue?: number | undefined;
  balanceXpValue?: number | undefined;
  lanePerformance: CDOTAUserMsgStatsTeamMinuteDetails_LocationPerformance[];
}

export interface CDOTAUserMsgStatsTeamMinuteDetails_LocationPerformance {
  locationCategory?: number | undefined;
  statType?: number | undefined;
  value?: number | undefined;
}

export interface CDOTAUserMsgStatsPlayerKillShare {
  playerId?: number | undefined;
  killSharePercent?: number | undefined;
  playerLocX?: number | undefined;
  playerLocY?: number | undefined;
  healthPercent?: number | undefined;
  manaPercent?: number | undefined;
}

export interface CDOTAUserMsgStatsKillDetails {
  victimId?: number | undefined;
  killShares: CDOTAUserMsgStatsPlayerKillShare[];
  damageToKill?: number | undefined;
  effectiveHealth?: number | undefined;
  deathTime?: number | undefined;
  killerId?: number | undefined;
}

export interface CDOTAUserMsgStatsMatchDetails {
  heroLookup: CDOTAUserMsgStatsHeroLookup[];
  radiantStats: CDOTAUserMsgStatsTeamMinuteDetails[];
  direStats: CDOTAUserMsgStatsTeamMinuteDetails[];
  radiantKills: CDOTAUserMsgStatsKillDetails[];
  direKills: CDOTAUserMsgStatsKillDetails[];
  fightDetails: CDOTAUserMsgStatsMatchDetails_CDOTAUserMsgStatsFightDetails[];
}

export interface CDOTAUserMsgStatsMatchDetails_CDOTAUserMsgStatsFightTeamDetails {
  participants: number[];
  deaths: number[];
  goldDelta?: number | undefined;
  xpDelta?: number | undefined;
}

export interface CDOTAUserMsgStatsMatchDetails_CDOTAUserMsgStatsFightDetails {
  startTime?: number | undefined;
  endTime?: number | undefined;
  radiantFightDetails?: CDOTAUserMsgStatsMatchDetails_CDOTAUserMsgStatsFightTeamDetails | undefined;
  direFightDetails?: CDOTAUserMsgStatsMatchDetails_CDOTAUserMsgStatsFightTeamDetails | undefined;
}

export interface CDOTAUserMsgMiniTaunt {
  tauntingPlayerId?: number | undefined;
}

export interface CDOTAUserMsgSpeechBubble {
  destroyAll?: boolean | undefined;
}

export interface CDOTAUserMsgCustomHeaderMessage {
  playerId?: number | undefined;
  duration?: number | undefined;
  message?: string | undefined;
  value?: number | undefined;
}

export interface CMsgHeroAbilityStat {
  statType?: EHeroStatType | undefined;
  intValue?: number | undefined;
  floatValue?: number | undefined;
}

export interface CMsgCombatAnalyzerPlayerStat {
  accountId?: number | undefined;
  heroAbilityStats: CMsgHeroAbilityStat[];
}

export interface CMsgCombatAnalyzerStats {
  matchId?: string | undefined;
  playerStats: CMsgCombatAnalyzerPlayerStat[];
}

export interface CDOTAUserMsgBeastChat {
  team?: number | undefined;
  format?: string | undefined;
  message?: string | undefined;
  target?: string | undefined;
}

export interface CDOTAUserMsgCustomHudElementCreate {
  elementId?: string | undefined;
  layoutFilename?: string | undefined;
  data?: Buffer | undefined;
}

export interface CDOTAUserMsgCustomHudElementModify {
  elementId?: string | undefined;
  modifyVisible?: boolean | undefined;
  data?: Buffer | undefined;
}

export interface CDOTAUserMsgCustomHudElementDestroy {
  elementId?: string | undefined;
}

export interface CDOTAUserMsgCompendiumStatePlayer {
  playerId?: number | undefined;
  level?: number | undefined;
}

export interface CDOTAUserMsgCompendiumState {
  compendiumPlayers: CDOTAUserMsgCompendiumStatePlayer[];
}

export interface CDOTAUserMsgProjectionAbility {
  abilityId?: number | undefined;
  casterEntIndex?: number | undefined;
  casterTeam?: number | undefined;
  channelEnd?: boolean | undefined;
  origin?: CMsgVector | undefined;
  trackCasterOnly?: boolean | undefined;
  endTime?: number | undefined;
  victimEntIndex?: number | undefined;
}

export interface CDOTAUserMsgProjectionEvent {
  eventId?: EProjectionEvent | undefined;
  team?: number | undefined;
}

export interface CDOTAUserMsgXPAlert {
  playerId?: number | undefined;
  targetEntindex?: number | undefined;
}

export interface CDOTAUserMsgTalentTreeAlert {
  playerId?: number | undefined;
  targetEntindex?: number | undefined;
  abilityId?: number | undefined;
  slot?: number | undefined;
  learned?: boolean | undefined;
}

export interface CDOTAUserMsgUpdateQuestProgress {}

export interface CDOTAUserMsgQuestStatus {
  playerId: number;
  questId?: number | undefined;
  challengeId?: number | undefined;
  progress?: number | undefined;
  goal?: number | undefined;
  query?: number | undefined;
  failGametime?: number | undefined;
  itemAbilityId?: number | undefined;
}

export interface CDOTAUserMsgSuggestHeroPick {
  playerId: number;
  heroId?: number | undefined;
  ban?: boolean | undefined;
  facetId?: number | undefined;
}

export interface CDOTAUserMsgSuggestHeroRole {
  playerId: number;
  heroRole?: string | undefined;
}

export interface CDOTAUserMsgKillcamDamageTaken {
  playerId: number;
  damageTaken?: number | undefined;
  itemType?: number | undefined;
  itemAbilityId?: number | undefined;
  heroName?: string | undefined;
  damageColor?: string | undefined;
}

export interface CDOTAUserMsgSelectPenaltyGold {
  playerId: number;
  cost?: number | undefined;
}

export interface CDOTAUserMsgRollDiceResult {
  playerId?: number | undefined;
  channelType?: number | undefined;
  rollMin?: number | undefined;
  rollMax?: number | undefined;
  result?: number | undefined;
}

export interface CDOTAUserMsgFlipCoinResult {
  playerId?: number | undefined;
  channelType?: number | undefined;
  result?: boolean | undefined;
}

export interface CDOTAUserMessageRequestItemSuggestions {
  playerId?: number | undefined;
}

export interface CDOTAUserMessageTeamCaptainChanged {
  team?: number | undefined;
  captainPlayerId?: number | undefined;
}

export interface CDOTAUserMsgChatWheelCooldown {
  messageId?: number | undefined;
  cooldownRemaining?: number | undefined;
}

export interface CDOTAUserMsgHeroRelicProgress {
  heroRelicType?: number | undefined;
  value?: number | undefined;
  ehandle?: number | undefined;
  eventId?: number | undefined;
  valueDisplay?: number | undefined;
}

export interface CDOTAUserMsgAbilityDraftRequestAbility {
  playerId?: number | undefined;
  requestedAbilityId?: number | undefined;
  ctrlIsDown?: boolean | undefined;
}

export interface CDOTAUserMsgDamageReport {
  playerId?: number | undefined;
  targetHeroId?: number | undefined;
  sourceHeroId?: number | undefined;
  damageAmount?: number | undefined;
  broadcast?: boolean | undefined;
}

export interface CDOTAUserMsgSalutePlayer {
  sourcePlayerId?: number | undefined;
  targetPlayerId?: number | undefined;
  tipAmount?: number | undefined;
  eventId?: number | undefined;
  customTipStyle?: string | undefined;
  numRecentTips?: number | undefined;
}

export interface CDOTAUserMsgGiftPlayer {
  sourcePlayerId?: number | undefined;
  targetPlayerId?: number | undefined;
  giftItemDefIndex?: number | undefined;
}

export interface CDOTAUserMsgTipAlert {
  playerId?: number | undefined;
  tipText?: string | undefined;
}

export interface CDOTAUserMsgReplaceQueryUnit {
  playerId: number;
  sourceEntindex?: number | undefined;
  targetEntindex?: number | undefined;
}

export interface CDOTAUserMsgESArcanaCombo {
  ehandle?: number | undefined;
  comboCount?: number | undefined;
  arcanaLevel?: number | undefined;
}

export interface CDOTAUserMsgESArcanaComboSummary {
  ehandle?: number | undefined;
  comboCount?: number | undefined;
  damageAmount?: number | undefined;
}

export interface CDOTAUserMsgOMArcanaCombo {
  ehandle?: number | undefined;
  multicastAmount?: number | undefined;
  arcanaLevel?: number | undefined;
  multicastChance?: number | undefined;
}

export interface CDOTAUserMsgHighFiveCompleted {
  playerId1?: number | undefined;
  playerId2?: number | undefined;
  specialHighFive?: boolean | undefined;
  specialEntindex?: number | undefined;
}

export interface CDOTAUserMsgHighFiveLeftHanging {
  playerId?: number | undefined;
}

export interface CDOTAUserMsgShovelUnearth {
  playerId?: number | undefined;
  allChat?: boolean | undefined;
  locstring?: string | undefined;
  quantity?: number | undefined;
}

export interface CDOTAUserMsgAllStarEvent {
  sourcePlayerId?: number | undefined;
  targetPlayerId?: number | undefined;
  pointAmount?: number | undefined;
  eventId?: number | undefined;
  playerScores: CDOTAUserMsgAllStarEvent_PlayerScore[];
}

export interface CDOTAUserMsgAllStarEvent_PlayerScore {
  playerId?: number | undefined;
  scoreSansKda?: number | undefined;
}

export interface CDOTAUserMsgQueuedOrderRemoved {
  unitOrderSequence: number[];
}

export interface CDOTAUserMsgDebugChallenge {
  challengeType: number;
  challengeQueryId: number;
  eventId: number;
  instanceId?: number | undefined;
  challengeVar0?: number | undefined;
  challengeVar1?: number | undefined;
  challengeMaxRank?: number | undefined;
}

export interface CDOTAUserMsgFoundNeutralItem {
  playerId?: number | undefined;
  itemAbilityId?: number | undefined;
  itemTier?: number | undefined;
  tierItemCount?: number | undefined;
}

export interface CDOTAUserMsgOutpostCaptured {
  outpostEntindex?: number | undefined;
  teamId?: number | undefined;
}

export interface CDOTAUserMsgOutpostGrantedXP {
  teamId?: number | undefined;
  xpAmount?: number | undefined;
}

export interface CDOTAUserMsgMoveCameraToUnit {
  unitEhandle?: number | undefined;
}

export interface CDOTAUserMsgPauseMinigameData {
  dataBits: CDOTAUserMsgPauseMinigameData_DataBit[];
}

export interface CDOTAUserMsgPauseMinigameData_DataBit {
  index?: number | undefined;
  data?: number | undefined;
  dataExtra?: string | undefined;
}

export interface CDOTAUserMsgVersusScenePlayerBehavior {
  playerId?: number | undefined;
  behavior?: EDOTAVersusScenePlayerBehavior | undefined;
  playActivity?: VersusScenePlayActivity | undefined;
  chatWheel?: VersusSceneChatWheel | undefined;
  playbackRate?: VersusScenePlaybackRate | undefined;
}

export interface CDOTAUserMsgQoPArcanaSummary {
  ehandle?: number | undefined;
  arcanaLevel?: number | undefined;
  playersHit?: number | undefined;
  playersKilled?: number | undefined;
}

export interface CDOTAUserMsgHotPotatoCreated {
  playerId1?: number | undefined;
  playerId2?: number | undefined;
}

export interface CDOTAUserMsgHotPotatoExploded {
  playerId?: number | undefined;
}

export interface CDOTAUserMsgWKArcanaProgress {
  ehandle?: number | undefined;
  arcanaLevel?: number | undefined;
  heroId?: number | undefined;
}

export interface CDOTAUserMsgGuildChallengeProgress {
  playerProgress: CDOTAUserMsgGuildChallengeProgress_PlayerProgress[];
  guildId?: number | undefined;
  challengeInstanceId?: number | undefined;
  challengeParameter?: number | undefined;
  challengeType?: CDOTAUserMsgGuildChallengeProgress_EChallengeType | undefined;
  challengeProgressAtStart?: number | undefined;
  complete?: boolean | undefined;
}

export enum CDOTAUserMsgGuildChallengeProgress_EChallengeType {
  k_EChallengeType_Invalid = 0,
  k_EChallengeType_Cooperative = 1,
  k_EChallengeType_Contract = 2,
}

export function cDOTAUserMsgGuildChallengeProgress_EChallengeTypeFromJSON(
  object: any,
): CDOTAUserMsgGuildChallengeProgress_EChallengeType {
  switch (object) {
    case 0:
    case "k_EChallengeType_Invalid":
      return CDOTAUserMsgGuildChallengeProgress_EChallengeType.k_EChallengeType_Invalid;
    case 1:
    case "k_EChallengeType_Cooperative":
      return CDOTAUserMsgGuildChallengeProgress_EChallengeType.k_EChallengeType_Cooperative;
    case 2:
    case "k_EChallengeType_Contract":
      return CDOTAUserMsgGuildChallengeProgress_EChallengeType.k_EChallengeType_Contract;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum CDOTAUserMsgGuildChallengeProgress_EChallengeType",
      );
  }
}

export function cDOTAUserMsgGuildChallengeProgress_EChallengeTypeToJSON(
  object: CDOTAUserMsgGuildChallengeProgress_EChallengeType,
): string {
  switch (object) {
    case CDOTAUserMsgGuildChallengeProgress_EChallengeType.k_EChallengeType_Invalid:
      return "k_EChallengeType_Invalid";
    case CDOTAUserMsgGuildChallengeProgress_EChallengeType.k_EChallengeType_Cooperative:
      return "k_EChallengeType_Cooperative";
    case CDOTAUserMsgGuildChallengeProgress_EChallengeType.k_EChallengeType_Contract:
      return "k_EChallengeType_Contract";
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum CDOTAUserMsgGuildChallengeProgress_EChallengeType",
      );
  }
}

export interface CDOTAUserMsgGuildChallengeProgress_PlayerProgress {
  playerId?: number | undefined;
  progress?: number | undefined;
}

export interface CDOTAUserMsgWRArcanaProgress {
  ehandle?: number | undefined;
  targetEhandle?: number | undefined;
  arrowsLanded?: number | undefined;
  damageDealt?: number | undefined;
  targetHp?: number | undefined;
  targetMaxHp?: number | undefined;
  arcanaLevel?: number | undefined;
}

export interface CDOTAUserMsgWRArcanaSummary {
  ehandle?: number | undefined;
  targetEhandle?: number | undefined;
  arrowsLanded?: number | undefined;
  damageDealt?: number | undefined;
  targetHp?: number | undefined;
  targetMaxHp?: number | undefined;
  arcanaLevel?: number | undefined;
  success?: boolean | undefined;
}

export interface CDOTAUserMsgEmptyItemSlotAlert {
  sourcePlayerId?: number | undefined;
  targetPlayerId?: number | undefined;
  slotIndex?: number | undefined;
  cooldownSeconds?: number | undefined;
}

export interface CDOTAUserMsgAghsStatusAlert {
  sourcePlayerId?: number | undefined;
  targetPlayerId?: number | undefined;
  targetEntindex?: number | undefined;
  alertType?: number | undefined;
  hasScepter?: boolean | undefined;
  hasShard?: boolean | undefined;
}

export interface CDOTAUserMsgMutedPlayers {
  textMutedPlayerIds: number[];
  voiceMutedPlayerIds: number[];
}

export interface CDOTAUserMsgContextualTip {
  tipId?: number | undefined;
  referencedAbilities: string[];
  referencedUnits: string[];
  panoramaClasses: string[];
  forceAnnotation?: boolean | undefined;
  variant?: number | undefined;
  intParam?: number | undefined;
  intParam2?: number | undefined;
  floatParam?: number | undefined;
  floatParam2?: number | undefined;
  stringParam?: string | undefined;
  stringParam2?: string | undefined;
  tipTextOverride?: string | undefined;
  tipAnnotationOverride?: string | undefined;
  panoramaSnippet?: string | undefined;
}

export interface CDOTAUserMsgChatMessage {
  sourcePlayerId?: number | undefined;
  channelType?: number | undefined;
  messageText?: string | undefined;
}

export interface CDOTAUserMsgRockPaperScissorsStarted {
  playerIdSource?: number | undefined;
  playerIdTarget?: number | undefined;
}

export interface CDOTAUserMsgRockPaperScissorsFinished {
  playerId1?: number | undefined;
  playerId2?: number | undefined;
  player1Choice?: number | undefined;
  player2Choice?: number | undefined;
}

export interface CDOTAUserMsgDuelOpponentKilled {
  playerIdWinner?: number | undefined;
  playerIdLoser?: number | undefined;
}

export interface CDOTAUserMsgDuelAccepted {
  playerId1?: number | undefined;
  playerId2?: number | undefined;
}

export interface CDOTAUserMsgDuelRequested {
  playerIdRequestor?: number | undefined;
}

export interface CDOTAUserMsgMuertaReleaseEventAssignedTargetKilled {
  playerIdKiller: number;
  playerIdTarget: number;
  points: number;
  pointsTotal: number;
  lastHit: boolean;
}

export interface CDOTAUserMsgPlayerDraftSuggestPick {
  playerId?: number | undefined;
  suggestionPlayerId?: number | undefined;
}

export interface CDOTAUserMsgPlayerDraftPick {
  playerIdCaptain?: number | undefined;
  playerIdTarget?: number | undefined;
  team?: number | undefined;
}

export interface CDOTAUserMsgFacetPing {
  playerId?: number | undefined;
  facetStrhash?: number | undefined;
  entityId?: number | undefined;
  allChat?: boolean | undefined;
}

export interface CDOTAUserMsgInnatePing {
  playerId?: number | undefined;
  entityId?: number | undefined;
  allChat?: boolean | undefined;
}

function createBaseCDOTAUserMsgAIDebugLine(): CDOTAUserMsgAIDebugLine {
  return { message: "" };
}

export const CDOTAUserMsgAIDebugLine = {
  encode(message: CDOTAUserMsgAIDebugLine, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.message !== undefined && message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgAIDebugLine {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgAIDebugLine();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgAIDebugLine {
    return { message: isSet(object.message) ? globalThis.String(object.message) : "" };
  },

  toJSON(message: CDOTAUserMsgAIDebugLine): unknown {
    const obj: any = {};
    if (message.message !== undefined && message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgAIDebugLine>): CDOTAUserMsgAIDebugLine {
    return CDOTAUserMsgAIDebugLine.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgAIDebugLine>): CDOTAUserMsgAIDebugLine {
    const message = createBaseCDOTAUserMsgAIDebugLine();
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseCDOTAUserMsgPing(): CDOTAUserMsgPing {
  return { ping: 0, loss: 0 };
}

export const CDOTAUserMsgPing = {
  encode(message: CDOTAUserMsgPing, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.ping !== undefined && message.ping !== 0) {
      writer.uint32(16).uint32(message.ping);
    }
    if (message.loss !== undefined && message.loss !== 0) {
      writer.uint32(24).uint32(message.loss);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgPing {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgPing();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 16) {
            break;
          }

          message.ping = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.loss = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgPing {
    return {
      ping: isSet(object.ping) ? globalThis.Number(object.ping) : 0,
      loss: isSet(object.loss) ? globalThis.Number(object.loss) : 0,
    };
  },

  toJSON(message: CDOTAUserMsgPing): unknown {
    const obj: any = {};
    if (message.ping !== undefined && message.ping !== 0) {
      obj.ping = Math.round(message.ping);
    }
    if (message.loss !== undefined && message.loss !== 0) {
      obj.loss = Math.round(message.loss);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgPing>): CDOTAUserMsgPing {
    return CDOTAUserMsgPing.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgPing>): CDOTAUserMsgPing {
    const message = createBaseCDOTAUserMsgPing();
    message.ping = object.ping ?? 0;
    message.loss = object.loss ?? 0;
    return message;
  },
};

function createBaseCDOTAUserMsgSwapVerify(): CDOTAUserMsgSwapVerify {
  return { playerId: -1 };
}

export const CDOTAUserMsgSwapVerify = {
  encode(message: CDOTAUserMsgSwapVerify, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.playerId !== undefined && message.playerId !== -1) {
      writer.uint32(8).int32(message.playerId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgSwapVerify {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgSwapVerify();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.playerId = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgSwapVerify {
    return { playerId: isSet(object.playerId) ? globalThis.Number(object.playerId) : -1 };
  },

  toJSON(message: CDOTAUserMsgSwapVerify): unknown {
    const obj: any = {};
    if (message.playerId !== undefined && message.playerId !== -1) {
      obj.playerId = Math.round(message.playerId);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgSwapVerify>): CDOTAUserMsgSwapVerify {
    return CDOTAUserMsgSwapVerify.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgSwapVerify>): CDOTAUserMsgSwapVerify {
    const message = createBaseCDOTAUserMsgSwapVerify();
    message.playerId = object.playerId ?? -1;
    return message;
  },
};

function createBaseCDOTAUserMsgChatEvent(): CDOTAUserMsgChatEvent {
  return {
    type: -1,
    value: 0,
    playerid1: -1,
    playerid2: -1,
    playerid3: -1,
    playerid4: -1,
    playerid5: -1,
    playerid6: -1,
    value2: 0,
    value3: 0,
  };
}

export const CDOTAUserMsgChatEvent = {
  encode(message: CDOTAUserMsgChatEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.type !== -1) {
      writer.uint32(8).int32(message.type);
    }
    if (message.value !== undefined && message.value !== 0) {
      writer.uint32(16).uint32(message.value);
    }
    if (message.playerid1 !== undefined && message.playerid1 !== -1) {
      writer.uint32(24).sint32(message.playerid1);
    }
    if (message.playerid2 !== undefined && message.playerid2 !== -1) {
      writer.uint32(32).sint32(message.playerid2);
    }
    if (message.playerid3 !== undefined && message.playerid3 !== -1) {
      writer.uint32(40).sint32(message.playerid3);
    }
    if (message.playerid4 !== undefined && message.playerid4 !== -1) {
      writer.uint32(48).sint32(message.playerid4);
    }
    if (message.playerid5 !== undefined && message.playerid5 !== -1) {
      writer.uint32(56).sint32(message.playerid5);
    }
    if (message.playerid6 !== undefined && message.playerid6 !== -1) {
      writer.uint32(64).sint32(message.playerid6);
    }
    if (message.value2 !== undefined && message.value2 !== 0) {
      writer.uint32(72).uint32(message.value2);
    }
    if (message.value3 !== undefined && message.value3 !== 0) {
      writer.uint32(80).uint32(message.value3);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgChatEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgChatEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.value = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.playerid1 = reader.sint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.playerid2 = reader.sint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.playerid3 = reader.sint32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.playerid4 = reader.sint32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.playerid5 = reader.sint32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.playerid6 = reader.sint32();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.value2 = reader.uint32();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.value3 = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgChatEvent {
    return {
      type: isSet(object.type) ? dotaChatMessageFromJSON(object.type) : -1,
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
      playerid1: isSet(object.playerid1) ? globalThis.Number(object.playerid1) : -1,
      playerid2: isSet(object.playerid2) ? globalThis.Number(object.playerid2) : -1,
      playerid3: isSet(object.playerid3) ? globalThis.Number(object.playerid3) : -1,
      playerid4: isSet(object.playerid4) ? globalThis.Number(object.playerid4) : -1,
      playerid5: isSet(object.playerid5) ? globalThis.Number(object.playerid5) : -1,
      playerid6: isSet(object.playerid6) ? globalThis.Number(object.playerid6) : -1,
      value2: isSet(object.value2) ? globalThis.Number(object.value2) : 0,
      value3: isSet(object.value3) ? globalThis.Number(object.value3) : 0,
    };
  },

  toJSON(message: CDOTAUserMsgChatEvent): unknown {
    const obj: any = {};
    if (message.type !== -1) {
      obj.type = dotaChatMessageToJSON(message.type);
    }
    if (message.value !== undefined && message.value !== 0) {
      obj.value = Math.round(message.value);
    }
    if (message.playerid1 !== undefined && message.playerid1 !== -1) {
      obj.playerid1 = Math.round(message.playerid1);
    }
    if (message.playerid2 !== undefined && message.playerid2 !== -1) {
      obj.playerid2 = Math.round(message.playerid2);
    }
    if (message.playerid3 !== undefined && message.playerid3 !== -1) {
      obj.playerid3 = Math.round(message.playerid3);
    }
    if (message.playerid4 !== undefined && message.playerid4 !== -1) {
      obj.playerid4 = Math.round(message.playerid4);
    }
    if (message.playerid5 !== undefined && message.playerid5 !== -1) {
      obj.playerid5 = Math.round(message.playerid5);
    }
    if (message.playerid6 !== undefined && message.playerid6 !== -1) {
      obj.playerid6 = Math.round(message.playerid6);
    }
    if (message.value2 !== undefined && message.value2 !== 0) {
      obj.value2 = Math.round(message.value2);
    }
    if (message.value3 !== undefined && message.value3 !== 0) {
      obj.value3 = Math.round(message.value3);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgChatEvent>): CDOTAUserMsgChatEvent {
    return CDOTAUserMsgChatEvent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgChatEvent>): CDOTAUserMsgChatEvent {
    const message = createBaseCDOTAUserMsgChatEvent();
    message.type = object.type ?? -1;
    message.value = object.value ?? 0;
    message.playerid1 = object.playerid1 ?? -1;
    message.playerid2 = object.playerid2 ?? -1;
    message.playerid3 = object.playerid3 ?? -1;
    message.playerid4 = object.playerid4 ?? -1;
    message.playerid5 = object.playerid5 ?? -1;
    message.playerid6 = object.playerid6 ?? -1;
    message.value2 = object.value2 ?? 0;
    message.value3 = object.value3 ?? 0;
    return message;
  },
};

function createBaseCDOTAUserMsgBotChat(): CDOTAUserMsgBotChat {
  return { playerId: -1, message: "", target: "", teamOnly: false };
}

export const CDOTAUserMsgBotChat = {
  encode(message: CDOTAUserMsgBotChat, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.playerId !== undefined && message.playerId !== -1) {
      writer.uint32(8).int32(message.playerId);
    }
    if (message.message !== undefined && message.message !== "") {
      writer.uint32(26).string(message.message);
    }
    if (message.target !== undefined && message.target !== "") {
      writer.uint32(34).string(message.target);
    }
    if (message.teamOnly !== undefined && message.teamOnly !== false) {
      writer.uint32(40).bool(message.teamOnly);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgBotChat {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgBotChat();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.playerId = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.message = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.target = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.teamOnly = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgBotChat {
    return {
      playerId: isSet(object.playerId) ? globalThis.Number(object.playerId) : -1,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      target: isSet(object.target) ? globalThis.String(object.target) : "",
      teamOnly: isSet(object.teamOnly) ? globalThis.Boolean(object.teamOnly) : false,
    };
  },

  toJSON(message: CDOTAUserMsgBotChat): unknown {
    const obj: any = {};
    if (message.playerId !== undefined && message.playerId !== -1) {
      obj.playerId = Math.round(message.playerId);
    }
    if (message.message !== undefined && message.message !== "") {
      obj.message = message.message;
    }
    if (message.target !== undefined && message.target !== "") {
      obj.target = message.target;
    }
    if (message.teamOnly !== undefined && message.teamOnly !== false) {
      obj.teamOnly = message.teamOnly;
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgBotChat>): CDOTAUserMsgBotChat {
    return CDOTAUserMsgBotChat.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgBotChat>): CDOTAUserMsgBotChat {
    const message = createBaseCDOTAUserMsgBotChat();
    message.playerId = object.playerId ?? -1;
    message.message = object.message ?? "";
    message.target = object.target ?? "";
    message.teamOnly = object.teamOnly ?? false;
    return message;
  },
};

function createBaseCDOTAUserMsgCombatHeroPositions(): CDOTAUserMsgCombatHeroPositions {
  return { index: 0, time: 0, worldPos: undefined, health: 0 };
}

export const CDOTAUserMsgCombatHeroPositions = {
  encode(message: CDOTAUserMsgCombatHeroPositions, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.index !== undefined && message.index !== 0) {
      writer.uint32(8).uint32(message.index);
    }
    if (message.time !== undefined && message.time !== 0) {
      writer.uint32(16).int32(message.time);
    }
    if (message.worldPos !== undefined) {
      CMsgVector2D.encode(message.worldPos, writer.uint32(26).fork()).ldelim();
    }
    if (message.health !== undefined && message.health !== 0) {
      writer.uint32(32).int32(message.health);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgCombatHeroPositions {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgCombatHeroPositions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.index = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.time = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.worldPos = CMsgVector2D.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.health = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgCombatHeroPositions {
    return {
      index: isSet(object.index) ? globalThis.Number(object.index) : 0,
      time: isSet(object.time) ? globalThis.Number(object.time) : 0,
      worldPos: isSet(object.worldPos) ? CMsgVector2D.fromJSON(object.worldPos) : undefined,
      health: isSet(object.health) ? globalThis.Number(object.health) : 0,
    };
  },

  toJSON(message: CDOTAUserMsgCombatHeroPositions): unknown {
    const obj: any = {};
    if (message.index !== undefined && message.index !== 0) {
      obj.index = Math.round(message.index);
    }
    if (message.time !== undefined && message.time !== 0) {
      obj.time = Math.round(message.time);
    }
    if (message.worldPos !== undefined) {
      obj.worldPos = CMsgVector2D.toJSON(message.worldPos);
    }
    if (message.health !== undefined && message.health !== 0) {
      obj.health = Math.round(message.health);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgCombatHeroPositions>): CDOTAUserMsgCombatHeroPositions {
    return CDOTAUserMsgCombatHeroPositions.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgCombatHeroPositions>): CDOTAUserMsgCombatHeroPositions {
    const message = createBaseCDOTAUserMsgCombatHeroPositions();
    message.index = object.index ?? 0;
    message.time = object.time ?? 0;
    message.worldPos =
      object.worldPos !== undefined && object.worldPos !== null ? CMsgVector2D.fromPartial(object.worldPos) : undefined;
    message.health = object.health ?? 0;
    return message;
  },
};

function createBaseCDOTAUserMsgCombatLogBulkData(): CDOTAUserMsgCombatLogBulkData {
  return { combatEntries: [], timestamp: 0, duration: 0, playerId: -1, requestTime: 0 };
}

export const CDOTAUserMsgCombatLogBulkData = {
  encode(message: CDOTAUserMsgCombatLogBulkData, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.combatEntries) {
      CMsgDOTACombatLogEntry.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.timestamp !== undefined && message.timestamp !== 0) {
      writer.uint32(21).float(message.timestamp);
    }
    if (message.duration !== undefined && message.duration !== 0) {
      writer.uint32(29).float(message.duration);
    }
    if (message.playerId !== undefined && message.playerId !== -1) {
      writer.uint32(32).int32(message.playerId);
    }
    if (message.requestTime !== undefined && message.requestTime !== 0) {
      writer.uint32(45).float(message.requestTime);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgCombatLogBulkData {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgCombatLogBulkData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.combatEntries.push(CMsgDOTACombatLogEntry.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.timestamp = reader.float();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.duration = reader.float();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.playerId = reader.int32();
          continue;
        case 5:
          if (tag !== 45) {
            break;
          }

          message.requestTime = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgCombatLogBulkData {
    return {
      combatEntries: globalThis.Array.isArray(object?.combatEntries)
        ? object.combatEntries.map((e: any) => CMsgDOTACombatLogEntry.fromJSON(e))
        : [],
      timestamp: isSet(object.timestamp) ? globalThis.Number(object.timestamp) : 0,
      duration: isSet(object.duration) ? globalThis.Number(object.duration) : 0,
      playerId: isSet(object.playerId) ? globalThis.Number(object.playerId) : -1,
      requestTime: isSet(object.requestTime) ? globalThis.Number(object.requestTime) : 0,
    };
  },

  toJSON(message: CDOTAUserMsgCombatLogBulkData): unknown {
    const obj: any = {};
    if (message.combatEntries?.length) {
      obj.combatEntries = message.combatEntries.map((e) => CMsgDOTACombatLogEntry.toJSON(e));
    }
    if (message.timestamp !== undefined && message.timestamp !== 0) {
      obj.timestamp = message.timestamp;
    }
    if (message.duration !== undefined && message.duration !== 0) {
      obj.duration = message.duration;
    }
    if (message.playerId !== undefined && message.playerId !== -1) {
      obj.playerId = Math.round(message.playerId);
    }
    if (message.requestTime !== undefined && message.requestTime !== 0) {
      obj.requestTime = message.requestTime;
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgCombatLogBulkData>): CDOTAUserMsgCombatLogBulkData {
    return CDOTAUserMsgCombatLogBulkData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgCombatLogBulkData>): CDOTAUserMsgCombatLogBulkData {
    const message = createBaseCDOTAUserMsgCombatLogBulkData();
    message.combatEntries = object.combatEntries?.map((e) => CMsgDOTACombatLogEntry.fromPartial(e)) || [];
    message.timestamp = object.timestamp ?? 0;
    message.duration = object.duration ?? 0;
    message.playerId = object.playerId ?? -1;
    message.requestTime = object.requestTime ?? 0;
    return message;
  },
};

function createBaseCDOTAUserMsgProjectileParticleCPData(): CDOTAUserMsgProjectileParticleCPData {
  return { controlPoint: 0, vector: undefined };
}

export const CDOTAUserMsgProjectileParticleCPData = {
  encode(message: CDOTAUserMsgProjectileParticleCPData, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.controlPoint !== undefined && message.controlPoint !== 0) {
      writer.uint32(8).int32(message.controlPoint);
    }
    if (message.vector !== undefined) {
      CMsgVector.encode(message.vector, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgProjectileParticleCPData {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgProjectileParticleCPData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.controlPoint = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.vector = CMsgVector.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgProjectileParticleCPData {
    return {
      controlPoint: isSet(object.controlPoint) ? globalThis.Number(object.controlPoint) : 0,
      vector: isSet(object.vector) ? CMsgVector.fromJSON(object.vector) : undefined,
    };
  },

  toJSON(message: CDOTAUserMsgProjectileParticleCPData): unknown {
    const obj: any = {};
    if (message.controlPoint !== undefined && message.controlPoint !== 0) {
      obj.controlPoint = Math.round(message.controlPoint);
    }
    if (message.vector !== undefined) {
      obj.vector = CMsgVector.toJSON(message.vector);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgProjectileParticleCPData>): CDOTAUserMsgProjectileParticleCPData {
    return CDOTAUserMsgProjectileParticleCPData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgProjectileParticleCPData>): CDOTAUserMsgProjectileParticleCPData {
    const message = createBaseCDOTAUserMsgProjectileParticleCPData();
    message.controlPoint = object.controlPoint ?? 0;
    message.vector =
      object.vector !== undefined && object.vector !== null ? CMsgVector.fromPartial(object.vector) : undefined;
    return message;
  },
};

function createBaseCDOTAUserMsgUpdateLinearProjectileCPData(): CDOTAUserMsgUpdateLinearProjectileCPData {
  return { handle: 0, controlPoint: 0, vector: undefined };
}

export const CDOTAUserMsgUpdateLinearProjectileCPData = {
  encode(message: CDOTAUserMsgUpdateLinearProjectileCPData, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.handle !== undefined && message.handle !== 0) {
      writer.uint32(8).int32(message.handle);
    }
    if (message.controlPoint !== undefined && message.controlPoint !== 0) {
      writer.uint32(16).int32(message.controlPoint);
    }
    if (message.vector !== undefined) {
      CMsgVector.encode(message.vector, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgUpdateLinearProjectileCPData {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgUpdateLinearProjectileCPData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.handle = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.controlPoint = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.vector = CMsgVector.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgUpdateLinearProjectileCPData {
    return {
      handle: isSet(object.handle) ? globalThis.Number(object.handle) : 0,
      controlPoint: isSet(object.controlPoint) ? globalThis.Number(object.controlPoint) : 0,
      vector: isSet(object.vector) ? CMsgVector.fromJSON(object.vector) : undefined,
    };
  },

  toJSON(message: CDOTAUserMsgUpdateLinearProjectileCPData): unknown {
    const obj: any = {};
    if (message.handle !== undefined && message.handle !== 0) {
      obj.handle = Math.round(message.handle);
    }
    if (message.controlPoint !== undefined && message.controlPoint !== 0) {
      obj.controlPoint = Math.round(message.controlPoint);
    }
    if (message.vector !== undefined) {
      obj.vector = CMsgVector.toJSON(message.vector);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgUpdateLinearProjectileCPData>): CDOTAUserMsgUpdateLinearProjectileCPData {
    return CDOTAUserMsgUpdateLinearProjectileCPData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgUpdateLinearProjectileCPData>): CDOTAUserMsgUpdateLinearProjectileCPData {
    const message = createBaseCDOTAUserMsgUpdateLinearProjectileCPData();
    message.handle = object.handle ?? 0;
    message.controlPoint = object.controlPoint ?? 0;
    message.vector =
      object.vector !== undefined && object.vector !== null ? CMsgVector.fromPartial(object.vector) : undefined;
    return message;
  },
};

function createBaseCDOTAUserMsgMiniKillCamInfo(): CDOTAUserMsgMiniKillCamInfo {
  return { attackers: [] };
}

export const CDOTAUserMsgMiniKillCamInfo = {
  encode(message: CDOTAUserMsgMiniKillCamInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.attackers) {
      CDOTAUserMsgMiniKillCamInfo_Attacker.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgMiniKillCamInfo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgMiniKillCamInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.attackers.push(CDOTAUserMsgMiniKillCamInfo_Attacker.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgMiniKillCamInfo {
    return {
      attackers: globalThis.Array.isArray(object?.attackers)
        ? object.attackers.map((e: any) => CDOTAUserMsgMiniKillCamInfo_Attacker.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CDOTAUserMsgMiniKillCamInfo): unknown {
    const obj: any = {};
    if (message.attackers?.length) {
      obj.attackers = message.attackers.map((e) => CDOTAUserMsgMiniKillCamInfo_Attacker.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgMiniKillCamInfo>): CDOTAUserMsgMiniKillCamInfo {
    return CDOTAUserMsgMiniKillCamInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgMiniKillCamInfo>): CDOTAUserMsgMiniKillCamInfo {
    const message = createBaseCDOTAUserMsgMiniKillCamInfo();
    message.attackers = object.attackers?.map((e) => CDOTAUserMsgMiniKillCamInfo_Attacker.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCDOTAUserMsgMiniKillCamInfo_Attacker(): CDOTAUserMsgMiniKillCamInfo_Attacker {
  return { attacker: 16777215, totalDamage: 0, abilities: [], attackerName: "" };
}

export const CDOTAUserMsgMiniKillCamInfo_Attacker = {
  encode(message: CDOTAUserMsgMiniKillCamInfo_Attacker, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.attacker !== undefined && message.attacker !== 16777215) {
      writer.uint32(8).uint32(message.attacker);
    }
    if (message.totalDamage !== undefined && message.totalDamage !== 0) {
      writer.uint32(16).int32(message.totalDamage);
    }
    for (const v of message.abilities) {
      CDOTAUserMsgMiniKillCamInfo_Attacker_Ability.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    if (message.attackerName !== undefined && message.attackerName !== "") {
      writer.uint32(34).string(message.attackerName);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgMiniKillCamInfo_Attacker {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgMiniKillCamInfo_Attacker();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.attacker = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.totalDamage = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.abilities.push(CDOTAUserMsgMiniKillCamInfo_Attacker_Ability.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.attackerName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgMiniKillCamInfo_Attacker {
    return {
      attacker: isSet(object.attacker) ? globalThis.Number(object.attacker) : 16777215,
      totalDamage: isSet(object.totalDamage) ? globalThis.Number(object.totalDamage) : 0,
      abilities: globalThis.Array.isArray(object?.abilities)
        ? object.abilities.map((e: any) => CDOTAUserMsgMiniKillCamInfo_Attacker_Ability.fromJSON(e))
        : [],
      attackerName: isSet(object.attackerName) ? globalThis.String(object.attackerName) : "",
    };
  },

  toJSON(message: CDOTAUserMsgMiniKillCamInfo_Attacker): unknown {
    const obj: any = {};
    if (message.attacker !== undefined && message.attacker !== 16777215) {
      obj.attacker = Math.round(message.attacker);
    }
    if (message.totalDamage !== undefined && message.totalDamage !== 0) {
      obj.totalDamage = Math.round(message.totalDamage);
    }
    if (message.abilities?.length) {
      obj.abilities = message.abilities.map((e) => CDOTAUserMsgMiniKillCamInfo_Attacker_Ability.toJSON(e));
    }
    if (message.attackerName !== undefined && message.attackerName !== "") {
      obj.attackerName = message.attackerName;
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgMiniKillCamInfo_Attacker>): CDOTAUserMsgMiniKillCamInfo_Attacker {
    return CDOTAUserMsgMiniKillCamInfo_Attacker.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgMiniKillCamInfo_Attacker>): CDOTAUserMsgMiniKillCamInfo_Attacker {
    const message = createBaseCDOTAUserMsgMiniKillCamInfo_Attacker();
    message.attacker = object.attacker ?? 16777215;
    message.totalDamage = object.totalDamage ?? 0;
    message.abilities = object.abilities?.map((e) => CDOTAUserMsgMiniKillCamInfo_Attacker_Ability.fromPartial(e)) || [];
    message.attackerName = object.attackerName ?? "";
    return message;
  },
};

function createBaseCDOTAUserMsgMiniKillCamInfo_Attacker_Ability(): CDOTAUserMsgMiniKillCamInfo_Attacker_Ability {
  return { abilityId: -1, damage: 0 };
}

export const CDOTAUserMsgMiniKillCamInfo_Attacker_Ability = {
  encode(message: CDOTAUserMsgMiniKillCamInfo_Attacker_Ability, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.abilityId !== undefined && message.abilityId !== -1) {
      writer.uint32(8).int32(message.abilityId);
    }
    if (message.damage !== undefined && message.damage !== 0) {
      writer.uint32(16).int32(message.damage);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgMiniKillCamInfo_Attacker_Ability {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgMiniKillCamInfo_Attacker_Ability();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.abilityId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.damage = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgMiniKillCamInfo_Attacker_Ability {
    return {
      abilityId: isSet(object.abilityId) ? globalThis.Number(object.abilityId) : -1,
      damage: isSet(object.damage) ? globalThis.Number(object.damage) : 0,
    };
  },

  toJSON(message: CDOTAUserMsgMiniKillCamInfo_Attacker_Ability): unknown {
    const obj: any = {};
    if (message.abilityId !== undefined && message.abilityId !== -1) {
      obj.abilityId = Math.round(message.abilityId);
    }
    if (message.damage !== undefined && message.damage !== 0) {
      obj.damage = Math.round(message.damage);
    }
    return obj;
  },

  create(
    base?: DeepPartial<CDOTAUserMsgMiniKillCamInfo_Attacker_Ability>,
  ): CDOTAUserMsgMiniKillCamInfo_Attacker_Ability {
    return CDOTAUserMsgMiniKillCamInfo_Attacker_Ability.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CDOTAUserMsgMiniKillCamInfo_Attacker_Ability>,
  ): CDOTAUserMsgMiniKillCamInfo_Attacker_Ability {
    const message = createBaseCDOTAUserMsgMiniKillCamInfo_Attacker_Ability();
    message.abilityId = object.abilityId ?? -1;
    message.damage = object.damage ?? 0;
    return message;
  },
};

function createBaseCDOTAUserMsgGlobalLightColor(): CDOTAUserMsgGlobalLightColor {
  return { color: 0, duration: 0 };
}

export const CDOTAUserMsgGlobalLightColor = {
  encode(message: CDOTAUserMsgGlobalLightColor, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.color !== undefined && message.color !== 0) {
      writer.uint32(8).uint32(message.color);
    }
    if (message.duration !== undefined && message.duration !== 0) {
      writer.uint32(21).float(message.duration);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgGlobalLightColor {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgGlobalLightColor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.color = reader.uint32();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.duration = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgGlobalLightColor {
    return {
      color: isSet(object.color) ? globalThis.Number(object.color) : 0,
      duration: isSet(object.duration) ? globalThis.Number(object.duration) : 0,
    };
  },

  toJSON(message: CDOTAUserMsgGlobalLightColor): unknown {
    const obj: any = {};
    if (message.color !== undefined && message.color !== 0) {
      obj.color = Math.round(message.color);
    }
    if (message.duration !== undefined && message.duration !== 0) {
      obj.duration = message.duration;
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgGlobalLightColor>): CDOTAUserMsgGlobalLightColor {
    return CDOTAUserMsgGlobalLightColor.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgGlobalLightColor>): CDOTAUserMsgGlobalLightColor {
    const message = createBaseCDOTAUserMsgGlobalLightColor();
    message.color = object.color ?? 0;
    message.duration = object.duration ?? 0;
    return message;
  },
};

function createBaseCDOTAUserMsgGlobalLightDirection(): CDOTAUserMsgGlobalLightDirection {
  return { direction: undefined, duration: 0 };
}

export const CDOTAUserMsgGlobalLightDirection = {
  encode(message: CDOTAUserMsgGlobalLightDirection, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.direction !== undefined) {
      CMsgVector.encode(message.direction, writer.uint32(10).fork()).ldelim();
    }
    if (message.duration !== undefined && message.duration !== 0) {
      writer.uint32(21).float(message.duration);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgGlobalLightDirection {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgGlobalLightDirection();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.direction = CMsgVector.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.duration = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgGlobalLightDirection {
    return {
      direction: isSet(object.direction) ? CMsgVector.fromJSON(object.direction) : undefined,
      duration: isSet(object.duration) ? globalThis.Number(object.duration) : 0,
    };
  },

  toJSON(message: CDOTAUserMsgGlobalLightDirection): unknown {
    const obj: any = {};
    if (message.direction !== undefined) {
      obj.direction = CMsgVector.toJSON(message.direction);
    }
    if (message.duration !== undefined && message.duration !== 0) {
      obj.duration = message.duration;
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgGlobalLightDirection>): CDOTAUserMsgGlobalLightDirection {
    return CDOTAUserMsgGlobalLightDirection.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgGlobalLightDirection>): CDOTAUserMsgGlobalLightDirection {
    const message = createBaseCDOTAUserMsgGlobalLightDirection();
    message.direction =
      object.direction !== undefined && object.direction !== null
        ? CMsgVector.fromPartial(object.direction)
        : undefined;
    message.duration = object.duration ?? 0;
    return message;
  },
};

function createBaseCDOTAUserMsgLocationPing(): CDOTAUserMsgLocationPing {
  return { playerId: -1, locationPing: undefined };
}

export const CDOTAUserMsgLocationPing = {
  encode(message: CDOTAUserMsgLocationPing, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.playerId !== undefined && message.playerId !== -1) {
      writer.uint32(8).int32(message.playerId);
    }
    if (message.locationPing !== undefined) {
      CDOTAMsgLocationPing.encode(message.locationPing, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgLocationPing {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgLocationPing();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.playerId = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.locationPing = CDOTAMsgLocationPing.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgLocationPing {
    return {
      playerId: isSet(object.playerId) ? globalThis.Number(object.playerId) : -1,
      locationPing: isSet(object.locationPing) ? CDOTAMsgLocationPing.fromJSON(object.locationPing) : undefined,
    };
  },

  toJSON(message: CDOTAUserMsgLocationPing): unknown {
    const obj: any = {};
    if (message.playerId !== undefined && message.playerId !== -1) {
      obj.playerId = Math.round(message.playerId);
    }
    if (message.locationPing !== undefined) {
      obj.locationPing = CDOTAMsgLocationPing.toJSON(message.locationPing);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgLocationPing>): CDOTAUserMsgLocationPing {
    return CDOTAUserMsgLocationPing.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgLocationPing>): CDOTAUserMsgLocationPing {
    const message = createBaseCDOTAUserMsgLocationPing();
    message.playerId = object.playerId ?? -1;
    message.locationPing =
      object.locationPing !== undefined && object.locationPing !== null
        ? CDOTAMsgLocationPing.fromPartial(object.locationPing)
        : undefined;
    return message;
  },
};

function createBaseCDOTAUserMsgPingConfirmation(): CDOTAUserMsgPingConfirmation {
  return { playerIdOfOriginalPinger: -1, entityIndex: 0, iconType: 0, location: undefined };
}

export const CDOTAUserMsgPingConfirmation = {
  encode(message: CDOTAUserMsgPingConfirmation, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.playerIdOfOriginalPinger !== undefined && message.playerIdOfOriginalPinger !== -1) {
      writer.uint32(8).int32(message.playerIdOfOriginalPinger);
    }
    if (message.entityIndex !== undefined && message.entityIndex !== 0) {
      writer.uint32(16).uint32(message.entityIndex);
    }
    if (message.iconType !== undefined && message.iconType !== 0) {
      writer.uint32(24).uint32(message.iconType);
    }
    if (message.location !== undefined) {
      CMsgVector.encode(message.location, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgPingConfirmation {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgPingConfirmation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.playerIdOfOriginalPinger = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.entityIndex = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.iconType = reader.uint32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.location = CMsgVector.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgPingConfirmation {
    return {
      playerIdOfOriginalPinger: isSet(object.playerIdOfOriginalPinger)
        ? globalThis.Number(object.playerIdOfOriginalPinger)
        : -1,
      entityIndex: isSet(object.entityIndex) ? globalThis.Number(object.entityIndex) : 0,
      iconType: isSet(object.iconType) ? globalThis.Number(object.iconType) : 0,
      location: isSet(object.location) ? CMsgVector.fromJSON(object.location) : undefined,
    };
  },

  toJSON(message: CDOTAUserMsgPingConfirmation): unknown {
    const obj: any = {};
    if (message.playerIdOfOriginalPinger !== undefined && message.playerIdOfOriginalPinger !== -1) {
      obj.playerIdOfOriginalPinger = Math.round(message.playerIdOfOriginalPinger);
    }
    if (message.entityIndex !== undefined && message.entityIndex !== 0) {
      obj.entityIndex = Math.round(message.entityIndex);
    }
    if (message.iconType !== undefined && message.iconType !== 0) {
      obj.iconType = Math.round(message.iconType);
    }
    if (message.location !== undefined) {
      obj.location = CMsgVector.toJSON(message.location);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgPingConfirmation>): CDOTAUserMsgPingConfirmation {
    return CDOTAUserMsgPingConfirmation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgPingConfirmation>): CDOTAUserMsgPingConfirmation {
    const message = createBaseCDOTAUserMsgPingConfirmation();
    message.playerIdOfOriginalPinger = object.playerIdOfOriginalPinger ?? -1;
    message.entityIndex = object.entityIndex ?? 0;
    message.iconType = object.iconType ?? 0;
    message.location =
      object.location !== undefined && object.location !== null ? CMsgVector.fromPartial(object.location) : undefined;
    return message;
  },
};

function createBaseCDOTAUserMsgItemAlert(): CDOTAUserMsgItemAlert {
  return { playerId: -1, itemAlert: undefined };
}

export const CDOTAUserMsgItemAlert = {
  encode(message: CDOTAUserMsgItemAlert, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.playerId !== undefined && message.playerId !== -1) {
      writer.uint32(8).int32(message.playerId);
    }
    if (message.itemAlert !== undefined) {
      CDOTAMsgItemAlert.encode(message.itemAlert, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgItemAlert {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgItemAlert();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.playerId = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.itemAlert = CDOTAMsgItemAlert.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgItemAlert {
    return {
      playerId: isSet(object.playerId) ? globalThis.Number(object.playerId) : -1,
      itemAlert: isSet(object.itemAlert) ? CDOTAMsgItemAlert.fromJSON(object.itemAlert) : undefined,
    };
  },

  toJSON(message: CDOTAUserMsgItemAlert): unknown {
    const obj: any = {};
    if (message.playerId !== undefined && message.playerId !== -1) {
      obj.playerId = Math.round(message.playerId);
    }
    if (message.itemAlert !== undefined) {
      obj.itemAlert = CDOTAMsgItemAlert.toJSON(message.itemAlert);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgItemAlert>): CDOTAUserMsgItemAlert {
    return CDOTAUserMsgItemAlert.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgItemAlert>): CDOTAUserMsgItemAlert {
    const message = createBaseCDOTAUserMsgItemAlert();
    message.playerId = object.playerId ?? -1;
    message.itemAlert =
      object.itemAlert !== undefined && object.itemAlert !== null
        ? CDOTAMsgItemAlert.fromPartial(object.itemAlert)
        : undefined;
    return message;
  },
};

function createBaseCDOTAUserMsgEnemyItemAlert(): CDOTAUserMsgEnemyItemAlert {
  return {
    playerId: -1,
    targetPlayerId: -1,
    itemAbilityId: -1,
    runeType: -1,
    entityId: 0,
    itemLevel: -1,
    primaryCharges: -1,
    secondaryCharges: -1,
  };
}

export const CDOTAUserMsgEnemyItemAlert = {
  encode(message: CDOTAUserMsgEnemyItemAlert, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.playerId !== undefined && message.playerId !== -1) {
      writer.uint32(8).int32(message.playerId);
    }
    if (message.targetPlayerId !== undefined && message.targetPlayerId !== -1) {
      writer.uint32(16).int32(message.targetPlayerId);
    }
    if (message.itemAbilityId !== undefined && message.itemAbilityId !== -1) {
      writer.uint32(24).int32(message.itemAbilityId);
    }
    if (message.runeType !== undefined && message.runeType !== -1) {
      writer.uint32(32).int32(message.runeType);
    }
    if (message.entityId !== undefined && message.entityId !== 0) {
      writer.uint32(40).int32(message.entityId);
    }
    if (message.itemLevel !== undefined && message.itemLevel !== -1) {
      writer.uint32(48).int32(message.itemLevel);
    }
    if (message.primaryCharges !== undefined && message.primaryCharges !== -1) {
      writer.uint32(56).int32(message.primaryCharges);
    }
    if (message.secondaryCharges !== undefined && message.secondaryCharges !== -1) {
      writer.uint32(64).int32(message.secondaryCharges);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgEnemyItemAlert {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgEnemyItemAlert();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.playerId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.targetPlayerId = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.itemAbilityId = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.runeType = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.entityId = reader.int32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.itemLevel = reader.int32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.primaryCharges = reader.int32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.secondaryCharges = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgEnemyItemAlert {
    return {
      playerId: isSet(object.playerId) ? globalThis.Number(object.playerId) : -1,
      targetPlayerId: isSet(object.targetPlayerId) ? globalThis.Number(object.targetPlayerId) : -1,
      itemAbilityId: isSet(object.itemAbilityId) ? globalThis.Number(object.itemAbilityId) : -1,
      runeType: isSet(object.runeType) ? globalThis.Number(object.runeType) : -1,
      entityId: isSet(object.entityId) ? globalThis.Number(object.entityId) : 0,
      itemLevel: isSet(object.itemLevel) ? globalThis.Number(object.itemLevel) : -1,
      primaryCharges: isSet(object.primaryCharges) ? globalThis.Number(object.primaryCharges) : -1,
      secondaryCharges: isSet(object.secondaryCharges) ? globalThis.Number(object.secondaryCharges) : -1,
    };
  },

  toJSON(message: CDOTAUserMsgEnemyItemAlert): unknown {
    const obj: any = {};
    if (message.playerId !== undefined && message.playerId !== -1) {
      obj.playerId = Math.round(message.playerId);
    }
    if (message.targetPlayerId !== undefined && message.targetPlayerId !== -1) {
      obj.targetPlayerId = Math.round(message.targetPlayerId);
    }
    if (message.itemAbilityId !== undefined && message.itemAbilityId !== -1) {
      obj.itemAbilityId = Math.round(message.itemAbilityId);
    }
    if (message.runeType !== undefined && message.runeType !== -1) {
      obj.runeType = Math.round(message.runeType);
    }
    if (message.entityId !== undefined && message.entityId !== 0) {
      obj.entityId = Math.round(message.entityId);
    }
    if (message.itemLevel !== undefined && message.itemLevel !== -1) {
      obj.itemLevel = Math.round(message.itemLevel);
    }
    if (message.primaryCharges !== undefined && message.primaryCharges !== -1) {
      obj.primaryCharges = Math.round(message.primaryCharges);
    }
    if (message.secondaryCharges !== undefined && message.secondaryCharges !== -1) {
      obj.secondaryCharges = Math.round(message.secondaryCharges);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgEnemyItemAlert>): CDOTAUserMsgEnemyItemAlert {
    return CDOTAUserMsgEnemyItemAlert.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgEnemyItemAlert>): CDOTAUserMsgEnemyItemAlert {
    const message = createBaseCDOTAUserMsgEnemyItemAlert();
    message.playerId = object.playerId ?? -1;
    message.targetPlayerId = object.targetPlayerId ?? -1;
    message.itemAbilityId = object.itemAbilityId ?? -1;
    message.runeType = object.runeType ?? -1;
    message.entityId = object.entityId ?? 0;
    message.itemLevel = object.itemLevel ?? -1;
    message.primaryCharges = object.primaryCharges ?? -1;
    message.secondaryCharges = object.secondaryCharges ?? -1;
    return message;
  },
};

function createBaseCDOTAUserMsgModifierAlert(): CDOTAUserMsgModifierAlert {
  return { playerId: -1, className: "", stackCount: 0, isDebuff: false, targetEntindex: -1, secondsRemaining: 0 };
}

export const CDOTAUserMsgModifierAlert = {
  encode(message: CDOTAUserMsgModifierAlert, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.playerId !== undefined && message.playerId !== -1) {
      writer.uint32(8).int32(message.playerId);
    }
    if (message.className !== undefined && message.className !== "") {
      writer.uint32(18).string(message.className);
    }
    if (message.stackCount !== undefined && message.stackCount !== 0) {
      writer.uint32(24).uint32(message.stackCount);
    }
    if (message.isDebuff !== undefined && message.isDebuff !== false) {
      writer.uint32(32).bool(message.isDebuff);
    }
    if (message.targetEntindex !== undefined && message.targetEntindex !== -1) {
      writer.uint32(40).int32(message.targetEntindex);
    }
    if (message.secondsRemaining !== undefined && message.secondsRemaining !== 0) {
      writer.uint32(53).float(message.secondsRemaining);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgModifierAlert {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgModifierAlert();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.playerId = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.className = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.stackCount = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.isDebuff = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.targetEntindex = reader.int32();
          continue;
        case 6:
          if (tag !== 53) {
            break;
          }

          message.secondsRemaining = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgModifierAlert {
    return {
      playerId: isSet(object.playerId) ? globalThis.Number(object.playerId) : -1,
      className: isSet(object.className) ? globalThis.String(object.className) : "",
      stackCount: isSet(object.stackCount) ? globalThis.Number(object.stackCount) : 0,
      isDebuff: isSet(object.isDebuff) ? globalThis.Boolean(object.isDebuff) : false,
      targetEntindex: isSet(object.targetEntindex) ? globalThis.Number(object.targetEntindex) : -1,
      secondsRemaining: isSet(object.secondsRemaining) ? globalThis.Number(object.secondsRemaining) : 0,
    };
  },

  toJSON(message: CDOTAUserMsgModifierAlert): unknown {
    const obj: any = {};
    if (message.playerId !== undefined && message.playerId !== -1) {
      obj.playerId = Math.round(message.playerId);
    }
    if (message.className !== undefined && message.className !== "") {
      obj.className = message.className;
    }
    if (message.stackCount !== undefined && message.stackCount !== 0) {
      obj.stackCount = Math.round(message.stackCount);
    }
    if (message.isDebuff !== undefined && message.isDebuff !== false) {
      obj.isDebuff = message.isDebuff;
    }
    if (message.targetEntindex !== undefined && message.targetEntindex !== -1) {
      obj.targetEntindex = Math.round(message.targetEntindex);
    }
    if (message.secondsRemaining !== undefined && message.secondsRemaining !== 0) {
      obj.secondsRemaining = message.secondsRemaining;
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgModifierAlert>): CDOTAUserMsgModifierAlert {
    return CDOTAUserMsgModifierAlert.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgModifierAlert>): CDOTAUserMsgModifierAlert {
    const message = createBaseCDOTAUserMsgModifierAlert();
    message.playerId = object.playerId ?? -1;
    message.className = object.className ?? "";
    message.stackCount = object.stackCount ?? 0;
    message.isDebuff = object.isDebuff ?? false;
    message.targetEntindex = object.targetEntindex ?? -1;
    message.secondsRemaining = object.secondsRemaining ?? 0;
    return message;
  },
};

function createBaseCDOTAUserMsgHPManaAlert(): CDOTAUserMsgHPManaAlert {
  return { playerId: -1, targetEntindex: -1, showRawValues: false };
}

export const CDOTAUserMsgHPManaAlert = {
  encode(message: CDOTAUserMsgHPManaAlert, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.playerId !== undefined && message.playerId !== -1) {
      writer.uint32(8).int32(message.playerId);
    }
    if (message.targetEntindex !== undefined && message.targetEntindex !== -1) {
      writer.uint32(16).int32(message.targetEntindex);
    }
    if (message.showRawValues !== undefined && message.showRawValues !== false) {
      writer.uint32(24).bool(message.showRawValues);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgHPManaAlert {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgHPManaAlert();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.playerId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.targetEntindex = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.showRawValues = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgHPManaAlert {
    return {
      playerId: isSet(object.playerId) ? globalThis.Number(object.playerId) : -1,
      targetEntindex: isSet(object.targetEntindex) ? globalThis.Number(object.targetEntindex) : -1,
      showRawValues: isSet(object.showRawValues) ? globalThis.Boolean(object.showRawValues) : false,
    };
  },

  toJSON(message: CDOTAUserMsgHPManaAlert): unknown {
    const obj: any = {};
    if (message.playerId !== undefined && message.playerId !== -1) {
      obj.playerId = Math.round(message.playerId);
    }
    if (message.targetEntindex !== undefined && message.targetEntindex !== -1) {
      obj.targetEntindex = Math.round(message.targetEntindex);
    }
    if (message.showRawValues !== undefined && message.showRawValues !== false) {
      obj.showRawValues = message.showRawValues;
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgHPManaAlert>): CDOTAUserMsgHPManaAlert {
    return CDOTAUserMsgHPManaAlert.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgHPManaAlert>): CDOTAUserMsgHPManaAlert {
    const message = createBaseCDOTAUserMsgHPManaAlert();
    message.playerId = object.playerId ?? -1;
    message.targetEntindex = object.targetEntindex ?? -1;
    message.showRawValues = object.showRawValues ?? false;
    return message;
  },
};

function createBaseCDOTAUserMsgNeutralCampAlert(): CDOTAUserMsgNeutralCampAlert {
  return {
    playerId: -1,
    spawnerEntindex: -1,
    unitEntindex: -1,
    stackCount: 0,
    campType: 0,
    stackRequest: false,
    stackIntention: false,
  };
}

export const CDOTAUserMsgNeutralCampAlert = {
  encode(message: CDOTAUserMsgNeutralCampAlert, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.playerId !== undefined && message.playerId !== -1) {
      writer.uint32(8).int32(message.playerId);
    }
    if (message.spawnerEntindex !== undefined && message.spawnerEntindex !== -1) {
      writer.uint32(16).int32(message.spawnerEntindex);
    }
    if (message.unitEntindex !== undefined && message.unitEntindex !== -1) {
      writer.uint32(24).int32(message.unitEntindex);
    }
    if (message.stackCount !== undefined && message.stackCount !== 0) {
      writer.uint32(32).int32(message.stackCount);
    }
    if (message.campType !== undefined && message.campType !== 0) {
      writer.uint32(40).int32(message.campType);
    }
    if (message.stackRequest !== undefined && message.stackRequest !== false) {
      writer.uint32(48).bool(message.stackRequest);
    }
    if (message.stackIntention !== undefined && message.stackIntention !== false) {
      writer.uint32(56).bool(message.stackIntention);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgNeutralCampAlert {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgNeutralCampAlert();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.playerId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.spawnerEntindex = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.unitEntindex = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.stackCount = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.campType = reader.int32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.stackRequest = reader.bool();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.stackIntention = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgNeutralCampAlert {
    return {
      playerId: isSet(object.playerId) ? globalThis.Number(object.playerId) : -1,
      spawnerEntindex: isSet(object.spawnerEntindex) ? globalThis.Number(object.spawnerEntindex) : -1,
      unitEntindex: isSet(object.unitEntindex) ? globalThis.Number(object.unitEntindex) : -1,
      stackCount: isSet(object.stackCount) ? globalThis.Number(object.stackCount) : 0,
      campType: isSet(object.campType) ? globalThis.Number(object.campType) : 0,
      stackRequest: isSet(object.stackRequest) ? globalThis.Boolean(object.stackRequest) : false,
      stackIntention: isSet(object.stackIntention) ? globalThis.Boolean(object.stackIntention) : false,
    };
  },

  toJSON(message: CDOTAUserMsgNeutralCampAlert): unknown {
    const obj: any = {};
    if (message.playerId !== undefined && message.playerId !== -1) {
      obj.playerId = Math.round(message.playerId);
    }
    if (message.spawnerEntindex !== undefined && message.spawnerEntindex !== -1) {
      obj.spawnerEntindex = Math.round(message.spawnerEntindex);
    }
    if (message.unitEntindex !== undefined && message.unitEntindex !== -1) {
      obj.unitEntindex = Math.round(message.unitEntindex);
    }
    if (message.stackCount !== undefined && message.stackCount !== 0) {
      obj.stackCount = Math.round(message.stackCount);
    }
    if (message.campType !== undefined && message.campType !== 0) {
      obj.campType = Math.round(message.campType);
    }
    if (message.stackRequest !== undefined && message.stackRequest !== false) {
      obj.stackRequest = message.stackRequest;
    }
    if (message.stackIntention !== undefined && message.stackIntention !== false) {
      obj.stackIntention = message.stackIntention;
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgNeutralCampAlert>): CDOTAUserMsgNeutralCampAlert {
    return CDOTAUserMsgNeutralCampAlert.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgNeutralCampAlert>): CDOTAUserMsgNeutralCampAlert {
    const message = createBaseCDOTAUserMsgNeutralCampAlert();
    message.playerId = object.playerId ?? -1;
    message.spawnerEntindex = object.spawnerEntindex ?? -1;
    message.unitEntindex = object.unitEntindex ?? -1;
    message.stackCount = object.stackCount ?? 0;
    message.campType = object.campType ?? 0;
    message.stackRequest = object.stackRequest ?? false;
    message.stackIntention = object.stackIntention ?? false;
    return message;
  },
};

function createBaseCDOTAUserMsgGlyphAlert(): CDOTAUserMsgGlyphAlert {
  return { playerId: -1, negative: false };
}

export const CDOTAUserMsgGlyphAlert = {
  encode(message: CDOTAUserMsgGlyphAlert, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.playerId !== undefined && message.playerId !== -1) {
      writer.uint32(8).int32(message.playerId);
    }
    if (message.negative !== undefined && message.negative !== false) {
      writer.uint32(16).bool(message.negative);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgGlyphAlert {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgGlyphAlert();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.playerId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.negative = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgGlyphAlert {
    return {
      playerId: isSet(object.playerId) ? globalThis.Number(object.playerId) : -1,
      negative: isSet(object.negative) ? globalThis.Boolean(object.negative) : false,
    };
  },

  toJSON(message: CDOTAUserMsgGlyphAlert): unknown {
    const obj: any = {};
    if (message.playerId !== undefined && message.playerId !== -1) {
      obj.playerId = Math.round(message.playerId);
    }
    if (message.negative !== undefined && message.negative !== false) {
      obj.negative = message.negative;
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgGlyphAlert>): CDOTAUserMsgGlyphAlert {
    return CDOTAUserMsgGlyphAlert.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgGlyphAlert>): CDOTAUserMsgGlyphAlert {
    const message = createBaseCDOTAUserMsgGlyphAlert();
    message.playerId = object.playerId ?? -1;
    message.negative = object.negative ?? false;
    return message;
  },
};

function createBaseCDOTAUserMsgRadarAlert(): CDOTAUserMsgRadarAlert {
  return { playerId: -1, negative: false };
}

export const CDOTAUserMsgRadarAlert = {
  encode(message: CDOTAUserMsgRadarAlert, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.playerId !== undefined && message.playerId !== -1) {
      writer.uint32(8).int32(message.playerId);
    }
    if (message.negative !== undefined && message.negative !== false) {
      writer.uint32(16).bool(message.negative);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgRadarAlert {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgRadarAlert();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.playerId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.negative = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgRadarAlert {
    return {
      playerId: isSet(object.playerId) ? globalThis.Number(object.playerId) : -1,
      negative: isSet(object.negative) ? globalThis.Boolean(object.negative) : false,
    };
  },

  toJSON(message: CDOTAUserMsgRadarAlert): unknown {
    const obj: any = {};
    if (message.playerId !== undefined && message.playerId !== -1) {
      obj.playerId = Math.round(message.playerId);
    }
    if (message.negative !== undefined && message.negative !== false) {
      obj.negative = message.negative;
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgRadarAlert>): CDOTAUserMsgRadarAlert {
    return CDOTAUserMsgRadarAlert.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgRadarAlert>): CDOTAUserMsgRadarAlert {
    const message = createBaseCDOTAUserMsgRadarAlert();
    message.playerId = object.playerId ?? -1;
    message.negative = object.negative ?? false;
    return message;
  },
};

function createBaseCDOTAUserMsgWillPurchaseAlert(): CDOTAUserMsgWillPurchaseAlert {
  return { itemAbilityId: -1, playerId: -1, goldRemaining: 0, suggestionPlayerId: -1 };
}

export const CDOTAUserMsgWillPurchaseAlert = {
  encode(message: CDOTAUserMsgWillPurchaseAlert, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.itemAbilityId !== undefined && message.itemAbilityId !== -1) {
      writer.uint32(8).int32(message.itemAbilityId);
    }
    if (message.playerId !== undefined && message.playerId !== -1) {
      writer.uint32(16).int32(message.playerId);
    }
    if (message.goldRemaining !== undefined && message.goldRemaining !== 0) {
      writer.uint32(24).uint32(message.goldRemaining);
    }
    if (message.suggestionPlayerId !== undefined && message.suggestionPlayerId !== -1) {
      writer.uint32(32).int32(message.suggestionPlayerId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgWillPurchaseAlert {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgWillPurchaseAlert();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.itemAbilityId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.playerId = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.goldRemaining = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.suggestionPlayerId = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgWillPurchaseAlert {
    return {
      itemAbilityId: isSet(object.itemAbilityId) ? globalThis.Number(object.itemAbilityId) : -1,
      playerId: isSet(object.playerId) ? globalThis.Number(object.playerId) : -1,
      goldRemaining: isSet(object.goldRemaining) ? globalThis.Number(object.goldRemaining) : 0,
      suggestionPlayerId: isSet(object.suggestionPlayerId) ? globalThis.Number(object.suggestionPlayerId) : -1,
    };
  },

  toJSON(message: CDOTAUserMsgWillPurchaseAlert): unknown {
    const obj: any = {};
    if (message.itemAbilityId !== undefined && message.itemAbilityId !== -1) {
      obj.itemAbilityId = Math.round(message.itemAbilityId);
    }
    if (message.playerId !== undefined && message.playerId !== -1) {
      obj.playerId = Math.round(message.playerId);
    }
    if (message.goldRemaining !== undefined && message.goldRemaining !== 0) {
      obj.goldRemaining = Math.round(message.goldRemaining);
    }
    if (message.suggestionPlayerId !== undefined && message.suggestionPlayerId !== -1) {
      obj.suggestionPlayerId = Math.round(message.suggestionPlayerId);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgWillPurchaseAlert>): CDOTAUserMsgWillPurchaseAlert {
    return CDOTAUserMsgWillPurchaseAlert.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgWillPurchaseAlert>): CDOTAUserMsgWillPurchaseAlert {
    const message = createBaseCDOTAUserMsgWillPurchaseAlert();
    message.itemAbilityId = object.itemAbilityId ?? -1;
    message.playerId = object.playerId ?? -1;
    message.goldRemaining = object.goldRemaining ?? 0;
    message.suggestionPlayerId = object.suggestionPlayerId ?? -1;
    return message;
  },
};

function createBaseCDOTAUserMsgEmptyTeleportAlert(): CDOTAUserMsgEmptyTeleportAlert {
  return { sourcePlayerId: -1, targetPlayerId: -1, cooldownSeconds: 0 };
}

export const CDOTAUserMsgEmptyTeleportAlert = {
  encode(message: CDOTAUserMsgEmptyTeleportAlert, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sourcePlayerId !== undefined && message.sourcePlayerId !== -1) {
      writer.uint32(8).int32(message.sourcePlayerId);
    }
    if (message.targetPlayerId !== undefined && message.targetPlayerId !== -1) {
      writer.uint32(16).int32(message.targetPlayerId);
    }
    if (message.cooldownSeconds !== undefined && message.cooldownSeconds !== 0) {
      writer.uint32(24).int32(message.cooldownSeconds);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgEmptyTeleportAlert {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgEmptyTeleportAlert();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.sourcePlayerId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.targetPlayerId = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.cooldownSeconds = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgEmptyTeleportAlert {
    return {
      sourcePlayerId: isSet(object.sourcePlayerId) ? globalThis.Number(object.sourcePlayerId) : -1,
      targetPlayerId: isSet(object.targetPlayerId) ? globalThis.Number(object.targetPlayerId) : -1,
      cooldownSeconds: isSet(object.cooldownSeconds) ? globalThis.Number(object.cooldownSeconds) : 0,
    };
  },

  toJSON(message: CDOTAUserMsgEmptyTeleportAlert): unknown {
    const obj: any = {};
    if (message.sourcePlayerId !== undefined && message.sourcePlayerId !== -1) {
      obj.sourcePlayerId = Math.round(message.sourcePlayerId);
    }
    if (message.targetPlayerId !== undefined && message.targetPlayerId !== -1) {
      obj.targetPlayerId = Math.round(message.targetPlayerId);
    }
    if (message.cooldownSeconds !== undefined && message.cooldownSeconds !== 0) {
      obj.cooldownSeconds = Math.round(message.cooldownSeconds);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgEmptyTeleportAlert>): CDOTAUserMsgEmptyTeleportAlert {
    return CDOTAUserMsgEmptyTeleportAlert.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgEmptyTeleportAlert>): CDOTAUserMsgEmptyTeleportAlert {
    const message = createBaseCDOTAUserMsgEmptyTeleportAlert();
    message.sourcePlayerId = object.sourcePlayerId ?? -1;
    message.targetPlayerId = object.targetPlayerId ?? -1;
    message.cooldownSeconds = object.cooldownSeconds ?? 0;
    return message;
  },
};

function createBaseCDOTAUserMsgMarsArenaOfBloodAttack(): CDOTAUserMsgMarsArenaOfBloodAttack {
  return { sourceEhandle: 16777215, targetEhandle: 16777215, warriorIndex: 0 };
}

export const CDOTAUserMsgMarsArenaOfBloodAttack = {
  encode(message: CDOTAUserMsgMarsArenaOfBloodAttack, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sourceEhandle !== undefined && message.sourceEhandle !== 16777215) {
      writer.uint32(8).uint32(message.sourceEhandle);
    }
    if (message.targetEhandle !== undefined && message.targetEhandle !== 16777215) {
      writer.uint32(16).uint32(message.targetEhandle);
    }
    if (message.warriorIndex !== undefined && message.warriorIndex !== 0) {
      writer.uint32(24).int32(message.warriorIndex);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgMarsArenaOfBloodAttack {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgMarsArenaOfBloodAttack();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.sourceEhandle = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.targetEhandle = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.warriorIndex = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgMarsArenaOfBloodAttack {
    return {
      sourceEhandle: isSet(object.sourceEhandle) ? globalThis.Number(object.sourceEhandle) : 16777215,
      targetEhandle: isSet(object.targetEhandle) ? globalThis.Number(object.targetEhandle) : 16777215,
      warriorIndex: isSet(object.warriorIndex) ? globalThis.Number(object.warriorIndex) : 0,
    };
  },

  toJSON(message: CDOTAUserMsgMarsArenaOfBloodAttack): unknown {
    const obj: any = {};
    if (message.sourceEhandle !== undefined && message.sourceEhandle !== 16777215) {
      obj.sourceEhandle = Math.round(message.sourceEhandle);
    }
    if (message.targetEhandle !== undefined && message.targetEhandle !== 16777215) {
      obj.targetEhandle = Math.round(message.targetEhandle);
    }
    if (message.warriorIndex !== undefined && message.warriorIndex !== 0) {
      obj.warriorIndex = Math.round(message.warriorIndex);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgMarsArenaOfBloodAttack>): CDOTAUserMsgMarsArenaOfBloodAttack {
    return CDOTAUserMsgMarsArenaOfBloodAttack.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgMarsArenaOfBloodAttack>): CDOTAUserMsgMarsArenaOfBloodAttack {
    const message = createBaseCDOTAUserMsgMarsArenaOfBloodAttack();
    message.sourceEhandle = object.sourceEhandle ?? 16777215;
    message.targetEhandle = object.targetEhandle ?? 16777215;
    message.warriorIndex = object.warriorIndex ?? 0;
    return message;
  },
};

function createBaseCDOTAEntityMsgInvokerSpellCast(): CDOTAEntityMsgInvokerSpellCast {
  return { entityMsg: undefined, castActivity: 0 };
}

export const CDOTAEntityMsgInvokerSpellCast = {
  encode(message: CDOTAEntityMsgInvokerSpellCast, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.entityMsg !== undefined) {
      CEntityMsg.encode(message.entityMsg, writer.uint32(10).fork()).ldelim();
    }
    if (message.castActivity !== undefined && message.castActivity !== 0) {
      writer.uint32(16).int32(message.castActivity);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAEntityMsgInvokerSpellCast {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAEntityMsgInvokerSpellCast();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.entityMsg = CEntityMsg.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.castActivity = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAEntityMsgInvokerSpellCast {
    return {
      entityMsg: isSet(object.entityMsg) ? CEntityMsg.fromJSON(object.entityMsg) : undefined,
      castActivity: isSet(object.castActivity) ? globalThis.Number(object.castActivity) : 0,
    };
  },

  toJSON(message: CDOTAEntityMsgInvokerSpellCast): unknown {
    const obj: any = {};
    if (message.entityMsg !== undefined) {
      obj.entityMsg = CEntityMsg.toJSON(message.entityMsg);
    }
    if (message.castActivity !== undefined && message.castActivity !== 0) {
      obj.castActivity = Math.round(message.castActivity);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAEntityMsgInvokerSpellCast>): CDOTAEntityMsgInvokerSpellCast {
    return CDOTAEntityMsgInvokerSpellCast.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAEntityMsgInvokerSpellCast>): CDOTAEntityMsgInvokerSpellCast {
    const message = createBaseCDOTAEntityMsgInvokerSpellCast();
    message.entityMsg =
      object.entityMsg !== undefined && object.entityMsg !== null
        ? CEntityMsg.fromPartial(object.entityMsg)
        : undefined;
    message.castActivity = object.castActivity ?? 0;
    return message;
  },
};

function createBaseCDOTAUserMsgBuyBackStateAlert(): CDOTAUserMsgBuyBackStateAlert {
  return { playerId: -1 };
}

export const CDOTAUserMsgBuyBackStateAlert = {
  encode(message: CDOTAUserMsgBuyBackStateAlert, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.playerId !== undefined && message.playerId !== -1) {
      writer.uint32(8).int32(message.playerId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgBuyBackStateAlert {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgBuyBackStateAlert();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.playerId = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgBuyBackStateAlert {
    return { playerId: isSet(object.playerId) ? globalThis.Number(object.playerId) : -1 };
  },

  toJSON(message: CDOTAUserMsgBuyBackStateAlert): unknown {
    const obj: any = {};
    if (message.playerId !== undefined && message.playerId !== -1) {
      obj.playerId = Math.round(message.playerId);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgBuyBackStateAlert>): CDOTAUserMsgBuyBackStateAlert {
    return CDOTAUserMsgBuyBackStateAlert.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgBuyBackStateAlert>): CDOTAUserMsgBuyBackStateAlert {
    const message = createBaseCDOTAUserMsgBuyBackStateAlert();
    message.playerId = object.playerId ?? -1;
    return message;
  },
};

function createBaseCDOTAUserMsgQuickBuyAlert(): CDOTAUserMsgQuickBuyAlert {
  return { playerId: -1, itemAbilityId: -1, goldCost: 0, itemCooldownSeconds: 0, showBuyback: false };
}

export const CDOTAUserMsgQuickBuyAlert = {
  encode(message: CDOTAUserMsgQuickBuyAlert, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.playerId !== undefined && message.playerId !== -1) {
      writer.uint32(8).int32(message.playerId);
    }
    if (message.itemAbilityId !== undefined && message.itemAbilityId !== -1) {
      writer.uint32(16).int32(message.itemAbilityId);
    }
    if (message.goldCost !== undefined && message.goldCost !== 0) {
      writer.uint32(24).int32(message.goldCost);
    }
    if (message.itemCooldownSeconds !== undefined && message.itemCooldownSeconds !== 0) {
      writer.uint32(32).int32(message.itemCooldownSeconds);
    }
    if (message.showBuyback !== undefined && message.showBuyback !== false) {
      writer.uint32(40).bool(message.showBuyback);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgQuickBuyAlert {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgQuickBuyAlert();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.playerId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.itemAbilityId = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.goldCost = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.itemCooldownSeconds = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.showBuyback = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgQuickBuyAlert {
    return {
      playerId: isSet(object.playerId) ? globalThis.Number(object.playerId) : -1,
      itemAbilityId: isSet(object.itemAbilityId) ? globalThis.Number(object.itemAbilityId) : -1,
      goldCost: isSet(object.goldCost) ? globalThis.Number(object.goldCost) : 0,
      itemCooldownSeconds: isSet(object.itemCooldownSeconds) ? globalThis.Number(object.itemCooldownSeconds) : 0,
      showBuyback: isSet(object.showBuyback) ? globalThis.Boolean(object.showBuyback) : false,
    };
  },

  toJSON(message: CDOTAUserMsgQuickBuyAlert): unknown {
    const obj: any = {};
    if (message.playerId !== undefined && message.playerId !== -1) {
      obj.playerId = Math.round(message.playerId);
    }
    if (message.itemAbilityId !== undefined && message.itemAbilityId !== -1) {
      obj.itemAbilityId = Math.round(message.itemAbilityId);
    }
    if (message.goldCost !== undefined && message.goldCost !== 0) {
      obj.goldCost = Math.round(message.goldCost);
    }
    if (message.itemCooldownSeconds !== undefined && message.itemCooldownSeconds !== 0) {
      obj.itemCooldownSeconds = Math.round(message.itemCooldownSeconds);
    }
    if (message.showBuyback !== undefined && message.showBuyback !== false) {
      obj.showBuyback = message.showBuyback;
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgQuickBuyAlert>): CDOTAUserMsgQuickBuyAlert {
    return CDOTAUserMsgQuickBuyAlert.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgQuickBuyAlert>): CDOTAUserMsgQuickBuyAlert {
    const message = createBaseCDOTAUserMsgQuickBuyAlert();
    message.playerId = object.playerId ?? -1;
    message.itemAbilityId = object.itemAbilityId ?? -1;
    message.goldCost = object.goldCost ?? 0;
    message.itemCooldownSeconds = object.itemCooldownSeconds ?? 0;
    message.showBuyback = object.showBuyback ?? false;
    return message;
  },
};

function createBaseCDOTAUserMsgCourierKilledAlert(): CDOTAUserMsgCourierKilledAlert {
  return {
    team: 0,
    goldValue: 0,
    entityHandle: 16777215,
    timestamp: 0,
    lostItems: [],
    killerPlayerId: -1,
    owningPlayerId: -1,
  };
}

export const CDOTAUserMsgCourierKilledAlert = {
  encode(message: CDOTAUserMsgCourierKilledAlert, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.team !== undefined && message.team !== 0) {
      writer.uint32(8).uint32(message.team);
    }
    if (message.goldValue !== undefined && message.goldValue !== 0) {
      writer.uint32(16).uint32(message.goldValue);
    }
    if (message.entityHandle !== undefined && message.entityHandle !== 16777215) {
      writer.uint32(24).uint32(message.entityHandle);
    }
    if (message.timestamp !== undefined && message.timestamp !== 0) {
      writer.uint32(32).int32(message.timestamp);
    }
    for (const v of message.lostItems) {
      CDOTAUserMsgCourierKilledAlert_LostItem.encode(v!, writer.uint32(42).fork()).ldelim();
    }
    if (message.killerPlayerId !== undefined && message.killerPlayerId !== -1) {
      writer.uint32(48).int32(message.killerPlayerId);
    }
    if (message.owningPlayerId !== undefined && message.owningPlayerId !== -1) {
      writer.uint32(56).int32(message.owningPlayerId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgCourierKilledAlert {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgCourierKilledAlert();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.team = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.goldValue = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.entityHandle = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.timestamp = reader.int32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.lostItems.push(CDOTAUserMsgCourierKilledAlert_LostItem.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.killerPlayerId = reader.int32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.owningPlayerId = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgCourierKilledAlert {
    return {
      team: isSet(object.team) ? globalThis.Number(object.team) : 0,
      goldValue: isSet(object.goldValue) ? globalThis.Number(object.goldValue) : 0,
      entityHandle: isSet(object.entityHandle) ? globalThis.Number(object.entityHandle) : 16777215,
      timestamp: isSet(object.timestamp) ? globalThis.Number(object.timestamp) : 0,
      lostItems: globalThis.Array.isArray(object?.lostItems)
        ? object.lostItems.map((e: any) => CDOTAUserMsgCourierKilledAlert_LostItem.fromJSON(e))
        : [],
      killerPlayerId: isSet(object.killerPlayerId) ? globalThis.Number(object.killerPlayerId) : -1,
      owningPlayerId: isSet(object.owningPlayerId) ? globalThis.Number(object.owningPlayerId) : -1,
    };
  },

  toJSON(message: CDOTAUserMsgCourierKilledAlert): unknown {
    const obj: any = {};
    if (message.team !== undefined && message.team !== 0) {
      obj.team = Math.round(message.team);
    }
    if (message.goldValue !== undefined && message.goldValue !== 0) {
      obj.goldValue = Math.round(message.goldValue);
    }
    if (message.entityHandle !== undefined && message.entityHandle !== 16777215) {
      obj.entityHandle = Math.round(message.entityHandle);
    }
    if (message.timestamp !== undefined && message.timestamp !== 0) {
      obj.timestamp = Math.round(message.timestamp);
    }
    if (message.lostItems?.length) {
      obj.lostItems = message.lostItems.map((e) => CDOTAUserMsgCourierKilledAlert_LostItem.toJSON(e));
    }
    if (message.killerPlayerId !== undefined && message.killerPlayerId !== -1) {
      obj.killerPlayerId = Math.round(message.killerPlayerId);
    }
    if (message.owningPlayerId !== undefined && message.owningPlayerId !== -1) {
      obj.owningPlayerId = Math.round(message.owningPlayerId);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgCourierKilledAlert>): CDOTAUserMsgCourierKilledAlert {
    return CDOTAUserMsgCourierKilledAlert.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgCourierKilledAlert>): CDOTAUserMsgCourierKilledAlert {
    const message = createBaseCDOTAUserMsgCourierKilledAlert();
    message.team = object.team ?? 0;
    message.goldValue = object.goldValue ?? 0;
    message.entityHandle = object.entityHandle ?? 16777215;
    message.timestamp = object.timestamp ?? 0;
    message.lostItems = object.lostItems?.map((e) => CDOTAUserMsgCourierKilledAlert_LostItem.fromPartial(e)) || [];
    message.killerPlayerId = object.killerPlayerId ?? -1;
    message.owningPlayerId = object.owningPlayerId ?? -1;
    return message;
  },
};

function createBaseCDOTAUserMsgCourierKilledAlert_LostItem(): CDOTAUserMsgCourierKilledAlert_LostItem {
  return { itemAbilityId: -1, quantity: 0 };
}

export const CDOTAUserMsgCourierKilledAlert_LostItem = {
  encode(message: CDOTAUserMsgCourierKilledAlert_LostItem, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.itemAbilityId !== undefined && message.itemAbilityId !== -1) {
      writer.uint32(8).int32(message.itemAbilityId);
    }
    if (message.quantity !== undefined && message.quantity !== 0) {
      writer.uint32(16).uint32(message.quantity);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgCourierKilledAlert_LostItem {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgCourierKilledAlert_LostItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.itemAbilityId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.quantity = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgCourierKilledAlert_LostItem {
    return {
      itemAbilityId: isSet(object.itemAbilityId) ? globalThis.Number(object.itemAbilityId) : -1,
      quantity: isSet(object.quantity) ? globalThis.Number(object.quantity) : 0,
    };
  },

  toJSON(message: CDOTAUserMsgCourierKilledAlert_LostItem): unknown {
    const obj: any = {};
    if (message.itemAbilityId !== undefined && message.itemAbilityId !== -1) {
      obj.itemAbilityId = Math.round(message.itemAbilityId);
    }
    if (message.quantity !== undefined && message.quantity !== 0) {
      obj.quantity = Math.round(message.quantity);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgCourierKilledAlert_LostItem>): CDOTAUserMsgCourierKilledAlert_LostItem {
    return CDOTAUserMsgCourierKilledAlert_LostItem.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgCourierKilledAlert_LostItem>): CDOTAUserMsgCourierKilledAlert_LostItem {
    const message = createBaseCDOTAUserMsgCourierKilledAlert_LostItem();
    message.itemAbilityId = object.itemAbilityId ?? -1;
    message.quantity = object.quantity ?? 0;
    return message;
  },
};

function createBaseCDOTAUserMsgMinimapEvent(): CDOTAUserMsgMinimapEvent {
  return { eventType: 0, entityHandle: 16777215, x: 0, y: 0, duration: 0, targetEntityHandle: 16777215 };
}

export const CDOTAUserMsgMinimapEvent = {
  encode(message: CDOTAUserMsgMinimapEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.eventType !== undefined && message.eventType !== 0) {
      writer.uint32(8).int32(message.eventType);
    }
    if (message.entityHandle !== undefined && message.entityHandle !== 16777215) {
      writer.uint32(16).uint32(message.entityHandle);
    }
    if (message.x !== undefined && message.x !== 0) {
      writer.uint32(24).int32(message.x);
    }
    if (message.y !== undefined && message.y !== 0) {
      writer.uint32(32).int32(message.y);
    }
    if (message.duration !== undefined && message.duration !== 0) {
      writer.uint32(40).int32(message.duration);
    }
    if (message.targetEntityHandle !== undefined && message.targetEntityHandle !== 16777215) {
      writer.uint32(48).uint32(message.targetEntityHandle);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgMinimapEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgMinimapEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.eventType = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.entityHandle = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.x = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.y = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.duration = reader.int32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.targetEntityHandle = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgMinimapEvent {
    return {
      eventType: isSet(object.eventType) ? globalThis.Number(object.eventType) : 0,
      entityHandle: isSet(object.entityHandle) ? globalThis.Number(object.entityHandle) : 16777215,
      x: isSet(object.x) ? globalThis.Number(object.x) : 0,
      y: isSet(object.y) ? globalThis.Number(object.y) : 0,
      duration: isSet(object.duration) ? globalThis.Number(object.duration) : 0,
      targetEntityHandle: isSet(object.targetEntityHandle) ? globalThis.Number(object.targetEntityHandle) : 16777215,
    };
  },

  toJSON(message: CDOTAUserMsgMinimapEvent): unknown {
    const obj: any = {};
    if (message.eventType !== undefined && message.eventType !== 0) {
      obj.eventType = Math.round(message.eventType);
    }
    if (message.entityHandle !== undefined && message.entityHandle !== 16777215) {
      obj.entityHandle = Math.round(message.entityHandle);
    }
    if (message.x !== undefined && message.x !== 0) {
      obj.x = Math.round(message.x);
    }
    if (message.y !== undefined && message.y !== 0) {
      obj.y = Math.round(message.y);
    }
    if (message.duration !== undefined && message.duration !== 0) {
      obj.duration = Math.round(message.duration);
    }
    if (message.targetEntityHandle !== undefined && message.targetEntityHandle !== 16777215) {
      obj.targetEntityHandle = Math.round(message.targetEntityHandle);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgMinimapEvent>): CDOTAUserMsgMinimapEvent {
    return CDOTAUserMsgMinimapEvent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgMinimapEvent>): CDOTAUserMsgMinimapEvent {
    const message = createBaseCDOTAUserMsgMinimapEvent();
    message.eventType = object.eventType ?? 0;
    message.entityHandle = object.entityHandle ?? 16777215;
    message.x = object.x ?? 0;
    message.y = object.y ?? 0;
    message.duration = object.duration ?? 0;
    message.targetEntityHandle = object.targetEntityHandle ?? 16777215;
    return message;
  },
};

function createBaseCDOTAUserMsgMapLine(): CDOTAUserMsgMapLine {
  return { playerId: -1, mapline: undefined };
}

export const CDOTAUserMsgMapLine = {
  encode(message: CDOTAUserMsgMapLine, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.playerId !== undefined && message.playerId !== -1) {
      writer.uint32(8).int32(message.playerId);
    }
    if (message.mapline !== undefined) {
      CDOTAMsgMapLine.encode(message.mapline, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgMapLine {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgMapLine();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.playerId = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.mapline = CDOTAMsgMapLine.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgMapLine {
    return {
      playerId: isSet(object.playerId) ? globalThis.Number(object.playerId) : -1,
      mapline: isSet(object.mapline) ? CDOTAMsgMapLine.fromJSON(object.mapline) : undefined,
    };
  },

  toJSON(message: CDOTAUserMsgMapLine): unknown {
    const obj: any = {};
    if (message.playerId !== undefined && message.playerId !== -1) {
      obj.playerId = Math.round(message.playerId);
    }
    if (message.mapline !== undefined) {
      obj.mapline = CDOTAMsgMapLine.toJSON(message.mapline);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgMapLine>): CDOTAUserMsgMapLine {
    return CDOTAUserMsgMapLine.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgMapLine>): CDOTAUserMsgMapLine {
    const message = createBaseCDOTAUserMsgMapLine();
    message.playerId = object.playerId ?? -1;
    message.mapline =
      object.mapline !== undefined && object.mapline !== null ? CDOTAMsgMapLine.fromPartial(object.mapline) : undefined;
    return message;
  },
};

function createBaseCDOTAUserMsgMinimapDebugPoint(): CDOTAUserMsgMinimapDebugPoint {
  return { location: undefined, color: 0, size: 0, duration: 0, index: 0 };
}

export const CDOTAUserMsgMinimapDebugPoint = {
  encode(message: CDOTAUserMsgMinimapDebugPoint, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.location !== undefined) {
      CMsgVector.encode(message.location, writer.uint32(10).fork()).ldelim();
    }
    if (message.color !== undefined && message.color !== 0) {
      writer.uint32(16).uint32(message.color);
    }
    if (message.size !== undefined && message.size !== 0) {
      writer.uint32(24).int32(message.size);
    }
    if (message.duration !== undefined && message.duration !== 0) {
      writer.uint32(37).float(message.duration);
    }
    if (message.index !== undefined && message.index !== 0) {
      writer.uint32(40).int32(message.index);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgMinimapDebugPoint {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgMinimapDebugPoint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.location = CMsgVector.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.color = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.size = reader.int32();
          continue;
        case 4:
          if (tag !== 37) {
            break;
          }

          message.duration = reader.float();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.index = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgMinimapDebugPoint {
    return {
      location: isSet(object.location) ? CMsgVector.fromJSON(object.location) : undefined,
      color: isSet(object.color) ? globalThis.Number(object.color) : 0,
      size: isSet(object.size) ? globalThis.Number(object.size) : 0,
      duration: isSet(object.duration) ? globalThis.Number(object.duration) : 0,
      index: isSet(object.index) ? globalThis.Number(object.index) : 0,
    };
  },

  toJSON(message: CDOTAUserMsgMinimapDebugPoint): unknown {
    const obj: any = {};
    if (message.location !== undefined) {
      obj.location = CMsgVector.toJSON(message.location);
    }
    if (message.color !== undefined && message.color !== 0) {
      obj.color = Math.round(message.color);
    }
    if (message.size !== undefined && message.size !== 0) {
      obj.size = Math.round(message.size);
    }
    if (message.duration !== undefined && message.duration !== 0) {
      obj.duration = message.duration;
    }
    if (message.index !== undefined && message.index !== 0) {
      obj.index = Math.round(message.index);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgMinimapDebugPoint>): CDOTAUserMsgMinimapDebugPoint {
    return CDOTAUserMsgMinimapDebugPoint.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgMinimapDebugPoint>): CDOTAUserMsgMinimapDebugPoint {
    const message = createBaseCDOTAUserMsgMinimapDebugPoint();
    message.location =
      object.location !== undefined && object.location !== null ? CMsgVector.fromPartial(object.location) : undefined;
    message.color = object.color ?? 0;
    message.size = object.size ?? 0;
    message.duration = object.duration ?? 0;
    message.index = object.index ?? 0;
    return message;
  },
};

function createBaseCDOTAUserMsgCreateLinearProjectile(): CDOTAUserMsgCreateLinearProjectile {
  return {
    origin: undefined,
    velocity: undefined,
    entindex: -1,
    particleIndex: "0",
    handle: 0,
    acceleration: undefined,
    maxSpeed: 0,
    fowRadius: 0,
    stickyFowReveal: false,
    distance: 0,
    colorgemcolor: 0,
    particleCpData: [],
  };
}

export const CDOTAUserMsgCreateLinearProjectile = {
  encode(message: CDOTAUserMsgCreateLinearProjectile, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.origin !== undefined) {
      CMsgVector.encode(message.origin, writer.uint32(10).fork()).ldelim();
    }
    if (message.velocity !== undefined) {
      CMsgVector2D.encode(message.velocity, writer.uint32(18).fork()).ldelim();
    }
    if (message.entindex !== undefined && message.entindex !== -1) {
      writer.uint32(32).int32(message.entindex);
    }
    if (message.particleIndex !== undefined && message.particleIndex !== "0") {
      writer.uint32(40).uint64(message.particleIndex);
    }
    if (message.handle !== undefined && message.handle !== 0) {
      writer.uint32(48).int32(message.handle);
    }
    if (message.acceleration !== undefined) {
      CMsgVector2D.encode(message.acceleration, writer.uint32(58).fork()).ldelim();
    }
    if (message.maxSpeed !== undefined && message.maxSpeed !== 0) {
      writer.uint32(69).float(message.maxSpeed);
    }
    if (message.fowRadius !== undefined && message.fowRadius !== 0) {
      writer.uint32(77).float(message.fowRadius);
    }
    if (message.stickyFowReveal !== undefined && message.stickyFowReveal !== false) {
      writer.uint32(80).bool(message.stickyFowReveal);
    }
    if (message.distance !== undefined && message.distance !== 0) {
      writer.uint32(93).float(message.distance);
    }
    if (message.colorgemcolor !== undefined && message.colorgemcolor !== 0) {
      writer.uint32(101).fixed32(message.colorgemcolor);
    }
    for (const v of message.particleCpData) {
      CDOTAUserMsgProjectileParticleCPData.encode(v!, writer.uint32(106).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgCreateLinearProjectile {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgCreateLinearProjectile();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.origin = CMsgVector.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.velocity = CMsgVector2D.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.entindex = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.particleIndex = longToString(reader.uint64() as Long);
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.handle = reader.int32();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.acceleration = CMsgVector2D.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 69) {
            break;
          }

          message.maxSpeed = reader.float();
          continue;
        case 9:
          if (tag !== 77) {
            break;
          }

          message.fowRadius = reader.float();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.stickyFowReveal = reader.bool();
          continue;
        case 11:
          if (tag !== 93) {
            break;
          }

          message.distance = reader.float();
          continue;
        case 12:
          if (tag !== 101) {
            break;
          }

          message.colorgemcolor = reader.fixed32();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.particleCpData.push(CDOTAUserMsgProjectileParticleCPData.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgCreateLinearProjectile {
    return {
      origin: isSet(object.origin) ? CMsgVector.fromJSON(object.origin) : undefined,
      velocity: isSet(object.velocity) ? CMsgVector2D.fromJSON(object.velocity) : undefined,
      entindex: isSet(object.entindex) ? globalThis.Number(object.entindex) : -1,
      particleIndex: isSet(object.particleIndex) ? globalThis.String(object.particleIndex) : "0",
      handle: isSet(object.handle) ? globalThis.Number(object.handle) : 0,
      acceleration: isSet(object.acceleration) ? CMsgVector2D.fromJSON(object.acceleration) : undefined,
      maxSpeed: isSet(object.maxSpeed) ? globalThis.Number(object.maxSpeed) : 0,
      fowRadius: isSet(object.fowRadius) ? globalThis.Number(object.fowRadius) : 0,
      stickyFowReveal: isSet(object.stickyFowReveal) ? globalThis.Boolean(object.stickyFowReveal) : false,
      distance: isSet(object.distance) ? globalThis.Number(object.distance) : 0,
      colorgemcolor: isSet(object.colorgemcolor) ? globalThis.Number(object.colorgemcolor) : 0,
      particleCpData: globalThis.Array.isArray(object?.particleCpData)
        ? object.particleCpData.map((e: any) => CDOTAUserMsgProjectileParticleCPData.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CDOTAUserMsgCreateLinearProjectile): unknown {
    const obj: any = {};
    if (message.origin !== undefined) {
      obj.origin = CMsgVector.toJSON(message.origin);
    }
    if (message.velocity !== undefined) {
      obj.velocity = CMsgVector2D.toJSON(message.velocity);
    }
    if (message.entindex !== undefined && message.entindex !== -1) {
      obj.entindex = Math.round(message.entindex);
    }
    if (message.particleIndex !== undefined && message.particleIndex !== "0") {
      obj.particleIndex = message.particleIndex;
    }
    if (message.handle !== undefined && message.handle !== 0) {
      obj.handle = Math.round(message.handle);
    }
    if (message.acceleration !== undefined) {
      obj.acceleration = CMsgVector2D.toJSON(message.acceleration);
    }
    if (message.maxSpeed !== undefined && message.maxSpeed !== 0) {
      obj.maxSpeed = message.maxSpeed;
    }
    if (message.fowRadius !== undefined && message.fowRadius !== 0) {
      obj.fowRadius = message.fowRadius;
    }
    if (message.stickyFowReveal !== undefined && message.stickyFowReveal !== false) {
      obj.stickyFowReveal = message.stickyFowReveal;
    }
    if (message.distance !== undefined && message.distance !== 0) {
      obj.distance = message.distance;
    }
    if (message.colorgemcolor !== undefined && message.colorgemcolor !== 0) {
      obj.colorgemcolor = Math.round(message.colorgemcolor);
    }
    if (message.particleCpData?.length) {
      obj.particleCpData = message.particleCpData.map((e) => CDOTAUserMsgProjectileParticleCPData.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgCreateLinearProjectile>): CDOTAUserMsgCreateLinearProjectile {
    return CDOTAUserMsgCreateLinearProjectile.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgCreateLinearProjectile>): CDOTAUserMsgCreateLinearProjectile {
    const message = createBaseCDOTAUserMsgCreateLinearProjectile();
    message.origin =
      object.origin !== undefined && object.origin !== null ? CMsgVector.fromPartial(object.origin) : undefined;
    message.velocity =
      object.velocity !== undefined && object.velocity !== null ? CMsgVector2D.fromPartial(object.velocity) : undefined;
    message.entindex = object.entindex ?? -1;
    message.particleIndex = object.particleIndex ?? "0";
    message.handle = object.handle ?? 0;
    message.acceleration =
      object.acceleration !== undefined && object.acceleration !== null
        ? CMsgVector2D.fromPartial(object.acceleration)
        : undefined;
    message.maxSpeed = object.maxSpeed ?? 0;
    message.fowRadius = object.fowRadius ?? 0;
    message.stickyFowReveal = object.stickyFowReveal ?? false;
    message.distance = object.distance ?? 0;
    message.colorgemcolor = object.colorgemcolor ?? 0;
    message.particleCpData =
      object.particleCpData?.map((e) => CDOTAUserMsgProjectileParticleCPData.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCDOTAUserMsgDestroyLinearProjectile(): CDOTAUserMsgDestroyLinearProjectile {
  return { handle: 0 };
}

export const CDOTAUserMsgDestroyLinearProjectile = {
  encode(message: CDOTAUserMsgDestroyLinearProjectile, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.handle !== undefined && message.handle !== 0) {
      writer.uint32(8).int32(message.handle);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgDestroyLinearProjectile {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgDestroyLinearProjectile();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.handle = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgDestroyLinearProjectile {
    return { handle: isSet(object.handle) ? globalThis.Number(object.handle) : 0 };
  },

  toJSON(message: CDOTAUserMsgDestroyLinearProjectile): unknown {
    const obj: any = {};
    if (message.handle !== undefined && message.handle !== 0) {
      obj.handle = Math.round(message.handle);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgDestroyLinearProjectile>): CDOTAUserMsgDestroyLinearProjectile {
    return CDOTAUserMsgDestroyLinearProjectile.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgDestroyLinearProjectile>): CDOTAUserMsgDestroyLinearProjectile {
    const message = createBaseCDOTAUserMsgDestroyLinearProjectile();
    message.handle = object.handle ?? 0;
    return message;
  },
};

function createBaseCDOTAUserMsgDodgeTrackingProjectiles(): CDOTAUserMsgDodgeTrackingProjectiles {
  return { entindex: -1, attacksOnly: false };
}

export const CDOTAUserMsgDodgeTrackingProjectiles = {
  encode(message: CDOTAUserMsgDodgeTrackingProjectiles, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.entindex !== -1) {
      writer.uint32(8).int32(message.entindex);
    }
    if (message.attacksOnly !== undefined && message.attacksOnly !== false) {
      writer.uint32(16).bool(message.attacksOnly);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgDodgeTrackingProjectiles {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgDodgeTrackingProjectiles();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.entindex = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.attacksOnly = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgDodgeTrackingProjectiles {
    return {
      entindex: isSet(object.entindex) ? globalThis.Number(object.entindex) : -1,
      attacksOnly: isSet(object.attacksOnly) ? globalThis.Boolean(object.attacksOnly) : false,
    };
  },

  toJSON(message: CDOTAUserMsgDodgeTrackingProjectiles): unknown {
    const obj: any = {};
    if (message.entindex !== -1) {
      obj.entindex = Math.round(message.entindex);
    }
    if (message.attacksOnly !== undefined && message.attacksOnly !== false) {
      obj.attacksOnly = message.attacksOnly;
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgDodgeTrackingProjectiles>): CDOTAUserMsgDodgeTrackingProjectiles {
    return CDOTAUserMsgDodgeTrackingProjectiles.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgDodgeTrackingProjectiles>): CDOTAUserMsgDodgeTrackingProjectiles {
    const message = createBaseCDOTAUserMsgDodgeTrackingProjectiles();
    message.entindex = object.entindex ?? -1;
    message.attacksOnly = object.attacksOnly ?? false;
    return message;
  },
};

function createBaseCDOTAUserMsgSpectatorPlayerClick(): CDOTAUserMsgSpectatorPlayerClick {
  return { entindex: -1, orderType: 0, targetIndex: 0 };
}

export const CDOTAUserMsgSpectatorPlayerClick = {
  encode(message: CDOTAUserMsgSpectatorPlayerClick, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.entindex !== -1) {
      writer.uint32(8).int32(message.entindex);
    }
    if (message.orderType !== undefined && message.orderType !== 0) {
      writer.uint32(16).int32(message.orderType);
    }
    if (message.targetIndex !== undefined && message.targetIndex !== 0) {
      writer.uint32(24).int32(message.targetIndex);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgSpectatorPlayerClick {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgSpectatorPlayerClick();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.entindex = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.orderType = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.targetIndex = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgSpectatorPlayerClick {
    return {
      entindex: isSet(object.entindex) ? globalThis.Number(object.entindex) : -1,
      orderType: isSet(object.orderType) ? globalThis.Number(object.orderType) : 0,
      targetIndex: isSet(object.targetIndex) ? globalThis.Number(object.targetIndex) : 0,
    };
  },

  toJSON(message: CDOTAUserMsgSpectatorPlayerClick): unknown {
    const obj: any = {};
    if (message.entindex !== -1) {
      obj.entindex = Math.round(message.entindex);
    }
    if (message.orderType !== undefined && message.orderType !== 0) {
      obj.orderType = Math.round(message.orderType);
    }
    if (message.targetIndex !== undefined && message.targetIndex !== 0) {
      obj.targetIndex = Math.round(message.targetIndex);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgSpectatorPlayerClick>): CDOTAUserMsgSpectatorPlayerClick {
    return CDOTAUserMsgSpectatorPlayerClick.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgSpectatorPlayerClick>): CDOTAUserMsgSpectatorPlayerClick {
    const message = createBaseCDOTAUserMsgSpectatorPlayerClick();
    message.entindex = object.entindex ?? -1;
    message.orderType = object.orderType ?? 0;
    message.targetIndex = object.targetIndex ?? 0;
    return message;
  },
};

function createBaseCDOTAUserMsgSpectatorPlayerUnitOrders(): CDOTAUserMsgSpectatorPlayerUnitOrders {
  return {
    entindex: -1,
    orderType: 0,
    units: [],
    targetIndex: 0,
    abilityId: -1,
    position: undefined,
    queue: false,
    sequenceNumber: 0,
    flags: 0,
  };
}

export const CDOTAUserMsgSpectatorPlayerUnitOrders = {
  encode(message: CDOTAUserMsgSpectatorPlayerUnitOrders, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.entindex !== undefined && message.entindex !== -1) {
      writer.uint32(8).int32(message.entindex);
    }
    if (message.orderType !== undefined && message.orderType !== 0) {
      writer.uint32(16).int32(message.orderType);
    }
    writer.uint32(26).fork();
    for (const v of message.units) {
      writer.int32(v);
    }
    writer.ldelim();
    if (message.targetIndex !== undefined && message.targetIndex !== 0) {
      writer.uint32(32).int32(message.targetIndex);
    }
    if (message.abilityId !== undefined && message.abilityId !== -1) {
      writer.uint32(40).int32(message.abilityId);
    }
    if (message.position !== undefined) {
      CMsgVector.encode(message.position, writer.uint32(50).fork()).ldelim();
    }
    if (message.queue !== undefined && message.queue !== false) {
      writer.uint32(56).bool(message.queue);
    }
    if (message.sequenceNumber !== undefined && message.sequenceNumber !== 0) {
      writer.uint32(64).int32(message.sequenceNumber);
    }
    if (message.flags !== undefined && message.flags !== 0) {
      writer.uint32(72).uint32(message.flags);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgSpectatorPlayerUnitOrders {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgSpectatorPlayerUnitOrders();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.entindex = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.orderType = reader.int32();
          continue;
        case 3:
          if (tag === 24) {
            message.units.push(reader.int32());

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.units.push(reader.int32());
            }

            continue;
          }

          break;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.targetIndex = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.abilityId = reader.int32();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.position = CMsgVector.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.queue = reader.bool();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.sequenceNumber = reader.int32();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.flags = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgSpectatorPlayerUnitOrders {
    return {
      entindex: isSet(object.entindex) ? globalThis.Number(object.entindex) : -1,
      orderType: isSet(object.orderType) ? globalThis.Number(object.orderType) : 0,
      units: globalThis.Array.isArray(object?.units) ? object.units.map((e: any) => globalThis.Number(e)) : [],
      targetIndex: isSet(object.targetIndex) ? globalThis.Number(object.targetIndex) : 0,
      abilityId: isSet(object.abilityId) ? globalThis.Number(object.abilityId) : -1,
      position: isSet(object.position) ? CMsgVector.fromJSON(object.position) : undefined,
      queue: isSet(object.queue) ? globalThis.Boolean(object.queue) : false,
      sequenceNumber: isSet(object.sequenceNumber) ? globalThis.Number(object.sequenceNumber) : 0,
      flags: isSet(object.flags) ? globalThis.Number(object.flags) : 0,
    };
  },

  toJSON(message: CDOTAUserMsgSpectatorPlayerUnitOrders): unknown {
    const obj: any = {};
    if (message.entindex !== undefined && message.entindex !== -1) {
      obj.entindex = Math.round(message.entindex);
    }
    if (message.orderType !== undefined && message.orderType !== 0) {
      obj.orderType = Math.round(message.orderType);
    }
    if (message.units?.length) {
      obj.units = message.units.map((e) => Math.round(e));
    }
    if (message.targetIndex !== undefined && message.targetIndex !== 0) {
      obj.targetIndex = Math.round(message.targetIndex);
    }
    if (message.abilityId !== undefined && message.abilityId !== -1) {
      obj.abilityId = Math.round(message.abilityId);
    }
    if (message.position !== undefined) {
      obj.position = CMsgVector.toJSON(message.position);
    }
    if (message.queue !== undefined && message.queue !== false) {
      obj.queue = message.queue;
    }
    if (message.sequenceNumber !== undefined && message.sequenceNumber !== 0) {
      obj.sequenceNumber = Math.round(message.sequenceNumber);
    }
    if (message.flags !== undefined && message.flags !== 0) {
      obj.flags = Math.round(message.flags);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgSpectatorPlayerUnitOrders>): CDOTAUserMsgSpectatorPlayerUnitOrders {
    return CDOTAUserMsgSpectatorPlayerUnitOrders.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgSpectatorPlayerUnitOrders>): CDOTAUserMsgSpectatorPlayerUnitOrders {
    const message = createBaseCDOTAUserMsgSpectatorPlayerUnitOrders();
    message.entindex = object.entindex ?? -1;
    message.orderType = object.orderType ?? 0;
    message.units = object.units?.map((e) => e) || [];
    message.targetIndex = object.targetIndex ?? 0;
    message.abilityId = object.abilityId ?? -1;
    message.position =
      object.position !== undefined && object.position !== null ? CMsgVector.fromPartial(object.position) : undefined;
    message.queue = object.queue ?? false;
    message.sequenceNumber = object.sequenceNumber ?? 0;
    message.flags = object.flags ?? 0;
    return message;
  },
};

function createBaseCDOTAUserMsgNevermoreRequiem(): CDOTAUserMsgNevermoreRequiem {
  return { entityHandle: 16777215, lines: 0, origin: undefined, reverse: false };
}

export const CDOTAUserMsgNevermoreRequiem = {
  encode(message: CDOTAUserMsgNevermoreRequiem, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.entityHandle !== undefined && message.entityHandle !== 16777215) {
      writer.uint32(8).uint32(message.entityHandle);
    }
    if (message.lines !== undefined && message.lines !== 0) {
      writer.uint32(16).int32(message.lines);
    }
    if (message.origin !== undefined) {
      CMsgVector.encode(message.origin, writer.uint32(26).fork()).ldelim();
    }
    if (message.reverse !== undefined && message.reverse !== false) {
      writer.uint32(32).bool(message.reverse);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgNevermoreRequiem {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgNevermoreRequiem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.entityHandle = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.lines = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.origin = CMsgVector.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.reverse = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgNevermoreRequiem {
    return {
      entityHandle: isSet(object.entityHandle) ? globalThis.Number(object.entityHandle) : 16777215,
      lines: isSet(object.lines) ? globalThis.Number(object.lines) : 0,
      origin: isSet(object.origin) ? CMsgVector.fromJSON(object.origin) : undefined,
      reverse: isSet(object.reverse) ? globalThis.Boolean(object.reverse) : false,
    };
  },

  toJSON(message: CDOTAUserMsgNevermoreRequiem): unknown {
    const obj: any = {};
    if (message.entityHandle !== undefined && message.entityHandle !== 16777215) {
      obj.entityHandle = Math.round(message.entityHandle);
    }
    if (message.lines !== undefined && message.lines !== 0) {
      obj.lines = Math.round(message.lines);
    }
    if (message.origin !== undefined) {
      obj.origin = CMsgVector.toJSON(message.origin);
    }
    if (message.reverse !== undefined && message.reverse !== false) {
      obj.reverse = message.reverse;
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgNevermoreRequiem>): CDOTAUserMsgNevermoreRequiem {
    return CDOTAUserMsgNevermoreRequiem.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgNevermoreRequiem>): CDOTAUserMsgNevermoreRequiem {
    const message = createBaseCDOTAUserMsgNevermoreRequiem();
    message.entityHandle = object.entityHandle ?? 16777215;
    message.lines = object.lines ?? 0;
    message.origin =
      object.origin !== undefined && object.origin !== null ? CMsgVector.fromPartial(object.origin) : undefined;
    message.reverse = object.reverse ?? false;
    return message;
  },
};

function createBaseCDOTAUserMsgInvalidCommand(): CDOTAUserMsgInvalidCommand {
  return { message: "", sequenceNumber: 0 };
}

export const CDOTAUserMsgInvalidCommand = {
  encode(message: CDOTAUserMsgInvalidCommand, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.message !== undefined && message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    if (message.sequenceNumber !== undefined && message.sequenceNumber !== 0) {
      writer.uint32(16).int32(message.sequenceNumber);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgInvalidCommand {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgInvalidCommand();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.sequenceNumber = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgInvalidCommand {
    return {
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      sequenceNumber: isSet(object.sequenceNumber) ? globalThis.Number(object.sequenceNumber) : 0,
    };
  },

  toJSON(message: CDOTAUserMsgInvalidCommand): unknown {
    const obj: any = {};
    if (message.message !== undefined && message.message !== "") {
      obj.message = message.message;
    }
    if (message.sequenceNumber !== undefined && message.sequenceNumber !== 0) {
      obj.sequenceNumber = Math.round(message.sequenceNumber);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgInvalidCommand>): CDOTAUserMsgInvalidCommand {
    return CDOTAUserMsgInvalidCommand.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgInvalidCommand>): CDOTAUserMsgInvalidCommand {
    const message = createBaseCDOTAUserMsgInvalidCommand();
    message.message = object.message ?? "";
    message.sequenceNumber = object.sequenceNumber ?? 0;
    return message;
  },
};

function createBaseCDOTAUserMsgHudError(): CDOTAUserMsgHudError {
  return { orderId: 0, sequenceNumber: 0 };
}

export const CDOTAUserMsgHudError = {
  encode(message: CDOTAUserMsgHudError, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.orderId !== undefined && message.orderId !== 0) {
      writer.uint32(8).int32(message.orderId);
    }
    if (message.sequenceNumber !== undefined && message.sequenceNumber !== 0) {
      writer.uint32(16).int32(message.sequenceNumber);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgHudError {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgHudError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.orderId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.sequenceNumber = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgHudError {
    return {
      orderId: isSet(object.orderId) ? globalThis.Number(object.orderId) : 0,
      sequenceNumber: isSet(object.sequenceNumber) ? globalThis.Number(object.sequenceNumber) : 0,
    };
  },

  toJSON(message: CDOTAUserMsgHudError): unknown {
    const obj: any = {};
    if (message.orderId !== undefined && message.orderId !== 0) {
      obj.orderId = Math.round(message.orderId);
    }
    if (message.sequenceNumber !== undefined && message.sequenceNumber !== 0) {
      obj.sequenceNumber = Math.round(message.sequenceNumber);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgHudError>): CDOTAUserMsgHudError {
    return CDOTAUserMsgHudError.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgHudError>): CDOTAUserMsgHudError {
    const message = createBaseCDOTAUserMsgHudError();
    message.orderId = object.orderId ?? 0;
    message.sequenceNumber = object.sequenceNumber ?? 0;
    return message;
  },
};

function createBaseCDOTAUserMsgSharedCooldown(): CDOTAUserMsgSharedCooldown {
  return { entindex: -1, name: "", cooldown: 0, nameIndex: 0 };
}

export const CDOTAUserMsgSharedCooldown = {
  encode(message: CDOTAUserMsgSharedCooldown, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.entindex !== undefined && message.entindex !== -1) {
      writer.uint32(8).int32(message.entindex);
    }
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.cooldown !== undefined && message.cooldown !== 0) {
      writer.uint32(29).float(message.cooldown);
    }
    if (message.nameIndex !== undefined && message.nameIndex !== 0) {
      writer.uint32(32).int32(message.nameIndex);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgSharedCooldown {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgSharedCooldown();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.entindex = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.cooldown = reader.float();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.nameIndex = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgSharedCooldown {
    return {
      entindex: isSet(object.entindex) ? globalThis.Number(object.entindex) : -1,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      cooldown: isSet(object.cooldown) ? globalThis.Number(object.cooldown) : 0,
      nameIndex: isSet(object.nameIndex) ? globalThis.Number(object.nameIndex) : 0,
    };
  },

  toJSON(message: CDOTAUserMsgSharedCooldown): unknown {
    const obj: any = {};
    if (message.entindex !== undefined && message.entindex !== -1) {
      obj.entindex = Math.round(message.entindex);
    }
    if (message.name !== undefined && message.name !== "") {
      obj.name = message.name;
    }
    if (message.cooldown !== undefined && message.cooldown !== 0) {
      obj.cooldown = message.cooldown;
    }
    if (message.nameIndex !== undefined && message.nameIndex !== 0) {
      obj.nameIndex = Math.round(message.nameIndex);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgSharedCooldown>): CDOTAUserMsgSharedCooldown {
    return CDOTAUserMsgSharedCooldown.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgSharedCooldown>): CDOTAUserMsgSharedCooldown {
    const message = createBaseCDOTAUserMsgSharedCooldown();
    message.entindex = object.entindex ?? -1;
    message.name = object.name ?? "";
    message.cooldown = object.cooldown ?? 0;
    message.nameIndex = object.nameIndex ?? 0;
    return message;
  },
};

function createBaseCDOTAUserMsgSetNextAutobuyItem(): CDOTAUserMsgSetNextAutobuyItem {
  return { name: "" };
}

export const CDOTAUserMsgSetNextAutobuyItem = {
  encode(message: CDOTAUserMsgSetNextAutobuyItem, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgSetNextAutobuyItem {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgSetNextAutobuyItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgSetNextAutobuyItem {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: CDOTAUserMsgSetNextAutobuyItem): unknown {
    const obj: any = {};
    if (message.name !== undefined && message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgSetNextAutobuyItem>): CDOTAUserMsgSetNextAutobuyItem {
    return CDOTAUserMsgSetNextAutobuyItem.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgSetNextAutobuyItem>): CDOTAUserMsgSetNextAutobuyItem {
    const message = createBaseCDOTAUserMsgSetNextAutobuyItem();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseCDOTAUserMsgHalloweenDrops(): CDOTAUserMsgHalloweenDrops {
  return { itemDefs: [], playerIds: [], prizeList: 0 };
}

export const CDOTAUserMsgHalloweenDrops = {
  encode(message: CDOTAUserMsgHalloweenDrops, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.itemDefs) {
      writer.uint32(v);
    }
    writer.ldelim();
    writer.uint32(18).fork();
    for (const v of message.playerIds) {
      writer.int32(v);
    }
    writer.ldelim();
    if (message.prizeList !== undefined && message.prizeList !== 0) {
      writer.uint32(24).uint32(message.prizeList);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgHalloweenDrops {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgHalloweenDrops();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.itemDefs.push(reader.uint32());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.itemDefs.push(reader.uint32());
            }

            continue;
          }

          break;
        case 2:
          if (tag === 16) {
            message.playerIds.push(reader.int32());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.playerIds.push(reader.int32());
            }

            continue;
          }

          break;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.prizeList = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgHalloweenDrops {
    return {
      itemDefs: globalThis.Array.isArray(object?.itemDefs) ? object.itemDefs.map((e: any) => globalThis.Number(e)) : [],
      playerIds: globalThis.Array.isArray(object?.playerIds)
        ? object.playerIds.map((e: any) => globalThis.Number(e))
        : [],
      prizeList: isSet(object.prizeList) ? globalThis.Number(object.prizeList) : 0,
    };
  },

  toJSON(message: CDOTAUserMsgHalloweenDrops): unknown {
    const obj: any = {};
    if (message.itemDefs?.length) {
      obj.itemDefs = message.itemDefs.map((e) => Math.round(e));
    }
    if (message.playerIds?.length) {
      obj.playerIds = message.playerIds.map((e) => Math.round(e));
    }
    if (message.prizeList !== undefined && message.prizeList !== 0) {
      obj.prizeList = Math.round(message.prizeList);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgHalloweenDrops>): CDOTAUserMsgHalloweenDrops {
    return CDOTAUserMsgHalloweenDrops.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgHalloweenDrops>): CDOTAUserMsgHalloweenDrops {
    const message = createBaseCDOTAUserMsgHalloweenDrops();
    message.itemDefs = object.itemDefs?.map((e) => e) || [];
    message.playerIds = object.playerIds?.map((e) => e) || [];
    message.prizeList = object.prizeList ?? 0;
    return message;
  },
};

function createBaseCDOTAUserMsgPredictionResult(): CDOTAUserMsgPredictionResult {
  return { accountId: 0, matchId: "0", correct: false, predictions: [] };
}

export const CDOTAUserMsgPredictionResult = {
  encode(message: CDOTAUserMsgPredictionResult, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.accountId !== undefined && message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    if (message.matchId !== undefined && message.matchId !== "0") {
      writer.uint32(16).uint64(message.matchId);
    }
    if (message.correct !== undefined && message.correct !== false) {
      writer.uint32(24).bool(message.correct);
    }
    for (const v of message.predictions) {
      CDOTAUserMsgPredictionResult_Prediction.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgPredictionResult {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgPredictionResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.matchId = longToString(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.correct = reader.bool();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.predictions.push(CDOTAUserMsgPredictionResult_Prediction.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgPredictionResult {
    return {
      accountId: isSet(object.accountId) ? globalThis.Number(object.accountId) : 0,
      matchId: isSet(object.matchId) ? globalThis.String(object.matchId) : "0",
      correct: isSet(object.correct) ? globalThis.Boolean(object.correct) : false,
      predictions: globalThis.Array.isArray(object?.predictions)
        ? object.predictions.map((e: any) => CDOTAUserMsgPredictionResult_Prediction.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CDOTAUserMsgPredictionResult): unknown {
    const obj: any = {};
    if (message.accountId !== undefined && message.accountId !== 0) {
      obj.accountId = Math.round(message.accountId);
    }
    if (message.matchId !== undefined && message.matchId !== "0") {
      obj.matchId = message.matchId;
    }
    if (message.correct !== undefined && message.correct !== false) {
      obj.correct = message.correct;
    }
    if (message.predictions?.length) {
      obj.predictions = message.predictions.map((e) => CDOTAUserMsgPredictionResult_Prediction.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgPredictionResult>): CDOTAUserMsgPredictionResult {
    return CDOTAUserMsgPredictionResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgPredictionResult>): CDOTAUserMsgPredictionResult {
    const message = createBaseCDOTAUserMsgPredictionResult();
    message.accountId = object.accountId ?? 0;
    message.matchId = object.matchId ?? "0";
    message.correct = object.correct ?? false;
    message.predictions = object.predictions?.map((e) => CDOTAUserMsgPredictionResult_Prediction.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCDOTAUserMsgPredictionResult_Prediction(): CDOTAUserMsgPredictionResult_Prediction {
  return { itemDef: 0, numCorrect: 0, numFails: 0, result: 1, grantedItemDefs: [] };
}

export const CDOTAUserMsgPredictionResult_Prediction = {
  encode(message: CDOTAUserMsgPredictionResult_Prediction, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.itemDef !== undefined && message.itemDef !== 0) {
      writer.uint32(8).uint32(message.itemDef);
    }
    if (message.numCorrect !== undefined && message.numCorrect !== 0) {
      writer.uint32(16).uint32(message.numCorrect);
    }
    if (message.numFails !== undefined && message.numFails !== 0) {
      writer.uint32(24).uint32(message.numFails);
    }
    if (message.result !== undefined && message.result !== 1) {
      writer.uint32(32).int32(message.result);
    }
    writer.uint32(50).fork();
    for (const v of message.grantedItemDefs) {
      writer.uint32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgPredictionResult_Prediction {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgPredictionResult_Prediction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.itemDef = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.numCorrect = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.numFails = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.result = reader.int32() as any;
          continue;
        case 6:
          if (tag === 48) {
            message.grantedItemDefs.push(reader.uint32());

            continue;
          }

          if (tag === 50) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.grantedItemDefs.push(reader.uint32());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgPredictionResult_Prediction {
    return {
      itemDef: isSet(object.itemDef) ? globalThis.Number(object.itemDef) : 0,
      numCorrect: isSet(object.numCorrect) ? globalThis.Number(object.numCorrect) : 0,
      numFails: isSet(object.numFails) ? globalThis.Number(object.numFails) : 0,
      result: isSet(object.result) ? cDOTAUserMsgPredictionResult_Prediction_EResultFromJSON(object.result) : 1,
      grantedItemDefs: globalThis.Array.isArray(object?.grantedItemDefs)
        ? object.grantedItemDefs.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: CDOTAUserMsgPredictionResult_Prediction): unknown {
    const obj: any = {};
    if (message.itemDef !== undefined && message.itemDef !== 0) {
      obj.itemDef = Math.round(message.itemDef);
    }
    if (message.numCorrect !== undefined && message.numCorrect !== 0) {
      obj.numCorrect = Math.round(message.numCorrect);
    }
    if (message.numFails !== undefined && message.numFails !== 0) {
      obj.numFails = Math.round(message.numFails);
    }
    if (message.result !== undefined && message.result !== 1) {
      obj.result = cDOTAUserMsgPredictionResult_Prediction_EResultToJSON(message.result);
    }
    if (message.grantedItemDefs?.length) {
      obj.grantedItemDefs = message.grantedItemDefs.map((e) => Math.round(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgPredictionResult_Prediction>): CDOTAUserMsgPredictionResult_Prediction {
    return CDOTAUserMsgPredictionResult_Prediction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgPredictionResult_Prediction>): CDOTAUserMsgPredictionResult_Prediction {
    const message = createBaseCDOTAUserMsgPredictionResult_Prediction();
    message.itemDef = object.itemDef ?? 0;
    message.numCorrect = object.numCorrect ?? 0;
    message.numFails = object.numFails ?? 0;
    message.result = object.result ?? 1;
    message.grantedItemDefs = object.grantedItemDefs?.map((e) => e) || [];
    return message;
  },
};

function createBaseCDOTAResponseQuerySerialized(): CDOTAResponseQuerySerialized {
  return { facts: [] };
}

export const CDOTAResponseQuerySerialized = {
  encode(message: CDOTAResponseQuerySerialized, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.facts) {
      CDOTAResponseQuerySerialized_Fact.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAResponseQuerySerialized {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAResponseQuerySerialized();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.facts.push(CDOTAResponseQuerySerialized_Fact.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAResponseQuerySerialized {
    return {
      facts: globalThis.Array.isArray(object?.facts)
        ? object.facts.map((e: any) => CDOTAResponseQuerySerialized_Fact.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CDOTAResponseQuerySerialized): unknown {
    const obj: any = {};
    if (message.facts?.length) {
      obj.facts = message.facts.map((e) => CDOTAResponseQuerySerialized_Fact.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAResponseQuerySerialized>): CDOTAResponseQuerySerialized {
    return CDOTAResponseQuerySerialized.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAResponseQuerySerialized>): CDOTAResponseQuerySerialized {
    const message = createBaseCDOTAResponseQuerySerialized();
    message.facts = object.facts?.map((e) => CDOTAResponseQuerySerialized_Fact.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCDOTAResponseQuerySerialized_Fact(): CDOTAResponseQuerySerialized_Fact {
  return { key: 0, valtype: 1, valNumeric: 0, valString: "", valStringtableIndex: 0, valIntNumeric: 0 };
}

export const CDOTAResponseQuerySerialized_Fact = {
  encode(message: CDOTAResponseQuerySerialized_Fact, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== 0) {
      writer.uint32(8).int32(message.key);
    }
    if (message.valtype !== 1) {
      writer.uint32(16).int32(message.valtype);
    }
    if (message.valNumeric !== undefined && message.valNumeric !== 0) {
      writer.uint32(29).float(message.valNumeric);
    }
    if (message.valString !== undefined && message.valString !== "") {
      writer.uint32(34).string(message.valString);
    }
    if (message.valStringtableIndex !== undefined && message.valStringtableIndex !== 0) {
      writer.uint32(40).int32(message.valStringtableIndex);
    }
    if (message.valIntNumeric !== undefined && message.valIntNumeric !== 0) {
      writer.uint32(48).sint32(message.valIntNumeric);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAResponseQuerySerialized_Fact {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAResponseQuerySerialized_Fact();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.key = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.valtype = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.valNumeric = reader.float();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.valString = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.valStringtableIndex = reader.int32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.valIntNumeric = reader.sint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAResponseQuerySerialized_Fact {
    return {
      key: isSet(object.key) ? globalThis.Number(object.key) : 0,
      valtype: isSet(object.valtype) ? cDOTAResponseQuerySerialized_Fact_ValueTypeFromJSON(object.valtype) : 1,
      valNumeric: isSet(object.valNumeric) ? globalThis.Number(object.valNumeric) : 0,
      valString: isSet(object.valString) ? globalThis.String(object.valString) : "",
      valStringtableIndex: isSet(object.valStringtableIndex) ? globalThis.Number(object.valStringtableIndex) : 0,
      valIntNumeric: isSet(object.valIntNumeric) ? globalThis.Number(object.valIntNumeric) : 0,
    };
  },

  toJSON(message: CDOTAResponseQuerySerialized_Fact): unknown {
    const obj: any = {};
    if (message.key !== 0) {
      obj.key = Math.round(message.key);
    }
    if (message.valtype !== 1) {
      obj.valtype = cDOTAResponseQuerySerialized_Fact_ValueTypeToJSON(message.valtype);
    }
    if (message.valNumeric !== undefined && message.valNumeric !== 0) {
      obj.valNumeric = message.valNumeric;
    }
    if (message.valString !== undefined && message.valString !== "") {
      obj.valString = message.valString;
    }
    if (message.valStringtableIndex !== undefined && message.valStringtableIndex !== 0) {
      obj.valStringtableIndex = Math.round(message.valStringtableIndex);
    }
    if (message.valIntNumeric !== undefined && message.valIntNumeric !== 0) {
      obj.valIntNumeric = Math.round(message.valIntNumeric);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAResponseQuerySerialized_Fact>): CDOTAResponseQuerySerialized_Fact {
    return CDOTAResponseQuerySerialized_Fact.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAResponseQuerySerialized_Fact>): CDOTAResponseQuerySerialized_Fact {
    const message = createBaseCDOTAResponseQuerySerialized_Fact();
    message.key = object.key ?? 0;
    message.valtype = object.valtype ?? 1;
    message.valNumeric = object.valNumeric ?? 0;
    message.valString = object.valString ?? "";
    message.valStringtableIndex = object.valStringtableIndex ?? 0;
    message.valIntNumeric = object.valIntNumeric ?? 0;
    return message;
  },
};

function createBaseCDOTASpeechMatchOnClient(): CDOTASpeechMatchOnClient {
  return { speechConcept: 0, recipientType: 0, responsequery: undefined, randomseed: 0 };
}

export const CDOTASpeechMatchOnClient = {
  encode(message: CDOTASpeechMatchOnClient, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.speechConcept !== undefined && message.speechConcept !== 0) {
      writer.uint32(8).int32(message.speechConcept);
    }
    if (message.recipientType !== undefined && message.recipientType !== 0) {
      writer.uint32(16).int32(message.recipientType);
    }
    if (message.responsequery !== undefined) {
      CDOTAResponseQuerySerialized.encode(message.responsequery, writer.uint32(26).fork()).ldelim();
    }
    if (message.randomseed !== undefined && message.randomseed !== 0) {
      writer.uint32(37).sfixed32(message.randomseed);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTASpeechMatchOnClient {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTASpeechMatchOnClient();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.speechConcept = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.recipientType = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.responsequery = CDOTAResponseQuerySerialized.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 37) {
            break;
          }

          message.randomseed = reader.sfixed32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTASpeechMatchOnClient {
    return {
      speechConcept: isSet(object.speechConcept) ? globalThis.Number(object.speechConcept) : 0,
      recipientType: isSet(object.recipientType) ? globalThis.Number(object.recipientType) : 0,
      responsequery: isSet(object.responsequery)
        ? CDOTAResponseQuerySerialized.fromJSON(object.responsequery)
        : undefined,
      randomseed: isSet(object.randomseed) ? globalThis.Number(object.randomseed) : 0,
    };
  },

  toJSON(message: CDOTASpeechMatchOnClient): unknown {
    const obj: any = {};
    if (message.speechConcept !== undefined && message.speechConcept !== 0) {
      obj.speechConcept = Math.round(message.speechConcept);
    }
    if (message.recipientType !== undefined && message.recipientType !== 0) {
      obj.recipientType = Math.round(message.recipientType);
    }
    if (message.responsequery !== undefined) {
      obj.responsequery = CDOTAResponseQuerySerialized.toJSON(message.responsequery);
    }
    if (message.randomseed !== undefined && message.randomseed !== 0) {
      obj.randomseed = Math.round(message.randomseed);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTASpeechMatchOnClient>): CDOTASpeechMatchOnClient {
    return CDOTASpeechMatchOnClient.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTASpeechMatchOnClient>): CDOTASpeechMatchOnClient {
    const message = createBaseCDOTASpeechMatchOnClient();
    message.speechConcept = object.speechConcept ?? 0;
    message.recipientType = object.recipientType ?? 0;
    message.responsequery =
      object.responsequery !== undefined && object.responsequery !== null
        ? CDOTAResponseQuerySerialized.fromPartial(object.responsequery)
        : undefined;
    message.randomseed = object.randomseed ?? 0;
    return message;
  },
};

function createBaseCDOTAUserMsgUnitEvent(): CDOTAUserMsgUnitEvent {
  return {
    msgType: 0,
    entityIndex: 0,
    speech: undefined,
    speechMute: undefined,
    addGesture: undefined,
    removeGesture: undefined,
    bloodImpact: undefined,
    fadeGesture: undefined,
    speechMatchOnClient: undefined,
  };
}

export const CDOTAUserMsgUnitEvent = {
  encode(message: CDOTAUserMsgUnitEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.msgType !== 0) {
      writer.uint32(8).int32(message.msgType);
    }
    if (message.entityIndex !== 0) {
      writer.uint32(16).int32(message.entityIndex);
    }
    if (message.speech !== undefined) {
      CDOTAUserMsgUnitEvent_Speech.encode(message.speech, writer.uint32(26).fork()).ldelim();
    }
    if (message.speechMute !== undefined) {
      CDOTAUserMsgUnitEvent_SpeechMute.encode(message.speechMute, writer.uint32(34).fork()).ldelim();
    }
    if (message.addGesture !== undefined) {
      CDOTAUserMsgUnitEvent_AddGesture.encode(message.addGesture, writer.uint32(42).fork()).ldelim();
    }
    if (message.removeGesture !== undefined) {
      CDOTAUserMsgUnitEvent_RemoveGesture.encode(message.removeGesture, writer.uint32(50).fork()).ldelim();
    }
    if (message.bloodImpact !== undefined) {
      CDOTAUserMsgUnitEvent_BloodImpact.encode(message.bloodImpact, writer.uint32(58).fork()).ldelim();
    }
    if (message.fadeGesture !== undefined) {
      CDOTAUserMsgUnitEvent_FadeGesture.encode(message.fadeGesture, writer.uint32(66).fork()).ldelim();
    }
    if (message.speechMatchOnClient !== undefined) {
      CDOTASpeechMatchOnClient.encode(message.speechMatchOnClient, writer.uint32(74).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgUnitEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgUnitEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.msgType = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.entityIndex = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.speech = CDOTAUserMsgUnitEvent_Speech.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.speechMute = CDOTAUserMsgUnitEvent_SpeechMute.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.addGesture = CDOTAUserMsgUnitEvent_AddGesture.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.removeGesture = CDOTAUserMsgUnitEvent_RemoveGesture.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.bloodImpact = CDOTAUserMsgUnitEvent_BloodImpact.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.fadeGesture = CDOTAUserMsgUnitEvent_FadeGesture.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.speechMatchOnClient = CDOTASpeechMatchOnClient.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgUnitEvent {
    return {
      msgType: isSet(object.msgType) ? eDotaEntityMessagesFromJSON(object.msgType) : 0,
      entityIndex: isSet(object.entityIndex) ? globalThis.Number(object.entityIndex) : 0,
      speech: isSet(object.speech) ? CDOTAUserMsgUnitEvent_Speech.fromJSON(object.speech) : undefined,
      speechMute: isSet(object.speechMute) ? CDOTAUserMsgUnitEvent_SpeechMute.fromJSON(object.speechMute) : undefined,
      addGesture: isSet(object.addGesture) ? CDOTAUserMsgUnitEvent_AddGesture.fromJSON(object.addGesture) : undefined,
      removeGesture: isSet(object.removeGesture)
        ? CDOTAUserMsgUnitEvent_RemoveGesture.fromJSON(object.removeGesture)
        : undefined,
      bloodImpact: isSet(object.bloodImpact)
        ? CDOTAUserMsgUnitEvent_BloodImpact.fromJSON(object.bloodImpact)
        : undefined,
      fadeGesture: isSet(object.fadeGesture)
        ? CDOTAUserMsgUnitEvent_FadeGesture.fromJSON(object.fadeGesture)
        : undefined,
      speechMatchOnClient: isSet(object.speechMatchOnClient)
        ? CDOTASpeechMatchOnClient.fromJSON(object.speechMatchOnClient)
        : undefined,
    };
  },

  toJSON(message: CDOTAUserMsgUnitEvent): unknown {
    const obj: any = {};
    if (message.msgType !== 0) {
      obj.msgType = eDotaEntityMessagesToJSON(message.msgType);
    }
    if (message.entityIndex !== 0) {
      obj.entityIndex = Math.round(message.entityIndex);
    }
    if (message.speech !== undefined) {
      obj.speech = CDOTAUserMsgUnitEvent_Speech.toJSON(message.speech);
    }
    if (message.speechMute !== undefined) {
      obj.speechMute = CDOTAUserMsgUnitEvent_SpeechMute.toJSON(message.speechMute);
    }
    if (message.addGesture !== undefined) {
      obj.addGesture = CDOTAUserMsgUnitEvent_AddGesture.toJSON(message.addGesture);
    }
    if (message.removeGesture !== undefined) {
      obj.removeGesture = CDOTAUserMsgUnitEvent_RemoveGesture.toJSON(message.removeGesture);
    }
    if (message.bloodImpact !== undefined) {
      obj.bloodImpact = CDOTAUserMsgUnitEvent_BloodImpact.toJSON(message.bloodImpact);
    }
    if (message.fadeGesture !== undefined) {
      obj.fadeGesture = CDOTAUserMsgUnitEvent_FadeGesture.toJSON(message.fadeGesture);
    }
    if (message.speechMatchOnClient !== undefined) {
      obj.speechMatchOnClient = CDOTASpeechMatchOnClient.toJSON(message.speechMatchOnClient);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgUnitEvent>): CDOTAUserMsgUnitEvent {
    return CDOTAUserMsgUnitEvent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgUnitEvent>): CDOTAUserMsgUnitEvent {
    const message = createBaseCDOTAUserMsgUnitEvent();
    message.msgType = object.msgType ?? 0;
    message.entityIndex = object.entityIndex ?? 0;
    message.speech =
      object.speech !== undefined && object.speech !== null
        ? CDOTAUserMsgUnitEvent_Speech.fromPartial(object.speech)
        : undefined;
    message.speechMute =
      object.speechMute !== undefined && object.speechMute !== null
        ? CDOTAUserMsgUnitEvent_SpeechMute.fromPartial(object.speechMute)
        : undefined;
    message.addGesture =
      object.addGesture !== undefined && object.addGesture !== null
        ? CDOTAUserMsgUnitEvent_AddGesture.fromPartial(object.addGesture)
        : undefined;
    message.removeGesture =
      object.removeGesture !== undefined && object.removeGesture !== null
        ? CDOTAUserMsgUnitEvent_RemoveGesture.fromPartial(object.removeGesture)
        : undefined;
    message.bloodImpact =
      object.bloodImpact !== undefined && object.bloodImpact !== null
        ? CDOTAUserMsgUnitEvent_BloodImpact.fromPartial(object.bloodImpact)
        : undefined;
    message.fadeGesture =
      object.fadeGesture !== undefined && object.fadeGesture !== null
        ? CDOTAUserMsgUnitEvent_FadeGesture.fromPartial(object.fadeGesture)
        : undefined;
    message.speechMatchOnClient =
      object.speechMatchOnClient !== undefined && object.speechMatchOnClient !== null
        ? CDOTASpeechMatchOnClient.fromPartial(object.speechMatchOnClient)
        : undefined;
    return message;
  },
};

function createBaseCDOTAUserMsgUnitEvent_Interval(): CDOTAUserMsgUnitEvent_Interval {
  return { start: 0, range: 0 };
}

export const CDOTAUserMsgUnitEvent_Interval = {
  encode(message: CDOTAUserMsgUnitEvent_Interval, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.start !== undefined && message.start !== 0) {
      writer.uint32(13).float(message.start);
    }
    if (message.range !== undefined && message.range !== 0) {
      writer.uint32(21).float(message.range);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgUnitEvent_Interval {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgUnitEvent_Interval();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.start = reader.float();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.range = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgUnitEvent_Interval {
    return {
      start: isSet(object.start) ? globalThis.Number(object.start) : 0,
      range: isSet(object.range) ? globalThis.Number(object.range) : 0,
    };
  },

  toJSON(message: CDOTAUserMsgUnitEvent_Interval): unknown {
    const obj: any = {};
    if (message.start !== undefined && message.start !== 0) {
      obj.start = message.start;
    }
    if (message.range !== undefined && message.range !== 0) {
      obj.range = message.range;
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgUnitEvent_Interval>): CDOTAUserMsgUnitEvent_Interval {
    return CDOTAUserMsgUnitEvent_Interval.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgUnitEvent_Interval>): CDOTAUserMsgUnitEvent_Interval {
    const message = createBaseCDOTAUserMsgUnitEvent_Interval();
    message.start = object.start ?? 0;
    message.range = object.range ?? 0;
    return message;
  },
};

function createBaseCDOTAUserMsgUnitEvent_Speech(): CDOTAUserMsgUnitEvent_Speech {
  return { speechConcept: 0, response: "", recipientType: 0, muteable: false, predelay: undefined, flags: 0 };
}

export const CDOTAUserMsgUnitEvent_Speech = {
  encode(message: CDOTAUserMsgUnitEvent_Speech, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.speechConcept !== undefined && message.speechConcept !== 0) {
      writer.uint32(8).int32(message.speechConcept);
    }
    if (message.response !== undefined && message.response !== "") {
      writer.uint32(18).string(message.response);
    }
    if (message.recipientType !== undefined && message.recipientType !== 0) {
      writer.uint32(24).int32(message.recipientType);
    }
    if (message.muteable !== undefined && message.muteable !== false) {
      writer.uint32(40).bool(message.muteable);
    }
    if (message.predelay !== undefined) {
      CDOTAUserMsgUnitEvent_Interval.encode(message.predelay, writer.uint32(50).fork()).ldelim();
    }
    if (message.flags !== undefined && message.flags !== 0) {
      writer.uint32(56).uint32(message.flags);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgUnitEvent_Speech {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgUnitEvent_Speech();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.speechConcept = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.response = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.recipientType = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.muteable = reader.bool();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.predelay = CDOTAUserMsgUnitEvent_Interval.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.flags = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgUnitEvent_Speech {
    return {
      speechConcept: isSet(object.speechConcept) ? globalThis.Number(object.speechConcept) : 0,
      response: isSet(object.response) ? globalThis.String(object.response) : "",
      recipientType: isSet(object.recipientType) ? globalThis.Number(object.recipientType) : 0,
      muteable: isSet(object.muteable) ? globalThis.Boolean(object.muteable) : false,
      predelay: isSet(object.predelay) ? CDOTAUserMsgUnitEvent_Interval.fromJSON(object.predelay) : undefined,
      flags: isSet(object.flags) ? globalThis.Number(object.flags) : 0,
    };
  },

  toJSON(message: CDOTAUserMsgUnitEvent_Speech): unknown {
    const obj: any = {};
    if (message.speechConcept !== undefined && message.speechConcept !== 0) {
      obj.speechConcept = Math.round(message.speechConcept);
    }
    if (message.response !== undefined && message.response !== "") {
      obj.response = message.response;
    }
    if (message.recipientType !== undefined && message.recipientType !== 0) {
      obj.recipientType = Math.round(message.recipientType);
    }
    if (message.muteable !== undefined && message.muteable !== false) {
      obj.muteable = message.muteable;
    }
    if (message.predelay !== undefined) {
      obj.predelay = CDOTAUserMsgUnitEvent_Interval.toJSON(message.predelay);
    }
    if (message.flags !== undefined && message.flags !== 0) {
      obj.flags = Math.round(message.flags);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgUnitEvent_Speech>): CDOTAUserMsgUnitEvent_Speech {
    return CDOTAUserMsgUnitEvent_Speech.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgUnitEvent_Speech>): CDOTAUserMsgUnitEvent_Speech {
    const message = createBaseCDOTAUserMsgUnitEvent_Speech();
    message.speechConcept = object.speechConcept ?? 0;
    message.response = object.response ?? "";
    message.recipientType = object.recipientType ?? 0;
    message.muteable = object.muteable ?? false;
    message.predelay =
      object.predelay !== undefined && object.predelay !== null
        ? CDOTAUserMsgUnitEvent_Interval.fromPartial(object.predelay)
        : undefined;
    message.flags = object.flags ?? 0;
    return message;
  },
};

function createBaseCDOTAUserMsgUnitEvent_SpeechMute(): CDOTAUserMsgUnitEvent_SpeechMute {
  return { delay: 0.5 };
}

export const CDOTAUserMsgUnitEvent_SpeechMute = {
  encode(message: CDOTAUserMsgUnitEvent_SpeechMute, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.delay !== undefined && message.delay !== 0.5) {
      writer.uint32(13).float(message.delay);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgUnitEvent_SpeechMute {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgUnitEvent_SpeechMute();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.delay = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgUnitEvent_SpeechMute {
    return { delay: isSet(object.delay) ? globalThis.Number(object.delay) : 0.5 };
  },

  toJSON(message: CDOTAUserMsgUnitEvent_SpeechMute): unknown {
    const obj: any = {};
    if (message.delay !== undefined && message.delay !== 0.5) {
      obj.delay = message.delay;
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgUnitEvent_SpeechMute>): CDOTAUserMsgUnitEvent_SpeechMute {
    return CDOTAUserMsgUnitEvent_SpeechMute.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgUnitEvent_SpeechMute>): CDOTAUserMsgUnitEvent_SpeechMute {
    const message = createBaseCDOTAUserMsgUnitEvent_SpeechMute();
    message.delay = object.delay ?? 0.5;
    return message;
  },
};

function createBaseCDOTAUserMsgUnitEvent_AddGesture(): CDOTAUserMsgUnitEvent_AddGesture {
  return { activity: 0, slot: 0, fadeIn: 0, fadeOut: 0.1, playbackRate: 1, sequenceVariant: 0 };
}

export const CDOTAUserMsgUnitEvent_AddGesture = {
  encode(message: CDOTAUserMsgUnitEvent_AddGesture, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.activity !== undefined && message.activity !== 0) {
      writer.uint32(8).int32(message.activity);
    }
    if (message.slot !== undefined && message.slot !== 0) {
      writer.uint32(16).int32(message.slot);
    }
    if (message.fadeIn !== undefined && message.fadeIn !== 0) {
      writer.uint32(29).float(message.fadeIn);
    }
    if (message.fadeOut !== undefined && message.fadeOut !== 0.1) {
      writer.uint32(37).float(message.fadeOut);
    }
    if (message.playbackRate !== undefined && message.playbackRate !== 1) {
      writer.uint32(45).float(message.playbackRate);
    }
    if (message.sequenceVariant !== undefined && message.sequenceVariant !== 0) {
      writer.uint32(48).int32(message.sequenceVariant);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgUnitEvent_AddGesture {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgUnitEvent_AddGesture();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.activity = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.slot = reader.int32();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.fadeIn = reader.float();
          continue;
        case 4:
          if (tag !== 37) {
            break;
          }

          message.fadeOut = reader.float();
          continue;
        case 5:
          if (tag !== 45) {
            break;
          }

          message.playbackRate = reader.float();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.sequenceVariant = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgUnitEvent_AddGesture {
    return {
      activity: isSet(object.activity) ? globalThis.Number(object.activity) : 0,
      slot: isSet(object.slot) ? globalThis.Number(object.slot) : 0,
      fadeIn: isSet(object.fadeIn) ? globalThis.Number(object.fadeIn) : 0,
      fadeOut: isSet(object.fadeOut) ? globalThis.Number(object.fadeOut) : 0.1,
      playbackRate: isSet(object.playbackRate) ? globalThis.Number(object.playbackRate) : 1,
      sequenceVariant: isSet(object.sequenceVariant) ? globalThis.Number(object.sequenceVariant) : 0,
    };
  },

  toJSON(message: CDOTAUserMsgUnitEvent_AddGesture): unknown {
    const obj: any = {};
    if (message.activity !== undefined && message.activity !== 0) {
      obj.activity = Math.round(message.activity);
    }
    if (message.slot !== undefined && message.slot !== 0) {
      obj.slot = Math.round(message.slot);
    }
    if (message.fadeIn !== undefined && message.fadeIn !== 0) {
      obj.fadeIn = message.fadeIn;
    }
    if (message.fadeOut !== undefined && message.fadeOut !== 0.1) {
      obj.fadeOut = message.fadeOut;
    }
    if (message.playbackRate !== undefined && message.playbackRate !== 1) {
      obj.playbackRate = message.playbackRate;
    }
    if (message.sequenceVariant !== undefined && message.sequenceVariant !== 0) {
      obj.sequenceVariant = Math.round(message.sequenceVariant);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgUnitEvent_AddGesture>): CDOTAUserMsgUnitEvent_AddGesture {
    return CDOTAUserMsgUnitEvent_AddGesture.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgUnitEvent_AddGesture>): CDOTAUserMsgUnitEvent_AddGesture {
    const message = createBaseCDOTAUserMsgUnitEvent_AddGesture();
    message.activity = object.activity ?? 0;
    message.slot = object.slot ?? 0;
    message.fadeIn = object.fadeIn ?? 0;
    message.fadeOut = object.fadeOut ?? 0.1;
    message.playbackRate = object.playbackRate ?? 1;
    message.sequenceVariant = object.sequenceVariant ?? 0;
    return message;
  },
};

function createBaseCDOTAUserMsgUnitEvent_RemoveGesture(): CDOTAUserMsgUnitEvent_RemoveGesture {
  return { activity: 0 };
}

export const CDOTAUserMsgUnitEvent_RemoveGesture = {
  encode(message: CDOTAUserMsgUnitEvent_RemoveGesture, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.activity !== undefined && message.activity !== 0) {
      writer.uint32(8).int32(message.activity);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgUnitEvent_RemoveGesture {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgUnitEvent_RemoveGesture();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.activity = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgUnitEvent_RemoveGesture {
    return { activity: isSet(object.activity) ? globalThis.Number(object.activity) : 0 };
  },

  toJSON(message: CDOTAUserMsgUnitEvent_RemoveGesture): unknown {
    const obj: any = {};
    if (message.activity !== undefined && message.activity !== 0) {
      obj.activity = Math.round(message.activity);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgUnitEvent_RemoveGesture>): CDOTAUserMsgUnitEvent_RemoveGesture {
    return CDOTAUserMsgUnitEvent_RemoveGesture.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgUnitEvent_RemoveGesture>): CDOTAUserMsgUnitEvent_RemoveGesture {
    const message = createBaseCDOTAUserMsgUnitEvent_RemoveGesture();
    message.activity = object.activity ?? 0;
    return message;
  },
};

function createBaseCDOTAUserMsgUnitEvent_BloodImpact(): CDOTAUserMsgUnitEvent_BloodImpact {
  return { scale: 0, xNormal: 0, yNormal: 0 };
}

export const CDOTAUserMsgUnitEvent_BloodImpact = {
  encode(message: CDOTAUserMsgUnitEvent_BloodImpact, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.scale !== undefined && message.scale !== 0) {
      writer.uint32(8).int32(message.scale);
    }
    if (message.xNormal !== undefined && message.xNormal !== 0) {
      writer.uint32(16).int32(message.xNormal);
    }
    if (message.yNormal !== undefined && message.yNormal !== 0) {
      writer.uint32(24).int32(message.yNormal);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgUnitEvent_BloodImpact {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgUnitEvent_BloodImpact();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.scale = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.xNormal = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.yNormal = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgUnitEvent_BloodImpact {
    return {
      scale: isSet(object.scale) ? globalThis.Number(object.scale) : 0,
      xNormal: isSet(object.xNormal) ? globalThis.Number(object.xNormal) : 0,
      yNormal: isSet(object.yNormal) ? globalThis.Number(object.yNormal) : 0,
    };
  },

  toJSON(message: CDOTAUserMsgUnitEvent_BloodImpact): unknown {
    const obj: any = {};
    if (message.scale !== undefined && message.scale !== 0) {
      obj.scale = Math.round(message.scale);
    }
    if (message.xNormal !== undefined && message.xNormal !== 0) {
      obj.xNormal = Math.round(message.xNormal);
    }
    if (message.yNormal !== undefined && message.yNormal !== 0) {
      obj.yNormal = Math.round(message.yNormal);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgUnitEvent_BloodImpact>): CDOTAUserMsgUnitEvent_BloodImpact {
    return CDOTAUserMsgUnitEvent_BloodImpact.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgUnitEvent_BloodImpact>): CDOTAUserMsgUnitEvent_BloodImpact {
    const message = createBaseCDOTAUserMsgUnitEvent_BloodImpact();
    message.scale = object.scale ?? 0;
    message.xNormal = object.xNormal ?? 0;
    message.yNormal = object.yNormal ?? 0;
    return message;
  },
};

function createBaseCDOTAUserMsgUnitEvent_FadeGesture(): CDOTAUserMsgUnitEvent_FadeGesture {
  return { activity: 0 };
}

export const CDOTAUserMsgUnitEvent_FadeGesture = {
  encode(message: CDOTAUserMsgUnitEvent_FadeGesture, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.activity !== undefined && message.activity !== 0) {
      writer.uint32(8).int32(message.activity);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgUnitEvent_FadeGesture {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgUnitEvent_FadeGesture();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.activity = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgUnitEvent_FadeGesture {
    return { activity: isSet(object.activity) ? globalThis.Number(object.activity) : 0 };
  },

  toJSON(message: CDOTAUserMsgUnitEvent_FadeGesture): unknown {
    const obj: any = {};
    if (message.activity !== undefined && message.activity !== 0) {
      obj.activity = Math.round(message.activity);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgUnitEvent_FadeGesture>): CDOTAUserMsgUnitEvent_FadeGesture {
    return CDOTAUserMsgUnitEvent_FadeGesture.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgUnitEvent_FadeGesture>): CDOTAUserMsgUnitEvent_FadeGesture {
    const message = createBaseCDOTAUserMsgUnitEvent_FadeGesture();
    message.activity = object.activity ?? 0;
    return message;
  },
};

function createBaseCDOTAUserMsgItemPurchased(): CDOTAUserMsgItemPurchased {
  return { itemAbilityId: -1 };
}

export const CDOTAUserMsgItemPurchased = {
  encode(message: CDOTAUserMsgItemPurchased, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.itemAbilityId !== undefined && message.itemAbilityId !== -1) {
      writer.uint32(8).int32(message.itemAbilityId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgItemPurchased {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgItemPurchased();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.itemAbilityId = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgItemPurchased {
    return { itemAbilityId: isSet(object.itemAbilityId) ? globalThis.Number(object.itemAbilityId) : -1 };
  },

  toJSON(message: CDOTAUserMsgItemPurchased): unknown {
    const obj: any = {};
    if (message.itemAbilityId !== undefined && message.itemAbilityId !== -1) {
      obj.itemAbilityId = Math.round(message.itemAbilityId);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgItemPurchased>): CDOTAUserMsgItemPurchased {
    return CDOTAUserMsgItemPurchased.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgItemPurchased>): CDOTAUserMsgItemPurchased {
    const message = createBaseCDOTAUserMsgItemPurchased();
    message.itemAbilityId = object.itemAbilityId ?? -1;
    return message;
  },
};

function createBaseCDOTAUserMsgItemSold(): CDOTAUserMsgItemSold {
  return { itemAbilityId: -1 };
}

export const CDOTAUserMsgItemSold = {
  encode(message: CDOTAUserMsgItemSold, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.itemAbilityId !== undefined && message.itemAbilityId !== -1) {
      writer.uint32(8).int32(message.itemAbilityId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgItemSold {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgItemSold();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.itemAbilityId = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgItemSold {
    return { itemAbilityId: isSet(object.itemAbilityId) ? globalThis.Number(object.itemAbilityId) : -1 };
  },

  toJSON(message: CDOTAUserMsgItemSold): unknown {
    const obj: any = {};
    if (message.itemAbilityId !== undefined && message.itemAbilityId !== -1) {
      obj.itemAbilityId = Math.round(message.itemAbilityId);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgItemSold>): CDOTAUserMsgItemSold {
    return CDOTAUserMsgItemSold.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgItemSold>): CDOTAUserMsgItemSold {
    const message = createBaseCDOTAUserMsgItemSold();
    message.itemAbilityId = object.itemAbilityId ?? -1;
    return message;
  },
};

function createBaseCDOTAUserMsgItemFound(): CDOTAUserMsgItemFound {
  return { player: -1, quality: 0, rarity: 0, method: 0, itemdef: 0 };
}

export const CDOTAUserMsgItemFound = {
  encode(message: CDOTAUserMsgItemFound, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.player !== undefined && message.player !== -1) {
      writer.uint32(8).int32(message.player);
    }
    if (message.quality !== undefined && message.quality !== 0) {
      writer.uint32(16).int32(message.quality);
    }
    if (message.rarity !== undefined && message.rarity !== 0) {
      writer.uint32(24).int32(message.rarity);
    }
    if (message.method !== undefined && message.method !== 0) {
      writer.uint32(32).int32(message.method);
    }
    if (message.itemdef !== undefined && message.itemdef !== 0) {
      writer.uint32(40).uint32(message.itemdef);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgItemFound {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgItemFound();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.player = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.quality = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.rarity = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.method = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.itemdef = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgItemFound {
    return {
      player: isSet(object.player) ? globalThis.Number(object.player) : -1,
      quality: isSet(object.quality) ? globalThis.Number(object.quality) : 0,
      rarity: isSet(object.rarity) ? globalThis.Number(object.rarity) : 0,
      method: isSet(object.method) ? globalThis.Number(object.method) : 0,
      itemdef: isSet(object.itemdef) ? globalThis.Number(object.itemdef) : 0,
    };
  },

  toJSON(message: CDOTAUserMsgItemFound): unknown {
    const obj: any = {};
    if (message.player !== undefined && message.player !== -1) {
      obj.player = Math.round(message.player);
    }
    if (message.quality !== undefined && message.quality !== 0) {
      obj.quality = Math.round(message.quality);
    }
    if (message.rarity !== undefined && message.rarity !== 0) {
      obj.rarity = Math.round(message.rarity);
    }
    if (message.method !== undefined && message.method !== 0) {
      obj.method = Math.round(message.method);
    }
    if (message.itemdef !== undefined && message.itemdef !== 0) {
      obj.itemdef = Math.round(message.itemdef);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgItemFound>): CDOTAUserMsgItemFound {
    return CDOTAUserMsgItemFound.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgItemFound>): CDOTAUserMsgItemFound {
    const message = createBaseCDOTAUserMsgItemFound();
    message.player = object.player ?? -1;
    message.quality = object.quality ?? 0;
    message.rarity = object.rarity ?? 0;
    message.method = object.method ?? 0;
    message.itemdef = object.itemdef ?? 0;
    return message;
  },
};

function createBaseCDOTAUserMsgOverheadEvent(): CDOTAUserMsgOverheadEvent {
  return { messageType: 0, value: 0, targetPlayerEntindex: -1, targetEntindex: -1, sourcePlayerEntindex: -1 };
}

export const CDOTAUserMsgOverheadEvent = {
  encode(message: CDOTAUserMsgOverheadEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.messageType !== 0) {
      writer.uint32(8).int32(message.messageType);
    }
    if (message.value !== undefined && message.value !== 0) {
      writer.uint32(16).int32(message.value);
    }
    if (message.targetPlayerEntindex !== undefined && message.targetPlayerEntindex !== -1) {
      writer.uint32(24).int32(message.targetPlayerEntindex);
    }
    if (message.targetEntindex !== undefined && message.targetEntindex !== -1) {
      writer.uint32(32).int32(message.targetEntindex);
    }
    if (message.sourcePlayerEntindex !== undefined && message.sourcePlayerEntindex !== -1) {
      writer.uint32(40).int32(message.sourcePlayerEntindex);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgOverheadEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgOverheadEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.messageType = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.value = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.targetPlayerEntindex = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.targetEntindex = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.sourcePlayerEntindex = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgOverheadEvent {
    return {
      messageType: isSet(object.messageType) ? dotaOverheadAlertFromJSON(object.messageType) : 0,
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
      targetPlayerEntindex: isSet(object.targetPlayerEntindex) ? globalThis.Number(object.targetPlayerEntindex) : -1,
      targetEntindex: isSet(object.targetEntindex) ? globalThis.Number(object.targetEntindex) : -1,
      sourcePlayerEntindex: isSet(object.sourcePlayerEntindex) ? globalThis.Number(object.sourcePlayerEntindex) : -1,
    };
  },

  toJSON(message: CDOTAUserMsgOverheadEvent): unknown {
    const obj: any = {};
    if (message.messageType !== 0) {
      obj.messageType = dotaOverheadAlertToJSON(message.messageType);
    }
    if (message.value !== undefined && message.value !== 0) {
      obj.value = Math.round(message.value);
    }
    if (message.targetPlayerEntindex !== undefined && message.targetPlayerEntindex !== -1) {
      obj.targetPlayerEntindex = Math.round(message.targetPlayerEntindex);
    }
    if (message.targetEntindex !== undefined && message.targetEntindex !== -1) {
      obj.targetEntindex = Math.round(message.targetEntindex);
    }
    if (message.sourcePlayerEntindex !== undefined && message.sourcePlayerEntindex !== -1) {
      obj.sourcePlayerEntindex = Math.round(message.sourcePlayerEntindex);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgOverheadEvent>): CDOTAUserMsgOverheadEvent {
    return CDOTAUserMsgOverheadEvent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgOverheadEvent>): CDOTAUserMsgOverheadEvent {
    const message = createBaseCDOTAUserMsgOverheadEvent();
    message.messageType = object.messageType ?? 0;
    message.value = object.value ?? 0;
    message.targetPlayerEntindex = object.targetPlayerEntindex ?? -1;
    message.targetEntindex = object.targetEntindex ?? -1;
    message.sourcePlayerEntindex = object.sourcePlayerEntindex ?? -1;
    return message;
  },
};

function createBaseCDOTAUserMsgTutorialTipInfo(): CDOTAUserMsgTutorialTipInfo {
  return { name: "", progress: 0 };
}

export const CDOTAUserMsgTutorialTipInfo = {
  encode(message: CDOTAUserMsgTutorialTipInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.progress !== undefined && message.progress !== 0) {
      writer.uint32(16).int32(message.progress);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgTutorialTipInfo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgTutorialTipInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.progress = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgTutorialTipInfo {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      progress: isSet(object.progress) ? globalThis.Number(object.progress) : 0,
    };
  },

  toJSON(message: CDOTAUserMsgTutorialTipInfo): unknown {
    const obj: any = {};
    if (message.name !== undefined && message.name !== "") {
      obj.name = message.name;
    }
    if (message.progress !== undefined && message.progress !== 0) {
      obj.progress = Math.round(message.progress);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgTutorialTipInfo>): CDOTAUserMsgTutorialTipInfo {
    return CDOTAUserMsgTutorialTipInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgTutorialTipInfo>): CDOTAUserMsgTutorialTipInfo {
    const message = createBaseCDOTAUserMsgTutorialTipInfo();
    message.name = object.name ?? "";
    message.progress = object.progress ?? 0;
    return message;
  },
};

function createBaseCDOTAUserMsgTutorialFinish(): CDOTAUserMsgTutorialFinish {
  return { heading: "", emblem: "", body: "", success: false };
}

export const CDOTAUserMsgTutorialFinish = {
  encode(message: CDOTAUserMsgTutorialFinish, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.heading !== undefined && message.heading !== "") {
      writer.uint32(10).string(message.heading);
    }
    if (message.emblem !== undefined && message.emblem !== "") {
      writer.uint32(18).string(message.emblem);
    }
    if (message.body !== undefined && message.body !== "") {
      writer.uint32(26).string(message.body);
    }
    if (message.success !== undefined && message.success !== false) {
      writer.uint32(32).bool(message.success);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgTutorialFinish {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgTutorialFinish();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.heading = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.emblem = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.body = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.success = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgTutorialFinish {
    return {
      heading: isSet(object.heading) ? globalThis.String(object.heading) : "",
      emblem: isSet(object.emblem) ? globalThis.String(object.emblem) : "",
      body: isSet(object.body) ? globalThis.String(object.body) : "",
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
    };
  },

  toJSON(message: CDOTAUserMsgTutorialFinish): unknown {
    const obj: any = {};
    if (message.heading !== undefined && message.heading !== "") {
      obj.heading = message.heading;
    }
    if (message.emblem !== undefined && message.emblem !== "") {
      obj.emblem = message.emblem;
    }
    if (message.body !== undefined && message.body !== "") {
      obj.body = message.body;
    }
    if (message.success !== undefined && message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgTutorialFinish>): CDOTAUserMsgTutorialFinish {
    return CDOTAUserMsgTutorialFinish.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgTutorialFinish>): CDOTAUserMsgTutorialFinish {
    const message = createBaseCDOTAUserMsgTutorialFinish();
    message.heading = object.heading ?? "";
    message.emblem = object.emblem ?? "";
    message.body = object.body ?? "";
    message.success = object.success ?? false;
    return message;
  },
};

function createBaseCDOTAUserMsgTutorialMinimapPosition(): CDOTAUserMsgTutorialMinimapPosition {
  return {};
}

export const CDOTAUserMsgTutorialMinimapPosition = {
  encode(_: CDOTAUserMsgTutorialMinimapPosition, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgTutorialMinimapPosition {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgTutorialMinimapPosition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CDOTAUserMsgTutorialMinimapPosition {
    return {};
  },

  toJSON(_: CDOTAUserMsgTutorialMinimapPosition): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgTutorialMinimapPosition>): CDOTAUserMsgTutorialMinimapPosition {
    return CDOTAUserMsgTutorialMinimapPosition.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<CDOTAUserMsgTutorialMinimapPosition>): CDOTAUserMsgTutorialMinimapPosition {
    const message = createBaseCDOTAUserMsgTutorialMinimapPosition();
    return message;
  },
};

function createBaseCDOTAUserMsgSendGenericToolTip(): CDOTAUserMsgSendGenericToolTip {
  return { title: "", text: "", entindex: 0, close: false };
}

export const CDOTAUserMsgSendGenericToolTip = {
  encode(message: CDOTAUserMsgSendGenericToolTip, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.title !== undefined && message.title !== "") {
      writer.uint32(10).string(message.title);
    }
    if (message.text !== undefined && message.text !== "") {
      writer.uint32(18).string(message.text);
    }
    if (message.entindex !== undefined && message.entindex !== 0) {
      writer.uint32(24).int32(message.entindex);
    }
    if (message.close !== undefined && message.close !== false) {
      writer.uint32(32).bool(message.close);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgSendGenericToolTip {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgSendGenericToolTip();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.title = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.text = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.entindex = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.close = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgSendGenericToolTip {
    return {
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      text: isSet(object.text) ? globalThis.String(object.text) : "",
      entindex: isSet(object.entindex) ? globalThis.Number(object.entindex) : 0,
      close: isSet(object.close) ? globalThis.Boolean(object.close) : false,
    };
  },

  toJSON(message: CDOTAUserMsgSendGenericToolTip): unknown {
    const obj: any = {};
    if (message.title !== undefined && message.title !== "") {
      obj.title = message.title;
    }
    if (message.text !== undefined && message.text !== "") {
      obj.text = message.text;
    }
    if (message.entindex !== undefined && message.entindex !== 0) {
      obj.entindex = Math.round(message.entindex);
    }
    if (message.close !== undefined && message.close !== false) {
      obj.close = message.close;
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgSendGenericToolTip>): CDOTAUserMsgSendGenericToolTip {
    return CDOTAUserMsgSendGenericToolTip.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgSendGenericToolTip>): CDOTAUserMsgSendGenericToolTip {
    const message = createBaseCDOTAUserMsgSendGenericToolTip();
    message.title = object.title ?? "";
    message.text = object.text ?? "";
    message.entindex = object.entindex ?? 0;
    message.close = object.close ?? false;
    return message;
  },
};

function createBaseCDOTAUserMsgWorldLine(): CDOTAUserMsgWorldLine {
  return { playerId: -1, worldline: undefined };
}

export const CDOTAUserMsgWorldLine = {
  encode(message: CDOTAUserMsgWorldLine, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.playerId !== undefined && message.playerId !== -1) {
      writer.uint32(8).int32(message.playerId);
    }
    if (message.worldline !== undefined) {
      CDOTAMsgWorldLine.encode(message.worldline, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgWorldLine {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgWorldLine();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.playerId = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.worldline = CDOTAMsgWorldLine.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgWorldLine {
    return {
      playerId: isSet(object.playerId) ? globalThis.Number(object.playerId) : -1,
      worldline: isSet(object.worldline) ? CDOTAMsgWorldLine.fromJSON(object.worldline) : undefined,
    };
  },

  toJSON(message: CDOTAUserMsgWorldLine): unknown {
    const obj: any = {};
    if (message.playerId !== undefined && message.playerId !== -1) {
      obj.playerId = Math.round(message.playerId);
    }
    if (message.worldline !== undefined) {
      obj.worldline = CDOTAMsgWorldLine.toJSON(message.worldline);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgWorldLine>): CDOTAUserMsgWorldLine {
    return CDOTAUserMsgWorldLine.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgWorldLine>): CDOTAUserMsgWorldLine {
    const message = createBaseCDOTAUserMsgWorldLine();
    message.playerId = object.playerId ?? -1;
    message.worldline =
      object.worldline !== undefined && object.worldline !== null
        ? CDOTAMsgWorldLine.fromPartial(object.worldline)
        : undefined;
    return message;
  },
};

function createBaseCDOTAUserMsgChatWheel(): CDOTAUserMsgChatWheel {
  return { chatMessageId: 4294967295, playerId: -1, accountId: 0, paramHeroId: 0, emoticonId: 0 };
}

export const CDOTAUserMsgChatWheel = {
  encode(message: CDOTAUserMsgChatWheel, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.chatMessageId !== undefined && message.chatMessageId !== 4294967295) {
      writer.uint32(8).uint32(message.chatMessageId);
    }
    if (message.playerId !== undefined && message.playerId !== -1) {
      writer.uint32(16).int32(message.playerId);
    }
    if (message.accountId !== undefined && message.accountId !== 0) {
      writer.uint32(24).uint32(message.accountId);
    }
    if (message.paramHeroId !== undefined && message.paramHeroId !== 0) {
      writer.uint32(32).uint32(message.paramHeroId);
    }
    if (message.emoticonId !== undefined && message.emoticonId !== 0) {
      writer.uint32(40).uint32(message.emoticonId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgChatWheel {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgChatWheel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.chatMessageId = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.playerId = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.paramHeroId = reader.uint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.emoticonId = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgChatWheel {
    return {
      chatMessageId: isSet(object.chatMessageId) ? globalThis.Number(object.chatMessageId) : 4294967295,
      playerId: isSet(object.playerId) ? globalThis.Number(object.playerId) : -1,
      accountId: isSet(object.accountId) ? globalThis.Number(object.accountId) : 0,
      paramHeroId: isSet(object.paramHeroId) ? globalThis.Number(object.paramHeroId) : 0,
      emoticonId: isSet(object.emoticonId) ? globalThis.Number(object.emoticonId) : 0,
    };
  },

  toJSON(message: CDOTAUserMsgChatWheel): unknown {
    const obj: any = {};
    if (message.chatMessageId !== undefined && message.chatMessageId !== 4294967295) {
      obj.chatMessageId = Math.round(message.chatMessageId);
    }
    if (message.playerId !== undefined && message.playerId !== -1) {
      obj.playerId = Math.round(message.playerId);
    }
    if (message.accountId !== undefined && message.accountId !== 0) {
      obj.accountId = Math.round(message.accountId);
    }
    if (message.paramHeroId !== undefined && message.paramHeroId !== 0) {
      obj.paramHeroId = Math.round(message.paramHeroId);
    }
    if (message.emoticonId !== undefined && message.emoticonId !== 0) {
      obj.emoticonId = Math.round(message.emoticonId);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgChatWheel>): CDOTAUserMsgChatWheel {
    return CDOTAUserMsgChatWheel.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgChatWheel>): CDOTAUserMsgChatWheel {
    const message = createBaseCDOTAUserMsgChatWheel();
    message.chatMessageId = object.chatMessageId ?? 4294967295;
    message.playerId = object.playerId ?? -1;
    message.accountId = object.accountId ?? 0;
    message.paramHeroId = object.paramHeroId ?? 0;
    message.emoticonId = object.emoticonId ?? 0;
    return message;
  },
};

function createBaseCDOTAUserMsgReceivedXmasGift(): CDOTAUserMsgReceivedXmasGift {
  return { playerId: -1, itemName: "", inventorySlot: 0 };
}

export const CDOTAUserMsgReceivedXmasGift = {
  encode(message: CDOTAUserMsgReceivedXmasGift, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.playerId !== undefined && message.playerId !== -1) {
      writer.uint32(8).int32(message.playerId);
    }
    if (message.itemName !== undefined && message.itemName !== "") {
      writer.uint32(18).string(message.itemName);
    }
    if (message.inventorySlot !== undefined && message.inventorySlot !== 0) {
      writer.uint32(24).int32(message.inventorySlot);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgReceivedXmasGift {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgReceivedXmasGift();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.playerId = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.itemName = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.inventorySlot = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgReceivedXmasGift {
    return {
      playerId: isSet(object.playerId) ? globalThis.Number(object.playerId) : -1,
      itemName: isSet(object.itemName) ? globalThis.String(object.itemName) : "",
      inventorySlot: isSet(object.inventorySlot) ? globalThis.Number(object.inventorySlot) : 0,
    };
  },

  toJSON(message: CDOTAUserMsgReceivedXmasGift): unknown {
    const obj: any = {};
    if (message.playerId !== undefined && message.playerId !== -1) {
      obj.playerId = Math.round(message.playerId);
    }
    if (message.itemName !== undefined && message.itemName !== "") {
      obj.itemName = message.itemName;
    }
    if (message.inventorySlot !== undefined && message.inventorySlot !== 0) {
      obj.inventorySlot = Math.round(message.inventorySlot);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgReceivedXmasGift>): CDOTAUserMsgReceivedXmasGift {
    return CDOTAUserMsgReceivedXmasGift.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgReceivedXmasGift>): CDOTAUserMsgReceivedXmasGift {
    const message = createBaseCDOTAUserMsgReceivedXmasGift();
    message.playerId = object.playerId ?? -1;
    message.itemName = object.itemName ?? "";
    message.inventorySlot = object.inventorySlot ?? 0;
    return message;
  },
};

function createBaseCDOTAUserMsgShowSurvey(): CDOTAUserMsgShowSurvey {
  return { surveyId: 0, matchId: "0", responseStyle: "", teammateHeroId: 0, teammateName: "", teammateAccountId: 0 };
}

export const CDOTAUserMsgShowSurvey = {
  encode(message: CDOTAUserMsgShowSurvey, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.surveyId !== undefined && message.surveyId !== 0) {
      writer.uint32(8).int32(message.surveyId);
    }
    if (message.matchId !== undefined && message.matchId !== "0") {
      writer.uint32(16).uint64(message.matchId);
    }
    if (message.responseStyle !== undefined && message.responseStyle !== "") {
      writer.uint32(26).string(message.responseStyle);
    }
    if (message.teammateHeroId !== undefined && message.teammateHeroId !== 0) {
      writer.uint32(32).uint32(message.teammateHeroId);
    }
    if (message.teammateName !== undefined && message.teammateName !== "") {
      writer.uint32(42).string(message.teammateName);
    }
    if (message.teammateAccountId !== undefined && message.teammateAccountId !== 0) {
      writer.uint32(48).uint32(message.teammateAccountId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgShowSurvey {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgShowSurvey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.surveyId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.matchId = longToString(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.responseStyle = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.teammateHeroId = reader.uint32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.teammateName = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.teammateAccountId = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgShowSurvey {
    return {
      surveyId: isSet(object.surveyId) ? globalThis.Number(object.surveyId) : 0,
      matchId: isSet(object.matchId) ? globalThis.String(object.matchId) : "0",
      responseStyle: isSet(object.responseStyle) ? globalThis.String(object.responseStyle) : "",
      teammateHeroId: isSet(object.teammateHeroId) ? globalThis.Number(object.teammateHeroId) : 0,
      teammateName: isSet(object.teammateName) ? globalThis.String(object.teammateName) : "",
      teammateAccountId: isSet(object.teammateAccountId) ? globalThis.Number(object.teammateAccountId) : 0,
    };
  },

  toJSON(message: CDOTAUserMsgShowSurvey): unknown {
    const obj: any = {};
    if (message.surveyId !== undefined && message.surveyId !== 0) {
      obj.surveyId = Math.round(message.surveyId);
    }
    if (message.matchId !== undefined && message.matchId !== "0") {
      obj.matchId = message.matchId;
    }
    if (message.responseStyle !== undefined && message.responseStyle !== "") {
      obj.responseStyle = message.responseStyle;
    }
    if (message.teammateHeroId !== undefined && message.teammateHeroId !== 0) {
      obj.teammateHeroId = Math.round(message.teammateHeroId);
    }
    if (message.teammateName !== undefined && message.teammateName !== "") {
      obj.teammateName = message.teammateName;
    }
    if (message.teammateAccountId !== undefined && message.teammateAccountId !== 0) {
      obj.teammateAccountId = Math.round(message.teammateAccountId);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgShowSurvey>): CDOTAUserMsgShowSurvey {
    return CDOTAUserMsgShowSurvey.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgShowSurvey>): CDOTAUserMsgShowSurvey {
    const message = createBaseCDOTAUserMsgShowSurvey();
    message.surveyId = object.surveyId ?? 0;
    message.matchId = object.matchId ?? "0";
    message.responseStyle = object.responseStyle ?? "";
    message.teammateHeroId = object.teammateHeroId ?? 0;
    message.teammateName = object.teammateName ?? "";
    message.teammateAccountId = object.teammateAccountId ?? 0;
    return message;
  },
};

function createBaseCDOTAUserMsgUpdateSharedContent(): CDOTAUserMsgUpdateSharedContent {
  return { slotType: 0 };
}

export const CDOTAUserMsgUpdateSharedContent = {
  encode(message: CDOTAUserMsgUpdateSharedContent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.slotType !== undefined && message.slotType !== 0) {
      writer.uint32(8).int32(message.slotType);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgUpdateSharedContent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgUpdateSharedContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.slotType = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgUpdateSharedContent {
    return { slotType: isSet(object.slotType) ? globalThis.Number(object.slotType) : 0 };
  },

  toJSON(message: CDOTAUserMsgUpdateSharedContent): unknown {
    const obj: any = {};
    if (message.slotType !== undefined && message.slotType !== 0) {
      obj.slotType = Math.round(message.slotType);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgUpdateSharedContent>): CDOTAUserMsgUpdateSharedContent {
    return CDOTAUserMsgUpdateSharedContent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgUpdateSharedContent>): CDOTAUserMsgUpdateSharedContent {
    const message = createBaseCDOTAUserMsgUpdateSharedContent();
    message.slotType = object.slotType ?? 0;
    return message;
  },
};

function createBaseCDOTAUserMsgTutorialRequestExp(): CDOTAUserMsgTutorialRequestExp {
  return {};
}

export const CDOTAUserMsgTutorialRequestExp = {
  encode(_: CDOTAUserMsgTutorialRequestExp, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgTutorialRequestExp {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgTutorialRequestExp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CDOTAUserMsgTutorialRequestExp {
    return {};
  },

  toJSON(_: CDOTAUserMsgTutorialRequestExp): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgTutorialRequestExp>): CDOTAUserMsgTutorialRequestExp {
    return CDOTAUserMsgTutorialRequestExp.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<CDOTAUserMsgTutorialRequestExp>): CDOTAUserMsgTutorialRequestExp {
    const message = createBaseCDOTAUserMsgTutorialRequestExp();
    return message;
  },
};

function createBaseCDOTAUserMsgTutorialFade(): CDOTAUserMsgTutorialFade {
  return { tgtAlpha: 0 };
}

export const CDOTAUserMsgTutorialFade = {
  encode(message: CDOTAUserMsgTutorialFade, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.tgtAlpha !== undefined && message.tgtAlpha !== 0) {
      writer.uint32(8).int32(message.tgtAlpha);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgTutorialFade {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgTutorialFade();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.tgtAlpha = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgTutorialFade {
    return { tgtAlpha: isSet(object.tgtAlpha) ? globalThis.Number(object.tgtAlpha) : 0 };
  },

  toJSON(message: CDOTAUserMsgTutorialFade): unknown {
    const obj: any = {};
    if (message.tgtAlpha !== undefined && message.tgtAlpha !== 0) {
      obj.tgtAlpha = Math.round(message.tgtAlpha);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgTutorialFade>): CDOTAUserMsgTutorialFade {
    return CDOTAUserMsgTutorialFade.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgTutorialFade>): CDOTAUserMsgTutorialFade {
    const message = createBaseCDOTAUserMsgTutorialFade();
    message.tgtAlpha = object.tgtAlpha ?? 0;
    return message;
  },
};

function createBaseCDOTAUserMsgTutorialPingMinimap(): CDOTAUserMsgTutorialPingMinimap {
  return { playerId: -1, posX: 0, posY: 0, posZ: 0, entityIndex: 0 };
}

export const CDOTAUserMsgTutorialPingMinimap = {
  encode(message: CDOTAUserMsgTutorialPingMinimap, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.playerId !== undefined && message.playerId !== -1) {
      writer.uint32(8).int32(message.playerId);
    }
    if (message.posX !== undefined && message.posX !== 0) {
      writer.uint32(21).float(message.posX);
    }
    if (message.posY !== undefined && message.posY !== 0) {
      writer.uint32(29).float(message.posY);
    }
    if (message.posZ !== undefined && message.posZ !== 0) {
      writer.uint32(37).float(message.posZ);
    }
    if (message.entityIndex !== undefined && message.entityIndex !== 0) {
      writer.uint32(40).int32(message.entityIndex);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgTutorialPingMinimap {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgTutorialPingMinimap();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.playerId = reader.int32();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.posX = reader.float();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.posY = reader.float();
          continue;
        case 4:
          if (tag !== 37) {
            break;
          }

          message.posZ = reader.float();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.entityIndex = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgTutorialPingMinimap {
    return {
      playerId: isSet(object.playerId) ? globalThis.Number(object.playerId) : -1,
      posX: isSet(object.posX) ? globalThis.Number(object.posX) : 0,
      posY: isSet(object.posY) ? globalThis.Number(object.posY) : 0,
      posZ: isSet(object.posZ) ? globalThis.Number(object.posZ) : 0,
      entityIndex: isSet(object.entityIndex) ? globalThis.Number(object.entityIndex) : 0,
    };
  },

  toJSON(message: CDOTAUserMsgTutorialPingMinimap): unknown {
    const obj: any = {};
    if (message.playerId !== undefined && message.playerId !== -1) {
      obj.playerId = Math.round(message.playerId);
    }
    if (message.posX !== undefined && message.posX !== 0) {
      obj.posX = message.posX;
    }
    if (message.posY !== undefined && message.posY !== 0) {
      obj.posY = message.posY;
    }
    if (message.posZ !== undefined && message.posZ !== 0) {
      obj.posZ = message.posZ;
    }
    if (message.entityIndex !== undefined && message.entityIndex !== 0) {
      obj.entityIndex = Math.round(message.entityIndex);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgTutorialPingMinimap>): CDOTAUserMsgTutorialPingMinimap {
    return CDOTAUserMsgTutorialPingMinimap.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgTutorialPingMinimap>): CDOTAUserMsgTutorialPingMinimap {
    const message = createBaseCDOTAUserMsgTutorialPingMinimap();
    message.playerId = object.playerId ?? -1;
    message.posX = object.posX ?? 0;
    message.posY = object.posY ?? 0;
    message.posZ = object.posZ ?? 0;
    message.entityIndex = object.entityIndex ?? 0;
    return message;
  },
};

function createBaseCDOTAUserMsgGamerulesStateChanged(): CDOTAUserMsgGamerulesStateChanged {
  return { state: 0 };
}

export const CDOTAUserMsgGamerulesStateChanged = {
  encode(message: CDOTAUserMsgGamerulesStateChanged, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.state !== undefined && message.state !== 0) {
      writer.uint32(8).uint32(message.state);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgGamerulesStateChanged {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgGamerulesStateChanged();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.state = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgGamerulesStateChanged {
    return { state: isSet(object.state) ? globalThis.Number(object.state) : 0 };
  },

  toJSON(message: CDOTAUserMsgGamerulesStateChanged): unknown {
    const obj: any = {};
    if (message.state !== undefined && message.state !== 0) {
      obj.state = Math.round(message.state);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgGamerulesStateChanged>): CDOTAUserMsgGamerulesStateChanged {
    return CDOTAUserMsgGamerulesStateChanged.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgGamerulesStateChanged>): CDOTAUserMsgGamerulesStateChanged {
    const message = createBaseCDOTAUserMsgGamerulesStateChanged();
    message.state = object.state ?? 0;
    return message;
  },
};

function createBaseCDOTAUserMsgAddQuestLogEntry(): CDOTAUserMsgAddQuestLogEntry {
  return { npcName: "", npcDialog: "" };
}

export const CDOTAUserMsgAddQuestLogEntry = {
  encode(message: CDOTAUserMsgAddQuestLogEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.npcName !== undefined && message.npcName !== "") {
      writer.uint32(10).string(message.npcName);
    }
    if (message.npcDialog !== undefined && message.npcDialog !== "") {
      writer.uint32(18).string(message.npcDialog);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgAddQuestLogEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgAddQuestLogEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.npcName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.npcDialog = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgAddQuestLogEntry {
    return {
      npcName: isSet(object.npcName) ? globalThis.String(object.npcName) : "",
      npcDialog: isSet(object.npcDialog) ? globalThis.String(object.npcDialog) : "",
    };
  },

  toJSON(message: CDOTAUserMsgAddQuestLogEntry): unknown {
    const obj: any = {};
    if (message.npcName !== undefined && message.npcName !== "") {
      obj.npcName = message.npcName;
    }
    if (message.npcDialog !== undefined && message.npcDialog !== "") {
      obj.npcDialog = message.npcDialog;
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgAddQuestLogEntry>): CDOTAUserMsgAddQuestLogEntry {
    return CDOTAUserMsgAddQuestLogEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgAddQuestLogEntry>): CDOTAUserMsgAddQuestLogEntry {
    const message = createBaseCDOTAUserMsgAddQuestLogEntry();
    message.npcName = object.npcName ?? "";
    message.npcDialog = object.npcDialog ?? "";
    return message;
  },
};

function createBaseCDOTAUserMsgSendStatPopup(): CDOTAUserMsgSendStatPopup {
  return { playerId: -1, statpopup: undefined };
}

export const CDOTAUserMsgSendStatPopup = {
  encode(message: CDOTAUserMsgSendStatPopup, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.playerId !== undefined && message.playerId !== -1) {
      writer.uint32(8).int32(message.playerId);
    }
    if (message.statpopup !== undefined) {
      CDOTAMsgSendStatPopup.encode(message.statpopup, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgSendStatPopup {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgSendStatPopup();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.playerId = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.statpopup = CDOTAMsgSendStatPopup.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgSendStatPopup {
    return {
      playerId: isSet(object.playerId) ? globalThis.Number(object.playerId) : -1,
      statpopup: isSet(object.statpopup) ? CDOTAMsgSendStatPopup.fromJSON(object.statpopup) : undefined,
    };
  },

  toJSON(message: CDOTAUserMsgSendStatPopup): unknown {
    const obj: any = {};
    if (message.playerId !== undefined && message.playerId !== -1) {
      obj.playerId = Math.round(message.playerId);
    }
    if (message.statpopup !== undefined) {
      obj.statpopup = CDOTAMsgSendStatPopup.toJSON(message.statpopup);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgSendStatPopup>): CDOTAUserMsgSendStatPopup {
    return CDOTAUserMsgSendStatPopup.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgSendStatPopup>): CDOTAUserMsgSendStatPopup {
    const message = createBaseCDOTAUserMsgSendStatPopup();
    message.playerId = object.playerId ?? -1;
    message.statpopup =
      object.statpopup !== undefined && object.statpopup !== null
        ? CDOTAMsgSendStatPopup.fromPartial(object.statpopup)
        : undefined;
    return message;
  },
};

function createBaseCDOTAUserMsgDismissAllStatPopups(): CDOTAUserMsgDismissAllStatPopups {
  return { dismissallmsg: undefined };
}

export const CDOTAUserMsgDismissAllStatPopups = {
  encode(message: CDOTAUserMsgDismissAllStatPopups, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.dismissallmsg !== undefined) {
      CDOTAMsgDismissAllStatPopups.encode(message.dismissallmsg, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgDismissAllStatPopups {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgDismissAllStatPopups();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.dismissallmsg = CDOTAMsgDismissAllStatPopups.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgDismissAllStatPopups {
    return {
      dismissallmsg: isSet(object.dismissallmsg)
        ? CDOTAMsgDismissAllStatPopups.fromJSON(object.dismissallmsg)
        : undefined,
    };
  },

  toJSON(message: CDOTAUserMsgDismissAllStatPopups): unknown {
    const obj: any = {};
    if (message.dismissallmsg !== undefined) {
      obj.dismissallmsg = CDOTAMsgDismissAllStatPopups.toJSON(message.dismissallmsg);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgDismissAllStatPopups>): CDOTAUserMsgDismissAllStatPopups {
    return CDOTAUserMsgDismissAllStatPopups.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgDismissAllStatPopups>): CDOTAUserMsgDismissAllStatPopups {
    const message = createBaseCDOTAUserMsgDismissAllStatPopups();
    message.dismissallmsg =
      object.dismissallmsg !== undefined && object.dismissallmsg !== null
        ? CDOTAMsgDismissAllStatPopups.fromPartial(object.dismissallmsg)
        : undefined;
    return message;
  },
};

function createBaseCDOTAUserMsgSendRoshanSpectatorPhase(): CDOTAUserMsgSendRoshanSpectatorPhase {
  return { phase: 0, phaseStartTime: 0, phaseLength: 0 };
}

export const CDOTAUserMsgSendRoshanSpectatorPhase = {
  encode(message: CDOTAUserMsgSendRoshanSpectatorPhase, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.phase !== undefined && message.phase !== 0) {
      writer.uint32(8).int32(message.phase);
    }
    if (message.phaseStartTime !== undefined && message.phaseStartTime !== 0) {
      writer.uint32(16).int32(message.phaseStartTime);
    }
    if (message.phaseLength !== undefined && message.phaseLength !== 0) {
      writer.uint32(24).int32(message.phaseLength);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgSendRoshanSpectatorPhase {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgSendRoshanSpectatorPhase();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.phase = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.phaseStartTime = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.phaseLength = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgSendRoshanSpectatorPhase {
    return {
      phase: isSet(object.phase) ? dotaRoshanPhaseFromJSON(object.phase) : 0,
      phaseStartTime: isSet(object.phaseStartTime) ? globalThis.Number(object.phaseStartTime) : 0,
      phaseLength: isSet(object.phaseLength) ? globalThis.Number(object.phaseLength) : 0,
    };
  },

  toJSON(message: CDOTAUserMsgSendRoshanSpectatorPhase): unknown {
    const obj: any = {};
    if (message.phase !== undefined && message.phase !== 0) {
      obj.phase = dotaRoshanPhaseToJSON(message.phase);
    }
    if (message.phaseStartTime !== undefined && message.phaseStartTime !== 0) {
      obj.phaseStartTime = Math.round(message.phaseStartTime);
    }
    if (message.phaseLength !== undefined && message.phaseLength !== 0) {
      obj.phaseLength = Math.round(message.phaseLength);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgSendRoshanSpectatorPhase>): CDOTAUserMsgSendRoshanSpectatorPhase {
    return CDOTAUserMsgSendRoshanSpectatorPhase.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgSendRoshanSpectatorPhase>): CDOTAUserMsgSendRoshanSpectatorPhase {
    const message = createBaseCDOTAUserMsgSendRoshanSpectatorPhase();
    message.phase = object.phase ?? 0;
    message.phaseStartTime = object.phaseStartTime ?? 0;
    message.phaseLength = object.phaseLength ?? 0;
    return message;
  },
};

function createBaseCDOTAUserMsgSendRoshanPopup(): CDOTAUserMsgSendRoshanPopup {
  return { reclaimed: false, gametime: 0 };
}

export const CDOTAUserMsgSendRoshanPopup = {
  encode(message: CDOTAUserMsgSendRoshanPopup, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.reclaimed !== undefined && message.reclaimed !== false) {
      writer.uint32(8).bool(message.reclaimed);
    }
    if (message.gametime !== undefined && message.gametime !== 0) {
      writer.uint32(16).int32(message.gametime);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgSendRoshanPopup {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgSendRoshanPopup();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.reclaimed = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.gametime = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgSendRoshanPopup {
    return {
      reclaimed: isSet(object.reclaimed) ? globalThis.Boolean(object.reclaimed) : false,
      gametime: isSet(object.gametime) ? globalThis.Number(object.gametime) : 0,
    };
  },

  toJSON(message: CDOTAUserMsgSendRoshanPopup): unknown {
    const obj: any = {};
    if (message.reclaimed !== undefined && message.reclaimed !== false) {
      obj.reclaimed = message.reclaimed;
    }
    if (message.gametime !== undefined && message.gametime !== 0) {
      obj.gametime = Math.round(message.gametime);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgSendRoshanPopup>): CDOTAUserMsgSendRoshanPopup {
    return CDOTAUserMsgSendRoshanPopup.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgSendRoshanPopup>): CDOTAUserMsgSendRoshanPopup {
    const message = createBaseCDOTAUserMsgSendRoshanPopup();
    message.reclaimed = object.reclaimed ?? false;
    message.gametime = object.gametime ?? 0;
    return message;
  },
};

function createBaseCDOTAUserMsgSendFinalGold(): CDOTAUserMsgSendFinalGold {
  return { reliableGold: [], unreliableGold: [] };
}

export const CDOTAUserMsgSendFinalGold = {
  encode(message: CDOTAUserMsgSendFinalGold, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.reliableGold) {
      writer.uint32(v);
    }
    writer.ldelim();
    writer.uint32(18).fork();
    for (const v of message.unreliableGold) {
      writer.uint32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgSendFinalGold {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgSendFinalGold();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.reliableGold.push(reader.uint32());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.reliableGold.push(reader.uint32());
            }

            continue;
          }

          break;
        case 2:
          if (tag === 16) {
            message.unreliableGold.push(reader.uint32());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.unreliableGold.push(reader.uint32());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgSendFinalGold {
    return {
      reliableGold: globalThis.Array.isArray(object?.reliableGold)
        ? object.reliableGold.map((e: any) => globalThis.Number(e))
        : [],
      unreliableGold: globalThis.Array.isArray(object?.unreliableGold)
        ? object.unreliableGold.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: CDOTAUserMsgSendFinalGold): unknown {
    const obj: any = {};
    if (message.reliableGold?.length) {
      obj.reliableGold = message.reliableGold.map((e) => Math.round(e));
    }
    if (message.unreliableGold?.length) {
      obj.unreliableGold = message.unreliableGold.map((e) => Math.round(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgSendFinalGold>): CDOTAUserMsgSendFinalGold {
    return CDOTAUserMsgSendFinalGold.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgSendFinalGold>): CDOTAUserMsgSendFinalGold {
    const message = createBaseCDOTAUserMsgSendFinalGold();
    message.reliableGold = object.reliableGold?.map((e) => e) || [];
    message.unreliableGold = object.unreliableGold?.map((e) => e) || [];
    return message;
  },
};

function createBaseCDOTAUserMsgCustomMsg(): CDOTAUserMsgCustomMsg {
  return { message: "", playerId: -1, value: 0 };
}

export const CDOTAUserMsgCustomMsg = {
  encode(message: CDOTAUserMsgCustomMsg, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.message !== undefined && message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    if (message.playerId !== undefined && message.playerId !== -1) {
      writer.uint32(16).int32(message.playerId);
    }
    if (message.value !== undefined && message.value !== 0) {
      writer.uint32(24).int32(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgCustomMsg {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgCustomMsg();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.playerId = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.value = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgCustomMsg {
    return {
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      playerId: isSet(object.playerId) ? globalThis.Number(object.playerId) : -1,
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
    };
  },

  toJSON(message: CDOTAUserMsgCustomMsg): unknown {
    const obj: any = {};
    if (message.message !== undefined && message.message !== "") {
      obj.message = message.message;
    }
    if (message.playerId !== undefined && message.playerId !== -1) {
      obj.playerId = Math.round(message.playerId);
    }
    if (message.value !== undefined && message.value !== 0) {
      obj.value = Math.round(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgCustomMsg>): CDOTAUserMsgCustomMsg {
    return CDOTAUserMsgCustomMsg.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgCustomMsg>): CDOTAUserMsgCustomMsg {
    const message = createBaseCDOTAUserMsgCustomMsg();
    message.message = object.message ?? "";
    message.playerId = object.playerId ?? -1;
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseCDOTAUserMsgCoachHUDPing(): CDOTAUserMsgCoachHUDPing {
  return { playerId: -1, hudPing: undefined };
}

export const CDOTAUserMsgCoachHUDPing = {
  encode(message: CDOTAUserMsgCoachHUDPing, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.playerId !== undefined && message.playerId !== -1) {
      writer.uint32(8).int32(message.playerId);
    }
    if (message.hudPing !== undefined) {
      CDOTAMsgCoachHUDPing.encode(message.hudPing, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgCoachHUDPing {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgCoachHUDPing();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.playerId = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.hudPing = CDOTAMsgCoachHUDPing.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgCoachHUDPing {
    return {
      playerId: isSet(object.playerId) ? globalThis.Number(object.playerId) : -1,
      hudPing: isSet(object.hudPing) ? CDOTAMsgCoachHUDPing.fromJSON(object.hudPing) : undefined,
    };
  },

  toJSON(message: CDOTAUserMsgCoachHUDPing): unknown {
    const obj: any = {};
    if (message.playerId !== undefined && message.playerId !== -1) {
      obj.playerId = Math.round(message.playerId);
    }
    if (message.hudPing !== undefined) {
      obj.hudPing = CDOTAMsgCoachHUDPing.toJSON(message.hudPing);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgCoachHUDPing>): CDOTAUserMsgCoachHUDPing {
    return CDOTAUserMsgCoachHUDPing.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgCoachHUDPing>): CDOTAUserMsgCoachHUDPing {
    const message = createBaseCDOTAUserMsgCoachHUDPing();
    message.playerId = object.playerId ?? -1;
    message.hudPing =
      object.hudPing !== undefined && object.hudPing !== null
        ? CDOTAMsgCoachHUDPing.fromPartial(object.hudPing)
        : undefined;
    return message;
  },
};

function createBaseCDOTAUserMsgClientLoadGridNav(): CDOTAUserMsgClientLoadGridNav {
  return {};
}

export const CDOTAUserMsgClientLoadGridNav = {
  encode(_: CDOTAUserMsgClientLoadGridNav, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgClientLoadGridNav {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgClientLoadGridNav();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CDOTAUserMsgClientLoadGridNav {
    return {};
  },

  toJSON(_: CDOTAUserMsgClientLoadGridNav): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgClientLoadGridNav>): CDOTAUserMsgClientLoadGridNav {
    return CDOTAUserMsgClientLoadGridNav.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<CDOTAUserMsgClientLoadGridNav>): CDOTAUserMsgClientLoadGridNav {
    const message = createBaseCDOTAUserMsgClientLoadGridNav();
    return message;
  },
};

function createBaseCDOTAUserMsgTEProjectile(): CDOTAUserMsgTEProjectile {
  return {
    source: 16777215,
    target: 16777215,
    moveSpeed: 0,
    sourceAttachment: 0,
    particleSystemHandle: "0",
    dodgeable: false,
    isAttack: false,
    expireTime: 0,
    maximpacttime: 0,
    colorgemcolor: 0,
    launchTick: 0,
    handle: 0,
    targetLoc: undefined,
    particleCpData: [],
    additionalParticleSystemHandle: "0",
    originalMoveSpeed: 0,
    ability: 16777215,
  };
}

export const CDOTAUserMsgTEProjectile = {
  encode(message: CDOTAUserMsgTEProjectile, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.source !== undefined && message.source !== 16777215) {
      writer.uint32(8).uint32(message.source);
    }
    if (message.target !== undefined && message.target !== 16777215) {
      writer.uint32(16).uint32(message.target);
    }
    if (message.moveSpeed !== undefined && message.moveSpeed !== 0) {
      writer.uint32(24).int32(message.moveSpeed);
    }
    if (message.sourceAttachment !== undefined && message.sourceAttachment !== 0) {
      writer.uint32(32).int32(message.sourceAttachment);
    }
    if (message.particleSystemHandle !== undefined && message.particleSystemHandle !== "0") {
      writer.uint32(40).int64(message.particleSystemHandle);
    }
    if (message.dodgeable !== undefined && message.dodgeable !== false) {
      writer.uint32(48).bool(message.dodgeable);
    }
    if (message.isAttack !== undefined && message.isAttack !== false) {
      writer.uint32(56).bool(message.isAttack);
    }
    if (message.expireTime !== undefined && message.expireTime !== 0) {
      writer.uint32(77).float(message.expireTime);
    }
    if (message.maximpacttime !== undefined && message.maximpacttime !== 0) {
      writer.uint32(85).float(message.maximpacttime);
    }
    if (message.colorgemcolor !== undefined && message.colorgemcolor !== 0) {
      writer.uint32(93).fixed32(message.colorgemcolor);
    }
    if (message.launchTick !== undefined && message.launchTick !== 0) {
      writer.uint32(96).int32(message.launchTick);
    }
    if (message.handle !== undefined && message.handle !== 0) {
      writer.uint32(104).int32(message.handle);
    }
    if (message.targetLoc !== undefined) {
      CMsgVector.encode(message.targetLoc, writer.uint32(114).fork()).ldelim();
    }
    for (const v of message.particleCpData) {
      CDOTAUserMsgProjectileParticleCPData.encode(v!, writer.uint32(122).fork()).ldelim();
    }
    if (message.additionalParticleSystemHandle !== undefined && message.additionalParticleSystemHandle !== "0") {
      writer.uint32(128).int64(message.additionalParticleSystemHandle);
    }
    if (message.originalMoveSpeed !== undefined && message.originalMoveSpeed !== 0) {
      writer.uint32(136).int32(message.originalMoveSpeed);
    }
    if (message.ability !== undefined && message.ability !== 16777215) {
      writer.uint32(144).uint32(message.ability);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgTEProjectile {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgTEProjectile();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.source = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.target = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.moveSpeed = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.sourceAttachment = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.particleSystemHandle = longToString(reader.int64() as Long);
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.dodgeable = reader.bool();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.isAttack = reader.bool();
          continue;
        case 9:
          if (tag !== 77) {
            break;
          }

          message.expireTime = reader.float();
          continue;
        case 10:
          if (tag !== 85) {
            break;
          }

          message.maximpacttime = reader.float();
          continue;
        case 11:
          if (tag !== 93) {
            break;
          }

          message.colorgemcolor = reader.fixed32();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.launchTick = reader.int32();
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.handle = reader.int32();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.targetLoc = CMsgVector.decode(reader, reader.uint32());
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.particleCpData.push(CDOTAUserMsgProjectileParticleCPData.decode(reader, reader.uint32()));
          continue;
        case 16:
          if (tag !== 128) {
            break;
          }

          message.additionalParticleSystemHandle = longToString(reader.int64() as Long);
          continue;
        case 17:
          if (tag !== 136) {
            break;
          }

          message.originalMoveSpeed = reader.int32();
          continue;
        case 18:
          if (tag !== 144) {
            break;
          }

          message.ability = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgTEProjectile {
    return {
      source: isSet(object.source) ? globalThis.Number(object.source) : 16777215,
      target: isSet(object.target) ? globalThis.Number(object.target) : 16777215,
      moveSpeed: isSet(object.moveSpeed) ? globalThis.Number(object.moveSpeed) : 0,
      sourceAttachment: isSet(object.sourceAttachment) ? globalThis.Number(object.sourceAttachment) : 0,
      particleSystemHandle: isSet(object.particleSystemHandle) ? globalThis.String(object.particleSystemHandle) : "0",
      dodgeable: isSet(object.dodgeable) ? globalThis.Boolean(object.dodgeable) : false,
      isAttack: isSet(object.isAttack) ? globalThis.Boolean(object.isAttack) : false,
      expireTime: isSet(object.expireTime) ? globalThis.Number(object.expireTime) : 0,
      maximpacttime: isSet(object.maximpacttime) ? globalThis.Number(object.maximpacttime) : 0,
      colorgemcolor: isSet(object.colorgemcolor) ? globalThis.Number(object.colorgemcolor) : 0,
      launchTick: isSet(object.launchTick) ? globalThis.Number(object.launchTick) : 0,
      handle: isSet(object.handle) ? globalThis.Number(object.handle) : 0,
      targetLoc: isSet(object.targetLoc) ? CMsgVector.fromJSON(object.targetLoc) : undefined,
      particleCpData: globalThis.Array.isArray(object?.particleCpData)
        ? object.particleCpData.map((e: any) => CDOTAUserMsgProjectileParticleCPData.fromJSON(e))
        : [],
      additionalParticleSystemHandle: isSet(object.additionalParticleSystemHandle)
        ? globalThis.String(object.additionalParticleSystemHandle)
        : "0",
      originalMoveSpeed: isSet(object.originalMoveSpeed) ? globalThis.Number(object.originalMoveSpeed) : 0,
      ability: isSet(object.ability) ? globalThis.Number(object.ability) : 16777215,
    };
  },

  toJSON(message: CDOTAUserMsgTEProjectile): unknown {
    const obj: any = {};
    if (message.source !== undefined && message.source !== 16777215) {
      obj.source = Math.round(message.source);
    }
    if (message.target !== undefined && message.target !== 16777215) {
      obj.target = Math.round(message.target);
    }
    if (message.moveSpeed !== undefined && message.moveSpeed !== 0) {
      obj.moveSpeed = Math.round(message.moveSpeed);
    }
    if (message.sourceAttachment !== undefined && message.sourceAttachment !== 0) {
      obj.sourceAttachment = Math.round(message.sourceAttachment);
    }
    if (message.particleSystemHandle !== undefined && message.particleSystemHandle !== "0") {
      obj.particleSystemHandle = message.particleSystemHandle;
    }
    if (message.dodgeable !== undefined && message.dodgeable !== false) {
      obj.dodgeable = message.dodgeable;
    }
    if (message.isAttack !== undefined && message.isAttack !== false) {
      obj.isAttack = message.isAttack;
    }
    if (message.expireTime !== undefined && message.expireTime !== 0) {
      obj.expireTime = message.expireTime;
    }
    if (message.maximpacttime !== undefined && message.maximpacttime !== 0) {
      obj.maximpacttime = message.maximpacttime;
    }
    if (message.colorgemcolor !== undefined && message.colorgemcolor !== 0) {
      obj.colorgemcolor = Math.round(message.colorgemcolor);
    }
    if (message.launchTick !== undefined && message.launchTick !== 0) {
      obj.launchTick = Math.round(message.launchTick);
    }
    if (message.handle !== undefined && message.handle !== 0) {
      obj.handle = Math.round(message.handle);
    }
    if (message.targetLoc !== undefined) {
      obj.targetLoc = CMsgVector.toJSON(message.targetLoc);
    }
    if (message.particleCpData?.length) {
      obj.particleCpData = message.particleCpData.map((e) => CDOTAUserMsgProjectileParticleCPData.toJSON(e));
    }
    if (message.additionalParticleSystemHandle !== undefined && message.additionalParticleSystemHandle !== "0") {
      obj.additionalParticleSystemHandle = message.additionalParticleSystemHandle;
    }
    if (message.originalMoveSpeed !== undefined && message.originalMoveSpeed !== 0) {
      obj.originalMoveSpeed = Math.round(message.originalMoveSpeed);
    }
    if (message.ability !== undefined && message.ability !== 16777215) {
      obj.ability = Math.round(message.ability);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgTEProjectile>): CDOTAUserMsgTEProjectile {
    return CDOTAUserMsgTEProjectile.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgTEProjectile>): CDOTAUserMsgTEProjectile {
    const message = createBaseCDOTAUserMsgTEProjectile();
    message.source = object.source ?? 16777215;
    message.target = object.target ?? 16777215;
    message.moveSpeed = object.moveSpeed ?? 0;
    message.sourceAttachment = object.sourceAttachment ?? 0;
    message.particleSystemHandle = object.particleSystemHandle ?? "0";
    message.dodgeable = object.dodgeable ?? false;
    message.isAttack = object.isAttack ?? false;
    message.expireTime = object.expireTime ?? 0;
    message.maximpacttime = object.maximpacttime ?? 0;
    message.colorgemcolor = object.colorgemcolor ?? 0;
    message.launchTick = object.launchTick ?? 0;
    message.handle = object.handle ?? 0;
    message.targetLoc =
      object.targetLoc !== undefined && object.targetLoc !== null
        ? CMsgVector.fromPartial(object.targetLoc)
        : undefined;
    message.particleCpData =
      object.particleCpData?.map((e) => CDOTAUserMsgProjectileParticleCPData.fromPartial(e)) || [];
    message.additionalParticleSystemHandle = object.additionalParticleSystemHandle ?? "0";
    message.originalMoveSpeed = object.originalMoveSpeed ?? 0;
    message.ability = object.ability ?? 16777215;
    return message;
  },
};

function createBaseCDOTAUserMsgTEProjectileLoc(): CDOTAUserMsgTEProjectileLoc {
  return {
    sourceLoc: undefined,
    target: 16777215,
    moveSpeed: 0,
    particleSystemHandle: "0",
    dodgeable: false,
    isAttack: false,
    expireTime: 0,
    targetLoc: undefined,
    colorgemcolor: 0,
    launchTick: 0,
    handle: 0,
    source: 16777215,
    sourceAttachment: 0,
    particleCpData: [],
    additionalParticleSystemHandle: "0",
    originalMoveSpeed: 0,
  };
}

export const CDOTAUserMsgTEProjectileLoc = {
  encode(message: CDOTAUserMsgTEProjectileLoc, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sourceLoc !== undefined) {
      CMsgVector.encode(message.sourceLoc, writer.uint32(10).fork()).ldelim();
    }
    if (message.target !== undefined && message.target !== 16777215) {
      writer.uint32(16).uint32(message.target);
    }
    if (message.moveSpeed !== undefined && message.moveSpeed !== 0) {
      writer.uint32(24).int32(message.moveSpeed);
    }
    if (message.particleSystemHandle !== undefined && message.particleSystemHandle !== "0") {
      writer.uint32(32).int64(message.particleSystemHandle);
    }
    if (message.dodgeable !== undefined && message.dodgeable !== false) {
      writer.uint32(40).bool(message.dodgeable);
    }
    if (message.isAttack !== undefined && message.isAttack !== false) {
      writer.uint32(48).bool(message.isAttack);
    }
    if (message.expireTime !== undefined && message.expireTime !== 0) {
      writer.uint32(77).float(message.expireTime);
    }
    if (message.targetLoc !== undefined) {
      CMsgVector.encode(message.targetLoc, writer.uint32(82).fork()).ldelim();
    }
    if (message.colorgemcolor !== undefined && message.colorgemcolor !== 0) {
      writer.uint32(93).fixed32(message.colorgemcolor);
    }
    if (message.launchTick !== undefined && message.launchTick !== 0) {
      writer.uint32(96).int32(message.launchTick);
    }
    if (message.handle !== undefined && message.handle !== 0) {
      writer.uint32(104).int32(message.handle);
    }
    if (message.source !== undefined && message.source !== 16777215) {
      writer.uint32(112).uint32(message.source);
    }
    if (message.sourceAttachment !== undefined && message.sourceAttachment !== 0) {
      writer.uint32(120).int32(message.sourceAttachment);
    }
    for (const v of message.particleCpData) {
      CDOTAUserMsgProjectileParticleCPData.encode(v!, writer.uint32(130).fork()).ldelim();
    }
    if (message.additionalParticleSystemHandle !== undefined && message.additionalParticleSystemHandle !== "0") {
      writer.uint32(136).int64(message.additionalParticleSystemHandle);
    }
    if (message.originalMoveSpeed !== undefined && message.originalMoveSpeed !== 0) {
      writer.uint32(144).int32(message.originalMoveSpeed);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgTEProjectileLoc {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgTEProjectileLoc();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sourceLoc = CMsgVector.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.target = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.moveSpeed = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.particleSystemHandle = longToString(reader.int64() as Long);
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.dodgeable = reader.bool();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.isAttack = reader.bool();
          continue;
        case 9:
          if (tag !== 77) {
            break;
          }

          message.expireTime = reader.float();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.targetLoc = CMsgVector.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 93) {
            break;
          }

          message.colorgemcolor = reader.fixed32();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.launchTick = reader.int32();
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.handle = reader.int32();
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.source = reader.uint32();
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.sourceAttachment = reader.int32();
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.particleCpData.push(CDOTAUserMsgProjectileParticleCPData.decode(reader, reader.uint32()));
          continue;
        case 17:
          if (tag !== 136) {
            break;
          }

          message.additionalParticleSystemHandle = longToString(reader.int64() as Long);
          continue;
        case 18:
          if (tag !== 144) {
            break;
          }

          message.originalMoveSpeed = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgTEProjectileLoc {
    return {
      sourceLoc: isSet(object.sourceLoc) ? CMsgVector.fromJSON(object.sourceLoc) : undefined,
      target: isSet(object.target) ? globalThis.Number(object.target) : 16777215,
      moveSpeed: isSet(object.moveSpeed) ? globalThis.Number(object.moveSpeed) : 0,
      particleSystemHandle: isSet(object.particleSystemHandle) ? globalThis.String(object.particleSystemHandle) : "0",
      dodgeable: isSet(object.dodgeable) ? globalThis.Boolean(object.dodgeable) : false,
      isAttack: isSet(object.isAttack) ? globalThis.Boolean(object.isAttack) : false,
      expireTime: isSet(object.expireTime) ? globalThis.Number(object.expireTime) : 0,
      targetLoc: isSet(object.targetLoc) ? CMsgVector.fromJSON(object.targetLoc) : undefined,
      colorgemcolor: isSet(object.colorgemcolor) ? globalThis.Number(object.colorgemcolor) : 0,
      launchTick: isSet(object.launchTick) ? globalThis.Number(object.launchTick) : 0,
      handle: isSet(object.handle) ? globalThis.Number(object.handle) : 0,
      source: isSet(object.source) ? globalThis.Number(object.source) : 16777215,
      sourceAttachment: isSet(object.sourceAttachment) ? globalThis.Number(object.sourceAttachment) : 0,
      particleCpData: globalThis.Array.isArray(object?.particleCpData)
        ? object.particleCpData.map((e: any) => CDOTAUserMsgProjectileParticleCPData.fromJSON(e))
        : [],
      additionalParticleSystemHandle: isSet(object.additionalParticleSystemHandle)
        ? globalThis.String(object.additionalParticleSystemHandle)
        : "0",
      originalMoveSpeed: isSet(object.originalMoveSpeed) ? globalThis.Number(object.originalMoveSpeed) : 0,
    };
  },

  toJSON(message: CDOTAUserMsgTEProjectileLoc): unknown {
    const obj: any = {};
    if (message.sourceLoc !== undefined) {
      obj.sourceLoc = CMsgVector.toJSON(message.sourceLoc);
    }
    if (message.target !== undefined && message.target !== 16777215) {
      obj.target = Math.round(message.target);
    }
    if (message.moveSpeed !== undefined && message.moveSpeed !== 0) {
      obj.moveSpeed = Math.round(message.moveSpeed);
    }
    if (message.particleSystemHandle !== undefined && message.particleSystemHandle !== "0") {
      obj.particleSystemHandle = message.particleSystemHandle;
    }
    if (message.dodgeable !== undefined && message.dodgeable !== false) {
      obj.dodgeable = message.dodgeable;
    }
    if (message.isAttack !== undefined && message.isAttack !== false) {
      obj.isAttack = message.isAttack;
    }
    if (message.expireTime !== undefined && message.expireTime !== 0) {
      obj.expireTime = message.expireTime;
    }
    if (message.targetLoc !== undefined) {
      obj.targetLoc = CMsgVector.toJSON(message.targetLoc);
    }
    if (message.colorgemcolor !== undefined && message.colorgemcolor !== 0) {
      obj.colorgemcolor = Math.round(message.colorgemcolor);
    }
    if (message.launchTick !== undefined && message.launchTick !== 0) {
      obj.launchTick = Math.round(message.launchTick);
    }
    if (message.handle !== undefined && message.handle !== 0) {
      obj.handle = Math.round(message.handle);
    }
    if (message.source !== undefined && message.source !== 16777215) {
      obj.source = Math.round(message.source);
    }
    if (message.sourceAttachment !== undefined && message.sourceAttachment !== 0) {
      obj.sourceAttachment = Math.round(message.sourceAttachment);
    }
    if (message.particleCpData?.length) {
      obj.particleCpData = message.particleCpData.map((e) => CDOTAUserMsgProjectileParticleCPData.toJSON(e));
    }
    if (message.additionalParticleSystemHandle !== undefined && message.additionalParticleSystemHandle !== "0") {
      obj.additionalParticleSystemHandle = message.additionalParticleSystemHandle;
    }
    if (message.originalMoveSpeed !== undefined && message.originalMoveSpeed !== 0) {
      obj.originalMoveSpeed = Math.round(message.originalMoveSpeed);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgTEProjectileLoc>): CDOTAUserMsgTEProjectileLoc {
    return CDOTAUserMsgTEProjectileLoc.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgTEProjectileLoc>): CDOTAUserMsgTEProjectileLoc {
    const message = createBaseCDOTAUserMsgTEProjectileLoc();
    message.sourceLoc =
      object.sourceLoc !== undefined && object.sourceLoc !== null
        ? CMsgVector.fromPartial(object.sourceLoc)
        : undefined;
    message.target = object.target ?? 16777215;
    message.moveSpeed = object.moveSpeed ?? 0;
    message.particleSystemHandle = object.particleSystemHandle ?? "0";
    message.dodgeable = object.dodgeable ?? false;
    message.isAttack = object.isAttack ?? false;
    message.expireTime = object.expireTime ?? 0;
    message.targetLoc =
      object.targetLoc !== undefined && object.targetLoc !== null
        ? CMsgVector.fromPartial(object.targetLoc)
        : undefined;
    message.colorgemcolor = object.colorgemcolor ?? 0;
    message.launchTick = object.launchTick ?? 0;
    message.handle = object.handle ?? 0;
    message.source = object.source ?? 16777215;
    message.sourceAttachment = object.sourceAttachment ?? 0;
    message.particleCpData =
      object.particleCpData?.map((e) => CDOTAUserMsgProjectileParticleCPData.fromPartial(e)) || [];
    message.additionalParticleSystemHandle = object.additionalParticleSystemHandle ?? "0";
    message.originalMoveSpeed = object.originalMoveSpeed ?? 0;
    return message;
  },
};

function createBaseCDOTAUserMsgTEDestroyProjectile(): CDOTAUserMsgTEDestroyProjectile {
  return { handle: 0 };
}

export const CDOTAUserMsgTEDestroyProjectile = {
  encode(message: CDOTAUserMsgTEDestroyProjectile, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.handle !== undefined && message.handle !== 0) {
      writer.uint32(8).int32(message.handle);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgTEDestroyProjectile {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgTEDestroyProjectile();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.handle = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgTEDestroyProjectile {
    return { handle: isSet(object.handle) ? globalThis.Number(object.handle) : 0 };
  },

  toJSON(message: CDOTAUserMsgTEDestroyProjectile): unknown {
    const obj: any = {};
    if (message.handle !== undefined && message.handle !== 0) {
      obj.handle = Math.round(message.handle);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgTEDestroyProjectile>): CDOTAUserMsgTEDestroyProjectile {
    return CDOTAUserMsgTEDestroyProjectile.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgTEDestroyProjectile>): CDOTAUserMsgTEDestroyProjectile {
    const message = createBaseCDOTAUserMsgTEDestroyProjectile();
    message.handle = object.handle ?? 0;
    return message;
  },
};

function createBaseCDOTAUserMsgTEDotaBloodImpact(): CDOTAUserMsgTEDotaBloodImpact {
  return { entity: 16777215, scale: 0, xnormal: 0, ynormal: 0 };
}

export const CDOTAUserMsgTEDotaBloodImpact = {
  encode(message: CDOTAUserMsgTEDotaBloodImpact, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.entity !== undefined && message.entity !== 16777215) {
      writer.uint32(8).uint32(message.entity);
    }
    if (message.scale !== undefined && message.scale !== 0) {
      writer.uint32(21).float(message.scale);
    }
    if (message.xnormal !== undefined && message.xnormal !== 0) {
      writer.uint32(29).float(message.xnormal);
    }
    if (message.ynormal !== undefined && message.ynormal !== 0) {
      writer.uint32(37).float(message.ynormal);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgTEDotaBloodImpact {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgTEDotaBloodImpact();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.entity = reader.uint32();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.scale = reader.float();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.xnormal = reader.float();
          continue;
        case 4:
          if (tag !== 37) {
            break;
          }

          message.ynormal = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgTEDotaBloodImpact {
    return {
      entity: isSet(object.entity) ? globalThis.Number(object.entity) : 16777215,
      scale: isSet(object.scale) ? globalThis.Number(object.scale) : 0,
      xnormal: isSet(object.xnormal) ? globalThis.Number(object.xnormal) : 0,
      ynormal: isSet(object.ynormal) ? globalThis.Number(object.ynormal) : 0,
    };
  },

  toJSON(message: CDOTAUserMsgTEDotaBloodImpact): unknown {
    const obj: any = {};
    if (message.entity !== undefined && message.entity !== 16777215) {
      obj.entity = Math.round(message.entity);
    }
    if (message.scale !== undefined && message.scale !== 0) {
      obj.scale = message.scale;
    }
    if (message.xnormal !== undefined && message.xnormal !== 0) {
      obj.xnormal = message.xnormal;
    }
    if (message.ynormal !== undefined && message.ynormal !== 0) {
      obj.ynormal = message.ynormal;
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgTEDotaBloodImpact>): CDOTAUserMsgTEDotaBloodImpact {
    return CDOTAUserMsgTEDotaBloodImpact.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgTEDotaBloodImpact>): CDOTAUserMsgTEDotaBloodImpact {
    const message = createBaseCDOTAUserMsgTEDotaBloodImpact();
    message.entity = object.entity ?? 16777215;
    message.scale = object.scale ?? 0;
    message.xnormal = object.xnormal ?? 0;
    message.ynormal = object.ynormal ?? 0;
    return message;
  },
};

function createBaseCDOTAUserMsgAbilityPing(): CDOTAUserMsgAbilityPing {
  return {
    playerId: -1,
    abilityId: -1,
    type: 1,
    cooldownSeconds: 0,
    level: 0,
    passive: false,
    manaNeeded: 0,
    entityId: 0,
    primaryCharges: 0,
    secondaryCharges: 0,
    ctrlHeld: false,
    reclaimTime: 0,
    ownerEntity: -1,
  };
}

export const CDOTAUserMsgAbilityPing = {
  encode(message: CDOTAUserMsgAbilityPing, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.playerId !== undefined && message.playerId !== -1) {
      writer.uint32(8).int32(message.playerId);
    }
    if (message.abilityId !== undefined && message.abilityId !== -1) {
      writer.uint32(16).int32(message.abilityId);
    }
    if (message.type !== undefined && message.type !== 1) {
      writer.uint32(24).int32(message.type);
    }
    if (message.cooldownSeconds !== undefined && message.cooldownSeconds !== 0) {
      writer.uint32(32).uint32(message.cooldownSeconds);
    }
    if (message.level !== undefined && message.level !== 0) {
      writer.uint32(40).uint32(message.level);
    }
    if (message.passive !== undefined && message.passive !== false) {
      writer.uint32(48).bool(message.passive);
    }
    if (message.manaNeeded !== undefined && message.manaNeeded !== 0) {
      writer.uint32(56).uint32(message.manaNeeded);
    }
    if (message.entityId !== undefined && message.entityId !== 0) {
      writer.uint32(64).uint32(message.entityId);
    }
    if (message.primaryCharges !== undefined && message.primaryCharges !== 0) {
      writer.uint32(72).int32(message.primaryCharges);
    }
    if (message.secondaryCharges !== undefined && message.secondaryCharges !== 0) {
      writer.uint32(80).int32(message.secondaryCharges);
    }
    if (message.ctrlHeld !== undefined && message.ctrlHeld !== false) {
      writer.uint32(96).bool(message.ctrlHeld);
    }
    if (message.reclaimTime !== undefined && message.reclaimTime !== 0) {
      writer.uint32(109).float(message.reclaimTime);
    }
    if (message.ownerEntity !== undefined && message.ownerEntity !== -1) {
      writer.uint32(112).int32(message.ownerEntity);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgAbilityPing {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgAbilityPing();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.playerId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.abilityId = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.cooldownSeconds = reader.uint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.level = reader.uint32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.passive = reader.bool();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.manaNeeded = reader.uint32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.entityId = reader.uint32();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.primaryCharges = reader.int32();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.secondaryCharges = reader.int32();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.ctrlHeld = reader.bool();
          continue;
        case 13:
          if (tag !== 109) {
            break;
          }

          message.reclaimTime = reader.float();
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.ownerEntity = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgAbilityPing {
    return {
      playerId: isSet(object.playerId) ? globalThis.Number(object.playerId) : -1,
      abilityId: isSet(object.abilityId) ? globalThis.Number(object.abilityId) : -1,
      type: isSet(object.type) ? dotaAbilityPingTypeFromJSON(object.type) : 1,
      cooldownSeconds: isSet(object.cooldownSeconds) ? globalThis.Number(object.cooldownSeconds) : 0,
      level: isSet(object.level) ? globalThis.Number(object.level) : 0,
      passive: isSet(object.passive) ? globalThis.Boolean(object.passive) : false,
      manaNeeded: isSet(object.manaNeeded) ? globalThis.Number(object.manaNeeded) : 0,
      entityId: isSet(object.entityId) ? globalThis.Number(object.entityId) : 0,
      primaryCharges: isSet(object.primaryCharges) ? globalThis.Number(object.primaryCharges) : 0,
      secondaryCharges: isSet(object.secondaryCharges) ? globalThis.Number(object.secondaryCharges) : 0,
      ctrlHeld: isSet(object.ctrlHeld) ? globalThis.Boolean(object.ctrlHeld) : false,
      reclaimTime: isSet(object.reclaimTime) ? globalThis.Number(object.reclaimTime) : 0,
      ownerEntity: isSet(object.ownerEntity) ? globalThis.Number(object.ownerEntity) : -1,
    };
  },

  toJSON(message: CDOTAUserMsgAbilityPing): unknown {
    const obj: any = {};
    if (message.playerId !== undefined && message.playerId !== -1) {
      obj.playerId = Math.round(message.playerId);
    }
    if (message.abilityId !== undefined && message.abilityId !== -1) {
      obj.abilityId = Math.round(message.abilityId);
    }
    if (message.type !== undefined && message.type !== 1) {
      obj.type = dotaAbilityPingTypeToJSON(message.type);
    }
    if (message.cooldownSeconds !== undefined && message.cooldownSeconds !== 0) {
      obj.cooldownSeconds = Math.round(message.cooldownSeconds);
    }
    if (message.level !== undefined && message.level !== 0) {
      obj.level = Math.round(message.level);
    }
    if (message.passive !== undefined && message.passive !== false) {
      obj.passive = message.passive;
    }
    if (message.manaNeeded !== undefined && message.manaNeeded !== 0) {
      obj.manaNeeded = Math.round(message.manaNeeded);
    }
    if (message.entityId !== undefined && message.entityId !== 0) {
      obj.entityId = Math.round(message.entityId);
    }
    if (message.primaryCharges !== undefined && message.primaryCharges !== 0) {
      obj.primaryCharges = Math.round(message.primaryCharges);
    }
    if (message.secondaryCharges !== undefined && message.secondaryCharges !== 0) {
      obj.secondaryCharges = Math.round(message.secondaryCharges);
    }
    if (message.ctrlHeld !== undefined && message.ctrlHeld !== false) {
      obj.ctrlHeld = message.ctrlHeld;
    }
    if (message.reclaimTime !== undefined && message.reclaimTime !== 0) {
      obj.reclaimTime = message.reclaimTime;
    }
    if (message.ownerEntity !== undefined && message.ownerEntity !== -1) {
      obj.ownerEntity = Math.round(message.ownerEntity);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgAbilityPing>): CDOTAUserMsgAbilityPing {
    return CDOTAUserMsgAbilityPing.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgAbilityPing>): CDOTAUserMsgAbilityPing {
    const message = createBaseCDOTAUserMsgAbilityPing();
    message.playerId = object.playerId ?? -1;
    message.abilityId = object.abilityId ?? -1;
    message.type = object.type ?? 1;
    message.cooldownSeconds = object.cooldownSeconds ?? 0;
    message.level = object.level ?? 0;
    message.passive = object.passive ?? false;
    message.manaNeeded = object.manaNeeded ?? 0;
    message.entityId = object.entityId ?? 0;
    message.primaryCharges = object.primaryCharges ?? 0;
    message.secondaryCharges = object.secondaryCharges ?? 0;
    message.ctrlHeld = object.ctrlHeld ?? false;
    message.reclaimTime = object.reclaimTime ?? 0;
    message.ownerEntity = object.ownerEntity ?? -1;
    return message;
  },
};

function createBaseCDOTAUserMsgTEUnitAnimation(): CDOTAUserMsgTEUnitAnimation {
  return {
    entity: 16777215,
    sequenceVariant: 0,
    playbackrate: 0,
    castpoint: 0,
    type: 0,
    activity: 0,
    lagCompensationTime: 0,
  };
}

export const CDOTAUserMsgTEUnitAnimation = {
  encode(message: CDOTAUserMsgTEUnitAnimation, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.entity !== undefined && message.entity !== 16777215) {
      writer.uint32(8).uint32(message.entity);
    }
    if (message.sequenceVariant !== undefined && message.sequenceVariant !== 0) {
      writer.uint32(16).int32(message.sequenceVariant);
    }
    if (message.playbackrate !== undefined && message.playbackrate !== 0) {
      writer.uint32(29).float(message.playbackrate);
    }
    if (message.castpoint !== undefined && message.castpoint !== 0) {
      writer.uint32(37).float(message.castpoint);
    }
    if (message.type !== undefined && message.type !== 0) {
      writer.uint32(40).int32(message.type);
    }
    if (message.activity !== undefined && message.activity !== 0) {
      writer.uint32(48).int32(message.activity);
    }
    if (message.lagCompensationTime !== undefined && message.lagCompensationTime !== 0) {
      writer.uint32(61).float(message.lagCompensationTime);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgTEUnitAnimation {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgTEUnitAnimation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.entity = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.sequenceVariant = reader.int32();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.playbackrate = reader.float();
          continue;
        case 4:
          if (tag !== 37) {
            break;
          }

          message.castpoint = reader.float();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.type = reader.int32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.activity = reader.int32();
          continue;
        case 7:
          if (tag !== 61) {
            break;
          }

          message.lagCompensationTime = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgTEUnitAnimation {
    return {
      entity: isSet(object.entity) ? globalThis.Number(object.entity) : 16777215,
      sequenceVariant: isSet(object.sequenceVariant) ? globalThis.Number(object.sequenceVariant) : 0,
      playbackrate: isSet(object.playbackrate) ? globalThis.Number(object.playbackrate) : 0,
      castpoint: isSet(object.castpoint) ? globalThis.Number(object.castpoint) : 0,
      type: isSet(object.type) ? globalThis.Number(object.type) : 0,
      activity: isSet(object.activity) ? globalThis.Number(object.activity) : 0,
      lagCompensationTime: isSet(object.lagCompensationTime) ? globalThis.Number(object.lagCompensationTime) : 0,
    };
  },

  toJSON(message: CDOTAUserMsgTEUnitAnimation): unknown {
    const obj: any = {};
    if (message.entity !== undefined && message.entity !== 16777215) {
      obj.entity = Math.round(message.entity);
    }
    if (message.sequenceVariant !== undefined && message.sequenceVariant !== 0) {
      obj.sequenceVariant = Math.round(message.sequenceVariant);
    }
    if (message.playbackrate !== undefined && message.playbackrate !== 0) {
      obj.playbackrate = message.playbackrate;
    }
    if (message.castpoint !== undefined && message.castpoint !== 0) {
      obj.castpoint = message.castpoint;
    }
    if (message.type !== undefined && message.type !== 0) {
      obj.type = Math.round(message.type);
    }
    if (message.activity !== undefined && message.activity !== 0) {
      obj.activity = Math.round(message.activity);
    }
    if (message.lagCompensationTime !== undefined && message.lagCompensationTime !== 0) {
      obj.lagCompensationTime = message.lagCompensationTime;
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgTEUnitAnimation>): CDOTAUserMsgTEUnitAnimation {
    return CDOTAUserMsgTEUnitAnimation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgTEUnitAnimation>): CDOTAUserMsgTEUnitAnimation {
    const message = createBaseCDOTAUserMsgTEUnitAnimation();
    message.entity = object.entity ?? 16777215;
    message.sequenceVariant = object.sequenceVariant ?? 0;
    message.playbackrate = object.playbackrate ?? 0;
    message.castpoint = object.castpoint ?? 0;
    message.type = object.type ?? 0;
    message.activity = object.activity ?? 0;
    message.lagCompensationTime = object.lagCompensationTime ?? 0;
    return message;
  },
};

function createBaseCDOTAUserMsgTEUnitAnimationEnd(): CDOTAUserMsgTEUnitAnimationEnd {
  return { entity: 16777215, snap: false };
}

export const CDOTAUserMsgTEUnitAnimationEnd = {
  encode(message: CDOTAUserMsgTEUnitAnimationEnd, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.entity !== undefined && message.entity !== 16777215) {
      writer.uint32(8).uint32(message.entity);
    }
    if (message.snap !== undefined && message.snap !== false) {
      writer.uint32(16).bool(message.snap);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgTEUnitAnimationEnd {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgTEUnitAnimationEnd();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.entity = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.snap = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgTEUnitAnimationEnd {
    return {
      entity: isSet(object.entity) ? globalThis.Number(object.entity) : 16777215,
      snap: isSet(object.snap) ? globalThis.Boolean(object.snap) : false,
    };
  },

  toJSON(message: CDOTAUserMsgTEUnitAnimationEnd): unknown {
    const obj: any = {};
    if (message.entity !== undefined && message.entity !== 16777215) {
      obj.entity = Math.round(message.entity);
    }
    if (message.snap !== undefined && message.snap !== false) {
      obj.snap = message.snap;
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgTEUnitAnimationEnd>): CDOTAUserMsgTEUnitAnimationEnd {
    return CDOTAUserMsgTEUnitAnimationEnd.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgTEUnitAnimationEnd>): CDOTAUserMsgTEUnitAnimationEnd {
    const message = createBaseCDOTAUserMsgTEUnitAnimationEnd();
    message.entity = object.entity ?? 16777215;
    message.snap = object.snap ?? false;
    return message;
  },
};

function createBaseCDOTAUserMsgShowGenericPopup(): CDOTAUserMsgShowGenericPopup {
  return { header: "", body: "", param1: "", param2: "", tintScreen: false, showNoOtherDialogs: false };
}

export const CDOTAUserMsgShowGenericPopup = {
  encode(message: CDOTAUserMsgShowGenericPopup, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.header !== "") {
      writer.uint32(10).string(message.header);
    }
    if (message.body !== "") {
      writer.uint32(18).string(message.body);
    }
    if (message.param1 !== undefined && message.param1 !== "") {
      writer.uint32(26).string(message.param1);
    }
    if (message.param2 !== undefined && message.param2 !== "") {
      writer.uint32(34).string(message.param2);
    }
    if (message.tintScreen !== undefined && message.tintScreen !== false) {
      writer.uint32(40).bool(message.tintScreen);
    }
    if (message.showNoOtherDialogs !== undefined && message.showNoOtherDialogs !== false) {
      writer.uint32(48).bool(message.showNoOtherDialogs);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgShowGenericPopup {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgShowGenericPopup();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.header = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.body = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.param1 = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.param2 = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.tintScreen = reader.bool();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.showNoOtherDialogs = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgShowGenericPopup {
    return {
      header: isSet(object.header) ? globalThis.String(object.header) : "",
      body: isSet(object.body) ? globalThis.String(object.body) : "",
      param1: isSet(object.param1) ? globalThis.String(object.param1) : "",
      param2: isSet(object.param2) ? globalThis.String(object.param2) : "",
      tintScreen: isSet(object.tintScreen) ? globalThis.Boolean(object.tintScreen) : false,
      showNoOtherDialogs: isSet(object.showNoOtherDialogs) ? globalThis.Boolean(object.showNoOtherDialogs) : false,
    };
  },

  toJSON(message: CDOTAUserMsgShowGenericPopup): unknown {
    const obj: any = {};
    if (message.header !== "") {
      obj.header = message.header;
    }
    if (message.body !== "") {
      obj.body = message.body;
    }
    if (message.param1 !== undefined && message.param1 !== "") {
      obj.param1 = message.param1;
    }
    if (message.param2 !== undefined && message.param2 !== "") {
      obj.param2 = message.param2;
    }
    if (message.tintScreen !== undefined && message.tintScreen !== false) {
      obj.tintScreen = message.tintScreen;
    }
    if (message.showNoOtherDialogs !== undefined && message.showNoOtherDialogs !== false) {
      obj.showNoOtherDialogs = message.showNoOtherDialogs;
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgShowGenericPopup>): CDOTAUserMsgShowGenericPopup {
    return CDOTAUserMsgShowGenericPopup.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgShowGenericPopup>): CDOTAUserMsgShowGenericPopup {
    const message = createBaseCDOTAUserMsgShowGenericPopup();
    message.header = object.header ?? "";
    message.body = object.body ?? "";
    message.param1 = object.param1 ?? "";
    message.param2 = object.param2 ?? "";
    message.tintScreen = object.tintScreen ?? false;
    message.showNoOtherDialogs = object.showNoOtherDialogs ?? false;
    return message;
  },
};

function createBaseCDOTAUserMsgVoteStart(): CDOTAUserMsgVoteStart {
  return { title: "", duration: 0, choiceCount: 0, choices: [] };
}

export const CDOTAUserMsgVoteStart = {
  encode(message: CDOTAUserMsgVoteStart, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.title !== undefined && message.title !== "") {
      writer.uint32(10).string(message.title);
    }
    if (message.duration !== undefined && message.duration !== 0) {
      writer.uint32(21).float(message.duration);
    }
    if (message.choiceCount !== undefined && message.choiceCount !== 0) {
      writer.uint32(24).int32(message.choiceCount);
    }
    for (const v of message.choices) {
      writer.uint32(34).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgVoteStart {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgVoteStart();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.title = reader.string();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.duration = reader.float();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.choiceCount = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.choices.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgVoteStart {
    return {
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      duration: isSet(object.duration) ? globalThis.Number(object.duration) : 0,
      choiceCount: isSet(object.choiceCount) ? globalThis.Number(object.choiceCount) : 0,
      choices: globalThis.Array.isArray(object?.choices) ? object.choices.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: CDOTAUserMsgVoteStart): unknown {
    const obj: any = {};
    if (message.title !== undefined && message.title !== "") {
      obj.title = message.title;
    }
    if (message.duration !== undefined && message.duration !== 0) {
      obj.duration = message.duration;
    }
    if (message.choiceCount !== undefined && message.choiceCount !== 0) {
      obj.choiceCount = Math.round(message.choiceCount);
    }
    if (message.choices?.length) {
      obj.choices = message.choices;
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgVoteStart>): CDOTAUserMsgVoteStart {
    return CDOTAUserMsgVoteStart.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgVoteStart>): CDOTAUserMsgVoteStart {
    const message = createBaseCDOTAUserMsgVoteStart();
    message.title = object.title ?? "";
    message.duration = object.duration ?? 0;
    message.choiceCount = object.choiceCount ?? 0;
    message.choices = object.choices?.map((e) => e) || [];
    return message;
  },
};

function createBaseCDOTAUserMsgVoteUpdate(): CDOTAUserMsgVoteUpdate {
  return { choiceCounts: [] };
}

export const CDOTAUserMsgVoteUpdate = {
  encode(message: CDOTAUserMsgVoteUpdate, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.choiceCounts) {
      writer.int32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgVoteUpdate {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgVoteUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.choiceCounts.push(reader.int32());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.choiceCounts.push(reader.int32());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgVoteUpdate {
    return {
      choiceCounts: globalThis.Array.isArray(object?.choiceCounts)
        ? object.choiceCounts.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: CDOTAUserMsgVoteUpdate): unknown {
    const obj: any = {};
    if (message.choiceCounts?.length) {
      obj.choiceCounts = message.choiceCounts.map((e) => Math.round(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgVoteUpdate>): CDOTAUserMsgVoteUpdate {
    return CDOTAUserMsgVoteUpdate.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgVoteUpdate>): CDOTAUserMsgVoteUpdate {
    const message = createBaseCDOTAUserMsgVoteUpdate();
    message.choiceCounts = object.choiceCounts?.map((e) => e) || [];
    return message;
  },
};

function createBaseCDOTAUserMsgVoteEnd(): CDOTAUserMsgVoteEnd {
  return { selectedChoice: 0 };
}

export const CDOTAUserMsgVoteEnd = {
  encode(message: CDOTAUserMsgVoteEnd, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.selectedChoice !== undefined && message.selectedChoice !== 0) {
      writer.uint32(8).int32(message.selectedChoice);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgVoteEnd {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgVoteEnd();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.selectedChoice = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgVoteEnd {
    return { selectedChoice: isSet(object.selectedChoice) ? globalThis.Number(object.selectedChoice) : 0 };
  },

  toJSON(message: CDOTAUserMsgVoteEnd): unknown {
    const obj: any = {};
    if (message.selectedChoice !== undefined && message.selectedChoice !== 0) {
      obj.selectedChoice = Math.round(message.selectedChoice);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgVoteEnd>): CDOTAUserMsgVoteEnd {
    return CDOTAUserMsgVoteEnd.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgVoteEnd>): CDOTAUserMsgVoteEnd {
    const message = createBaseCDOTAUserMsgVoteEnd();
    message.selectedChoice = object.selectedChoice ?? 0;
    return message;
  },
};

function createBaseCDOTAUserMsgBoosterStatePlayer(): CDOTAUserMsgBoosterStatePlayer {
  return { playerId: -1, bonus: 0, eventBonus: 0, bonusItemId: 0, eventBonusItemId: 0 };
}

export const CDOTAUserMsgBoosterStatePlayer = {
  encode(message: CDOTAUserMsgBoosterStatePlayer, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.playerId !== undefined && message.playerId !== -1) {
      writer.uint32(8).int32(message.playerId);
    }
    if (message.bonus !== undefined && message.bonus !== 0) {
      writer.uint32(21).float(message.bonus);
    }
    if (message.eventBonus !== undefined && message.eventBonus !== 0) {
      writer.uint32(29).float(message.eventBonus);
    }
    if (message.bonusItemId !== undefined && message.bonusItemId !== 0) {
      writer.uint32(32).uint32(message.bonusItemId);
    }
    if (message.eventBonusItemId !== undefined && message.eventBonusItemId !== 0) {
      writer.uint32(40).uint32(message.eventBonusItemId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgBoosterStatePlayer {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgBoosterStatePlayer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.playerId = reader.int32();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.bonus = reader.float();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.eventBonus = reader.float();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.bonusItemId = reader.uint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.eventBonusItemId = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgBoosterStatePlayer {
    return {
      playerId: isSet(object.playerId) ? globalThis.Number(object.playerId) : -1,
      bonus: isSet(object.bonus) ? globalThis.Number(object.bonus) : 0,
      eventBonus: isSet(object.eventBonus) ? globalThis.Number(object.eventBonus) : 0,
      bonusItemId: isSet(object.bonusItemId) ? globalThis.Number(object.bonusItemId) : 0,
      eventBonusItemId: isSet(object.eventBonusItemId) ? globalThis.Number(object.eventBonusItemId) : 0,
    };
  },

  toJSON(message: CDOTAUserMsgBoosterStatePlayer): unknown {
    const obj: any = {};
    if (message.playerId !== undefined && message.playerId !== -1) {
      obj.playerId = Math.round(message.playerId);
    }
    if (message.bonus !== undefined && message.bonus !== 0) {
      obj.bonus = message.bonus;
    }
    if (message.eventBonus !== undefined && message.eventBonus !== 0) {
      obj.eventBonus = message.eventBonus;
    }
    if (message.bonusItemId !== undefined && message.bonusItemId !== 0) {
      obj.bonusItemId = Math.round(message.bonusItemId);
    }
    if (message.eventBonusItemId !== undefined && message.eventBonusItemId !== 0) {
      obj.eventBonusItemId = Math.round(message.eventBonusItemId);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgBoosterStatePlayer>): CDOTAUserMsgBoosterStatePlayer {
    return CDOTAUserMsgBoosterStatePlayer.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgBoosterStatePlayer>): CDOTAUserMsgBoosterStatePlayer {
    const message = createBaseCDOTAUserMsgBoosterStatePlayer();
    message.playerId = object.playerId ?? -1;
    message.bonus = object.bonus ?? 0;
    message.eventBonus = object.eventBonus ?? 0;
    message.bonusItemId = object.bonusItemId ?? 0;
    message.eventBonusItemId = object.eventBonusItemId ?? 0;
    return message;
  },
};

function createBaseCDOTAUserMsgBoosterState(): CDOTAUserMsgBoosterState {
  return { boostedPlayers: [] };
}

export const CDOTAUserMsgBoosterState = {
  encode(message: CDOTAUserMsgBoosterState, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.boostedPlayers) {
      CDOTAUserMsgBoosterStatePlayer.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgBoosterState {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgBoosterState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.boostedPlayers.push(CDOTAUserMsgBoosterStatePlayer.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgBoosterState {
    return {
      boostedPlayers: globalThis.Array.isArray(object?.boostedPlayers)
        ? object.boostedPlayers.map((e: any) => CDOTAUserMsgBoosterStatePlayer.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CDOTAUserMsgBoosterState): unknown {
    const obj: any = {};
    if (message.boostedPlayers?.length) {
      obj.boostedPlayers = message.boostedPlayers.map((e) => CDOTAUserMsgBoosterStatePlayer.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgBoosterState>): CDOTAUserMsgBoosterState {
    return CDOTAUserMsgBoosterState.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgBoosterState>): CDOTAUserMsgBoosterState {
    const message = createBaseCDOTAUserMsgBoosterState();
    message.boostedPlayers = object.boostedPlayers?.map((e) => CDOTAUserMsgBoosterStatePlayer.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCDOTAUserMsgPlayerMMR(): CDOTAUserMsgPlayerMMR {
  return { mmr: [] };
}

export const CDOTAUserMsgPlayerMMR = {
  encode(message: CDOTAUserMsgPlayerMMR, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.mmr) {
      writer.sint32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgPlayerMMR {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgPlayerMMR();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.mmr.push(reader.sint32());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.mmr.push(reader.sint32());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgPlayerMMR {
    return { mmr: globalThis.Array.isArray(object?.mmr) ? object.mmr.map((e: any) => globalThis.Number(e)) : [] };
  },

  toJSON(message: CDOTAUserMsgPlayerMMR): unknown {
    const obj: any = {};
    if (message.mmr?.length) {
      obj.mmr = message.mmr.map((e) => Math.round(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgPlayerMMR>): CDOTAUserMsgPlayerMMR {
    return CDOTAUserMsgPlayerMMR.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgPlayerMMR>): CDOTAUserMsgPlayerMMR {
    const message = createBaseCDOTAUserMsgPlayerMMR();
    message.mmr = object.mmr?.map((e) => e) || [];
    return message;
  },
};

function createBaseCDOTAUserMsgAbilitySteal(): CDOTAUserMsgAbilitySteal {
  return { playerId: -1, abilityId: -1, abilityLevel: 0 };
}

export const CDOTAUserMsgAbilitySteal = {
  encode(message: CDOTAUserMsgAbilitySteal, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.playerId !== undefined && message.playerId !== -1) {
      writer.uint32(8).int32(message.playerId);
    }
    if (message.abilityId !== undefined && message.abilityId !== -1) {
      writer.uint32(16).int32(message.abilityId);
    }
    if (message.abilityLevel !== undefined && message.abilityLevel !== 0) {
      writer.uint32(24).uint32(message.abilityLevel);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgAbilitySteal {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgAbilitySteal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.playerId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.abilityId = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.abilityLevel = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgAbilitySteal {
    return {
      playerId: isSet(object.playerId) ? globalThis.Number(object.playerId) : -1,
      abilityId: isSet(object.abilityId) ? globalThis.Number(object.abilityId) : -1,
      abilityLevel: isSet(object.abilityLevel) ? globalThis.Number(object.abilityLevel) : 0,
    };
  },

  toJSON(message: CDOTAUserMsgAbilitySteal): unknown {
    const obj: any = {};
    if (message.playerId !== undefined && message.playerId !== -1) {
      obj.playerId = Math.round(message.playerId);
    }
    if (message.abilityId !== undefined && message.abilityId !== -1) {
      obj.abilityId = Math.round(message.abilityId);
    }
    if (message.abilityLevel !== undefined && message.abilityLevel !== 0) {
      obj.abilityLevel = Math.round(message.abilityLevel);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgAbilitySteal>): CDOTAUserMsgAbilitySteal {
    return CDOTAUserMsgAbilitySteal.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgAbilitySteal>): CDOTAUserMsgAbilitySteal {
    const message = createBaseCDOTAUserMsgAbilitySteal();
    message.playerId = object.playerId ?? -1;
    message.abilityId = object.abilityId ?? -1;
    message.abilityLevel = object.abilityLevel ?? 0;
    return message;
  },
};

function createBaseCDOTAUserMsgStatsHeroLookup(): CDOTAUserMsgStatsHeroLookup {
  return { playerId: -1, heroId: 0, heroName: "", persona: "" };
}

export const CDOTAUserMsgStatsHeroLookup = {
  encode(message: CDOTAUserMsgStatsHeroLookup, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.playerId !== undefined && message.playerId !== -1) {
      writer.uint32(8).int32(message.playerId);
    }
    if (message.heroId !== undefined && message.heroId !== 0) {
      writer.uint32(16).int32(message.heroId);
    }
    if (message.heroName !== undefined && message.heroName !== "") {
      writer.uint32(26).string(message.heroName);
    }
    if (message.persona !== undefined && message.persona !== "") {
      writer.uint32(34).string(message.persona);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgStatsHeroLookup {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgStatsHeroLookup();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.playerId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.heroId = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.heroName = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.persona = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgStatsHeroLookup {
    return {
      playerId: isSet(object.playerId) ? globalThis.Number(object.playerId) : -1,
      heroId: isSet(object.heroId) ? globalThis.Number(object.heroId) : 0,
      heroName: isSet(object.heroName) ? globalThis.String(object.heroName) : "",
      persona: isSet(object.persona) ? globalThis.String(object.persona) : "",
    };
  },

  toJSON(message: CDOTAUserMsgStatsHeroLookup): unknown {
    const obj: any = {};
    if (message.playerId !== undefined && message.playerId !== -1) {
      obj.playerId = Math.round(message.playerId);
    }
    if (message.heroId !== undefined && message.heroId !== 0) {
      obj.heroId = Math.round(message.heroId);
    }
    if (message.heroName !== undefined && message.heroName !== "") {
      obj.heroName = message.heroName;
    }
    if (message.persona !== undefined && message.persona !== "") {
      obj.persona = message.persona;
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgStatsHeroLookup>): CDOTAUserMsgStatsHeroLookup {
    return CDOTAUserMsgStatsHeroLookup.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgStatsHeroLookup>): CDOTAUserMsgStatsHeroLookup {
    const message = createBaseCDOTAUserMsgStatsHeroLookup();
    message.playerId = object.playerId ?? -1;
    message.heroId = object.heroId ?? 0;
    message.heroName = object.heroName ?? "";
    message.persona = object.persona ?? "";
    return message;
  },
};

function createBaseCDOTAUserMsgStatsHeroPositionInfo(): CDOTAUserMsgStatsHeroPositionInfo {
  return { averagePosition: 0, positionDetails: [] };
}

export const CDOTAUserMsgStatsHeroPositionInfo = {
  encode(message: CDOTAUserMsgStatsHeroPositionInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.averagePosition !== undefined && message.averagePosition !== 0) {
      writer.uint32(13).float(message.averagePosition);
    }
    for (const v of message.positionDetails) {
      CDOTAUserMsgStatsHeroPositionInfo_PositionPair.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgStatsHeroPositionInfo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgStatsHeroPositionInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.averagePosition = reader.float();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.positionDetails.push(CDOTAUserMsgStatsHeroPositionInfo_PositionPair.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgStatsHeroPositionInfo {
    return {
      averagePosition: isSet(object.averagePosition) ? globalThis.Number(object.averagePosition) : 0,
      positionDetails: globalThis.Array.isArray(object?.positionDetails)
        ? object.positionDetails.map((e: any) => CDOTAUserMsgStatsHeroPositionInfo_PositionPair.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CDOTAUserMsgStatsHeroPositionInfo): unknown {
    const obj: any = {};
    if (message.averagePosition !== undefined && message.averagePosition !== 0) {
      obj.averagePosition = message.averagePosition;
    }
    if (message.positionDetails?.length) {
      obj.positionDetails = message.positionDetails.map((e) =>
        CDOTAUserMsgStatsHeroPositionInfo_PositionPair.toJSON(e),
      );
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgStatsHeroPositionInfo>): CDOTAUserMsgStatsHeroPositionInfo {
    return CDOTAUserMsgStatsHeroPositionInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgStatsHeroPositionInfo>): CDOTAUserMsgStatsHeroPositionInfo {
    const message = createBaseCDOTAUserMsgStatsHeroPositionInfo();
    message.averagePosition = object.averagePosition ?? 0;
    message.positionDetails =
      object.positionDetails?.map((e) => CDOTAUserMsgStatsHeroPositionInfo_PositionPair.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCDOTAUserMsgStatsHeroPositionInfo_PositionPair(): CDOTAUserMsgStatsHeroPositionInfo_PositionPair {
  return { positionCategory: 0, positionCount: 0 };
}

export const CDOTAUserMsgStatsHeroPositionInfo_PositionPair = {
  encode(
    message: CDOTAUserMsgStatsHeroPositionInfo_PositionPair,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.positionCategory !== undefined && message.positionCategory !== 0) {
      writer.uint32(8).int32(message.positionCategory);
    }
    if (message.positionCount !== undefined && message.positionCount !== 0) {
      writer.uint32(16).uint32(message.positionCount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgStatsHeroPositionInfo_PositionPair {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgStatsHeroPositionInfo_PositionPair();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.positionCategory = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.positionCount = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgStatsHeroPositionInfo_PositionPair {
    return {
      positionCategory: isSet(object.positionCategory) ? dotaPositionCategoryFromJSON(object.positionCategory) : 0,
      positionCount: isSet(object.positionCount) ? globalThis.Number(object.positionCount) : 0,
    };
  },

  toJSON(message: CDOTAUserMsgStatsHeroPositionInfo_PositionPair): unknown {
    const obj: any = {};
    if (message.positionCategory !== undefined && message.positionCategory !== 0) {
      obj.positionCategory = dotaPositionCategoryToJSON(message.positionCategory);
    }
    if (message.positionCount !== undefined && message.positionCount !== 0) {
      obj.positionCount = Math.round(message.positionCount);
    }
    return obj;
  },

  create(
    base?: DeepPartial<CDOTAUserMsgStatsHeroPositionInfo_PositionPair>,
  ): CDOTAUserMsgStatsHeroPositionInfo_PositionPair {
    return CDOTAUserMsgStatsHeroPositionInfo_PositionPair.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CDOTAUserMsgStatsHeroPositionInfo_PositionPair>,
  ): CDOTAUserMsgStatsHeroPositionInfo_PositionPair {
    const message = createBaseCDOTAUserMsgStatsHeroPositionInfo_PositionPair();
    message.positionCategory = object.positionCategory ?? 0;
    message.positionCount = object.positionCount ?? 0;
    return message;
  },
};

function createBaseCDOTAUserMsgStatsHeroMinuteDetails(): CDOTAUserMsgStatsHeroMinuteDetails {
  return {
    lastHits: 0,
    heroKills: 0,
    heroDamage: 0,
    towerDamage: 0,
    positionInfo: undefined,
    totalXp: 0,
    netWorth: 0,
    harvestedCreepGold: 0,
    claimedFarm: 0,
    wardsPlaced: 0,
    runesCollected: 0,
    tpsUsed: 0,
    manaSpent: [],
    damageAbsorbed: [],
    damageDone: [],
  };
}

export const CDOTAUserMsgStatsHeroMinuteDetails = {
  encode(message: CDOTAUserMsgStatsHeroMinuteDetails, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.lastHits !== undefined && message.lastHits !== 0) {
      writer.uint32(8).uint32(message.lastHits);
    }
    if (message.heroKills !== undefined && message.heroKills !== 0) {
      writer.uint32(16).uint32(message.heroKills);
    }
    if (message.heroDamage !== undefined && message.heroDamage !== 0) {
      writer.uint32(24).uint32(message.heroDamage);
    }
    if (message.towerDamage !== undefined && message.towerDamage !== 0) {
      writer.uint32(32).uint32(message.towerDamage);
    }
    if (message.positionInfo !== undefined) {
      CDOTAUserMsgStatsHeroPositionInfo.encode(message.positionInfo, writer.uint32(42).fork()).ldelim();
    }
    if (message.totalXp !== undefined && message.totalXp !== 0) {
      writer.uint32(48).uint32(message.totalXp);
    }
    if (message.netWorth !== undefined && message.netWorth !== 0) {
      writer.uint32(56).uint32(message.netWorth);
    }
    if (message.harvestedCreepGold !== undefined && message.harvestedCreepGold !== 0) {
      writer.uint32(64).uint32(message.harvestedCreepGold);
    }
    if (message.claimedFarm !== undefined && message.claimedFarm !== 0) {
      writer.uint32(72).uint32(message.claimedFarm);
    }
    if (message.wardsPlaced !== undefined && message.wardsPlaced !== 0) {
      writer.uint32(80).uint32(message.wardsPlaced);
    }
    if (message.runesCollected !== undefined && message.runesCollected !== 0) {
      writer.uint32(88).uint32(message.runesCollected);
    }
    if (message.tpsUsed !== undefined && message.tpsUsed !== 0) {
      writer.uint32(96).uint32(message.tpsUsed);
    }
    writer.uint32(106).fork();
    for (const v of message.manaSpent) {
      writer.uint32(v);
    }
    writer.ldelim();
    writer.uint32(114).fork();
    for (const v of message.damageAbsorbed) {
      writer.uint32(v);
    }
    writer.ldelim();
    writer.uint32(122).fork();
    for (const v of message.damageDone) {
      writer.uint32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgStatsHeroMinuteDetails {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgStatsHeroMinuteDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.lastHits = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.heroKills = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.heroDamage = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.towerDamage = reader.uint32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.positionInfo = CDOTAUserMsgStatsHeroPositionInfo.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.totalXp = reader.uint32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.netWorth = reader.uint32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.harvestedCreepGold = reader.uint32();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.claimedFarm = reader.uint32();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.wardsPlaced = reader.uint32();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.runesCollected = reader.uint32();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.tpsUsed = reader.uint32();
          continue;
        case 13:
          if (tag === 104) {
            message.manaSpent.push(reader.uint32());

            continue;
          }

          if (tag === 106) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.manaSpent.push(reader.uint32());
            }

            continue;
          }

          break;
        case 14:
          if (tag === 112) {
            message.damageAbsorbed.push(reader.uint32());

            continue;
          }

          if (tag === 114) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.damageAbsorbed.push(reader.uint32());
            }

            continue;
          }

          break;
        case 15:
          if (tag === 120) {
            message.damageDone.push(reader.uint32());

            continue;
          }

          if (tag === 122) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.damageDone.push(reader.uint32());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgStatsHeroMinuteDetails {
    return {
      lastHits: isSet(object.lastHits) ? globalThis.Number(object.lastHits) : 0,
      heroKills: isSet(object.heroKills) ? globalThis.Number(object.heroKills) : 0,
      heroDamage: isSet(object.heroDamage) ? globalThis.Number(object.heroDamage) : 0,
      towerDamage: isSet(object.towerDamage) ? globalThis.Number(object.towerDamage) : 0,
      positionInfo: isSet(object.positionInfo)
        ? CDOTAUserMsgStatsHeroPositionInfo.fromJSON(object.positionInfo)
        : undefined,
      totalXp: isSet(object.totalXp) ? globalThis.Number(object.totalXp) : 0,
      netWorth: isSet(object.netWorth) ? globalThis.Number(object.netWorth) : 0,
      harvestedCreepGold: isSet(object.harvestedCreepGold) ? globalThis.Number(object.harvestedCreepGold) : 0,
      claimedFarm: isSet(object.claimedFarm) ? globalThis.Number(object.claimedFarm) : 0,
      wardsPlaced: isSet(object.wardsPlaced) ? globalThis.Number(object.wardsPlaced) : 0,
      runesCollected: isSet(object.runesCollected) ? globalThis.Number(object.runesCollected) : 0,
      tpsUsed: isSet(object.tpsUsed) ? globalThis.Number(object.tpsUsed) : 0,
      manaSpent: globalThis.Array.isArray(object?.manaSpent)
        ? object.manaSpent.map((e: any) => globalThis.Number(e))
        : [],
      damageAbsorbed: globalThis.Array.isArray(object?.damageAbsorbed)
        ? object.damageAbsorbed.map((e: any) => globalThis.Number(e))
        : [],
      damageDone: globalThis.Array.isArray(object?.damageDone)
        ? object.damageDone.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: CDOTAUserMsgStatsHeroMinuteDetails): unknown {
    const obj: any = {};
    if (message.lastHits !== undefined && message.lastHits !== 0) {
      obj.lastHits = Math.round(message.lastHits);
    }
    if (message.heroKills !== undefined && message.heroKills !== 0) {
      obj.heroKills = Math.round(message.heroKills);
    }
    if (message.heroDamage !== undefined && message.heroDamage !== 0) {
      obj.heroDamage = Math.round(message.heroDamage);
    }
    if (message.towerDamage !== undefined && message.towerDamage !== 0) {
      obj.towerDamage = Math.round(message.towerDamage);
    }
    if (message.positionInfo !== undefined) {
      obj.positionInfo = CDOTAUserMsgStatsHeroPositionInfo.toJSON(message.positionInfo);
    }
    if (message.totalXp !== undefined && message.totalXp !== 0) {
      obj.totalXp = Math.round(message.totalXp);
    }
    if (message.netWorth !== undefined && message.netWorth !== 0) {
      obj.netWorth = Math.round(message.netWorth);
    }
    if (message.harvestedCreepGold !== undefined && message.harvestedCreepGold !== 0) {
      obj.harvestedCreepGold = Math.round(message.harvestedCreepGold);
    }
    if (message.claimedFarm !== undefined && message.claimedFarm !== 0) {
      obj.claimedFarm = Math.round(message.claimedFarm);
    }
    if (message.wardsPlaced !== undefined && message.wardsPlaced !== 0) {
      obj.wardsPlaced = Math.round(message.wardsPlaced);
    }
    if (message.runesCollected !== undefined && message.runesCollected !== 0) {
      obj.runesCollected = Math.round(message.runesCollected);
    }
    if (message.tpsUsed !== undefined && message.tpsUsed !== 0) {
      obj.tpsUsed = Math.round(message.tpsUsed);
    }
    if (message.manaSpent?.length) {
      obj.manaSpent = message.manaSpent.map((e) => Math.round(e));
    }
    if (message.damageAbsorbed?.length) {
      obj.damageAbsorbed = message.damageAbsorbed.map((e) => Math.round(e));
    }
    if (message.damageDone?.length) {
      obj.damageDone = message.damageDone.map((e) => Math.round(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgStatsHeroMinuteDetails>): CDOTAUserMsgStatsHeroMinuteDetails {
    return CDOTAUserMsgStatsHeroMinuteDetails.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgStatsHeroMinuteDetails>): CDOTAUserMsgStatsHeroMinuteDetails {
    const message = createBaseCDOTAUserMsgStatsHeroMinuteDetails();
    message.lastHits = object.lastHits ?? 0;
    message.heroKills = object.heroKills ?? 0;
    message.heroDamage = object.heroDamage ?? 0;
    message.towerDamage = object.towerDamage ?? 0;
    message.positionInfo =
      object.positionInfo !== undefined && object.positionInfo !== null
        ? CDOTAUserMsgStatsHeroPositionInfo.fromPartial(object.positionInfo)
        : undefined;
    message.totalXp = object.totalXp ?? 0;
    message.netWorth = object.netWorth ?? 0;
    message.harvestedCreepGold = object.harvestedCreepGold ?? 0;
    message.claimedFarm = object.claimedFarm ?? 0;
    message.wardsPlaced = object.wardsPlaced ?? 0;
    message.runesCollected = object.runesCollected ?? 0;
    message.tpsUsed = object.tpsUsed ?? 0;
    message.manaSpent = object.manaSpent?.map((e) => e) || [];
    message.damageAbsorbed = object.damageAbsorbed?.map((e) => e) || [];
    message.damageDone = object.damageDone?.map((e) => e) || [];
    return message;
  },
};

function createBaseCDOTAUserMsgStatsTeamMinuteDetails(): CDOTAUserMsgStatsTeamMinuteDetails {
  return {
    playerStats: [],
    towerKills: 0,
    barrackKills: 0,
    availableLaneCreepGold: 0,
    balanceKillValue: 0,
    balanceTowerValue: 0,
    balanceBarracksValue: 0,
    balanceGoldValue: 0,
    balanceXpValue: 0,
    lanePerformance: [],
  };
}

export const CDOTAUserMsgStatsTeamMinuteDetails = {
  encode(message: CDOTAUserMsgStatsTeamMinuteDetails, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.playerStats) {
      CDOTAUserMsgStatsHeroMinuteDetails.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.towerKills !== undefined && message.towerKills !== 0) {
      writer.uint32(16).uint32(message.towerKills);
    }
    if (message.barrackKills !== undefined && message.barrackKills !== 0) {
      writer.uint32(24).uint32(message.barrackKills);
    }
    if (message.availableLaneCreepGold !== undefined && message.availableLaneCreepGold !== 0) {
      writer.uint32(32).uint32(message.availableLaneCreepGold);
    }
    if (message.balanceKillValue !== undefined && message.balanceKillValue !== 0) {
      writer.uint32(40).uint32(message.balanceKillValue);
    }
    if (message.balanceTowerValue !== undefined && message.balanceTowerValue !== 0) {
      writer.uint32(48).uint32(message.balanceTowerValue);
    }
    if (message.balanceBarracksValue !== undefined && message.balanceBarracksValue !== 0) {
      writer.uint32(56).uint32(message.balanceBarracksValue);
    }
    if (message.balanceGoldValue !== undefined && message.balanceGoldValue !== 0) {
      writer.uint32(64).uint32(message.balanceGoldValue);
    }
    if (message.balanceXpValue !== undefined && message.balanceXpValue !== 0) {
      writer.uint32(72).uint32(message.balanceXpValue);
    }
    for (const v of message.lanePerformance) {
      CDOTAUserMsgStatsTeamMinuteDetails_LocationPerformance.encode(v!, writer.uint32(82).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgStatsTeamMinuteDetails {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgStatsTeamMinuteDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.playerStats.push(CDOTAUserMsgStatsHeroMinuteDetails.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.towerKills = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.barrackKills = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.availableLaneCreepGold = reader.uint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.balanceKillValue = reader.uint32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.balanceTowerValue = reader.uint32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.balanceBarracksValue = reader.uint32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.balanceGoldValue = reader.uint32();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.balanceXpValue = reader.uint32();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.lanePerformance.push(
            CDOTAUserMsgStatsTeamMinuteDetails_LocationPerformance.decode(reader, reader.uint32()),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgStatsTeamMinuteDetails {
    return {
      playerStats: globalThis.Array.isArray(object?.playerStats)
        ? object.playerStats.map((e: any) => CDOTAUserMsgStatsHeroMinuteDetails.fromJSON(e))
        : [],
      towerKills: isSet(object.towerKills) ? globalThis.Number(object.towerKills) : 0,
      barrackKills: isSet(object.barrackKills) ? globalThis.Number(object.barrackKills) : 0,
      availableLaneCreepGold: isSet(object.availableLaneCreepGold)
        ? globalThis.Number(object.availableLaneCreepGold)
        : 0,
      balanceKillValue: isSet(object.balanceKillValue) ? globalThis.Number(object.balanceKillValue) : 0,
      balanceTowerValue: isSet(object.balanceTowerValue) ? globalThis.Number(object.balanceTowerValue) : 0,
      balanceBarracksValue: isSet(object.balanceBarracksValue) ? globalThis.Number(object.balanceBarracksValue) : 0,
      balanceGoldValue: isSet(object.balanceGoldValue) ? globalThis.Number(object.balanceGoldValue) : 0,
      balanceXpValue: isSet(object.balanceXpValue) ? globalThis.Number(object.balanceXpValue) : 0,
      lanePerformance: globalThis.Array.isArray(object?.lanePerformance)
        ? object.lanePerformance.map((e: any) => CDOTAUserMsgStatsTeamMinuteDetails_LocationPerformance.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CDOTAUserMsgStatsTeamMinuteDetails): unknown {
    const obj: any = {};
    if (message.playerStats?.length) {
      obj.playerStats = message.playerStats.map((e) => CDOTAUserMsgStatsHeroMinuteDetails.toJSON(e));
    }
    if (message.towerKills !== undefined && message.towerKills !== 0) {
      obj.towerKills = Math.round(message.towerKills);
    }
    if (message.barrackKills !== undefined && message.barrackKills !== 0) {
      obj.barrackKills = Math.round(message.barrackKills);
    }
    if (message.availableLaneCreepGold !== undefined && message.availableLaneCreepGold !== 0) {
      obj.availableLaneCreepGold = Math.round(message.availableLaneCreepGold);
    }
    if (message.balanceKillValue !== undefined && message.balanceKillValue !== 0) {
      obj.balanceKillValue = Math.round(message.balanceKillValue);
    }
    if (message.balanceTowerValue !== undefined && message.balanceTowerValue !== 0) {
      obj.balanceTowerValue = Math.round(message.balanceTowerValue);
    }
    if (message.balanceBarracksValue !== undefined && message.balanceBarracksValue !== 0) {
      obj.balanceBarracksValue = Math.round(message.balanceBarracksValue);
    }
    if (message.balanceGoldValue !== undefined && message.balanceGoldValue !== 0) {
      obj.balanceGoldValue = Math.round(message.balanceGoldValue);
    }
    if (message.balanceXpValue !== undefined && message.balanceXpValue !== 0) {
      obj.balanceXpValue = Math.round(message.balanceXpValue);
    }
    if (message.lanePerformance?.length) {
      obj.lanePerformance = message.lanePerformance.map((e) =>
        CDOTAUserMsgStatsTeamMinuteDetails_LocationPerformance.toJSON(e),
      );
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgStatsTeamMinuteDetails>): CDOTAUserMsgStatsTeamMinuteDetails {
    return CDOTAUserMsgStatsTeamMinuteDetails.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgStatsTeamMinuteDetails>): CDOTAUserMsgStatsTeamMinuteDetails {
    const message = createBaseCDOTAUserMsgStatsTeamMinuteDetails();
    message.playerStats = object.playerStats?.map((e) => CDOTAUserMsgStatsHeroMinuteDetails.fromPartial(e)) || [];
    message.towerKills = object.towerKills ?? 0;
    message.barrackKills = object.barrackKills ?? 0;
    message.availableLaneCreepGold = object.availableLaneCreepGold ?? 0;
    message.balanceKillValue = object.balanceKillValue ?? 0;
    message.balanceTowerValue = object.balanceTowerValue ?? 0;
    message.balanceBarracksValue = object.balanceBarracksValue ?? 0;
    message.balanceGoldValue = object.balanceGoldValue ?? 0;
    message.balanceXpValue = object.balanceXpValue ?? 0;
    message.lanePerformance =
      object.lanePerformance?.map((e) => CDOTAUserMsgStatsTeamMinuteDetails_LocationPerformance.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCDOTAUserMsgStatsTeamMinuteDetails_LocationPerformance(): CDOTAUserMsgStatsTeamMinuteDetails_LocationPerformance {
  return { locationCategory: 0, statType: 0, value: 0 };
}

export const CDOTAUserMsgStatsTeamMinuteDetails_LocationPerformance = {
  encode(
    message: CDOTAUserMsgStatsTeamMinuteDetails_LocationPerformance,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.locationCategory !== undefined && message.locationCategory !== 0) {
      writer.uint32(8).uint32(message.locationCategory);
    }
    if (message.statType !== undefined && message.statType !== 0) {
      writer.uint32(16).uint32(message.statType);
    }
    if (message.value !== undefined && message.value !== 0) {
      writer.uint32(24).uint32(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgStatsTeamMinuteDetails_LocationPerformance {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgStatsTeamMinuteDetails_LocationPerformance();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.locationCategory = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.statType = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.value = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgStatsTeamMinuteDetails_LocationPerformance {
    return {
      locationCategory: isSet(object.locationCategory) ? globalThis.Number(object.locationCategory) : 0,
      statType: isSet(object.statType) ? globalThis.Number(object.statType) : 0,
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
    };
  },

  toJSON(message: CDOTAUserMsgStatsTeamMinuteDetails_LocationPerformance): unknown {
    const obj: any = {};
    if (message.locationCategory !== undefined && message.locationCategory !== 0) {
      obj.locationCategory = Math.round(message.locationCategory);
    }
    if (message.statType !== undefined && message.statType !== 0) {
      obj.statType = Math.round(message.statType);
    }
    if (message.value !== undefined && message.value !== 0) {
      obj.value = Math.round(message.value);
    }
    return obj;
  },

  create(
    base?: DeepPartial<CDOTAUserMsgStatsTeamMinuteDetails_LocationPerformance>,
  ): CDOTAUserMsgStatsTeamMinuteDetails_LocationPerformance {
    return CDOTAUserMsgStatsTeamMinuteDetails_LocationPerformance.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CDOTAUserMsgStatsTeamMinuteDetails_LocationPerformance>,
  ): CDOTAUserMsgStatsTeamMinuteDetails_LocationPerformance {
    const message = createBaseCDOTAUserMsgStatsTeamMinuteDetails_LocationPerformance();
    message.locationCategory = object.locationCategory ?? 0;
    message.statType = object.statType ?? 0;
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseCDOTAUserMsgStatsPlayerKillShare(): CDOTAUserMsgStatsPlayerKillShare {
  return { playerId: -1, killSharePercent: 0, playerLocX: 0, playerLocY: 0, healthPercent: 0, manaPercent: 0 };
}

export const CDOTAUserMsgStatsPlayerKillShare = {
  encode(message: CDOTAUserMsgStatsPlayerKillShare, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.playerId !== undefined && message.playerId !== -1) {
      writer.uint32(8).int32(message.playerId);
    }
    if (message.killSharePercent !== undefined && message.killSharePercent !== 0) {
      writer.uint32(21).float(message.killSharePercent);
    }
    if (message.playerLocX !== undefined && message.playerLocX !== 0) {
      writer.uint32(29).float(message.playerLocX);
    }
    if (message.playerLocY !== undefined && message.playerLocY !== 0) {
      writer.uint32(37).float(message.playerLocY);
    }
    if (message.healthPercent !== undefined && message.healthPercent !== 0) {
      writer.uint32(45).float(message.healthPercent);
    }
    if (message.manaPercent !== undefined && message.manaPercent !== 0) {
      writer.uint32(53).float(message.manaPercent);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgStatsPlayerKillShare {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgStatsPlayerKillShare();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.playerId = reader.int32();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.killSharePercent = reader.float();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.playerLocX = reader.float();
          continue;
        case 4:
          if (tag !== 37) {
            break;
          }

          message.playerLocY = reader.float();
          continue;
        case 5:
          if (tag !== 45) {
            break;
          }

          message.healthPercent = reader.float();
          continue;
        case 6:
          if (tag !== 53) {
            break;
          }

          message.manaPercent = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgStatsPlayerKillShare {
    return {
      playerId: isSet(object.playerId) ? globalThis.Number(object.playerId) : -1,
      killSharePercent: isSet(object.killSharePercent) ? globalThis.Number(object.killSharePercent) : 0,
      playerLocX: isSet(object.playerLocX) ? globalThis.Number(object.playerLocX) : 0,
      playerLocY: isSet(object.playerLocY) ? globalThis.Number(object.playerLocY) : 0,
      healthPercent: isSet(object.healthPercent) ? globalThis.Number(object.healthPercent) : 0,
      manaPercent: isSet(object.manaPercent) ? globalThis.Number(object.manaPercent) : 0,
    };
  },

  toJSON(message: CDOTAUserMsgStatsPlayerKillShare): unknown {
    const obj: any = {};
    if (message.playerId !== undefined && message.playerId !== -1) {
      obj.playerId = Math.round(message.playerId);
    }
    if (message.killSharePercent !== undefined && message.killSharePercent !== 0) {
      obj.killSharePercent = message.killSharePercent;
    }
    if (message.playerLocX !== undefined && message.playerLocX !== 0) {
      obj.playerLocX = message.playerLocX;
    }
    if (message.playerLocY !== undefined && message.playerLocY !== 0) {
      obj.playerLocY = message.playerLocY;
    }
    if (message.healthPercent !== undefined && message.healthPercent !== 0) {
      obj.healthPercent = message.healthPercent;
    }
    if (message.manaPercent !== undefined && message.manaPercent !== 0) {
      obj.manaPercent = message.manaPercent;
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgStatsPlayerKillShare>): CDOTAUserMsgStatsPlayerKillShare {
    return CDOTAUserMsgStatsPlayerKillShare.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgStatsPlayerKillShare>): CDOTAUserMsgStatsPlayerKillShare {
    const message = createBaseCDOTAUserMsgStatsPlayerKillShare();
    message.playerId = object.playerId ?? -1;
    message.killSharePercent = object.killSharePercent ?? 0;
    message.playerLocX = object.playerLocX ?? 0;
    message.playerLocY = object.playerLocY ?? 0;
    message.healthPercent = object.healthPercent ?? 0;
    message.manaPercent = object.manaPercent ?? 0;
    return message;
  },
};

function createBaseCDOTAUserMsgStatsKillDetails(): CDOTAUserMsgStatsKillDetails {
  return { victimId: -1, killShares: [], damageToKill: 0, effectiveHealth: 0, deathTime: 0, killerId: -1 };
}

export const CDOTAUserMsgStatsKillDetails = {
  encode(message: CDOTAUserMsgStatsKillDetails, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.victimId !== undefined && message.victimId !== -1) {
      writer.uint32(8).int32(message.victimId);
    }
    for (const v of message.killShares) {
      CDOTAUserMsgStatsPlayerKillShare.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.damageToKill !== undefined && message.damageToKill !== 0) {
      writer.uint32(24).uint32(message.damageToKill);
    }
    if (message.effectiveHealth !== undefined && message.effectiveHealth !== 0) {
      writer.uint32(32).uint32(message.effectiveHealth);
    }
    if (message.deathTime !== undefined && message.deathTime !== 0) {
      writer.uint32(45).float(message.deathTime);
    }
    if (message.killerId !== undefined && message.killerId !== -1) {
      writer.uint32(48).int32(message.killerId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgStatsKillDetails {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgStatsKillDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.victimId = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.killShares.push(CDOTAUserMsgStatsPlayerKillShare.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.damageToKill = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.effectiveHealth = reader.uint32();
          continue;
        case 5:
          if (tag !== 45) {
            break;
          }

          message.deathTime = reader.float();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.killerId = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgStatsKillDetails {
    return {
      victimId: isSet(object.victimId) ? globalThis.Number(object.victimId) : -1,
      killShares: globalThis.Array.isArray(object?.killShares)
        ? object.killShares.map((e: any) => CDOTAUserMsgStatsPlayerKillShare.fromJSON(e))
        : [],
      damageToKill: isSet(object.damageToKill) ? globalThis.Number(object.damageToKill) : 0,
      effectiveHealth: isSet(object.effectiveHealth) ? globalThis.Number(object.effectiveHealth) : 0,
      deathTime: isSet(object.deathTime) ? globalThis.Number(object.deathTime) : 0,
      killerId: isSet(object.killerId) ? globalThis.Number(object.killerId) : -1,
    };
  },

  toJSON(message: CDOTAUserMsgStatsKillDetails): unknown {
    const obj: any = {};
    if (message.victimId !== undefined && message.victimId !== -1) {
      obj.victimId = Math.round(message.victimId);
    }
    if (message.killShares?.length) {
      obj.killShares = message.killShares.map((e) => CDOTAUserMsgStatsPlayerKillShare.toJSON(e));
    }
    if (message.damageToKill !== undefined && message.damageToKill !== 0) {
      obj.damageToKill = Math.round(message.damageToKill);
    }
    if (message.effectiveHealth !== undefined && message.effectiveHealth !== 0) {
      obj.effectiveHealth = Math.round(message.effectiveHealth);
    }
    if (message.deathTime !== undefined && message.deathTime !== 0) {
      obj.deathTime = message.deathTime;
    }
    if (message.killerId !== undefined && message.killerId !== -1) {
      obj.killerId = Math.round(message.killerId);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgStatsKillDetails>): CDOTAUserMsgStatsKillDetails {
    return CDOTAUserMsgStatsKillDetails.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgStatsKillDetails>): CDOTAUserMsgStatsKillDetails {
    const message = createBaseCDOTAUserMsgStatsKillDetails();
    message.victimId = object.victimId ?? -1;
    message.killShares = object.killShares?.map((e) => CDOTAUserMsgStatsPlayerKillShare.fromPartial(e)) || [];
    message.damageToKill = object.damageToKill ?? 0;
    message.effectiveHealth = object.effectiveHealth ?? 0;
    message.deathTime = object.deathTime ?? 0;
    message.killerId = object.killerId ?? -1;
    return message;
  },
};

function createBaseCDOTAUserMsgStatsMatchDetails(): CDOTAUserMsgStatsMatchDetails {
  return { heroLookup: [], radiantStats: [], direStats: [], radiantKills: [], direKills: [], fightDetails: [] };
}

export const CDOTAUserMsgStatsMatchDetails = {
  encode(message: CDOTAUserMsgStatsMatchDetails, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.heroLookup) {
      CDOTAUserMsgStatsHeroLookup.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.radiantStats) {
      CDOTAUserMsgStatsTeamMinuteDetails.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.direStats) {
      CDOTAUserMsgStatsTeamMinuteDetails.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    for (const v of message.radiantKills) {
      CDOTAUserMsgStatsKillDetails.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    for (const v of message.direKills) {
      CDOTAUserMsgStatsKillDetails.encode(v!, writer.uint32(42).fork()).ldelim();
    }
    for (const v of message.fightDetails) {
      CDOTAUserMsgStatsMatchDetails_CDOTAUserMsgStatsFightDetails.encode(v!, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgStatsMatchDetails {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgStatsMatchDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.heroLookup.push(CDOTAUserMsgStatsHeroLookup.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.radiantStats.push(CDOTAUserMsgStatsTeamMinuteDetails.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.direStats.push(CDOTAUserMsgStatsTeamMinuteDetails.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.radiantKills.push(CDOTAUserMsgStatsKillDetails.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.direKills.push(CDOTAUserMsgStatsKillDetails.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.fightDetails.push(
            CDOTAUserMsgStatsMatchDetails_CDOTAUserMsgStatsFightDetails.decode(reader, reader.uint32()),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgStatsMatchDetails {
    return {
      heroLookup: globalThis.Array.isArray(object?.heroLookup)
        ? object.heroLookup.map((e: any) => CDOTAUserMsgStatsHeroLookup.fromJSON(e))
        : [],
      radiantStats: globalThis.Array.isArray(object?.radiantStats)
        ? object.radiantStats.map((e: any) => CDOTAUserMsgStatsTeamMinuteDetails.fromJSON(e))
        : [],
      direStats: globalThis.Array.isArray(object?.direStats)
        ? object.direStats.map((e: any) => CDOTAUserMsgStatsTeamMinuteDetails.fromJSON(e))
        : [],
      radiantKills: globalThis.Array.isArray(object?.radiantKills)
        ? object.radiantKills.map((e: any) => CDOTAUserMsgStatsKillDetails.fromJSON(e))
        : [],
      direKills: globalThis.Array.isArray(object?.direKills)
        ? object.direKills.map((e: any) => CDOTAUserMsgStatsKillDetails.fromJSON(e))
        : [],
      fightDetails: globalThis.Array.isArray(object?.fightDetails)
        ? object.fightDetails.map((e: any) => CDOTAUserMsgStatsMatchDetails_CDOTAUserMsgStatsFightDetails.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CDOTAUserMsgStatsMatchDetails): unknown {
    const obj: any = {};
    if (message.heroLookup?.length) {
      obj.heroLookup = message.heroLookup.map((e) => CDOTAUserMsgStatsHeroLookup.toJSON(e));
    }
    if (message.radiantStats?.length) {
      obj.radiantStats = message.radiantStats.map((e) => CDOTAUserMsgStatsTeamMinuteDetails.toJSON(e));
    }
    if (message.direStats?.length) {
      obj.direStats = message.direStats.map((e) => CDOTAUserMsgStatsTeamMinuteDetails.toJSON(e));
    }
    if (message.radiantKills?.length) {
      obj.radiantKills = message.radiantKills.map((e) => CDOTAUserMsgStatsKillDetails.toJSON(e));
    }
    if (message.direKills?.length) {
      obj.direKills = message.direKills.map((e) => CDOTAUserMsgStatsKillDetails.toJSON(e));
    }
    if (message.fightDetails?.length) {
      obj.fightDetails = message.fightDetails.map((e) =>
        CDOTAUserMsgStatsMatchDetails_CDOTAUserMsgStatsFightDetails.toJSON(e),
      );
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgStatsMatchDetails>): CDOTAUserMsgStatsMatchDetails {
    return CDOTAUserMsgStatsMatchDetails.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgStatsMatchDetails>): CDOTAUserMsgStatsMatchDetails {
    const message = createBaseCDOTAUserMsgStatsMatchDetails();
    message.heroLookup = object.heroLookup?.map((e) => CDOTAUserMsgStatsHeroLookup.fromPartial(e)) || [];
    message.radiantStats = object.radiantStats?.map((e) => CDOTAUserMsgStatsTeamMinuteDetails.fromPartial(e)) || [];
    message.direStats = object.direStats?.map((e) => CDOTAUserMsgStatsTeamMinuteDetails.fromPartial(e)) || [];
    message.radiantKills = object.radiantKills?.map((e) => CDOTAUserMsgStatsKillDetails.fromPartial(e)) || [];
    message.direKills = object.direKills?.map((e) => CDOTAUserMsgStatsKillDetails.fromPartial(e)) || [];
    message.fightDetails =
      object.fightDetails?.map((e) => CDOTAUserMsgStatsMatchDetails_CDOTAUserMsgStatsFightDetails.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCDOTAUserMsgStatsMatchDetails_CDOTAUserMsgStatsFightTeamDetails(): CDOTAUserMsgStatsMatchDetails_CDOTAUserMsgStatsFightTeamDetails {
  return { participants: [], deaths: [], goldDelta: 0, xpDelta: 0 };
}

export const CDOTAUserMsgStatsMatchDetails_CDOTAUserMsgStatsFightTeamDetails = {
  encode(
    message: CDOTAUserMsgStatsMatchDetails_CDOTAUserMsgStatsFightTeamDetails,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.participants) {
      writer.int32(v);
    }
    writer.ldelim();
    writer.uint32(18).fork();
    for (const v of message.deaths) {
      writer.int32(v);
    }
    writer.ldelim();
    if (message.goldDelta !== undefined && message.goldDelta !== 0) {
      writer.uint32(24).uint32(message.goldDelta);
    }
    if (message.xpDelta !== undefined && message.xpDelta !== 0) {
      writer.uint32(32).uint32(message.xpDelta);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): CDOTAUserMsgStatsMatchDetails_CDOTAUserMsgStatsFightTeamDetails {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgStatsMatchDetails_CDOTAUserMsgStatsFightTeamDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.participants.push(reader.int32());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.participants.push(reader.int32());
            }

            continue;
          }

          break;
        case 2:
          if (tag === 16) {
            message.deaths.push(reader.int32());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.deaths.push(reader.int32());
            }

            continue;
          }

          break;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.goldDelta = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.xpDelta = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgStatsMatchDetails_CDOTAUserMsgStatsFightTeamDetails {
    return {
      participants: globalThis.Array.isArray(object?.participants)
        ? object.participants.map((e: any) => globalThis.Number(e))
        : [],
      deaths: globalThis.Array.isArray(object?.deaths) ? object.deaths.map((e: any) => globalThis.Number(e)) : [],
      goldDelta: isSet(object.goldDelta) ? globalThis.Number(object.goldDelta) : 0,
      xpDelta: isSet(object.xpDelta) ? globalThis.Number(object.xpDelta) : 0,
    };
  },

  toJSON(message: CDOTAUserMsgStatsMatchDetails_CDOTAUserMsgStatsFightTeamDetails): unknown {
    const obj: any = {};
    if (message.participants?.length) {
      obj.participants = message.participants.map((e) => Math.round(e));
    }
    if (message.deaths?.length) {
      obj.deaths = message.deaths.map((e) => Math.round(e));
    }
    if (message.goldDelta !== undefined && message.goldDelta !== 0) {
      obj.goldDelta = Math.round(message.goldDelta);
    }
    if (message.xpDelta !== undefined && message.xpDelta !== 0) {
      obj.xpDelta = Math.round(message.xpDelta);
    }
    return obj;
  },

  create(
    base?: DeepPartial<CDOTAUserMsgStatsMatchDetails_CDOTAUserMsgStatsFightTeamDetails>,
  ): CDOTAUserMsgStatsMatchDetails_CDOTAUserMsgStatsFightTeamDetails {
    return CDOTAUserMsgStatsMatchDetails_CDOTAUserMsgStatsFightTeamDetails.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CDOTAUserMsgStatsMatchDetails_CDOTAUserMsgStatsFightTeamDetails>,
  ): CDOTAUserMsgStatsMatchDetails_CDOTAUserMsgStatsFightTeamDetails {
    const message = createBaseCDOTAUserMsgStatsMatchDetails_CDOTAUserMsgStatsFightTeamDetails();
    message.participants = object.participants?.map((e) => e) || [];
    message.deaths = object.deaths?.map((e) => e) || [];
    message.goldDelta = object.goldDelta ?? 0;
    message.xpDelta = object.xpDelta ?? 0;
    return message;
  },
};

function createBaseCDOTAUserMsgStatsMatchDetails_CDOTAUserMsgStatsFightDetails(): CDOTAUserMsgStatsMatchDetails_CDOTAUserMsgStatsFightDetails {
  return { startTime: 0, endTime: 0, radiantFightDetails: undefined, direFightDetails: undefined };
}

export const CDOTAUserMsgStatsMatchDetails_CDOTAUserMsgStatsFightDetails = {
  encode(
    message: CDOTAUserMsgStatsMatchDetails_CDOTAUserMsgStatsFightDetails,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.startTime !== undefined && message.startTime !== 0) {
      writer.uint32(13).float(message.startTime);
    }
    if (message.endTime !== undefined && message.endTime !== 0) {
      writer.uint32(21).float(message.endTime);
    }
    if (message.radiantFightDetails !== undefined) {
      CDOTAUserMsgStatsMatchDetails_CDOTAUserMsgStatsFightTeamDetails.encode(
        message.radiantFightDetails,
        writer.uint32(26).fork(),
      ).ldelim();
    }
    if (message.direFightDetails !== undefined) {
      CDOTAUserMsgStatsMatchDetails_CDOTAUserMsgStatsFightTeamDetails.encode(
        message.direFightDetails,
        writer.uint32(34).fork(),
      ).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgStatsMatchDetails_CDOTAUserMsgStatsFightDetails {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgStatsMatchDetails_CDOTAUserMsgStatsFightDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.startTime = reader.float();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.endTime = reader.float();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.radiantFightDetails = CDOTAUserMsgStatsMatchDetails_CDOTAUserMsgStatsFightTeamDetails.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.direFightDetails = CDOTAUserMsgStatsMatchDetails_CDOTAUserMsgStatsFightTeamDetails.decode(
            reader,
            reader.uint32(),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgStatsMatchDetails_CDOTAUserMsgStatsFightDetails {
    return {
      startTime: isSet(object.startTime) ? globalThis.Number(object.startTime) : 0,
      endTime: isSet(object.endTime) ? globalThis.Number(object.endTime) : 0,
      radiantFightDetails: isSet(object.radiantFightDetails)
        ? CDOTAUserMsgStatsMatchDetails_CDOTAUserMsgStatsFightTeamDetails.fromJSON(object.radiantFightDetails)
        : undefined,
      direFightDetails: isSet(object.direFightDetails)
        ? CDOTAUserMsgStatsMatchDetails_CDOTAUserMsgStatsFightTeamDetails.fromJSON(object.direFightDetails)
        : undefined,
    };
  },

  toJSON(message: CDOTAUserMsgStatsMatchDetails_CDOTAUserMsgStatsFightDetails): unknown {
    const obj: any = {};
    if (message.startTime !== undefined && message.startTime !== 0) {
      obj.startTime = message.startTime;
    }
    if (message.endTime !== undefined && message.endTime !== 0) {
      obj.endTime = message.endTime;
    }
    if (message.radiantFightDetails !== undefined) {
      obj.radiantFightDetails = CDOTAUserMsgStatsMatchDetails_CDOTAUserMsgStatsFightTeamDetails.toJSON(
        message.radiantFightDetails,
      );
    }
    if (message.direFightDetails !== undefined) {
      obj.direFightDetails = CDOTAUserMsgStatsMatchDetails_CDOTAUserMsgStatsFightTeamDetails.toJSON(
        message.direFightDetails,
      );
    }
    return obj;
  },

  create(
    base?: DeepPartial<CDOTAUserMsgStatsMatchDetails_CDOTAUserMsgStatsFightDetails>,
  ): CDOTAUserMsgStatsMatchDetails_CDOTAUserMsgStatsFightDetails {
    return CDOTAUserMsgStatsMatchDetails_CDOTAUserMsgStatsFightDetails.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CDOTAUserMsgStatsMatchDetails_CDOTAUserMsgStatsFightDetails>,
  ): CDOTAUserMsgStatsMatchDetails_CDOTAUserMsgStatsFightDetails {
    const message = createBaseCDOTAUserMsgStatsMatchDetails_CDOTAUserMsgStatsFightDetails();
    message.startTime = object.startTime ?? 0;
    message.endTime = object.endTime ?? 0;
    message.radiantFightDetails =
      object.radiantFightDetails !== undefined && object.radiantFightDetails !== null
        ? CDOTAUserMsgStatsMatchDetails_CDOTAUserMsgStatsFightTeamDetails.fromPartial(object.radiantFightDetails)
        : undefined;
    message.direFightDetails =
      object.direFightDetails !== undefined && object.direFightDetails !== null
        ? CDOTAUserMsgStatsMatchDetails_CDOTAUserMsgStatsFightTeamDetails.fromPartial(object.direFightDetails)
        : undefined;
    return message;
  },
};

function createBaseCDOTAUserMsgMiniTaunt(): CDOTAUserMsgMiniTaunt {
  return { tauntingPlayerId: -1 };
}

export const CDOTAUserMsgMiniTaunt = {
  encode(message: CDOTAUserMsgMiniTaunt, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.tauntingPlayerId !== undefined && message.tauntingPlayerId !== -1) {
      writer.uint32(8).int32(message.tauntingPlayerId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgMiniTaunt {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgMiniTaunt();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.tauntingPlayerId = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgMiniTaunt {
    return { tauntingPlayerId: isSet(object.tauntingPlayerId) ? globalThis.Number(object.tauntingPlayerId) : -1 };
  },

  toJSON(message: CDOTAUserMsgMiniTaunt): unknown {
    const obj: any = {};
    if (message.tauntingPlayerId !== undefined && message.tauntingPlayerId !== -1) {
      obj.tauntingPlayerId = Math.round(message.tauntingPlayerId);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgMiniTaunt>): CDOTAUserMsgMiniTaunt {
    return CDOTAUserMsgMiniTaunt.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgMiniTaunt>): CDOTAUserMsgMiniTaunt {
    const message = createBaseCDOTAUserMsgMiniTaunt();
    message.tauntingPlayerId = object.tauntingPlayerId ?? -1;
    return message;
  },
};

function createBaseCDOTAUserMsgSpeechBubble(): CDOTAUserMsgSpeechBubble {
  return { destroyAll: false };
}

export const CDOTAUserMsgSpeechBubble = {
  encode(message: CDOTAUserMsgSpeechBubble, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.destroyAll !== undefined && message.destroyAll !== false) {
      writer.uint32(8).bool(message.destroyAll);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgSpeechBubble {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgSpeechBubble();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.destroyAll = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgSpeechBubble {
    return { destroyAll: isSet(object.destroyAll) ? globalThis.Boolean(object.destroyAll) : false };
  },

  toJSON(message: CDOTAUserMsgSpeechBubble): unknown {
    const obj: any = {};
    if (message.destroyAll !== undefined && message.destroyAll !== false) {
      obj.destroyAll = message.destroyAll;
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgSpeechBubble>): CDOTAUserMsgSpeechBubble {
    return CDOTAUserMsgSpeechBubble.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgSpeechBubble>): CDOTAUserMsgSpeechBubble {
    const message = createBaseCDOTAUserMsgSpeechBubble();
    message.destroyAll = object.destroyAll ?? false;
    return message;
  },
};

function createBaseCDOTAUserMsgCustomHeaderMessage(): CDOTAUserMsgCustomHeaderMessage {
  return { playerId: -1, duration: 0, message: "", value: 0 };
}

export const CDOTAUserMsgCustomHeaderMessage = {
  encode(message: CDOTAUserMsgCustomHeaderMessage, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.playerId !== undefined && message.playerId !== -1) {
      writer.uint32(8).int32(message.playerId);
    }
    if (message.duration !== undefined && message.duration !== 0) {
      writer.uint32(21).float(message.duration);
    }
    if (message.message !== undefined && message.message !== "") {
      writer.uint32(26).string(message.message);
    }
    if (message.value !== undefined && message.value !== 0) {
      writer.uint32(32).int32(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgCustomHeaderMessage {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgCustomHeaderMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.playerId = reader.int32();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.duration = reader.float();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.message = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.value = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgCustomHeaderMessage {
    return {
      playerId: isSet(object.playerId) ? globalThis.Number(object.playerId) : -1,
      duration: isSet(object.duration) ? globalThis.Number(object.duration) : 0,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
    };
  },

  toJSON(message: CDOTAUserMsgCustomHeaderMessage): unknown {
    const obj: any = {};
    if (message.playerId !== undefined && message.playerId !== -1) {
      obj.playerId = Math.round(message.playerId);
    }
    if (message.duration !== undefined && message.duration !== 0) {
      obj.duration = message.duration;
    }
    if (message.message !== undefined && message.message !== "") {
      obj.message = message.message;
    }
    if (message.value !== undefined && message.value !== 0) {
      obj.value = Math.round(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgCustomHeaderMessage>): CDOTAUserMsgCustomHeaderMessage {
    return CDOTAUserMsgCustomHeaderMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgCustomHeaderMessage>): CDOTAUserMsgCustomHeaderMessage {
    const message = createBaseCDOTAUserMsgCustomHeaderMessage();
    message.playerId = object.playerId ?? -1;
    message.duration = object.duration ?? 0;
    message.message = object.message ?? "";
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseCMsgHeroAbilityStat(): CMsgHeroAbilityStat {
  return { statType: 0, intValue: 0, floatValue: 0 };
}

export const CMsgHeroAbilityStat = {
  encode(message: CMsgHeroAbilityStat, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.statType !== undefined && message.statType !== 0) {
      writer.uint32(8).int32(message.statType);
    }
    if (message.intValue !== undefined && message.intValue !== 0) {
      writer.uint32(16).int32(message.intValue);
    }
    if (message.floatValue !== undefined && message.floatValue !== 0) {
      writer.uint32(29).float(message.floatValue);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgHeroAbilityStat {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgHeroAbilityStat();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.statType = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.intValue = reader.int32();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.floatValue = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgHeroAbilityStat {
    return {
      statType: isSet(object.statType) ? eHeroStatTypeFromJSON(object.statType) : 0,
      intValue: isSet(object.intValue) ? globalThis.Number(object.intValue) : 0,
      floatValue: isSet(object.floatValue) ? globalThis.Number(object.floatValue) : 0,
    };
  },

  toJSON(message: CMsgHeroAbilityStat): unknown {
    const obj: any = {};
    if (message.statType !== undefined && message.statType !== 0) {
      obj.statType = eHeroStatTypeToJSON(message.statType);
    }
    if (message.intValue !== undefined && message.intValue !== 0) {
      obj.intValue = Math.round(message.intValue);
    }
    if (message.floatValue !== undefined && message.floatValue !== 0) {
      obj.floatValue = message.floatValue;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgHeroAbilityStat>): CMsgHeroAbilityStat {
    return CMsgHeroAbilityStat.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgHeroAbilityStat>): CMsgHeroAbilityStat {
    const message = createBaseCMsgHeroAbilityStat();
    message.statType = object.statType ?? 0;
    message.intValue = object.intValue ?? 0;
    message.floatValue = object.floatValue ?? 0;
    return message;
  },
};

function createBaseCMsgCombatAnalyzerPlayerStat(): CMsgCombatAnalyzerPlayerStat {
  return { accountId: 0, heroAbilityStats: [] };
}

export const CMsgCombatAnalyzerPlayerStat = {
  encode(message: CMsgCombatAnalyzerPlayerStat, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.accountId !== undefined && message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    for (const v of message.heroAbilityStats) {
      CMsgHeroAbilityStat.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgCombatAnalyzerPlayerStat {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgCombatAnalyzerPlayerStat();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.heroAbilityStats.push(CMsgHeroAbilityStat.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgCombatAnalyzerPlayerStat {
    return {
      accountId: isSet(object.accountId) ? globalThis.Number(object.accountId) : 0,
      heroAbilityStats: globalThis.Array.isArray(object?.heroAbilityStats)
        ? object.heroAbilityStats.map((e: any) => CMsgHeroAbilityStat.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgCombatAnalyzerPlayerStat): unknown {
    const obj: any = {};
    if (message.accountId !== undefined && message.accountId !== 0) {
      obj.accountId = Math.round(message.accountId);
    }
    if (message.heroAbilityStats?.length) {
      obj.heroAbilityStats = message.heroAbilityStats.map((e) => CMsgHeroAbilityStat.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgCombatAnalyzerPlayerStat>): CMsgCombatAnalyzerPlayerStat {
    return CMsgCombatAnalyzerPlayerStat.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgCombatAnalyzerPlayerStat>): CMsgCombatAnalyzerPlayerStat {
    const message = createBaseCMsgCombatAnalyzerPlayerStat();
    message.accountId = object.accountId ?? 0;
    message.heroAbilityStats = object.heroAbilityStats?.map((e) => CMsgHeroAbilityStat.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgCombatAnalyzerStats(): CMsgCombatAnalyzerStats {
  return { matchId: "0", playerStats: [] };
}

export const CMsgCombatAnalyzerStats = {
  encode(message: CMsgCombatAnalyzerStats, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.matchId !== undefined && message.matchId !== "0") {
      writer.uint32(8).uint64(message.matchId);
    }
    for (const v of message.playerStats) {
      CMsgCombatAnalyzerPlayerStat.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgCombatAnalyzerStats {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgCombatAnalyzerStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.matchId = longToString(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.playerStats.push(CMsgCombatAnalyzerPlayerStat.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgCombatAnalyzerStats {
    return {
      matchId: isSet(object.matchId) ? globalThis.String(object.matchId) : "0",
      playerStats: globalThis.Array.isArray(object?.playerStats)
        ? object.playerStats.map((e: any) => CMsgCombatAnalyzerPlayerStat.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgCombatAnalyzerStats): unknown {
    const obj: any = {};
    if (message.matchId !== undefined && message.matchId !== "0") {
      obj.matchId = message.matchId;
    }
    if (message.playerStats?.length) {
      obj.playerStats = message.playerStats.map((e) => CMsgCombatAnalyzerPlayerStat.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgCombatAnalyzerStats>): CMsgCombatAnalyzerStats {
    return CMsgCombatAnalyzerStats.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgCombatAnalyzerStats>): CMsgCombatAnalyzerStats {
    const message = createBaseCMsgCombatAnalyzerStats();
    message.matchId = object.matchId ?? "0";
    message.playerStats = object.playerStats?.map((e) => CMsgCombatAnalyzerPlayerStat.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCDOTAUserMsgBeastChat(): CDOTAUserMsgBeastChat {
  return { team: 0, format: "", message: "", target: "" };
}

export const CDOTAUserMsgBeastChat = {
  encode(message: CDOTAUserMsgBeastChat, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.team !== undefined && message.team !== 0) {
      writer.uint32(8).uint32(message.team);
    }
    if (message.format !== undefined && message.format !== "") {
      writer.uint32(18).string(message.format);
    }
    if (message.message !== undefined && message.message !== "") {
      writer.uint32(26).string(message.message);
    }
    if (message.target !== undefined && message.target !== "") {
      writer.uint32(34).string(message.target);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgBeastChat {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgBeastChat();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.team = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.format = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.message = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.target = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgBeastChat {
    return {
      team: isSet(object.team) ? globalThis.Number(object.team) : 0,
      format: isSet(object.format) ? globalThis.String(object.format) : "",
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      target: isSet(object.target) ? globalThis.String(object.target) : "",
    };
  },

  toJSON(message: CDOTAUserMsgBeastChat): unknown {
    const obj: any = {};
    if (message.team !== undefined && message.team !== 0) {
      obj.team = Math.round(message.team);
    }
    if (message.format !== undefined && message.format !== "") {
      obj.format = message.format;
    }
    if (message.message !== undefined && message.message !== "") {
      obj.message = message.message;
    }
    if (message.target !== undefined && message.target !== "") {
      obj.target = message.target;
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgBeastChat>): CDOTAUserMsgBeastChat {
    return CDOTAUserMsgBeastChat.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgBeastChat>): CDOTAUserMsgBeastChat {
    const message = createBaseCDOTAUserMsgBeastChat();
    message.team = object.team ?? 0;
    message.format = object.format ?? "";
    message.message = object.message ?? "";
    message.target = object.target ?? "";
    return message;
  },
};

function createBaseCDOTAUserMsgCustomHudElementCreate(): CDOTAUserMsgCustomHudElementCreate {
  return { elementId: "", layoutFilename: "", data: Buffer.alloc(0) };
}

export const CDOTAUserMsgCustomHudElementCreate = {
  encode(message: CDOTAUserMsgCustomHudElementCreate, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.elementId !== undefined && message.elementId !== "") {
      writer.uint32(10).string(message.elementId);
    }
    if (message.layoutFilename !== undefined && message.layoutFilename !== "") {
      writer.uint32(18).string(message.layoutFilename);
    }
    if (message.data !== undefined && message.data.length !== 0) {
      writer.uint32(26).bytes(message.data);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgCustomHudElementCreate {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgCustomHudElementCreate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.elementId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.layoutFilename = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.data = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgCustomHudElementCreate {
    return {
      elementId: isSet(object.elementId) ? globalThis.String(object.elementId) : "",
      layoutFilename: isSet(object.layoutFilename) ? globalThis.String(object.layoutFilename) : "",
      data: isSet(object.data) ? Buffer.from(bytesFromBase64(object.data)) : Buffer.alloc(0),
    };
  },

  toJSON(message: CDOTAUserMsgCustomHudElementCreate): unknown {
    const obj: any = {};
    if (message.elementId !== undefined && message.elementId !== "") {
      obj.elementId = message.elementId;
    }
    if (message.layoutFilename !== undefined && message.layoutFilename !== "") {
      obj.layoutFilename = message.layoutFilename;
    }
    if (message.data !== undefined && message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgCustomHudElementCreate>): CDOTAUserMsgCustomHudElementCreate {
    return CDOTAUserMsgCustomHudElementCreate.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgCustomHudElementCreate>): CDOTAUserMsgCustomHudElementCreate {
    const message = createBaseCDOTAUserMsgCustomHudElementCreate();
    message.elementId = object.elementId ?? "";
    message.layoutFilename = object.layoutFilename ?? "";
    message.data = object.data ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseCDOTAUserMsgCustomHudElementModify(): CDOTAUserMsgCustomHudElementModify {
  return { elementId: "", modifyVisible: false, data: Buffer.alloc(0) };
}

export const CDOTAUserMsgCustomHudElementModify = {
  encode(message: CDOTAUserMsgCustomHudElementModify, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.elementId !== undefined && message.elementId !== "") {
      writer.uint32(10).string(message.elementId);
    }
    if (message.modifyVisible !== undefined && message.modifyVisible !== false) {
      writer.uint32(16).bool(message.modifyVisible);
    }
    if (message.data !== undefined && message.data.length !== 0) {
      writer.uint32(26).bytes(message.data);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgCustomHudElementModify {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgCustomHudElementModify();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.elementId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.modifyVisible = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.data = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgCustomHudElementModify {
    return {
      elementId: isSet(object.elementId) ? globalThis.String(object.elementId) : "",
      modifyVisible: isSet(object.modifyVisible) ? globalThis.Boolean(object.modifyVisible) : false,
      data: isSet(object.data) ? Buffer.from(bytesFromBase64(object.data)) : Buffer.alloc(0),
    };
  },

  toJSON(message: CDOTAUserMsgCustomHudElementModify): unknown {
    const obj: any = {};
    if (message.elementId !== undefined && message.elementId !== "") {
      obj.elementId = message.elementId;
    }
    if (message.modifyVisible !== undefined && message.modifyVisible !== false) {
      obj.modifyVisible = message.modifyVisible;
    }
    if (message.data !== undefined && message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgCustomHudElementModify>): CDOTAUserMsgCustomHudElementModify {
    return CDOTAUserMsgCustomHudElementModify.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgCustomHudElementModify>): CDOTAUserMsgCustomHudElementModify {
    const message = createBaseCDOTAUserMsgCustomHudElementModify();
    message.elementId = object.elementId ?? "";
    message.modifyVisible = object.modifyVisible ?? false;
    message.data = object.data ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseCDOTAUserMsgCustomHudElementDestroy(): CDOTAUserMsgCustomHudElementDestroy {
  return { elementId: "" };
}

export const CDOTAUserMsgCustomHudElementDestroy = {
  encode(message: CDOTAUserMsgCustomHudElementDestroy, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.elementId !== undefined && message.elementId !== "") {
      writer.uint32(10).string(message.elementId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgCustomHudElementDestroy {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgCustomHudElementDestroy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.elementId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgCustomHudElementDestroy {
    return { elementId: isSet(object.elementId) ? globalThis.String(object.elementId) : "" };
  },

  toJSON(message: CDOTAUserMsgCustomHudElementDestroy): unknown {
    const obj: any = {};
    if (message.elementId !== undefined && message.elementId !== "") {
      obj.elementId = message.elementId;
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgCustomHudElementDestroy>): CDOTAUserMsgCustomHudElementDestroy {
    return CDOTAUserMsgCustomHudElementDestroy.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgCustomHudElementDestroy>): CDOTAUserMsgCustomHudElementDestroy {
    const message = createBaseCDOTAUserMsgCustomHudElementDestroy();
    message.elementId = object.elementId ?? "";
    return message;
  },
};

function createBaseCDOTAUserMsgCompendiumStatePlayer(): CDOTAUserMsgCompendiumStatePlayer {
  return { playerId: -1, level: 0 };
}

export const CDOTAUserMsgCompendiumStatePlayer = {
  encode(message: CDOTAUserMsgCompendiumStatePlayer, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.playerId !== undefined && message.playerId !== -1) {
      writer.uint32(8).int32(message.playerId);
    }
    if (message.level !== undefined && message.level !== 0) {
      writer.uint32(16).uint32(message.level);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgCompendiumStatePlayer {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgCompendiumStatePlayer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.playerId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.level = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgCompendiumStatePlayer {
    return {
      playerId: isSet(object.playerId) ? globalThis.Number(object.playerId) : -1,
      level: isSet(object.level) ? globalThis.Number(object.level) : 0,
    };
  },

  toJSON(message: CDOTAUserMsgCompendiumStatePlayer): unknown {
    const obj: any = {};
    if (message.playerId !== undefined && message.playerId !== -1) {
      obj.playerId = Math.round(message.playerId);
    }
    if (message.level !== undefined && message.level !== 0) {
      obj.level = Math.round(message.level);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgCompendiumStatePlayer>): CDOTAUserMsgCompendiumStatePlayer {
    return CDOTAUserMsgCompendiumStatePlayer.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgCompendiumStatePlayer>): CDOTAUserMsgCompendiumStatePlayer {
    const message = createBaseCDOTAUserMsgCompendiumStatePlayer();
    message.playerId = object.playerId ?? -1;
    message.level = object.level ?? 0;
    return message;
  },
};

function createBaseCDOTAUserMsgCompendiumState(): CDOTAUserMsgCompendiumState {
  return { compendiumPlayers: [] };
}

export const CDOTAUserMsgCompendiumState = {
  encode(message: CDOTAUserMsgCompendiumState, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.compendiumPlayers) {
      CDOTAUserMsgCompendiumStatePlayer.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgCompendiumState {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgCompendiumState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.compendiumPlayers.push(CDOTAUserMsgCompendiumStatePlayer.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgCompendiumState {
    return {
      compendiumPlayers: globalThis.Array.isArray(object?.compendiumPlayers)
        ? object.compendiumPlayers.map((e: any) => CDOTAUserMsgCompendiumStatePlayer.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CDOTAUserMsgCompendiumState): unknown {
    const obj: any = {};
    if (message.compendiumPlayers?.length) {
      obj.compendiumPlayers = message.compendiumPlayers.map((e) => CDOTAUserMsgCompendiumStatePlayer.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgCompendiumState>): CDOTAUserMsgCompendiumState {
    return CDOTAUserMsgCompendiumState.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgCompendiumState>): CDOTAUserMsgCompendiumState {
    const message = createBaseCDOTAUserMsgCompendiumState();
    message.compendiumPlayers =
      object.compendiumPlayers?.map((e) => CDOTAUserMsgCompendiumStatePlayer.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCDOTAUserMsgProjectionAbility(): CDOTAUserMsgProjectionAbility {
  return {
    abilityId: -1,
    casterEntIndex: -1,
    casterTeam: 0,
    channelEnd: false,
    origin: undefined,
    trackCasterOnly: false,
    endTime: 0,
    victimEntIndex: -1,
  };
}

export const CDOTAUserMsgProjectionAbility = {
  encode(message: CDOTAUserMsgProjectionAbility, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.abilityId !== undefined && message.abilityId !== -1) {
      writer.uint32(8).int32(message.abilityId);
    }
    if (message.casterEntIndex !== undefined && message.casterEntIndex !== -1) {
      writer.uint32(16).int32(message.casterEntIndex);
    }
    if (message.casterTeam !== undefined && message.casterTeam !== 0) {
      writer.uint32(24).int32(message.casterTeam);
    }
    if (message.channelEnd !== undefined && message.channelEnd !== false) {
      writer.uint32(32).bool(message.channelEnd);
    }
    if (message.origin !== undefined) {
      CMsgVector.encode(message.origin, writer.uint32(42).fork()).ldelim();
    }
    if (message.trackCasterOnly !== undefined && message.trackCasterOnly !== false) {
      writer.uint32(48).bool(message.trackCasterOnly);
    }
    if (message.endTime !== undefined && message.endTime !== 0) {
      writer.uint32(61).float(message.endTime);
    }
    if (message.victimEntIndex !== undefined && message.victimEntIndex !== -1) {
      writer.uint32(64).int32(message.victimEntIndex);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgProjectionAbility {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgProjectionAbility();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.abilityId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.casterEntIndex = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.casterTeam = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.channelEnd = reader.bool();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.origin = CMsgVector.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.trackCasterOnly = reader.bool();
          continue;
        case 7:
          if (tag !== 61) {
            break;
          }

          message.endTime = reader.float();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.victimEntIndex = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgProjectionAbility {
    return {
      abilityId: isSet(object.abilityId) ? globalThis.Number(object.abilityId) : -1,
      casterEntIndex: isSet(object.casterEntIndex) ? globalThis.Number(object.casterEntIndex) : -1,
      casterTeam: isSet(object.casterTeam) ? globalThis.Number(object.casterTeam) : 0,
      channelEnd: isSet(object.channelEnd) ? globalThis.Boolean(object.channelEnd) : false,
      origin: isSet(object.origin) ? CMsgVector.fromJSON(object.origin) : undefined,
      trackCasterOnly: isSet(object.trackCasterOnly) ? globalThis.Boolean(object.trackCasterOnly) : false,
      endTime: isSet(object.endTime) ? globalThis.Number(object.endTime) : 0,
      victimEntIndex: isSet(object.victimEntIndex) ? globalThis.Number(object.victimEntIndex) : -1,
    };
  },

  toJSON(message: CDOTAUserMsgProjectionAbility): unknown {
    const obj: any = {};
    if (message.abilityId !== undefined && message.abilityId !== -1) {
      obj.abilityId = Math.round(message.abilityId);
    }
    if (message.casterEntIndex !== undefined && message.casterEntIndex !== -1) {
      obj.casterEntIndex = Math.round(message.casterEntIndex);
    }
    if (message.casterTeam !== undefined && message.casterTeam !== 0) {
      obj.casterTeam = Math.round(message.casterTeam);
    }
    if (message.channelEnd !== undefined && message.channelEnd !== false) {
      obj.channelEnd = message.channelEnd;
    }
    if (message.origin !== undefined) {
      obj.origin = CMsgVector.toJSON(message.origin);
    }
    if (message.trackCasterOnly !== undefined && message.trackCasterOnly !== false) {
      obj.trackCasterOnly = message.trackCasterOnly;
    }
    if (message.endTime !== undefined && message.endTime !== 0) {
      obj.endTime = message.endTime;
    }
    if (message.victimEntIndex !== undefined && message.victimEntIndex !== -1) {
      obj.victimEntIndex = Math.round(message.victimEntIndex);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgProjectionAbility>): CDOTAUserMsgProjectionAbility {
    return CDOTAUserMsgProjectionAbility.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgProjectionAbility>): CDOTAUserMsgProjectionAbility {
    const message = createBaseCDOTAUserMsgProjectionAbility();
    message.abilityId = object.abilityId ?? -1;
    message.casterEntIndex = object.casterEntIndex ?? -1;
    message.casterTeam = object.casterTeam ?? 0;
    message.channelEnd = object.channelEnd ?? false;
    message.origin =
      object.origin !== undefined && object.origin !== null ? CMsgVector.fromPartial(object.origin) : undefined;
    message.trackCasterOnly = object.trackCasterOnly ?? false;
    message.endTime = object.endTime ?? 0;
    message.victimEntIndex = object.victimEntIndex ?? -1;
    return message;
  },
};

function createBaseCDOTAUserMsgProjectionEvent(): CDOTAUserMsgProjectionEvent {
  return { eventId: 0, team: 0 };
}

export const CDOTAUserMsgProjectionEvent = {
  encode(message: CDOTAUserMsgProjectionEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.eventId !== undefined && message.eventId !== 0) {
      writer.uint32(8).int32(message.eventId);
    }
    if (message.team !== undefined && message.team !== 0) {
      writer.uint32(16).uint32(message.team);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgProjectionEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgProjectionEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.eventId = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.team = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgProjectionEvent {
    return {
      eventId: isSet(object.eventId) ? eProjectionEventFromJSON(object.eventId) : 0,
      team: isSet(object.team) ? globalThis.Number(object.team) : 0,
    };
  },

  toJSON(message: CDOTAUserMsgProjectionEvent): unknown {
    const obj: any = {};
    if (message.eventId !== undefined && message.eventId !== 0) {
      obj.eventId = eProjectionEventToJSON(message.eventId);
    }
    if (message.team !== undefined && message.team !== 0) {
      obj.team = Math.round(message.team);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgProjectionEvent>): CDOTAUserMsgProjectionEvent {
    return CDOTAUserMsgProjectionEvent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgProjectionEvent>): CDOTAUserMsgProjectionEvent {
    const message = createBaseCDOTAUserMsgProjectionEvent();
    message.eventId = object.eventId ?? 0;
    message.team = object.team ?? 0;
    return message;
  },
};

function createBaseCDOTAUserMsgXPAlert(): CDOTAUserMsgXPAlert {
  return { playerId: -1, targetEntindex: -1 };
}

export const CDOTAUserMsgXPAlert = {
  encode(message: CDOTAUserMsgXPAlert, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.playerId !== undefined && message.playerId !== -1) {
      writer.uint32(8).int32(message.playerId);
    }
    if (message.targetEntindex !== undefined && message.targetEntindex !== -1) {
      writer.uint32(16).int32(message.targetEntindex);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgXPAlert {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgXPAlert();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.playerId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.targetEntindex = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgXPAlert {
    return {
      playerId: isSet(object.playerId) ? globalThis.Number(object.playerId) : -1,
      targetEntindex: isSet(object.targetEntindex) ? globalThis.Number(object.targetEntindex) : -1,
    };
  },

  toJSON(message: CDOTAUserMsgXPAlert): unknown {
    const obj: any = {};
    if (message.playerId !== undefined && message.playerId !== -1) {
      obj.playerId = Math.round(message.playerId);
    }
    if (message.targetEntindex !== undefined && message.targetEntindex !== -1) {
      obj.targetEntindex = Math.round(message.targetEntindex);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgXPAlert>): CDOTAUserMsgXPAlert {
    return CDOTAUserMsgXPAlert.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgXPAlert>): CDOTAUserMsgXPAlert {
    const message = createBaseCDOTAUserMsgXPAlert();
    message.playerId = object.playerId ?? -1;
    message.targetEntindex = object.targetEntindex ?? -1;
    return message;
  },
};

function createBaseCDOTAUserMsgTalentTreeAlert(): CDOTAUserMsgTalentTreeAlert {
  return { playerId: -1, targetEntindex: -1, abilityId: -1, slot: 0, learned: false };
}

export const CDOTAUserMsgTalentTreeAlert = {
  encode(message: CDOTAUserMsgTalentTreeAlert, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.playerId !== undefined && message.playerId !== -1) {
      writer.uint32(8).int32(message.playerId);
    }
    if (message.targetEntindex !== undefined && message.targetEntindex !== -1) {
      writer.uint32(16).int32(message.targetEntindex);
    }
    if (message.abilityId !== undefined && message.abilityId !== -1) {
      writer.uint32(24).int32(message.abilityId);
    }
    if (message.slot !== undefined && message.slot !== 0) {
      writer.uint32(32).int32(message.slot);
    }
    if (message.learned !== undefined && message.learned !== false) {
      writer.uint32(40).bool(message.learned);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgTalentTreeAlert {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgTalentTreeAlert();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.playerId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.targetEntindex = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.abilityId = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.slot = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.learned = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgTalentTreeAlert {
    return {
      playerId: isSet(object.playerId) ? globalThis.Number(object.playerId) : -1,
      targetEntindex: isSet(object.targetEntindex) ? globalThis.Number(object.targetEntindex) : -1,
      abilityId: isSet(object.abilityId) ? globalThis.Number(object.abilityId) : -1,
      slot: isSet(object.slot) ? globalThis.Number(object.slot) : 0,
      learned: isSet(object.learned) ? globalThis.Boolean(object.learned) : false,
    };
  },

  toJSON(message: CDOTAUserMsgTalentTreeAlert): unknown {
    const obj: any = {};
    if (message.playerId !== undefined && message.playerId !== -1) {
      obj.playerId = Math.round(message.playerId);
    }
    if (message.targetEntindex !== undefined && message.targetEntindex !== -1) {
      obj.targetEntindex = Math.round(message.targetEntindex);
    }
    if (message.abilityId !== undefined && message.abilityId !== -1) {
      obj.abilityId = Math.round(message.abilityId);
    }
    if (message.slot !== undefined && message.slot !== 0) {
      obj.slot = Math.round(message.slot);
    }
    if (message.learned !== undefined && message.learned !== false) {
      obj.learned = message.learned;
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgTalentTreeAlert>): CDOTAUserMsgTalentTreeAlert {
    return CDOTAUserMsgTalentTreeAlert.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgTalentTreeAlert>): CDOTAUserMsgTalentTreeAlert {
    const message = createBaseCDOTAUserMsgTalentTreeAlert();
    message.playerId = object.playerId ?? -1;
    message.targetEntindex = object.targetEntindex ?? -1;
    message.abilityId = object.abilityId ?? -1;
    message.slot = object.slot ?? 0;
    message.learned = object.learned ?? false;
    return message;
  },
};

function createBaseCDOTAUserMsgUpdateQuestProgress(): CDOTAUserMsgUpdateQuestProgress {
  return {};
}

export const CDOTAUserMsgUpdateQuestProgress = {
  encode(_: CDOTAUserMsgUpdateQuestProgress, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgUpdateQuestProgress {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgUpdateQuestProgress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CDOTAUserMsgUpdateQuestProgress {
    return {};
  },

  toJSON(_: CDOTAUserMsgUpdateQuestProgress): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgUpdateQuestProgress>): CDOTAUserMsgUpdateQuestProgress {
    return CDOTAUserMsgUpdateQuestProgress.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<CDOTAUserMsgUpdateQuestProgress>): CDOTAUserMsgUpdateQuestProgress {
    const message = createBaseCDOTAUserMsgUpdateQuestProgress();
    return message;
  },
};

function createBaseCDOTAUserMsgQuestStatus(): CDOTAUserMsgQuestStatus {
  return {
    playerId: -1,
    questId: 0,
    challengeId: 0,
    progress: 0,
    goal: 0,
    query: 0,
    failGametime: 0,
    itemAbilityId: -1,
  };
}

export const CDOTAUserMsgQuestStatus = {
  encode(message: CDOTAUserMsgQuestStatus, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.playerId !== -1) {
      writer.uint32(8).int32(message.playerId);
    }
    if (message.questId !== undefined && message.questId !== 0) {
      writer.uint32(16).uint32(message.questId);
    }
    if (message.challengeId !== undefined && message.challengeId !== 0) {
      writer.uint32(24).uint32(message.challengeId);
    }
    if (message.progress !== undefined && message.progress !== 0) {
      writer.uint32(32).uint32(message.progress);
    }
    if (message.goal !== undefined && message.goal !== 0) {
      writer.uint32(40).uint32(message.goal);
    }
    if (message.query !== undefined && message.query !== 0) {
      writer.uint32(48).uint32(message.query);
    }
    if (message.failGametime !== undefined && message.failGametime !== 0) {
      writer.uint32(61).float(message.failGametime);
    }
    if (message.itemAbilityId !== undefined && message.itemAbilityId !== -1) {
      writer.uint32(64).int32(message.itemAbilityId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgQuestStatus {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgQuestStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.playerId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.questId = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.challengeId = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.progress = reader.uint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.goal = reader.uint32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.query = reader.uint32();
          continue;
        case 7:
          if (tag !== 61) {
            break;
          }

          message.failGametime = reader.float();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.itemAbilityId = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgQuestStatus {
    return {
      playerId: isSet(object.playerId) ? globalThis.Number(object.playerId) : -1,
      questId: isSet(object.questId) ? globalThis.Number(object.questId) : 0,
      challengeId: isSet(object.challengeId) ? globalThis.Number(object.challengeId) : 0,
      progress: isSet(object.progress) ? globalThis.Number(object.progress) : 0,
      goal: isSet(object.goal) ? globalThis.Number(object.goal) : 0,
      query: isSet(object.query) ? globalThis.Number(object.query) : 0,
      failGametime: isSet(object.failGametime) ? globalThis.Number(object.failGametime) : 0,
      itemAbilityId: isSet(object.itemAbilityId) ? globalThis.Number(object.itemAbilityId) : -1,
    };
  },

  toJSON(message: CDOTAUserMsgQuestStatus): unknown {
    const obj: any = {};
    if (message.playerId !== -1) {
      obj.playerId = Math.round(message.playerId);
    }
    if (message.questId !== undefined && message.questId !== 0) {
      obj.questId = Math.round(message.questId);
    }
    if (message.challengeId !== undefined && message.challengeId !== 0) {
      obj.challengeId = Math.round(message.challengeId);
    }
    if (message.progress !== undefined && message.progress !== 0) {
      obj.progress = Math.round(message.progress);
    }
    if (message.goal !== undefined && message.goal !== 0) {
      obj.goal = Math.round(message.goal);
    }
    if (message.query !== undefined && message.query !== 0) {
      obj.query = Math.round(message.query);
    }
    if (message.failGametime !== undefined && message.failGametime !== 0) {
      obj.failGametime = message.failGametime;
    }
    if (message.itemAbilityId !== undefined && message.itemAbilityId !== -1) {
      obj.itemAbilityId = Math.round(message.itemAbilityId);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgQuestStatus>): CDOTAUserMsgQuestStatus {
    return CDOTAUserMsgQuestStatus.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgQuestStatus>): CDOTAUserMsgQuestStatus {
    const message = createBaseCDOTAUserMsgQuestStatus();
    message.playerId = object.playerId ?? -1;
    message.questId = object.questId ?? 0;
    message.challengeId = object.challengeId ?? 0;
    message.progress = object.progress ?? 0;
    message.goal = object.goal ?? 0;
    message.query = object.query ?? 0;
    message.failGametime = object.failGametime ?? 0;
    message.itemAbilityId = object.itemAbilityId ?? -1;
    return message;
  },
};

function createBaseCDOTAUserMsgSuggestHeroPick(): CDOTAUserMsgSuggestHeroPick {
  return { playerId: -1, heroId: 0, ban: false, facetId: 0 };
}

export const CDOTAUserMsgSuggestHeroPick = {
  encode(message: CDOTAUserMsgSuggestHeroPick, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.playerId !== -1) {
      writer.uint32(8).int32(message.playerId);
    }
    if (message.heroId !== undefined && message.heroId !== 0) {
      writer.uint32(16).uint32(message.heroId);
    }
    if (message.ban !== undefined && message.ban !== false) {
      writer.uint32(24).bool(message.ban);
    }
    if (message.facetId !== undefined && message.facetId !== 0) {
      writer.uint32(32).uint32(message.facetId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgSuggestHeroPick {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgSuggestHeroPick();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.playerId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.heroId = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.ban = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.facetId = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgSuggestHeroPick {
    return {
      playerId: isSet(object.playerId) ? globalThis.Number(object.playerId) : -1,
      heroId: isSet(object.heroId) ? globalThis.Number(object.heroId) : 0,
      ban: isSet(object.ban) ? globalThis.Boolean(object.ban) : false,
      facetId: isSet(object.facetId) ? globalThis.Number(object.facetId) : 0,
    };
  },

  toJSON(message: CDOTAUserMsgSuggestHeroPick): unknown {
    const obj: any = {};
    if (message.playerId !== -1) {
      obj.playerId = Math.round(message.playerId);
    }
    if (message.heroId !== undefined && message.heroId !== 0) {
      obj.heroId = Math.round(message.heroId);
    }
    if (message.ban !== undefined && message.ban !== false) {
      obj.ban = message.ban;
    }
    if (message.facetId !== undefined && message.facetId !== 0) {
      obj.facetId = Math.round(message.facetId);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgSuggestHeroPick>): CDOTAUserMsgSuggestHeroPick {
    return CDOTAUserMsgSuggestHeroPick.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgSuggestHeroPick>): CDOTAUserMsgSuggestHeroPick {
    const message = createBaseCDOTAUserMsgSuggestHeroPick();
    message.playerId = object.playerId ?? -1;
    message.heroId = object.heroId ?? 0;
    message.ban = object.ban ?? false;
    message.facetId = object.facetId ?? 0;
    return message;
  },
};

function createBaseCDOTAUserMsgSuggestHeroRole(): CDOTAUserMsgSuggestHeroRole {
  return { playerId: -1, heroRole: "" };
}

export const CDOTAUserMsgSuggestHeroRole = {
  encode(message: CDOTAUserMsgSuggestHeroRole, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.playerId !== -1) {
      writer.uint32(8).int32(message.playerId);
    }
    if (message.heroRole !== undefined && message.heroRole !== "") {
      writer.uint32(18).string(message.heroRole);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgSuggestHeroRole {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgSuggestHeroRole();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.playerId = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.heroRole = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgSuggestHeroRole {
    return {
      playerId: isSet(object.playerId) ? globalThis.Number(object.playerId) : -1,
      heroRole: isSet(object.heroRole) ? globalThis.String(object.heroRole) : "",
    };
  },

  toJSON(message: CDOTAUserMsgSuggestHeroRole): unknown {
    const obj: any = {};
    if (message.playerId !== -1) {
      obj.playerId = Math.round(message.playerId);
    }
    if (message.heroRole !== undefined && message.heroRole !== "") {
      obj.heroRole = message.heroRole;
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgSuggestHeroRole>): CDOTAUserMsgSuggestHeroRole {
    return CDOTAUserMsgSuggestHeroRole.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgSuggestHeroRole>): CDOTAUserMsgSuggestHeroRole {
    const message = createBaseCDOTAUserMsgSuggestHeroRole();
    message.playerId = object.playerId ?? -1;
    message.heroRole = object.heroRole ?? "";
    return message;
  },
};

function createBaseCDOTAUserMsgKillcamDamageTaken(): CDOTAUserMsgKillcamDamageTaken {
  return { playerId: -1, damageTaken: 0, itemType: 0, itemAbilityId: -1, heroName: "", damageColor: "" };
}

export const CDOTAUserMsgKillcamDamageTaken = {
  encode(message: CDOTAUserMsgKillcamDamageTaken, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.playerId !== -1) {
      writer.uint32(8).int32(message.playerId);
    }
    if (message.damageTaken !== undefined && message.damageTaken !== 0) {
      writer.uint32(16).uint32(message.damageTaken);
    }
    if (message.itemType !== undefined && message.itemType !== 0) {
      writer.uint32(24).uint32(message.itemType);
    }
    if (message.itemAbilityId !== undefined && message.itemAbilityId !== -1) {
      writer.uint32(32).int32(message.itemAbilityId);
    }
    if (message.heroName !== undefined && message.heroName !== "") {
      writer.uint32(42).string(message.heroName);
    }
    if (message.damageColor !== undefined && message.damageColor !== "") {
      writer.uint32(50).string(message.damageColor);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgKillcamDamageTaken {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgKillcamDamageTaken();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.playerId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.damageTaken = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.itemType = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.itemAbilityId = reader.int32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.heroName = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.damageColor = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgKillcamDamageTaken {
    return {
      playerId: isSet(object.playerId) ? globalThis.Number(object.playerId) : -1,
      damageTaken: isSet(object.damageTaken) ? globalThis.Number(object.damageTaken) : 0,
      itemType: isSet(object.itemType) ? globalThis.Number(object.itemType) : 0,
      itemAbilityId: isSet(object.itemAbilityId) ? globalThis.Number(object.itemAbilityId) : -1,
      heroName: isSet(object.heroName) ? globalThis.String(object.heroName) : "",
      damageColor: isSet(object.damageColor) ? globalThis.String(object.damageColor) : "",
    };
  },

  toJSON(message: CDOTAUserMsgKillcamDamageTaken): unknown {
    const obj: any = {};
    if (message.playerId !== -1) {
      obj.playerId = Math.round(message.playerId);
    }
    if (message.damageTaken !== undefined && message.damageTaken !== 0) {
      obj.damageTaken = Math.round(message.damageTaken);
    }
    if (message.itemType !== undefined && message.itemType !== 0) {
      obj.itemType = Math.round(message.itemType);
    }
    if (message.itemAbilityId !== undefined && message.itemAbilityId !== -1) {
      obj.itemAbilityId = Math.round(message.itemAbilityId);
    }
    if (message.heroName !== undefined && message.heroName !== "") {
      obj.heroName = message.heroName;
    }
    if (message.damageColor !== undefined && message.damageColor !== "") {
      obj.damageColor = message.damageColor;
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgKillcamDamageTaken>): CDOTAUserMsgKillcamDamageTaken {
    return CDOTAUserMsgKillcamDamageTaken.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgKillcamDamageTaken>): CDOTAUserMsgKillcamDamageTaken {
    const message = createBaseCDOTAUserMsgKillcamDamageTaken();
    message.playerId = object.playerId ?? -1;
    message.damageTaken = object.damageTaken ?? 0;
    message.itemType = object.itemType ?? 0;
    message.itemAbilityId = object.itemAbilityId ?? -1;
    message.heroName = object.heroName ?? "";
    message.damageColor = object.damageColor ?? "";
    return message;
  },
};

function createBaseCDOTAUserMsgSelectPenaltyGold(): CDOTAUserMsgSelectPenaltyGold {
  return { playerId: -1, cost: 0 };
}

export const CDOTAUserMsgSelectPenaltyGold = {
  encode(message: CDOTAUserMsgSelectPenaltyGold, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.playerId !== -1) {
      writer.uint32(8).int32(message.playerId);
    }
    if (message.cost !== undefined && message.cost !== 0) {
      writer.uint32(16).sint32(message.cost);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgSelectPenaltyGold {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgSelectPenaltyGold();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.playerId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.cost = reader.sint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgSelectPenaltyGold {
    return {
      playerId: isSet(object.playerId) ? globalThis.Number(object.playerId) : -1,
      cost: isSet(object.cost) ? globalThis.Number(object.cost) : 0,
    };
  },

  toJSON(message: CDOTAUserMsgSelectPenaltyGold): unknown {
    const obj: any = {};
    if (message.playerId !== -1) {
      obj.playerId = Math.round(message.playerId);
    }
    if (message.cost !== undefined && message.cost !== 0) {
      obj.cost = Math.round(message.cost);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgSelectPenaltyGold>): CDOTAUserMsgSelectPenaltyGold {
    return CDOTAUserMsgSelectPenaltyGold.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgSelectPenaltyGold>): CDOTAUserMsgSelectPenaltyGold {
    const message = createBaseCDOTAUserMsgSelectPenaltyGold();
    message.playerId = object.playerId ?? -1;
    message.cost = object.cost ?? 0;
    return message;
  },
};

function createBaseCDOTAUserMsgRollDiceResult(): CDOTAUserMsgRollDiceResult {
  return { playerId: -1, channelType: 0, rollMin: 0, rollMax: 0, result: 0 };
}

export const CDOTAUserMsgRollDiceResult = {
  encode(message: CDOTAUserMsgRollDiceResult, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.playerId !== undefined && message.playerId !== -1) {
      writer.uint32(8).int32(message.playerId);
    }
    if (message.channelType !== undefined && message.channelType !== 0) {
      writer.uint32(16).uint32(message.channelType);
    }
    if (message.rollMin !== undefined && message.rollMin !== 0) {
      writer.uint32(24).uint32(message.rollMin);
    }
    if (message.rollMax !== undefined && message.rollMax !== 0) {
      writer.uint32(32).uint32(message.rollMax);
    }
    if (message.result !== undefined && message.result !== 0) {
      writer.uint32(40).uint32(message.result);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgRollDiceResult {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgRollDiceResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.playerId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.channelType = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.rollMin = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.rollMax = reader.uint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.result = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgRollDiceResult {
    return {
      playerId: isSet(object.playerId) ? globalThis.Number(object.playerId) : -1,
      channelType: isSet(object.channelType) ? globalThis.Number(object.channelType) : 0,
      rollMin: isSet(object.rollMin) ? globalThis.Number(object.rollMin) : 0,
      rollMax: isSet(object.rollMax) ? globalThis.Number(object.rollMax) : 0,
      result: isSet(object.result) ? globalThis.Number(object.result) : 0,
    };
  },

  toJSON(message: CDOTAUserMsgRollDiceResult): unknown {
    const obj: any = {};
    if (message.playerId !== undefined && message.playerId !== -1) {
      obj.playerId = Math.round(message.playerId);
    }
    if (message.channelType !== undefined && message.channelType !== 0) {
      obj.channelType = Math.round(message.channelType);
    }
    if (message.rollMin !== undefined && message.rollMin !== 0) {
      obj.rollMin = Math.round(message.rollMin);
    }
    if (message.rollMax !== undefined && message.rollMax !== 0) {
      obj.rollMax = Math.round(message.rollMax);
    }
    if (message.result !== undefined && message.result !== 0) {
      obj.result = Math.round(message.result);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgRollDiceResult>): CDOTAUserMsgRollDiceResult {
    return CDOTAUserMsgRollDiceResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgRollDiceResult>): CDOTAUserMsgRollDiceResult {
    const message = createBaseCDOTAUserMsgRollDiceResult();
    message.playerId = object.playerId ?? -1;
    message.channelType = object.channelType ?? 0;
    message.rollMin = object.rollMin ?? 0;
    message.rollMax = object.rollMax ?? 0;
    message.result = object.result ?? 0;
    return message;
  },
};

function createBaseCDOTAUserMsgFlipCoinResult(): CDOTAUserMsgFlipCoinResult {
  return { playerId: -1, channelType: 0, result: false };
}

export const CDOTAUserMsgFlipCoinResult = {
  encode(message: CDOTAUserMsgFlipCoinResult, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.playerId !== undefined && message.playerId !== -1) {
      writer.uint32(8).int32(message.playerId);
    }
    if (message.channelType !== undefined && message.channelType !== 0) {
      writer.uint32(16).uint32(message.channelType);
    }
    if (message.result !== undefined && message.result !== false) {
      writer.uint32(24).bool(message.result);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgFlipCoinResult {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgFlipCoinResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.playerId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.channelType = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.result = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgFlipCoinResult {
    return {
      playerId: isSet(object.playerId) ? globalThis.Number(object.playerId) : -1,
      channelType: isSet(object.channelType) ? globalThis.Number(object.channelType) : 0,
      result: isSet(object.result) ? globalThis.Boolean(object.result) : false,
    };
  },

  toJSON(message: CDOTAUserMsgFlipCoinResult): unknown {
    const obj: any = {};
    if (message.playerId !== undefined && message.playerId !== -1) {
      obj.playerId = Math.round(message.playerId);
    }
    if (message.channelType !== undefined && message.channelType !== 0) {
      obj.channelType = Math.round(message.channelType);
    }
    if (message.result !== undefined && message.result !== false) {
      obj.result = message.result;
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgFlipCoinResult>): CDOTAUserMsgFlipCoinResult {
    return CDOTAUserMsgFlipCoinResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgFlipCoinResult>): CDOTAUserMsgFlipCoinResult {
    const message = createBaseCDOTAUserMsgFlipCoinResult();
    message.playerId = object.playerId ?? -1;
    message.channelType = object.channelType ?? 0;
    message.result = object.result ?? false;
    return message;
  },
};

function createBaseCDOTAUserMessageRequestItemSuggestions(): CDOTAUserMessageRequestItemSuggestions {
  return { playerId: -1 };
}

export const CDOTAUserMessageRequestItemSuggestions = {
  encode(message: CDOTAUserMessageRequestItemSuggestions, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.playerId !== undefined && message.playerId !== -1) {
      writer.uint32(8).int32(message.playerId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMessageRequestItemSuggestions {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMessageRequestItemSuggestions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.playerId = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMessageRequestItemSuggestions {
    return { playerId: isSet(object.playerId) ? globalThis.Number(object.playerId) : -1 };
  },

  toJSON(message: CDOTAUserMessageRequestItemSuggestions): unknown {
    const obj: any = {};
    if (message.playerId !== undefined && message.playerId !== -1) {
      obj.playerId = Math.round(message.playerId);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMessageRequestItemSuggestions>): CDOTAUserMessageRequestItemSuggestions {
    return CDOTAUserMessageRequestItemSuggestions.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMessageRequestItemSuggestions>): CDOTAUserMessageRequestItemSuggestions {
    const message = createBaseCDOTAUserMessageRequestItemSuggestions();
    message.playerId = object.playerId ?? -1;
    return message;
  },
};

function createBaseCDOTAUserMessageTeamCaptainChanged(): CDOTAUserMessageTeamCaptainChanged {
  return { team: 0, captainPlayerId: -1 };
}

export const CDOTAUserMessageTeamCaptainChanged = {
  encode(message: CDOTAUserMessageTeamCaptainChanged, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.team !== undefined && message.team !== 0) {
      writer.uint32(8).uint32(message.team);
    }
    if (message.captainPlayerId !== undefined && message.captainPlayerId !== -1) {
      writer.uint32(16).int32(message.captainPlayerId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMessageTeamCaptainChanged {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMessageTeamCaptainChanged();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.team = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.captainPlayerId = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMessageTeamCaptainChanged {
    return {
      team: isSet(object.team) ? globalThis.Number(object.team) : 0,
      captainPlayerId: isSet(object.captainPlayerId) ? globalThis.Number(object.captainPlayerId) : -1,
    };
  },

  toJSON(message: CDOTAUserMessageTeamCaptainChanged): unknown {
    const obj: any = {};
    if (message.team !== undefined && message.team !== 0) {
      obj.team = Math.round(message.team);
    }
    if (message.captainPlayerId !== undefined && message.captainPlayerId !== -1) {
      obj.captainPlayerId = Math.round(message.captainPlayerId);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMessageTeamCaptainChanged>): CDOTAUserMessageTeamCaptainChanged {
    return CDOTAUserMessageTeamCaptainChanged.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMessageTeamCaptainChanged>): CDOTAUserMessageTeamCaptainChanged {
    const message = createBaseCDOTAUserMessageTeamCaptainChanged();
    message.team = object.team ?? 0;
    message.captainPlayerId = object.captainPlayerId ?? -1;
    return message;
  },
};

function createBaseCDOTAUserMsgChatWheelCooldown(): CDOTAUserMsgChatWheelCooldown {
  return { messageId: 4294967295, cooldownRemaining: 0 };
}

export const CDOTAUserMsgChatWheelCooldown = {
  encode(message: CDOTAUserMsgChatWheelCooldown, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.messageId !== undefined && message.messageId !== 4294967295) {
      writer.uint32(8).uint32(message.messageId);
    }
    if (message.cooldownRemaining !== undefined && message.cooldownRemaining !== 0) {
      writer.uint32(21).float(message.cooldownRemaining);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgChatWheelCooldown {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgChatWheelCooldown();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.messageId = reader.uint32();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.cooldownRemaining = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgChatWheelCooldown {
    return {
      messageId: isSet(object.messageId) ? globalThis.Number(object.messageId) : 4294967295,
      cooldownRemaining: isSet(object.cooldownRemaining) ? globalThis.Number(object.cooldownRemaining) : 0,
    };
  },

  toJSON(message: CDOTAUserMsgChatWheelCooldown): unknown {
    const obj: any = {};
    if (message.messageId !== undefined && message.messageId !== 4294967295) {
      obj.messageId = Math.round(message.messageId);
    }
    if (message.cooldownRemaining !== undefined && message.cooldownRemaining !== 0) {
      obj.cooldownRemaining = message.cooldownRemaining;
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgChatWheelCooldown>): CDOTAUserMsgChatWheelCooldown {
    return CDOTAUserMsgChatWheelCooldown.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgChatWheelCooldown>): CDOTAUserMsgChatWheelCooldown {
    const message = createBaseCDOTAUserMsgChatWheelCooldown();
    message.messageId = object.messageId ?? 4294967295;
    message.cooldownRemaining = object.cooldownRemaining ?? 0;
    return message;
  },
};

function createBaseCDOTAUserMsgHeroRelicProgress(): CDOTAUserMsgHeroRelicProgress {
  return { heroRelicType: 0, value: 0, ehandle: 16777215, eventId: 0, valueDisplay: 0 };
}

export const CDOTAUserMsgHeroRelicProgress = {
  encode(message: CDOTAUserMsgHeroRelicProgress, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.heroRelicType !== undefined && message.heroRelicType !== 0) {
      writer.uint32(8).uint32(message.heroRelicType);
    }
    if (message.value !== undefined && message.value !== 0) {
      writer.uint32(16).uint32(message.value);
    }
    if (message.ehandle !== undefined && message.ehandle !== 16777215) {
      writer.uint32(24).uint32(message.ehandle);
    }
    if (message.eventId !== undefined && message.eventId !== 0) {
      writer.uint32(32).uint32(message.eventId);
    }
    if (message.valueDisplay !== undefined && message.valueDisplay !== 0) {
      writer.uint32(45).float(message.valueDisplay);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgHeroRelicProgress {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgHeroRelicProgress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.heroRelicType = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.value = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.ehandle = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.eventId = reader.uint32();
          continue;
        case 5:
          if (tag !== 45) {
            break;
          }

          message.valueDisplay = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgHeroRelicProgress {
    return {
      heroRelicType: isSet(object.heroRelicType) ? globalThis.Number(object.heroRelicType) : 0,
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
      ehandle: isSet(object.ehandle) ? globalThis.Number(object.ehandle) : 16777215,
      eventId: isSet(object.eventId) ? globalThis.Number(object.eventId) : 0,
      valueDisplay: isSet(object.valueDisplay) ? globalThis.Number(object.valueDisplay) : 0,
    };
  },

  toJSON(message: CDOTAUserMsgHeroRelicProgress): unknown {
    const obj: any = {};
    if (message.heroRelicType !== undefined && message.heroRelicType !== 0) {
      obj.heroRelicType = Math.round(message.heroRelicType);
    }
    if (message.value !== undefined && message.value !== 0) {
      obj.value = Math.round(message.value);
    }
    if (message.ehandle !== undefined && message.ehandle !== 16777215) {
      obj.ehandle = Math.round(message.ehandle);
    }
    if (message.eventId !== undefined && message.eventId !== 0) {
      obj.eventId = Math.round(message.eventId);
    }
    if (message.valueDisplay !== undefined && message.valueDisplay !== 0) {
      obj.valueDisplay = message.valueDisplay;
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgHeroRelicProgress>): CDOTAUserMsgHeroRelicProgress {
    return CDOTAUserMsgHeroRelicProgress.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgHeroRelicProgress>): CDOTAUserMsgHeroRelicProgress {
    const message = createBaseCDOTAUserMsgHeroRelicProgress();
    message.heroRelicType = object.heroRelicType ?? 0;
    message.value = object.value ?? 0;
    message.ehandle = object.ehandle ?? 16777215;
    message.eventId = object.eventId ?? 0;
    message.valueDisplay = object.valueDisplay ?? 0;
    return message;
  },
};

function createBaseCDOTAUserMsgAbilityDraftRequestAbility(): CDOTAUserMsgAbilityDraftRequestAbility {
  return { playerId: -1, requestedAbilityId: -1, ctrlIsDown: false };
}

export const CDOTAUserMsgAbilityDraftRequestAbility = {
  encode(message: CDOTAUserMsgAbilityDraftRequestAbility, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.playerId !== undefined && message.playerId !== -1) {
      writer.uint32(8).int32(message.playerId);
    }
    if (message.requestedAbilityId !== undefined && message.requestedAbilityId !== -1) {
      writer.uint32(16).int32(message.requestedAbilityId);
    }
    if (message.ctrlIsDown !== undefined && message.ctrlIsDown !== false) {
      writer.uint32(24).bool(message.ctrlIsDown);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgAbilityDraftRequestAbility {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgAbilityDraftRequestAbility();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.playerId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.requestedAbilityId = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.ctrlIsDown = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgAbilityDraftRequestAbility {
    return {
      playerId: isSet(object.playerId) ? globalThis.Number(object.playerId) : -1,
      requestedAbilityId: isSet(object.requestedAbilityId) ? globalThis.Number(object.requestedAbilityId) : -1,
      ctrlIsDown: isSet(object.ctrlIsDown) ? globalThis.Boolean(object.ctrlIsDown) : false,
    };
  },

  toJSON(message: CDOTAUserMsgAbilityDraftRequestAbility): unknown {
    const obj: any = {};
    if (message.playerId !== undefined && message.playerId !== -1) {
      obj.playerId = Math.round(message.playerId);
    }
    if (message.requestedAbilityId !== undefined && message.requestedAbilityId !== -1) {
      obj.requestedAbilityId = Math.round(message.requestedAbilityId);
    }
    if (message.ctrlIsDown !== undefined && message.ctrlIsDown !== false) {
      obj.ctrlIsDown = message.ctrlIsDown;
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgAbilityDraftRequestAbility>): CDOTAUserMsgAbilityDraftRequestAbility {
    return CDOTAUserMsgAbilityDraftRequestAbility.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgAbilityDraftRequestAbility>): CDOTAUserMsgAbilityDraftRequestAbility {
    const message = createBaseCDOTAUserMsgAbilityDraftRequestAbility();
    message.playerId = object.playerId ?? -1;
    message.requestedAbilityId = object.requestedAbilityId ?? -1;
    message.ctrlIsDown = object.ctrlIsDown ?? false;
    return message;
  },
};

function createBaseCDOTAUserMsgDamageReport(): CDOTAUserMsgDamageReport {
  return { playerId: -1, targetHeroId: 0, sourceHeroId: 0, damageAmount: 0, broadcast: false };
}

export const CDOTAUserMsgDamageReport = {
  encode(message: CDOTAUserMsgDamageReport, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.playerId !== undefined && message.playerId !== -1) {
      writer.uint32(8).int32(message.playerId);
    }
    if (message.targetHeroId !== undefined && message.targetHeroId !== 0) {
      writer.uint32(16).uint32(message.targetHeroId);
    }
    if (message.sourceHeroId !== undefined && message.sourceHeroId !== 0) {
      writer.uint32(24).uint32(message.sourceHeroId);
    }
    if (message.damageAmount !== undefined && message.damageAmount !== 0) {
      writer.uint32(32).int32(message.damageAmount);
    }
    if (message.broadcast !== undefined && message.broadcast !== false) {
      writer.uint32(40).bool(message.broadcast);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgDamageReport {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgDamageReport();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.playerId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.targetHeroId = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.sourceHeroId = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.damageAmount = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.broadcast = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgDamageReport {
    return {
      playerId: isSet(object.playerId) ? globalThis.Number(object.playerId) : -1,
      targetHeroId: isSet(object.targetHeroId) ? globalThis.Number(object.targetHeroId) : 0,
      sourceHeroId: isSet(object.sourceHeroId) ? globalThis.Number(object.sourceHeroId) : 0,
      damageAmount: isSet(object.damageAmount) ? globalThis.Number(object.damageAmount) : 0,
      broadcast: isSet(object.broadcast) ? globalThis.Boolean(object.broadcast) : false,
    };
  },

  toJSON(message: CDOTAUserMsgDamageReport): unknown {
    const obj: any = {};
    if (message.playerId !== undefined && message.playerId !== -1) {
      obj.playerId = Math.round(message.playerId);
    }
    if (message.targetHeroId !== undefined && message.targetHeroId !== 0) {
      obj.targetHeroId = Math.round(message.targetHeroId);
    }
    if (message.sourceHeroId !== undefined && message.sourceHeroId !== 0) {
      obj.sourceHeroId = Math.round(message.sourceHeroId);
    }
    if (message.damageAmount !== undefined && message.damageAmount !== 0) {
      obj.damageAmount = Math.round(message.damageAmount);
    }
    if (message.broadcast !== undefined && message.broadcast !== false) {
      obj.broadcast = message.broadcast;
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgDamageReport>): CDOTAUserMsgDamageReport {
    return CDOTAUserMsgDamageReport.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgDamageReport>): CDOTAUserMsgDamageReport {
    const message = createBaseCDOTAUserMsgDamageReport();
    message.playerId = object.playerId ?? -1;
    message.targetHeroId = object.targetHeroId ?? 0;
    message.sourceHeroId = object.sourceHeroId ?? 0;
    message.damageAmount = object.damageAmount ?? 0;
    message.broadcast = object.broadcast ?? false;
    return message;
  },
};

function createBaseCDOTAUserMsgSalutePlayer(): CDOTAUserMsgSalutePlayer {
  return { sourcePlayerId: -1, targetPlayerId: -1, tipAmount: 0, eventId: 0, customTipStyle: "", numRecentTips: 0 };
}

export const CDOTAUserMsgSalutePlayer = {
  encode(message: CDOTAUserMsgSalutePlayer, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sourcePlayerId !== undefined && message.sourcePlayerId !== -1) {
      writer.uint32(8).int32(message.sourcePlayerId);
    }
    if (message.targetPlayerId !== undefined && message.targetPlayerId !== -1) {
      writer.uint32(16).int32(message.targetPlayerId);
    }
    if (message.tipAmount !== undefined && message.tipAmount !== 0) {
      writer.uint32(24).uint32(message.tipAmount);
    }
    if (message.eventId !== undefined && message.eventId !== 0) {
      writer.uint32(32).uint32(message.eventId);
    }
    if (message.customTipStyle !== undefined && message.customTipStyle !== "") {
      writer.uint32(42).string(message.customTipStyle);
    }
    if (message.numRecentTips !== undefined && message.numRecentTips !== 0) {
      writer.uint32(48).uint32(message.numRecentTips);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgSalutePlayer {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgSalutePlayer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.sourcePlayerId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.targetPlayerId = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.tipAmount = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.eventId = reader.uint32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.customTipStyle = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.numRecentTips = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgSalutePlayer {
    return {
      sourcePlayerId: isSet(object.sourcePlayerId) ? globalThis.Number(object.sourcePlayerId) : -1,
      targetPlayerId: isSet(object.targetPlayerId) ? globalThis.Number(object.targetPlayerId) : -1,
      tipAmount: isSet(object.tipAmount) ? globalThis.Number(object.tipAmount) : 0,
      eventId: isSet(object.eventId) ? globalThis.Number(object.eventId) : 0,
      customTipStyle: isSet(object.customTipStyle) ? globalThis.String(object.customTipStyle) : "",
      numRecentTips: isSet(object.numRecentTips) ? globalThis.Number(object.numRecentTips) : 0,
    };
  },

  toJSON(message: CDOTAUserMsgSalutePlayer): unknown {
    const obj: any = {};
    if (message.sourcePlayerId !== undefined && message.sourcePlayerId !== -1) {
      obj.sourcePlayerId = Math.round(message.sourcePlayerId);
    }
    if (message.targetPlayerId !== undefined && message.targetPlayerId !== -1) {
      obj.targetPlayerId = Math.round(message.targetPlayerId);
    }
    if (message.tipAmount !== undefined && message.tipAmount !== 0) {
      obj.tipAmount = Math.round(message.tipAmount);
    }
    if (message.eventId !== undefined && message.eventId !== 0) {
      obj.eventId = Math.round(message.eventId);
    }
    if (message.customTipStyle !== undefined && message.customTipStyle !== "") {
      obj.customTipStyle = message.customTipStyle;
    }
    if (message.numRecentTips !== undefined && message.numRecentTips !== 0) {
      obj.numRecentTips = Math.round(message.numRecentTips);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgSalutePlayer>): CDOTAUserMsgSalutePlayer {
    return CDOTAUserMsgSalutePlayer.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgSalutePlayer>): CDOTAUserMsgSalutePlayer {
    const message = createBaseCDOTAUserMsgSalutePlayer();
    message.sourcePlayerId = object.sourcePlayerId ?? -1;
    message.targetPlayerId = object.targetPlayerId ?? -1;
    message.tipAmount = object.tipAmount ?? 0;
    message.eventId = object.eventId ?? 0;
    message.customTipStyle = object.customTipStyle ?? "";
    message.numRecentTips = object.numRecentTips ?? 0;
    return message;
  },
};

function createBaseCDOTAUserMsgGiftPlayer(): CDOTAUserMsgGiftPlayer {
  return { sourcePlayerId: -1, targetPlayerId: -1, giftItemDefIndex: 0 };
}

export const CDOTAUserMsgGiftPlayer = {
  encode(message: CDOTAUserMsgGiftPlayer, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sourcePlayerId !== undefined && message.sourcePlayerId !== -1) {
      writer.uint32(8).int32(message.sourcePlayerId);
    }
    if (message.targetPlayerId !== undefined && message.targetPlayerId !== -1) {
      writer.uint32(16).int32(message.targetPlayerId);
    }
    if (message.giftItemDefIndex !== undefined && message.giftItemDefIndex !== 0) {
      writer.uint32(24).uint32(message.giftItemDefIndex);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgGiftPlayer {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgGiftPlayer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.sourcePlayerId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.targetPlayerId = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.giftItemDefIndex = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgGiftPlayer {
    return {
      sourcePlayerId: isSet(object.sourcePlayerId) ? globalThis.Number(object.sourcePlayerId) : -1,
      targetPlayerId: isSet(object.targetPlayerId) ? globalThis.Number(object.targetPlayerId) : -1,
      giftItemDefIndex: isSet(object.giftItemDefIndex) ? globalThis.Number(object.giftItemDefIndex) : 0,
    };
  },

  toJSON(message: CDOTAUserMsgGiftPlayer): unknown {
    const obj: any = {};
    if (message.sourcePlayerId !== undefined && message.sourcePlayerId !== -1) {
      obj.sourcePlayerId = Math.round(message.sourcePlayerId);
    }
    if (message.targetPlayerId !== undefined && message.targetPlayerId !== -1) {
      obj.targetPlayerId = Math.round(message.targetPlayerId);
    }
    if (message.giftItemDefIndex !== undefined && message.giftItemDefIndex !== 0) {
      obj.giftItemDefIndex = Math.round(message.giftItemDefIndex);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgGiftPlayer>): CDOTAUserMsgGiftPlayer {
    return CDOTAUserMsgGiftPlayer.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgGiftPlayer>): CDOTAUserMsgGiftPlayer {
    const message = createBaseCDOTAUserMsgGiftPlayer();
    message.sourcePlayerId = object.sourcePlayerId ?? -1;
    message.targetPlayerId = object.targetPlayerId ?? -1;
    message.giftItemDefIndex = object.giftItemDefIndex ?? 0;
    return message;
  },
};

function createBaseCDOTAUserMsgTipAlert(): CDOTAUserMsgTipAlert {
  return { playerId: -1, tipText: "" };
}

export const CDOTAUserMsgTipAlert = {
  encode(message: CDOTAUserMsgTipAlert, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.playerId !== undefined && message.playerId !== -1) {
      writer.uint32(8).int32(message.playerId);
    }
    if (message.tipText !== undefined && message.tipText !== "") {
      writer.uint32(18).string(message.tipText);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgTipAlert {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgTipAlert();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.playerId = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.tipText = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgTipAlert {
    return {
      playerId: isSet(object.playerId) ? globalThis.Number(object.playerId) : -1,
      tipText: isSet(object.tipText) ? globalThis.String(object.tipText) : "",
    };
  },

  toJSON(message: CDOTAUserMsgTipAlert): unknown {
    const obj: any = {};
    if (message.playerId !== undefined && message.playerId !== -1) {
      obj.playerId = Math.round(message.playerId);
    }
    if (message.tipText !== undefined && message.tipText !== "") {
      obj.tipText = message.tipText;
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgTipAlert>): CDOTAUserMsgTipAlert {
    return CDOTAUserMsgTipAlert.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgTipAlert>): CDOTAUserMsgTipAlert {
    const message = createBaseCDOTAUserMsgTipAlert();
    message.playerId = object.playerId ?? -1;
    message.tipText = object.tipText ?? "";
    return message;
  },
};

function createBaseCDOTAUserMsgReplaceQueryUnit(): CDOTAUserMsgReplaceQueryUnit {
  return { playerId: -1, sourceEntindex: -1, targetEntindex: -1 };
}

export const CDOTAUserMsgReplaceQueryUnit = {
  encode(message: CDOTAUserMsgReplaceQueryUnit, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.playerId !== -1) {
      writer.uint32(8).int32(message.playerId);
    }
    if (message.sourceEntindex !== undefined && message.sourceEntindex !== -1) {
      writer.uint32(16).int32(message.sourceEntindex);
    }
    if (message.targetEntindex !== undefined && message.targetEntindex !== -1) {
      writer.uint32(24).int32(message.targetEntindex);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgReplaceQueryUnit {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgReplaceQueryUnit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.playerId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.sourceEntindex = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.targetEntindex = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgReplaceQueryUnit {
    return {
      playerId: isSet(object.playerId) ? globalThis.Number(object.playerId) : -1,
      sourceEntindex: isSet(object.sourceEntindex) ? globalThis.Number(object.sourceEntindex) : -1,
      targetEntindex: isSet(object.targetEntindex) ? globalThis.Number(object.targetEntindex) : -1,
    };
  },

  toJSON(message: CDOTAUserMsgReplaceQueryUnit): unknown {
    const obj: any = {};
    if (message.playerId !== -1) {
      obj.playerId = Math.round(message.playerId);
    }
    if (message.sourceEntindex !== undefined && message.sourceEntindex !== -1) {
      obj.sourceEntindex = Math.round(message.sourceEntindex);
    }
    if (message.targetEntindex !== undefined && message.targetEntindex !== -1) {
      obj.targetEntindex = Math.round(message.targetEntindex);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgReplaceQueryUnit>): CDOTAUserMsgReplaceQueryUnit {
    return CDOTAUserMsgReplaceQueryUnit.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgReplaceQueryUnit>): CDOTAUserMsgReplaceQueryUnit {
    const message = createBaseCDOTAUserMsgReplaceQueryUnit();
    message.playerId = object.playerId ?? -1;
    message.sourceEntindex = object.sourceEntindex ?? -1;
    message.targetEntindex = object.targetEntindex ?? -1;
    return message;
  },
};

function createBaseCDOTAUserMsgESArcanaCombo(): CDOTAUserMsgESArcanaCombo {
  return { ehandle: 16777215, comboCount: 0, arcanaLevel: 0 };
}

export const CDOTAUserMsgESArcanaCombo = {
  encode(message: CDOTAUserMsgESArcanaCombo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.ehandle !== undefined && message.ehandle !== 16777215) {
      writer.uint32(8).uint32(message.ehandle);
    }
    if (message.comboCount !== undefined && message.comboCount !== 0) {
      writer.uint32(16).uint32(message.comboCount);
    }
    if (message.arcanaLevel !== undefined && message.arcanaLevel !== 0) {
      writer.uint32(24).uint32(message.arcanaLevel);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgESArcanaCombo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgESArcanaCombo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.ehandle = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.comboCount = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.arcanaLevel = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgESArcanaCombo {
    return {
      ehandle: isSet(object.ehandle) ? globalThis.Number(object.ehandle) : 16777215,
      comboCount: isSet(object.comboCount) ? globalThis.Number(object.comboCount) : 0,
      arcanaLevel: isSet(object.arcanaLevel) ? globalThis.Number(object.arcanaLevel) : 0,
    };
  },

  toJSON(message: CDOTAUserMsgESArcanaCombo): unknown {
    const obj: any = {};
    if (message.ehandle !== undefined && message.ehandle !== 16777215) {
      obj.ehandle = Math.round(message.ehandle);
    }
    if (message.comboCount !== undefined && message.comboCount !== 0) {
      obj.comboCount = Math.round(message.comboCount);
    }
    if (message.arcanaLevel !== undefined && message.arcanaLevel !== 0) {
      obj.arcanaLevel = Math.round(message.arcanaLevel);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgESArcanaCombo>): CDOTAUserMsgESArcanaCombo {
    return CDOTAUserMsgESArcanaCombo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgESArcanaCombo>): CDOTAUserMsgESArcanaCombo {
    const message = createBaseCDOTAUserMsgESArcanaCombo();
    message.ehandle = object.ehandle ?? 16777215;
    message.comboCount = object.comboCount ?? 0;
    message.arcanaLevel = object.arcanaLevel ?? 0;
    return message;
  },
};

function createBaseCDOTAUserMsgESArcanaComboSummary(): CDOTAUserMsgESArcanaComboSummary {
  return { ehandle: 16777215, comboCount: 0, damageAmount: 0 };
}

export const CDOTAUserMsgESArcanaComboSummary = {
  encode(message: CDOTAUserMsgESArcanaComboSummary, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.ehandle !== undefined && message.ehandle !== 16777215) {
      writer.uint32(8).uint32(message.ehandle);
    }
    if (message.comboCount !== undefined && message.comboCount !== 0) {
      writer.uint32(16).uint32(message.comboCount);
    }
    if (message.damageAmount !== undefined && message.damageAmount !== 0) {
      writer.uint32(24).uint32(message.damageAmount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgESArcanaComboSummary {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgESArcanaComboSummary();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.ehandle = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.comboCount = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.damageAmount = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgESArcanaComboSummary {
    return {
      ehandle: isSet(object.ehandle) ? globalThis.Number(object.ehandle) : 16777215,
      comboCount: isSet(object.comboCount) ? globalThis.Number(object.comboCount) : 0,
      damageAmount: isSet(object.damageAmount) ? globalThis.Number(object.damageAmount) : 0,
    };
  },

  toJSON(message: CDOTAUserMsgESArcanaComboSummary): unknown {
    const obj: any = {};
    if (message.ehandle !== undefined && message.ehandle !== 16777215) {
      obj.ehandle = Math.round(message.ehandle);
    }
    if (message.comboCount !== undefined && message.comboCount !== 0) {
      obj.comboCount = Math.round(message.comboCount);
    }
    if (message.damageAmount !== undefined && message.damageAmount !== 0) {
      obj.damageAmount = Math.round(message.damageAmount);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgESArcanaComboSummary>): CDOTAUserMsgESArcanaComboSummary {
    return CDOTAUserMsgESArcanaComboSummary.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgESArcanaComboSummary>): CDOTAUserMsgESArcanaComboSummary {
    const message = createBaseCDOTAUserMsgESArcanaComboSummary();
    message.ehandle = object.ehandle ?? 16777215;
    message.comboCount = object.comboCount ?? 0;
    message.damageAmount = object.damageAmount ?? 0;
    return message;
  },
};

function createBaseCDOTAUserMsgOMArcanaCombo(): CDOTAUserMsgOMArcanaCombo {
  return { ehandle: 16777215, multicastAmount: 0, arcanaLevel: 0, multicastChance: 0 };
}

export const CDOTAUserMsgOMArcanaCombo = {
  encode(message: CDOTAUserMsgOMArcanaCombo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.ehandle !== undefined && message.ehandle !== 16777215) {
      writer.uint32(8).uint32(message.ehandle);
    }
    if (message.multicastAmount !== undefined && message.multicastAmount !== 0) {
      writer.uint32(16).uint32(message.multicastAmount);
    }
    if (message.arcanaLevel !== undefined && message.arcanaLevel !== 0) {
      writer.uint32(24).uint32(message.arcanaLevel);
    }
    if (message.multicastChance !== undefined && message.multicastChance !== 0) {
      writer.uint32(32).uint32(message.multicastChance);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgOMArcanaCombo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgOMArcanaCombo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.ehandle = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.multicastAmount = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.arcanaLevel = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.multicastChance = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgOMArcanaCombo {
    return {
      ehandle: isSet(object.ehandle) ? globalThis.Number(object.ehandle) : 16777215,
      multicastAmount: isSet(object.multicastAmount) ? globalThis.Number(object.multicastAmount) : 0,
      arcanaLevel: isSet(object.arcanaLevel) ? globalThis.Number(object.arcanaLevel) : 0,
      multicastChance: isSet(object.multicastChance) ? globalThis.Number(object.multicastChance) : 0,
    };
  },

  toJSON(message: CDOTAUserMsgOMArcanaCombo): unknown {
    const obj: any = {};
    if (message.ehandle !== undefined && message.ehandle !== 16777215) {
      obj.ehandle = Math.round(message.ehandle);
    }
    if (message.multicastAmount !== undefined && message.multicastAmount !== 0) {
      obj.multicastAmount = Math.round(message.multicastAmount);
    }
    if (message.arcanaLevel !== undefined && message.arcanaLevel !== 0) {
      obj.arcanaLevel = Math.round(message.arcanaLevel);
    }
    if (message.multicastChance !== undefined && message.multicastChance !== 0) {
      obj.multicastChance = Math.round(message.multicastChance);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgOMArcanaCombo>): CDOTAUserMsgOMArcanaCombo {
    return CDOTAUserMsgOMArcanaCombo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgOMArcanaCombo>): CDOTAUserMsgOMArcanaCombo {
    const message = createBaseCDOTAUserMsgOMArcanaCombo();
    message.ehandle = object.ehandle ?? 16777215;
    message.multicastAmount = object.multicastAmount ?? 0;
    message.arcanaLevel = object.arcanaLevel ?? 0;
    message.multicastChance = object.multicastChance ?? 0;
    return message;
  },
};

function createBaseCDOTAUserMsgHighFiveCompleted(): CDOTAUserMsgHighFiveCompleted {
  return { playerId1: -1, playerId2: -1, specialHighFive: false, specialEntindex: -1 };
}

export const CDOTAUserMsgHighFiveCompleted = {
  encode(message: CDOTAUserMsgHighFiveCompleted, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.playerId1 !== undefined && message.playerId1 !== -1) {
      writer.uint32(8).int32(message.playerId1);
    }
    if (message.playerId2 !== undefined && message.playerId2 !== -1) {
      writer.uint32(16).int32(message.playerId2);
    }
    if (message.specialHighFive !== undefined && message.specialHighFive !== false) {
      writer.uint32(24).bool(message.specialHighFive);
    }
    if (message.specialEntindex !== undefined && message.specialEntindex !== -1) {
      writer.uint32(32).int32(message.specialEntindex);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgHighFiveCompleted {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgHighFiveCompleted();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.playerId1 = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.playerId2 = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.specialHighFive = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.specialEntindex = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgHighFiveCompleted {
    return {
      playerId1: isSet(object.playerId1) ? globalThis.Number(object.playerId1) : -1,
      playerId2: isSet(object.playerId2) ? globalThis.Number(object.playerId2) : -1,
      specialHighFive: isSet(object.specialHighFive) ? globalThis.Boolean(object.specialHighFive) : false,
      specialEntindex: isSet(object.specialEntindex) ? globalThis.Number(object.specialEntindex) : -1,
    };
  },

  toJSON(message: CDOTAUserMsgHighFiveCompleted): unknown {
    const obj: any = {};
    if (message.playerId1 !== undefined && message.playerId1 !== -1) {
      obj.playerId1 = Math.round(message.playerId1);
    }
    if (message.playerId2 !== undefined && message.playerId2 !== -1) {
      obj.playerId2 = Math.round(message.playerId2);
    }
    if (message.specialHighFive !== undefined && message.specialHighFive !== false) {
      obj.specialHighFive = message.specialHighFive;
    }
    if (message.specialEntindex !== undefined && message.specialEntindex !== -1) {
      obj.specialEntindex = Math.round(message.specialEntindex);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgHighFiveCompleted>): CDOTAUserMsgHighFiveCompleted {
    return CDOTAUserMsgHighFiveCompleted.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgHighFiveCompleted>): CDOTAUserMsgHighFiveCompleted {
    const message = createBaseCDOTAUserMsgHighFiveCompleted();
    message.playerId1 = object.playerId1 ?? -1;
    message.playerId2 = object.playerId2 ?? -1;
    message.specialHighFive = object.specialHighFive ?? false;
    message.specialEntindex = object.specialEntindex ?? -1;
    return message;
  },
};

function createBaseCDOTAUserMsgHighFiveLeftHanging(): CDOTAUserMsgHighFiveLeftHanging {
  return { playerId: -1 };
}

export const CDOTAUserMsgHighFiveLeftHanging = {
  encode(message: CDOTAUserMsgHighFiveLeftHanging, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.playerId !== undefined && message.playerId !== -1) {
      writer.uint32(8).int32(message.playerId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgHighFiveLeftHanging {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgHighFiveLeftHanging();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.playerId = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgHighFiveLeftHanging {
    return { playerId: isSet(object.playerId) ? globalThis.Number(object.playerId) : -1 };
  },

  toJSON(message: CDOTAUserMsgHighFiveLeftHanging): unknown {
    const obj: any = {};
    if (message.playerId !== undefined && message.playerId !== -1) {
      obj.playerId = Math.round(message.playerId);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgHighFiveLeftHanging>): CDOTAUserMsgHighFiveLeftHanging {
    return CDOTAUserMsgHighFiveLeftHanging.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgHighFiveLeftHanging>): CDOTAUserMsgHighFiveLeftHanging {
    const message = createBaseCDOTAUserMsgHighFiveLeftHanging();
    message.playerId = object.playerId ?? -1;
    return message;
  },
};

function createBaseCDOTAUserMsgShovelUnearth(): CDOTAUserMsgShovelUnearth {
  return { playerId: -1, allChat: false, locstring: "", quantity: 0 };
}

export const CDOTAUserMsgShovelUnearth = {
  encode(message: CDOTAUserMsgShovelUnearth, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.playerId !== undefined && message.playerId !== -1) {
      writer.uint32(8).int32(message.playerId);
    }
    if (message.allChat !== undefined && message.allChat !== false) {
      writer.uint32(16).bool(message.allChat);
    }
    if (message.locstring !== undefined && message.locstring !== "") {
      writer.uint32(26).string(message.locstring);
    }
    if (message.quantity !== undefined && message.quantity !== 0) {
      writer.uint32(32).uint32(message.quantity);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgShovelUnearth {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgShovelUnearth();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.playerId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.allChat = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.locstring = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.quantity = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgShovelUnearth {
    return {
      playerId: isSet(object.playerId) ? globalThis.Number(object.playerId) : -1,
      allChat: isSet(object.allChat) ? globalThis.Boolean(object.allChat) : false,
      locstring: isSet(object.locstring) ? globalThis.String(object.locstring) : "",
      quantity: isSet(object.quantity) ? globalThis.Number(object.quantity) : 0,
    };
  },

  toJSON(message: CDOTAUserMsgShovelUnearth): unknown {
    const obj: any = {};
    if (message.playerId !== undefined && message.playerId !== -1) {
      obj.playerId = Math.round(message.playerId);
    }
    if (message.allChat !== undefined && message.allChat !== false) {
      obj.allChat = message.allChat;
    }
    if (message.locstring !== undefined && message.locstring !== "") {
      obj.locstring = message.locstring;
    }
    if (message.quantity !== undefined && message.quantity !== 0) {
      obj.quantity = Math.round(message.quantity);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgShovelUnearth>): CDOTAUserMsgShovelUnearth {
    return CDOTAUserMsgShovelUnearth.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgShovelUnearth>): CDOTAUserMsgShovelUnearth {
    const message = createBaseCDOTAUserMsgShovelUnearth();
    message.playerId = object.playerId ?? -1;
    message.allChat = object.allChat ?? false;
    message.locstring = object.locstring ?? "";
    message.quantity = object.quantity ?? 0;
    return message;
  },
};

function createBaseCDOTAUserMsgAllStarEvent(): CDOTAUserMsgAllStarEvent {
  return { sourcePlayerId: -1, targetPlayerId: -1, pointAmount: 0, eventId: 0, playerScores: [] };
}

export const CDOTAUserMsgAllStarEvent = {
  encode(message: CDOTAUserMsgAllStarEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sourcePlayerId !== undefined && message.sourcePlayerId !== -1) {
      writer.uint32(8).int32(message.sourcePlayerId);
    }
    if (message.targetPlayerId !== undefined && message.targetPlayerId !== -1) {
      writer.uint32(16).int32(message.targetPlayerId);
    }
    if (message.pointAmount !== undefined && message.pointAmount !== 0) {
      writer.uint32(24).uint32(message.pointAmount);
    }
    if (message.eventId !== undefined && message.eventId !== 0) {
      writer.uint32(32).uint32(message.eventId);
    }
    for (const v of message.playerScores) {
      CDOTAUserMsgAllStarEvent_PlayerScore.encode(v!, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgAllStarEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgAllStarEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.sourcePlayerId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.targetPlayerId = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.pointAmount = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.eventId = reader.uint32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.playerScores.push(CDOTAUserMsgAllStarEvent_PlayerScore.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgAllStarEvent {
    return {
      sourcePlayerId: isSet(object.sourcePlayerId) ? globalThis.Number(object.sourcePlayerId) : -1,
      targetPlayerId: isSet(object.targetPlayerId) ? globalThis.Number(object.targetPlayerId) : -1,
      pointAmount: isSet(object.pointAmount) ? globalThis.Number(object.pointAmount) : 0,
      eventId: isSet(object.eventId) ? globalThis.Number(object.eventId) : 0,
      playerScores: globalThis.Array.isArray(object?.playerScores)
        ? object.playerScores.map((e: any) => CDOTAUserMsgAllStarEvent_PlayerScore.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CDOTAUserMsgAllStarEvent): unknown {
    const obj: any = {};
    if (message.sourcePlayerId !== undefined && message.sourcePlayerId !== -1) {
      obj.sourcePlayerId = Math.round(message.sourcePlayerId);
    }
    if (message.targetPlayerId !== undefined && message.targetPlayerId !== -1) {
      obj.targetPlayerId = Math.round(message.targetPlayerId);
    }
    if (message.pointAmount !== undefined && message.pointAmount !== 0) {
      obj.pointAmount = Math.round(message.pointAmount);
    }
    if (message.eventId !== undefined && message.eventId !== 0) {
      obj.eventId = Math.round(message.eventId);
    }
    if (message.playerScores?.length) {
      obj.playerScores = message.playerScores.map((e) => CDOTAUserMsgAllStarEvent_PlayerScore.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgAllStarEvent>): CDOTAUserMsgAllStarEvent {
    return CDOTAUserMsgAllStarEvent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgAllStarEvent>): CDOTAUserMsgAllStarEvent {
    const message = createBaseCDOTAUserMsgAllStarEvent();
    message.sourcePlayerId = object.sourcePlayerId ?? -1;
    message.targetPlayerId = object.targetPlayerId ?? -1;
    message.pointAmount = object.pointAmount ?? 0;
    message.eventId = object.eventId ?? 0;
    message.playerScores = object.playerScores?.map((e) => CDOTAUserMsgAllStarEvent_PlayerScore.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCDOTAUserMsgAllStarEvent_PlayerScore(): CDOTAUserMsgAllStarEvent_PlayerScore {
  return { playerId: -1, scoreSansKda: 0 };
}

export const CDOTAUserMsgAllStarEvent_PlayerScore = {
  encode(message: CDOTAUserMsgAllStarEvent_PlayerScore, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.playerId !== undefined && message.playerId !== -1) {
      writer.uint32(8).int32(message.playerId);
    }
    if (message.scoreSansKda !== undefined && message.scoreSansKda !== 0) {
      writer.uint32(16).uint32(message.scoreSansKda);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgAllStarEvent_PlayerScore {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgAllStarEvent_PlayerScore();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.playerId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.scoreSansKda = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgAllStarEvent_PlayerScore {
    return {
      playerId: isSet(object.playerId) ? globalThis.Number(object.playerId) : -1,
      scoreSansKda: isSet(object.scoreSansKda) ? globalThis.Number(object.scoreSansKda) : 0,
    };
  },

  toJSON(message: CDOTAUserMsgAllStarEvent_PlayerScore): unknown {
    const obj: any = {};
    if (message.playerId !== undefined && message.playerId !== -1) {
      obj.playerId = Math.round(message.playerId);
    }
    if (message.scoreSansKda !== undefined && message.scoreSansKda !== 0) {
      obj.scoreSansKda = Math.round(message.scoreSansKda);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgAllStarEvent_PlayerScore>): CDOTAUserMsgAllStarEvent_PlayerScore {
    return CDOTAUserMsgAllStarEvent_PlayerScore.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgAllStarEvent_PlayerScore>): CDOTAUserMsgAllStarEvent_PlayerScore {
    const message = createBaseCDOTAUserMsgAllStarEvent_PlayerScore();
    message.playerId = object.playerId ?? -1;
    message.scoreSansKda = object.scoreSansKda ?? 0;
    return message;
  },
};

function createBaseCDOTAUserMsgQueuedOrderRemoved(): CDOTAUserMsgQueuedOrderRemoved {
  return { unitOrderSequence: [] };
}

export const CDOTAUserMsgQueuedOrderRemoved = {
  encode(message: CDOTAUserMsgQueuedOrderRemoved, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.unitOrderSequence) {
      writer.uint32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgQueuedOrderRemoved {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgQueuedOrderRemoved();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.unitOrderSequence.push(reader.uint32());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.unitOrderSequence.push(reader.uint32());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgQueuedOrderRemoved {
    return {
      unitOrderSequence: globalThis.Array.isArray(object?.unitOrderSequence)
        ? object.unitOrderSequence.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: CDOTAUserMsgQueuedOrderRemoved): unknown {
    const obj: any = {};
    if (message.unitOrderSequence?.length) {
      obj.unitOrderSequence = message.unitOrderSequence.map((e) => Math.round(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgQueuedOrderRemoved>): CDOTAUserMsgQueuedOrderRemoved {
    return CDOTAUserMsgQueuedOrderRemoved.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgQueuedOrderRemoved>): CDOTAUserMsgQueuedOrderRemoved {
    const message = createBaseCDOTAUserMsgQueuedOrderRemoved();
    message.unitOrderSequence = object.unitOrderSequence?.map((e) => e) || [];
    return message;
  },
};

function createBaseCDOTAUserMsgDebugChallenge(): CDOTAUserMsgDebugChallenge {
  return {
    challengeType: 0,
    challengeQueryId: 0,
    eventId: 0,
    instanceId: 0,
    challengeVar0: 0,
    challengeVar1: 0,
    challengeMaxRank: 0,
  };
}

export const CDOTAUserMsgDebugChallenge = {
  encode(message: CDOTAUserMsgDebugChallenge, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.challengeType !== 0) {
      writer.uint32(8).uint32(message.challengeType);
    }
    if (message.challengeQueryId !== 0) {
      writer.uint32(16).uint32(message.challengeQueryId);
    }
    if (message.eventId !== 0) {
      writer.uint32(24).uint32(message.eventId);
    }
    if (message.instanceId !== undefined && message.instanceId !== 0) {
      writer.uint32(32).uint32(message.instanceId);
    }
    if (message.challengeVar0 !== undefined && message.challengeVar0 !== 0) {
      writer.uint32(40).uint32(message.challengeVar0);
    }
    if (message.challengeVar1 !== undefined && message.challengeVar1 !== 0) {
      writer.uint32(48).uint32(message.challengeVar1);
    }
    if (message.challengeMaxRank !== undefined && message.challengeMaxRank !== 0) {
      writer.uint32(56).uint32(message.challengeMaxRank);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgDebugChallenge {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgDebugChallenge();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.challengeType = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.challengeQueryId = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.eventId = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.instanceId = reader.uint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.challengeVar0 = reader.uint32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.challengeVar1 = reader.uint32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.challengeMaxRank = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgDebugChallenge {
    return {
      challengeType: isSet(object.challengeType) ? globalThis.Number(object.challengeType) : 0,
      challengeQueryId: isSet(object.challengeQueryId) ? globalThis.Number(object.challengeQueryId) : 0,
      eventId: isSet(object.eventId) ? globalThis.Number(object.eventId) : 0,
      instanceId: isSet(object.instanceId) ? globalThis.Number(object.instanceId) : 0,
      challengeVar0: isSet(object.challengeVar0) ? globalThis.Number(object.challengeVar0) : 0,
      challengeVar1: isSet(object.challengeVar1) ? globalThis.Number(object.challengeVar1) : 0,
      challengeMaxRank: isSet(object.challengeMaxRank) ? globalThis.Number(object.challengeMaxRank) : 0,
    };
  },

  toJSON(message: CDOTAUserMsgDebugChallenge): unknown {
    const obj: any = {};
    if (message.challengeType !== 0) {
      obj.challengeType = Math.round(message.challengeType);
    }
    if (message.challengeQueryId !== 0) {
      obj.challengeQueryId = Math.round(message.challengeQueryId);
    }
    if (message.eventId !== 0) {
      obj.eventId = Math.round(message.eventId);
    }
    if (message.instanceId !== undefined && message.instanceId !== 0) {
      obj.instanceId = Math.round(message.instanceId);
    }
    if (message.challengeVar0 !== undefined && message.challengeVar0 !== 0) {
      obj.challengeVar0 = Math.round(message.challengeVar0);
    }
    if (message.challengeVar1 !== undefined && message.challengeVar1 !== 0) {
      obj.challengeVar1 = Math.round(message.challengeVar1);
    }
    if (message.challengeMaxRank !== undefined && message.challengeMaxRank !== 0) {
      obj.challengeMaxRank = Math.round(message.challengeMaxRank);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgDebugChallenge>): CDOTAUserMsgDebugChallenge {
    return CDOTAUserMsgDebugChallenge.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgDebugChallenge>): CDOTAUserMsgDebugChallenge {
    const message = createBaseCDOTAUserMsgDebugChallenge();
    message.challengeType = object.challengeType ?? 0;
    message.challengeQueryId = object.challengeQueryId ?? 0;
    message.eventId = object.eventId ?? 0;
    message.instanceId = object.instanceId ?? 0;
    message.challengeVar0 = object.challengeVar0 ?? 0;
    message.challengeVar1 = object.challengeVar1 ?? 0;
    message.challengeMaxRank = object.challengeMaxRank ?? 0;
    return message;
  },
};

function createBaseCDOTAUserMsgFoundNeutralItem(): CDOTAUserMsgFoundNeutralItem {
  return { playerId: -1, itemAbilityId: -1, itemTier: 0, tierItemCount: 0 };
}

export const CDOTAUserMsgFoundNeutralItem = {
  encode(message: CDOTAUserMsgFoundNeutralItem, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.playerId !== undefined && message.playerId !== -1) {
      writer.uint32(8).int32(message.playerId);
    }
    if (message.itemAbilityId !== undefined && message.itemAbilityId !== -1) {
      writer.uint32(16).int32(message.itemAbilityId);
    }
    if (message.itemTier !== undefined && message.itemTier !== 0) {
      writer.uint32(24).uint32(message.itemTier);
    }
    if (message.tierItemCount !== undefined && message.tierItemCount !== 0) {
      writer.uint32(32).uint32(message.tierItemCount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgFoundNeutralItem {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgFoundNeutralItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.playerId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.itemAbilityId = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.itemTier = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.tierItemCount = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgFoundNeutralItem {
    return {
      playerId: isSet(object.playerId) ? globalThis.Number(object.playerId) : -1,
      itemAbilityId: isSet(object.itemAbilityId) ? globalThis.Number(object.itemAbilityId) : -1,
      itemTier: isSet(object.itemTier) ? globalThis.Number(object.itemTier) : 0,
      tierItemCount: isSet(object.tierItemCount) ? globalThis.Number(object.tierItemCount) : 0,
    };
  },

  toJSON(message: CDOTAUserMsgFoundNeutralItem): unknown {
    const obj: any = {};
    if (message.playerId !== undefined && message.playerId !== -1) {
      obj.playerId = Math.round(message.playerId);
    }
    if (message.itemAbilityId !== undefined && message.itemAbilityId !== -1) {
      obj.itemAbilityId = Math.round(message.itemAbilityId);
    }
    if (message.itemTier !== undefined && message.itemTier !== 0) {
      obj.itemTier = Math.round(message.itemTier);
    }
    if (message.tierItemCount !== undefined && message.tierItemCount !== 0) {
      obj.tierItemCount = Math.round(message.tierItemCount);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgFoundNeutralItem>): CDOTAUserMsgFoundNeutralItem {
    return CDOTAUserMsgFoundNeutralItem.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgFoundNeutralItem>): CDOTAUserMsgFoundNeutralItem {
    const message = createBaseCDOTAUserMsgFoundNeutralItem();
    message.playerId = object.playerId ?? -1;
    message.itemAbilityId = object.itemAbilityId ?? -1;
    message.itemTier = object.itemTier ?? 0;
    message.tierItemCount = object.tierItemCount ?? 0;
    return message;
  },
};

function createBaseCDOTAUserMsgOutpostCaptured(): CDOTAUserMsgOutpostCaptured {
  return { outpostEntindex: -1, teamId: 0 };
}

export const CDOTAUserMsgOutpostCaptured = {
  encode(message: CDOTAUserMsgOutpostCaptured, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.outpostEntindex !== undefined && message.outpostEntindex !== -1) {
      writer.uint32(8).int32(message.outpostEntindex);
    }
    if (message.teamId !== undefined && message.teamId !== 0) {
      writer.uint32(16).uint32(message.teamId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgOutpostCaptured {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgOutpostCaptured();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.outpostEntindex = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.teamId = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgOutpostCaptured {
    return {
      outpostEntindex: isSet(object.outpostEntindex) ? globalThis.Number(object.outpostEntindex) : -1,
      teamId: isSet(object.teamId) ? globalThis.Number(object.teamId) : 0,
    };
  },

  toJSON(message: CDOTAUserMsgOutpostCaptured): unknown {
    const obj: any = {};
    if (message.outpostEntindex !== undefined && message.outpostEntindex !== -1) {
      obj.outpostEntindex = Math.round(message.outpostEntindex);
    }
    if (message.teamId !== undefined && message.teamId !== 0) {
      obj.teamId = Math.round(message.teamId);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgOutpostCaptured>): CDOTAUserMsgOutpostCaptured {
    return CDOTAUserMsgOutpostCaptured.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgOutpostCaptured>): CDOTAUserMsgOutpostCaptured {
    const message = createBaseCDOTAUserMsgOutpostCaptured();
    message.outpostEntindex = object.outpostEntindex ?? -1;
    message.teamId = object.teamId ?? 0;
    return message;
  },
};

function createBaseCDOTAUserMsgOutpostGrantedXP(): CDOTAUserMsgOutpostGrantedXP {
  return { teamId: 0, xpAmount: 0 };
}

export const CDOTAUserMsgOutpostGrantedXP = {
  encode(message: CDOTAUserMsgOutpostGrantedXP, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.teamId !== undefined && message.teamId !== 0) {
      writer.uint32(8).uint32(message.teamId);
    }
    if (message.xpAmount !== undefined && message.xpAmount !== 0) {
      writer.uint32(16).uint32(message.xpAmount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgOutpostGrantedXP {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgOutpostGrantedXP();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.teamId = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.xpAmount = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgOutpostGrantedXP {
    return {
      teamId: isSet(object.teamId) ? globalThis.Number(object.teamId) : 0,
      xpAmount: isSet(object.xpAmount) ? globalThis.Number(object.xpAmount) : 0,
    };
  },

  toJSON(message: CDOTAUserMsgOutpostGrantedXP): unknown {
    const obj: any = {};
    if (message.teamId !== undefined && message.teamId !== 0) {
      obj.teamId = Math.round(message.teamId);
    }
    if (message.xpAmount !== undefined && message.xpAmount !== 0) {
      obj.xpAmount = Math.round(message.xpAmount);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgOutpostGrantedXP>): CDOTAUserMsgOutpostGrantedXP {
    return CDOTAUserMsgOutpostGrantedXP.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgOutpostGrantedXP>): CDOTAUserMsgOutpostGrantedXP {
    const message = createBaseCDOTAUserMsgOutpostGrantedXP();
    message.teamId = object.teamId ?? 0;
    message.xpAmount = object.xpAmount ?? 0;
    return message;
  },
};

function createBaseCDOTAUserMsgMoveCameraToUnit(): CDOTAUserMsgMoveCameraToUnit {
  return { unitEhandle: 16777215 };
}

export const CDOTAUserMsgMoveCameraToUnit = {
  encode(message: CDOTAUserMsgMoveCameraToUnit, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.unitEhandle !== undefined && message.unitEhandle !== 16777215) {
      writer.uint32(8).uint32(message.unitEhandle);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgMoveCameraToUnit {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgMoveCameraToUnit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.unitEhandle = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgMoveCameraToUnit {
    return { unitEhandle: isSet(object.unitEhandle) ? globalThis.Number(object.unitEhandle) : 16777215 };
  },

  toJSON(message: CDOTAUserMsgMoveCameraToUnit): unknown {
    const obj: any = {};
    if (message.unitEhandle !== undefined && message.unitEhandle !== 16777215) {
      obj.unitEhandle = Math.round(message.unitEhandle);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgMoveCameraToUnit>): CDOTAUserMsgMoveCameraToUnit {
    return CDOTAUserMsgMoveCameraToUnit.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgMoveCameraToUnit>): CDOTAUserMsgMoveCameraToUnit {
    const message = createBaseCDOTAUserMsgMoveCameraToUnit();
    message.unitEhandle = object.unitEhandle ?? 16777215;
    return message;
  },
};

function createBaseCDOTAUserMsgPauseMinigameData(): CDOTAUserMsgPauseMinigameData {
  return { dataBits: [] };
}

export const CDOTAUserMsgPauseMinigameData = {
  encode(message: CDOTAUserMsgPauseMinigameData, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.dataBits) {
      CDOTAUserMsgPauseMinigameData_DataBit.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgPauseMinigameData {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgPauseMinigameData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.dataBits.push(CDOTAUserMsgPauseMinigameData_DataBit.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgPauseMinigameData {
    return {
      dataBits: globalThis.Array.isArray(object?.dataBits)
        ? object.dataBits.map((e: any) => CDOTAUserMsgPauseMinigameData_DataBit.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CDOTAUserMsgPauseMinigameData): unknown {
    const obj: any = {};
    if (message.dataBits?.length) {
      obj.dataBits = message.dataBits.map((e) => CDOTAUserMsgPauseMinigameData_DataBit.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgPauseMinigameData>): CDOTAUserMsgPauseMinigameData {
    return CDOTAUserMsgPauseMinigameData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgPauseMinigameData>): CDOTAUserMsgPauseMinigameData {
    const message = createBaseCDOTAUserMsgPauseMinigameData();
    message.dataBits = object.dataBits?.map((e) => CDOTAUserMsgPauseMinigameData_DataBit.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCDOTAUserMsgPauseMinigameData_DataBit(): CDOTAUserMsgPauseMinigameData_DataBit {
  return { index: 0, data: 0, dataExtra: "0" };
}

export const CDOTAUserMsgPauseMinigameData_DataBit = {
  encode(message: CDOTAUserMsgPauseMinigameData_DataBit, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.index !== undefined && message.index !== 0) {
      writer.uint32(8).uint32(message.index);
    }
    if (message.data !== undefined && message.data !== 0) {
      writer.uint32(16).int32(message.data);
    }
    if (message.dataExtra !== undefined && message.dataExtra !== "0") {
      writer.uint32(24).int64(message.dataExtra);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgPauseMinigameData_DataBit {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgPauseMinigameData_DataBit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.index = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.data = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.dataExtra = longToString(reader.int64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgPauseMinigameData_DataBit {
    return {
      index: isSet(object.index) ? globalThis.Number(object.index) : 0,
      data: isSet(object.data) ? globalThis.Number(object.data) : 0,
      dataExtra: isSet(object.dataExtra) ? globalThis.String(object.dataExtra) : "0",
    };
  },

  toJSON(message: CDOTAUserMsgPauseMinigameData_DataBit): unknown {
    const obj: any = {};
    if (message.index !== undefined && message.index !== 0) {
      obj.index = Math.round(message.index);
    }
    if (message.data !== undefined && message.data !== 0) {
      obj.data = Math.round(message.data);
    }
    if (message.dataExtra !== undefined && message.dataExtra !== "0") {
      obj.dataExtra = message.dataExtra;
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgPauseMinigameData_DataBit>): CDOTAUserMsgPauseMinigameData_DataBit {
    return CDOTAUserMsgPauseMinigameData_DataBit.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgPauseMinigameData_DataBit>): CDOTAUserMsgPauseMinigameData_DataBit {
    const message = createBaseCDOTAUserMsgPauseMinigameData_DataBit();
    message.index = object.index ?? 0;
    message.data = object.data ?? 0;
    message.dataExtra = object.dataExtra ?? "0";
    return message;
  },
};

function createBaseCDOTAUserMsgVersusScenePlayerBehavior(): CDOTAUserMsgVersusScenePlayerBehavior {
  return { playerId: -1, behavior: 1, playActivity: undefined, chatWheel: undefined, playbackRate: undefined };
}

export const CDOTAUserMsgVersusScenePlayerBehavior = {
  encode(message: CDOTAUserMsgVersusScenePlayerBehavior, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.playerId !== undefined && message.playerId !== -1) {
      writer.uint32(8).int32(message.playerId);
    }
    if (message.behavior !== undefined && message.behavior !== 1) {
      writer.uint32(16).int32(message.behavior);
    }
    if (message.playActivity !== undefined) {
      VersusScenePlayActivity.encode(message.playActivity, writer.uint32(26).fork()).ldelim();
    }
    if (message.chatWheel !== undefined) {
      VersusSceneChatWheel.encode(message.chatWheel, writer.uint32(34).fork()).ldelim();
    }
    if (message.playbackRate !== undefined) {
      VersusScenePlaybackRate.encode(message.playbackRate, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgVersusScenePlayerBehavior {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgVersusScenePlayerBehavior();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.playerId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.behavior = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.playActivity = VersusScenePlayActivity.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.chatWheel = VersusSceneChatWheel.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.playbackRate = VersusScenePlaybackRate.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgVersusScenePlayerBehavior {
    return {
      playerId: isSet(object.playerId) ? globalThis.Number(object.playerId) : -1,
      behavior: isSet(object.behavior) ? eDOTAVersusScenePlayerBehaviorFromJSON(object.behavior) : 1,
      playActivity: isSet(object.playActivity) ? VersusScenePlayActivity.fromJSON(object.playActivity) : undefined,
      chatWheel: isSet(object.chatWheel) ? VersusSceneChatWheel.fromJSON(object.chatWheel) : undefined,
      playbackRate: isSet(object.playbackRate) ? VersusScenePlaybackRate.fromJSON(object.playbackRate) : undefined,
    };
  },

  toJSON(message: CDOTAUserMsgVersusScenePlayerBehavior): unknown {
    const obj: any = {};
    if (message.playerId !== undefined && message.playerId !== -1) {
      obj.playerId = Math.round(message.playerId);
    }
    if (message.behavior !== undefined && message.behavior !== 1) {
      obj.behavior = eDOTAVersusScenePlayerBehaviorToJSON(message.behavior);
    }
    if (message.playActivity !== undefined) {
      obj.playActivity = VersusScenePlayActivity.toJSON(message.playActivity);
    }
    if (message.chatWheel !== undefined) {
      obj.chatWheel = VersusSceneChatWheel.toJSON(message.chatWheel);
    }
    if (message.playbackRate !== undefined) {
      obj.playbackRate = VersusScenePlaybackRate.toJSON(message.playbackRate);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgVersusScenePlayerBehavior>): CDOTAUserMsgVersusScenePlayerBehavior {
    return CDOTAUserMsgVersusScenePlayerBehavior.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgVersusScenePlayerBehavior>): CDOTAUserMsgVersusScenePlayerBehavior {
    const message = createBaseCDOTAUserMsgVersusScenePlayerBehavior();
    message.playerId = object.playerId ?? -1;
    message.behavior = object.behavior ?? 1;
    message.playActivity =
      object.playActivity !== undefined && object.playActivity !== null
        ? VersusScenePlayActivity.fromPartial(object.playActivity)
        : undefined;
    message.chatWheel =
      object.chatWheel !== undefined && object.chatWheel !== null
        ? VersusSceneChatWheel.fromPartial(object.chatWheel)
        : undefined;
    message.playbackRate =
      object.playbackRate !== undefined && object.playbackRate !== null
        ? VersusScenePlaybackRate.fromPartial(object.playbackRate)
        : undefined;
    return message;
  },
};

function createBaseCDOTAUserMsgQoPArcanaSummary(): CDOTAUserMsgQoPArcanaSummary {
  return { ehandle: 16777215, arcanaLevel: 0, playersHit: 0, playersKilled: 0 };
}

export const CDOTAUserMsgQoPArcanaSummary = {
  encode(message: CDOTAUserMsgQoPArcanaSummary, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.ehandle !== undefined && message.ehandle !== 16777215) {
      writer.uint32(8).uint32(message.ehandle);
    }
    if (message.arcanaLevel !== undefined && message.arcanaLevel !== 0) {
      writer.uint32(16).uint32(message.arcanaLevel);
    }
    if (message.playersHit !== undefined && message.playersHit !== 0) {
      writer.uint32(24).uint32(message.playersHit);
    }
    if (message.playersKilled !== undefined && message.playersKilled !== 0) {
      writer.uint32(32).uint32(message.playersKilled);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgQoPArcanaSummary {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgQoPArcanaSummary();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.ehandle = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.arcanaLevel = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.playersHit = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.playersKilled = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgQoPArcanaSummary {
    return {
      ehandle: isSet(object.ehandle) ? globalThis.Number(object.ehandle) : 16777215,
      arcanaLevel: isSet(object.arcanaLevel) ? globalThis.Number(object.arcanaLevel) : 0,
      playersHit: isSet(object.playersHit) ? globalThis.Number(object.playersHit) : 0,
      playersKilled: isSet(object.playersKilled) ? globalThis.Number(object.playersKilled) : 0,
    };
  },

  toJSON(message: CDOTAUserMsgQoPArcanaSummary): unknown {
    const obj: any = {};
    if (message.ehandle !== undefined && message.ehandle !== 16777215) {
      obj.ehandle = Math.round(message.ehandle);
    }
    if (message.arcanaLevel !== undefined && message.arcanaLevel !== 0) {
      obj.arcanaLevel = Math.round(message.arcanaLevel);
    }
    if (message.playersHit !== undefined && message.playersHit !== 0) {
      obj.playersHit = Math.round(message.playersHit);
    }
    if (message.playersKilled !== undefined && message.playersKilled !== 0) {
      obj.playersKilled = Math.round(message.playersKilled);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgQoPArcanaSummary>): CDOTAUserMsgQoPArcanaSummary {
    return CDOTAUserMsgQoPArcanaSummary.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgQoPArcanaSummary>): CDOTAUserMsgQoPArcanaSummary {
    const message = createBaseCDOTAUserMsgQoPArcanaSummary();
    message.ehandle = object.ehandle ?? 16777215;
    message.arcanaLevel = object.arcanaLevel ?? 0;
    message.playersHit = object.playersHit ?? 0;
    message.playersKilled = object.playersKilled ?? 0;
    return message;
  },
};

function createBaseCDOTAUserMsgHotPotatoCreated(): CDOTAUserMsgHotPotatoCreated {
  return { playerId1: -1, playerId2: -1 };
}

export const CDOTAUserMsgHotPotatoCreated = {
  encode(message: CDOTAUserMsgHotPotatoCreated, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.playerId1 !== undefined && message.playerId1 !== -1) {
      writer.uint32(8).int32(message.playerId1);
    }
    if (message.playerId2 !== undefined && message.playerId2 !== -1) {
      writer.uint32(16).int32(message.playerId2);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgHotPotatoCreated {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgHotPotatoCreated();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.playerId1 = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.playerId2 = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgHotPotatoCreated {
    return {
      playerId1: isSet(object.playerId1) ? globalThis.Number(object.playerId1) : -1,
      playerId2: isSet(object.playerId2) ? globalThis.Number(object.playerId2) : -1,
    };
  },

  toJSON(message: CDOTAUserMsgHotPotatoCreated): unknown {
    const obj: any = {};
    if (message.playerId1 !== undefined && message.playerId1 !== -1) {
      obj.playerId1 = Math.round(message.playerId1);
    }
    if (message.playerId2 !== undefined && message.playerId2 !== -1) {
      obj.playerId2 = Math.round(message.playerId2);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgHotPotatoCreated>): CDOTAUserMsgHotPotatoCreated {
    return CDOTAUserMsgHotPotatoCreated.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgHotPotatoCreated>): CDOTAUserMsgHotPotatoCreated {
    const message = createBaseCDOTAUserMsgHotPotatoCreated();
    message.playerId1 = object.playerId1 ?? -1;
    message.playerId2 = object.playerId2 ?? -1;
    return message;
  },
};

function createBaseCDOTAUserMsgHotPotatoExploded(): CDOTAUserMsgHotPotatoExploded {
  return { playerId: -1 };
}

export const CDOTAUserMsgHotPotatoExploded = {
  encode(message: CDOTAUserMsgHotPotatoExploded, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.playerId !== undefined && message.playerId !== -1) {
      writer.uint32(8).int32(message.playerId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgHotPotatoExploded {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgHotPotatoExploded();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.playerId = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgHotPotatoExploded {
    return { playerId: isSet(object.playerId) ? globalThis.Number(object.playerId) : -1 };
  },

  toJSON(message: CDOTAUserMsgHotPotatoExploded): unknown {
    const obj: any = {};
    if (message.playerId !== undefined && message.playerId !== -1) {
      obj.playerId = Math.round(message.playerId);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgHotPotatoExploded>): CDOTAUserMsgHotPotatoExploded {
    return CDOTAUserMsgHotPotatoExploded.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgHotPotatoExploded>): CDOTAUserMsgHotPotatoExploded {
    const message = createBaseCDOTAUserMsgHotPotatoExploded();
    message.playerId = object.playerId ?? -1;
    return message;
  },
};

function createBaseCDOTAUserMsgWKArcanaProgress(): CDOTAUserMsgWKArcanaProgress {
  return { ehandle: 16777215, arcanaLevel: 0, heroId: 0 };
}

export const CDOTAUserMsgWKArcanaProgress = {
  encode(message: CDOTAUserMsgWKArcanaProgress, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.ehandle !== undefined && message.ehandle !== 16777215) {
      writer.uint32(8).uint32(message.ehandle);
    }
    if (message.arcanaLevel !== undefined && message.arcanaLevel !== 0) {
      writer.uint32(16).uint32(message.arcanaLevel);
    }
    if (message.heroId !== undefined && message.heroId !== 0) {
      writer.uint32(24).uint32(message.heroId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgWKArcanaProgress {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgWKArcanaProgress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.ehandle = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.arcanaLevel = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.heroId = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgWKArcanaProgress {
    return {
      ehandle: isSet(object.ehandle) ? globalThis.Number(object.ehandle) : 16777215,
      arcanaLevel: isSet(object.arcanaLevel) ? globalThis.Number(object.arcanaLevel) : 0,
      heroId: isSet(object.heroId) ? globalThis.Number(object.heroId) : 0,
    };
  },

  toJSON(message: CDOTAUserMsgWKArcanaProgress): unknown {
    const obj: any = {};
    if (message.ehandle !== undefined && message.ehandle !== 16777215) {
      obj.ehandle = Math.round(message.ehandle);
    }
    if (message.arcanaLevel !== undefined && message.arcanaLevel !== 0) {
      obj.arcanaLevel = Math.round(message.arcanaLevel);
    }
    if (message.heroId !== undefined && message.heroId !== 0) {
      obj.heroId = Math.round(message.heroId);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgWKArcanaProgress>): CDOTAUserMsgWKArcanaProgress {
    return CDOTAUserMsgWKArcanaProgress.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgWKArcanaProgress>): CDOTAUserMsgWKArcanaProgress {
    const message = createBaseCDOTAUserMsgWKArcanaProgress();
    message.ehandle = object.ehandle ?? 16777215;
    message.arcanaLevel = object.arcanaLevel ?? 0;
    message.heroId = object.heroId ?? 0;
    return message;
  },
};

function createBaseCDOTAUserMsgGuildChallengeProgress(): CDOTAUserMsgGuildChallengeProgress {
  return {
    playerProgress: [],
    guildId: 0,
    challengeInstanceId: 0,
    challengeParameter: 0,
    challengeType: 0,
    challengeProgressAtStart: 0,
    complete: false,
  };
}

export const CDOTAUserMsgGuildChallengeProgress = {
  encode(message: CDOTAUserMsgGuildChallengeProgress, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.playerProgress) {
      CDOTAUserMsgGuildChallengeProgress_PlayerProgress.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.guildId !== undefined && message.guildId !== 0) {
      writer.uint32(16).uint32(message.guildId);
    }
    if (message.challengeInstanceId !== undefined && message.challengeInstanceId !== 0) {
      writer.uint32(24).uint32(message.challengeInstanceId);
    }
    if (message.challengeParameter !== undefined && message.challengeParameter !== 0) {
      writer.uint32(32).uint32(message.challengeParameter);
    }
    if (message.challengeType !== undefined && message.challengeType !== 0) {
      writer.uint32(40).int32(message.challengeType);
    }
    if (message.challengeProgressAtStart !== undefined && message.challengeProgressAtStart !== 0) {
      writer.uint32(56).uint32(message.challengeProgressAtStart);
    }
    if (message.complete !== undefined && message.complete !== false) {
      writer.uint32(64).bool(message.complete);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgGuildChallengeProgress {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgGuildChallengeProgress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.playerProgress.push(
            CDOTAUserMsgGuildChallengeProgress_PlayerProgress.decode(reader, reader.uint32()),
          );
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.guildId = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.challengeInstanceId = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.challengeParameter = reader.uint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.challengeType = reader.int32() as any;
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.challengeProgressAtStart = reader.uint32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.complete = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgGuildChallengeProgress {
    return {
      playerProgress: globalThis.Array.isArray(object?.playerProgress)
        ? object.playerProgress.map((e: any) => CDOTAUserMsgGuildChallengeProgress_PlayerProgress.fromJSON(e))
        : [],
      guildId: isSet(object.guildId) ? globalThis.Number(object.guildId) : 0,
      challengeInstanceId: isSet(object.challengeInstanceId) ? globalThis.Number(object.challengeInstanceId) : 0,
      challengeParameter: isSet(object.challengeParameter) ? globalThis.Number(object.challengeParameter) : 0,
      challengeType: isSet(object.challengeType)
        ? cDOTAUserMsgGuildChallengeProgress_EChallengeTypeFromJSON(object.challengeType)
        : 0,
      challengeProgressAtStart: isSet(object.challengeProgressAtStart)
        ? globalThis.Number(object.challengeProgressAtStart)
        : 0,
      complete: isSet(object.complete) ? globalThis.Boolean(object.complete) : false,
    };
  },

  toJSON(message: CDOTAUserMsgGuildChallengeProgress): unknown {
    const obj: any = {};
    if (message.playerProgress?.length) {
      obj.playerProgress = message.playerProgress.map((e) =>
        CDOTAUserMsgGuildChallengeProgress_PlayerProgress.toJSON(e),
      );
    }
    if (message.guildId !== undefined && message.guildId !== 0) {
      obj.guildId = Math.round(message.guildId);
    }
    if (message.challengeInstanceId !== undefined && message.challengeInstanceId !== 0) {
      obj.challengeInstanceId = Math.round(message.challengeInstanceId);
    }
    if (message.challengeParameter !== undefined && message.challengeParameter !== 0) {
      obj.challengeParameter = Math.round(message.challengeParameter);
    }
    if (message.challengeType !== undefined && message.challengeType !== 0) {
      obj.challengeType = cDOTAUserMsgGuildChallengeProgress_EChallengeTypeToJSON(message.challengeType);
    }
    if (message.challengeProgressAtStart !== undefined && message.challengeProgressAtStart !== 0) {
      obj.challengeProgressAtStart = Math.round(message.challengeProgressAtStart);
    }
    if (message.complete !== undefined && message.complete !== false) {
      obj.complete = message.complete;
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgGuildChallengeProgress>): CDOTAUserMsgGuildChallengeProgress {
    return CDOTAUserMsgGuildChallengeProgress.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgGuildChallengeProgress>): CDOTAUserMsgGuildChallengeProgress {
    const message = createBaseCDOTAUserMsgGuildChallengeProgress();
    message.playerProgress =
      object.playerProgress?.map((e) => CDOTAUserMsgGuildChallengeProgress_PlayerProgress.fromPartial(e)) || [];
    message.guildId = object.guildId ?? 0;
    message.challengeInstanceId = object.challengeInstanceId ?? 0;
    message.challengeParameter = object.challengeParameter ?? 0;
    message.challengeType = object.challengeType ?? 0;
    message.challengeProgressAtStart = object.challengeProgressAtStart ?? 0;
    message.complete = object.complete ?? false;
    return message;
  },
};

function createBaseCDOTAUserMsgGuildChallengeProgress_PlayerProgress(): CDOTAUserMsgGuildChallengeProgress_PlayerProgress {
  return { playerId: -1, progress: 0 };
}

export const CDOTAUserMsgGuildChallengeProgress_PlayerProgress = {
  encode(
    message: CDOTAUserMsgGuildChallengeProgress_PlayerProgress,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.playerId !== undefined && message.playerId !== -1) {
      writer.uint32(8).int32(message.playerId);
    }
    if (message.progress !== undefined && message.progress !== 0) {
      writer.uint32(48).uint32(message.progress);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgGuildChallengeProgress_PlayerProgress {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgGuildChallengeProgress_PlayerProgress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.playerId = reader.int32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.progress = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgGuildChallengeProgress_PlayerProgress {
    return {
      playerId: isSet(object.playerId) ? globalThis.Number(object.playerId) : -1,
      progress: isSet(object.progress) ? globalThis.Number(object.progress) : 0,
    };
  },

  toJSON(message: CDOTAUserMsgGuildChallengeProgress_PlayerProgress): unknown {
    const obj: any = {};
    if (message.playerId !== undefined && message.playerId !== -1) {
      obj.playerId = Math.round(message.playerId);
    }
    if (message.progress !== undefined && message.progress !== 0) {
      obj.progress = Math.round(message.progress);
    }
    return obj;
  },

  create(
    base?: DeepPartial<CDOTAUserMsgGuildChallengeProgress_PlayerProgress>,
  ): CDOTAUserMsgGuildChallengeProgress_PlayerProgress {
    return CDOTAUserMsgGuildChallengeProgress_PlayerProgress.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CDOTAUserMsgGuildChallengeProgress_PlayerProgress>,
  ): CDOTAUserMsgGuildChallengeProgress_PlayerProgress {
    const message = createBaseCDOTAUserMsgGuildChallengeProgress_PlayerProgress();
    message.playerId = object.playerId ?? -1;
    message.progress = object.progress ?? 0;
    return message;
  },
};

function createBaseCDOTAUserMsgWRArcanaProgress(): CDOTAUserMsgWRArcanaProgress {
  return {
    ehandle: 16777215,
    targetEhandle: 16777215,
    arrowsLanded: 0,
    damageDealt: 0,
    targetHp: 0,
    targetMaxHp: 0,
    arcanaLevel: 0,
  };
}

export const CDOTAUserMsgWRArcanaProgress = {
  encode(message: CDOTAUserMsgWRArcanaProgress, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.ehandle !== undefined && message.ehandle !== 16777215) {
      writer.uint32(8).uint32(message.ehandle);
    }
    if (message.targetEhandle !== undefined && message.targetEhandle !== 16777215) {
      writer.uint32(16).uint32(message.targetEhandle);
    }
    if (message.arrowsLanded !== undefined && message.arrowsLanded !== 0) {
      writer.uint32(24).uint32(message.arrowsLanded);
    }
    if (message.damageDealt !== undefined && message.damageDealt !== 0) {
      writer.uint32(32).uint32(message.damageDealt);
    }
    if (message.targetHp !== undefined && message.targetHp !== 0) {
      writer.uint32(40).uint32(message.targetHp);
    }
    if (message.targetMaxHp !== undefined && message.targetMaxHp !== 0) {
      writer.uint32(48).uint32(message.targetMaxHp);
    }
    if (message.arcanaLevel !== undefined && message.arcanaLevel !== 0) {
      writer.uint32(56).uint32(message.arcanaLevel);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgWRArcanaProgress {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgWRArcanaProgress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.ehandle = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.targetEhandle = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.arrowsLanded = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.damageDealt = reader.uint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.targetHp = reader.uint32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.targetMaxHp = reader.uint32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.arcanaLevel = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgWRArcanaProgress {
    return {
      ehandle: isSet(object.ehandle) ? globalThis.Number(object.ehandle) : 16777215,
      targetEhandle: isSet(object.targetEhandle) ? globalThis.Number(object.targetEhandle) : 16777215,
      arrowsLanded: isSet(object.arrowsLanded) ? globalThis.Number(object.arrowsLanded) : 0,
      damageDealt: isSet(object.damageDealt) ? globalThis.Number(object.damageDealt) : 0,
      targetHp: isSet(object.targetHp) ? globalThis.Number(object.targetHp) : 0,
      targetMaxHp: isSet(object.targetMaxHp) ? globalThis.Number(object.targetMaxHp) : 0,
      arcanaLevel: isSet(object.arcanaLevel) ? globalThis.Number(object.arcanaLevel) : 0,
    };
  },

  toJSON(message: CDOTAUserMsgWRArcanaProgress): unknown {
    const obj: any = {};
    if (message.ehandle !== undefined && message.ehandle !== 16777215) {
      obj.ehandle = Math.round(message.ehandle);
    }
    if (message.targetEhandle !== undefined && message.targetEhandle !== 16777215) {
      obj.targetEhandle = Math.round(message.targetEhandle);
    }
    if (message.arrowsLanded !== undefined && message.arrowsLanded !== 0) {
      obj.arrowsLanded = Math.round(message.arrowsLanded);
    }
    if (message.damageDealt !== undefined && message.damageDealt !== 0) {
      obj.damageDealt = Math.round(message.damageDealt);
    }
    if (message.targetHp !== undefined && message.targetHp !== 0) {
      obj.targetHp = Math.round(message.targetHp);
    }
    if (message.targetMaxHp !== undefined && message.targetMaxHp !== 0) {
      obj.targetMaxHp = Math.round(message.targetMaxHp);
    }
    if (message.arcanaLevel !== undefined && message.arcanaLevel !== 0) {
      obj.arcanaLevel = Math.round(message.arcanaLevel);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgWRArcanaProgress>): CDOTAUserMsgWRArcanaProgress {
    return CDOTAUserMsgWRArcanaProgress.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgWRArcanaProgress>): CDOTAUserMsgWRArcanaProgress {
    const message = createBaseCDOTAUserMsgWRArcanaProgress();
    message.ehandle = object.ehandle ?? 16777215;
    message.targetEhandle = object.targetEhandle ?? 16777215;
    message.arrowsLanded = object.arrowsLanded ?? 0;
    message.damageDealt = object.damageDealt ?? 0;
    message.targetHp = object.targetHp ?? 0;
    message.targetMaxHp = object.targetMaxHp ?? 0;
    message.arcanaLevel = object.arcanaLevel ?? 0;
    return message;
  },
};

function createBaseCDOTAUserMsgWRArcanaSummary(): CDOTAUserMsgWRArcanaSummary {
  return {
    ehandle: 16777215,
    targetEhandle: 16777215,
    arrowsLanded: 0,
    damageDealt: 0,
    targetHp: 0,
    targetMaxHp: 0,
    arcanaLevel: 0,
    success: false,
  };
}

export const CDOTAUserMsgWRArcanaSummary = {
  encode(message: CDOTAUserMsgWRArcanaSummary, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.ehandle !== undefined && message.ehandle !== 16777215) {
      writer.uint32(8).uint32(message.ehandle);
    }
    if (message.targetEhandle !== undefined && message.targetEhandle !== 16777215) {
      writer.uint32(16).uint32(message.targetEhandle);
    }
    if (message.arrowsLanded !== undefined && message.arrowsLanded !== 0) {
      writer.uint32(24).uint32(message.arrowsLanded);
    }
    if (message.damageDealt !== undefined && message.damageDealt !== 0) {
      writer.uint32(32).uint32(message.damageDealt);
    }
    if (message.targetHp !== undefined && message.targetHp !== 0) {
      writer.uint32(40).uint32(message.targetHp);
    }
    if (message.targetMaxHp !== undefined && message.targetMaxHp !== 0) {
      writer.uint32(48).uint32(message.targetMaxHp);
    }
    if (message.arcanaLevel !== undefined && message.arcanaLevel !== 0) {
      writer.uint32(56).uint32(message.arcanaLevel);
    }
    if (message.success !== undefined && message.success !== false) {
      writer.uint32(64).bool(message.success);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgWRArcanaSummary {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgWRArcanaSummary();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.ehandle = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.targetEhandle = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.arrowsLanded = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.damageDealt = reader.uint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.targetHp = reader.uint32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.targetMaxHp = reader.uint32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.arcanaLevel = reader.uint32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.success = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgWRArcanaSummary {
    return {
      ehandle: isSet(object.ehandle) ? globalThis.Number(object.ehandle) : 16777215,
      targetEhandle: isSet(object.targetEhandle) ? globalThis.Number(object.targetEhandle) : 16777215,
      arrowsLanded: isSet(object.arrowsLanded) ? globalThis.Number(object.arrowsLanded) : 0,
      damageDealt: isSet(object.damageDealt) ? globalThis.Number(object.damageDealt) : 0,
      targetHp: isSet(object.targetHp) ? globalThis.Number(object.targetHp) : 0,
      targetMaxHp: isSet(object.targetMaxHp) ? globalThis.Number(object.targetMaxHp) : 0,
      arcanaLevel: isSet(object.arcanaLevel) ? globalThis.Number(object.arcanaLevel) : 0,
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
    };
  },

  toJSON(message: CDOTAUserMsgWRArcanaSummary): unknown {
    const obj: any = {};
    if (message.ehandle !== undefined && message.ehandle !== 16777215) {
      obj.ehandle = Math.round(message.ehandle);
    }
    if (message.targetEhandle !== undefined && message.targetEhandle !== 16777215) {
      obj.targetEhandle = Math.round(message.targetEhandle);
    }
    if (message.arrowsLanded !== undefined && message.arrowsLanded !== 0) {
      obj.arrowsLanded = Math.round(message.arrowsLanded);
    }
    if (message.damageDealt !== undefined && message.damageDealt !== 0) {
      obj.damageDealt = Math.round(message.damageDealt);
    }
    if (message.targetHp !== undefined && message.targetHp !== 0) {
      obj.targetHp = Math.round(message.targetHp);
    }
    if (message.targetMaxHp !== undefined && message.targetMaxHp !== 0) {
      obj.targetMaxHp = Math.round(message.targetMaxHp);
    }
    if (message.arcanaLevel !== undefined && message.arcanaLevel !== 0) {
      obj.arcanaLevel = Math.round(message.arcanaLevel);
    }
    if (message.success !== undefined && message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgWRArcanaSummary>): CDOTAUserMsgWRArcanaSummary {
    return CDOTAUserMsgWRArcanaSummary.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgWRArcanaSummary>): CDOTAUserMsgWRArcanaSummary {
    const message = createBaseCDOTAUserMsgWRArcanaSummary();
    message.ehandle = object.ehandle ?? 16777215;
    message.targetEhandle = object.targetEhandle ?? 16777215;
    message.arrowsLanded = object.arrowsLanded ?? 0;
    message.damageDealt = object.damageDealt ?? 0;
    message.targetHp = object.targetHp ?? 0;
    message.targetMaxHp = object.targetMaxHp ?? 0;
    message.arcanaLevel = object.arcanaLevel ?? 0;
    message.success = object.success ?? false;
    return message;
  },
};

function createBaseCDOTAUserMsgEmptyItemSlotAlert(): CDOTAUserMsgEmptyItemSlotAlert {
  return { sourcePlayerId: -1, targetPlayerId: -1, slotIndex: 0, cooldownSeconds: 0 };
}

export const CDOTAUserMsgEmptyItemSlotAlert = {
  encode(message: CDOTAUserMsgEmptyItemSlotAlert, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sourcePlayerId !== undefined && message.sourcePlayerId !== -1) {
      writer.uint32(8).int32(message.sourcePlayerId);
    }
    if (message.targetPlayerId !== undefined && message.targetPlayerId !== -1) {
      writer.uint32(16).int32(message.targetPlayerId);
    }
    if (message.slotIndex !== undefined && message.slotIndex !== 0) {
      writer.uint32(24).int32(message.slotIndex);
    }
    if (message.cooldownSeconds !== undefined && message.cooldownSeconds !== 0) {
      writer.uint32(32).int32(message.cooldownSeconds);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgEmptyItemSlotAlert {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgEmptyItemSlotAlert();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.sourcePlayerId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.targetPlayerId = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.slotIndex = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.cooldownSeconds = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgEmptyItemSlotAlert {
    return {
      sourcePlayerId: isSet(object.sourcePlayerId) ? globalThis.Number(object.sourcePlayerId) : -1,
      targetPlayerId: isSet(object.targetPlayerId) ? globalThis.Number(object.targetPlayerId) : -1,
      slotIndex: isSet(object.slotIndex) ? globalThis.Number(object.slotIndex) : 0,
      cooldownSeconds: isSet(object.cooldownSeconds) ? globalThis.Number(object.cooldownSeconds) : 0,
    };
  },

  toJSON(message: CDOTAUserMsgEmptyItemSlotAlert): unknown {
    const obj: any = {};
    if (message.sourcePlayerId !== undefined && message.sourcePlayerId !== -1) {
      obj.sourcePlayerId = Math.round(message.sourcePlayerId);
    }
    if (message.targetPlayerId !== undefined && message.targetPlayerId !== -1) {
      obj.targetPlayerId = Math.round(message.targetPlayerId);
    }
    if (message.slotIndex !== undefined && message.slotIndex !== 0) {
      obj.slotIndex = Math.round(message.slotIndex);
    }
    if (message.cooldownSeconds !== undefined && message.cooldownSeconds !== 0) {
      obj.cooldownSeconds = Math.round(message.cooldownSeconds);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgEmptyItemSlotAlert>): CDOTAUserMsgEmptyItemSlotAlert {
    return CDOTAUserMsgEmptyItemSlotAlert.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgEmptyItemSlotAlert>): CDOTAUserMsgEmptyItemSlotAlert {
    const message = createBaseCDOTAUserMsgEmptyItemSlotAlert();
    message.sourcePlayerId = object.sourcePlayerId ?? -1;
    message.targetPlayerId = object.targetPlayerId ?? -1;
    message.slotIndex = object.slotIndex ?? 0;
    message.cooldownSeconds = object.cooldownSeconds ?? 0;
    return message;
  },
};

function createBaseCDOTAUserMsgAghsStatusAlert(): CDOTAUserMsgAghsStatusAlert {
  return {
    sourcePlayerId: -1,
    targetPlayerId: -1,
    targetEntindex: -1,
    alertType: 0,
    hasScepter: false,
    hasShard: false,
  };
}

export const CDOTAUserMsgAghsStatusAlert = {
  encode(message: CDOTAUserMsgAghsStatusAlert, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sourcePlayerId !== undefined && message.sourcePlayerId !== -1) {
      writer.uint32(8).int32(message.sourcePlayerId);
    }
    if (message.targetPlayerId !== undefined && message.targetPlayerId !== -1) {
      writer.uint32(16).int32(message.targetPlayerId);
    }
    if (message.targetEntindex !== undefined && message.targetEntindex !== -1) {
      writer.uint32(24).int32(message.targetEntindex);
    }
    if (message.alertType !== undefined && message.alertType !== 0) {
      writer.uint32(32).uint32(message.alertType);
    }
    if (message.hasScepter !== undefined && message.hasScepter !== false) {
      writer.uint32(40).bool(message.hasScepter);
    }
    if (message.hasShard !== undefined && message.hasShard !== false) {
      writer.uint32(48).bool(message.hasShard);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgAghsStatusAlert {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgAghsStatusAlert();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.sourcePlayerId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.targetPlayerId = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.targetEntindex = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.alertType = reader.uint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.hasScepter = reader.bool();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.hasShard = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgAghsStatusAlert {
    return {
      sourcePlayerId: isSet(object.sourcePlayerId) ? globalThis.Number(object.sourcePlayerId) : -1,
      targetPlayerId: isSet(object.targetPlayerId) ? globalThis.Number(object.targetPlayerId) : -1,
      targetEntindex: isSet(object.targetEntindex) ? globalThis.Number(object.targetEntindex) : -1,
      alertType: isSet(object.alertType) ? globalThis.Number(object.alertType) : 0,
      hasScepter: isSet(object.hasScepter) ? globalThis.Boolean(object.hasScepter) : false,
      hasShard: isSet(object.hasShard) ? globalThis.Boolean(object.hasShard) : false,
    };
  },

  toJSON(message: CDOTAUserMsgAghsStatusAlert): unknown {
    const obj: any = {};
    if (message.sourcePlayerId !== undefined && message.sourcePlayerId !== -1) {
      obj.sourcePlayerId = Math.round(message.sourcePlayerId);
    }
    if (message.targetPlayerId !== undefined && message.targetPlayerId !== -1) {
      obj.targetPlayerId = Math.round(message.targetPlayerId);
    }
    if (message.targetEntindex !== undefined && message.targetEntindex !== -1) {
      obj.targetEntindex = Math.round(message.targetEntindex);
    }
    if (message.alertType !== undefined && message.alertType !== 0) {
      obj.alertType = Math.round(message.alertType);
    }
    if (message.hasScepter !== undefined && message.hasScepter !== false) {
      obj.hasScepter = message.hasScepter;
    }
    if (message.hasShard !== undefined && message.hasShard !== false) {
      obj.hasShard = message.hasShard;
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgAghsStatusAlert>): CDOTAUserMsgAghsStatusAlert {
    return CDOTAUserMsgAghsStatusAlert.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgAghsStatusAlert>): CDOTAUserMsgAghsStatusAlert {
    const message = createBaseCDOTAUserMsgAghsStatusAlert();
    message.sourcePlayerId = object.sourcePlayerId ?? -1;
    message.targetPlayerId = object.targetPlayerId ?? -1;
    message.targetEntindex = object.targetEntindex ?? -1;
    message.alertType = object.alertType ?? 0;
    message.hasScepter = object.hasScepter ?? false;
    message.hasShard = object.hasShard ?? false;
    return message;
  },
};

function createBaseCDOTAUserMsgMutedPlayers(): CDOTAUserMsgMutedPlayers {
  return { textMutedPlayerIds: [], voiceMutedPlayerIds: [] };
}

export const CDOTAUserMsgMutedPlayers = {
  encode(message: CDOTAUserMsgMutedPlayers, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.textMutedPlayerIds) {
      writer.int32(v);
    }
    writer.ldelim();
    writer.uint32(18).fork();
    for (const v of message.voiceMutedPlayerIds) {
      writer.int32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgMutedPlayers {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgMutedPlayers();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.textMutedPlayerIds.push(reader.int32());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.textMutedPlayerIds.push(reader.int32());
            }

            continue;
          }

          break;
        case 2:
          if (tag === 16) {
            message.voiceMutedPlayerIds.push(reader.int32());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.voiceMutedPlayerIds.push(reader.int32());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgMutedPlayers {
    return {
      textMutedPlayerIds: globalThis.Array.isArray(object?.textMutedPlayerIds)
        ? object.textMutedPlayerIds.map((e: any) => globalThis.Number(e))
        : [],
      voiceMutedPlayerIds: globalThis.Array.isArray(object?.voiceMutedPlayerIds)
        ? object.voiceMutedPlayerIds.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: CDOTAUserMsgMutedPlayers): unknown {
    const obj: any = {};
    if (message.textMutedPlayerIds?.length) {
      obj.textMutedPlayerIds = message.textMutedPlayerIds.map((e) => Math.round(e));
    }
    if (message.voiceMutedPlayerIds?.length) {
      obj.voiceMutedPlayerIds = message.voiceMutedPlayerIds.map((e) => Math.round(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgMutedPlayers>): CDOTAUserMsgMutedPlayers {
    return CDOTAUserMsgMutedPlayers.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgMutedPlayers>): CDOTAUserMsgMutedPlayers {
    const message = createBaseCDOTAUserMsgMutedPlayers();
    message.textMutedPlayerIds = object.textMutedPlayerIds?.map((e) => e) || [];
    message.voiceMutedPlayerIds = object.voiceMutedPlayerIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseCDOTAUserMsgContextualTip(): CDOTAUserMsgContextualTip {
  return {
    tipId: 0,
    referencedAbilities: [],
    referencedUnits: [],
    panoramaClasses: [],
    forceAnnotation: false,
    variant: 0,
    intParam: 0,
    intParam2: 0,
    floatParam: 0,
    floatParam2: 0,
    stringParam: "",
    stringParam2: "",
    tipTextOverride: "",
    tipAnnotationOverride: "",
    panoramaSnippet: "",
  };
}

export const CDOTAUserMsgContextualTip = {
  encode(message: CDOTAUserMsgContextualTip, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.tipId !== undefined && message.tipId !== 0) {
      writer.uint32(8).int32(message.tipId);
    }
    for (const v of message.referencedAbilities) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.referencedUnits) {
      writer.uint32(26).string(v!);
    }
    for (const v of message.panoramaClasses) {
      writer.uint32(34).string(v!);
    }
    if (message.forceAnnotation !== undefined && message.forceAnnotation !== false) {
      writer.uint32(40).bool(message.forceAnnotation);
    }
    if (message.variant !== undefined && message.variant !== 0) {
      writer.uint32(48).int32(message.variant);
    }
    if (message.intParam !== undefined && message.intParam !== 0) {
      writer.uint32(56).int32(message.intParam);
    }
    if (message.intParam2 !== undefined && message.intParam2 !== 0) {
      writer.uint32(64).int32(message.intParam2);
    }
    if (message.floatParam !== undefined && message.floatParam !== 0) {
      writer.uint32(77).float(message.floatParam);
    }
    if (message.floatParam2 !== undefined && message.floatParam2 !== 0) {
      writer.uint32(85).float(message.floatParam2);
    }
    if (message.stringParam !== undefined && message.stringParam !== "") {
      writer.uint32(90).string(message.stringParam);
    }
    if (message.stringParam2 !== undefined && message.stringParam2 !== "") {
      writer.uint32(98).string(message.stringParam2);
    }
    if (message.tipTextOverride !== undefined && message.tipTextOverride !== "") {
      writer.uint32(106).string(message.tipTextOverride);
    }
    if (message.tipAnnotationOverride !== undefined && message.tipAnnotationOverride !== "") {
      writer.uint32(114).string(message.tipAnnotationOverride);
    }
    if (message.panoramaSnippet !== undefined && message.panoramaSnippet !== "") {
      writer.uint32(122).string(message.panoramaSnippet);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgContextualTip {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgContextualTip();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.tipId = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.referencedAbilities.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.referencedUnits.push(reader.string());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.panoramaClasses.push(reader.string());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.forceAnnotation = reader.bool();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.variant = reader.int32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.intParam = reader.int32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.intParam2 = reader.int32();
          continue;
        case 9:
          if (tag !== 77) {
            break;
          }

          message.floatParam = reader.float();
          continue;
        case 10:
          if (tag !== 85) {
            break;
          }

          message.floatParam2 = reader.float();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.stringParam = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.stringParam2 = reader.string();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.tipTextOverride = reader.string();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.tipAnnotationOverride = reader.string();
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.panoramaSnippet = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgContextualTip {
    return {
      tipId: isSet(object.tipId) ? globalThis.Number(object.tipId) : 0,
      referencedAbilities: globalThis.Array.isArray(object?.referencedAbilities)
        ? object.referencedAbilities.map((e: any) => globalThis.String(e))
        : [],
      referencedUnits: globalThis.Array.isArray(object?.referencedUnits)
        ? object.referencedUnits.map((e: any) => globalThis.String(e))
        : [],
      panoramaClasses: globalThis.Array.isArray(object?.panoramaClasses)
        ? object.panoramaClasses.map((e: any) => globalThis.String(e))
        : [],
      forceAnnotation: isSet(object.forceAnnotation) ? globalThis.Boolean(object.forceAnnotation) : false,
      variant: isSet(object.variant) ? globalThis.Number(object.variant) : 0,
      intParam: isSet(object.intParam) ? globalThis.Number(object.intParam) : 0,
      intParam2: isSet(object.intParam2) ? globalThis.Number(object.intParam2) : 0,
      floatParam: isSet(object.floatParam) ? globalThis.Number(object.floatParam) : 0,
      floatParam2: isSet(object.floatParam2) ? globalThis.Number(object.floatParam2) : 0,
      stringParam: isSet(object.stringParam) ? globalThis.String(object.stringParam) : "",
      stringParam2: isSet(object.stringParam2) ? globalThis.String(object.stringParam2) : "",
      tipTextOverride: isSet(object.tipTextOverride) ? globalThis.String(object.tipTextOverride) : "",
      tipAnnotationOverride: isSet(object.tipAnnotationOverride) ? globalThis.String(object.tipAnnotationOverride) : "",
      panoramaSnippet: isSet(object.panoramaSnippet) ? globalThis.String(object.panoramaSnippet) : "",
    };
  },

  toJSON(message: CDOTAUserMsgContextualTip): unknown {
    const obj: any = {};
    if (message.tipId !== undefined && message.tipId !== 0) {
      obj.tipId = Math.round(message.tipId);
    }
    if (message.referencedAbilities?.length) {
      obj.referencedAbilities = message.referencedAbilities;
    }
    if (message.referencedUnits?.length) {
      obj.referencedUnits = message.referencedUnits;
    }
    if (message.panoramaClasses?.length) {
      obj.panoramaClasses = message.panoramaClasses;
    }
    if (message.forceAnnotation !== undefined && message.forceAnnotation !== false) {
      obj.forceAnnotation = message.forceAnnotation;
    }
    if (message.variant !== undefined && message.variant !== 0) {
      obj.variant = Math.round(message.variant);
    }
    if (message.intParam !== undefined && message.intParam !== 0) {
      obj.intParam = Math.round(message.intParam);
    }
    if (message.intParam2 !== undefined && message.intParam2 !== 0) {
      obj.intParam2 = Math.round(message.intParam2);
    }
    if (message.floatParam !== undefined && message.floatParam !== 0) {
      obj.floatParam = message.floatParam;
    }
    if (message.floatParam2 !== undefined && message.floatParam2 !== 0) {
      obj.floatParam2 = message.floatParam2;
    }
    if (message.stringParam !== undefined && message.stringParam !== "") {
      obj.stringParam = message.stringParam;
    }
    if (message.stringParam2 !== undefined && message.stringParam2 !== "") {
      obj.stringParam2 = message.stringParam2;
    }
    if (message.tipTextOverride !== undefined && message.tipTextOverride !== "") {
      obj.tipTextOverride = message.tipTextOverride;
    }
    if (message.tipAnnotationOverride !== undefined && message.tipAnnotationOverride !== "") {
      obj.tipAnnotationOverride = message.tipAnnotationOverride;
    }
    if (message.panoramaSnippet !== undefined && message.panoramaSnippet !== "") {
      obj.panoramaSnippet = message.panoramaSnippet;
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgContextualTip>): CDOTAUserMsgContextualTip {
    return CDOTAUserMsgContextualTip.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgContextualTip>): CDOTAUserMsgContextualTip {
    const message = createBaseCDOTAUserMsgContextualTip();
    message.tipId = object.tipId ?? 0;
    message.referencedAbilities = object.referencedAbilities?.map((e) => e) || [];
    message.referencedUnits = object.referencedUnits?.map((e) => e) || [];
    message.panoramaClasses = object.panoramaClasses?.map((e) => e) || [];
    message.forceAnnotation = object.forceAnnotation ?? false;
    message.variant = object.variant ?? 0;
    message.intParam = object.intParam ?? 0;
    message.intParam2 = object.intParam2 ?? 0;
    message.floatParam = object.floatParam ?? 0;
    message.floatParam2 = object.floatParam2 ?? 0;
    message.stringParam = object.stringParam ?? "";
    message.stringParam2 = object.stringParam2 ?? "";
    message.tipTextOverride = object.tipTextOverride ?? "";
    message.tipAnnotationOverride = object.tipAnnotationOverride ?? "";
    message.panoramaSnippet = object.panoramaSnippet ?? "";
    return message;
  },
};

function createBaseCDOTAUserMsgChatMessage(): CDOTAUserMsgChatMessage {
  return { sourcePlayerId: -1, channelType: 0, messageText: "" };
}

export const CDOTAUserMsgChatMessage = {
  encode(message: CDOTAUserMsgChatMessage, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sourcePlayerId !== undefined && message.sourcePlayerId !== -1) {
      writer.uint32(8).int32(message.sourcePlayerId);
    }
    if (message.channelType !== undefined && message.channelType !== 0) {
      writer.uint32(16).uint32(message.channelType);
    }
    if (message.messageText !== undefined && message.messageText !== "") {
      writer.uint32(26).string(message.messageText);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgChatMessage {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgChatMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.sourcePlayerId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.channelType = reader.uint32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.messageText = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgChatMessage {
    return {
      sourcePlayerId: isSet(object.sourcePlayerId) ? globalThis.Number(object.sourcePlayerId) : -1,
      channelType: isSet(object.channelType) ? globalThis.Number(object.channelType) : 0,
      messageText: isSet(object.messageText) ? globalThis.String(object.messageText) : "",
    };
  },

  toJSON(message: CDOTAUserMsgChatMessage): unknown {
    const obj: any = {};
    if (message.sourcePlayerId !== undefined && message.sourcePlayerId !== -1) {
      obj.sourcePlayerId = Math.round(message.sourcePlayerId);
    }
    if (message.channelType !== undefined && message.channelType !== 0) {
      obj.channelType = Math.round(message.channelType);
    }
    if (message.messageText !== undefined && message.messageText !== "") {
      obj.messageText = message.messageText;
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgChatMessage>): CDOTAUserMsgChatMessage {
    return CDOTAUserMsgChatMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgChatMessage>): CDOTAUserMsgChatMessage {
    const message = createBaseCDOTAUserMsgChatMessage();
    message.sourcePlayerId = object.sourcePlayerId ?? -1;
    message.channelType = object.channelType ?? 0;
    message.messageText = object.messageText ?? "";
    return message;
  },
};

function createBaseCDOTAUserMsgRockPaperScissorsStarted(): CDOTAUserMsgRockPaperScissorsStarted {
  return { playerIdSource: -1, playerIdTarget: -1 };
}

export const CDOTAUserMsgRockPaperScissorsStarted = {
  encode(message: CDOTAUserMsgRockPaperScissorsStarted, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.playerIdSource !== undefined && message.playerIdSource !== -1) {
      writer.uint32(8).int32(message.playerIdSource);
    }
    if (message.playerIdTarget !== undefined && message.playerIdTarget !== -1) {
      writer.uint32(16).int32(message.playerIdTarget);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgRockPaperScissorsStarted {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgRockPaperScissorsStarted();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.playerIdSource = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.playerIdTarget = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgRockPaperScissorsStarted {
    return {
      playerIdSource: isSet(object.playerIdSource) ? globalThis.Number(object.playerIdSource) : -1,
      playerIdTarget: isSet(object.playerIdTarget) ? globalThis.Number(object.playerIdTarget) : -1,
    };
  },

  toJSON(message: CDOTAUserMsgRockPaperScissorsStarted): unknown {
    const obj: any = {};
    if (message.playerIdSource !== undefined && message.playerIdSource !== -1) {
      obj.playerIdSource = Math.round(message.playerIdSource);
    }
    if (message.playerIdTarget !== undefined && message.playerIdTarget !== -1) {
      obj.playerIdTarget = Math.round(message.playerIdTarget);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgRockPaperScissorsStarted>): CDOTAUserMsgRockPaperScissorsStarted {
    return CDOTAUserMsgRockPaperScissorsStarted.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgRockPaperScissorsStarted>): CDOTAUserMsgRockPaperScissorsStarted {
    const message = createBaseCDOTAUserMsgRockPaperScissorsStarted();
    message.playerIdSource = object.playerIdSource ?? -1;
    message.playerIdTarget = object.playerIdTarget ?? -1;
    return message;
  },
};

function createBaseCDOTAUserMsgRockPaperScissorsFinished(): CDOTAUserMsgRockPaperScissorsFinished {
  return { playerId1: -1, playerId2: -1, player1Choice: 0, player2Choice: 0 };
}

export const CDOTAUserMsgRockPaperScissorsFinished = {
  encode(message: CDOTAUserMsgRockPaperScissorsFinished, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.playerId1 !== undefined && message.playerId1 !== -1) {
      writer.uint32(8).int32(message.playerId1);
    }
    if (message.playerId2 !== undefined && message.playerId2 !== -1) {
      writer.uint32(16).int32(message.playerId2);
    }
    if (message.player1Choice !== undefined && message.player1Choice !== 0) {
      writer.uint32(24).int32(message.player1Choice);
    }
    if (message.player2Choice !== undefined && message.player2Choice !== 0) {
      writer.uint32(32).int32(message.player2Choice);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgRockPaperScissorsFinished {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgRockPaperScissorsFinished();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.playerId1 = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.playerId2 = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.player1Choice = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.player2Choice = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgRockPaperScissorsFinished {
    return {
      playerId1: isSet(object.playerId1) ? globalThis.Number(object.playerId1) : -1,
      playerId2: isSet(object.playerId2) ? globalThis.Number(object.playerId2) : -1,
      player1Choice: isSet(object.player1Choice) ? globalThis.Number(object.player1Choice) : 0,
      player2Choice: isSet(object.player2Choice) ? globalThis.Number(object.player2Choice) : 0,
    };
  },

  toJSON(message: CDOTAUserMsgRockPaperScissorsFinished): unknown {
    const obj: any = {};
    if (message.playerId1 !== undefined && message.playerId1 !== -1) {
      obj.playerId1 = Math.round(message.playerId1);
    }
    if (message.playerId2 !== undefined && message.playerId2 !== -1) {
      obj.playerId2 = Math.round(message.playerId2);
    }
    if (message.player1Choice !== undefined && message.player1Choice !== 0) {
      obj.player1Choice = Math.round(message.player1Choice);
    }
    if (message.player2Choice !== undefined && message.player2Choice !== 0) {
      obj.player2Choice = Math.round(message.player2Choice);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgRockPaperScissorsFinished>): CDOTAUserMsgRockPaperScissorsFinished {
    return CDOTAUserMsgRockPaperScissorsFinished.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgRockPaperScissorsFinished>): CDOTAUserMsgRockPaperScissorsFinished {
    const message = createBaseCDOTAUserMsgRockPaperScissorsFinished();
    message.playerId1 = object.playerId1 ?? -1;
    message.playerId2 = object.playerId2 ?? -1;
    message.player1Choice = object.player1Choice ?? 0;
    message.player2Choice = object.player2Choice ?? 0;
    return message;
  },
};

function createBaseCDOTAUserMsgDuelOpponentKilled(): CDOTAUserMsgDuelOpponentKilled {
  return { playerIdWinner: 0, playerIdLoser: 0 };
}

export const CDOTAUserMsgDuelOpponentKilled = {
  encode(message: CDOTAUserMsgDuelOpponentKilled, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.playerIdWinner !== undefined && message.playerIdWinner !== 0) {
      writer.uint32(8).int32(message.playerIdWinner);
    }
    if (message.playerIdLoser !== undefined && message.playerIdLoser !== 0) {
      writer.uint32(16).int32(message.playerIdLoser);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgDuelOpponentKilled {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgDuelOpponentKilled();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.playerIdWinner = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.playerIdLoser = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgDuelOpponentKilled {
    return {
      playerIdWinner: isSet(object.playerIdWinner) ? globalThis.Number(object.playerIdWinner) : 0,
      playerIdLoser: isSet(object.playerIdLoser) ? globalThis.Number(object.playerIdLoser) : 0,
    };
  },

  toJSON(message: CDOTAUserMsgDuelOpponentKilled): unknown {
    const obj: any = {};
    if (message.playerIdWinner !== undefined && message.playerIdWinner !== 0) {
      obj.playerIdWinner = Math.round(message.playerIdWinner);
    }
    if (message.playerIdLoser !== undefined && message.playerIdLoser !== 0) {
      obj.playerIdLoser = Math.round(message.playerIdLoser);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgDuelOpponentKilled>): CDOTAUserMsgDuelOpponentKilled {
    return CDOTAUserMsgDuelOpponentKilled.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgDuelOpponentKilled>): CDOTAUserMsgDuelOpponentKilled {
    const message = createBaseCDOTAUserMsgDuelOpponentKilled();
    message.playerIdWinner = object.playerIdWinner ?? 0;
    message.playerIdLoser = object.playerIdLoser ?? 0;
    return message;
  },
};

function createBaseCDOTAUserMsgDuelAccepted(): CDOTAUserMsgDuelAccepted {
  return { playerId1: 0, playerId2: 0 };
}

export const CDOTAUserMsgDuelAccepted = {
  encode(message: CDOTAUserMsgDuelAccepted, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.playerId1 !== undefined && message.playerId1 !== 0) {
      writer.uint32(8).int32(message.playerId1);
    }
    if (message.playerId2 !== undefined && message.playerId2 !== 0) {
      writer.uint32(16).int32(message.playerId2);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgDuelAccepted {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgDuelAccepted();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.playerId1 = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.playerId2 = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgDuelAccepted {
    return {
      playerId1: isSet(object.playerId1) ? globalThis.Number(object.playerId1) : 0,
      playerId2: isSet(object.playerId2) ? globalThis.Number(object.playerId2) : 0,
    };
  },

  toJSON(message: CDOTAUserMsgDuelAccepted): unknown {
    const obj: any = {};
    if (message.playerId1 !== undefined && message.playerId1 !== 0) {
      obj.playerId1 = Math.round(message.playerId1);
    }
    if (message.playerId2 !== undefined && message.playerId2 !== 0) {
      obj.playerId2 = Math.round(message.playerId2);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgDuelAccepted>): CDOTAUserMsgDuelAccepted {
    return CDOTAUserMsgDuelAccepted.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgDuelAccepted>): CDOTAUserMsgDuelAccepted {
    const message = createBaseCDOTAUserMsgDuelAccepted();
    message.playerId1 = object.playerId1 ?? 0;
    message.playerId2 = object.playerId2 ?? 0;
    return message;
  },
};

function createBaseCDOTAUserMsgDuelRequested(): CDOTAUserMsgDuelRequested {
  return { playerIdRequestor: -1 };
}

export const CDOTAUserMsgDuelRequested = {
  encode(message: CDOTAUserMsgDuelRequested, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.playerIdRequestor !== undefined && message.playerIdRequestor !== -1) {
      writer.uint32(8).int32(message.playerIdRequestor);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgDuelRequested {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgDuelRequested();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.playerIdRequestor = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgDuelRequested {
    return { playerIdRequestor: isSet(object.playerIdRequestor) ? globalThis.Number(object.playerIdRequestor) : -1 };
  },

  toJSON(message: CDOTAUserMsgDuelRequested): unknown {
    const obj: any = {};
    if (message.playerIdRequestor !== undefined && message.playerIdRequestor !== -1) {
      obj.playerIdRequestor = Math.round(message.playerIdRequestor);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgDuelRequested>): CDOTAUserMsgDuelRequested {
    return CDOTAUserMsgDuelRequested.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgDuelRequested>): CDOTAUserMsgDuelRequested {
    const message = createBaseCDOTAUserMsgDuelRequested();
    message.playerIdRequestor = object.playerIdRequestor ?? -1;
    return message;
  },
};

function createBaseCDOTAUserMsgMuertaReleaseEventAssignedTargetKilled(): CDOTAUserMsgMuertaReleaseEventAssignedTargetKilled {
  return { playerIdKiller: -1, playerIdTarget: -1, points: 0, pointsTotal: 0, lastHit: false };
}

export const CDOTAUserMsgMuertaReleaseEventAssignedTargetKilled = {
  encode(
    message: CDOTAUserMsgMuertaReleaseEventAssignedTargetKilled,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.playerIdKiller !== -1) {
      writer.uint32(8).int32(message.playerIdKiller);
    }
    if (message.playerIdTarget !== -1) {
      writer.uint32(16).int32(message.playerIdTarget);
    }
    if (message.points !== 0) {
      writer.uint32(24).int32(message.points);
    }
    if (message.pointsTotal !== 0) {
      writer.uint32(32).int32(message.pointsTotal);
    }
    if (message.lastHit !== false) {
      writer.uint32(40).bool(message.lastHit);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgMuertaReleaseEventAssignedTargetKilled {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgMuertaReleaseEventAssignedTargetKilled();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.playerIdKiller = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.playerIdTarget = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.points = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.pointsTotal = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.lastHit = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgMuertaReleaseEventAssignedTargetKilled {
    return {
      playerIdKiller: isSet(object.playerIdKiller) ? globalThis.Number(object.playerIdKiller) : -1,
      playerIdTarget: isSet(object.playerIdTarget) ? globalThis.Number(object.playerIdTarget) : -1,
      points: isSet(object.points) ? globalThis.Number(object.points) : 0,
      pointsTotal: isSet(object.pointsTotal) ? globalThis.Number(object.pointsTotal) : 0,
      lastHit: isSet(object.lastHit) ? globalThis.Boolean(object.lastHit) : false,
    };
  },

  toJSON(message: CDOTAUserMsgMuertaReleaseEventAssignedTargetKilled): unknown {
    const obj: any = {};
    if (message.playerIdKiller !== -1) {
      obj.playerIdKiller = Math.round(message.playerIdKiller);
    }
    if (message.playerIdTarget !== -1) {
      obj.playerIdTarget = Math.round(message.playerIdTarget);
    }
    if (message.points !== 0) {
      obj.points = Math.round(message.points);
    }
    if (message.pointsTotal !== 0) {
      obj.pointsTotal = Math.round(message.pointsTotal);
    }
    if (message.lastHit !== false) {
      obj.lastHit = message.lastHit;
    }
    return obj;
  },

  create(
    base?: DeepPartial<CDOTAUserMsgMuertaReleaseEventAssignedTargetKilled>,
  ): CDOTAUserMsgMuertaReleaseEventAssignedTargetKilled {
    return CDOTAUserMsgMuertaReleaseEventAssignedTargetKilled.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CDOTAUserMsgMuertaReleaseEventAssignedTargetKilled>,
  ): CDOTAUserMsgMuertaReleaseEventAssignedTargetKilled {
    const message = createBaseCDOTAUserMsgMuertaReleaseEventAssignedTargetKilled();
    message.playerIdKiller = object.playerIdKiller ?? -1;
    message.playerIdTarget = object.playerIdTarget ?? -1;
    message.points = object.points ?? 0;
    message.pointsTotal = object.pointsTotal ?? 0;
    message.lastHit = object.lastHit ?? false;
    return message;
  },
};

function createBaseCDOTAUserMsgPlayerDraftSuggestPick(): CDOTAUserMsgPlayerDraftSuggestPick {
  return { playerId: -1, suggestionPlayerId: -1 };
}

export const CDOTAUserMsgPlayerDraftSuggestPick = {
  encode(message: CDOTAUserMsgPlayerDraftSuggestPick, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.playerId !== undefined && message.playerId !== -1) {
      writer.uint32(8).int32(message.playerId);
    }
    if (message.suggestionPlayerId !== undefined && message.suggestionPlayerId !== -1) {
      writer.uint32(16).int32(message.suggestionPlayerId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgPlayerDraftSuggestPick {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgPlayerDraftSuggestPick();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.playerId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.suggestionPlayerId = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgPlayerDraftSuggestPick {
    return {
      playerId: isSet(object.playerId) ? globalThis.Number(object.playerId) : -1,
      suggestionPlayerId: isSet(object.suggestionPlayerId) ? globalThis.Number(object.suggestionPlayerId) : -1,
    };
  },

  toJSON(message: CDOTAUserMsgPlayerDraftSuggestPick): unknown {
    const obj: any = {};
    if (message.playerId !== undefined && message.playerId !== -1) {
      obj.playerId = Math.round(message.playerId);
    }
    if (message.suggestionPlayerId !== undefined && message.suggestionPlayerId !== -1) {
      obj.suggestionPlayerId = Math.round(message.suggestionPlayerId);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgPlayerDraftSuggestPick>): CDOTAUserMsgPlayerDraftSuggestPick {
    return CDOTAUserMsgPlayerDraftSuggestPick.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgPlayerDraftSuggestPick>): CDOTAUserMsgPlayerDraftSuggestPick {
    const message = createBaseCDOTAUserMsgPlayerDraftSuggestPick();
    message.playerId = object.playerId ?? -1;
    message.suggestionPlayerId = object.suggestionPlayerId ?? -1;
    return message;
  },
};

function createBaseCDOTAUserMsgPlayerDraftPick(): CDOTAUserMsgPlayerDraftPick {
  return { playerIdCaptain: -1, playerIdTarget: -1, team: 0 };
}

export const CDOTAUserMsgPlayerDraftPick = {
  encode(message: CDOTAUserMsgPlayerDraftPick, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.playerIdCaptain !== undefined && message.playerIdCaptain !== -1) {
      writer.uint32(8).int32(message.playerIdCaptain);
    }
    if (message.playerIdTarget !== undefined && message.playerIdTarget !== -1) {
      writer.uint32(16).int32(message.playerIdTarget);
    }
    if (message.team !== undefined && message.team !== 0) {
      writer.uint32(24).int32(message.team);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgPlayerDraftPick {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgPlayerDraftPick();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.playerIdCaptain = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.playerIdTarget = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.team = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgPlayerDraftPick {
    return {
      playerIdCaptain: isSet(object.playerIdCaptain) ? globalThis.Number(object.playerIdCaptain) : -1,
      playerIdTarget: isSet(object.playerIdTarget) ? globalThis.Number(object.playerIdTarget) : -1,
      team: isSet(object.team) ? globalThis.Number(object.team) : 0,
    };
  },

  toJSON(message: CDOTAUserMsgPlayerDraftPick): unknown {
    const obj: any = {};
    if (message.playerIdCaptain !== undefined && message.playerIdCaptain !== -1) {
      obj.playerIdCaptain = Math.round(message.playerIdCaptain);
    }
    if (message.playerIdTarget !== undefined && message.playerIdTarget !== -1) {
      obj.playerIdTarget = Math.round(message.playerIdTarget);
    }
    if (message.team !== undefined && message.team !== 0) {
      obj.team = Math.round(message.team);
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgPlayerDraftPick>): CDOTAUserMsgPlayerDraftPick {
    return CDOTAUserMsgPlayerDraftPick.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgPlayerDraftPick>): CDOTAUserMsgPlayerDraftPick {
    const message = createBaseCDOTAUserMsgPlayerDraftPick();
    message.playerIdCaptain = object.playerIdCaptain ?? -1;
    message.playerIdTarget = object.playerIdTarget ?? -1;
    message.team = object.team ?? 0;
    return message;
  },
};

function createBaseCDOTAUserMsgFacetPing(): CDOTAUserMsgFacetPing {
  return { playerId: -1, facetStrhash: 0, entityId: 0, allChat: false };
}

export const CDOTAUserMsgFacetPing = {
  encode(message: CDOTAUserMsgFacetPing, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.playerId !== undefined && message.playerId !== -1) {
      writer.uint32(8).int32(message.playerId);
    }
    if (message.facetStrhash !== undefined && message.facetStrhash !== 0) {
      writer.uint32(16).uint32(message.facetStrhash);
    }
    if (message.entityId !== undefined && message.entityId !== 0) {
      writer.uint32(24).uint32(message.entityId);
    }
    if (message.allChat !== undefined && message.allChat !== false) {
      writer.uint32(32).bool(message.allChat);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgFacetPing {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgFacetPing();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.playerId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.facetStrhash = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.entityId = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.allChat = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgFacetPing {
    return {
      playerId: isSet(object.playerId) ? globalThis.Number(object.playerId) : -1,
      facetStrhash: isSet(object.facetStrhash) ? globalThis.Number(object.facetStrhash) : 0,
      entityId: isSet(object.entityId) ? globalThis.Number(object.entityId) : 0,
      allChat: isSet(object.allChat) ? globalThis.Boolean(object.allChat) : false,
    };
  },

  toJSON(message: CDOTAUserMsgFacetPing): unknown {
    const obj: any = {};
    if (message.playerId !== undefined && message.playerId !== -1) {
      obj.playerId = Math.round(message.playerId);
    }
    if (message.facetStrhash !== undefined && message.facetStrhash !== 0) {
      obj.facetStrhash = Math.round(message.facetStrhash);
    }
    if (message.entityId !== undefined && message.entityId !== 0) {
      obj.entityId = Math.round(message.entityId);
    }
    if (message.allChat !== undefined && message.allChat !== false) {
      obj.allChat = message.allChat;
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgFacetPing>): CDOTAUserMsgFacetPing {
    return CDOTAUserMsgFacetPing.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgFacetPing>): CDOTAUserMsgFacetPing {
    const message = createBaseCDOTAUserMsgFacetPing();
    message.playerId = object.playerId ?? -1;
    message.facetStrhash = object.facetStrhash ?? 0;
    message.entityId = object.entityId ?? 0;
    message.allChat = object.allChat ?? false;
    return message;
  },
};

function createBaseCDOTAUserMsgInnatePing(): CDOTAUserMsgInnatePing {
  return { playerId: -1, entityId: 0, allChat: false };
}

export const CDOTAUserMsgInnatePing = {
  encode(message: CDOTAUserMsgInnatePing, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.playerId !== undefined && message.playerId !== -1) {
      writer.uint32(8).int32(message.playerId);
    }
    if (message.entityId !== undefined && message.entityId !== 0) {
      writer.uint32(16).uint32(message.entityId);
    }
    if (message.allChat !== undefined && message.allChat !== false) {
      writer.uint32(24).bool(message.allChat);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CDOTAUserMsgInnatePing {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDOTAUserMsgInnatePing();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.playerId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.entityId = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.allChat = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDOTAUserMsgInnatePing {
    return {
      playerId: isSet(object.playerId) ? globalThis.Number(object.playerId) : -1,
      entityId: isSet(object.entityId) ? globalThis.Number(object.entityId) : 0,
      allChat: isSet(object.allChat) ? globalThis.Boolean(object.allChat) : false,
    };
  },

  toJSON(message: CDOTAUserMsgInnatePing): unknown {
    const obj: any = {};
    if (message.playerId !== undefined && message.playerId !== -1) {
      obj.playerId = Math.round(message.playerId);
    }
    if (message.entityId !== undefined && message.entityId !== 0) {
      obj.entityId = Math.round(message.entityId);
    }
    if (message.allChat !== undefined && message.allChat !== false) {
      obj.allChat = message.allChat;
    }
    return obj;
  },

  create(base?: DeepPartial<CDOTAUserMsgInnatePing>): CDOTAUserMsgInnatePing {
    return CDOTAUserMsgInnatePing.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CDOTAUserMsgInnatePing>): CDOTAUserMsgInnatePing {
    const message = createBaseCDOTAUserMsgInnatePing();
    message.playerId = object.playerId ?? -1;
    message.entityId = object.entityId ?? 0;
    message.allChat = object.allChat ?? false;
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin
  ? T
  : T extends globalThis.Array<infer U>
    ? globalThis.Array<DeepPartial<U>>
    : T extends ReadonlyArray<infer U>
      ? ReadonlyArray<DeepPartial<U>>
      : T extends {}
        ? { [K in keyof T]?: DeepPartial<T[K]> }
        : Partial<T>;

function longToString(long: Long) {
  return long.toString();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

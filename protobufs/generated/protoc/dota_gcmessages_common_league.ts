// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.176.1
//   protoc               v5.26.1
// source: dota_gcmessages_common_league.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";
import {
  ELeagueBroadcastProvider,
  eLeagueBroadcastProviderFromJSON,
  eLeagueBroadcastProviderToJSON,
  ELeagueDivision,
  eLeagueDivisionFromJSON,
  eLeagueDivisionToJSON,
  ELeaguePhase,
  eLeaguePhaseFromJSON,
  eLeaguePhaseToJSON,
  ELeagueRegion,
  eLeagueRegionFromJSON,
  eLeagueRegionToJSON,
  ELeagueStatus,
  eLeagueStatusFromJSON,
  eLeagueStatusToJSON,
  ELeagueTier,
  eLeagueTierFromJSON,
  eLeagueTierToJSON,
} from "./dota_shared_enums";

export enum ELeagueNodeGroupType {
  INVALID_GROUP_TYPE = 0,
  ORGANIZATIONAL = 1,
  ROUND_ROBIN = 2,
  SWISS = 3,
  BRACKET_SINGLE = 4,
  BRACKET_DOUBLE_SEED_LOSER = 5,
  BRACKET_DOUBLE_ALL_WINNER = 6,
  SHOWMATCH = 7,
  GSL = 8,
  PLACEMENT = 9,
}

export function eLeagueNodeGroupTypeFromJSON(object: any): ELeagueNodeGroupType {
  switch (object) {
    case 0:
    case "INVALID_GROUP_TYPE":
      return ELeagueNodeGroupType.INVALID_GROUP_TYPE;
    case 1:
    case "ORGANIZATIONAL":
      return ELeagueNodeGroupType.ORGANIZATIONAL;
    case 2:
    case "ROUND_ROBIN":
      return ELeagueNodeGroupType.ROUND_ROBIN;
    case 3:
    case "SWISS":
      return ELeagueNodeGroupType.SWISS;
    case 4:
    case "BRACKET_SINGLE":
      return ELeagueNodeGroupType.BRACKET_SINGLE;
    case 5:
    case "BRACKET_DOUBLE_SEED_LOSER":
      return ELeagueNodeGroupType.BRACKET_DOUBLE_SEED_LOSER;
    case 6:
    case "BRACKET_DOUBLE_ALL_WINNER":
      return ELeagueNodeGroupType.BRACKET_DOUBLE_ALL_WINNER;
    case 7:
    case "SHOWMATCH":
      return ELeagueNodeGroupType.SHOWMATCH;
    case 8:
    case "GSL":
      return ELeagueNodeGroupType.GSL;
    case 9:
    case "PLACEMENT":
      return ELeagueNodeGroupType.PLACEMENT;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ELeagueNodeGroupType");
  }
}

export function eLeagueNodeGroupTypeToJSON(object: ELeagueNodeGroupType): string {
  switch (object) {
    case ELeagueNodeGroupType.INVALID_GROUP_TYPE:
      return "INVALID_GROUP_TYPE";
    case ELeagueNodeGroupType.ORGANIZATIONAL:
      return "ORGANIZATIONAL";
    case ELeagueNodeGroupType.ROUND_ROBIN:
      return "ROUND_ROBIN";
    case ELeagueNodeGroupType.SWISS:
      return "SWISS";
    case ELeagueNodeGroupType.BRACKET_SINGLE:
      return "BRACKET_SINGLE";
    case ELeagueNodeGroupType.BRACKET_DOUBLE_SEED_LOSER:
      return "BRACKET_DOUBLE_SEED_LOSER";
    case ELeagueNodeGroupType.BRACKET_DOUBLE_ALL_WINNER:
      return "BRACKET_DOUBLE_ALL_WINNER";
    case ELeagueNodeGroupType.SHOWMATCH:
      return "SHOWMATCH";
    case ELeagueNodeGroupType.GSL:
      return "GSL";
    case ELeagueNodeGroupType.PLACEMENT:
      return "PLACEMENT";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ELeagueNodeGroupType");
  }
}

export enum ELeagueNodeType {
  INVALID_NODE_TYPE = 0,
  BEST_OF_ONE = 1,
  BEST_OF_THREE = 2,
  BEST_OF_FIVE = 3,
  BEST_OF_TWO = 4,
}

export function eLeagueNodeTypeFromJSON(object: any): ELeagueNodeType {
  switch (object) {
    case 0:
    case "INVALID_NODE_TYPE":
      return ELeagueNodeType.INVALID_NODE_TYPE;
    case 1:
    case "BEST_OF_ONE":
      return ELeagueNodeType.BEST_OF_ONE;
    case 2:
    case "BEST_OF_THREE":
      return ELeagueNodeType.BEST_OF_THREE;
    case 3:
    case "BEST_OF_FIVE":
      return ELeagueNodeType.BEST_OF_FIVE;
    case 4:
    case "BEST_OF_TWO":
      return ELeagueNodeType.BEST_OF_TWO;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ELeagueNodeType");
  }
}

export function eLeagueNodeTypeToJSON(object: ELeagueNodeType): string {
  switch (object) {
    case ELeagueNodeType.INVALID_NODE_TYPE:
      return "INVALID_NODE_TYPE";
    case ELeagueNodeType.BEST_OF_ONE:
      return "BEST_OF_ONE";
    case ELeagueNodeType.BEST_OF_THREE:
      return "BEST_OF_THREE";
    case ELeagueNodeType.BEST_OF_FIVE:
      return "BEST_OF_FIVE";
    case ELeagueNodeType.BEST_OF_TWO:
      return "BEST_OF_TWO";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ELeagueNodeType");
  }
}

export interface CMsgDOTALeagueNode {
  name?: string | undefined;
  nodeId?: number | undefined;
  nodeGroupId?: number | undefined;
  winningNodeId?: number | undefined;
  losingNodeId?: number | undefined;
  incomingNodeId1?: number | undefined;
  incomingNodeId2?: number | undefined;
  nodeType?: ELeagueNodeType | undefined;
  scheduledTime?: number | undefined;
  actualTime?: number | undefined;
  seriesId?: number | undefined;
  teamId1?: number | undefined;
  teamId2?: number | undefined;
  matches: CMsgDOTALeagueNode_MatchDetails[];
  team1Wins?: number | undefined;
  team2Wins?: number | undefined;
  hasStarted?: boolean | undefined;
  isCompleted?: boolean | undefined;
  streamIds: number[];
  vods: CMsgDOTALeagueNode_VOD[];
}

export interface CMsgDOTALeagueNode_MatchDetails {
  matchId?: string | undefined;
  winningTeamId?: number | undefined;
}

export interface CMsgDOTALeagueNode_VOD {
  seriesGame?: number | undefined;
  streamId?: number | undefined;
  url?: string | undefined;
}

export interface CMsgDOTALeagueNodeGroup {
  name?: string | undefined;
  nodeGroupId?: number | undefined;
  parentNodeGroupId?: number | undefined;
  incomingNodeGroupIds: number[];
  advancingNodeGroupId?: number | undefined;
  advancingTeamCount?: number | undefined;
  teamCount?: number | undefined;
  nodeGroupType?: ELeagueNodeGroupType | undefined;
  defaultNodeType?: ELeagueNodeType | undefined;
  round?: number | undefined;
  maxRounds?: number | undefined;
  isTiebreaker?: boolean | undefined;
  isFinalGroup?: boolean | undefined;
  isCompleted?: boolean | undefined;
  phase?: ELeaguePhase | undefined;
  region?: ELeagueRegion | undefined;
  startTime?: number | undefined;
  endTime?: number | undefined;
  secondaryAdvancingNodeGroupId?: number | undefined;
  secondaryAdvancingTeamCount?: number | undefined;
  tertiaryAdvancingNodeGroupId?: number | undefined;
  tertiaryAdvancingTeamCount?: number | undefined;
  eliminationDpcPoints?: number | undefined;
  teamStandings: CMsgDOTALeagueNodeGroup_TeamStanding[];
  nodes: CMsgDOTALeagueNode[];
  nodeGroups: CMsgDOTALeagueNodeGroup[];
}

export interface CMsgDOTALeagueNodeGroup_TeamStanding {
  standing?: number | undefined;
  teamId?: number | undefined;
  teamName?: string | undefined;
  teamTag?: string | undefined;
  teamLogo?: string | undefined;
  teamLogoUrl?: string | undefined;
  wins?: number | undefined;
  losses?: number | undefined;
  score?: string | undefined;
  teamAbbreviation?: string | undefined;
  scoreTiebreakGroup?: string | undefined;
  scoreTiebreakBelow?: string | undefined;
  scoreTiebreakRandom?: string | undefined;
  isPro?: boolean | undefined;
}

export interface CMsgDOTALeague {
  info?: CMsgDOTALeague_Info | undefined;
  prizePool?: CMsgDOTALeague_PrizePool | undefined;
  admins: CMsgDOTALeague_Admin[];
  streams: CMsgDOTALeague_Stream[];
  nodeGroups: CMsgDOTALeagueNodeGroup[];
  seriesInfos: CMsgDOTALeague_SeriesInfo[];
  registeredPlayers: CMsgDOTALeague_Player[];
}

export interface CMsgDOTALeague_Info {
  leagueId?: number | undefined;
  name?: string | undefined;
  tier?: ELeagueTier | undefined;
  region?: ELeagueRegion | undefined;
  url?: string | undefined;
  description?: string | undefined;
  notes?: string | undefined;
  startTimestamp?: number | undefined;
  endTimestamp?: number | undefined;
  proCircuitPoints?: number | undefined;
  imageBits?: number | undefined;
  status?: ELeagueStatus | undefined;
  mostRecentActivity?: number | undefined;
  registrationPeriod?: number | undefined;
}

export interface CMsgDOTALeague_Admin {
  accountId?: number | undefined;
  isPrimary?: boolean | undefined;
  emailAddress?: string | undefined;
}

export interface CMsgDOTALeague_PrizePoolItem {
  itemDef?: number | undefined;
  salesStopTimestamp?: number | undefined;
  revenuePct?: number | undefined;
  revenueCentsPerSale?: number | undefined;
}

export interface CMsgDOTALeague_PrizePool {
  basePrizePool?: number | undefined;
  totalPrizePool?: number | undefined;
  prizeSplitPctX100: number[];
  prizePoolItems: CMsgDOTALeague_PrizePoolItem[];
}

export interface CMsgDOTALeague_Stream {
  streamId?: number | undefined;
  language?: number | undefined;
  name?: string | undefined;
  broadcastProvider?: ELeagueBroadcastProvider | undefined;
  streamUrl?: string | undefined;
  vodUrl?: string | undefined;
}

export interface CMsgDOTALeague_SeriesInfo {
  seriesId?: number | undefined;
  seriesType?: number | undefined;
  startTime?: number | undefined;
  matchIds: string[];
  teamId1?: number | undefined;
  teamId2?: number | undefined;
}

export interface CMsgDOTALeague_Player {
  accountId?: number | undefined;
  name?: string | undefined;
  teamId?: number | undefined;
}

export interface CMsgDOTALeagueList {
  leagues: CMsgDOTALeague[];
}

export interface CMsgDOTALeagueInfo {
  leagueId?: number | undefined;
  name?: string | undefined;
  tier?: ELeagueTier | undefined;
  region?: ELeagueRegion | undefined;
  mostRecentActivity?: number | undefined;
  totalPrizePool?: number | undefined;
  startTimestamp?: number | undefined;
  endTimestamp?: number | undefined;
  status?: number | undefined;
}

export interface CMsgDOTALeagueInfoList {
  infos: CMsgDOTALeagueInfo[];
}

export interface CMsgDOTALeagueLiveGames {
  games: CMsgDOTALeagueLiveGames_LiveGame[];
}

export interface CMsgDOTALeagueLiveGames_LiveGame {
  leagueId?: number | undefined;
  serverSteamId?: string | undefined;
  radiantName?: string | undefined;
  radiantLogo?: string | undefined;
  radiantTeamId?: number | undefined;
  direName?: string | undefined;
  direLogo?: string | undefined;
  direTeamId?: number | undefined;
  time?: number | undefined;
  spectators?: number | undefined;
  leagueNodeId?: number | undefined;
  seriesId?: number | undefined;
  matchId?: string | undefined;
}

export interface CMsgDOTALeagueMessages {
  messages: CMsgDOTALeagueMessages_Message[];
}

export interface CMsgDOTALeagueMessages_Message {
  authorAccountId?: number | undefined;
  timestamp?: number | undefined;
  message?: string | undefined;
}

export interface CMsgDOTALeaguePrizePool {
  prizePool?: number | undefined;
  incrementPerSecond?: number | undefined;
}

export interface CMsgDOTALeagueInfoListAdminsRequest {
}

export interface CMsgDOTALeagueAvailableLobbyNodesRequest {
  leagueId?: number | undefined;
}

export interface CMsgDOTALeagueAvailableLobbyNodes {
  nodeInfos: CMsgDOTALeagueAvailableLobbyNodes_NodeInfo[];
}

export interface CMsgDOTALeagueAvailableLobbyNodes_NodeInfo {
  nodeId?: number | undefined;
  nodeName?: string | undefined;
  nodeGroupName?: string | undefined;
  teamId1?: number | undefined;
  teamId2?: number | undefined;
}

export interface CMsgDOTALeagueNodeResults {
  nodeResults: CMsgDOTALeagueNodeResults_Result[];
}

export interface CMsgDOTALeagueNodeResults_Result {
  nodeId?: number | undefined;
  winningNodeId?: number | undefined;
  losingNodeId?: number | undefined;
  incomingNodeId1?: number | undefined;
  incomingNodeId2?: number | undefined;
  teamId1?: number | undefined;
  teamId2?: number | undefined;
  team1Name?: string | undefined;
  team2Name?: string | undefined;
  team1Wins?: number | undefined;
  team2Wins?: number | undefined;
  winningTeamId?: number | undefined;
  losingTeamId?: number | undefined;
  hasStarted?: boolean | undefined;
  isCompleted?: boolean | undefined;
  scheduledTime?: number | undefined;
  matchIds: string[];
}

export interface CMsgDOTADPCLeagueResults {
  results: CMsgDOTADPCLeagueResults_Result[];
  points: number[];
  dollars: number[];
}

export interface CMsgDOTADPCLeagueResults_Result {
  standing?: number | undefined;
  teamId?: number | undefined;
  teamName?: string | undefined;
  teamLogo?: string | undefined;
  teamLogoUrl?: string | undefined;
  points?: number | undefined;
  earnings?: number | undefined;
  timestamp?: number | undefined;
  phase?: ELeaguePhase | undefined;
  teamAbbreviation?: string | undefined;
}

export interface CMsgDOTADPCTeamResults {
  results: CMsgDOTADPCTeamResults_Result[];
}

export interface CMsgDOTADPCTeamResults_Result {
  leagueId?: number | undefined;
  standing?: number | undefined;
  points?: number | undefined;
  earnings?: number | undefined;
  timestamp?: number | undefined;
}

export interface CMsgDOTADPCSeasonResults {
  results: CMsgDOTADPCSeasonResults_TeamResult[];
  standings: CMsgDOTADPCSeasonResults_Standing[];
  majorWildcardStandings: CMsgDOTADPCSeasonResults_StandingEntry[];
  majorGroupStandings: CMsgDOTADPCSeasonResults_StandingEntry[];
  majorPlayoffStandings: CMsgDOTADPCSeasonResults_StandingEntry[];
}

export interface CMsgDOTADPCSeasonResults_TeamLeagueResult {
  timestamp?: number | undefined;
  leagueId?: number | undefined;
  standing?: number | undefined;
  points?: number | undefined;
  earnings?: number | undefined;
  auditAction?: number | undefined;
  auditData?: number | undefined;
}

export interface CMsgDOTADPCSeasonResults_TeamResult {
  teamId?: number | undefined;
  teamName?: string | undefined;
  teamAbbreviation?: string | undefined;
  teamLogo?: string | undefined;
  teamLogoUrl?: string | undefined;
  totalPoints?: number | undefined;
  totalEarnings?: number | undefined;
  leagueResults: CMsgDOTADPCSeasonResults_TeamLeagueResult[];
}

export interface CMsgDOTADPCSeasonResults_StandingEntry {
  teamId?: number | undefined;
  wins?: number | undefined;
  losses?: number | undefined;
  teamUrl?: string | undefined;
  teamName?: string | undefined;
  teamAbbreviation?: string | undefined;
}

export interface CMsgDOTADPCSeasonResults_Standing {
  region?: ELeagueRegion | undefined;
  division?: ELeagueDivision | undefined;
  entries: CMsgDOTADPCSeasonResults_StandingEntry[];
}

export interface CMsgDOTADPCSeasonSpoilerResults {
  timeLastUpdated?: number | undefined;
  savedResults?: CMsgDOTADPCSeasonResults | undefined;
}

function createBaseCMsgDOTALeagueNode(): CMsgDOTALeagueNode {
  return {
    name: "",
    nodeId: 0,
    nodeGroupId: 0,
    winningNodeId: 0,
    losingNodeId: 0,
    incomingNodeId1: 0,
    incomingNodeId2: 0,
    nodeType: 0,
    scheduledTime: 0,
    actualTime: 0,
    seriesId: 0,
    teamId1: 0,
    teamId2: 0,
    matches: [],
    team1Wins: 0,
    team2Wins: 0,
    hasStarted: false,
    isCompleted: false,
    streamIds: [],
    vods: [],
  };
}

export const CMsgDOTALeagueNode = {
  encode(message: CMsgDOTALeagueNode, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.nodeId !== undefined && message.nodeId !== 0) {
      writer.uint32(16).uint32(message.nodeId);
    }
    if (message.nodeGroupId !== undefined && message.nodeGroupId !== 0) {
      writer.uint32(24).uint32(message.nodeGroupId);
    }
    if (message.winningNodeId !== undefined && message.winningNodeId !== 0) {
      writer.uint32(32).uint32(message.winningNodeId);
    }
    if (message.losingNodeId !== undefined && message.losingNodeId !== 0) {
      writer.uint32(40).uint32(message.losingNodeId);
    }
    if (message.incomingNodeId1 !== undefined && message.incomingNodeId1 !== 0) {
      writer.uint32(48).uint32(message.incomingNodeId1);
    }
    if (message.incomingNodeId2 !== undefined && message.incomingNodeId2 !== 0) {
      writer.uint32(56).uint32(message.incomingNodeId2);
    }
    if (message.nodeType !== undefined && message.nodeType !== 0) {
      writer.uint32(64).int32(message.nodeType);
    }
    if (message.scheduledTime !== undefined && message.scheduledTime !== 0) {
      writer.uint32(72).uint32(message.scheduledTime);
    }
    if (message.actualTime !== undefined && message.actualTime !== 0) {
      writer.uint32(152).uint32(message.actualTime);
    }
    if (message.seriesId !== undefined && message.seriesId !== 0) {
      writer.uint32(80).uint32(message.seriesId);
    }
    if (message.teamId1 !== undefined && message.teamId1 !== 0) {
      writer.uint32(88).uint32(message.teamId1);
    }
    if (message.teamId2 !== undefined && message.teamId2 !== 0) {
      writer.uint32(96).uint32(message.teamId2);
    }
    for (const v of message.matches) {
      CMsgDOTALeagueNode_MatchDetails.encode(v!, writer.uint32(106).fork()).ldelim();
    }
    if (message.team1Wins !== undefined && message.team1Wins !== 0) {
      writer.uint32(112).uint32(message.team1Wins);
    }
    if (message.team2Wins !== undefined && message.team2Wins !== 0) {
      writer.uint32(120).uint32(message.team2Wins);
    }
    if (message.hasStarted !== undefined && message.hasStarted !== false) {
      writer.uint32(128).bool(message.hasStarted);
    }
    if (message.isCompleted !== undefined && message.isCompleted !== false) {
      writer.uint32(136).bool(message.isCompleted);
    }
    writer.uint32(146).fork();
    for (const v of message.streamIds) {
      writer.uint32(v);
    }
    writer.ldelim();
    for (const v of message.vods) {
      CMsgDOTALeagueNode_VOD.encode(v!, writer.uint32(162).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTALeagueNode {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTALeagueNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.nodeId = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.nodeGroupId = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.winningNodeId = reader.uint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.losingNodeId = reader.uint32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.incomingNodeId1 = reader.uint32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.incomingNodeId2 = reader.uint32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.nodeType = reader.int32() as any;
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.scheduledTime = reader.uint32();
          continue;
        case 19:
          if (tag !== 152) {
            break;
          }

          message.actualTime = reader.uint32();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.seriesId = reader.uint32();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.teamId1 = reader.uint32();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.teamId2 = reader.uint32();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.matches.push(CMsgDOTALeagueNode_MatchDetails.decode(reader, reader.uint32()));
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.team1Wins = reader.uint32();
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.team2Wins = reader.uint32();
          continue;
        case 16:
          if (tag !== 128) {
            break;
          }

          message.hasStarted = reader.bool();
          continue;
        case 17:
          if (tag !== 136) {
            break;
          }

          message.isCompleted = reader.bool();
          continue;
        case 18:
          if (tag === 144) {
            message.streamIds.push(reader.uint32());

            continue;
          }

          if (tag === 146) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.streamIds.push(reader.uint32());
            }

            continue;
          }

          break;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.vods.push(CMsgDOTALeagueNode_VOD.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTALeagueNode {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      nodeId: isSet(object.nodeId) ? globalThis.Number(object.nodeId) : 0,
      nodeGroupId: isSet(object.nodeGroupId) ? globalThis.Number(object.nodeGroupId) : 0,
      winningNodeId: isSet(object.winningNodeId) ? globalThis.Number(object.winningNodeId) : 0,
      losingNodeId: isSet(object.losingNodeId) ? globalThis.Number(object.losingNodeId) : 0,
      incomingNodeId1: isSet(object.incomingNodeId1) ? globalThis.Number(object.incomingNodeId1) : 0,
      incomingNodeId2: isSet(object.incomingNodeId2) ? globalThis.Number(object.incomingNodeId2) : 0,
      nodeType: isSet(object.nodeType) ? eLeagueNodeTypeFromJSON(object.nodeType) : 0,
      scheduledTime: isSet(object.scheduledTime) ? globalThis.Number(object.scheduledTime) : 0,
      actualTime: isSet(object.actualTime) ? globalThis.Number(object.actualTime) : 0,
      seriesId: isSet(object.seriesId) ? globalThis.Number(object.seriesId) : 0,
      teamId1: isSet(object.teamId1) ? globalThis.Number(object.teamId1) : 0,
      teamId2: isSet(object.teamId2) ? globalThis.Number(object.teamId2) : 0,
      matches: globalThis.Array.isArray(object?.matches)
        ? object.matches.map((e: any) => CMsgDOTALeagueNode_MatchDetails.fromJSON(e))
        : [],
      team1Wins: isSet(object.team1Wins) ? globalThis.Number(object.team1Wins) : 0,
      team2Wins: isSet(object.team2Wins) ? globalThis.Number(object.team2Wins) : 0,
      hasStarted: isSet(object.hasStarted) ? globalThis.Boolean(object.hasStarted) : false,
      isCompleted: isSet(object.isCompleted) ? globalThis.Boolean(object.isCompleted) : false,
      streamIds: globalThis.Array.isArray(object?.streamIds)
        ? object.streamIds.map((e: any) => globalThis.Number(e))
        : [],
      vods: globalThis.Array.isArray(object?.vods)
        ? object.vods.map((e: any) => CMsgDOTALeagueNode_VOD.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgDOTALeagueNode): unknown {
    const obj: any = {};
    if (message.name !== undefined && message.name !== "") {
      obj.name = message.name;
    }
    if (message.nodeId !== undefined && message.nodeId !== 0) {
      obj.nodeId = Math.round(message.nodeId);
    }
    if (message.nodeGroupId !== undefined && message.nodeGroupId !== 0) {
      obj.nodeGroupId = Math.round(message.nodeGroupId);
    }
    if (message.winningNodeId !== undefined && message.winningNodeId !== 0) {
      obj.winningNodeId = Math.round(message.winningNodeId);
    }
    if (message.losingNodeId !== undefined && message.losingNodeId !== 0) {
      obj.losingNodeId = Math.round(message.losingNodeId);
    }
    if (message.incomingNodeId1 !== undefined && message.incomingNodeId1 !== 0) {
      obj.incomingNodeId1 = Math.round(message.incomingNodeId1);
    }
    if (message.incomingNodeId2 !== undefined && message.incomingNodeId2 !== 0) {
      obj.incomingNodeId2 = Math.round(message.incomingNodeId2);
    }
    if (message.nodeType !== undefined && message.nodeType !== 0) {
      obj.nodeType = eLeagueNodeTypeToJSON(message.nodeType);
    }
    if (message.scheduledTime !== undefined && message.scheduledTime !== 0) {
      obj.scheduledTime = Math.round(message.scheduledTime);
    }
    if (message.actualTime !== undefined && message.actualTime !== 0) {
      obj.actualTime = Math.round(message.actualTime);
    }
    if (message.seriesId !== undefined && message.seriesId !== 0) {
      obj.seriesId = Math.round(message.seriesId);
    }
    if (message.teamId1 !== undefined && message.teamId1 !== 0) {
      obj.teamId1 = Math.round(message.teamId1);
    }
    if (message.teamId2 !== undefined && message.teamId2 !== 0) {
      obj.teamId2 = Math.round(message.teamId2);
    }
    if (message.matches?.length) {
      obj.matches = message.matches.map((e) => CMsgDOTALeagueNode_MatchDetails.toJSON(e));
    }
    if (message.team1Wins !== undefined && message.team1Wins !== 0) {
      obj.team1Wins = Math.round(message.team1Wins);
    }
    if (message.team2Wins !== undefined && message.team2Wins !== 0) {
      obj.team2Wins = Math.round(message.team2Wins);
    }
    if (message.hasStarted !== undefined && message.hasStarted !== false) {
      obj.hasStarted = message.hasStarted;
    }
    if (message.isCompleted !== undefined && message.isCompleted !== false) {
      obj.isCompleted = message.isCompleted;
    }
    if (message.streamIds?.length) {
      obj.streamIds = message.streamIds.map((e) => Math.round(e));
    }
    if (message.vods?.length) {
      obj.vods = message.vods.map((e) => CMsgDOTALeagueNode_VOD.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTALeagueNode>): CMsgDOTALeagueNode {
    return CMsgDOTALeagueNode.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTALeagueNode>): CMsgDOTALeagueNode {
    const message = createBaseCMsgDOTALeagueNode();
    message.name = object.name ?? "";
    message.nodeId = object.nodeId ?? 0;
    message.nodeGroupId = object.nodeGroupId ?? 0;
    message.winningNodeId = object.winningNodeId ?? 0;
    message.losingNodeId = object.losingNodeId ?? 0;
    message.incomingNodeId1 = object.incomingNodeId1 ?? 0;
    message.incomingNodeId2 = object.incomingNodeId2 ?? 0;
    message.nodeType = object.nodeType ?? 0;
    message.scheduledTime = object.scheduledTime ?? 0;
    message.actualTime = object.actualTime ?? 0;
    message.seriesId = object.seriesId ?? 0;
    message.teamId1 = object.teamId1 ?? 0;
    message.teamId2 = object.teamId2 ?? 0;
    message.matches = object.matches?.map((e) => CMsgDOTALeagueNode_MatchDetails.fromPartial(e)) || [];
    message.team1Wins = object.team1Wins ?? 0;
    message.team2Wins = object.team2Wins ?? 0;
    message.hasStarted = object.hasStarted ?? false;
    message.isCompleted = object.isCompleted ?? false;
    message.streamIds = object.streamIds?.map((e) => e) || [];
    message.vods = object.vods?.map((e) => CMsgDOTALeagueNode_VOD.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgDOTALeagueNode_MatchDetails(): CMsgDOTALeagueNode_MatchDetails {
  return { matchId: "0", winningTeamId: 0 };
}

export const CMsgDOTALeagueNode_MatchDetails = {
  encode(message: CMsgDOTALeagueNode_MatchDetails, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.matchId !== undefined && message.matchId !== "0") {
      writer.uint32(8).uint64(message.matchId);
    }
    if (message.winningTeamId !== undefined && message.winningTeamId !== 0) {
      writer.uint32(16).uint32(message.winningTeamId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTALeagueNode_MatchDetails {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTALeagueNode_MatchDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.matchId = longToString(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.winningTeamId = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTALeagueNode_MatchDetails {
    return {
      matchId: isSet(object.matchId) ? globalThis.String(object.matchId) : "0",
      winningTeamId: isSet(object.winningTeamId) ? globalThis.Number(object.winningTeamId) : 0,
    };
  },

  toJSON(message: CMsgDOTALeagueNode_MatchDetails): unknown {
    const obj: any = {};
    if (message.matchId !== undefined && message.matchId !== "0") {
      obj.matchId = message.matchId;
    }
    if (message.winningTeamId !== undefined && message.winningTeamId !== 0) {
      obj.winningTeamId = Math.round(message.winningTeamId);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTALeagueNode_MatchDetails>): CMsgDOTALeagueNode_MatchDetails {
    return CMsgDOTALeagueNode_MatchDetails.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTALeagueNode_MatchDetails>): CMsgDOTALeagueNode_MatchDetails {
    const message = createBaseCMsgDOTALeagueNode_MatchDetails();
    message.matchId = object.matchId ?? "0";
    message.winningTeamId = object.winningTeamId ?? 0;
    return message;
  },
};

function createBaseCMsgDOTALeagueNode_VOD(): CMsgDOTALeagueNode_VOD {
  return { seriesGame: 0, streamId: 0, url: "" };
}

export const CMsgDOTALeagueNode_VOD = {
  encode(message: CMsgDOTALeagueNode_VOD, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.seriesGame !== undefined && message.seriesGame !== 0) {
      writer.uint32(8).uint32(message.seriesGame);
    }
    if (message.streamId !== undefined && message.streamId !== 0) {
      writer.uint32(16).uint32(message.streamId);
    }
    if (message.url !== undefined && message.url !== "") {
      writer.uint32(26).string(message.url);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTALeagueNode_VOD {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTALeagueNode_VOD();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.seriesGame = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.streamId = reader.uint32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.url = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTALeagueNode_VOD {
    return {
      seriesGame: isSet(object.seriesGame) ? globalThis.Number(object.seriesGame) : 0,
      streamId: isSet(object.streamId) ? globalThis.Number(object.streamId) : 0,
      url: isSet(object.url) ? globalThis.String(object.url) : "",
    };
  },

  toJSON(message: CMsgDOTALeagueNode_VOD): unknown {
    const obj: any = {};
    if (message.seriesGame !== undefined && message.seriesGame !== 0) {
      obj.seriesGame = Math.round(message.seriesGame);
    }
    if (message.streamId !== undefined && message.streamId !== 0) {
      obj.streamId = Math.round(message.streamId);
    }
    if (message.url !== undefined && message.url !== "") {
      obj.url = message.url;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTALeagueNode_VOD>): CMsgDOTALeagueNode_VOD {
    return CMsgDOTALeagueNode_VOD.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTALeagueNode_VOD>): CMsgDOTALeagueNode_VOD {
    const message = createBaseCMsgDOTALeagueNode_VOD();
    message.seriesGame = object.seriesGame ?? 0;
    message.streamId = object.streamId ?? 0;
    message.url = object.url ?? "";
    return message;
  },
};

function createBaseCMsgDOTALeagueNodeGroup(): CMsgDOTALeagueNodeGroup {
  return {
    name: "",
    nodeGroupId: 0,
    parentNodeGroupId: 0,
    incomingNodeGroupIds: [],
    advancingNodeGroupId: 0,
    advancingTeamCount: 0,
    teamCount: 0,
    nodeGroupType: 0,
    defaultNodeType: 0,
    round: 0,
    maxRounds: 0,
    isTiebreaker: false,
    isFinalGroup: false,
    isCompleted: false,
    phase: 0,
    region: 0,
    startTime: 0,
    endTime: 0,
    secondaryAdvancingNodeGroupId: 0,
    secondaryAdvancingTeamCount: 0,
    tertiaryAdvancingNodeGroupId: 0,
    tertiaryAdvancingTeamCount: 0,
    eliminationDpcPoints: 0,
    teamStandings: [],
    nodes: [],
    nodeGroups: [],
  };
}

export const CMsgDOTALeagueNodeGroup = {
  encode(message: CMsgDOTALeagueNodeGroup, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.nodeGroupId !== undefined && message.nodeGroupId !== 0) {
      writer.uint32(16).uint32(message.nodeGroupId);
    }
    if (message.parentNodeGroupId !== undefined && message.parentNodeGroupId !== 0) {
      writer.uint32(24).uint32(message.parentNodeGroupId);
    }
    writer.uint32(34).fork();
    for (const v of message.incomingNodeGroupIds) {
      writer.uint32(v);
    }
    writer.ldelim();
    if (message.advancingNodeGroupId !== undefined && message.advancingNodeGroupId !== 0) {
      writer.uint32(40).uint32(message.advancingNodeGroupId);
    }
    if (message.advancingTeamCount !== undefined && message.advancingTeamCount !== 0) {
      writer.uint32(48).uint32(message.advancingTeamCount);
    }
    if (message.teamCount !== undefined && message.teamCount !== 0) {
      writer.uint32(56).uint32(message.teamCount);
    }
    if (message.nodeGroupType !== undefined && message.nodeGroupType !== 0) {
      writer.uint32(64).int32(message.nodeGroupType);
    }
    if (message.defaultNodeType !== undefined && message.defaultNodeType !== 0) {
      writer.uint32(72).int32(message.defaultNodeType);
    }
    if (message.round !== undefined && message.round !== 0) {
      writer.uint32(80).uint32(message.round);
    }
    if (message.maxRounds !== undefined && message.maxRounds !== 0) {
      writer.uint32(88).uint32(message.maxRounds);
    }
    if (message.isTiebreaker !== undefined && message.isTiebreaker !== false) {
      writer.uint32(96).bool(message.isTiebreaker);
    }
    if (message.isFinalGroup !== undefined && message.isFinalGroup !== false) {
      writer.uint32(104).bool(message.isFinalGroup);
    }
    if (message.isCompleted !== undefined && message.isCompleted !== false) {
      writer.uint32(112).bool(message.isCompleted);
    }
    if (message.phase !== undefined && message.phase !== 0) {
      writer.uint32(144).int32(message.phase);
    }
    if (message.region !== undefined && message.region !== 0) {
      writer.uint32(152).int32(message.region);
    }
    if (message.startTime !== undefined && message.startTime !== 0) {
      writer.uint32(160).uint32(message.startTime);
    }
    if (message.endTime !== undefined && message.endTime !== 0) {
      writer.uint32(168).uint32(message.endTime);
    }
    if (message.secondaryAdvancingNodeGroupId !== undefined && message.secondaryAdvancingNodeGroupId !== 0) {
      writer.uint32(176).uint32(message.secondaryAdvancingNodeGroupId);
    }
    if (message.secondaryAdvancingTeamCount !== undefined && message.secondaryAdvancingTeamCount !== 0) {
      writer.uint32(184).uint32(message.secondaryAdvancingTeamCount);
    }
    if (message.tertiaryAdvancingNodeGroupId !== undefined && message.tertiaryAdvancingNodeGroupId !== 0) {
      writer.uint32(192).uint32(message.tertiaryAdvancingNodeGroupId);
    }
    if (message.tertiaryAdvancingTeamCount !== undefined && message.tertiaryAdvancingTeamCount !== 0) {
      writer.uint32(200).uint32(message.tertiaryAdvancingTeamCount);
    }
    if (message.eliminationDpcPoints !== undefined && message.eliminationDpcPoints !== 0) {
      writer.uint32(208).uint32(message.eliminationDpcPoints);
    }
    for (const v of message.teamStandings) {
      CMsgDOTALeagueNodeGroup_TeamStanding.encode(v!, writer.uint32(122).fork()).ldelim();
    }
    for (const v of message.nodes) {
      CMsgDOTALeagueNode.encode(v!, writer.uint32(130).fork()).ldelim();
    }
    for (const v of message.nodeGroups) {
      CMsgDOTALeagueNodeGroup.encode(v!, writer.uint32(138).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTALeagueNodeGroup {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTALeagueNodeGroup();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.nodeGroupId = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.parentNodeGroupId = reader.uint32();
          continue;
        case 4:
          if (tag === 32) {
            message.incomingNodeGroupIds.push(reader.uint32());

            continue;
          }

          if (tag === 34) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.incomingNodeGroupIds.push(reader.uint32());
            }

            continue;
          }

          break;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.advancingNodeGroupId = reader.uint32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.advancingTeamCount = reader.uint32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.teamCount = reader.uint32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.nodeGroupType = reader.int32() as any;
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.defaultNodeType = reader.int32() as any;
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.round = reader.uint32();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.maxRounds = reader.uint32();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.isTiebreaker = reader.bool();
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.isFinalGroup = reader.bool();
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.isCompleted = reader.bool();
          continue;
        case 18:
          if (tag !== 144) {
            break;
          }

          message.phase = reader.int32() as any;
          continue;
        case 19:
          if (tag !== 152) {
            break;
          }

          message.region = reader.int32() as any;
          continue;
        case 20:
          if (tag !== 160) {
            break;
          }

          message.startTime = reader.uint32();
          continue;
        case 21:
          if (tag !== 168) {
            break;
          }

          message.endTime = reader.uint32();
          continue;
        case 22:
          if (tag !== 176) {
            break;
          }

          message.secondaryAdvancingNodeGroupId = reader.uint32();
          continue;
        case 23:
          if (tag !== 184) {
            break;
          }

          message.secondaryAdvancingTeamCount = reader.uint32();
          continue;
        case 24:
          if (tag !== 192) {
            break;
          }

          message.tertiaryAdvancingNodeGroupId = reader.uint32();
          continue;
        case 25:
          if (tag !== 200) {
            break;
          }

          message.tertiaryAdvancingTeamCount = reader.uint32();
          continue;
        case 26:
          if (tag !== 208) {
            break;
          }

          message.eliminationDpcPoints = reader.uint32();
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.teamStandings.push(CMsgDOTALeagueNodeGroup_TeamStanding.decode(reader, reader.uint32()));
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.nodes.push(CMsgDOTALeagueNode.decode(reader, reader.uint32()));
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.nodeGroups.push(CMsgDOTALeagueNodeGroup.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTALeagueNodeGroup {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      nodeGroupId: isSet(object.nodeGroupId) ? globalThis.Number(object.nodeGroupId) : 0,
      parentNodeGroupId: isSet(object.parentNodeGroupId) ? globalThis.Number(object.parentNodeGroupId) : 0,
      incomingNodeGroupIds: globalThis.Array.isArray(object?.incomingNodeGroupIds)
        ? object.incomingNodeGroupIds.map((e: any) => globalThis.Number(e))
        : [],
      advancingNodeGroupId: isSet(object.advancingNodeGroupId) ? globalThis.Number(object.advancingNodeGroupId) : 0,
      advancingTeamCount: isSet(object.advancingTeamCount) ? globalThis.Number(object.advancingTeamCount) : 0,
      teamCount: isSet(object.teamCount) ? globalThis.Number(object.teamCount) : 0,
      nodeGroupType: isSet(object.nodeGroupType) ? eLeagueNodeGroupTypeFromJSON(object.nodeGroupType) : 0,
      defaultNodeType: isSet(object.defaultNodeType) ? eLeagueNodeTypeFromJSON(object.defaultNodeType) : 0,
      round: isSet(object.round) ? globalThis.Number(object.round) : 0,
      maxRounds: isSet(object.maxRounds) ? globalThis.Number(object.maxRounds) : 0,
      isTiebreaker: isSet(object.isTiebreaker) ? globalThis.Boolean(object.isTiebreaker) : false,
      isFinalGroup: isSet(object.isFinalGroup) ? globalThis.Boolean(object.isFinalGroup) : false,
      isCompleted: isSet(object.isCompleted) ? globalThis.Boolean(object.isCompleted) : false,
      phase: isSet(object.phase) ? eLeaguePhaseFromJSON(object.phase) : 0,
      region: isSet(object.region) ? eLeagueRegionFromJSON(object.region) : 0,
      startTime: isSet(object.startTime) ? globalThis.Number(object.startTime) : 0,
      endTime: isSet(object.endTime) ? globalThis.Number(object.endTime) : 0,
      secondaryAdvancingNodeGroupId: isSet(object.secondaryAdvancingNodeGroupId)
        ? globalThis.Number(object.secondaryAdvancingNodeGroupId)
        : 0,
      secondaryAdvancingTeamCount: isSet(object.secondaryAdvancingTeamCount)
        ? globalThis.Number(object.secondaryAdvancingTeamCount)
        : 0,
      tertiaryAdvancingNodeGroupId: isSet(object.tertiaryAdvancingNodeGroupId)
        ? globalThis.Number(object.tertiaryAdvancingNodeGroupId)
        : 0,
      tertiaryAdvancingTeamCount: isSet(object.tertiaryAdvancingTeamCount)
        ? globalThis.Number(object.tertiaryAdvancingTeamCount)
        : 0,
      eliminationDpcPoints: isSet(object.eliminationDpcPoints) ? globalThis.Number(object.eliminationDpcPoints) : 0,
      teamStandings: globalThis.Array.isArray(object?.teamStandings)
        ? object.teamStandings.map((e: any) => CMsgDOTALeagueNodeGroup_TeamStanding.fromJSON(e))
        : [],
      nodes: globalThis.Array.isArray(object?.nodes)
        ? object.nodes.map((e: any) => CMsgDOTALeagueNode.fromJSON(e))
        : [],
      nodeGroups: globalThis.Array.isArray(object?.nodeGroups)
        ? object.nodeGroups.map((e: any) => CMsgDOTALeagueNodeGroup.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgDOTALeagueNodeGroup): unknown {
    const obj: any = {};
    if (message.name !== undefined && message.name !== "") {
      obj.name = message.name;
    }
    if (message.nodeGroupId !== undefined && message.nodeGroupId !== 0) {
      obj.nodeGroupId = Math.round(message.nodeGroupId);
    }
    if (message.parentNodeGroupId !== undefined && message.parentNodeGroupId !== 0) {
      obj.parentNodeGroupId = Math.round(message.parentNodeGroupId);
    }
    if (message.incomingNodeGroupIds?.length) {
      obj.incomingNodeGroupIds = message.incomingNodeGroupIds.map((e) => Math.round(e));
    }
    if (message.advancingNodeGroupId !== undefined && message.advancingNodeGroupId !== 0) {
      obj.advancingNodeGroupId = Math.round(message.advancingNodeGroupId);
    }
    if (message.advancingTeamCount !== undefined && message.advancingTeamCount !== 0) {
      obj.advancingTeamCount = Math.round(message.advancingTeamCount);
    }
    if (message.teamCount !== undefined && message.teamCount !== 0) {
      obj.teamCount = Math.round(message.teamCount);
    }
    if (message.nodeGroupType !== undefined && message.nodeGroupType !== 0) {
      obj.nodeGroupType = eLeagueNodeGroupTypeToJSON(message.nodeGroupType);
    }
    if (message.defaultNodeType !== undefined && message.defaultNodeType !== 0) {
      obj.defaultNodeType = eLeagueNodeTypeToJSON(message.defaultNodeType);
    }
    if (message.round !== undefined && message.round !== 0) {
      obj.round = Math.round(message.round);
    }
    if (message.maxRounds !== undefined && message.maxRounds !== 0) {
      obj.maxRounds = Math.round(message.maxRounds);
    }
    if (message.isTiebreaker !== undefined && message.isTiebreaker !== false) {
      obj.isTiebreaker = message.isTiebreaker;
    }
    if (message.isFinalGroup !== undefined && message.isFinalGroup !== false) {
      obj.isFinalGroup = message.isFinalGroup;
    }
    if (message.isCompleted !== undefined && message.isCompleted !== false) {
      obj.isCompleted = message.isCompleted;
    }
    if (message.phase !== undefined && message.phase !== 0) {
      obj.phase = eLeaguePhaseToJSON(message.phase);
    }
    if (message.region !== undefined && message.region !== 0) {
      obj.region = eLeagueRegionToJSON(message.region);
    }
    if (message.startTime !== undefined && message.startTime !== 0) {
      obj.startTime = Math.round(message.startTime);
    }
    if (message.endTime !== undefined && message.endTime !== 0) {
      obj.endTime = Math.round(message.endTime);
    }
    if (message.secondaryAdvancingNodeGroupId !== undefined && message.secondaryAdvancingNodeGroupId !== 0) {
      obj.secondaryAdvancingNodeGroupId = Math.round(message.secondaryAdvancingNodeGroupId);
    }
    if (message.secondaryAdvancingTeamCount !== undefined && message.secondaryAdvancingTeamCount !== 0) {
      obj.secondaryAdvancingTeamCount = Math.round(message.secondaryAdvancingTeamCount);
    }
    if (message.tertiaryAdvancingNodeGroupId !== undefined && message.tertiaryAdvancingNodeGroupId !== 0) {
      obj.tertiaryAdvancingNodeGroupId = Math.round(message.tertiaryAdvancingNodeGroupId);
    }
    if (message.tertiaryAdvancingTeamCount !== undefined && message.tertiaryAdvancingTeamCount !== 0) {
      obj.tertiaryAdvancingTeamCount = Math.round(message.tertiaryAdvancingTeamCount);
    }
    if (message.eliminationDpcPoints !== undefined && message.eliminationDpcPoints !== 0) {
      obj.eliminationDpcPoints = Math.round(message.eliminationDpcPoints);
    }
    if (message.teamStandings?.length) {
      obj.teamStandings = message.teamStandings.map((e) => CMsgDOTALeagueNodeGroup_TeamStanding.toJSON(e));
    }
    if (message.nodes?.length) {
      obj.nodes = message.nodes.map((e) => CMsgDOTALeagueNode.toJSON(e));
    }
    if (message.nodeGroups?.length) {
      obj.nodeGroups = message.nodeGroups.map((e) => CMsgDOTALeagueNodeGroup.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTALeagueNodeGroup>): CMsgDOTALeagueNodeGroup {
    return CMsgDOTALeagueNodeGroup.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTALeagueNodeGroup>): CMsgDOTALeagueNodeGroup {
    const message = createBaseCMsgDOTALeagueNodeGroup();
    message.name = object.name ?? "";
    message.nodeGroupId = object.nodeGroupId ?? 0;
    message.parentNodeGroupId = object.parentNodeGroupId ?? 0;
    message.incomingNodeGroupIds = object.incomingNodeGroupIds?.map((e) => e) || [];
    message.advancingNodeGroupId = object.advancingNodeGroupId ?? 0;
    message.advancingTeamCount = object.advancingTeamCount ?? 0;
    message.teamCount = object.teamCount ?? 0;
    message.nodeGroupType = object.nodeGroupType ?? 0;
    message.defaultNodeType = object.defaultNodeType ?? 0;
    message.round = object.round ?? 0;
    message.maxRounds = object.maxRounds ?? 0;
    message.isTiebreaker = object.isTiebreaker ?? false;
    message.isFinalGroup = object.isFinalGroup ?? false;
    message.isCompleted = object.isCompleted ?? false;
    message.phase = object.phase ?? 0;
    message.region = object.region ?? 0;
    message.startTime = object.startTime ?? 0;
    message.endTime = object.endTime ?? 0;
    message.secondaryAdvancingNodeGroupId = object.secondaryAdvancingNodeGroupId ?? 0;
    message.secondaryAdvancingTeamCount = object.secondaryAdvancingTeamCount ?? 0;
    message.tertiaryAdvancingNodeGroupId = object.tertiaryAdvancingNodeGroupId ?? 0;
    message.tertiaryAdvancingTeamCount = object.tertiaryAdvancingTeamCount ?? 0;
    message.eliminationDpcPoints = object.eliminationDpcPoints ?? 0;
    message.teamStandings = object.teamStandings?.map((e) => CMsgDOTALeagueNodeGroup_TeamStanding.fromPartial(e)) || [];
    message.nodes = object.nodes?.map((e) => CMsgDOTALeagueNode.fromPartial(e)) || [];
    message.nodeGroups = object.nodeGroups?.map((e) => CMsgDOTALeagueNodeGroup.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgDOTALeagueNodeGroup_TeamStanding(): CMsgDOTALeagueNodeGroup_TeamStanding {
  return {
    standing: 0,
    teamId: 0,
    teamName: "",
    teamTag: "",
    teamLogo: "0",
    teamLogoUrl: "",
    wins: 0,
    losses: 0,
    score: "0",
    teamAbbreviation: "",
    scoreTiebreakGroup: "0",
    scoreTiebreakBelow: "0",
    scoreTiebreakRandom: "0",
    isPro: false,
  };
}

export const CMsgDOTALeagueNodeGroup_TeamStanding = {
  encode(message: CMsgDOTALeagueNodeGroup_TeamStanding, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.standing !== undefined && message.standing !== 0) {
      writer.uint32(8).uint32(message.standing);
    }
    if (message.teamId !== undefined && message.teamId !== 0) {
      writer.uint32(16).uint32(message.teamId);
    }
    if (message.teamName !== undefined && message.teamName !== "") {
      writer.uint32(26).string(message.teamName);
    }
    if (message.teamTag !== undefined && message.teamTag !== "") {
      writer.uint32(34).string(message.teamTag);
    }
    if (message.teamLogo !== undefined && message.teamLogo !== "0") {
      writer.uint32(40).uint64(message.teamLogo);
    }
    if (message.teamLogoUrl !== undefined && message.teamLogoUrl !== "") {
      writer.uint32(50).string(message.teamLogoUrl);
    }
    if (message.wins !== undefined && message.wins !== 0) {
      writer.uint32(56).uint32(message.wins);
    }
    if (message.losses !== undefined && message.losses !== 0) {
      writer.uint32(64).uint32(message.losses);
    }
    if (message.score !== undefined && message.score !== "0") {
      writer.uint32(72).int64(message.score);
    }
    if (message.teamAbbreviation !== undefined && message.teamAbbreviation !== "") {
      writer.uint32(82).string(message.teamAbbreviation);
    }
    if (message.scoreTiebreakGroup !== undefined && message.scoreTiebreakGroup !== "0") {
      writer.uint32(88).int64(message.scoreTiebreakGroup);
    }
    if (message.scoreTiebreakBelow !== undefined && message.scoreTiebreakBelow !== "0") {
      writer.uint32(96).int64(message.scoreTiebreakBelow);
    }
    if (message.scoreTiebreakRandom !== undefined && message.scoreTiebreakRandom !== "0") {
      writer.uint32(104).int64(message.scoreTiebreakRandom);
    }
    if (message.isPro !== undefined && message.isPro !== false) {
      writer.uint32(112).bool(message.isPro);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTALeagueNodeGroup_TeamStanding {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTALeagueNodeGroup_TeamStanding();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.standing = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.teamId = reader.uint32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.teamName = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.teamTag = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.teamLogo = longToString(reader.uint64() as Long);
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.teamLogoUrl = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.wins = reader.uint32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.losses = reader.uint32();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.score = longToString(reader.int64() as Long);
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.teamAbbreviation = reader.string();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.scoreTiebreakGroup = longToString(reader.int64() as Long);
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.scoreTiebreakBelow = longToString(reader.int64() as Long);
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.scoreTiebreakRandom = longToString(reader.int64() as Long);
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.isPro = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTALeagueNodeGroup_TeamStanding {
    return {
      standing: isSet(object.standing) ? globalThis.Number(object.standing) : 0,
      teamId: isSet(object.teamId) ? globalThis.Number(object.teamId) : 0,
      teamName: isSet(object.teamName) ? globalThis.String(object.teamName) : "",
      teamTag: isSet(object.teamTag) ? globalThis.String(object.teamTag) : "",
      teamLogo: isSet(object.teamLogo) ? globalThis.String(object.teamLogo) : "0",
      teamLogoUrl: isSet(object.teamLogoUrl) ? globalThis.String(object.teamLogoUrl) : "",
      wins: isSet(object.wins) ? globalThis.Number(object.wins) : 0,
      losses: isSet(object.losses) ? globalThis.Number(object.losses) : 0,
      score: isSet(object.score) ? globalThis.String(object.score) : "0",
      teamAbbreviation: isSet(object.teamAbbreviation) ? globalThis.String(object.teamAbbreviation) : "",
      scoreTiebreakGroup: isSet(object.scoreTiebreakGroup) ? globalThis.String(object.scoreTiebreakGroup) : "0",
      scoreTiebreakBelow: isSet(object.scoreTiebreakBelow) ? globalThis.String(object.scoreTiebreakBelow) : "0",
      scoreTiebreakRandom: isSet(object.scoreTiebreakRandom) ? globalThis.String(object.scoreTiebreakRandom) : "0",
      isPro: isSet(object.isPro) ? globalThis.Boolean(object.isPro) : false,
    };
  },

  toJSON(message: CMsgDOTALeagueNodeGroup_TeamStanding): unknown {
    const obj: any = {};
    if (message.standing !== undefined && message.standing !== 0) {
      obj.standing = Math.round(message.standing);
    }
    if (message.teamId !== undefined && message.teamId !== 0) {
      obj.teamId = Math.round(message.teamId);
    }
    if (message.teamName !== undefined && message.teamName !== "") {
      obj.teamName = message.teamName;
    }
    if (message.teamTag !== undefined && message.teamTag !== "") {
      obj.teamTag = message.teamTag;
    }
    if (message.teamLogo !== undefined && message.teamLogo !== "0") {
      obj.teamLogo = message.teamLogo;
    }
    if (message.teamLogoUrl !== undefined && message.teamLogoUrl !== "") {
      obj.teamLogoUrl = message.teamLogoUrl;
    }
    if (message.wins !== undefined && message.wins !== 0) {
      obj.wins = Math.round(message.wins);
    }
    if (message.losses !== undefined && message.losses !== 0) {
      obj.losses = Math.round(message.losses);
    }
    if (message.score !== undefined && message.score !== "0") {
      obj.score = message.score;
    }
    if (message.teamAbbreviation !== undefined && message.teamAbbreviation !== "") {
      obj.teamAbbreviation = message.teamAbbreviation;
    }
    if (message.scoreTiebreakGroup !== undefined && message.scoreTiebreakGroup !== "0") {
      obj.scoreTiebreakGroup = message.scoreTiebreakGroup;
    }
    if (message.scoreTiebreakBelow !== undefined && message.scoreTiebreakBelow !== "0") {
      obj.scoreTiebreakBelow = message.scoreTiebreakBelow;
    }
    if (message.scoreTiebreakRandom !== undefined && message.scoreTiebreakRandom !== "0") {
      obj.scoreTiebreakRandom = message.scoreTiebreakRandom;
    }
    if (message.isPro !== undefined && message.isPro !== false) {
      obj.isPro = message.isPro;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTALeagueNodeGroup_TeamStanding>): CMsgDOTALeagueNodeGroup_TeamStanding {
    return CMsgDOTALeagueNodeGroup_TeamStanding.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTALeagueNodeGroup_TeamStanding>): CMsgDOTALeagueNodeGroup_TeamStanding {
    const message = createBaseCMsgDOTALeagueNodeGroup_TeamStanding();
    message.standing = object.standing ?? 0;
    message.teamId = object.teamId ?? 0;
    message.teamName = object.teamName ?? "";
    message.teamTag = object.teamTag ?? "";
    message.teamLogo = object.teamLogo ?? "0";
    message.teamLogoUrl = object.teamLogoUrl ?? "";
    message.wins = object.wins ?? 0;
    message.losses = object.losses ?? 0;
    message.score = object.score ?? "0";
    message.teamAbbreviation = object.teamAbbreviation ?? "";
    message.scoreTiebreakGroup = object.scoreTiebreakGroup ?? "0";
    message.scoreTiebreakBelow = object.scoreTiebreakBelow ?? "0";
    message.scoreTiebreakRandom = object.scoreTiebreakRandom ?? "0";
    message.isPro = object.isPro ?? false;
    return message;
  },
};

function createBaseCMsgDOTALeague(): CMsgDOTALeague {
  return {
    info: undefined,
    prizePool: undefined,
    admins: [],
    streams: [],
    nodeGroups: [],
    seriesInfos: [],
    registeredPlayers: [],
  };
}

export const CMsgDOTALeague = {
  encode(message: CMsgDOTALeague, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.info !== undefined) {
      CMsgDOTALeague_Info.encode(message.info, writer.uint32(10).fork()).ldelim();
    }
    if (message.prizePool !== undefined) {
      CMsgDOTALeague_PrizePool.encode(message.prizePool, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.admins) {
      CMsgDOTALeague_Admin.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    for (const v of message.streams) {
      CMsgDOTALeague_Stream.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    for (const v of message.nodeGroups) {
      CMsgDOTALeagueNodeGroup.encode(v!, writer.uint32(42).fork()).ldelim();
    }
    for (const v of message.seriesInfos) {
      CMsgDOTALeague_SeriesInfo.encode(v!, writer.uint32(50).fork()).ldelim();
    }
    for (const v of message.registeredPlayers) {
      CMsgDOTALeague_Player.encode(v!, writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTALeague {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTALeague();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.info = CMsgDOTALeague_Info.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.prizePool = CMsgDOTALeague_PrizePool.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.admins.push(CMsgDOTALeague_Admin.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.streams.push(CMsgDOTALeague_Stream.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.nodeGroups.push(CMsgDOTALeagueNodeGroup.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.seriesInfos.push(CMsgDOTALeague_SeriesInfo.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.registeredPlayers.push(CMsgDOTALeague_Player.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTALeague {
    return {
      info: isSet(object.info) ? CMsgDOTALeague_Info.fromJSON(object.info) : undefined,
      prizePool: isSet(object.prizePool) ? CMsgDOTALeague_PrizePool.fromJSON(object.prizePool) : undefined,
      admins: globalThis.Array.isArray(object?.admins)
        ? object.admins.map((e: any) => CMsgDOTALeague_Admin.fromJSON(e))
        : [],
      streams: globalThis.Array.isArray(object?.streams)
        ? object.streams.map((e: any) => CMsgDOTALeague_Stream.fromJSON(e))
        : [],
      nodeGroups: globalThis.Array.isArray(object?.nodeGroups)
        ? object.nodeGroups.map((e: any) => CMsgDOTALeagueNodeGroup.fromJSON(e))
        : [],
      seriesInfos: globalThis.Array.isArray(object?.seriesInfos)
        ? object.seriesInfos.map((e: any) => CMsgDOTALeague_SeriesInfo.fromJSON(e))
        : [],
      registeredPlayers: globalThis.Array.isArray(object?.registeredPlayers)
        ? object.registeredPlayers.map((e: any) => CMsgDOTALeague_Player.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgDOTALeague): unknown {
    const obj: any = {};
    if (message.info !== undefined) {
      obj.info = CMsgDOTALeague_Info.toJSON(message.info);
    }
    if (message.prizePool !== undefined) {
      obj.prizePool = CMsgDOTALeague_PrizePool.toJSON(message.prizePool);
    }
    if (message.admins?.length) {
      obj.admins = message.admins.map((e) => CMsgDOTALeague_Admin.toJSON(e));
    }
    if (message.streams?.length) {
      obj.streams = message.streams.map((e) => CMsgDOTALeague_Stream.toJSON(e));
    }
    if (message.nodeGroups?.length) {
      obj.nodeGroups = message.nodeGroups.map((e) => CMsgDOTALeagueNodeGroup.toJSON(e));
    }
    if (message.seriesInfos?.length) {
      obj.seriesInfos = message.seriesInfos.map((e) => CMsgDOTALeague_SeriesInfo.toJSON(e));
    }
    if (message.registeredPlayers?.length) {
      obj.registeredPlayers = message.registeredPlayers.map((e) => CMsgDOTALeague_Player.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTALeague>): CMsgDOTALeague {
    return CMsgDOTALeague.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTALeague>): CMsgDOTALeague {
    const message = createBaseCMsgDOTALeague();
    message.info = (object.info !== undefined && object.info !== null)
      ? CMsgDOTALeague_Info.fromPartial(object.info)
      : undefined;
    message.prizePool = (object.prizePool !== undefined && object.prizePool !== null)
      ? CMsgDOTALeague_PrizePool.fromPartial(object.prizePool)
      : undefined;
    message.admins = object.admins?.map((e) => CMsgDOTALeague_Admin.fromPartial(e)) || [];
    message.streams = object.streams?.map((e) => CMsgDOTALeague_Stream.fromPartial(e)) || [];
    message.nodeGroups = object.nodeGroups?.map((e) => CMsgDOTALeagueNodeGroup.fromPartial(e)) || [];
    message.seriesInfos = object.seriesInfos?.map((e) => CMsgDOTALeague_SeriesInfo.fromPartial(e)) || [];
    message.registeredPlayers = object.registeredPlayers?.map((e) => CMsgDOTALeague_Player.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgDOTALeague_Info(): CMsgDOTALeague_Info {
  return {
    leagueId: 0,
    name: "",
    tier: 0,
    region: 0,
    url: "",
    description: "",
    notes: "",
    startTimestamp: 0,
    endTimestamp: 0,
    proCircuitPoints: 0,
    imageBits: 0,
    status: 0,
    mostRecentActivity: 0,
    registrationPeriod: 0,
  };
}

export const CMsgDOTALeague_Info = {
  encode(message: CMsgDOTALeague_Info, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.leagueId !== undefined && message.leagueId !== 0) {
      writer.uint32(8).uint32(message.leagueId);
    }
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.tier !== undefined && message.tier !== 0) {
      writer.uint32(24).int32(message.tier);
    }
    if (message.region !== undefined && message.region !== 0) {
      writer.uint32(32).int32(message.region);
    }
    if (message.url !== undefined && message.url !== "") {
      writer.uint32(42).string(message.url);
    }
    if (message.description !== undefined && message.description !== "") {
      writer.uint32(50).string(message.description);
    }
    if (message.notes !== undefined && message.notes !== "") {
      writer.uint32(58).string(message.notes);
    }
    if (message.startTimestamp !== undefined && message.startTimestamp !== 0) {
      writer.uint32(64).uint32(message.startTimestamp);
    }
    if (message.endTimestamp !== undefined && message.endTimestamp !== 0) {
      writer.uint32(72).uint32(message.endTimestamp);
    }
    if (message.proCircuitPoints !== undefined && message.proCircuitPoints !== 0) {
      writer.uint32(80).uint32(message.proCircuitPoints);
    }
    if (message.imageBits !== undefined && message.imageBits !== 0) {
      writer.uint32(88).uint32(message.imageBits);
    }
    if (message.status !== undefined && message.status !== 0) {
      writer.uint32(96).int32(message.status);
    }
    if (message.mostRecentActivity !== undefined && message.mostRecentActivity !== 0) {
      writer.uint32(104).uint32(message.mostRecentActivity);
    }
    if (message.registrationPeriod !== undefined && message.registrationPeriod !== 0) {
      writer.uint32(112).uint32(message.registrationPeriod);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTALeague_Info {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTALeague_Info();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.leagueId = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.tier = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.region = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.url = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.description = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.notes = reader.string();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.startTimestamp = reader.uint32();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.endTimestamp = reader.uint32();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.proCircuitPoints = reader.uint32();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.imageBits = reader.uint32();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.mostRecentActivity = reader.uint32();
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.registrationPeriod = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTALeague_Info {
    return {
      leagueId: isSet(object.leagueId) ? globalThis.Number(object.leagueId) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      tier: isSet(object.tier) ? eLeagueTierFromJSON(object.tier) : 0,
      region: isSet(object.region) ? eLeagueRegionFromJSON(object.region) : 0,
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      notes: isSet(object.notes) ? globalThis.String(object.notes) : "",
      startTimestamp: isSet(object.startTimestamp) ? globalThis.Number(object.startTimestamp) : 0,
      endTimestamp: isSet(object.endTimestamp) ? globalThis.Number(object.endTimestamp) : 0,
      proCircuitPoints: isSet(object.proCircuitPoints) ? globalThis.Number(object.proCircuitPoints) : 0,
      imageBits: isSet(object.imageBits) ? globalThis.Number(object.imageBits) : 0,
      status: isSet(object.status) ? eLeagueStatusFromJSON(object.status) : 0,
      mostRecentActivity: isSet(object.mostRecentActivity) ? globalThis.Number(object.mostRecentActivity) : 0,
      registrationPeriod: isSet(object.registrationPeriod) ? globalThis.Number(object.registrationPeriod) : 0,
    };
  },

  toJSON(message: CMsgDOTALeague_Info): unknown {
    const obj: any = {};
    if (message.leagueId !== undefined && message.leagueId !== 0) {
      obj.leagueId = Math.round(message.leagueId);
    }
    if (message.name !== undefined && message.name !== "") {
      obj.name = message.name;
    }
    if (message.tier !== undefined && message.tier !== 0) {
      obj.tier = eLeagueTierToJSON(message.tier);
    }
    if (message.region !== undefined && message.region !== 0) {
      obj.region = eLeagueRegionToJSON(message.region);
    }
    if (message.url !== undefined && message.url !== "") {
      obj.url = message.url;
    }
    if (message.description !== undefined && message.description !== "") {
      obj.description = message.description;
    }
    if (message.notes !== undefined && message.notes !== "") {
      obj.notes = message.notes;
    }
    if (message.startTimestamp !== undefined && message.startTimestamp !== 0) {
      obj.startTimestamp = Math.round(message.startTimestamp);
    }
    if (message.endTimestamp !== undefined && message.endTimestamp !== 0) {
      obj.endTimestamp = Math.round(message.endTimestamp);
    }
    if (message.proCircuitPoints !== undefined && message.proCircuitPoints !== 0) {
      obj.proCircuitPoints = Math.round(message.proCircuitPoints);
    }
    if (message.imageBits !== undefined && message.imageBits !== 0) {
      obj.imageBits = Math.round(message.imageBits);
    }
    if (message.status !== undefined && message.status !== 0) {
      obj.status = eLeagueStatusToJSON(message.status);
    }
    if (message.mostRecentActivity !== undefined && message.mostRecentActivity !== 0) {
      obj.mostRecentActivity = Math.round(message.mostRecentActivity);
    }
    if (message.registrationPeriod !== undefined && message.registrationPeriod !== 0) {
      obj.registrationPeriod = Math.round(message.registrationPeriod);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTALeague_Info>): CMsgDOTALeague_Info {
    return CMsgDOTALeague_Info.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTALeague_Info>): CMsgDOTALeague_Info {
    const message = createBaseCMsgDOTALeague_Info();
    message.leagueId = object.leagueId ?? 0;
    message.name = object.name ?? "";
    message.tier = object.tier ?? 0;
    message.region = object.region ?? 0;
    message.url = object.url ?? "";
    message.description = object.description ?? "";
    message.notes = object.notes ?? "";
    message.startTimestamp = object.startTimestamp ?? 0;
    message.endTimestamp = object.endTimestamp ?? 0;
    message.proCircuitPoints = object.proCircuitPoints ?? 0;
    message.imageBits = object.imageBits ?? 0;
    message.status = object.status ?? 0;
    message.mostRecentActivity = object.mostRecentActivity ?? 0;
    message.registrationPeriod = object.registrationPeriod ?? 0;
    return message;
  },
};

function createBaseCMsgDOTALeague_Admin(): CMsgDOTALeague_Admin {
  return { accountId: 0, isPrimary: false, emailAddress: "" };
}

export const CMsgDOTALeague_Admin = {
  encode(message: CMsgDOTALeague_Admin, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.accountId !== undefined && message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    if (message.isPrimary !== undefined && message.isPrimary !== false) {
      writer.uint32(16).bool(message.isPrimary);
    }
    if (message.emailAddress !== undefined && message.emailAddress !== "") {
      writer.uint32(26).string(message.emailAddress);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTALeague_Admin {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTALeague_Admin();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.isPrimary = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.emailAddress = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTALeague_Admin {
    return {
      accountId: isSet(object.accountId) ? globalThis.Number(object.accountId) : 0,
      isPrimary: isSet(object.isPrimary) ? globalThis.Boolean(object.isPrimary) : false,
      emailAddress: isSet(object.emailAddress) ? globalThis.String(object.emailAddress) : "",
    };
  },

  toJSON(message: CMsgDOTALeague_Admin): unknown {
    const obj: any = {};
    if (message.accountId !== undefined && message.accountId !== 0) {
      obj.accountId = Math.round(message.accountId);
    }
    if (message.isPrimary !== undefined && message.isPrimary !== false) {
      obj.isPrimary = message.isPrimary;
    }
    if (message.emailAddress !== undefined && message.emailAddress !== "") {
      obj.emailAddress = message.emailAddress;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTALeague_Admin>): CMsgDOTALeague_Admin {
    return CMsgDOTALeague_Admin.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTALeague_Admin>): CMsgDOTALeague_Admin {
    const message = createBaseCMsgDOTALeague_Admin();
    message.accountId = object.accountId ?? 0;
    message.isPrimary = object.isPrimary ?? false;
    message.emailAddress = object.emailAddress ?? "";
    return message;
  },
};

function createBaseCMsgDOTALeague_PrizePoolItem(): CMsgDOTALeague_PrizePoolItem {
  return { itemDef: 0, salesStopTimestamp: 0, revenuePct: 0, revenueCentsPerSale: 0 };
}

export const CMsgDOTALeague_PrizePoolItem = {
  encode(message: CMsgDOTALeague_PrizePoolItem, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.itemDef !== undefined && message.itemDef !== 0) {
      writer.uint32(8).uint32(message.itemDef);
    }
    if (message.salesStopTimestamp !== undefined && message.salesStopTimestamp !== 0) {
      writer.uint32(16).uint32(message.salesStopTimestamp);
    }
    if (message.revenuePct !== undefined && message.revenuePct !== 0) {
      writer.uint32(24).uint32(message.revenuePct);
    }
    if (message.revenueCentsPerSale !== undefined && message.revenueCentsPerSale !== 0) {
      writer.uint32(32).uint32(message.revenueCentsPerSale);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTALeague_PrizePoolItem {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTALeague_PrizePoolItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.itemDef = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.salesStopTimestamp = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.revenuePct = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.revenueCentsPerSale = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTALeague_PrizePoolItem {
    return {
      itemDef: isSet(object.itemDef) ? globalThis.Number(object.itemDef) : 0,
      salesStopTimestamp: isSet(object.salesStopTimestamp) ? globalThis.Number(object.salesStopTimestamp) : 0,
      revenuePct: isSet(object.revenuePct) ? globalThis.Number(object.revenuePct) : 0,
      revenueCentsPerSale: isSet(object.revenueCentsPerSale) ? globalThis.Number(object.revenueCentsPerSale) : 0,
    };
  },

  toJSON(message: CMsgDOTALeague_PrizePoolItem): unknown {
    const obj: any = {};
    if (message.itemDef !== undefined && message.itemDef !== 0) {
      obj.itemDef = Math.round(message.itemDef);
    }
    if (message.salesStopTimestamp !== undefined && message.salesStopTimestamp !== 0) {
      obj.salesStopTimestamp = Math.round(message.salesStopTimestamp);
    }
    if (message.revenuePct !== undefined && message.revenuePct !== 0) {
      obj.revenuePct = Math.round(message.revenuePct);
    }
    if (message.revenueCentsPerSale !== undefined && message.revenueCentsPerSale !== 0) {
      obj.revenueCentsPerSale = Math.round(message.revenueCentsPerSale);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTALeague_PrizePoolItem>): CMsgDOTALeague_PrizePoolItem {
    return CMsgDOTALeague_PrizePoolItem.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTALeague_PrizePoolItem>): CMsgDOTALeague_PrizePoolItem {
    const message = createBaseCMsgDOTALeague_PrizePoolItem();
    message.itemDef = object.itemDef ?? 0;
    message.salesStopTimestamp = object.salesStopTimestamp ?? 0;
    message.revenuePct = object.revenuePct ?? 0;
    message.revenueCentsPerSale = object.revenueCentsPerSale ?? 0;
    return message;
  },
};

function createBaseCMsgDOTALeague_PrizePool(): CMsgDOTALeague_PrizePool {
  return { basePrizePool: 0, totalPrizePool: 0, prizeSplitPctX100: [], prizePoolItems: [] };
}

export const CMsgDOTALeague_PrizePool = {
  encode(message: CMsgDOTALeague_PrizePool, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.basePrizePool !== undefined && message.basePrizePool !== 0) {
      writer.uint32(8).uint32(message.basePrizePool);
    }
    if (message.totalPrizePool !== undefined && message.totalPrizePool !== 0) {
      writer.uint32(16).uint32(message.totalPrizePool);
    }
    writer.uint32(26).fork();
    for (const v of message.prizeSplitPctX100) {
      writer.uint32(v);
    }
    writer.ldelim();
    for (const v of message.prizePoolItems) {
      CMsgDOTALeague_PrizePoolItem.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTALeague_PrizePool {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTALeague_PrizePool();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.basePrizePool = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.totalPrizePool = reader.uint32();
          continue;
        case 3:
          if (tag === 24) {
            message.prizeSplitPctX100.push(reader.uint32());

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.prizeSplitPctX100.push(reader.uint32());
            }

            continue;
          }

          break;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.prizePoolItems.push(CMsgDOTALeague_PrizePoolItem.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTALeague_PrizePool {
    return {
      basePrizePool: isSet(object.basePrizePool) ? globalThis.Number(object.basePrizePool) : 0,
      totalPrizePool: isSet(object.totalPrizePool) ? globalThis.Number(object.totalPrizePool) : 0,
      prizeSplitPctX100: globalThis.Array.isArray(object?.prizeSplitPctX100)
        ? object.prizeSplitPctX100.map((e: any) => globalThis.Number(e))
        : [],
      prizePoolItems: globalThis.Array.isArray(object?.prizePoolItems)
        ? object.prizePoolItems.map((e: any) => CMsgDOTALeague_PrizePoolItem.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgDOTALeague_PrizePool): unknown {
    const obj: any = {};
    if (message.basePrizePool !== undefined && message.basePrizePool !== 0) {
      obj.basePrizePool = Math.round(message.basePrizePool);
    }
    if (message.totalPrizePool !== undefined && message.totalPrizePool !== 0) {
      obj.totalPrizePool = Math.round(message.totalPrizePool);
    }
    if (message.prizeSplitPctX100?.length) {
      obj.prizeSplitPctX100 = message.prizeSplitPctX100.map((e) => Math.round(e));
    }
    if (message.prizePoolItems?.length) {
      obj.prizePoolItems = message.prizePoolItems.map((e) => CMsgDOTALeague_PrizePoolItem.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTALeague_PrizePool>): CMsgDOTALeague_PrizePool {
    return CMsgDOTALeague_PrizePool.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTALeague_PrizePool>): CMsgDOTALeague_PrizePool {
    const message = createBaseCMsgDOTALeague_PrizePool();
    message.basePrizePool = object.basePrizePool ?? 0;
    message.totalPrizePool = object.totalPrizePool ?? 0;
    message.prizeSplitPctX100 = object.prizeSplitPctX100?.map((e) => e) || [];
    message.prizePoolItems = object.prizePoolItems?.map((e) => CMsgDOTALeague_PrizePoolItem.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgDOTALeague_Stream(): CMsgDOTALeague_Stream {
  return { streamId: 0, language: 0, name: "", broadcastProvider: 0, streamUrl: "", vodUrl: "" };
}

export const CMsgDOTALeague_Stream = {
  encode(message: CMsgDOTALeague_Stream, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.streamId !== undefined && message.streamId !== 0) {
      writer.uint32(8).uint32(message.streamId);
    }
    if (message.language !== undefined && message.language !== 0) {
      writer.uint32(16).uint32(message.language);
    }
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.broadcastProvider !== undefined && message.broadcastProvider !== 0) {
      writer.uint32(32).int32(message.broadcastProvider);
    }
    if (message.streamUrl !== undefined && message.streamUrl !== "") {
      writer.uint32(42).string(message.streamUrl);
    }
    if (message.vodUrl !== undefined && message.vodUrl !== "") {
      writer.uint32(50).string(message.vodUrl);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTALeague_Stream {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTALeague_Stream();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.streamId = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.language = reader.uint32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.broadcastProvider = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.streamUrl = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.vodUrl = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTALeague_Stream {
    return {
      streamId: isSet(object.streamId) ? globalThis.Number(object.streamId) : 0,
      language: isSet(object.language) ? globalThis.Number(object.language) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      broadcastProvider: isSet(object.broadcastProvider)
        ? eLeagueBroadcastProviderFromJSON(object.broadcastProvider)
        : 0,
      streamUrl: isSet(object.streamUrl) ? globalThis.String(object.streamUrl) : "",
      vodUrl: isSet(object.vodUrl) ? globalThis.String(object.vodUrl) : "",
    };
  },

  toJSON(message: CMsgDOTALeague_Stream): unknown {
    const obj: any = {};
    if (message.streamId !== undefined && message.streamId !== 0) {
      obj.streamId = Math.round(message.streamId);
    }
    if (message.language !== undefined && message.language !== 0) {
      obj.language = Math.round(message.language);
    }
    if (message.name !== undefined && message.name !== "") {
      obj.name = message.name;
    }
    if (message.broadcastProvider !== undefined && message.broadcastProvider !== 0) {
      obj.broadcastProvider = eLeagueBroadcastProviderToJSON(message.broadcastProvider);
    }
    if (message.streamUrl !== undefined && message.streamUrl !== "") {
      obj.streamUrl = message.streamUrl;
    }
    if (message.vodUrl !== undefined && message.vodUrl !== "") {
      obj.vodUrl = message.vodUrl;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTALeague_Stream>): CMsgDOTALeague_Stream {
    return CMsgDOTALeague_Stream.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTALeague_Stream>): CMsgDOTALeague_Stream {
    const message = createBaseCMsgDOTALeague_Stream();
    message.streamId = object.streamId ?? 0;
    message.language = object.language ?? 0;
    message.name = object.name ?? "";
    message.broadcastProvider = object.broadcastProvider ?? 0;
    message.streamUrl = object.streamUrl ?? "";
    message.vodUrl = object.vodUrl ?? "";
    return message;
  },
};

function createBaseCMsgDOTALeague_SeriesInfo(): CMsgDOTALeague_SeriesInfo {
  return { seriesId: 0, seriesType: 0, startTime: 0, matchIds: [], teamId1: 0, teamId2: 0 };
}

export const CMsgDOTALeague_SeriesInfo = {
  encode(message: CMsgDOTALeague_SeriesInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.seriesId !== undefined && message.seriesId !== 0) {
      writer.uint32(8).uint32(message.seriesId);
    }
    if (message.seriesType !== undefined && message.seriesType !== 0) {
      writer.uint32(16).uint32(message.seriesType);
    }
    if (message.startTime !== undefined && message.startTime !== 0) {
      writer.uint32(24).uint32(message.startTime);
    }
    writer.uint32(34).fork();
    for (const v of message.matchIds) {
      writer.uint64(v);
    }
    writer.ldelim();
    if (message.teamId1 !== undefined && message.teamId1 !== 0) {
      writer.uint32(40).uint32(message.teamId1);
    }
    if (message.teamId2 !== undefined && message.teamId2 !== 0) {
      writer.uint32(48).uint32(message.teamId2);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTALeague_SeriesInfo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTALeague_SeriesInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.seriesId = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.seriesType = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.startTime = reader.uint32();
          continue;
        case 4:
          if (tag === 32) {
            message.matchIds.push(longToString(reader.uint64() as Long));

            continue;
          }

          if (tag === 34) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.matchIds.push(longToString(reader.uint64() as Long));
            }

            continue;
          }

          break;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.teamId1 = reader.uint32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.teamId2 = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTALeague_SeriesInfo {
    return {
      seriesId: isSet(object.seriesId) ? globalThis.Number(object.seriesId) : 0,
      seriesType: isSet(object.seriesType) ? globalThis.Number(object.seriesType) : 0,
      startTime: isSet(object.startTime) ? globalThis.Number(object.startTime) : 0,
      matchIds: globalThis.Array.isArray(object?.matchIds) ? object.matchIds.map((e: any) => globalThis.String(e)) : [],
      teamId1: isSet(object.teamId1) ? globalThis.Number(object.teamId1) : 0,
      teamId2: isSet(object.teamId2) ? globalThis.Number(object.teamId2) : 0,
    };
  },

  toJSON(message: CMsgDOTALeague_SeriesInfo): unknown {
    const obj: any = {};
    if (message.seriesId !== undefined && message.seriesId !== 0) {
      obj.seriesId = Math.round(message.seriesId);
    }
    if (message.seriesType !== undefined && message.seriesType !== 0) {
      obj.seriesType = Math.round(message.seriesType);
    }
    if (message.startTime !== undefined && message.startTime !== 0) {
      obj.startTime = Math.round(message.startTime);
    }
    if (message.matchIds?.length) {
      obj.matchIds = message.matchIds;
    }
    if (message.teamId1 !== undefined && message.teamId1 !== 0) {
      obj.teamId1 = Math.round(message.teamId1);
    }
    if (message.teamId2 !== undefined && message.teamId2 !== 0) {
      obj.teamId2 = Math.round(message.teamId2);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTALeague_SeriesInfo>): CMsgDOTALeague_SeriesInfo {
    return CMsgDOTALeague_SeriesInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTALeague_SeriesInfo>): CMsgDOTALeague_SeriesInfo {
    const message = createBaseCMsgDOTALeague_SeriesInfo();
    message.seriesId = object.seriesId ?? 0;
    message.seriesType = object.seriesType ?? 0;
    message.startTime = object.startTime ?? 0;
    message.matchIds = object.matchIds?.map((e) => e) || [];
    message.teamId1 = object.teamId1 ?? 0;
    message.teamId2 = object.teamId2 ?? 0;
    return message;
  },
};

function createBaseCMsgDOTALeague_Player(): CMsgDOTALeague_Player {
  return { accountId: 0, name: "", teamId: 0 };
}

export const CMsgDOTALeague_Player = {
  encode(message: CMsgDOTALeague_Player, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.accountId !== undefined && message.accountId !== 0) {
      writer.uint32(8).uint32(message.accountId);
    }
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.teamId !== undefined && message.teamId !== 0) {
      writer.uint32(24).uint32(message.teamId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTALeague_Player {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTALeague_Player();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.teamId = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTALeague_Player {
    return {
      accountId: isSet(object.accountId) ? globalThis.Number(object.accountId) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      teamId: isSet(object.teamId) ? globalThis.Number(object.teamId) : 0,
    };
  },

  toJSON(message: CMsgDOTALeague_Player): unknown {
    const obj: any = {};
    if (message.accountId !== undefined && message.accountId !== 0) {
      obj.accountId = Math.round(message.accountId);
    }
    if (message.name !== undefined && message.name !== "") {
      obj.name = message.name;
    }
    if (message.teamId !== undefined && message.teamId !== 0) {
      obj.teamId = Math.round(message.teamId);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTALeague_Player>): CMsgDOTALeague_Player {
    return CMsgDOTALeague_Player.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTALeague_Player>): CMsgDOTALeague_Player {
    const message = createBaseCMsgDOTALeague_Player();
    message.accountId = object.accountId ?? 0;
    message.name = object.name ?? "";
    message.teamId = object.teamId ?? 0;
    return message;
  },
};

function createBaseCMsgDOTALeagueList(): CMsgDOTALeagueList {
  return { leagues: [] };
}

export const CMsgDOTALeagueList = {
  encode(message: CMsgDOTALeagueList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.leagues) {
      CMsgDOTALeague.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTALeagueList {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTALeagueList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.leagues.push(CMsgDOTALeague.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTALeagueList {
    return {
      leagues: globalThis.Array.isArray(object?.leagues)
        ? object.leagues.map((e: any) => CMsgDOTALeague.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgDOTALeagueList): unknown {
    const obj: any = {};
    if (message.leagues?.length) {
      obj.leagues = message.leagues.map((e) => CMsgDOTALeague.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTALeagueList>): CMsgDOTALeagueList {
    return CMsgDOTALeagueList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTALeagueList>): CMsgDOTALeagueList {
    const message = createBaseCMsgDOTALeagueList();
    message.leagues = object.leagues?.map((e) => CMsgDOTALeague.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgDOTALeagueInfo(): CMsgDOTALeagueInfo {
  return {
    leagueId: 0,
    name: "",
    tier: 0,
    region: 0,
    mostRecentActivity: 0,
    totalPrizePool: 0,
    startTimestamp: 0,
    endTimestamp: 0,
    status: 0,
  };
}

export const CMsgDOTALeagueInfo = {
  encode(message: CMsgDOTALeagueInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.leagueId !== undefined && message.leagueId !== 0) {
      writer.uint32(8).uint32(message.leagueId);
    }
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.tier !== undefined && message.tier !== 0) {
      writer.uint32(24).int32(message.tier);
    }
    if (message.region !== undefined && message.region !== 0) {
      writer.uint32(32).int32(message.region);
    }
    if (message.mostRecentActivity !== undefined && message.mostRecentActivity !== 0) {
      writer.uint32(40).uint32(message.mostRecentActivity);
    }
    if (message.totalPrizePool !== undefined && message.totalPrizePool !== 0) {
      writer.uint32(48).uint32(message.totalPrizePool);
    }
    if (message.startTimestamp !== undefined && message.startTimestamp !== 0) {
      writer.uint32(56).uint32(message.startTimestamp);
    }
    if (message.endTimestamp !== undefined && message.endTimestamp !== 0) {
      writer.uint32(64).uint32(message.endTimestamp);
    }
    if (message.status !== undefined && message.status !== 0) {
      writer.uint32(72).uint32(message.status);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTALeagueInfo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTALeagueInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.leagueId = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.tier = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.region = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.mostRecentActivity = reader.uint32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.totalPrizePool = reader.uint32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.startTimestamp = reader.uint32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.endTimestamp = reader.uint32();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.status = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTALeagueInfo {
    return {
      leagueId: isSet(object.leagueId) ? globalThis.Number(object.leagueId) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      tier: isSet(object.tier) ? eLeagueTierFromJSON(object.tier) : 0,
      region: isSet(object.region) ? eLeagueRegionFromJSON(object.region) : 0,
      mostRecentActivity: isSet(object.mostRecentActivity) ? globalThis.Number(object.mostRecentActivity) : 0,
      totalPrizePool: isSet(object.totalPrizePool) ? globalThis.Number(object.totalPrizePool) : 0,
      startTimestamp: isSet(object.startTimestamp) ? globalThis.Number(object.startTimestamp) : 0,
      endTimestamp: isSet(object.endTimestamp) ? globalThis.Number(object.endTimestamp) : 0,
      status: isSet(object.status) ? globalThis.Number(object.status) : 0,
    };
  },

  toJSON(message: CMsgDOTALeagueInfo): unknown {
    const obj: any = {};
    if (message.leagueId !== undefined && message.leagueId !== 0) {
      obj.leagueId = Math.round(message.leagueId);
    }
    if (message.name !== undefined && message.name !== "") {
      obj.name = message.name;
    }
    if (message.tier !== undefined && message.tier !== 0) {
      obj.tier = eLeagueTierToJSON(message.tier);
    }
    if (message.region !== undefined && message.region !== 0) {
      obj.region = eLeagueRegionToJSON(message.region);
    }
    if (message.mostRecentActivity !== undefined && message.mostRecentActivity !== 0) {
      obj.mostRecentActivity = Math.round(message.mostRecentActivity);
    }
    if (message.totalPrizePool !== undefined && message.totalPrizePool !== 0) {
      obj.totalPrizePool = Math.round(message.totalPrizePool);
    }
    if (message.startTimestamp !== undefined && message.startTimestamp !== 0) {
      obj.startTimestamp = Math.round(message.startTimestamp);
    }
    if (message.endTimestamp !== undefined && message.endTimestamp !== 0) {
      obj.endTimestamp = Math.round(message.endTimestamp);
    }
    if (message.status !== undefined && message.status !== 0) {
      obj.status = Math.round(message.status);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTALeagueInfo>): CMsgDOTALeagueInfo {
    return CMsgDOTALeagueInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTALeagueInfo>): CMsgDOTALeagueInfo {
    const message = createBaseCMsgDOTALeagueInfo();
    message.leagueId = object.leagueId ?? 0;
    message.name = object.name ?? "";
    message.tier = object.tier ?? 0;
    message.region = object.region ?? 0;
    message.mostRecentActivity = object.mostRecentActivity ?? 0;
    message.totalPrizePool = object.totalPrizePool ?? 0;
    message.startTimestamp = object.startTimestamp ?? 0;
    message.endTimestamp = object.endTimestamp ?? 0;
    message.status = object.status ?? 0;
    return message;
  },
};

function createBaseCMsgDOTALeagueInfoList(): CMsgDOTALeagueInfoList {
  return { infos: [] };
}

export const CMsgDOTALeagueInfoList = {
  encode(message: CMsgDOTALeagueInfoList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.infos) {
      CMsgDOTALeagueInfo.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTALeagueInfoList {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTALeagueInfoList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.infos.push(CMsgDOTALeagueInfo.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTALeagueInfoList {
    return {
      infos: globalThis.Array.isArray(object?.infos)
        ? object.infos.map((e: any) => CMsgDOTALeagueInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgDOTALeagueInfoList): unknown {
    const obj: any = {};
    if (message.infos?.length) {
      obj.infos = message.infos.map((e) => CMsgDOTALeagueInfo.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTALeagueInfoList>): CMsgDOTALeagueInfoList {
    return CMsgDOTALeagueInfoList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTALeagueInfoList>): CMsgDOTALeagueInfoList {
    const message = createBaseCMsgDOTALeagueInfoList();
    message.infos = object.infos?.map((e) => CMsgDOTALeagueInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgDOTALeagueLiveGames(): CMsgDOTALeagueLiveGames {
  return { games: [] };
}

export const CMsgDOTALeagueLiveGames = {
  encode(message: CMsgDOTALeagueLiveGames, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.games) {
      CMsgDOTALeagueLiveGames_LiveGame.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTALeagueLiveGames {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTALeagueLiveGames();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.games.push(CMsgDOTALeagueLiveGames_LiveGame.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTALeagueLiveGames {
    return {
      games: globalThis.Array.isArray(object?.games)
        ? object.games.map((e: any) => CMsgDOTALeagueLiveGames_LiveGame.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgDOTALeagueLiveGames): unknown {
    const obj: any = {};
    if (message.games?.length) {
      obj.games = message.games.map((e) => CMsgDOTALeagueLiveGames_LiveGame.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTALeagueLiveGames>): CMsgDOTALeagueLiveGames {
    return CMsgDOTALeagueLiveGames.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTALeagueLiveGames>): CMsgDOTALeagueLiveGames {
    const message = createBaseCMsgDOTALeagueLiveGames();
    message.games = object.games?.map((e) => CMsgDOTALeagueLiveGames_LiveGame.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgDOTALeagueLiveGames_LiveGame(): CMsgDOTALeagueLiveGames_LiveGame {
  return {
    leagueId: 0,
    serverSteamId: "0",
    radiantName: "",
    radiantLogo: "0",
    radiantTeamId: 0,
    direName: "",
    direLogo: "0",
    direTeamId: 0,
    time: 0,
    spectators: 0,
    leagueNodeId: 0,
    seriesId: 0,
    matchId: "0",
  };
}

export const CMsgDOTALeagueLiveGames_LiveGame = {
  encode(message: CMsgDOTALeagueLiveGames_LiveGame, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.leagueId !== undefined && message.leagueId !== 0) {
      writer.uint32(8).uint32(message.leagueId);
    }
    if (message.serverSteamId !== undefined && message.serverSteamId !== "0") {
      writer.uint32(16).uint64(message.serverSteamId);
    }
    if (message.radiantName !== undefined && message.radiantName !== "") {
      writer.uint32(26).string(message.radiantName);
    }
    if (message.radiantLogo !== undefined && message.radiantLogo !== "0") {
      writer.uint32(32).uint64(message.radiantLogo);
    }
    if (message.radiantTeamId !== undefined && message.radiantTeamId !== 0) {
      writer.uint32(72).uint32(message.radiantTeamId);
    }
    if (message.direName !== undefined && message.direName !== "") {
      writer.uint32(42).string(message.direName);
    }
    if (message.direLogo !== undefined && message.direLogo !== "0") {
      writer.uint32(48).uint64(message.direLogo);
    }
    if (message.direTeamId !== undefined && message.direTeamId !== 0) {
      writer.uint32(80).uint32(message.direTeamId);
    }
    if (message.time !== undefined && message.time !== 0) {
      writer.uint32(56).uint32(message.time);
    }
    if (message.spectators !== undefined && message.spectators !== 0) {
      writer.uint32(64).uint32(message.spectators);
    }
    if (message.leagueNodeId !== undefined && message.leagueNodeId !== 0) {
      writer.uint32(88).uint32(message.leagueNodeId);
    }
    if (message.seriesId !== undefined && message.seriesId !== 0) {
      writer.uint32(96).uint32(message.seriesId);
    }
    if (message.matchId !== undefined && message.matchId !== "0") {
      writer.uint32(104).uint64(message.matchId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTALeagueLiveGames_LiveGame {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTALeagueLiveGames_LiveGame();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.leagueId = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.serverSteamId = longToString(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.radiantName = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.radiantLogo = longToString(reader.uint64() as Long);
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.radiantTeamId = reader.uint32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.direName = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.direLogo = longToString(reader.uint64() as Long);
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.direTeamId = reader.uint32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.time = reader.uint32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.spectators = reader.uint32();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.leagueNodeId = reader.uint32();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.seriesId = reader.uint32();
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.matchId = longToString(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTALeagueLiveGames_LiveGame {
    return {
      leagueId: isSet(object.leagueId) ? globalThis.Number(object.leagueId) : 0,
      serverSteamId: isSet(object.serverSteamId) ? globalThis.String(object.serverSteamId) : "0",
      radiantName: isSet(object.radiantName) ? globalThis.String(object.radiantName) : "",
      radiantLogo: isSet(object.radiantLogo) ? globalThis.String(object.radiantLogo) : "0",
      radiantTeamId: isSet(object.radiantTeamId) ? globalThis.Number(object.radiantTeamId) : 0,
      direName: isSet(object.direName) ? globalThis.String(object.direName) : "",
      direLogo: isSet(object.direLogo) ? globalThis.String(object.direLogo) : "0",
      direTeamId: isSet(object.direTeamId) ? globalThis.Number(object.direTeamId) : 0,
      time: isSet(object.time) ? globalThis.Number(object.time) : 0,
      spectators: isSet(object.spectators) ? globalThis.Number(object.spectators) : 0,
      leagueNodeId: isSet(object.leagueNodeId) ? globalThis.Number(object.leagueNodeId) : 0,
      seriesId: isSet(object.seriesId) ? globalThis.Number(object.seriesId) : 0,
      matchId: isSet(object.matchId) ? globalThis.String(object.matchId) : "0",
    };
  },

  toJSON(message: CMsgDOTALeagueLiveGames_LiveGame): unknown {
    const obj: any = {};
    if (message.leagueId !== undefined && message.leagueId !== 0) {
      obj.leagueId = Math.round(message.leagueId);
    }
    if (message.serverSteamId !== undefined && message.serverSteamId !== "0") {
      obj.serverSteamId = message.serverSteamId;
    }
    if (message.radiantName !== undefined && message.radiantName !== "") {
      obj.radiantName = message.radiantName;
    }
    if (message.radiantLogo !== undefined && message.radiantLogo !== "0") {
      obj.radiantLogo = message.radiantLogo;
    }
    if (message.radiantTeamId !== undefined && message.radiantTeamId !== 0) {
      obj.radiantTeamId = Math.round(message.radiantTeamId);
    }
    if (message.direName !== undefined && message.direName !== "") {
      obj.direName = message.direName;
    }
    if (message.direLogo !== undefined && message.direLogo !== "0") {
      obj.direLogo = message.direLogo;
    }
    if (message.direTeamId !== undefined && message.direTeamId !== 0) {
      obj.direTeamId = Math.round(message.direTeamId);
    }
    if (message.time !== undefined && message.time !== 0) {
      obj.time = Math.round(message.time);
    }
    if (message.spectators !== undefined && message.spectators !== 0) {
      obj.spectators = Math.round(message.spectators);
    }
    if (message.leagueNodeId !== undefined && message.leagueNodeId !== 0) {
      obj.leagueNodeId = Math.round(message.leagueNodeId);
    }
    if (message.seriesId !== undefined && message.seriesId !== 0) {
      obj.seriesId = Math.round(message.seriesId);
    }
    if (message.matchId !== undefined && message.matchId !== "0") {
      obj.matchId = message.matchId;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTALeagueLiveGames_LiveGame>): CMsgDOTALeagueLiveGames_LiveGame {
    return CMsgDOTALeagueLiveGames_LiveGame.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTALeagueLiveGames_LiveGame>): CMsgDOTALeagueLiveGames_LiveGame {
    const message = createBaseCMsgDOTALeagueLiveGames_LiveGame();
    message.leagueId = object.leagueId ?? 0;
    message.serverSteamId = object.serverSteamId ?? "0";
    message.radiantName = object.radiantName ?? "";
    message.radiantLogo = object.radiantLogo ?? "0";
    message.radiantTeamId = object.radiantTeamId ?? 0;
    message.direName = object.direName ?? "";
    message.direLogo = object.direLogo ?? "0";
    message.direTeamId = object.direTeamId ?? 0;
    message.time = object.time ?? 0;
    message.spectators = object.spectators ?? 0;
    message.leagueNodeId = object.leagueNodeId ?? 0;
    message.seriesId = object.seriesId ?? 0;
    message.matchId = object.matchId ?? "0";
    return message;
  },
};

function createBaseCMsgDOTALeagueMessages(): CMsgDOTALeagueMessages {
  return { messages: [] };
}

export const CMsgDOTALeagueMessages = {
  encode(message: CMsgDOTALeagueMessages, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.messages) {
      CMsgDOTALeagueMessages_Message.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTALeagueMessages {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTALeagueMessages();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.messages.push(CMsgDOTALeagueMessages_Message.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTALeagueMessages {
    return {
      messages: globalThis.Array.isArray(object?.messages)
        ? object.messages.map((e: any) => CMsgDOTALeagueMessages_Message.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgDOTALeagueMessages): unknown {
    const obj: any = {};
    if (message.messages?.length) {
      obj.messages = message.messages.map((e) => CMsgDOTALeagueMessages_Message.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTALeagueMessages>): CMsgDOTALeagueMessages {
    return CMsgDOTALeagueMessages.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTALeagueMessages>): CMsgDOTALeagueMessages {
    const message = createBaseCMsgDOTALeagueMessages();
    message.messages = object.messages?.map((e) => CMsgDOTALeagueMessages_Message.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgDOTALeagueMessages_Message(): CMsgDOTALeagueMessages_Message {
  return { authorAccountId: 0, timestamp: 0, message: "" };
}

export const CMsgDOTALeagueMessages_Message = {
  encode(message: CMsgDOTALeagueMessages_Message, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.authorAccountId !== undefined && message.authorAccountId !== 0) {
      writer.uint32(8).uint32(message.authorAccountId);
    }
    if (message.timestamp !== undefined && message.timestamp !== 0) {
      writer.uint32(16).uint32(message.timestamp);
    }
    if (message.message !== undefined && message.message !== "") {
      writer.uint32(26).string(message.message);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTALeagueMessages_Message {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTALeagueMessages_Message();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.authorAccountId = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.timestamp = reader.uint32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.message = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTALeagueMessages_Message {
    return {
      authorAccountId: isSet(object.authorAccountId) ? globalThis.Number(object.authorAccountId) : 0,
      timestamp: isSet(object.timestamp) ? globalThis.Number(object.timestamp) : 0,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: CMsgDOTALeagueMessages_Message): unknown {
    const obj: any = {};
    if (message.authorAccountId !== undefined && message.authorAccountId !== 0) {
      obj.authorAccountId = Math.round(message.authorAccountId);
    }
    if (message.timestamp !== undefined && message.timestamp !== 0) {
      obj.timestamp = Math.round(message.timestamp);
    }
    if (message.message !== undefined && message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTALeagueMessages_Message>): CMsgDOTALeagueMessages_Message {
    return CMsgDOTALeagueMessages_Message.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTALeagueMessages_Message>): CMsgDOTALeagueMessages_Message {
    const message = createBaseCMsgDOTALeagueMessages_Message();
    message.authorAccountId = object.authorAccountId ?? 0;
    message.timestamp = object.timestamp ?? 0;
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseCMsgDOTALeaguePrizePool(): CMsgDOTALeaguePrizePool {
  return { prizePool: 0, incrementPerSecond: 0 };
}

export const CMsgDOTALeaguePrizePool = {
  encode(message: CMsgDOTALeaguePrizePool, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.prizePool !== undefined && message.prizePool !== 0) {
      writer.uint32(8).uint32(message.prizePool);
    }
    if (message.incrementPerSecond !== undefined && message.incrementPerSecond !== 0) {
      writer.uint32(21).float(message.incrementPerSecond);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTALeaguePrizePool {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTALeaguePrizePool();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.prizePool = reader.uint32();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.incrementPerSecond = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTALeaguePrizePool {
    return {
      prizePool: isSet(object.prizePool) ? globalThis.Number(object.prizePool) : 0,
      incrementPerSecond: isSet(object.incrementPerSecond) ? globalThis.Number(object.incrementPerSecond) : 0,
    };
  },

  toJSON(message: CMsgDOTALeaguePrizePool): unknown {
    const obj: any = {};
    if (message.prizePool !== undefined && message.prizePool !== 0) {
      obj.prizePool = Math.round(message.prizePool);
    }
    if (message.incrementPerSecond !== undefined && message.incrementPerSecond !== 0) {
      obj.incrementPerSecond = message.incrementPerSecond;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTALeaguePrizePool>): CMsgDOTALeaguePrizePool {
    return CMsgDOTALeaguePrizePool.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTALeaguePrizePool>): CMsgDOTALeaguePrizePool {
    const message = createBaseCMsgDOTALeaguePrizePool();
    message.prizePool = object.prizePool ?? 0;
    message.incrementPerSecond = object.incrementPerSecond ?? 0;
    return message;
  },
};

function createBaseCMsgDOTALeagueInfoListAdminsRequest(): CMsgDOTALeagueInfoListAdminsRequest {
  return {};
}

export const CMsgDOTALeagueInfoListAdminsRequest = {
  encode(_: CMsgDOTALeagueInfoListAdminsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTALeagueInfoListAdminsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTALeagueInfoListAdminsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CMsgDOTALeagueInfoListAdminsRequest {
    return {};
  },

  toJSON(_: CMsgDOTALeagueInfoListAdminsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTALeagueInfoListAdminsRequest>): CMsgDOTALeagueInfoListAdminsRequest {
    return CMsgDOTALeagueInfoListAdminsRequest.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<CMsgDOTALeagueInfoListAdminsRequest>): CMsgDOTALeagueInfoListAdminsRequest {
    const message = createBaseCMsgDOTALeagueInfoListAdminsRequest();
    return message;
  },
};

function createBaseCMsgDOTALeagueAvailableLobbyNodesRequest(): CMsgDOTALeagueAvailableLobbyNodesRequest {
  return { leagueId: 0 };
}

export const CMsgDOTALeagueAvailableLobbyNodesRequest = {
  encode(message: CMsgDOTALeagueAvailableLobbyNodesRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.leagueId !== undefined && message.leagueId !== 0) {
      writer.uint32(8).uint32(message.leagueId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTALeagueAvailableLobbyNodesRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTALeagueAvailableLobbyNodesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.leagueId = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTALeagueAvailableLobbyNodesRequest {
    return { leagueId: isSet(object.leagueId) ? globalThis.Number(object.leagueId) : 0 };
  },

  toJSON(message: CMsgDOTALeagueAvailableLobbyNodesRequest): unknown {
    const obj: any = {};
    if (message.leagueId !== undefined && message.leagueId !== 0) {
      obj.leagueId = Math.round(message.leagueId);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTALeagueAvailableLobbyNodesRequest>): CMsgDOTALeagueAvailableLobbyNodesRequest {
    return CMsgDOTALeagueAvailableLobbyNodesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTALeagueAvailableLobbyNodesRequest>): CMsgDOTALeagueAvailableLobbyNodesRequest {
    const message = createBaseCMsgDOTALeagueAvailableLobbyNodesRequest();
    message.leagueId = object.leagueId ?? 0;
    return message;
  },
};

function createBaseCMsgDOTALeagueAvailableLobbyNodes(): CMsgDOTALeagueAvailableLobbyNodes {
  return { nodeInfos: [] };
}

export const CMsgDOTALeagueAvailableLobbyNodes = {
  encode(message: CMsgDOTALeagueAvailableLobbyNodes, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.nodeInfos) {
      CMsgDOTALeagueAvailableLobbyNodes_NodeInfo.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTALeagueAvailableLobbyNodes {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTALeagueAvailableLobbyNodes();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.nodeInfos.push(CMsgDOTALeagueAvailableLobbyNodes_NodeInfo.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTALeagueAvailableLobbyNodes {
    return {
      nodeInfos: globalThis.Array.isArray(object?.nodeInfos)
        ? object.nodeInfos.map((e: any) => CMsgDOTALeagueAvailableLobbyNodes_NodeInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgDOTALeagueAvailableLobbyNodes): unknown {
    const obj: any = {};
    if (message.nodeInfos?.length) {
      obj.nodeInfos = message.nodeInfos.map((e) => CMsgDOTALeagueAvailableLobbyNodes_NodeInfo.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTALeagueAvailableLobbyNodes>): CMsgDOTALeagueAvailableLobbyNodes {
    return CMsgDOTALeagueAvailableLobbyNodes.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTALeagueAvailableLobbyNodes>): CMsgDOTALeagueAvailableLobbyNodes {
    const message = createBaseCMsgDOTALeagueAvailableLobbyNodes();
    message.nodeInfos = object.nodeInfos?.map((e) => CMsgDOTALeagueAvailableLobbyNodes_NodeInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgDOTALeagueAvailableLobbyNodes_NodeInfo(): CMsgDOTALeagueAvailableLobbyNodes_NodeInfo {
  return { nodeId: 0, nodeName: "", nodeGroupName: "", teamId1: 0, teamId2: 0 };
}

export const CMsgDOTALeagueAvailableLobbyNodes_NodeInfo = {
  encode(message: CMsgDOTALeagueAvailableLobbyNodes_NodeInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.nodeId !== undefined && message.nodeId !== 0) {
      writer.uint32(8).uint32(message.nodeId);
    }
    if (message.nodeName !== undefined && message.nodeName !== "") {
      writer.uint32(18).string(message.nodeName);
    }
    if (message.nodeGroupName !== undefined && message.nodeGroupName !== "") {
      writer.uint32(26).string(message.nodeGroupName);
    }
    if (message.teamId1 !== undefined && message.teamId1 !== 0) {
      writer.uint32(32).uint32(message.teamId1);
    }
    if (message.teamId2 !== undefined && message.teamId2 !== 0) {
      writer.uint32(40).uint32(message.teamId2);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTALeagueAvailableLobbyNodes_NodeInfo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTALeagueAvailableLobbyNodes_NodeInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.nodeId = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nodeName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.nodeGroupName = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.teamId1 = reader.uint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.teamId2 = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTALeagueAvailableLobbyNodes_NodeInfo {
    return {
      nodeId: isSet(object.nodeId) ? globalThis.Number(object.nodeId) : 0,
      nodeName: isSet(object.nodeName) ? globalThis.String(object.nodeName) : "",
      nodeGroupName: isSet(object.nodeGroupName) ? globalThis.String(object.nodeGroupName) : "",
      teamId1: isSet(object.teamId1) ? globalThis.Number(object.teamId1) : 0,
      teamId2: isSet(object.teamId2) ? globalThis.Number(object.teamId2) : 0,
    };
  },

  toJSON(message: CMsgDOTALeagueAvailableLobbyNodes_NodeInfo): unknown {
    const obj: any = {};
    if (message.nodeId !== undefined && message.nodeId !== 0) {
      obj.nodeId = Math.round(message.nodeId);
    }
    if (message.nodeName !== undefined && message.nodeName !== "") {
      obj.nodeName = message.nodeName;
    }
    if (message.nodeGroupName !== undefined && message.nodeGroupName !== "") {
      obj.nodeGroupName = message.nodeGroupName;
    }
    if (message.teamId1 !== undefined && message.teamId1 !== 0) {
      obj.teamId1 = Math.round(message.teamId1);
    }
    if (message.teamId2 !== undefined && message.teamId2 !== 0) {
      obj.teamId2 = Math.round(message.teamId2);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTALeagueAvailableLobbyNodes_NodeInfo>): CMsgDOTALeagueAvailableLobbyNodes_NodeInfo {
    return CMsgDOTALeagueAvailableLobbyNodes_NodeInfo.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgDOTALeagueAvailableLobbyNodes_NodeInfo>,
  ): CMsgDOTALeagueAvailableLobbyNodes_NodeInfo {
    const message = createBaseCMsgDOTALeagueAvailableLobbyNodes_NodeInfo();
    message.nodeId = object.nodeId ?? 0;
    message.nodeName = object.nodeName ?? "";
    message.nodeGroupName = object.nodeGroupName ?? "";
    message.teamId1 = object.teamId1 ?? 0;
    message.teamId2 = object.teamId2 ?? 0;
    return message;
  },
};

function createBaseCMsgDOTALeagueNodeResults(): CMsgDOTALeagueNodeResults {
  return { nodeResults: [] };
}

export const CMsgDOTALeagueNodeResults = {
  encode(message: CMsgDOTALeagueNodeResults, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.nodeResults) {
      CMsgDOTALeagueNodeResults_Result.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTALeagueNodeResults {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTALeagueNodeResults();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.nodeResults.push(CMsgDOTALeagueNodeResults_Result.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTALeagueNodeResults {
    return {
      nodeResults: globalThis.Array.isArray(object?.nodeResults)
        ? object.nodeResults.map((e: any) => CMsgDOTALeagueNodeResults_Result.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgDOTALeagueNodeResults): unknown {
    const obj: any = {};
    if (message.nodeResults?.length) {
      obj.nodeResults = message.nodeResults.map((e) => CMsgDOTALeagueNodeResults_Result.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTALeagueNodeResults>): CMsgDOTALeagueNodeResults {
    return CMsgDOTALeagueNodeResults.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTALeagueNodeResults>): CMsgDOTALeagueNodeResults {
    const message = createBaseCMsgDOTALeagueNodeResults();
    message.nodeResults = object.nodeResults?.map((e) => CMsgDOTALeagueNodeResults_Result.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgDOTALeagueNodeResults_Result(): CMsgDOTALeagueNodeResults_Result {
  return {
    nodeId: 0,
    winningNodeId: 0,
    losingNodeId: 0,
    incomingNodeId1: 0,
    incomingNodeId2: 0,
    teamId1: 0,
    teamId2: 0,
    team1Name: "",
    team2Name: "",
    team1Wins: 0,
    team2Wins: 0,
    winningTeamId: 0,
    losingTeamId: 0,
    hasStarted: false,
    isCompleted: false,
    scheduledTime: 0,
    matchIds: [],
  };
}

export const CMsgDOTALeagueNodeResults_Result = {
  encode(message: CMsgDOTALeagueNodeResults_Result, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.nodeId !== undefined && message.nodeId !== 0) {
      writer.uint32(8).uint32(message.nodeId);
    }
    if (message.winningNodeId !== undefined && message.winningNodeId !== 0) {
      writer.uint32(16).uint32(message.winningNodeId);
    }
    if (message.losingNodeId !== undefined && message.losingNodeId !== 0) {
      writer.uint32(24).uint32(message.losingNodeId);
    }
    if (message.incomingNodeId1 !== undefined && message.incomingNodeId1 !== 0) {
      writer.uint32(32).uint32(message.incomingNodeId1);
    }
    if (message.incomingNodeId2 !== undefined && message.incomingNodeId2 !== 0) {
      writer.uint32(40).uint32(message.incomingNodeId2);
    }
    if (message.teamId1 !== undefined && message.teamId1 !== 0) {
      writer.uint32(48).uint32(message.teamId1);
    }
    if (message.teamId2 !== undefined && message.teamId2 !== 0) {
      writer.uint32(56).uint32(message.teamId2);
    }
    if (message.team1Name !== undefined && message.team1Name !== "") {
      writer.uint32(66).string(message.team1Name);
    }
    if (message.team2Name !== undefined && message.team2Name !== "") {
      writer.uint32(74).string(message.team2Name);
    }
    if (message.team1Wins !== undefined && message.team1Wins !== 0) {
      writer.uint32(80).uint32(message.team1Wins);
    }
    if (message.team2Wins !== undefined && message.team2Wins !== 0) {
      writer.uint32(88).uint32(message.team2Wins);
    }
    if (message.winningTeamId !== undefined && message.winningTeamId !== 0) {
      writer.uint32(96).uint32(message.winningTeamId);
    }
    if (message.losingTeamId !== undefined && message.losingTeamId !== 0) {
      writer.uint32(104).uint32(message.losingTeamId);
    }
    if (message.hasStarted !== undefined && message.hasStarted !== false) {
      writer.uint32(112).bool(message.hasStarted);
    }
    if (message.isCompleted !== undefined && message.isCompleted !== false) {
      writer.uint32(120).bool(message.isCompleted);
    }
    if (message.scheduledTime !== undefined && message.scheduledTime !== 0) {
      writer.uint32(128).uint32(message.scheduledTime);
    }
    writer.uint32(138).fork();
    for (const v of message.matchIds) {
      writer.uint64(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTALeagueNodeResults_Result {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTALeagueNodeResults_Result();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.nodeId = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.winningNodeId = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.losingNodeId = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.incomingNodeId1 = reader.uint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.incomingNodeId2 = reader.uint32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.teamId1 = reader.uint32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.teamId2 = reader.uint32();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.team1Name = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.team2Name = reader.string();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.team1Wins = reader.uint32();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.team2Wins = reader.uint32();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.winningTeamId = reader.uint32();
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.losingTeamId = reader.uint32();
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.hasStarted = reader.bool();
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.isCompleted = reader.bool();
          continue;
        case 16:
          if (tag !== 128) {
            break;
          }

          message.scheduledTime = reader.uint32();
          continue;
        case 17:
          if (tag === 136) {
            message.matchIds.push(longToString(reader.uint64() as Long));

            continue;
          }

          if (tag === 138) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.matchIds.push(longToString(reader.uint64() as Long));
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTALeagueNodeResults_Result {
    return {
      nodeId: isSet(object.nodeId) ? globalThis.Number(object.nodeId) : 0,
      winningNodeId: isSet(object.winningNodeId) ? globalThis.Number(object.winningNodeId) : 0,
      losingNodeId: isSet(object.losingNodeId) ? globalThis.Number(object.losingNodeId) : 0,
      incomingNodeId1: isSet(object.incomingNodeId1) ? globalThis.Number(object.incomingNodeId1) : 0,
      incomingNodeId2: isSet(object.incomingNodeId2) ? globalThis.Number(object.incomingNodeId2) : 0,
      teamId1: isSet(object.teamId1) ? globalThis.Number(object.teamId1) : 0,
      teamId2: isSet(object.teamId2) ? globalThis.Number(object.teamId2) : 0,
      team1Name: isSet(object.team1Name) ? globalThis.String(object.team1Name) : "",
      team2Name: isSet(object.team2Name) ? globalThis.String(object.team2Name) : "",
      team1Wins: isSet(object.team1Wins) ? globalThis.Number(object.team1Wins) : 0,
      team2Wins: isSet(object.team2Wins) ? globalThis.Number(object.team2Wins) : 0,
      winningTeamId: isSet(object.winningTeamId) ? globalThis.Number(object.winningTeamId) : 0,
      losingTeamId: isSet(object.losingTeamId) ? globalThis.Number(object.losingTeamId) : 0,
      hasStarted: isSet(object.hasStarted) ? globalThis.Boolean(object.hasStarted) : false,
      isCompleted: isSet(object.isCompleted) ? globalThis.Boolean(object.isCompleted) : false,
      scheduledTime: isSet(object.scheduledTime) ? globalThis.Number(object.scheduledTime) : 0,
      matchIds: globalThis.Array.isArray(object?.matchIds) ? object.matchIds.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: CMsgDOTALeagueNodeResults_Result): unknown {
    const obj: any = {};
    if (message.nodeId !== undefined && message.nodeId !== 0) {
      obj.nodeId = Math.round(message.nodeId);
    }
    if (message.winningNodeId !== undefined && message.winningNodeId !== 0) {
      obj.winningNodeId = Math.round(message.winningNodeId);
    }
    if (message.losingNodeId !== undefined && message.losingNodeId !== 0) {
      obj.losingNodeId = Math.round(message.losingNodeId);
    }
    if (message.incomingNodeId1 !== undefined && message.incomingNodeId1 !== 0) {
      obj.incomingNodeId1 = Math.round(message.incomingNodeId1);
    }
    if (message.incomingNodeId2 !== undefined && message.incomingNodeId2 !== 0) {
      obj.incomingNodeId2 = Math.round(message.incomingNodeId2);
    }
    if (message.teamId1 !== undefined && message.teamId1 !== 0) {
      obj.teamId1 = Math.round(message.teamId1);
    }
    if (message.teamId2 !== undefined && message.teamId2 !== 0) {
      obj.teamId2 = Math.round(message.teamId2);
    }
    if (message.team1Name !== undefined && message.team1Name !== "") {
      obj.team1Name = message.team1Name;
    }
    if (message.team2Name !== undefined && message.team2Name !== "") {
      obj.team2Name = message.team2Name;
    }
    if (message.team1Wins !== undefined && message.team1Wins !== 0) {
      obj.team1Wins = Math.round(message.team1Wins);
    }
    if (message.team2Wins !== undefined && message.team2Wins !== 0) {
      obj.team2Wins = Math.round(message.team2Wins);
    }
    if (message.winningTeamId !== undefined && message.winningTeamId !== 0) {
      obj.winningTeamId = Math.round(message.winningTeamId);
    }
    if (message.losingTeamId !== undefined && message.losingTeamId !== 0) {
      obj.losingTeamId = Math.round(message.losingTeamId);
    }
    if (message.hasStarted !== undefined && message.hasStarted !== false) {
      obj.hasStarted = message.hasStarted;
    }
    if (message.isCompleted !== undefined && message.isCompleted !== false) {
      obj.isCompleted = message.isCompleted;
    }
    if (message.scheduledTime !== undefined && message.scheduledTime !== 0) {
      obj.scheduledTime = Math.round(message.scheduledTime);
    }
    if (message.matchIds?.length) {
      obj.matchIds = message.matchIds;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTALeagueNodeResults_Result>): CMsgDOTALeagueNodeResults_Result {
    return CMsgDOTALeagueNodeResults_Result.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTALeagueNodeResults_Result>): CMsgDOTALeagueNodeResults_Result {
    const message = createBaseCMsgDOTALeagueNodeResults_Result();
    message.nodeId = object.nodeId ?? 0;
    message.winningNodeId = object.winningNodeId ?? 0;
    message.losingNodeId = object.losingNodeId ?? 0;
    message.incomingNodeId1 = object.incomingNodeId1 ?? 0;
    message.incomingNodeId2 = object.incomingNodeId2 ?? 0;
    message.teamId1 = object.teamId1 ?? 0;
    message.teamId2 = object.teamId2 ?? 0;
    message.team1Name = object.team1Name ?? "";
    message.team2Name = object.team2Name ?? "";
    message.team1Wins = object.team1Wins ?? 0;
    message.team2Wins = object.team2Wins ?? 0;
    message.winningTeamId = object.winningTeamId ?? 0;
    message.losingTeamId = object.losingTeamId ?? 0;
    message.hasStarted = object.hasStarted ?? false;
    message.isCompleted = object.isCompleted ?? false;
    message.scheduledTime = object.scheduledTime ?? 0;
    message.matchIds = object.matchIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseCMsgDOTADPCLeagueResults(): CMsgDOTADPCLeagueResults {
  return { results: [], points: [], dollars: [] };
}

export const CMsgDOTADPCLeagueResults = {
  encode(message: CMsgDOTADPCLeagueResults, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.results) {
      CMsgDOTADPCLeagueResults_Result.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    writer.uint32(18).fork();
    for (const v of message.points) {
      writer.uint32(v);
    }
    writer.ldelim();
    writer.uint32(26).fork();
    for (const v of message.dollars) {
      writer.uint32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTADPCLeagueResults {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTADPCLeagueResults();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.results.push(CMsgDOTADPCLeagueResults_Result.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag === 16) {
            message.points.push(reader.uint32());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.points.push(reader.uint32());
            }

            continue;
          }

          break;
        case 3:
          if (tag === 24) {
            message.dollars.push(reader.uint32());

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.dollars.push(reader.uint32());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTADPCLeagueResults {
    return {
      results: globalThis.Array.isArray(object?.results)
        ? object.results.map((e: any) => CMsgDOTADPCLeagueResults_Result.fromJSON(e))
        : [],
      points: globalThis.Array.isArray(object?.points) ? object.points.map((e: any) => globalThis.Number(e)) : [],
      dollars: globalThis.Array.isArray(object?.dollars) ? object.dollars.map((e: any) => globalThis.Number(e)) : [],
    };
  },

  toJSON(message: CMsgDOTADPCLeagueResults): unknown {
    const obj: any = {};
    if (message.results?.length) {
      obj.results = message.results.map((e) => CMsgDOTADPCLeagueResults_Result.toJSON(e));
    }
    if (message.points?.length) {
      obj.points = message.points.map((e) => Math.round(e));
    }
    if (message.dollars?.length) {
      obj.dollars = message.dollars.map((e) => Math.round(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTADPCLeagueResults>): CMsgDOTADPCLeagueResults {
    return CMsgDOTADPCLeagueResults.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTADPCLeagueResults>): CMsgDOTADPCLeagueResults {
    const message = createBaseCMsgDOTADPCLeagueResults();
    message.results = object.results?.map((e) => CMsgDOTADPCLeagueResults_Result.fromPartial(e)) || [];
    message.points = object.points?.map((e) => e) || [];
    message.dollars = object.dollars?.map((e) => e) || [];
    return message;
  },
};

function createBaseCMsgDOTADPCLeagueResults_Result(): CMsgDOTADPCLeagueResults_Result {
  return {
    standing: 0,
    teamId: 0,
    teamName: "",
    teamLogo: "0",
    teamLogoUrl: "",
    points: 0,
    earnings: 0,
    timestamp: 0,
    phase: 0,
    teamAbbreviation: "",
  };
}

export const CMsgDOTADPCLeagueResults_Result = {
  encode(message: CMsgDOTADPCLeagueResults_Result, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.standing !== undefined && message.standing !== 0) {
      writer.uint32(8).uint32(message.standing);
    }
    if (message.teamId !== undefined && message.teamId !== 0) {
      writer.uint32(16).uint32(message.teamId);
    }
    if (message.teamName !== undefined && message.teamName !== "") {
      writer.uint32(26).string(message.teamName);
    }
    if (message.teamLogo !== undefined && message.teamLogo !== "0") {
      writer.uint32(32).uint64(message.teamLogo);
    }
    if (message.teamLogoUrl !== undefined && message.teamLogoUrl !== "") {
      writer.uint32(42).string(message.teamLogoUrl);
    }
    if (message.points !== undefined && message.points !== 0) {
      writer.uint32(48).uint32(message.points);
    }
    if (message.earnings !== undefined && message.earnings !== 0) {
      writer.uint32(56).uint32(message.earnings);
    }
    if (message.timestamp !== undefined && message.timestamp !== 0) {
      writer.uint32(64).uint32(message.timestamp);
    }
    if (message.phase !== undefined && message.phase !== 0) {
      writer.uint32(72).int32(message.phase);
    }
    if (message.teamAbbreviation !== undefined && message.teamAbbreviation !== "") {
      writer.uint32(82).string(message.teamAbbreviation);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTADPCLeagueResults_Result {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTADPCLeagueResults_Result();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.standing = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.teamId = reader.uint32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.teamName = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.teamLogo = longToString(reader.uint64() as Long);
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.teamLogoUrl = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.points = reader.uint32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.earnings = reader.uint32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.timestamp = reader.uint32();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.phase = reader.int32() as any;
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.teamAbbreviation = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTADPCLeagueResults_Result {
    return {
      standing: isSet(object.standing) ? globalThis.Number(object.standing) : 0,
      teamId: isSet(object.teamId) ? globalThis.Number(object.teamId) : 0,
      teamName: isSet(object.teamName) ? globalThis.String(object.teamName) : "",
      teamLogo: isSet(object.teamLogo) ? globalThis.String(object.teamLogo) : "0",
      teamLogoUrl: isSet(object.teamLogoUrl) ? globalThis.String(object.teamLogoUrl) : "",
      points: isSet(object.points) ? globalThis.Number(object.points) : 0,
      earnings: isSet(object.earnings) ? globalThis.Number(object.earnings) : 0,
      timestamp: isSet(object.timestamp) ? globalThis.Number(object.timestamp) : 0,
      phase: isSet(object.phase) ? eLeaguePhaseFromJSON(object.phase) : 0,
      teamAbbreviation: isSet(object.teamAbbreviation) ? globalThis.String(object.teamAbbreviation) : "",
    };
  },

  toJSON(message: CMsgDOTADPCLeagueResults_Result): unknown {
    const obj: any = {};
    if (message.standing !== undefined && message.standing !== 0) {
      obj.standing = Math.round(message.standing);
    }
    if (message.teamId !== undefined && message.teamId !== 0) {
      obj.teamId = Math.round(message.teamId);
    }
    if (message.teamName !== undefined && message.teamName !== "") {
      obj.teamName = message.teamName;
    }
    if (message.teamLogo !== undefined && message.teamLogo !== "0") {
      obj.teamLogo = message.teamLogo;
    }
    if (message.teamLogoUrl !== undefined && message.teamLogoUrl !== "") {
      obj.teamLogoUrl = message.teamLogoUrl;
    }
    if (message.points !== undefined && message.points !== 0) {
      obj.points = Math.round(message.points);
    }
    if (message.earnings !== undefined && message.earnings !== 0) {
      obj.earnings = Math.round(message.earnings);
    }
    if (message.timestamp !== undefined && message.timestamp !== 0) {
      obj.timestamp = Math.round(message.timestamp);
    }
    if (message.phase !== undefined && message.phase !== 0) {
      obj.phase = eLeaguePhaseToJSON(message.phase);
    }
    if (message.teamAbbreviation !== undefined && message.teamAbbreviation !== "") {
      obj.teamAbbreviation = message.teamAbbreviation;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTADPCLeagueResults_Result>): CMsgDOTADPCLeagueResults_Result {
    return CMsgDOTADPCLeagueResults_Result.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTADPCLeagueResults_Result>): CMsgDOTADPCLeagueResults_Result {
    const message = createBaseCMsgDOTADPCLeagueResults_Result();
    message.standing = object.standing ?? 0;
    message.teamId = object.teamId ?? 0;
    message.teamName = object.teamName ?? "";
    message.teamLogo = object.teamLogo ?? "0";
    message.teamLogoUrl = object.teamLogoUrl ?? "";
    message.points = object.points ?? 0;
    message.earnings = object.earnings ?? 0;
    message.timestamp = object.timestamp ?? 0;
    message.phase = object.phase ?? 0;
    message.teamAbbreviation = object.teamAbbreviation ?? "";
    return message;
  },
};

function createBaseCMsgDOTADPCTeamResults(): CMsgDOTADPCTeamResults {
  return { results: [] };
}

export const CMsgDOTADPCTeamResults = {
  encode(message: CMsgDOTADPCTeamResults, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.results) {
      CMsgDOTADPCTeamResults_Result.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTADPCTeamResults {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTADPCTeamResults();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.results.push(CMsgDOTADPCTeamResults_Result.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTADPCTeamResults {
    return {
      results: globalThis.Array.isArray(object?.results)
        ? object.results.map((e: any) => CMsgDOTADPCTeamResults_Result.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgDOTADPCTeamResults): unknown {
    const obj: any = {};
    if (message.results?.length) {
      obj.results = message.results.map((e) => CMsgDOTADPCTeamResults_Result.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTADPCTeamResults>): CMsgDOTADPCTeamResults {
    return CMsgDOTADPCTeamResults.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTADPCTeamResults>): CMsgDOTADPCTeamResults {
    const message = createBaseCMsgDOTADPCTeamResults();
    message.results = object.results?.map((e) => CMsgDOTADPCTeamResults_Result.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgDOTADPCTeamResults_Result(): CMsgDOTADPCTeamResults_Result {
  return { leagueId: 0, standing: 0, points: 0, earnings: 0, timestamp: 0 };
}

export const CMsgDOTADPCTeamResults_Result = {
  encode(message: CMsgDOTADPCTeamResults_Result, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.leagueId !== undefined && message.leagueId !== 0) {
      writer.uint32(8).uint32(message.leagueId);
    }
    if (message.standing !== undefined && message.standing !== 0) {
      writer.uint32(16).uint32(message.standing);
    }
    if (message.points !== undefined && message.points !== 0) {
      writer.uint32(24).uint32(message.points);
    }
    if (message.earnings !== undefined && message.earnings !== 0) {
      writer.uint32(32).uint32(message.earnings);
    }
    if (message.timestamp !== undefined && message.timestamp !== 0) {
      writer.uint32(40).uint32(message.timestamp);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTADPCTeamResults_Result {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTADPCTeamResults_Result();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.leagueId = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.standing = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.points = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.earnings = reader.uint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.timestamp = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTADPCTeamResults_Result {
    return {
      leagueId: isSet(object.leagueId) ? globalThis.Number(object.leagueId) : 0,
      standing: isSet(object.standing) ? globalThis.Number(object.standing) : 0,
      points: isSet(object.points) ? globalThis.Number(object.points) : 0,
      earnings: isSet(object.earnings) ? globalThis.Number(object.earnings) : 0,
      timestamp: isSet(object.timestamp) ? globalThis.Number(object.timestamp) : 0,
    };
  },

  toJSON(message: CMsgDOTADPCTeamResults_Result): unknown {
    const obj: any = {};
    if (message.leagueId !== undefined && message.leagueId !== 0) {
      obj.leagueId = Math.round(message.leagueId);
    }
    if (message.standing !== undefined && message.standing !== 0) {
      obj.standing = Math.round(message.standing);
    }
    if (message.points !== undefined && message.points !== 0) {
      obj.points = Math.round(message.points);
    }
    if (message.earnings !== undefined && message.earnings !== 0) {
      obj.earnings = Math.round(message.earnings);
    }
    if (message.timestamp !== undefined && message.timestamp !== 0) {
      obj.timestamp = Math.round(message.timestamp);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTADPCTeamResults_Result>): CMsgDOTADPCTeamResults_Result {
    return CMsgDOTADPCTeamResults_Result.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTADPCTeamResults_Result>): CMsgDOTADPCTeamResults_Result {
    const message = createBaseCMsgDOTADPCTeamResults_Result();
    message.leagueId = object.leagueId ?? 0;
    message.standing = object.standing ?? 0;
    message.points = object.points ?? 0;
    message.earnings = object.earnings ?? 0;
    message.timestamp = object.timestamp ?? 0;
    return message;
  },
};

function createBaseCMsgDOTADPCSeasonResults(): CMsgDOTADPCSeasonResults {
  return { results: [], standings: [], majorWildcardStandings: [], majorGroupStandings: [], majorPlayoffStandings: [] };
}

export const CMsgDOTADPCSeasonResults = {
  encode(message: CMsgDOTADPCSeasonResults, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.results) {
      CMsgDOTADPCSeasonResults_TeamResult.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.standings) {
      CMsgDOTADPCSeasonResults_Standing.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.majorWildcardStandings) {
      CMsgDOTADPCSeasonResults_StandingEntry.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    for (const v of message.majorGroupStandings) {
      CMsgDOTADPCSeasonResults_StandingEntry.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    for (const v of message.majorPlayoffStandings) {
      CMsgDOTADPCSeasonResults_StandingEntry.encode(v!, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTADPCSeasonResults {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTADPCSeasonResults();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.results.push(CMsgDOTADPCSeasonResults_TeamResult.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.standings.push(CMsgDOTADPCSeasonResults_Standing.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.majorWildcardStandings.push(CMsgDOTADPCSeasonResults_StandingEntry.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.majorGroupStandings.push(CMsgDOTADPCSeasonResults_StandingEntry.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.majorPlayoffStandings.push(CMsgDOTADPCSeasonResults_StandingEntry.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTADPCSeasonResults {
    return {
      results: globalThis.Array.isArray(object?.results)
        ? object.results.map((e: any) => CMsgDOTADPCSeasonResults_TeamResult.fromJSON(e))
        : [],
      standings: globalThis.Array.isArray(object?.standings)
        ? object.standings.map((e: any) => CMsgDOTADPCSeasonResults_Standing.fromJSON(e))
        : [],
      majorWildcardStandings: globalThis.Array.isArray(object?.majorWildcardStandings)
        ? object.majorWildcardStandings.map((e: any) => CMsgDOTADPCSeasonResults_StandingEntry.fromJSON(e))
        : [],
      majorGroupStandings: globalThis.Array.isArray(object?.majorGroupStandings)
        ? object.majorGroupStandings.map((e: any) => CMsgDOTADPCSeasonResults_StandingEntry.fromJSON(e))
        : [],
      majorPlayoffStandings: globalThis.Array.isArray(object?.majorPlayoffStandings)
        ? object.majorPlayoffStandings.map((e: any) => CMsgDOTADPCSeasonResults_StandingEntry.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgDOTADPCSeasonResults): unknown {
    const obj: any = {};
    if (message.results?.length) {
      obj.results = message.results.map((e) => CMsgDOTADPCSeasonResults_TeamResult.toJSON(e));
    }
    if (message.standings?.length) {
      obj.standings = message.standings.map((e) => CMsgDOTADPCSeasonResults_Standing.toJSON(e));
    }
    if (message.majorWildcardStandings?.length) {
      obj.majorWildcardStandings = message.majorWildcardStandings.map((e) =>
        CMsgDOTADPCSeasonResults_StandingEntry.toJSON(e)
      );
    }
    if (message.majorGroupStandings?.length) {
      obj.majorGroupStandings = message.majorGroupStandings.map((e) =>
        CMsgDOTADPCSeasonResults_StandingEntry.toJSON(e)
      );
    }
    if (message.majorPlayoffStandings?.length) {
      obj.majorPlayoffStandings = message.majorPlayoffStandings.map((e) =>
        CMsgDOTADPCSeasonResults_StandingEntry.toJSON(e)
      );
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTADPCSeasonResults>): CMsgDOTADPCSeasonResults {
    return CMsgDOTADPCSeasonResults.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTADPCSeasonResults>): CMsgDOTADPCSeasonResults {
    const message = createBaseCMsgDOTADPCSeasonResults();
    message.results = object.results?.map((e) => CMsgDOTADPCSeasonResults_TeamResult.fromPartial(e)) || [];
    message.standings = object.standings?.map((e) => CMsgDOTADPCSeasonResults_Standing.fromPartial(e)) || [];
    message.majorWildcardStandings =
      object.majorWildcardStandings?.map((e) => CMsgDOTADPCSeasonResults_StandingEntry.fromPartial(e)) || [];
    message.majorGroupStandings =
      object.majorGroupStandings?.map((e) => CMsgDOTADPCSeasonResults_StandingEntry.fromPartial(e)) || [];
    message.majorPlayoffStandings =
      object.majorPlayoffStandings?.map((e) => CMsgDOTADPCSeasonResults_StandingEntry.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgDOTADPCSeasonResults_TeamLeagueResult(): CMsgDOTADPCSeasonResults_TeamLeagueResult {
  return { timestamp: 0, leagueId: 0, standing: 0, points: 0, earnings: 0, auditAction: 0, auditData: 0 };
}

export const CMsgDOTADPCSeasonResults_TeamLeagueResult = {
  encode(message: CMsgDOTADPCSeasonResults_TeamLeagueResult, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.timestamp !== undefined && message.timestamp !== 0) {
      writer.uint32(8).uint32(message.timestamp);
    }
    if (message.leagueId !== undefined && message.leagueId !== 0) {
      writer.uint32(16).uint32(message.leagueId);
    }
    if (message.standing !== undefined && message.standing !== 0) {
      writer.uint32(24).uint32(message.standing);
    }
    if (message.points !== undefined && message.points !== 0) {
      writer.uint32(32).uint32(message.points);
    }
    if (message.earnings !== undefined && message.earnings !== 0) {
      writer.uint32(40).uint32(message.earnings);
    }
    if (message.auditAction !== undefined && message.auditAction !== 0) {
      writer.uint32(48).uint32(message.auditAction);
    }
    if (message.auditData !== undefined && message.auditData !== 0) {
      writer.uint32(56).uint32(message.auditData);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTADPCSeasonResults_TeamLeagueResult {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTADPCSeasonResults_TeamLeagueResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.timestamp = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.leagueId = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.standing = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.points = reader.uint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.earnings = reader.uint32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.auditAction = reader.uint32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.auditData = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTADPCSeasonResults_TeamLeagueResult {
    return {
      timestamp: isSet(object.timestamp) ? globalThis.Number(object.timestamp) : 0,
      leagueId: isSet(object.leagueId) ? globalThis.Number(object.leagueId) : 0,
      standing: isSet(object.standing) ? globalThis.Number(object.standing) : 0,
      points: isSet(object.points) ? globalThis.Number(object.points) : 0,
      earnings: isSet(object.earnings) ? globalThis.Number(object.earnings) : 0,
      auditAction: isSet(object.auditAction) ? globalThis.Number(object.auditAction) : 0,
      auditData: isSet(object.auditData) ? globalThis.Number(object.auditData) : 0,
    };
  },

  toJSON(message: CMsgDOTADPCSeasonResults_TeamLeagueResult): unknown {
    const obj: any = {};
    if (message.timestamp !== undefined && message.timestamp !== 0) {
      obj.timestamp = Math.round(message.timestamp);
    }
    if (message.leagueId !== undefined && message.leagueId !== 0) {
      obj.leagueId = Math.round(message.leagueId);
    }
    if (message.standing !== undefined && message.standing !== 0) {
      obj.standing = Math.round(message.standing);
    }
    if (message.points !== undefined && message.points !== 0) {
      obj.points = Math.round(message.points);
    }
    if (message.earnings !== undefined && message.earnings !== 0) {
      obj.earnings = Math.round(message.earnings);
    }
    if (message.auditAction !== undefined && message.auditAction !== 0) {
      obj.auditAction = Math.round(message.auditAction);
    }
    if (message.auditData !== undefined && message.auditData !== 0) {
      obj.auditData = Math.round(message.auditData);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTADPCSeasonResults_TeamLeagueResult>): CMsgDOTADPCSeasonResults_TeamLeagueResult {
    return CMsgDOTADPCSeasonResults_TeamLeagueResult.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CMsgDOTADPCSeasonResults_TeamLeagueResult>,
  ): CMsgDOTADPCSeasonResults_TeamLeagueResult {
    const message = createBaseCMsgDOTADPCSeasonResults_TeamLeagueResult();
    message.timestamp = object.timestamp ?? 0;
    message.leagueId = object.leagueId ?? 0;
    message.standing = object.standing ?? 0;
    message.points = object.points ?? 0;
    message.earnings = object.earnings ?? 0;
    message.auditAction = object.auditAction ?? 0;
    message.auditData = object.auditData ?? 0;
    return message;
  },
};

function createBaseCMsgDOTADPCSeasonResults_TeamResult(): CMsgDOTADPCSeasonResults_TeamResult {
  return {
    teamId: 0,
    teamName: "",
    teamAbbreviation: "",
    teamLogo: "0",
    teamLogoUrl: "",
    totalPoints: 0,
    totalEarnings: 0,
    leagueResults: [],
  };
}

export const CMsgDOTADPCSeasonResults_TeamResult = {
  encode(message: CMsgDOTADPCSeasonResults_TeamResult, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.teamId !== undefined && message.teamId !== 0) {
      writer.uint32(8).uint32(message.teamId);
    }
    if (message.teamName !== undefined && message.teamName !== "") {
      writer.uint32(18).string(message.teamName);
    }
    if (message.teamAbbreviation !== undefined && message.teamAbbreviation !== "") {
      writer.uint32(66).string(message.teamAbbreviation);
    }
    if (message.teamLogo !== undefined && message.teamLogo !== "0") {
      writer.uint32(24).uint64(message.teamLogo);
    }
    if (message.teamLogoUrl !== undefined && message.teamLogoUrl !== "") {
      writer.uint32(34).string(message.teamLogoUrl);
    }
    if (message.totalPoints !== undefined && message.totalPoints !== 0) {
      writer.uint32(40).uint32(message.totalPoints);
    }
    if (message.totalEarnings !== undefined && message.totalEarnings !== 0) {
      writer.uint32(48).uint32(message.totalEarnings);
    }
    for (const v of message.leagueResults) {
      CMsgDOTADPCSeasonResults_TeamLeagueResult.encode(v!, writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTADPCSeasonResults_TeamResult {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTADPCSeasonResults_TeamResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.teamId = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.teamName = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.teamAbbreviation = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.teamLogo = longToString(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.teamLogoUrl = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.totalPoints = reader.uint32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.totalEarnings = reader.uint32();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.leagueResults.push(CMsgDOTADPCSeasonResults_TeamLeagueResult.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTADPCSeasonResults_TeamResult {
    return {
      teamId: isSet(object.teamId) ? globalThis.Number(object.teamId) : 0,
      teamName: isSet(object.teamName) ? globalThis.String(object.teamName) : "",
      teamAbbreviation: isSet(object.teamAbbreviation) ? globalThis.String(object.teamAbbreviation) : "",
      teamLogo: isSet(object.teamLogo) ? globalThis.String(object.teamLogo) : "0",
      teamLogoUrl: isSet(object.teamLogoUrl) ? globalThis.String(object.teamLogoUrl) : "",
      totalPoints: isSet(object.totalPoints) ? globalThis.Number(object.totalPoints) : 0,
      totalEarnings: isSet(object.totalEarnings) ? globalThis.Number(object.totalEarnings) : 0,
      leagueResults: globalThis.Array.isArray(object?.leagueResults)
        ? object.leagueResults.map((e: any) => CMsgDOTADPCSeasonResults_TeamLeagueResult.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgDOTADPCSeasonResults_TeamResult): unknown {
    const obj: any = {};
    if (message.teamId !== undefined && message.teamId !== 0) {
      obj.teamId = Math.round(message.teamId);
    }
    if (message.teamName !== undefined && message.teamName !== "") {
      obj.teamName = message.teamName;
    }
    if (message.teamAbbreviation !== undefined && message.teamAbbreviation !== "") {
      obj.teamAbbreviation = message.teamAbbreviation;
    }
    if (message.teamLogo !== undefined && message.teamLogo !== "0") {
      obj.teamLogo = message.teamLogo;
    }
    if (message.teamLogoUrl !== undefined && message.teamLogoUrl !== "") {
      obj.teamLogoUrl = message.teamLogoUrl;
    }
    if (message.totalPoints !== undefined && message.totalPoints !== 0) {
      obj.totalPoints = Math.round(message.totalPoints);
    }
    if (message.totalEarnings !== undefined && message.totalEarnings !== 0) {
      obj.totalEarnings = Math.round(message.totalEarnings);
    }
    if (message.leagueResults?.length) {
      obj.leagueResults = message.leagueResults.map((e) => CMsgDOTADPCSeasonResults_TeamLeagueResult.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTADPCSeasonResults_TeamResult>): CMsgDOTADPCSeasonResults_TeamResult {
    return CMsgDOTADPCSeasonResults_TeamResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTADPCSeasonResults_TeamResult>): CMsgDOTADPCSeasonResults_TeamResult {
    const message = createBaseCMsgDOTADPCSeasonResults_TeamResult();
    message.teamId = object.teamId ?? 0;
    message.teamName = object.teamName ?? "";
    message.teamAbbreviation = object.teamAbbreviation ?? "";
    message.teamLogo = object.teamLogo ?? "0";
    message.teamLogoUrl = object.teamLogoUrl ?? "";
    message.totalPoints = object.totalPoints ?? 0;
    message.totalEarnings = object.totalEarnings ?? 0;
    message.leagueResults =
      object.leagueResults?.map((e) => CMsgDOTADPCSeasonResults_TeamLeagueResult.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgDOTADPCSeasonResults_StandingEntry(): CMsgDOTADPCSeasonResults_StandingEntry {
  return { teamId: 0, wins: 0, losses: 0, teamUrl: "", teamName: "", teamAbbreviation: "" };
}

export const CMsgDOTADPCSeasonResults_StandingEntry = {
  encode(message: CMsgDOTADPCSeasonResults_StandingEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.teamId !== undefined && message.teamId !== 0) {
      writer.uint32(8).uint32(message.teamId);
    }
    if (message.wins !== undefined && message.wins !== 0) {
      writer.uint32(16).uint32(message.wins);
    }
    if (message.losses !== undefined && message.losses !== 0) {
      writer.uint32(24).uint32(message.losses);
    }
    if (message.teamUrl !== undefined && message.teamUrl !== "") {
      writer.uint32(34).string(message.teamUrl);
    }
    if (message.teamName !== undefined && message.teamName !== "") {
      writer.uint32(42).string(message.teamName);
    }
    if (message.teamAbbreviation !== undefined && message.teamAbbreviation !== "") {
      writer.uint32(50).string(message.teamAbbreviation);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTADPCSeasonResults_StandingEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTADPCSeasonResults_StandingEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.teamId = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.wins = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.losses = reader.uint32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.teamUrl = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.teamName = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.teamAbbreviation = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTADPCSeasonResults_StandingEntry {
    return {
      teamId: isSet(object.teamId) ? globalThis.Number(object.teamId) : 0,
      wins: isSet(object.wins) ? globalThis.Number(object.wins) : 0,
      losses: isSet(object.losses) ? globalThis.Number(object.losses) : 0,
      teamUrl: isSet(object.teamUrl) ? globalThis.String(object.teamUrl) : "",
      teamName: isSet(object.teamName) ? globalThis.String(object.teamName) : "",
      teamAbbreviation: isSet(object.teamAbbreviation) ? globalThis.String(object.teamAbbreviation) : "",
    };
  },

  toJSON(message: CMsgDOTADPCSeasonResults_StandingEntry): unknown {
    const obj: any = {};
    if (message.teamId !== undefined && message.teamId !== 0) {
      obj.teamId = Math.round(message.teamId);
    }
    if (message.wins !== undefined && message.wins !== 0) {
      obj.wins = Math.round(message.wins);
    }
    if (message.losses !== undefined && message.losses !== 0) {
      obj.losses = Math.round(message.losses);
    }
    if (message.teamUrl !== undefined && message.teamUrl !== "") {
      obj.teamUrl = message.teamUrl;
    }
    if (message.teamName !== undefined && message.teamName !== "") {
      obj.teamName = message.teamName;
    }
    if (message.teamAbbreviation !== undefined && message.teamAbbreviation !== "") {
      obj.teamAbbreviation = message.teamAbbreviation;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTADPCSeasonResults_StandingEntry>): CMsgDOTADPCSeasonResults_StandingEntry {
    return CMsgDOTADPCSeasonResults_StandingEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTADPCSeasonResults_StandingEntry>): CMsgDOTADPCSeasonResults_StandingEntry {
    const message = createBaseCMsgDOTADPCSeasonResults_StandingEntry();
    message.teamId = object.teamId ?? 0;
    message.wins = object.wins ?? 0;
    message.losses = object.losses ?? 0;
    message.teamUrl = object.teamUrl ?? "";
    message.teamName = object.teamName ?? "";
    message.teamAbbreviation = object.teamAbbreviation ?? "";
    return message;
  },
};

function createBaseCMsgDOTADPCSeasonResults_Standing(): CMsgDOTADPCSeasonResults_Standing {
  return { region: 0, division: 0, entries: [] };
}

export const CMsgDOTADPCSeasonResults_Standing = {
  encode(message: CMsgDOTADPCSeasonResults_Standing, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.region !== undefined && message.region !== 0) {
      writer.uint32(8).int32(message.region);
    }
    if (message.division !== undefined && message.division !== 0) {
      writer.uint32(16).int32(message.division);
    }
    for (const v of message.entries) {
      CMsgDOTADPCSeasonResults_StandingEntry.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTADPCSeasonResults_Standing {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTADPCSeasonResults_Standing();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.region = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.division = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.entries.push(CMsgDOTADPCSeasonResults_StandingEntry.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTADPCSeasonResults_Standing {
    return {
      region: isSet(object.region) ? eLeagueRegionFromJSON(object.region) : 0,
      division: isSet(object.division) ? eLeagueDivisionFromJSON(object.division) : 0,
      entries: globalThis.Array.isArray(object?.entries)
        ? object.entries.map((e: any) => CMsgDOTADPCSeasonResults_StandingEntry.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgDOTADPCSeasonResults_Standing): unknown {
    const obj: any = {};
    if (message.region !== undefined && message.region !== 0) {
      obj.region = eLeagueRegionToJSON(message.region);
    }
    if (message.division !== undefined && message.division !== 0) {
      obj.division = eLeagueDivisionToJSON(message.division);
    }
    if (message.entries?.length) {
      obj.entries = message.entries.map((e) => CMsgDOTADPCSeasonResults_StandingEntry.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTADPCSeasonResults_Standing>): CMsgDOTADPCSeasonResults_Standing {
    return CMsgDOTADPCSeasonResults_Standing.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTADPCSeasonResults_Standing>): CMsgDOTADPCSeasonResults_Standing {
    const message = createBaseCMsgDOTADPCSeasonResults_Standing();
    message.region = object.region ?? 0;
    message.division = object.division ?? 0;
    message.entries = object.entries?.map((e) => CMsgDOTADPCSeasonResults_StandingEntry.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgDOTADPCSeasonSpoilerResults(): CMsgDOTADPCSeasonSpoilerResults {
  return { timeLastUpdated: 0, savedResults: undefined };
}

export const CMsgDOTADPCSeasonSpoilerResults = {
  encode(message: CMsgDOTADPCSeasonSpoilerResults, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.timeLastUpdated !== undefined && message.timeLastUpdated !== 0) {
      writer.uint32(8).uint32(message.timeLastUpdated);
    }
    if (message.savedResults !== undefined) {
      CMsgDOTADPCSeasonResults.encode(message.savedResults, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgDOTADPCSeasonSpoilerResults {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgDOTADPCSeasonSpoilerResults();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.timeLastUpdated = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.savedResults = CMsgDOTADPCSeasonResults.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgDOTADPCSeasonSpoilerResults {
    return {
      timeLastUpdated: isSet(object.timeLastUpdated) ? globalThis.Number(object.timeLastUpdated) : 0,
      savedResults: isSet(object.savedResults) ? CMsgDOTADPCSeasonResults.fromJSON(object.savedResults) : undefined,
    };
  },

  toJSON(message: CMsgDOTADPCSeasonSpoilerResults): unknown {
    const obj: any = {};
    if (message.timeLastUpdated !== undefined && message.timeLastUpdated !== 0) {
      obj.timeLastUpdated = Math.round(message.timeLastUpdated);
    }
    if (message.savedResults !== undefined) {
      obj.savedResults = CMsgDOTADPCSeasonResults.toJSON(message.savedResults);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgDOTADPCSeasonSpoilerResults>): CMsgDOTADPCSeasonSpoilerResults {
    return CMsgDOTADPCSeasonSpoilerResults.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgDOTADPCSeasonSpoilerResults>): CMsgDOTADPCSeasonSpoilerResults {
    const message = createBaseCMsgDOTADPCSeasonSpoilerResults();
    message.timeLastUpdated = object.timeLastUpdated ?? 0;
    message.savedResults = (object.savedResults !== undefined && object.savedResults !== null)
      ? CMsgDOTADPCSeasonResults.fromPartial(object.savedResults)
      : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function longToString(long: Long) {
  return long.toString();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

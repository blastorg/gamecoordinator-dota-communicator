// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.176.1
//   protoc               v5.26.1
// source: netmessages.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";
import { CMsgQAngle, CMsgVector, CSVCMsgGameSessionConfiguration } from "./networkbasetypes";

export enum CLCMessages {
  clc_ClientInfo = 20,
  clc_Move = 21,
  clc_VoiceData = 22,
  clc_BaselineAck = 23,
  clc_RespondCvarValue = 25,
  clc_FileCRCCheck = 26,
  clc_LoadingProgress = 27,
  clc_SplitPlayerConnect = 28,
  clc_SplitPlayerDisconnect = 30,
  clc_ServerStatus = 31,
  clc_RequestPause = 33,
  clc_CmdKeyValues = 34,
  clc_RconServerDetails = 35,
  clc_HltvReplay = 36,
  clc_Diagnostic = 37,
}

export function cLCMessagesFromJSON(object: any): CLCMessages {
  switch (object) {
    case 20:
    case "clc_ClientInfo":
      return CLCMessages.clc_ClientInfo;
    case 21:
    case "clc_Move":
      return CLCMessages.clc_Move;
    case 22:
    case "clc_VoiceData":
      return CLCMessages.clc_VoiceData;
    case 23:
    case "clc_BaselineAck":
      return CLCMessages.clc_BaselineAck;
    case 25:
    case "clc_RespondCvarValue":
      return CLCMessages.clc_RespondCvarValue;
    case 26:
    case "clc_FileCRCCheck":
      return CLCMessages.clc_FileCRCCheck;
    case 27:
    case "clc_LoadingProgress":
      return CLCMessages.clc_LoadingProgress;
    case 28:
    case "clc_SplitPlayerConnect":
      return CLCMessages.clc_SplitPlayerConnect;
    case 30:
    case "clc_SplitPlayerDisconnect":
      return CLCMessages.clc_SplitPlayerDisconnect;
    case 31:
    case "clc_ServerStatus":
      return CLCMessages.clc_ServerStatus;
    case 33:
    case "clc_RequestPause":
      return CLCMessages.clc_RequestPause;
    case 34:
    case "clc_CmdKeyValues":
      return CLCMessages.clc_CmdKeyValues;
    case 35:
    case "clc_RconServerDetails":
      return CLCMessages.clc_RconServerDetails;
    case 36:
    case "clc_HltvReplay":
      return CLCMessages.clc_HltvReplay;
    case 37:
    case "clc_Diagnostic":
      return CLCMessages.clc_Diagnostic;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum CLCMessages");
  }
}

export function cLCMessagesToJSON(object: CLCMessages): string {
  switch (object) {
    case CLCMessages.clc_ClientInfo:
      return "clc_ClientInfo";
    case CLCMessages.clc_Move:
      return "clc_Move";
    case CLCMessages.clc_VoiceData:
      return "clc_VoiceData";
    case CLCMessages.clc_BaselineAck:
      return "clc_BaselineAck";
    case CLCMessages.clc_RespondCvarValue:
      return "clc_RespondCvarValue";
    case CLCMessages.clc_FileCRCCheck:
      return "clc_FileCRCCheck";
    case CLCMessages.clc_LoadingProgress:
      return "clc_LoadingProgress";
    case CLCMessages.clc_SplitPlayerConnect:
      return "clc_SplitPlayerConnect";
    case CLCMessages.clc_SplitPlayerDisconnect:
      return "clc_SplitPlayerDisconnect";
    case CLCMessages.clc_ServerStatus:
      return "clc_ServerStatus";
    case CLCMessages.clc_RequestPause:
      return "clc_RequestPause";
    case CLCMessages.clc_CmdKeyValues:
      return "clc_CmdKeyValues";
    case CLCMessages.clc_RconServerDetails:
      return "clc_RconServerDetails";
    case CLCMessages.clc_HltvReplay:
      return "clc_HltvReplay";
    case CLCMessages.clc_Diagnostic:
      return "clc_Diagnostic";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum CLCMessages");
  }
}

export enum SVCMessages {
  svc_ServerInfo = 40,
  svc_FlattenedSerializer = 41,
  svc_ClassInfo = 42,
  svc_SetPause = 43,
  svc_CreateStringTable = 44,
  svc_UpdateStringTable = 45,
  svc_VoiceInit = 46,
  svc_VoiceData = 47,
  svc_Print = 48,
  svc_Sounds = 49,
  svc_SetView = 50,
  svc_ClearAllStringTables = 51,
  svc_CmdKeyValues = 52,
  svc_BSPDecal = 53,
  svc_SplitScreen = 54,
  svc_PacketEntities = 55,
  svc_Prefetch = 56,
  svc_Menu = 57,
  svc_GetCvarValue = 58,
  svc_StopSound = 59,
  svc_PeerList = 60,
  svc_PacketReliable = 61,
  svc_HLTVStatus = 62,
  svc_ServerSteamID = 63,
  svc_FullFrameSplit = 70,
  svc_RconServerDetails = 71,
  svc_UserMessage = 72,
  svc_Broadcast_Command = 74,
  svc_HltvFixupOperatorStatus = 75,
  svc_UserCmds = 76,
}

export function sVCMessagesFromJSON(object: any): SVCMessages {
  switch (object) {
    case 40:
    case "svc_ServerInfo":
      return SVCMessages.svc_ServerInfo;
    case 41:
    case "svc_FlattenedSerializer":
      return SVCMessages.svc_FlattenedSerializer;
    case 42:
    case "svc_ClassInfo":
      return SVCMessages.svc_ClassInfo;
    case 43:
    case "svc_SetPause":
      return SVCMessages.svc_SetPause;
    case 44:
    case "svc_CreateStringTable":
      return SVCMessages.svc_CreateStringTable;
    case 45:
    case "svc_UpdateStringTable":
      return SVCMessages.svc_UpdateStringTable;
    case 46:
    case "svc_VoiceInit":
      return SVCMessages.svc_VoiceInit;
    case 47:
    case "svc_VoiceData":
      return SVCMessages.svc_VoiceData;
    case 48:
    case "svc_Print":
      return SVCMessages.svc_Print;
    case 49:
    case "svc_Sounds":
      return SVCMessages.svc_Sounds;
    case 50:
    case "svc_SetView":
      return SVCMessages.svc_SetView;
    case 51:
    case "svc_ClearAllStringTables":
      return SVCMessages.svc_ClearAllStringTables;
    case 52:
    case "svc_CmdKeyValues":
      return SVCMessages.svc_CmdKeyValues;
    case 53:
    case "svc_BSPDecal":
      return SVCMessages.svc_BSPDecal;
    case 54:
    case "svc_SplitScreen":
      return SVCMessages.svc_SplitScreen;
    case 55:
    case "svc_PacketEntities":
      return SVCMessages.svc_PacketEntities;
    case 56:
    case "svc_Prefetch":
      return SVCMessages.svc_Prefetch;
    case 57:
    case "svc_Menu":
      return SVCMessages.svc_Menu;
    case 58:
    case "svc_GetCvarValue":
      return SVCMessages.svc_GetCvarValue;
    case 59:
    case "svc_StopSound":
      return SVCMessages.svc_StopSound;
    case 60:
    case "svc_PeerList":
      return SVCMessages.svc_PeerList;
    case 61:
    case "svc_PacketReliable":
      return SVCMessages.svc_PacketReliable;
    case 62:
    case "svc_HLTVStatus":
      return SVCMessages.svc_HLTVStatus;
    case 63:
    case "svc_ServerSteamID":
      return SVCMessages.svc_ServerSteamID;
    case 70:
    case "svc_FullFrameSplit":
      return SVCMessages.svc_FullFrameSplit;
    case 71:
    case "svc_RconServerDetails":
      return SVCMessages.svc_RconServerDetails;
    case 72:
    case "svc_UserMessage":
      return SVCMessages.svc_UserMessage;
    case 74:
    case "svc_Broadcast_Command":
      return SVCMessages.svc_Broadcast_Command;
    case 75:
    case "svc_HltvFixupOperatorStatus":
      return SVCMessages.svc_HltvFixupOperatorStatus;
    case 76:
    case "svc_UserCmds":
      return SVCMessages.svc_UserCmds;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum SVCMessages");
  }
}

export function sVCMessagesToJSON(object: SVCMessages): string {
  switch (object) {
    case SVCMessages.svc_ServerInfo:
      return "svc_ServerInfo";
    case SVCMessages.svc_FlattenedSerializer:
      return "svc_FlattenedSerializer";
    case SVCMessages.svc_ClassInfo:
      return "svc_ClassInfo";
    case SVCMessages.svc_SetPause:
      return "svc_SetPause";
    case SVCMessages.svc_CreateStringTable:
      return "svc_CreateStringTable";
    case SVCMessages.svc_UpdateStringTable:
      return "svc_UpdateStringTable";
    case SVCMessages.svc_VoiceInit:
      return "svc_VoiceInit";
    case SVCMessages.svc_VoiceData:
      return "svc_VoiceData";
    case SVCMessages.svc_Print:
      return "svc_Print";
    case SVCMessages.svc_Sounds:
      return "svc_Sounds";
    case SVCMessages.svc_SetView:
      return "svc_SetView";
    case SVCMessages.svc_ClearAllStringTables:
      return "svc_ClearAllStringTables";
    case SVCMessages.svc_CmdKeyValues:
      return "svc_CmdKeyValues";
    case SVCMessages.svc_BSPDecal:
      return "svc_BSPDecal";
    case SVCMessages.svc_SplitScreen:
      return "svc_SplitScreen";
    case SVCMessages.svc_PacketEntities:
      return "svc_PacketEntities";
    case SVCMessages.svc_Prefetch:
      return "svc_Prefetch";
    case SVCMessages.svc_Menu:
      return "svc_Menu";
    case SVCMessages.svc_GetCvarValue:
      return "svc_GetCvarValue";
    case SVCMessages.svc_StopSound:
      return "svc_StopSound";
    case SVCMessages.svc_PeerList:
      return "svc_PeerList";
    case SVCMessages.svc_PacketReliable:
      return "svc_PacketReliable";
    case SVCMessages.svc_HLTVStatus:
      return "svc_HLTVStatus";
    case SVCMessages.svc_ServerSteamID:
      return "svc_ServerSteamID";
    case SVCMessages.svc_FullFrameSplit:
      return "svc_FullFrameSplit";
    case SVCMessages.svc_RconServerDetails:
      return "svc_RconServerDetails";
    case SVCMessages.svc_UserMessage:
      return "svc_UserMessage";
    case SVCMessages.svc_Broadcast_Command:
      return "svc_Broadcast_Command";
    case SVCMessages.svc_HltvFixupOperatorStatus:
      return "svc_HltvFixupOperatorStatus";
    case SVCMessages.svc_UserCmds:
      return "svc_UserCmds";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum SVCMessages");
  }
}

export enum VoiceDataFormatT {
  VOICEDATA_FORMAT_STEAM = 0,
  VOICEDATA_FORMAT_ENGINE = 1,
  VOICEDATA_FORMAT_OPUS = 2,
}

export function voiceDataFormatTFromJSON(object: any): VoiceDataFormatT {
  switch (object) {
    case 0:
    case "VOICEDATA_FORMAT_STEAM":
      return VoiceDataFormatT.VOICEDATA_FORMAT_STEAM;
    case 1:
    case "VOICEDATA_FORMAT_ENGINE":
      return VoiceDataFormatT.VOICEDATA_FORMAT_ENGINE;
    case 2:
    case "VOICEDATA_FORMAT_OPUS":
      return VoiceDataFormatT.VOICEDATA_FORMAT_OPUS;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum VoiceDataFormatT");
  }
}

export function voiceDataFormatTToJSON(object: VoiceDataFormatT): string {
  switch (object) {
    case VoiceDataFormatT.VOICEDATA_FORMAT_STEAM:
      return "VOICEDATA_FORMAT_STEAM";
    case VoiceDataFormatT.VOICEDATA_FORMAT_ENGINE:
      return "VOICEDATA_FORMAT_ENGINE";
    case VoiceDataFormatT.VOICEDATA_FORMAT_OPUS:
      return "VOICEDATA_FORMAT_OPUS";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum VoiceDataFormatT");
  }
}

export enum RequestPauseT {
  RP_PAUSE = 0,
  RP_UNPAUSE = 1,
  RP_TOGGLEPAUSE = 2,
}

export function requestPauseTFromJSON(object: any): RequestPauseT {
  switch (object) {
    case 0:
    case "RP_PAUSE":
      return RequestPauseT.RP_PAUSE;
    case 1:
    case "RP_UNPAUSE":
      return RequestPauseT.RP_UNPAUSE;
    case 2:
    case "RP_TOGGLEPAUSE":
      return RequestPauseT.RP_TOGGLEPAUSE;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum RequestPauseT");
  }
}

export function requestPauseTToJSON(object: RequestPauseT): string {
  switch (object) {
    case RequestPauseT.RP_PAUSE:
      return "RP_PAUSE";
    case RequestPauseT.RP_UNPAUSE:
      return "RP_UNPAUSE";
    case RequestPauseT.RP_TOGGLEPAUSE:
      return "RP_TOGGLEPAUSE";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum RequestPauseT");
  }
}

export enum PrefetchType {
  PFT_SOUND = 0,
}

export function prefetchTypeFromJSON(object: any): PrefetchType {
  switch (object) {
    case 0:
    case "PFT_SOUND":
      return PrefetchType.PFT_SOUND;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum PrefetchType");
  }
}

export function prefetchTypeToJSON(object: PrefetchType): string {
  switch (object) {
    case PrefetchType.PFT_SOUND:
      return "PFT_SOUND";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum PrefetchType");
  }
}

export enum ESplitScreenMessageType {
  MSG_SPLITSCREEN_ADDUSER = 0,
  MSG_SPLITSCREEN_REMOVEUSER = 1,
}

export function eSplitScreenMessageTypeFromJSON(object: any): ESplitScreenMessageType {
  switch (object) {
    case 0:
    case "MSG_SPLITSCREEN_ADDUSER":
      return ESplitScreenMessageType.MSG_SPLITSCREEN_ADDUSER;
    case 1:
    case "MSG_SPLITSCREEN_REMOVEUSER":
      return ESplitScreenMessageType.MSG_SPLITSCREEN_REMOVEUSER;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ESplitScreenMessageType");
  }
}

export function eSplitScreenMessageTypeToJSON(object: ESplitScreenMessageType): string {
  switch (object) {
    case ESplitScreenMessageType.MSG_SPLITSCREEN_ADDUSER:
      return "MSG_SPLITSCREEN_ADDUSER";
    case ESplitScreenMessageType.MSG_SPLITSCREEN_REMOVEUSER:
      return "MSG_SPLITSCREEN_REMOVEUSER";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ESplitScreenMessageType");
  }
}

export enum EQueryCvarValueStatus {
  eQueryCvarValueStatus_ValueIntact = 0,
  eQueryCvarValueStatus_CvarNotFound = 1,
  eQueryCvarValueStatus_NotACvar = 2,
  eQueryCvarValueStatus_CvarProtected = 3,
}

export function eQueryCvarValueStatusFromJSON(object: any): EQueryCvarValueStatus {
  switch (object) {
    case 0:
    case "eQueryCvarValueStatus_ValueIntact":
      return EQueryCvarValueStatus.eQueryCvarValueStatus_ValueIntact;
    case 1:
    case "eQueryCvarValueStatus_CvarNotFound":
      return EQueryCvarValueStatus.eQueryCvarValueStatus_CvarNotFound;
    case 2:
    case "eQueryCvarValueStatus_NotACvar":
      return EQueryCvarValueStatus.eQueryCvarValueStatus_NotACvar;
    case 3:
    case "eQueryCvarValueStatus_CvarProtected":
      return EQueryCvarValueStatus.eQueryCvarValueStatus_CvarProtected;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum EQueryCvarValueStatus");
  }
}

export function eQueryCvarValueStatusToJSON(object: EQueryCvarValueStatus): string {
  switch (object) {
    case EQueryCvarValueStatus.eQueryCvarValueStatus_ValueIntact:
      return "eQueryCvarValueStatus_ValueIntact";
    case EQueryCvarValueStatus.eQueryCvarValueStatus_CvarNotFound:
      return "eQueryCvarValueStatus_CvarNotFound";
    case EQueryCvarValueStatus.eQueryCvarValueStatus_NotACvar:
      return "eQueryCvarValueStatus_NotACvar";
    case EQueryCvarValueStatus.eQueryCvarValueStatus_CvarProtected:
      return "eQueryCvarValueStatus_CvarProtected";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum EQueryCvarValueStatus");
  }
}

export enum dialogType {
  DIALOG_MSG = 0,
  DIALOG_MENU = 1,
  DIALOG_TEXT = 2,
  DIALOG_ENTRY = 3,
  DIALOG_ASKCONNECT = 4,
}

export function dialogTypeFromJSON(object: any): dialogType {
  switch (object) {
    case 0:
    case "DIALOG_MSG":
      return dialogType.DIALOG_MSG;
    case 1:
    case "DIALOG_MENU":
      return dialogType.DIALOG_MENU;
    case 2:
    case "DIALOG_TEXT":
      return dialogType.DIALOG_TEXT;
    case 3:
    case "DIALOG_ENTRY":
      return dialogType.DIALOG_ENTRY;
    case 4:
    case "DIALOG_ASKCONNECT":
      return dialogType.DIALOG_ASKCONNECT;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum dialogType");
  }
}

export function dialogTypeToJSON(object: dialogType): string {
  switch (object) {
    case dialogType.DIALOG_MSG:
      return "DIALOG_MSG";
    case dialogType.DIALOG_MENU:
      return "DIALOG_MENU";
    case dialogType.DIALOG_TEXT:
      return "DIALOG_TEXT";
    case dialogType.DIALOG_ENTRY:
      return "DIALOG_ENTRY";
    case dialogType.DIALOG_ASKCONNECT:
      return "DIALOG_ASKCONNECT";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum dialogType");
  }
}

export enum SVCMessagesLowFrequency {
  svc_dummy = 600,
}

export function sVCMessagesLowFrequencyFromJSON(object: any): SVCMessagesLowFrequency {
  switch (object) {
    case 600:
    case "svc_dummy":
      return SVCMessagesLowFrequency.svc_dummy;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum SVCMessagesLowFrequency");
  }
}

export function sVCMessagesLowFrequencyToJSON(object: SVCMessagesLowFrequency): string {
  switch (object) {
    case SVCMessagesLowFrequency.svc_dummy:
      return "svc_dummy";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum SVCMessagesLowFrequency");
  }
}

export enum BidirectionalMessages {
  bi_RebroadcastGameEvent = 16,
  bi_RebroadcastSource = 17,
  bi_GameEvent = 18,
  bi_PredictionEvent = 19,
}

export function bidirectionalMessagesFromJSON(object: any): BidirectionalMessages {
  switch (object) {
    case 16:
    case "bi_RebroadcastGameEvent":
      return BidirectionalMessages.bi_RebroadcastGameEvent;
    case 17:
    case "bi_RebroadcastSource":
      return BidirectionalMessages.bi_RebroadcastSource;
    case 18:
    case "bi_GameEvent":
      return BidirectionalMessages.bi_GameEvent;
    case 19:
    case "bi_PredictionEvent":
      return BidirectionalMessages.bi_PredictionEvent;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum BidirectionalMessages");
  }
}

export function bidirectionalMessagesToJSON(object: BidirectionalMessages): string {
  switch (object) {
    case BidirectionalMessages.bi_RebroadcastGameEvent:
      return "bi_RebroadcastGameEvent";
    case BidirectionalMessages.bi_RebroadcastSource:
      return "bi_RebroadcastSource";
    case BidirectionalMessages.bi_GameEvent:
      return "bi_GameEvent";
    case BidirectionalMessages.bi_PredictionEvent:
      return "bi_PredictionEvent";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum BidirectionalMessages");
  }
}

export enum BidirectionalMessagesLowFrequency {
  bi_RelayInfo = 700,
  bi_RelayPacket = 701,
}

export function bidirectionalMessagesLowFrequencyFromJSON(object: any): BidirectionalMessagesLowFrequency {
  switch (object) {
    case 700:
    case "bi_RelayInfo":
      return BidirectionalMessagesLowFrequency.bi_RelayInfo;
    case 701:
    case "bi_RelayPacket":
      return BidirectionalMessagesLowFrequency.bi_RelayPacket;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum BidirectionalMessagesLowFrequency");
  }
}

export function bidirectionalMessagesLowFrequencyToJSON(object: BidirectionalMessagesLowFrequency): string {
  switch (object) {
    case BidirectionalMessagesLowFrequency.bi_RelayInfo:
      return "bi_RelayInfo";
    case BidirectionalMessagesLowFrequency.bi_RelayPacket:
      return "bi_RelayPacket";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum BidirectionalMessagesLowFrequency");
  }
}

export enum ReplayEventTypeT {
  REPLAY_EVENT_CANCEL = 0,
  REPLAY_EVENT_DEATH = 1,
  REPLAY_EVENT_GENERIC = 2,
  REPLAY_EVENT_STUCK_NEED_FULL_UPDATE = 3,
  REPLAY_EVENT_VICTORY = 4,
}

export function replayEventTypeTFromJSON(object: any): ReplayEventTypeT {
  switch (object) {
    case 0:
    case "REPLAY_EVENT_CANCEL":
      return ReplayEventTypeT.REPLAY_EVENT_CANCEL;
    case 1:
    case "REPLAY_EVENT_DEATH":
      return ReplayEventTypeT.REPLAY_EVENT_DEATH;
    case 2:
    case "REPLAY_EVENT_GENERIC":
      return ReplayEventTypeT.REPLAY_EVENT_GENERIC;
    case 3:
    case "REPLAY_EVENT_STUCK_NEED_FULL_UPDATE":
      return ReplayEventTypeT.REPLAY_EVENT_STUCK_NEED_FULL_UPDATE;
    case 4:
    case "REPLAY_EVENT_VICTORY":
      return ReplayEventTypeT.REPLAY_EVENT_VICTORY;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ReplayEventTypeT");
  }
}

export function replayEventTypeTToJSON(object: ReplayEventTypeT): string {
  switch (object) {
    case ReplayEventTypeT.REPLAY_EVENT_CANCEL:
      return "REPLAY_EVENT_CANCEL";
    case ReplayEventTypeT.REPLAY_EVENT_DEATH:
      return "REPLAY_EVENT_DEATH";
    case ReplayEventTypeT.REPLAY_EVENT_GENERIC:
      return "REPLAY_EVENT_GENERIC";
    case ReplayEventTypeT.REPLAY_EVENT_STUCK_NEED_FULL_UPDATE:
      return "REPLAY_EVENT_STUCK_NEED_FULL_UPDATE";
    case ReplayEventTypeT.REPLAY_EVENT_VICTORY:
      return "REPLAY_EVENT_VICTORY";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ReplayEventTypeT");
  }
}

export interface CCLCMsgClientInfo {
  sendTableCrc?: number | undefined;
  serverCount?: number | undefined;
  isHltv?: boolean | undefined;
  friendsId?: number | undefined;
  friendsName?: string | undefined;
}

export interface CCLCMsgMove {
  data?: Buffer | undefined;
  lastCommandNumber?: number | undefined;
}

export interface CMsgVoiceAudio {
  format?: VoiceDataFormatT | undefined;
  voiceData?: Buffer | undefined;
  sequenceBytes?: number | undefined;
  sectionNumber?: number | undefined;
  sampleRate?: number | undefined;
  uncompressedSampleOffset?: number | undefined;
  numPackets?: number | undefined;
  packetOffsets: number[];
  voiceLevel?: number | undefined;
}

export interface CCLCMsgVoiceData {
  audio?: CMsgVoiceAudio | undefined;
  xuid?: string | undefined;
  tick?: number | undefined;
}

export interface CCLCMsgBaselineAck {
  baselineTick?: number | undefined;
  baselineNr?: number | undefined;
}

export interface CCLCMsgListenEvents {
  eventMask: number[];
}

export interface CCLCMsgRespondCvarValue {
  cookie?: number | undefined;
  statusCode?: number | undefined;
  name?: string | undefined;
  value?: string | undefined;
}

export interface CCLCMsgFileCRCCheck {
  codePath?: number | undefined;
  path?: string | undefined;
  codeFilename?: number | undefined;
  filename?: string | undefined;
  crc?: number | undefined;
}

export interface CCLCMsgLoadingProgress {
  progress?: number | undefined;
}

export interface CCLCMsgSplitPlayerConnect {
  playername?: string | undefined;
}

export interface CCLCMsgSplitPlayerDisconnect {
  slot?: number | undefined;
}

export interface CCLCMsgServerStatus {
  simplified?: boolean | undefined;
}

export interface CCLCMsgRequestPause {
  pauseType?: RequestPauseT | undefined;
  pauseGroup?: number | undefined;
}

export interface CCLCMsgCmdKeyValues {
  data?: Buffer | undefined;
}

export interface CCLCMsgRconServerDetails {
  token?: Buffer | undefined;
}

export interface CMsgSource2SystemSpecs {
  cpuId?: string | undefined;
  cpuBrand?: string | undefined;
  cpuModel?: number | undefined;
  cpuNumPhysical?: number | undefined;
  ramPhysicalTotalMb?: number | undefined;
  gpuRendersystemDllName?: string | undefined;
  gpuVendorId?: number | undefined;
  gpuDriverName?: string | undefined;
  gpuDriverVersionHigh?: number | undefined;
  gpuDriverVersionLow?: number | undefined;
  gpuDxSupportLevel?: number | undefined;
  gpuTextureMemorySizeMb?: number | undefined;
}

export interface CMsgSource2VProfLiteReportItem {
  name?: string | undefined;
  activeSamples?: number | undefined;
  activeSamples1secmax?: number | undefined;
  usecMax?: number | undefined;
  usecAvgActive?: number | undefined;
  usecP50Active?: number | undefined;
  usecP99Active?: number | undefined;
  usecAvgAll?: number | undefined;
  usecP50All?: number | undefined;
  usecP99All?: number | undefined;
  usec1secmaxAvgActive?: number | undefined;
  usec1secmaxP50Active?: number | undefined;
  usec1secmaxP95Active?: number | undefined;
  usec1secmaxP99Active?: number | undefined;
  usec1secmaxAvgAll?: number | undefined;
  usec1secmaxP50All?: number | undefined;
  usec1secmaxP95All?: number | undefined;
  usec1secmaxP99All?: number | undefined;
}

export interface CMsgSource2VProfLiteReport {
  total?: CMsgSource2VProfLiteReportItem | undefined;
  items: CMsgSource2VProfLiteReportItem[];
  discardedFrames?: number | undefined;
}

export interface CMsgSource2NetworkFlowQuality {
  duration?: number | undefined;
  bytesTotal?: string | undefined;
  bytesTotalReliable?: string | undefined;
  bytesTotalVoice?: string | undefined;
  bytesSecP95?: number | undefined;
  bytesSecP99?: number | undefined;
  enginemsgsTotal?: number | undefined;
  enginemsgsSecP95?: number | undefined;
  enginemsgsSecP99?: number | undefined;
  ticksTotal?: number | undefined;
  ticksGood?: number | undefined;
  ticksGoodAlmostLate?: number | undefined;
  ticksFixedDropped?: number | undefined;
  ticksFixedLate?: number | undefined;
  ticksBadDropped?: number | undefined;
  ticksBadLate?: number | undefined;
  ticksBadOther?: number | undefined;
  tickMissrateSamplesTotal?: number | undefined;
  tickMissrateSamplesPerfect?: number | undefined;
  tickMissrateSamplesPerfectnet?: number | undefined;
  tickMissratenetP75X10?: number | undefined;
  tickMissratenetP95X10?: number | undefined;
  tickMissratenetP99X10?: number | undefined;
  recvmarginP1?: number | undefined;
  recvmarginP5?: number | undefined;
  recvmarginP25?: number | undefined;
  recvmarginP50?: number | undefined;
  recvmarginP75?: number | undefined;
  recvmarginP95?: number | undefined;
}

export interface CCLCMsgDiagnostic {
  systemSpecs?: CMsgSource2SystemSpecs | undefined;
  vprofReport?: CMsgSource2VProfLiteReport | undefined;
}

export interface CSource2MetricsMatchPerfSummaryNotification {
  appid?: number | undefined;
  gameMode?: string | undefined;
  serverBuildId?: number | undefined;
  serverProfile?: CMsgSource2VProfLiteReport | undefined;
  clients: CSource2MetricsMatchPerfSummaryNotification_Client[];
  map?: string | undefined;
}

export interface CSource2MetricsMatchPerfSummaryNotification_Client {
  systemSpecs?: CMsgSource2SystemSpecs | undefined;
  profile?: CMsgSource2VProfLiteReport | undefined;
  buildId?: number | undefined;
  steamid?: string | undefined;
}

export interface CSVCMsgServerInfo {
  protocol?: number | undefined;
  serverCount?: number | undefined;
  isDedicated?: boolean | undefined;
  isHltv?: boolean | undefined;
  cOs?: number | undefined;
  maxClients?: number | undefined;
  maxClasses?: number | undefined;
  playerSlot?: number | undefined;
  tickInterval?: number | undefined;
  gameDir?: string | undefined;
  mapName?: string | undefined;
  skyName?: string | undefined;
  hostName?: string | undefined;
  addonName?: string | undefined;
  gameSessionConfig?: CSVCMsgGameSessionConfiguration | undefined;
  gameSessionManifest?: Buffer | undefined;
}

export interface CSVCMsgClassInfo {
  createOnClient?: boolean | undefined;
  classes: CSVCMsgClassInfo_classT[];
}

export interface CSVCMsgClassInfo_classT {
  classId?: number | undefined;
  className?: string | undefined;
}

export interface CSVCMsgSetPause {
  paused?: boolean | undefined;
}

export interface CSVCMsgVoiceInit {
  quality?: number | undefined;
  codec?: string | undefined;
  version?: number | undefined;
}

export interface CSVCMsgPrint {
  text?: string | undefined;
}

export interface CSVCMsgSounds {
  reliableSound?: boolean | undefined;
  sounds: CSVCMsgSounds_sounddataT[];
}

export interface CSVCMsgSounds_sounddataT {
  originX?: number | undefined;
  originY?: number | undefined;
  originZ?: number | undefined;
  volume?: number | undefined;
  delayValue?: number | undefined;
  sequenceNumber?: number | undefined;
  entityIndex?: number | undefined;
  channel?: number | undefined;
  pitch?: number | undefined;
  flags?: number | undefined;
  soundNum?: number | undefined;
  soundNumHandle?: number | undefined;
  speakerEntity?: number | undefined;
  randomSeed?: number | undefined;
  soundLevel?: number | undefined;
  isSentence?: boolean | undefined;
  isAmbient?: boolean | undefined;
  guid?: number | undefined;
  soundResourceId?: string | undefined;
}

export interface CSVCMsgPrefetch {
  soundIndex?: number | undefined;
  resourceType?: PrefetchType | undefined;
}

export interface CSVCMsgSetView {
  entityIndex?: number | undefined;
  slot?: number | undefined;
}

export interface CSVCMsgFixAngle {
  relative?: boolean | undefined;
  angle?: CMsgQAngle | undefined;
}

export interface CSVCMsgCrosshairAngle {
  angle?: CMsgQAngle | undefined;
}

export interface CSVCMsgBSPDecal {
  pos?: CMsgVector | undefined;
  decalTextureIndex?: number | undefined;
  entityIndex?: number | undefined;
  modelIndex?: number | undefined;
  lowPriority?: boolean | undefined;
}

export interface CSVCMsgSplitScreen {
  type?: ESplitScreenMessageType | undefined;
  slot?: number | undefined;
  playerIndex?: number | undefined;
}

export interface CSVCMsgGetCvarValue {
  cookie?: number | undefined;
  cvarName?: string | undefined;
}

export interface CSVCMsgMenu {
  dialogType?: number | undefined;
  menuKeyValues?: Buffer | undefined;
}

export interface CSVCMsgUserMessage {
  msgType?: number | undefined;
  msgData?: Buffer | undefined;
  passthrough?: number | undefined;
}

export interface CSVCMsgSendTable {
  isEnd?: boolean | undefined;
  netTableName?: string | undefined;
  needsDecoder?: boolean | undefined;
  props: CSVCMsgSendTable_sendpropT[];
}

export interface CSVCMsgSendTable_sendpropT {
  type?: number | undefined;
  varName?: string | undefined;
  flags?: number | undefined;
  priority?: number | undefined;
  dtName?: string | undefined;
  numElements?: number | undefined;
  lowValue?: number | undefined;
  highValue?: number | undefined;
  numBits?: number | undefined;
}

export interface CSVCMsgGameEventList {
  descriptors: CSVCMsgGameEventList_descriptorT[];
}

export interface CSVCMsgGameEventList_keyT {
  type?: number | undefined;
  name?: string | undefined;
}

export interface CSVCMsgGameEventList_descriptorT {
  eventid?: number | undefined;
  name?: string | undefined;
  keys: CSVCMsgGameEventList_keyT[];
}

export interface CSVCMsgPacketEntities {
  maxEntries?: number | undefined;
  updatedEntries?: number | undefined;
  legacyIsDelta?: boolean | undefined;
  updateBaseline?: boolean | undefined;
  baseline?: number | undefined;
  deltaFrom?: number | undefined;
  entityData?: Buffer | undefined;
  pendingFullFrame?: boolean | undefined;
  activeSpawngroupHandle?: number | undefined;
  maxSpawngroupCreationsequence?: number | undefined;
  lastCmdNumberExecuted?: number | undefined;
  lastCmdNumberRecvDelta?: number | undefined;
  serverTick?: number | undefined;
  serializedEntities?: Buffer | undefined;
  alternateBaselines: CSVCMsgPacketEntities_alternateBaselineT[];
  hasPvsVisBitsDeprecated?: number | undefined;
  cmdRecvStatus: number[];
  nonTransmittedEntities?: CSVCMsgPacketEntities_nonTransmittedEntitiesT | undefined;
  cqStarvedCommandTicks?: number | undefined;
  cqDiscardedCommandTicks?: number | undefined;
  devPadding?: Buffer | undefined;
}

export interface CSVCMsgPacketEntities_alternateBaselineT {
  entityIndex?: number | undefined;
  baselineIndex?: number | undefined;
}

export interface CSVCMsgPacketEntities_nonTransmittedEntitiesT {
  headerCount?: number | undefined;
  data?: Buffer | undefined;
}

export interface CSVCMsgTempEntities {
  reliable?: boolean | undefined;
  numEntries?: number | undefined;
  entityData?: Buffer | undefined;
}

export interface CSVCMsgCreateStringTable {
  name?: string | undefined;
  numEntries?: number | undefined;
  userDataFixedSize?: boolean | undefined;
  userDataSize?: number | undefined;
  userDataSizeBits?: number | undefined;
  flags?: number | undefined;
  stringData?: Buffer | undefined;
  uncompressedSize?: number | undefined;
  dataCompressed?: boolean | undefined;
  usingVarintBitcounts?: boolean | undefined;
}

export interface CSVCMsgUpdateStringTable {
  tableId?: number | undefined;
  numChangedEntries?: number | undefined;
  stringData?: Buffer | undefined;
}

export interface CSVCMsgVoiceData {
  audio?: CMsgVoiceAudio | undefined;
  client?: number | undefined;
  proximity?: boolean | undefined;
  xuid?: string | undefined;
  audibleMask?: number | undefined;
  tick?: number | undefined;
  passthrough?: number | undefined;
}

export interface CSVCMsgPacketReliable {
  tick?: number | undefined;
  messagessize?: number | undefined;
  state?: boolean | undefined;
}

export interface CSVCMsgFullFrameSplit {
  tick?: number | undefined;
  section?: number | undefined;
  total?: number | undefined;
  data?: Buffer | undefined;
}

export interface CSVCMsgHLTVStatus {
  master?: string | undefined;
  clients?: number | undefined;
  slots?: number | undefined;
  proxies?: number | undefined;
}

export interface CSVCMsgServerSteamID {
  steamId?: string | undefined;
}

export interface CSVCMsgCmdKeyValues {
  data?: Buffer | undefined;
}

export interface CSVCMsgRconServerDetails {
  token?: Buffer | undefined;
  details?: string | undefined;
}

export interface CMsgIPCAddress {
  computerGuid?: string | undefined;
  processId?: number | undefined;
}

export interface CMsgServerPeer {
  playerSlot?: number | undefined;
  steamid?: string | undefined;
  ipc?: CMsgIPCAddress | undefined;
  theyHearYou?: boolean | undefined;
  youHearThem?: boolean | undefined;
  isListenserverHost?: boolean | undefined;
}

export interface CSVCMsgPeerList {
  peer: CMsgServerPeer[];
}

export interface CSVCMsgClearAllStringTables {
  mapname?: string | undefined;
  createTablesSkipped?: boolean | undefined;
}

export interface ProtoFlattenedSerializerFieldT {
  varTypeSym?: number | undefined;
  varNameSym?: number | undefined;
  bitCount?: number | undefined;
  lowValue?: number | undefined;
  highValue?: number | undefined;
  encodeFlags?: number | undefined;
  fieldSerializerNameSym?: number | undefined;
  fieldSerializerVersion?: number | undefined;
  sendNodeSym?: number | undefined;
  varEncoderSym?: number | undefined;
  polymorphicTypes: ProtoFlattenedSerializerFieldT_polymorphicFieldT[];
  varSerializerSym?: number | undefined;
}

export interface ProtoFlattenedSerializerFieldT_polymorphicFieldT {
  polymorphicFieldSerializerNameSym?: number | undefined;
  polymorphicFieldSerializerVersion?: number | undefined;
}

export interface ProtoFlattenedSerializerT {
  serializerNameSym?: number | undefined;
  serializerVersion?: number | undefined;
  fieldsIndex: number[];
}

export interface CSVCMsgFlattenedSerializer {
  serializers: ProtoFlattenedSerializerT[];
  symbols: string[];
  fields: ProtoFlattenedSerializerFieldT[];
}

export interface CSVCMsgStopSound {
  guid?: number | undefined;
}

export interface CBidirMsgRebroadcastGameEvent {
  posttoserver?: boolean | undefined;
  buftype?: number | undefined;
  clientbitcount?: number | undefined;
  receivingclients?: string | undefined;
}

export interface CBidirMsgRebroadcastSource {
  eventsource?: number | undefined;
}

export interface CBidirMsgPredictionEvent {
  eventId: number;
  eventData: Buffer;
  syncType?: number | undefined;
  syncValUint32?: number | undefined;
}

export enum CBidirMsgPredictionEvent_ESyncType {
  ST_Tick = 0,
  ST_UserCmdNum = 1,
}

export function cBidirMsgPredictionEvent_ESyncTypeFromJSON(object: any): CBidirMsgPredictionEvent_ESyncType {
  switch (object) {
    case 0:
    case "ST_Tick":
      return CBidirMsgPredictionEvent_ESyncType.ST_Tick;
    case 1:
    case "ST_UserCmdNum":
      return CBidirMsgPredictionEvent_ESyncType.ST_UserCmdNum;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum CBidirMsgPredictionEvent_ESyncType");
  }
}

export function cBidirMsgPredictionEvent_ESyncTypeToJSON(object: CBidirMsgPredictionEvent_ESyncType): string {
  switch (object) {
    case CBidirMsgPredictionEvent_ESyncType.ST_Tick:
      return "ST_Tick";
    case CBidirMsgPredictionEvent_ESyncType.ST_UserCmdNum:
      return "ST_UserCmdNum";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum CBidirMsgPredictionEvent_ESyncType");
  }
}

export interface CMsgServerNetworkStats {
  dedicated?: boolean | undefined;
  cpuUsage?: number | undefined;
  memoryUsedMb?: number | undefined;
  memoryFreeMb?: number | undefined;
  uptime?: number | undefined;
  spawnCount?: number | undefined;
  numClients?: number | undefined;
  numBots?: number | undefined;
  numSpectators?: number | undefined;
  numTvRelays?: number | undefined;
  fps?: number | undefined;
  ports: CMsgServerNetworkStats_Port[];
  avgPingMs?: number | undefined;
  avgEngineLatencyOut?: number | undefined;
  avgPacketsOut?: number | undefined;
  avgPacketsIn?: number | undefined;
  avgLossOut?: number | undefined;
  avgLossIn?: number | undefined;
  avgDataOut?: number | undefined;
  avgDataIn?: number | undefined;
  totalDataIn?: string | undefined;
  totalPacketsIn?: string | undefined;
  totalDataOut?: string | undefined;
  totalPacketsOut?: string | undefined;
  players: CMsgServerNetworkStats_Player[];
}

export interface CMsgServerNetworkStats_Port {
  port?: number | undefined;
  name?: string | undefined;
}

export interface CMsgServerNetworkStats_Player {
  steamid?: string | undefined;
  remoteAddr?: string | undefined;
  pingAvgMs?: number | undefined;
  packetLossPct?: number | undefined;
  isBot?: boolean | undefined;
  lossIn?: number | undefined;
  lossOut?: number | undefined;
  engineLatencyMs?: number | undefined;
}

export interface CSVCMsgHltvReplay {
  delay?: number | undefined;
  primaryTarget?: number | undefined;
  replayStopAt?: number | undefined;
  replayStartAt?: number | undefined;
  replaySlowdownBegin?: number | undefined;
  replaySlowdownEnd?: number | undefined;
  replaySlowdownRate?: number | undefined;
  reason?: number | undefined;
}

export interface CCLCMsgHltvReplay {
  request?: number | undefined;
  slowdownLength?: number | undefined;
  slowdownRate?: number | undefined;
  primaryTarget?: number | undefined;
  eventTime?: number | undefined;
}

export interface CSVCMsgBroadcastCommand {
  cmd?: string | undefined;
}

export interface CCLCMsgHltvFixupOperatorTick {
  tick?: number | undefined;
  propsData?: Buffer | undefined;
  origin?: CMsgVector | undefined;
  eyeAngles?: CMsgQAngle | undefined;
  observerMode?: number | undefined;
  cameramanScoreboard?: boolean | undefined;
  observerTarget?: number | undefined;
  viewOffset?: CMsgVector | undefined;
}

export interface CSVCMsgHltvFixupOperatorStatus {
  mode?: number | undefined;
  overrideOperatorName?: string | undefined;
}

export interface CMsgServerUserCmd {
  data?: Buffer | undefined;
  cmdNumber?: number | undefined;
  playerSlot?: number | undefined;
  serverTickExecuted?: number | undefined;
  clientTick?: number | undefined;
}

export interface CSVCMsgUserCommands {
  commands: CMsgServerUserCmd[];
}

function createBaseCCLCMsgClientInfo(): CCLCMsgClientInfo {
  return { sendTableCrc: 0, serverCount: 0, isHltv: false, friendsId: 0, friendsName: "" };
}

export const CCLCMsgClientInfo = {
  encode(message: CCLCMsgClientInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sendTableCrc !== undefined && message.sendTableCrc !== 0) {
      writer.uint32(13).fixed32(message.sendTableCrc);
    }
    if (message.serverCount !== undefined && message.serverCount !== 0) {
      writer.uint32(16).uint32(message.serverCount);
    }
    if (message.isHltv !== undefined && message.isHltv !== false) {
      writer.uint32(24).bool(message.isHltv);
    }
    if (message.friendsId !== undefined && message.friendsId !== 0) {
      writer.uint32(40).uint32(message.friendsId);
    }
    if (message.friendsName !== undefined && message.friendsName !== "") {
      writer.uint32(50).string(message.friendsName);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CCLCMsgClientInfo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCCLCMsgClientInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.sendTableCrc = reader.fixed32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.serverCount = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.isHltv = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.friendsId = reader.uint32();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.friendsName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CCLCMsgClientInfo {
    return {
      sendTableCrc: isSet(object.sendTableCrc) ? globalThis.Number(object.sendTableCrc) : 0,
      serverCount: isSet(object.serverCount) ? globalThis.Number(object.serverCount) : 0,
      isHltv: isSet(object.isHltv) ? globalThis.Boolean(object.isHltv) : false,
      friendsId: isSet(object.friendsId) ? globalThis.Number(object.friendsId) : 0,
      friendsName: isSet(object.friendsName) ? globalThis.String(object.friendsName) : "",
    };
  },

  toJSON(message: CCLCMsgClientInfo): unknown {
    const obj: any = {};
    if (message.sendTableCrc !== undefined && message.sendTableCrc !== 0) {
      obj.sendTableCrc = Math.round(message.sendTableCrc);
    }
    if (message.serverCount !== undefined && message.serverCount !== 0) {
      obj.serverCount = Math.round(message.serverCount);
    }
    if (message.isHltv !== undefined && message.isHltv !== false) {
      obj.isHltv = message.isHltv;
    }
    if (message.friendsId !== undefined && message.friendsId !== 0) {
      obj.friendsId = Math.round(message.friendsId);
    }
    if (message.friendsName !== undefined && message.friendsName !== "") {
      obj.friendsName = message.friendsName;
    }
    return obj;
  },

  create(base?: DeepPartial<CCLCMsgClientInfo>): CCLCMsgClientInfo {
    return CCLCMsgClientInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CCLCMsgClientInfo>): CCLCMsgClientInfo {
    const message = createBaseCCLCMsgClientInfo();
    message.sendTableCrc = object.sendTableCrc ?? 0;
    message.serverCount = object.serverCount ?? 0;
    message.isHltv = object.isHltv ?? false;
    message.friendsId = object.friendsId ?? 0;
    message.friendsName = object.friendsName ?? "";
    return message;
  },
};

function createBaseCCLCMsgMove(): CCLCMsgMove {
  return { data: Buffer.alloc(0), lastCommandNumber: 0 };
}

export const CCLCMsgMove = {
  encode(message: CCLCMsgMove, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.data !== undefined && message.data.length !== 0) {
      writer.uint32(26).bytes(message.data);
    }
    if (message.lastCommandNumber !== undefined && message.lastCommandNumber !== 0) {
      writer.uint32(32).uint32(message.lastCommandNumber);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CCLCMsgMove {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCCLCMsgMove();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 26) {
            break;
          }

          message.data = reader.bytes() as Buffer;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.lastCommandNumber = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CCLCMsgMove {
    return {
      data: isSet(object.data) ? Buffer.from(bytesFromBase64(object.data)) : Buffer.alloc(0),
      lastCommandNumber: isSet(object.lastCommandNumber) ? globalThis.Number(object.lastCommandNumber) : 0,
    };
  },

  toJSON(message: CCLCMsgMove): unknown {
    const obj: any = {};
    if (message.data !== undefined && message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    if (message.lastCommandNumber !== undefined && message.lastCommandNumber !== 0) {
      obj.lastCommandNumber = Math.round(message.lastCommandNumber);
    }
    return obj;
  },

  create(base?: DeepPartial<CCLCMsgMove>): CCLCMsgMove {
    return CCLCMsgMove.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CCLCMsgMove>): CCLCMsgMove {
    const message = createBaseCCLCMsgMove();
    message.data = object.data ?? Buffer.alloc(0);
    message.lastCommandNumber = object.lastCommandNumber ?? 0;
    return message;
  },
};

function createBaseCMsgVoiceAudio(): CMsgVoiceAudio {
  return {
    format: 0,
    voiceData: Buffer.alloc(0),
    sequenceBytes: 0,
    sectionNumber: 0,
    sampleRate: 0,
    uncompressedSampleOffset: 0,
    numPackets: 0,
    packetOffsets: [],
    voiceLevel: 0,
  };
}

export const CMsgVoiceAudio = {
  encode(message: CMsgVoiceAudio, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.format !== undefined && message.format !== 0) {
      writer.uint32(8).int32(message.format);
    }
    if (message.voiceData !== undefined && message.voiceData.length !== 0) {
      writer.uint32(18).bytes(message.voiceData);
    }
    if (message.sequenceBytes !== undefined && message.sequenceBytes !== 0) {
      writer.uint32(24).int32(message.sequenceBytes);
    }
    if (message.sectionNumber !== undefined && message.sectionNumber !== 0) {
      writer.uint32(32).uint32(message.sectionNumber);
    }
    if (message.sampleRate !== undefined && message.sampleRate !== 0) {
      writer.uint32(40).uint32(message.sampleRate);
    }
    if (message.uncompressedSampleOffset !== undefined && message.uncompressedSampleOffset !== 0) {
      writer.uint32(48).uint32(message.uncompressedSampleOffset);
    }
    if (message.numPackets !== undefined && message.numPackets !== 0) {
      writer.uint32(56).uint32(message.numPackets);
    }
    writer.uint32(66).fork();
    for (const v of message.packetOffsets) {
      writer.uint32(v);
    }
    writer.ldelim();
    if (message.voiceLevel !== undefined && message.voiceLevel !== 0) {
      writer.uint32(77).float(message.voiceLevel);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgVoiceAudio {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgVoiceAudio();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.format = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.voiceData = reader.bytes() as Buffer;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.sequenceBytes = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.sectionNumber = reader.uint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.sampleRate = reader.uint32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.uncompressedSampleOffset = reader.uint32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.numPackets = reader.uint32();
          continue;
        case 8:
          if (tag === 64) {
            message.packetOffsets.push(reader.uint32());

            continue;
          }

          if (tag === 66) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.packetOffsets.push(reader.uint32());
            }

            continue;
          }

          break;
        case 9:
          if (tag !== 77) {
            break;
          }

          message.voiceLevel = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgVoiceAudio {
    return {
      format: isSet(object.format) ? voiceDataFormatTFromJSON(object.format) : 0,
      voiceData: isSet(object.voiceData) ? Buffer.from(bytesFromBase64(object.voiceData)) : Buffer.alloc(0),
      sequenceBytes: isSet(object.sequenceBytes) ? globalThis.Number(object.sequenceBytes) : 0,
      sectionNumber: isSet(object.sectionNumber) ? globalThis.Number(object.sectionNumber) : 0,
      sampleRate: isSet(object.sampleRate) ? globalThis.Number(object.sampleRate) : 0,
      uncompressedSampleOffset: isSet(object.uncompressedSampleOffset)
        ? globalThis.Number(object.uncompressedSampleOffset)
        : 0,
      numPackets: isSet(object.numPackets) ? globalThis.Number(object.numPackets) : 0,
      packetOffsets: globalThis.Array.isArray(object?.packetOffsets)
        ? object.packetOffsets.map((e: any) => globalThis.Number(e))
        : [],
      voiceLevel: isSet(object.voiceLevel) ? globalThis.Number(object.voiceLevel) : 0,
    };
  },

  toJSON(message: CMsgVoiceAudio): unknown {
    const obj: any = {};
    if (message.format !== undefined && message.format !== 0) {
      obj.format = voiceDataFormatTToJSON(message.format);
    }
    if (message.voiceData !== undefined && message.voiceData.length !== 0) {
      obj.voiceData = base64FromBytes(message.voiceData);
    }
    if (message.sequenceBytes !== undefined && message.sequenceBytes !== 0) {
      obj.sequenceBytes = Math.round(message.sequenceBytes);
    }
    if (message.sectionNumber !== undefined && message.sectionNumber !== 0) {
      obj.sectionNumber = Math.round(message.sectionNumber);
    }
    if (message.sampleRate !== undefined && message.sampleRate !== 0) {
      obj.sampleRate = Math.round(message.sampleRate);
    }
    if (message.uncompressedSampleOffset !== undefined && message.uncompressedSampleOffset !== 0) {
      obj.uncompressedSampleOffset = Math.round(message.uncompressedSampleOffset);
    }
    if (message.numPackets !== undefined && message.numPackets !== 0) {
      obj.numPackets = Math.round(message.numPackets);
    }
    if (message.packetOffsets?.length) {
      obj.packetOffsets = message.packetOffsets.map((e) => Math.round(e));
    }
    if (message.voiceLevel !== undefined && message.voiceLevel !== 0) {
      obj.voiceLevel = message.voiceLevel;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgVoiceAudio>): CMsgVoiceAudio {
    return CMsgVoiceAudio.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgVoiceAudio>): CMsgVoiceAudio {
    const message = createBaseCMsgVoiceAudio();
    message.format = object.format ?? 0;
    message.voiceData = object.voiceData ?? Buffer.alloc(0);
    message.sequenceBytes = object.sequenceBytes ?? 0;
    message.sectionNumber = object.sectionNumber ?? 0;
    message.sampleRate = object.sampleRate ?? 0;
    message.uncompressedSampleOffset = object.uncompressedSampleOffset ?? 0;
    message.numPackets = object.numPackets ?? 0;
    message.packetOffsets = object.packetOffsets?.map((e) => e) || [];
    message.voiceLevel = object.voiceLevel ?? 0;
    return message;
  },
};

function createBaseCCLCMsgVoiceData(): CCLCMsgVoiceData {
  return { audio: undefined, xuid: "0", tick: 0 };
}

export const CCLCMsgVoiceData = {
  encode(message: CCLCMsgVoiceData, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.audio !== undefined) {
      CMsgVoiceAudio.encode(message.audio, writer.uint32(10).fork()).ldelim();
    }
    if (message.xuid !== undefined && message.xuid !== "0") {
      writer.uint32(17).fixed64(message.xuid);
    }
    if (message.tick !== undefined && message.tick !== 0) {
      writer.uint32(24).uint32(message.tick);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CCLCMsgVoiceData {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCCLCMsgVoiceData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.audio = CMsgVoiceAudio.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.xuid = longToString(reader.fixed64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.tick = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CCLCMsgVoiceData {
    return {
      audio: isSet(object.audio) ? CMsgVoiceAudio.fromJSON(object.audio) : undefined,
      xuid: isSet(object.xuid) ? globalThis.String(object.xuid) : "0",
      tick: isSet(object.tick) ? globalThis.Number(object.tick) : 0,
    };
  },

  toJSON(message: CCLCMsgVoiceData): unknown {
    const obj: any = {};
    if (message.audio !== undefined) {
      obj.audio = CMsgVoiceAudio.toJSON(message.audio);
    }
    if (message.xuid !== undefined && message.xuid !== "0") {
      obj.xuid = message.xuid;
    }
    if (message.tick !== undefined && message.tick !== 0) {
      obj.tick = Math.round(message.tick);
    }
    return obj;
  },

  create(base?: DeepPartial<CCLCMsgVoiceData>): CCLCMsgVoiceData {
    return CCLCMsgVoiceData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CCLCMsgVoiceData>): CCLCMsgVoiceData {
    const message = createBaseCCLCMsgVoiceData();
    message.audio = (object.audio !== undefined && object.audio !== null)
      ? CMsgVoiceAudio.fromPartial(object.audio)
      : undefined;
    message.xuid = object.xuid ?? "0";
    message.tick = object.tick ?? 0;
    return message;
  },
};

function createBaseCCLCMsgBaselineAck(): CCLCMsgBaselineAck {
  return { baselineTick: 0, baselineNr: 0 };
}

export const CCLCMsgBaselineAck = {
  encode(message: CCLCMsgBaselineAck, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.baselineTick !== undefined && message.baselineTick !== 0) {
      writer.uint32(8).int32(message.baselineTick);
    }
    if (message.baselineNr !== undefined && message.baselineNr !== 0) {
      writer.uint32(16).int32(message.baselineNr);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CCLCMsgBaselineAck {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCCLCMsgBaselineAck();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.baselineTick = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.baselineNr = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CCLCMsgBaselineAck {
    return {
      baselineTick: isSet(object.baselineTick) ? globalThis.Number(object.baselineTick) : 0,
      baselineNr: isSet(object.baselineNr) ? globalThis.Number(object.baselineNr) : 0,
    };
  },

  toJSON(message: CCLCMsgBaselineAck): unknown {
    const obj: any = {};
    if (message.baselineTick !== undefined && message.baselineTick !== 0) {
      obj.baselineTick = Math.round(message.baselineTick);
    }
    if (message.baselineNr !== undefined && message.baselineNr !== 0) {
      obj.baselineNr = Math.round(message.baselineNr);
    }
    return obj;
  },

  create(base?: DeepPartial<CCLCMsgBaselineAck>): CCLCMsgBaselineAck {
    return CCLCMsgBaselineAck.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CCLCMsgBaselineAck>): CCLCMsgBaselineAck {
    const message = createBaseCCLCMsgBaselineAck();
    message.baselineTick = object.baselineTick ?? 0;
    message.baselineNr = object.baselineNr ?? 0;
    return message;
  },
};

function createBaseCCLCMsgListenEvents(): CCLCMsgListenEvents {
  return { eventMask: [] };
}

export const CCLCMsgListenEvents = {
  encode(message: CCLCMsgListenEvents, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.eventMask) {
      writer.fixed32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CCLCMsgListenEvents {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCCLCMsgListenEvents();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 13) {
            message.eventMask.push(reader.fixed32());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.eventMask.push(reader.fixed32());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CCLCMsgListenEvents {
    return {
      eventMask: globalThis.Array.isArray(object?.eventMask)
        ? object.eventMask.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: CCLCMsgListenEvents): unknown {
    const obj: any = {};
    if (message.eventMask?.length) {
      obj.eventMask = message.eventMask.map((e) => Math.round(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CCLCMsgListenEvents>): CCLCMsgListenEvents {
    return CCLCMsgListenEvents.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CCLCMsgListenEvents>): CCLCMsgListenEvents {
    const message = createBaseCCLCMsgListenEvents();
    message.eventMask = object.eventMask?.map((e) => e) || [];
    return message;
  },
};

function createBaseCCLCMsgRespondCvarValue(): CCLCMsgRespondCvarValue {
  return { cookie: 0, statusCode: 0, name: "", value: "" };
}

export const CCLCMsgRespondCvarValue = {
  encode(message: CCLCMsgRespondCvarValue, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.cookie !== undefined && message.cookie !== 0) {
      writer.uint32(8).int32(message.cookie);
    }
    if (message.statusCode !== undefined && message.statusCode !== 0) {
      writer.uint32(16).int32(message.statusCode);
    }
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.value !== undefined && message.value !== "") {
      writer.uint32(34).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CCLCMsgRespondCvarValue {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCCLCMsgRespondCvarValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.cookie = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.statusCode = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CCLCMsgRespondCvarValue {
    return {
      cookie: isSet(object.cookie) ? globalThis.Number(object.cookie) : 0,
      statusCode: isSet(object.statusCode) ? globalThis.Number(object.statusCode) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: CCLCMsgRespondCvarValue): unknown {
    const obj: any = {};
    if (message.cookie !== undefined && message.cookie !== 0) {
      obj.cookie = Math.round(message.cookie);
    }
    if (message.statusCode !== undefined && message.statusCode !== 0) {
      obj.statusCode = Math.round(message.statusCode);
    }
    if (message.name !== undefined && message.name !== "") {
      obj.name = message.name;
    }
    if (message.value !== undefined && message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<CCLCMsgRespondCvarValue>): CCLCMsgRespondCvarValue {
    return CCLCMsgRespondCvarValue.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CCLCMsgRespondCvarValue>): CCLCMsgRespondCvarValue {
    const message = createBaseCCLCMsgRespondCvarValue();
    message.cookie = object.cookie ?? 0;
    message.statusCode = object.statusCode ?? 0;
    message.name = object.name ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseCCLCMsgFileCRCCheck(): CCLCMsgFileCRCCheck {
  return { codePath: 0, path: "", codeFilename: 0, filename: "", crc: 0 };
}

export const CCLCMsgFileCRCCheck = {
  encode(message: CCLCMsgFileCRCCheck, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.codePath !== undefined && message.codePath !== 0) {
      writer.uint32(8).int32(message.codePath);
    }
    if (message.path !== undefined && message.path !== "") {
      writer.uint32(18).string(message.path);
    }
    if (message.codeFilename !== undefined && message.codeFilename !== 0) {
      writer.uint32(24).int32(message.codeFilename);
    }
    if (message.filename !== undefined && message.filename !== "") {
      writer.uint32(34).string(message.filename);
    }
    if (message.crc !== undefined && message.crc !== 0) {
      writer.uint32(45).fixed32(message.crc);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CCLCMsgFileCRCCheck {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCCLCMsgFileCRCCheck();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.codePath = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.path = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.codeFilename = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filename = reader.string();
          continue;
        case 5:
          if (tag !== 45) {
            break;
          }

          message.crc = reader.fixed32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CCLCMsgFileCRCCheck {
    return {
      codePath: isSet(object.codePath) ? globalThis.Number(object.codePath) : 0,
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      codeFilename: isSet(object.codeFilename) ? globalThis.Number(object.codeFilename) : 0,
      filename: isSet(object.filename) ? globalThis.String(object.filename) : "",
      crc: isSet(object.crc) ? globalThis.Number(object.crc) : 0,
    };
  },

  toJSON(message: CCLCMsgFileCRCCheck): unknown {
    const obj: any = {};
    if (message.codePath !== undefined && message.codePath !== 0) {
      obj.codePath = Math.round(message.codePath);
    }
    if (message.path !== undefined && message.path !== "") {
      obj.path = message.path;
    }
    if (message.codeFilename !== undefined && message.codeFilename !== 0) {
      obj.codeFilename = Math.round(message.codeFilename);
    }
    if (message.filename !== undefined && message.filename !== "") {
      obj.filename = message.filename;
    }
    if (message.crc !== undefined && message.crc !== 0) {
      obj.crc = Math.round(message.crc);
    }
    return obj;
  },

  create(base?: DeepPartial<CCLCMsgFileCRCCheck>): CCLCMsgFileCRCCheck {
    return CCLCMsgFileCRCCheck.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CCLCMsgFileCRCCheck>): CCLCMsgFileCRCCheck {
    const message = createBaseCCLCMsgFileCRCCheck();
    message.codePath = object.codePath ?? 0;
    message.path = object.path ?? "";
    message.codeFilename = object.codeFilename ?? 0;
    message.filename = object.filename ?? "";
    message.crc = object.crc ?? 0;
    return message;
  },
};

function createBaseCCLCMsgLoadingProgress(): CCLCMsgLoadingProgress {
  return { progress: 0 };
}

export const CCLCMsgLoadingProgress = {
  encode(message: CCLCMsgLoadingProgress, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.progress !== undefined && message.progress !== 0) {
      writer.uint32(8).int32(message.progress);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CCLCMsgLoadingProgress {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCCLCMsgLoadingProgress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.progress = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CCLCMsgLoadingProgress {
    return { progress: isSet(object.progress) ? globalThis.Number(object.progress) : 0 };
  },

  toJSON(message: CCLCMsgLoadingProgress): unknown {
    const obj: any = {};
    if (message.progress !== undefined && message.progress !== 0) {
      obj.progress = Math.round(message.progress);
    }
    return obj;
  },

  create(base?: DeepPartial<CCLCMsgLoadingProgress>): CCLCMsgLoadingProgress {
    return CCLCMsgLoadingProgress.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CCLCMsgLoadingProgress>): CCLCMsgLoadingProgress {
    const message = createBaseCCLCMsgLoadingProgress();
    message.progress = object.progress ?? 0;
    return message;
  },
};

function createBaseCCLCMsgSplitPlayerConnect(): CCLCMsgSplitPlayerConnect {
  return { playername: "" };
}

export const CCLCMsgSplitPlayerConnect = {
  encode(message: CCLCMsgSplitPlayerConnect, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.playername !== undefined && message.playername !== "") {
      writer.uint32(10).string(message.playername);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CCLCMsgSplitPlayerConnect {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCCLCMsgSplitPlayerConnect();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.playername = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CCLCMsgSplitPlayerConnect {
    return { playername: isSet(object.playername) ? globalThis.String(object.playername) : "" };
  },

  toJSON(message: CCLCMsgSplitPlayerConnect): unknown {
    const obj: any = {};
    if (message.playername !== undefined && message.playername !== "") {
      obj.playername = message.playername;
    }
    return obj;
  },

  create(base?: DeepPartial<CCLCMsgSplitPlayerConnect>): CCLCMsgSplitPlayerConnect {
    return CCLCMsgSplitPlayerConnect.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CCLCMsgSplitPlayerConnect>): CCLCMsgSplitPlayerConnect {
    const message = createBaseCCLCMsgSplitPlayerConnect();
    message.playername = object.playername ?? "";
    return message;
  },
};

function createBaseCCLCMsgSplitPlayerDisconnect(): CCLCMsgSplitPlayerDisconnect {
  return { slot: 0 };
}

export const CCLCMsgSplitPlayerDisconnect = {
  encode(message: CCLCMsgSplitPlayerDisconnect, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.slot !== undefined && message.slot !== 0) {
      writer.uint32(8).int32(message.slot);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CCLCMsgSplitPlayerDisconnect {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCCLCMsgSplitPlayerDisconnect();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.slot = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CCLCMsgSplitPlayerDisconnect {
    return { slot: isSet(object.slot) ? globalThis.Number(object.slot) : 0 };
  },

  toJSON(message: CCLCMsgSplitPlayerDisconnect): unknown {
    const obj: any = {};
    if (message.slot !== undefined && message.slot !== 0) {
      obj.slot = Math.round(message.slot);
    }
    return obj;
  },

  create(base?: DeepPartial<CCLCMsgSplitPlayerDisconnect>): CCLCMsgSplitPlayerDisconnect {
    return CCLCMsgSplitPlayerDisconnect.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CCLCMsgSplitPlayerDisconnect>): CCLCMsgSplitPlayerDisconnect {
    const message = createBaseCCLCMsgSplitPlayerDisconnect();
    message.slot = object.slot ?? 0;
    return message;
  },
};

function createBaseCCLCMsgServerStatus(): CCLCMsgServerStatus {
  return { simplified: false };
}

export const CCLCMsgServerStatus = {
  encode(message: CCLCMsgServerStatus, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.simplified !== undefined && message.simplified !== false) {
      writer.uint32(8).bool(message.simplified);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CCLCMsgServerStatus {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCCLCMsgServerStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.simplified = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CCLCMsgServerStatus {
    return { simplified: isSet(object.simplified) ? globalThis.Boolean(object.simplified) : false };
  },

  toJSON(message: CCLCMsgServerStatus): unknown {
    const obj: any = {};
    if (message.simplified !== undefined && message.simplified !== false) {
      obj.simplified = message.simplified;
    }
    return obj;
  },

  create(base?: DeepPartial<CCLCMsgServerStatus>): CCLCMsgServerStatus {
    return CCLCMsgServerStatus.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CCLCMsgServerStatus>): CCLCMsgServerStatus {
    const message = createBaseCCLCMsgServerStatus();
    message.simplified = object.simplified ?? false;
    return message;
  },
};

function createBaseCCLCMsgRequestPause(): CCLCMsgRequestPause {
  return { pauseType: 0, pauseGroup: 0 };
}

export const CCLCMsgRequestPause = {
  encode(message: CCLCMsgRequestPause, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.pauseType !== undefined && message.pauseType !== 0) {
      writer.uint32(8).int32(message.pauseType);
    }
    if (message.pauseGroup !== undefined && message.pauseGroup !== 0) {
      writer.uint32(16).int32(message.pauseGroup);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CCLCMsgRequestPause {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCCLCMsgRequestPause();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.pauseType = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pauseGroup = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CCLCMsgRequestPause {
    return {
      pauseType: isSet(object.pauseType) ? requestPauseTFromJSON(object.pauseType) : 0,
      pauseGroup: isSet(object.pauseGroup) ? globalThis.Number(object.pauseGroup) : 0,
    };
  },

  toJSON(message: CCLCMsgRequestPause): unknown {
    const obj: any = {};
    if (message.pauseType !== undefined && message.pauseType !== 0) {
      obj.pauseType = requestPauseTToJSON(message.pauseType);
    }
    if (message.pauseGroup !== undefined && message.pauseGroup !== 0) {
      obj.pauseGroup = Math.round(message.pauseGroup);
    }
    return obj;
  },

  create(base?: DeepPartial<CCLCMsgRequestPause>): CCLCMsgRequestPause {
    return CCLCMsgRequestPause.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CCLCMsgRequestPause>): CCLCMsgRequestPause {
    const message = createBaseCCLCMsgRequestPause();
    message.pauseType = object.pauseType ?? 0;
    message.pauseGroup = object.pauseGroup ?? 0;
    return message;
  },
};

function createBaseCCLCMsgCmdKeyValues(): CCLCMsgCmdKeyValues {
  return { data: Buffer.alloc(0) };
}

export const CCLCMsgCmdKeyValues = {
  encode(message: CCLCMsgCmdKeyValues, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.data !== undefined && message.data.length !== 0) {
      writer.uint32(10).bytes(message.data);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CCLCMsgCmdKeyValues {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCCLCMsgCmdKeyValues();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.data = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CCLCMsgCmdKeyValues {
    return { data: isSet(object.data) ? Buffer.from(bytesFromBase64(object.data)) : Buffer.alloc(0) };
  },

  toJSON(message: CCLCMsgCmdKeyValues): unknown {
    const obj: any = {};
    if (message.data !== undefined && message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    return obj;
  },

  create(base?: DeepPartial<CCLCMsgCmdKeyValues>): CCLCMsgCmdKeyValues {
    return CCLCMsgCmdKeyValues.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CCLCMsgCmdKeyValues>): CCLCMsgCmdKeyValues {
    const message = createBaseCCLCMsgCmdKeyValues();
    message.data = object.data ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseCCLCMsgRconServerDetails(): CCLCMsgRconServerDetails {
  return { token: Buffer.alloc(0) };
}

export const CCLCMsgRconServerDetails = {
  encode(message: CCLCMsgRconServerDetails, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.token !== undefined && message.token.length !== 0) {
      writer.uint32(10).bytes(message.token);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CCLCMsgRconServerDetails {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCCLCMsgRconServerDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.token = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CCLCMsgRconServerDetails {
    return { token: isSet(object.token) ? Buffer.from(bytesFromBase64(object.token)) : Buffer.alloc(0) };
  },

  toJSON(message: CCLCMsgRconServerDetails): unknown {
    const obj: any = {};
    if (message.token !== undefined && message.token.length !== 0) {
      obj.token = base64FromBytes(message.token);
    }
    return obj;
  },

  create(base?: DeepPartial<CCLCMsgRconServerDetails>): CCLCMsgRconServerDetails {
    return CCLCMsgRconServerDetails.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CCLCMsgRconServerDetails>): CCLCMsgRconServerDetails {
    const message = createBaseCCLCMsgRconServerDetails();
    message.token = object.token ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseCMsgSource2SystemSpecs(): CMsgSource2SystemSpecs {
  return {
    cpuId: "",
    cpuBrand: "",
    cpuModel: 0,
    cpuNumPhysical: 0,
    ramPhysicalTotalMb: 0,
    gpuRendersystemDllName: "",
    gpuVendorId: 0,
    gpuDriverName: "",
    gpuDriverVersionHigh: 0,
    gpuDriverVersionLow: 0,
    gpuDxSupportLevel: 0,
    gpuTextureMemorySizeMb: 0,
  };
}

export const CMsgSource2SystemSpecs = {
  encode(message: CMsgSource2SystemSpecs, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.cpuId !== undefined && message.cpuId !== "") {
      writer.uint32(10).string(message.cpuId);
    }
    if (message.cpuBrand !== undefined && message.cpuBrand !== "") {
      writer.uint32(18).string(message.cpuBrand);
    }
    if (message.cpuModel !== undefined && message.cpuModel !== 0) {
      writer.uint32(24).uint32(message.cpuModel);
    }
    if (message.cpuNumPhysical !== undefined && message.cpuNumPhysical !== 0) {
      writer.uint32(32).uint32(message.cpuNumPhysical);
    }
    if (message.ramPhysicalTotalMb !== undefined && message.ramPhysicalTotalMb !== 0) {
      writer.uint32(168).uint32(message.ramPhysicalTotalMb);
    }
    if (message.gpuRendersystemDllName !== undefined && message.gpuRendersystemDllName !== "") {
      writer.uint32(330).string(message.gpuRendersystemDllName);
    }
    if (message.gpuVendorId !== undefined && message.gpuVendorId !== 0) {
      writer.uint32(336).uint32(message.gpuVendorId);
    }
    if (message.gpuDriverName !== undefined && message.gpuDriverName !== "") {
      writer.uint32(346).string(message.gpuDriverName);
    }
    if (message.gpuDriverVersionHigh !== undefined && message.gpuDriverVersionHigh !== 0) {
      writer.uint32(352).uint32(message.gpuDriverVersionHigh);
    }
    if (message.gpuDriverVersionLow !== undefined && message.gpuDriverVersionLow !== 0) {
      writer.uint32(360).uint32(message.gpuDriverVersionLow);
    }
    if (message.gpuDxSupportLevel !== undefined && message.gpuDxSupportLevel !== 0) {
      writer.uint32(368).uint32(message.gpuDxSupportLevel);
    }
    if (message.gpuTextureMemorySizeMb !== undefined && message.gpuTextureMemorySizeMb !== 0) {
      writer.uint32(376).uint32(message.gpuTextureMemorySizeMb);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSource2SystemSpecs {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSource2SystemSpecs();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.cpuId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.cpuBrand = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.cpuModel = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.cpuNumPhysical = reader.uint32();
          continue;
        case 21:
          if (tag !== 168) {
            break;
          }

          message.ramPhysicalTotalMb = reader.uint32();
          continue;
        case 41:
          if (tag !== 330) {
            break;
          }

          message.gpuRendersystemDllName = reader.string();
          continue;
        case 42:
          if (tag !== 336) {
            break;
          }

          message.gpuVendorId = reader.uint32();
          continue;
        case 43:
          if (tag !== 346) {
            break;
          }

          message.gpuDriverName = reader.string();
          continue;
        case 44:
          if (tag !== 352) {
            break;
          }

          message.gpuDriverVersionHigh = reader.uint32();
          continue;
        case 45:
          if (tag !== 360) {
            break;
          }

          message.gpuDriverVersionLow = reader.uint32();
          continue;
        case 46:
          if (tag !== 368) {
            break;
          }

          message.gpuDxSupportLevel = reader.uint32();
          continue;
        case 47:
          if (tag !== 376) {
            break;
          }

          message.gpuTextureMemorySizeMb = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSource2SystemSpecs {
    return {
      cpuId: isSet(object.cpuId) ? globalThis.String(object.cpuId) : "",
      cpuBrand: isSet(object.cpuBrand) ? globalThis.String(object.cpuBrand) : "",
      cpuModel: isSet(object.cpuModel) ? globalThis.Number(object.cpuModel) : 0,
      cpuNumPhysical: isSet(object.cpuNumPhysical) ? globalThis.Number(object.cpuNumPhysical) : 0,
      ramPhysicalTotalMb: isSet(object.ramPhysicalTotalMb) ? globalThis.Number(object.ramPhysicalTotalMb) : 0,
      gpuRendersystemDllName: isSet(object.gpuRendersystemDllName)
        ? globalThis.String(object.gpuRendersystemDllName)
        : "",
      gpuVendorId: isSet(object.gpuVendorId) ? globalThis.Number(object.gpuVendorId) : 0,
      gpuDriverName: isSet(object.gpuDriverName) ? globalThis.String(object.gpuDriverName) : "",
      gpuDriverVersionHigh: isSet(object.gpuDriverVersionHigh) ? globalThis.Number(object.gpuDriverVersionHigh) : 0,
      gpuDriverVersionLow: isSet(object.gpuDriverVersionLow) ? globalThis.Number(object.gpuDriverVersionLow) : 0,
      gpuDxSupportLevel: isSet(object.gpuDxSupportLevel) ? globalThis.Number(object.gpuDxSupportLevel) : 0,
      gpuTextureMemorySizeMb: isSet(object.gpuTextureMemorySizeMb)
        ? globalThis.Number(object.gpuTextureMemorySizeMb)
        : 0,
    };
  },

  toJSON(message: CMsgSource2SystemSpecs): unknown {
    const obj: any = {};
    if (message.cpuId !== undefined && message.cpuId !== "") {
      obj.cpuId = message.cpuId;
    }
    if (message.cpuBrand !== undefined && message.cpuBrand !== "") {
      obj.cpuBrand = message.cpuBrand;
    }
    if (message.cpuModel !== undefined && message.cpuModel !== 0) {
      obj.cpuModel = Math.round(message.cpuModel);
    }
    if (message.cpuNumPhysical !== undefined && message.cpuNumPhysical !== 0) {
      obj.cpuNumPhysical = Math.round(message.cpuNumPhysical);
    }
    if (message.ramPhysicalTotalMb !== undefined && message.ramPhysicalTotalMb !== 0) {
      obj.ramPhysicalTotalMb = Math.round(message.ramPhysicalTotalMb);
    }
    if (message.gpuRendersystemDllName !== undefined && message.gpuRendersystemDllName !== "") {
      obj.gpuRendersystemDllName = message.gpuRendersystemDllName;
    }
    if (message.gpuVendorId !== undefined && message.gpuVendorId !== 0) {
      obj.gpuVendorId = Math.round(message.gpuVendorId);
    }
    if (message.gpuDriverName !== undefined && message.gpuDriverName !== "") {
      obj.gpuDriverName = message.gpuDriverName;
    }
    if (message.gpuDriverVersionHigh !== undefined && message.gpuDriverVersionHigh !== 0) {
      obj.gpuDriverVersionHigh = Math.round(message.gpuDriverVersionHigh);
    }
    if (message.gpuDriverVersionLow !== undefined && message.gpuDriverVersionLow !== 0) {
      obj.gpuDriverVersionLow = Math.round(message.gpuDriverVersionLow);
    }
    if (message.gpuDxSupportLevel !== undefined && message.gpuDxSupportLevel !== 0) {
      obj.gpuDxSupportLevel = Math.round(message.gpuDxSupportLevel);
    }
    if (message.gpuTextureMemorySizeMb !== undefined && message.gpuTextureMemorySizeMb !== 0) {
      obj.gpuTextureMemorySizeMb = Math.round(message.gpuTextureMemorySizeMb);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSource2SystemSpecs>): CMsgSource2SystemSpecs {
    return CMsgSource2SystemSpecs.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSource2SystemSpecs>): CMsgSource2SystemSpecs {
    const message = createBaseCMsgSource2SystemSpecs();
    message.cpuId = object.cpuId ?? "";
    message.cpuBrand = object.cpuBrand ?? "";
    message.cpuModel = object.cpuModel ?? 0;
    message.cpuNumPhysical = object.cpuNumPhysical ?? 0;
    message.ramPhysicalTotalMb = object.ramPhysicalTotalMb ?? 0;
    message.gpuRendersystemDllName = object.gpuRendersystemDllName ?? "";
    message.gpuVendorId = object.gpuVendorId ?? 0;
    message.gpuDriverName = object.gpuDriverName ?? "";
    message.gpuDriverVersionHigh = object.gpuDriverVersionHigh ?? 0;
    message.gpuDriverVersionLow = object.gpuDriverVersionLow ?? 0;
    message.gpuDxSupportLevel = object.gpuDxSupportLevel ?? 0;
    message.gpuTextureMemorySizeMb = object.gpuTextureMemorySizeMb ?? 0;
    return message;
  },
};

function createBaseCMsgSource2VProfLiteReportItem(): CMsgSource2VProfLiteReportItem {
  return {
    name: "",
    activeSamples: 0,
    activeSamples1secmax: 0,
    usecMax: 0,
    usecAvgActive: 0,
    usecP50Active: 0,
    usecP99Active: 0,
    usecAvgAll: 0,
    usecP50All: 0,
    usecP99All: 0,
    usec1secmaxAvgActive: 0,
    usec1secmaxP50Active: 0,
    usec1secmaxP95Active: 0,
    usec1secmaxP99Active: 0,
    usec1secmaxAvgAll: 0,
    usec1secmaxP50All: 0,
    usec1secmaxP95All: 0,
    usec1secmaxP99All: 0,
  };
}

export const CMsgSource2VProfLiteReportItem = {
  encode(message: CMsgSource2VProfLiteReportItem, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.activeSamples !== undefined && message.activeSamples !== 0) {
      writer.uint32(16).uint32(message.activeSamples);
    }
    if (message.activeSamples1secmax !== undefined && message.activeSamples1secmax !== 0) {
      writer.uint32(32).uint32(message.activeSamples1secmax);
    }
    if (message.usecMax !== undefined && message.usecMax !== 0) {
      writer.uint32(24).uint32(message.usecMax);
    }
    if (message.usecAvgActive !== undefined && message.usecAvgActive !== 0) {
      writer.uint32(88).uint32(message.usecAvgActive);
    }
    if (message.usecP50Active !== undefined && message.usecP50Active !== 0) {
      writer.uint32(96).uint32(message.usecP50Active);
    }
    if (message.usecP99Active !== undefined && message.usecP99Active !== 0) {
      writer.uint32(104).uint32(message.usecP99Active);
    }
    if (message.usecAvgAll !== undefined && message.usecAvgAll !== 0) {
      writer.uint32(168).uint32(message.usecAvgAll);
    }
    if (message.usecP50All !== undefined && message.usecP50All !== 0) {
      writer.uint32(176).uint32(message.usecP50All);
    }
    if (message.usecP99All !== undefined && message.usecP99All !== 0) {
      writer.uint32(184).uint32(message.usecP99All);
    }
    if (message.usec1secmaxAvgActive !== undefined && message.usec1secmaxAvgActive !== 0) {
      writer.uint32(248).uint32(message.usec1secmaxAvgActive);
    }
    if (message.usec1secmaxP50Active !== undefined && message.usec1secmaxP50Active !== 0) {
      writer.uint32(256).uint32(message.usec1secmaxP50Active);
    }
    if (message.usec1secmaxP95Active !== undefined && message.usec1secmaxP95Active !== 0) {
      writer.uint32(264).uint32(message.usec1secmaxP95Active);
    }
    if (message.usec1secmaxP99Active !== undefined && message.usec1secmaxP99Active !== 0) {
      writer.uint32(272).uint32(message.usec1secmaxP99Active);
    }
    if (message.usec1secmaxAvgAll !== undefined && message.usec1secmaxAvgAll !== 0) {
      writer.uint32(328).uint32(message.usec1secmaxAvgAll);
    }
    if (message.usec1secmaxP50All !== undefined && message.usec1secmaxP50All !== 0) {
      writer.uint32(336).uint32(message.usec1secmaxP50All);
    }
    if (message.usec1secmaxP95All !== undefined && message.usec1secmaxP95All !== 0) {
      writer.uint32(344).uint32(message.usec1secmaxP95All);
    }
    if (message.usec1secmaxP99All !== undefined && message.usec1secmaxP99All !== 0) {
      writer.uint32(352).uint32(message.usec1secmaxP99All);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSource2VProfLiteReportItem {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSource2VProfLiteReportItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.activeSamples = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.activeSamples1secmax = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.usecMax = reader.uint32();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.usecAvgActive = reader.uint32();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.usecP50Active = reader.uint32();
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.usecP99Active = reader.uint32();
          continue;
        case 21:
          if (tag !== 168) {
            break;
          }

          message.usecAvgAll = reader.uint32();
          continue;
        case 22:
          if (tag !== 176) {
            break;
          }

          message.usecP50All = reader.uint32();
          continue;
        case 23:
          if (tag !== 184) {
            break;
          }

          message.usecP99All = reader.uint32();
          continue;
        case 31:
          if (tag !== 248) {
            break;
          }

          message.usec1secmaxAvgActive = reader.uint32();
          continue;
        case 32:
          if (tag !== 256) {
            break;
          }

          message.usec1secmaxP50Active = reader.uint32();
          continue;
        case 33:
          if (tag !== 264) {
            break;
          }

          message.usec1secmaxP95Active = reader.uint32();
          continue;
        case 34:
          if (tag !== 272) {
            break;
          }

          message.usec1secmaxP99Active = reader.uint32();
          continue;
        case 41:
          if (tag !== 328) {
            break;
          }

          message.usec1secmaxAvgAll = reader.uint32();
          continue;
        case 42:
          if (tag !== 336) {
            break;
          }

          message.usec1secmaxP50All = reader.uint32();
          continue;
        case 43:
          if (tag !== 344) {
            break;
          }

          message.usec1secmaxP95All = reader.uint32();
          continue;
        case 44:
          if (tag !== 352) {
            break;
          }

          message.usec1secmaxP99All = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSource2VProfLiteReportItem {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      activeSamples: isSet(object.activeSamples) ? globalThis.Number(object.activeSamples) : 0,
      activeSamples1secmax: isSet(object.activeSamples1secmax) ? globalThis.Number(object.activeSamples1secmax) : 0,
      usecMax: isSet(object.usecMax) ? globalThis.Number(object.usecMax) : 0,
      usecAvgActive: isSet(object.usecAvgActive) ? globalThis.Number(object.usecAvgActive) : 0,
      usecP50Active: isSet(object.usecP50Active) ? globalThis.Number(object.usecP50Active) : 0,
      usecP99Active: isSet(object.usecP99Active) ? globalThis.Number(object.usecP99Active) : 0,
      usecAvgAll: isSet(object.usecAvgAll) ? globalThis.Number(object.usecAvgAll) : 0,
      usecP50All: isSet(object.usecP50All) ? globalThis.Number(object.usecP50All) : 0,
      usecP99All: isSet(object.usecP99All) ? globalThis.Number(object.usecP99All) : 0,
      usec1secmaxAvgActive: isSet(object.usec1secmaxAvgActive) ? globalThis.Number(object.usec1secmaxAvgActive) : 0,
      usec1secmaxP50Active: isSet(object.usec1secmaxP50Active) ? globalThis.Number(object.usec1secmaxP50Active) : 0,
      usec1secmaxP95Active: isSet(object.usec1secmaxP95Active) ? globalThis.Number(object.usec1secmaxP95Active) : 0,
      usec1secmaxP99Active: isSet(object.usec1secmaxP99Active) ? globalThis.Number(object.usec1secmaxP99Active) : 0,
      usec1secmaxAvgAll: isSet(object.usec1secmaxAvgAll) ? globalThis.Number(object.usec1secmaxAvgAll) : 0,
      usec1secmaxP50All: isSet(object.usec1secmaxP50All) ? globalThis.Number(object.usec1secmaxP50All) : 0,
      usec1secmaxP95All: isSet(object.usec1secmaxP95All) ? globalThis.Number(object.usec1secmaxP95All) : 0,
      usec1secmaxP99All: isSet(object.usec1secmaxP99All) ? globalThis.Number(object.usec1secmaxP99All) : 0,
    };
  },

  toJSON(message: CMsgSource2VProfLiteReportItem): unknown {
    const obj: any = {};
    if (message.name !== undefined && message.name !== "") {
      obj.name = message.name;
    }
    if (message.activeSamples !== undefined && message.activeSamples !== 0) {
      obj.activeSamples = Math.round(message.activeSamples);
    }
    if (message.activeSamples1secmax !== undefined && message.activeSamples1secmax !== 0) {
      obj.activeSamples1secmax = Math.round(message.activeSamples1secmax);
    }
    if (message.usecMax !== undefined && message.usecMax !== 0) {
      obj.usecMax = Math.round(message.usecMax);
    }
    if (message.usecAvgActive !== undefined && message.usecAvgActive !== 0) {
      obj.usecAvgActive = Math.round(message.usecAvgActive);
    }
    if (message.usecP50Active !== undefined && message.usecP50Active !== 0) {
      obj.usecP50Active = Math.round(message.usecP50Active);
    }
    if (message.usecP99Active !== undefined && message.usecP99Active !== 0) {
      obj.usecP99Active = Math.round(message.usecP99Active);
    }
    if (message.usecAvgAll !== undefined && message.usecAvgAll !== 0) {
      obj.usecAvgAll = Math.round(message.usecAvgAll);
    }
    if (message.usecP50All !== undefined && message.usecP50All !== 0) {
      obj.usecP50All = Math.round(message.usecP50All);
    }
    if (message.usecP99All !== undefined && message.usecP99All !== 0) {
      obj.usecP99All = Math.round(message.usecP99All);
    }
    if (message.usec1secmaxAvgActive !== undefined && message.usec1secmaxAvgActive !== 0) {
      obj.usec1secmaxAvgActive = Math.round(message.usec1secmaxAvgActive);
    }
    if (message.usec1secmaxP50Active !== undefined && message.usec1secmaxP50Active !== 0) {
      obj.usec1secmaxP50Active = Math.round(message.usec1secmaxP50Active);
    }
    if (message.usec1secmaxP95Active !== undefined && message.usec1secmaxP95Active !== 0) {
      obj.usec1secmaxP95Active = Math.round(message.usec1secmaxP95Active);
    }
    if (message.usec1secmaxP99Active !== undefined && message.usec1secmaxP99Active !== 0) {
      obj.usec1secmaxP99Active = Math.round(message.usec1secmaxP99Active);
    }
    if (message.usec1secmaxAvgAll !== undefined && message.usec1secmaxAvgAll !== 0) {
      obj.usec1secmaxAvgAll = Math.round(message.usec1secmaxAvgAll);
    }
    if (message.usec1secmaxP50All !== undefined && message.usec1secmaxP50All !== 0) {
      obj.usec1secmaxP50All = Math.round(message.usec1secmaxP50All);
    }
    if (message.usec1secmaxP95All !== undefined && message.usec1secmaxP95All !== 0) {
      obj.usec1secmaxP95All = Math.round(message.usec1secmaxP95All);
    }
    if (message.usec1secmaxP99All !== undefined && message.usec1secmaxP99All !== 0) {
      obj.usec1secmaxP99All = Math.round(message.usec1secmaxP99All);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSource2VProfLiteReportItem>): CMsgSource2VProfLiteReportItem {
    return CMsgSource2VProfLiteReportItem.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSource2VProfLiteReportItem>): CMsgSource2VProfLiteReportItem {
    const message = createBaseCMsgSource2VProfLiteReportItem();
    message.name = object.name ?? "";
    message.activeSamples = object.activeSamples ?? 0;
    message.activeSamples1secmax = object.activeSamples1secmax ?? 0;
    message.usecMax = object.usecMax ?? 0;
    message.usecAvgActive = object.usecAvgActive ?? 0;
    message.usecP50Active = object.usecP50Active ?? 0;
    message.usecP99Active = object.usecP99Active ?? 0;
    message.usecAvgAll = object.usecAvgAll ?? 0;
    message.usecP50All = object.usecP50All ?? 0;
    message.usecP99All = object.usecP99All ?? 0;
    message.usec1secmaxAvgActive = object.usec1secmaxAvgActive ?? 0;
    message.usec1secmaxP50Active = object.usec1secmaxP50Active ?? 0;
    message.usec1secmaxP95Active = object.usec1secmaxP95Active ?? 0;
    message.usec1secmaxP99Active = object.usec1secmaxP99Active ?? 0;
    message.usec1secmaxAvgAll = object.usec1secmaxAvgAll ?? 0;
    message.usec1secmaxP50All = object.usec1secmaxP50All ?? 0;
    message.usec1secmaxP95All = object.usec1secmaxP95All ?? 0;
    message.usec1secmaxP99All = object.usec1secmaxP99All ?? 0;
    return message;
  },
};

function createBaseCMsgSource2VProfLiteReport(): CMsgSource2VProfLiteReport {
  return { total: undefined, items: [], discardedFrames: 0 };
}

export const CMsgSource2VProfLiteReport = {
  encode(message: CMsgSource2VProfLiteReport, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.total !== undefined) {
      CMsgSource2VProfLiteReportItem.encode(message.total, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.items) {
      CMsgSource2VProfLiteReportItem.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.discardedFrames !== undefined && message.discardedFrames !== 0) {
      writer.uint32(24).uint32(message.discardedFrames);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSource2VProfLiteReport {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSource2VProfLiteReport();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.total = CMsgSource2VProfLiteReportItem.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.items.push(CMsgSource2VProfLiteReportItem.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.discardedFrames = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSource2VProfLiteReport {
    return {
      total: isSet(object.total) ? CMsgSource2VProfLiteReportItem.fromJSON(object.total) : undefined,
      items: globalThis.Array.isArray(object?.items)
        ? object.items.map((e: any) => CMsgSource2VProfLiteReportItem.fromJSON(e))
        : [],
      discardedFrames: isSet(object.discardedFrames) ? globalThis.Number(object.discardedFrames) : 0,
    };
  },

  toJSON(message: CMsgSource2VProfLiteReport): unknown {
    const obj: any = {};
    if (message.total !== undefined) {
      obj.total = CMsgSource2VProfLiteReportItem.toJSON(message.total);
    }
    if (message.items?.length) {
      obj.items = message.items.map((e) => CMsgSource2VProfLiteReportItem.toJSON(e));
    }
    if (message.discardedFrames !== undefined && message.discardedFrames !== 0) {
      obj.discardedFrames = Math.round(message.discardedFrames);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSource2VProfLiteReport>): CMsgSource2VProfLiteReport {
    return CMsgSource2VProfLiteReport.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSource2VProfLiteReport>): CMsgSource2VProfLiteReport {
    const message = createBaseCMsgSource2VProfLiteReport();
    message.total = (object.total !== undefined && object.total !== null)
      ? CMsgSource2VProfLiteReportItem.fromPartial(object.total)
      : undefined;
    message.items = object.items?.map((e) => CMsgSource2VProfLiteReportItem.fromPartial(e)) || [];
    message.discardedFrames = object.discardedFrames ?? 0;
    return message;
  },
};

function createBaseCMsgSource2NetworkFlowQuality(): CMsgSource2NetworkFlowQuality {
  return {
    duration: 0,
    bytesTotal: "0",
    bytesTotalReliable: "0",
    bytesTotalVoice: "0",
    bytesSecP95: 0,
    bytesSecP99: 0,
    enginemsgsTotal: 0,
    enginemsgsSecP95: 0,
    enginemsgsSecP99: 0,
    ticksTotal: 0,
    ticksGood: 0,
    ticksGoodAlmostLate: 0,
    ticksFixedDropped: 0,
    ticksFixedLate: 0,
    ticksBadDropped: 0,
    ticksBadLate: 0,
    ticksBadOther: 0,
    tickMissrateSamplesTotal: 0,
    tickMissrateSamplesPerfect: 0,
    tickMissrateSamplesPerfectnet: 0,
    tickMissratenetP75X10: 0,
    tickMissratenetP95X10: 0,
    tickMissratenetP99X10: 0,
    recvmarginP1: 0,
    recvmarginP5: 0,
    recvmarginP25: 0,
    recvmarginP50: 0,
    recvmarginP75: 0,
    recvmarginP95: 0,
  };
}

export const CMsgSource2NetworkFlowQuality = {
  encode(message: CMsgSource2NetworkFlowQuality, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.duration !== undefined && message.duration !== 0) {
      writer.uint32(8).uint32(message.duration);
    }
    if (message.bytesTotal !== undefined && message.bytesTotal !== "0") {
      writer.uint32(40).uint64(message.bytesTotal);
    }
    if (message.bytesTotalReliable !== undefined && message.bytesTotalReliable !== "0") {
      writer.uint32(48).uint64(message.bytesTotalReliable);
    }
    if (message.bytesTotalVoice !== undefined && message.bytesTotalVoice !== "0") {
      writer.uint32(56).uint64(message.bytesTotalVoice);
    }
    if (message.bytesSecP95 !== undefined && message.bytesSecP95 !== 0) {
      writer.uint32(80).uint32(message.bytesSecP95);
    }
    if (message.bytesSecP99 !== undefined && message.bytesSecP99 !== 0) {
      writer.uint32(88).uint32(message.bytesSecP99);
    }
    if (message.enginemsgsTotal !== undefined && message.enginemsgsTotal !== 0) {
      writer.uint32(160).uint32(message.enginemsgsTotal);
    }
    if (message.enginemsgsSecP95 !== undefined && message.enginemsgsSecP95 !== 0) {
      writer.uint32(168).uint32(message.enginemsgsSecP95);
    }
    if (message.enginemsgsSecP99 !== undefined && message.enginemsgsSecP99 !== 0) {
      writer.uint32(176).uint32(message.enginemsgsSecP99);
    }
    if (message.ticksTotal !== undefined && message.ticksTotal !== 0) {
      writer.uint32(320).uint32(message.ticksTotal);
    }
    if (message.ticksGood !== undefined && message.ticksGood !== 0) {
      writer.uint32(328).uint32(message.ticksGood);
    }
    if (message.ticksGoodAlmostLate !== undefined && message.ticksGoodAlmostLate !== 0) {
      writer.uint32(336).uint32(message.ticksGoodAlmostLate);
    }
    if (message.ticksFixedDropped !== undefined && message.ticksFixedDropped !== 0) {
      writer.uint32(344).uint32(message.ticksFixedDropped);
    }
    if (message.ticksFixedLate !== undefined && message.ticksFixedLate !== 0) {
      writer.uint32(352).uint32(message.ticksFixedLate);
    }
    if (message.ticksBadDropped !== undefined && message.ticksBadDropped !== 0) {
      writer.uint32(360).uint32(message.ticksBadDropped);
    }
    if (message.ticksBadLate !== undefined && message.ticksBadLate !== 0) {
      writer.uint32(368).uint32(message.ticksBadLate);
    }
    if (message.ticksBadOther !== undefined && message.ticksBadOther !== 0) {
      writer.uint32(376).uint32(message.ticksBadOther);
    }
    if (message.tickMissrateSamplesTotal !== undefined && message.tickMissrateSamplesTotal !== 0) {
      writer.uint32(400).uint32(message.tickMissrateSamplesTotal);
    }
    if (message.tickMissrateSamplesPerfect !== undefined && message.tickMissrateSamplesPerfect !== 0) {
      writer.uint32(408).uint32(message.tickMissrateSamplesPerfect);
    }
    if (message.tickMissrateSamplesPerfectnet !== undefined && message.tickMissrateSamplesPerfectnet !== 0) {
      writer.uint32(416).uint32(message.tickMissrateSamplesPerfectnet);
    }
    if (message.tickMissratenetP75X10 !== undefined && message.tickMissratenetP75X10 !== 0) {
      writer.uint32(424).uint32(message.tickMissratenetP75X10);
    }
    if (message.tickMissratenetP95X10 !== undefined && message.tickMissratenetP95X10 !== 0) {
      writer.uint32(432).uint32(message.tickMissratenetP95X10);
    }
    if (message.tickMissratenetP99X10 !== undefined && message.tickMissratenetP99X10 !== 0) {
      writer.uint32(440).uint32(message.tickMissratenetP99X10);
    }
    if (message.recvmarginP1 !== undefined && message.recvmarginP1 !== 0) {
      writer.uint32(488).sint32(message.recvmarginP1);
    }
    if (message.recvmarginP5 !== undefined && message.recvmarginP5 !== 0) {
      writer.uint32(496).sint32(message.recvmarginP5);
    }
    if (message.recvmarginP25 !== undefined && message.recvmarginP25 !== 0) {
      writer.uint32(504).sint32(message.recvmarginP25);
    }
    if (message.recvmarginP50 !== undefined && message.recvmarginP50 !== 0) {
      writer.uint32(512).sint32(message.recvmarginP50);
    }
    if (message.recvmarginP75 !== undefined && message.recvmarginP75 !== 0) {
      writer.uint32(520).sint32(message.recvmarginP75);
    }
    if (message.recvmarginP95 !== undefined && message.recvmarginP95 !== 0) {
      writer.uint32(528).sint32(message.recvmarginP95);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgSource2NetworkFlowQuality {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgSource2NetworkFlowQuality();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.duration = reader.uint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.bytesTotal = longToString(reader.uint64() as Long);
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.bytesTotalReliable = longToString(reader.uint64() as Long);
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.bytesTotalVoice = longToString(reader.uint64() as Long);
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.bytesSecP95 = reader.uint32();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.bytesSecP99 = reader.uint32();
          continue;
        case 20:
          if (tag !== 160) {
            break;
          }

          message.enginemsgsTotal = reader.uint32();
          continue;
        case 21:
          if (tag !== 168) {
            break;
          }

          message.enginemsgsSecP95 = reader.uint32();
          continue;
        case 22:
          if (tag !== 176) {
            break;
          }

          message.enginemsgsSecP99 = reader.uint32();
          continue;
        case 40:
          if (tag !== 320) {
            break;
          }

          message.ticksTotal = reader.uint32();
          continue;
        case 41:
          if (tag !== 328) {
            break;
          }

          message.ticksGood = reader.uint32();
          continue;
        case 42:
          if (tag !== 336) {
            break;
          }

          message.ticksGoodAlmostLate = reader.uint32();
          continue;
        case 43:
          if (tag !== 344) {
            break;
          }

          message.ticksFixedDropped = reader.uint32();
          continue;
        case 44:
          if (tag !== 352) {
            break;
          }

          message.ticksFixedLate = reader.uint32();
          continue;
        case 45:
          if (tag !== 360) {
            break;
          }

          message.ticksBadDropped = reader.uint32();
          continue;
        case 46:
          if (tag !== 368) {
            break;
          }

          message.ticksBadLate = reader.uint32();
          continue;
        case 47:
          if (tag !== 376) {
            break;
          }

          message.ticksBadOther = reader.uint32();
          continue;
        case 50:
          if (tag !== 400) {
            break;
          }

          message.tickMissrateSamplesTotal = reader.uint32();
          continue;
        case 51:
          if (tag !== 408) {
            break;
          }

          message.tickMissrateSamplesPerfect = reader.uint32();
          continue;
        case 52:
          if (tag !== 416) {
            break;
          }

          message.tickMissrateSamplesPerfectnet = reader.uint32();
          continue;
        case 53:
          if (tag !== 424) {
            break;
          }

          message.tickMissratenetP75X10 = reader.uint32();
          continue;
        case 54:
          if (tag !== 432) {
            break;
          }

          message.tickMissratenetP95X10 = reader.uint32();
          continue;
        case 55:
          if (tag !== 440) {
            break;
          }

          message.tickMissratenetP99X10 = reader.uint32();
          continue;
        case 61:
          if (tag !== 488) {
            break;
          }

          message.recvmarginP1 = reader.sint32();
          continue;
        case 62:
          if (tag !== 496) {
            break;
          }

          message.recvmarginP5 = reader.sint32();
          continue;
        case 63:
          if (tag !== 504) {
            break;
          }

          message.recvmarginP25 = reader.sint32();
          continue;
        case 64:
          if (tag !== 512) {
            break;
          }

          message.recvmarginP50 = reader.sint32();
          continue;
        case 65:
          if (tag !== 520) {
            break;
          }

          message.recvmarginP75 = reader.sint32();
          continue;
        case 66:
          if (tag !== 528) {
            break;
          }

          message.recvmarginP95 = reader.sint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgSource2NetworkFlowQuality {
    return {
      duration: isSet(object.duration) ? globalThis.Number(object.duration) : 0,
      bytesTotal: isSet(object.bytesTotal) ? globalThis.String(object.bytesTotal) : "0",
      bytesTotalReliable: isSet(object.bytesTotalReliable) ? globalThis.String(object.bytesTotalReliable) : "0",
      bytesTotalVoice: isSet(object.bytesTotalVoice) ? globalThis.String(object.bytesTotalVoice) : "0",
      bytesSecP95: isSet(object.bytesSecP95) ? globalThis.Number(object.bytesSecP95) : 0,
      bytesSecP99: isSet(object.bytesSecP99) ? globalThis.Number(object.bytesSecP99) : 0,
      enginemsgsTotal: isSet(object.enginemsgsTotal) ? globalThis.Number(object.enginemsgsTotal) : 0,
      enginemsgsSecP95: isSet(object.enginemsgsSecP95) ? globalThis.Number(object.enginemsgsSecP95) : 0,
      enginemsgsSecP99: isSet(object.enginemsgsSecP99) ? globalThis.Number(object.enginemsgsSecP99) : 0,
      ticksTotal: isSet(object.ticksTotal) ? globalThis.Number(object.ticksTotal) : 0,
      ticksGood: isSet(object.ticksGood) ? globalThis.Number(object.ticksGood) : 0,
      ticksGoodAlmostLate: isSet(object.ticksGoodAlmostLate) ? globalThis.Number(object.ticksGoodAlmostLate) : 0,
      ticksFixedDropped: isSet(object.ticksFixedDropped) ? globalThis.Number(object.ticksFixedDropped) : 0,
      ticksFixedLate: isSet(object.ticksFixedLate) ? globalThis.Number(object.ticksFixedLate) : 0,
      ticksBadDropped: isSet(object.ticksBadDropped) ? globalThis.Number(object.ticksBadDropped) : 0,
      ticksBadLate: isSet(object.ticksBadLate) ? globalThis.Number(object.ticksBadLate) : 0,
      ticksBadOther: isSet(object.ticksBadOther) ? globalThis.Number(object.ticksBadOther) : 0,
      tickMissrateSamplesTotal: isSet(object.tickMissrateSamplesTotal)
        ? globalThis.Number(object.tickMissrateSamplesTotal)
        : 0,
      tickMissrateSamplesPerfect: isSet(object.tickMissrateSamplesPerfect)
        ? globalThis.Number(object.tickMissrateSamplesPerfect)
        : 0,
      tickMissrateSamplesPerfectnet: isSet(object.tickMissrateSamplesPerfectnet)
        ? globalThis.Number(object.tickMissrateSamplesPerfectnet)
        : 0,
      tickMissratenetP75X10: isSet(object.tickMissratenetP75X10) ? globalThis.Number(object.tickMissratenetP75X10) : 0,
      tickMissratenetP95X10: isSet(object.tickMissratenetP95X10) ? globalThis.Number(object.tickMissratenetP95X10) : 0,
      tickMissratenetP99X10: isSet(object.tickMissratenetP99X10) ? globalThis.Number(object.tickMissratenetP99X10) : 0,
      recvmarginP1: isSet(object.recvmarginP1) ? globalThis.Number(object.recvmarginP1) : 0,
      recvmarginP5: isSet(object.recvmarginP5) ? globalThis.Number(object.recvmarginP5) : 0,
      recvmarginP25: isSet(object.recvmarginP25) ? globalThis.Number(object.recvmarginP25) : 0,
      recvmarginP50: isSet(object.recvmarginP50) ? globalThis.Number(object.recvmarginP50) : 0,
      recvmarginP75: isSet(object.recvmarginP75) ? globalThis.Number(object.recvmarginP75) : 0,
      recvmarginP95: isSet(object.recvmarginP95) ? globalThis.Number(object.recvmarginP95) : 0,
    };
  },

  toJSON(message: CMsgSource2NetworkFlowQuality): unknown {
    const obj: any = {};
    if (message.duration !== undefined && message.duration !== 0) {
      obj.duration = Math.round(message.duration);
    }
    if (message.bytesTotal !== undefined && message.bytesTotal !== "0") {
      obj.bytesTotal = message.bytesTotal;
    }
    if (message.bytesTotalReliable !== undefined && message.bytesTotalReliable !== "0") {
      obj.bytesTotalReliable = message.bytesTotalReliable;
    }
    if (message.bytesTotalVoice !== undefined && message.bytesTotalVoice !== "0") {
      obj.bytesTotalVoice = message.bytesTotalVoice;
    }
    if (message.bytesSecP95 !== undefined && message.bytesSecP95 !== 0) {
      obj.bytesSecP95 = Math.round(message.bytesSecP95);
    }
    if (message.bytesSecP99 !== undefined && message.bytesSecP99 !== 0) {
      obj.bytesSecP99 = Math.round(message.bytesSecP99);
    }
    if (message.enginemsgsTotal !== undefined && message.enginemsgsTotal !== 0) {
      obj.enginemsgsTotal = Math.round(message.enginemsgsTotal);
    }
    if (message.enginemsgsSecP95 !== undefined && message.enginemsgsSecP95 !== 0) {
      obj.enginemsgsSecP95 = Math.round(message.enginemsgsSecP95);
    }
    if (message.enginemsgsSecP99 !== undefined && message.enginemsgsSecP99 !== 0) {
      obj.enginemsgsSecP99 = Math.round(message.enginemsgsSecP99);
    }
    if (message.ticksTotal !== undefined && message.ticksTotal !== 0) {
      obj.ticksTotal = Math.round(message.ticksTotal);
    }
    if (message.ticksGood !== undefined && message.ticksGood !== 0) {
      obj.ticksGood = Math.round(message.ticksGood);
    }
    if (message.ticksGoodAlmostLate !== undefined && message.ticksGoodAlmostLate !== 0) {
      obj.ticksGoodAlmostLate = Math.round(message.ticksGoodAlmostLate);
    }
    if (message.ticksFixedDropped !== undefined && message.ticksFixedDropped !== 0) {
      obj.ticksFixedDropped = Math.round(message.ticksFixedDropped);
    }
    if (message.ticksFixedLate !== undefined && message.ticksFixedLate !== 0) {
      obj.ticksFixedLate = Math.round(message.ticksFixedLate);
    }
    if (message.ticksBadDropped !== undefined && message.ticksBadDropped !== 0) {
      obj.ticksBadDropped = Math.round(message.ticksBadDropped);
    }
    if (message.ticksBadLate !== undefined && message.ticksBadLate !== 0) {
      obj.ticksBadLate = Math.round(message.ticksBadLate);
    }
    if (message.ticksBadOther !== undefined && message.ticksBadOther !== 0) {
      obj.ticksBadOther = Math.round(message.ticksBadOther);
    }
    if (message.tickMissrateSamplesTotal !== undefined && message.tickMissrateSamplesTotal !== 0) {
      obj.tickMissrateSamplesTotal = Math.round(message.tickMissrateSamplesTotal);
    }
    if (message.tickMissrateSamplesPerfect !== undefined && message.tickMissrateSamplesPerfect !== 0) {
      obj.tickMissrateSamplesPerfect = Math.round(message.tickMissrateSamplesPerfect);
    }
    if (message.tickMissrateSamplesPerfectnet !== undefined && message.tickMissrateSamplesPerfectnet !== 0) {
      obj.tickMissrateSamplesPerfectnet = Math.round(message.tickMissrateSamplesPerfectnet);
    }
    if (message.tickMissratenetP75X10 !== undefined && message.tickMissratenetP75X10 !== 0) {
      obj.tickMissratenetP75X10 = Math.round(message.tickMissratenetP75X10);
    }
    if (message.tickMissratenetP95X10 !== undefined && message.tickMissratenetP95X10 !== 0) {
      obj.tickMissratenetP95X10 = Math.round(message.tickMissratenetP95X10);
    }
    if (message.tickMissratenetP99X10 !== undefined && message.tickMissratenetP99X10 !== 0) {
      obj.tickMissratenetP99X10 = Math.round(message.tickMissratenetP99X10);
    }
    if (message.recvmarginP1 !== undefined && message.recvmarginP1 !== 0) {
      obj.recvmarginP1 = Math.round(message.recvmarginP1);
    }
    if (message.recvmarginP5 !== undefined && message.recvmarginP5 !== 0) {
      obj.recvmarginP5 = Math.round(message.recvmarginP5);
    }
    if (message.recvmarginP25 !== undefined && message.recvmarginP25 !== 0) {
      obj.recvmarginP25 = Math.round(message.recvmarginP25);
    }
    if (message.recvmarginP50 !== undefined && message.recvmarginP50 !== 0) {
      obj.recvmarginP50 = Math.round(message.recvmarginP50);
    }
    if (message.recvmarginP75 !== undefined && message.recvmarginP75 !== 0) {
      obj.recvmarginP75 = Math.round(message.recvmarginP75);
    }
    if (message.recvmarginP95 !== undefined && message.recvmarginP95 !== 0) {
      obj.recvmarginP95 = Math.round(message.recvmarginP95);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgSource2NetworkFlowQuality>): CMsgSource2NetworkFlowQuality {
    return CMsgSource2NetworkFlowQuality.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgSource2NetworkFlowQuality>): CMsgSource2NetworkFlowQuality {
    const message = createBaseCMsgSource2NetworkFlowQuality();
    message.duration = object.duration ?? 0;
    message.bytesTotal = object.bytesTotal ?? "0";
    message.bytesTotalReliable = object.bytesTotalReliable ?? "0";
    message.bytesTotalVoice = object.bytesTotalVoice ?? "0";
    message.bytesSecP95 = object.bytesSecP95 ?? 0;
    message.bytesSecP99 = object.bytesSecP99 ?? 0;
    message.enginemsgsTotal = object.enginemsgsTotal ?? 0;
    message.enginemsgsSecP95 = object.enginemsgsSecP95 ?? 0;
    message.enginemsgsSecP99 = object.enginemsgsSecP99 ?? 0;
    message.ticksTotal = object.ticksTotal ?? 0;
    message.ticksGood = object.ticksGood ?? 0;
    message.ticksGoodAlmostLate = object.ticksGoodAlmostLate ?? 0;
    message.ticksFixedDropped = object.ticksFixedDropped ?? 0;
    message.ticksFixedLate = object.ticksFixedLate ?? 0;
    message.ticksBadDropped = object.ticksBadDropped ?? 0;
    message.ticksBadLate = object.ticksBadLate ?? 0;
    message.ticksBadOther = object.ticksBadOther ?? 0;
    message.tickMissrateSamplesTotal = object.tickMissrateSamplesTotal ?? 0;
    message.tickMissrateSamplesPerfect = object.tickMissrateSamplesPerfect ?? 0;
    message.tickMissrateSamplesPerfectnet = object.tickMissrateSamplesPerfectnet ?? 0;
    message.tickMissratenetP75X10 = object.tickMissratenetP75X10 ?? 0;
    message.tickMissratenetP95X10 = object.tickMissratenetP95X10 ?? 0;
    message.tickMissratenetP99X10 = object.tickMissratenetP99X10 ?? 0;
    message.recvmarginP1 = object.recvmarginP1 ?? 0;
    message.recvmarginP5 = object.recvmarginP5 ?? 0;
    message.recvmarginP25 = object.recvmarginP25 ?? 0;
    message.recvmarginP50 = object.recvmarginP50 ?? 0;
    message.recvmarginP75 = object.recvmarginP75 ?? 0;
    message.recvmarginP95 = object.recvmarginP95 ?? 0;
    return message;
  },
};

function createBaseCCLCMsgDiagnostic(): CCLCMsgDiagnostic {
  return { systemSpecs: undefined, vprofReport: undefined };
}

export const CCLCMsgDiagnostic = {
  encode(message: CCLCMsgDiagnostic, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.systemSpecs !== undefined) {
      CMsgSource2SystemSpecs.encode(message.systemSpecs, writer.uint32(10).fork()).ldelim();
    }
    if (message.vprofReport !== undefined) {
      CMsgSource2VProfLiteReport.encode(message.vprofReport, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CCLCMsgDiagnostic {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCCLCMsgDiagnostic();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.systemSpecs = CMsgSource2SystemSpecs.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.vprofReport = CMsgSource2VProfLiteReport.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CCLCMsgDiagnostic {
    return {
      systemSpecs: isSet(object.systemSpecs) ? CMsgSource2SystemSpecs.fromJSON(object.systemSpecs) : undefined,
      vprofReport: isSet(object.vprofReport) ? CMsgSource2VProfLiteReport.fromJSON(object.vprofReport) : undefined,
    };
  },

  toJSON(message: CCLCMsgDiagnostic): unknown {
    const obj: any = {};
    if (message.systemSpecs !== undefined) {
      obj.systemSpecs = CMsgSource2SystemSpecs.toJSON(message.systemSpecs);
    }
    if (message.vprofReport !== undefined) {
      obj.vprofReport = CMsgSource2VProfLiteReport.toJSON(message.vprofReport);
    }
    return obj;
  },

  create(base?: DeepPartial<CCLCMsgDiagnostic>): CCLCMsgDiagnostic {
    return CCLCMsgDiagnostic.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CCLCMsgDiagnostic>): CCLCMsgDiagnostic {
    const message = createBaseCCLCMsgDiagnostic();
    message.systemSpecs = (object.systemSpecs !== undefined && object.systemSpecs !== null)
      ? CMsgSource2SystemSpecs.fromPartial(object.systemSpecs)
      : undefined;
    message.vprofReport = (object.vprofReport !== undefined && object.vprofReport !== null)
      ? CMsgSource2VProfLiteReport.fromPartial(object.vprofReport)
      : undefined;
    return message;
  },
};

function createBaseCSource2MetricsMatchPerfSummaryNotification(): CSource2MetricsMatchPerfSummaryNotification {
  return { appid: 0, gameMode: "", serverBuildId: 0, serverProfile: undefined, clients: [], map: "" };
}

export const CSource2MetricsMatchPerfSummaryNotification = {
  encode(message: CSource2MetricsMatchPerfSummaryNotification, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.appid !== undefined && message.appid !== 0) {
      writer.uint32(8).uint32(message.appid);
    }
    if (message.gameMode !== undefined && message.gameMode !== "") {
      writer.uint32(18).string(message.gameMode);
    }
    if (message.serverBuildId !== undefined && message.serverBuildId !== 0) {
      writer.uint32(24).uint32(message.serverBuildId);
    }
    if (message.serverProfile !== undefined) {
      CMsgSource2VProfLiteReport.encode(message.serverProfile, writer.uint32(82).fork()).ldelim();
    }
    for (const v of message.clients) {
      CSource2MetricsMatchPerfSummaryNotification_Client.encode(v!, writer.uint32(90).fork()).ldelim();
    }
    if (message.map !== undefined && message.map !== "") {
      writer.uint32(162).string(message.map);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CSource2MetricsMatchPerfSummaryNotification {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCSource2MetricsMatchPerfSummaryNotification();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.appid = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.gameMode = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.serverBuildId = reader.uint32();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.serverProfile = CMsgSource2VProfLiteReport.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.clients.push(CSource2MetricsMatchPerfSummaryNotification_Client.decode(reader, reader.uint32()));
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.map = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CSource2MetricsMatchPerfSummaryNotification {
    return {
      appid: isSet(object.appid) ? globalThis.Number(object.appid) : 0,
      gameMode: isSet(object.gameMode) ? globalThis.String(object.gameMode) : "",
      serverBuildId: isSet(object.serverBuildId) ? globalThis.Number(object.serverBuildId) : 0,
      serverProfile: isSet(object.serverProfile)
        ? CMsgSource2VProfLiteReport.fromJSON(object.serverProfile)
        : undefined,
      clients: globalThis.Array.isArray(object?.clients)
        ? object.clients.map((e: any) => CSource2MetricsMatchPerfSummaryNotification_Client.fromJSON(e))
        : [],
      map: isSet(object.map) ? globalThis.String(object.map) : "",
    };
  },

  toJSON(message: CSource2MetricsMatchPerfSummaryNotification): unknown {
    const obj: any = {};
    if (message.appid !== undefined && message.appid !== 0) {
      obj.appid = Math.round(message.appid);
    }
    if (message.gameMode !== undefined && message.gameMode !== "") {
      obj.gameMode = message.gameMode;
    }
    if (message.serverBuildId !== undefined && message.serverBuildId !== 0) {
      obj.serverBuildId = Math.round(message.serverBuildId);
    }
    if (message.serverProfile !== undefined) {
      obj.serverProfile = CMsgSource2VProfLiteReport.toJSON(message.serverProfile);
    }
    if (message.clients?.length) {
      obj.clients = message.clients.map((e) => CSource2MetricsMatchPerfSummaryNotification_Client.toJSON(e));
    }
    if (message.map !== undefined && message.map !== "") {
      obj.map = message.map;
    }
    return obj;
  },

  create(base?: DeepPartial<CSource2MetricsMatchPerfSummaryNotification>): CSource2MetricsMatchPerfSummaryNotification {
    return CSource2MetricsMatchPerfSummaryNotification.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CSource2MetricsMatchPerfSummaryNotification>,
  ): CSource2MetricsMatchPerfSummaryNotification {
    const message = createBaseCSource2MetricsMatchPerfSummaryNotification();
    message.appid = object.appid ?? 0;
    message.gameMode = object.gameMode ?? "";
    message.serverBuildId = object.serverBuildId ?? 0;
    message.serverProfile = (object.serverProfile !== undefined && object.serverProfile !== null)
      ? CMsgSource2VProfLiteReport.fromPartial(object.serverProfile)
      : undefined;
    message.clients = object.clients?.map((e) => CSource2MetricsMatchPerfSummaryNotification_Client.fromPartial(e)) ||
      [];
    message.map = object.map ?? "";
    return message;
  },
};

function createBaseCSource2MetricsMatchPerfSummaryNotification_Client(): CSource2MetricsMatchPerfSummaryNotification_Client {
  return { systemSpecs: undefined, profile: undefined, buildId: 0, steamid: "0" };
}

export const CSource2MetricsMatchPerfSummaryNotification_Client = {
  encode(
    message: CSource2MetricsMatchPerfSummaryNotification_Client,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.systemSpecs !== undefined) {
      CMsgSource2SystemSpecs.encode(message.systemSpecs, writer.uint32(10).fork()).ldelim();
    }
    if (message.profile !== undefined) {
      CMsgSource2VProfLiteReport.encode(message.profile, writer.uint32(18).fork()).ldelim();
    }
    if (message.buildId !== undefined && message.buildId !== 0) {
      writer.uint32(24).uint32(message.buildId);
    }
    if (message.steamid !== undefined && message.steamid !== "0") {
      writer.uint32(81).fixed64(message.steamid);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CSource2MetricsMatchPerfSummaryNotification_Client {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCSource2MetricsMatchPerfSummaryNotification_Client();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.systemSpecs = CMsgSource2SystemSpecs.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.profile = CMsgSource2VProfLiteReport.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.buildId = reader.uint32();
          continue;
        case 10:
          if (tag !== 81) {
            break;
          }

          message.steamid = longToString(reader.fixed64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CSource2MetricsMatchPerfSummaryNotification_Client {
    return {
      systemSpecs: isSet(object.systemSpecs) ? CMsgSource2SystemSpecs.fromJSON(object.systemSpecs) : undefined,
      profile: isSet(object.profile) ? CMsgSource2VProfLiteReport.fromJSON(object.profile) : undefined,
      buildId: isSet(object.buildId) ? globalThis.Number(object.buildId) : 0,
      steamid: isSet(object.steamid) ? globalThis.String(object.steamid) : "0",
    };
  },

  toJSON(message: CSource2MetricsMatchPerfSummaryNotification_Client): unknown {
    const obj: any = {};
    if (message.systemSpecs !== undefined) {
      obj.systemSpecs = CMsgSource2SystemSpecs.toJSON(message.systemSpecs);
    }
    if (message.profile !== undefined) {
      obj.profile = CMsgSource2VProfLiteReport.toJSON(message.profile);
    }
    if (message.buildId !== undefined && message.buildId !== 0) {
      obj.buildId = Math.round(message.buildId);
    }
    if (message.steamid !== undefined && message.steamid !== "0") {
      obj.steamid = message.steamid;
    }
    return obj;
  },

  create(
    base?: DeepPartial<CSource2MetricsMatchPerfSummaryNotification_Client>,
  ): CSource2MetricsMatchPerfSummaryNotification_Client {
    return CSource2MetricsMatchPerfSummaryNotification_Client.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CSource2MetricsMatchPerfSummaryNotification_Client>,
  ): CSource2MetricsMatchPerfSummaryNotification_Client {
    const message = createBaseCSource2MetricsMatchPerfSummaryNotification_Client();
    message.systemSpecs = (object.systemSpecs !== undefined && object.systemSpecs !== null)
      ? CMsgSource2SystemSpecs.fromPartial(object.systemSpecs)
      : undefined;
    message.profile = (object.profile !== undefined && object.profile !== null)
      ? CMsgSource2VProfLiteReport.fromPartial(object.profile)
      : undefined;
    message.buildId = object.buildId ?? 0;
    message.steamid = object.steamid ?? "0";
    return message;
  },
};

function createBaseCSVCMsgServerInfo(): CSVCMsgServerInfo {
  return {
    protocol: 0,
    serverCount: 0,
    isDedicated: false,
    isHltv: false,
    cOs: 0,
    maxClients: 0,
    maxClasses: 0,
    playerSlot: -1,
    tickInterval: 0,
    gameDir: "",
    mapName: "",
    skyName: "",
    hostName: "",
    addonName: "",
    gameSessionConfig: undefined,
    gameSessionManifest: Buffer.alloc(0),
  };
}

export const CSVCMsgServerInfo = {
  encode(message: CSVCMsgServerInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.protocol !== undefined && message.protocol !== 0) {
      writer.uint32(8).int32(message.protocol);
    }
    if (message.serverCount !== undefined && message.serverCount !== 0) {
      writer.uint32(16).int32(message.serverCount);
    }
    if (message.isDedicated !== undefined && message.isDedicated !== false) {
      writer.uint32(24).bool(message.isDedicated);
    }
    if (message.isHltv !== undefined && message.isHltv !== false) {
      writer.uint32(32).bool(message.isHltv);
    }
    if (message.cOs !== undefined && message.cOs !== 0) {
      writer.uint32(48).int32(message.cOs);
    }
    if (message.maxClients !== undefined && message.maxClients !== 0) {
      writer.uint32(80).int32(message.maxClients);
    }
    if (message.maxClasses !== undefined && message.maxClasses !== 0) {
      writer.uint32(88).int32(message.maxClasses);
    }
    if (message.playerSlot !== undefined && message.playerSlot !== -1) {
      writer.uint32(96).int32(message.playerSlot);
    }
    if (message.tickInterval !== undefined && message.tickInterval !== 0) {
      writer.uint32(109).float(message.tickInterval);
    }
    if (message.gameDir !== undefined && message.gameDir !== "") {
      writer.uint32(114).string(message.gameDir);
    }
    if (message.mapName !== undefined && message.mapName !== "") {
      writer.uint32(122).string(message.mapName);
    }
    if (message.skyName !== undefined && message.skyName !== "") {
      writer.uint32(130).string(message.skyName);
    }
    if (message.hostName !== undefined && message.hostName !== "") {
      writer.uint32(138).string(message.hostName);
    }
    if (message.addonName !== undefined && message.addonName !== "") {
      writer.uint32(146).string(message.addonName);
    }
    if (message.gameSessionConfig !== undefined) {
      CSVCMsgGameSessionConfiguration.encode(message.gameSessionConfig, writer.uint32(154).fork()).ldelim();
    }
    if (message.gameSessionManifest !== undefined && message.gameSessionManifest.length !== 0) {
      writer.uint32(162).bytes(message.gameSessionManifest);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CSVCMsgServerInfo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCSVCMsgServerInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.protocol = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.serverCount = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.isDedicated = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.isHltv = reader.bool();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.cOs = reader.int32();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.maxClients = reader.int32();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.maxClasses = reader.int32();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.playerSlot = reader.int32();
          continue;
        case 13:
          if (tag !== 109) {
            break;
          }

          message.tickInterval = reader.float();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.gameDir = reader.string();
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.mapName = reader.string();
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.skyName = reader.string();
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.hostName = reader.string();
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.addonName = reader.string();
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.gameSessionConfig = CSVCMsgGameSessionConfiguration.decode(reader, reader.uint32());
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.gameSessionManifest = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CSVCMsgServerInfo {
    return {
      protocol: isSet(object.protocol) ? globalThis.Number(object.protocol) : 0,
      serverCount: isSet(object.serverCount) ? globalThis.Number(object.serverCount) : 0,
      isDedicated: isSet(object.isDedicated) ? globalThis.Boolean(object.isDedicated) : false,
      isHltv: isSet(object.isHltv) ? globalThis.Boolean(object.isHltv) : false,
      cOs: isSet(object.cOs) ? globalThis.Number(object.cOs) : 0,
      maxClients: isSet(object.maxClients) ? globalThis.Number(object.maxClients) : 0,
      maxClasses: isSet(object.maxClasses) ? globalThis.Number(object.maxClasses) : 0,
      playerSlot: isSet(object.playerSlot) ? globalThis.Number(object.playerSlot) : -1,
      tickInterval: isSet(object.tickInterval) ? globalThis.Number(object.tickInterval) : 0,
      gameDir: isSet(object.gameDir) ? globalThis.String(object.gameDir) : "",
      mapName: isSet(object.mapName) ? globalThis.String(object.mapName) : "",
      skyName: isSet(object.skyName) ? globalThis.String(object.skyName) : "",
      hostName: isSet(object.hostName) ? globalThis.String(object.hostName) : "",
      addonName: isSet(object.addonName) ? globalThis.String(object.addonName) : "",
      gameSessionConfig: isSet(object.gameSessionConfig)
        ? CSVCMsgGameSessionConfiguration.fromJSON(object.gameSessionConfig)
        : undefined,
      gameSessionManifest: isSet(object.gameSessionManifest)
        ? Buffer.from(bytesFromBase64(object.gameSessionManifest))
        : Buffer.alloc(0),
    };
  },

  toJSON(message: CSVCMsgServerInfo): unknown {
    const obj: any = {};
    if (message.protocol !== undefined && message.protocol !== 0) {
      obj.protocol = Math.round(message.protocol);
    }
    if (message.serverCount !== undefined && message.serverCount !== 0) {
      obj.serverCount = Math.round(message.serverCount);
    }
    if (message.isDedicated !== undefined && message.isDedicated !== false) {
      obj.isDedicated = message.isDedicated;
    }
    if (message.isHltv !== undefined && message.isHltv !== false) {
      obj.isHltv = message.isHltv;
    }
    if (message.cOs !== undefined && message.cOs !== 0) {
      obj.cOs = Math.round(message.cOs);
    }
    if (message.maxClients !== undefined && message.maxClients !== 0) {
      obj.maxClients = Math.round(message.maxClients);
    }
    if (message.maxClasses !== undefined && message.maxClasses !== 0) {
      obj.maxClasses = Math.round(message.maxClasses);
    }
    if (message.playerSlot !== undefined && message.playerSlot !== -1) {
      obj.playerSlot = Math.round(message.playerSlot);
    }
    if (message.tickInterval !== undefined && message.tickInterval !== 0) {
      obj.tickInterval = message.tickInterval;
    }
    if (message.gameDir !== undefined && message.gameDir !== "") {
      obj.gameDir = message.gameDir;
    }
    if (message.mapName !== undefined && message.mapName !== "") {
      obj.mapName = message.mapName;
    }
    if (message.skyName !== undefined && message.skyName !== "") {
      obj.skyName = message.skyName;
    }
    if (message.hostName !== undefined && message.hostName !== "") {
      obj.hostName = message.hostName;
    }
    if (message.addonName !== undefined && message.addonName !== "") {
      obj.addonName = message.addonName;
    }
    if (message.gameSessionConfig !== undefined) {
      obj.gameSessionConfig = CSVCMsgGameSessionConfiguration.toJSON(message.gameSessionConfig);
    }
    if (message.gameSessionManifest !== undefined && message.gameSessionManifest.length !== 0) {
      obj.gameSessionManifest = base64FromBytes(message.gameSessionManifest);
    }
    return obj;
  },

  create(base?: DeepPartial<CSVCMsgServerInfo>): CSVCMsgServerInfo {
    return CSVCMsgServerInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CSVCMsgServerInfo>): CSVCMsgServerInfo {
    const message = createBaseCSVCMsgServerInfo();
    message.protocol = object.protocol ?? 0;
    message.serverCount = object.serverCount ?? 0;
    message.isDedicated = object.isDedicated ?? false;
    message.isHltv = object.isHltv ?? false;
    message.cOs = object.cOs ?? 0;
    message.maxClients = object.maxClients ?? 0;
    message.maxClasses = object.maxClasses ?? 0;
    message.playerSlot = object.playerSlot ?? -1;
    message.tickInterval = object.tickInterval ?? 0;
    message.gameDir = object.gameDir ?? "";
    message.mapName = object.mapName ?? "";
    message.skyName = object.skyName ?? "";
    message.hostName = object.hostName ?? "";
    message.addonName = object.addonName ?? "";
    message.gameSessionConfig = (object.gameSessionConfig !== undefined && object.gameSessionConfig !== null)
      ? CSVCMsgGameSessionConfiguration.fromPartial(object.gameSessionConfig)
      : undefined;
    message.gameSessionManifest = object.gameSessionManifest ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseCSVCMsgClassInfo(): CSVCMsgClassInfo {
  return { createOnClient: false, classes: [] };
}

export const CSVCMsgClassInfo = {
  encode(message: CSVCMsgClassInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.createOnClient !== undefined && message.createOnClient !== false) {
      writer.uint32(8).bool(message.createOnClient);
    }
    for (const v of message.classes) {
      CSVCMsgClassInfo_classT.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CSVCMsgClassInfo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCSVCMsgClassInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.createOnClient = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.classes.push(CSVCMsgClassInfo_classT.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CSVCMsgClassInfo {
    return {
      createOnClient: isSet(object.createOnClient) ? globalThis.Boolean(object.createOnClient) : false,
      classes: globalThis.Array.isArray(object?.classes)
        ? object.classes.map((e: any) => CSVCMsgClassInfo_classT.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CSVCMsgClassInfo): unknown {
    const obj: any = {};
    if (message.createOnClient !== undefined && message.createOnClient !== false) {
      obj.createOnClient = message.createOnClient;
    }
    if (message.classes?.length) {
      obj.classes = message.classes.map((e) => CSVCMsgClassInfo_classT.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CSVCMsgClassInfo>): CSVCMsgClassInfo {
    return CSVCMsgClassInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CSVCMsgClassInfo>): CSVCMsgClassInfo {
    const message = createBaseCSVCMsgClassInfo();
    message.createOnClient = object.createOnClient ?? false;
    message.classes = object.classes?.map((e) => CSVCMsgClassInfo_classT.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCSVCMsgClassInfo_classT(): CSVCMsgClassInfo_classT {
  return { classId: 0, className: "" };
}

export const CSVCMsgClassInfo_classT = {
  encode(message: CSVCMsgClassInfo_classT, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.classId !== undefined && message.classId !== 0) {
      writer.uint32(8).int32(message.classId);
    }
    if (message.className !== undefined && message.className !== "") {
      writer.uint32(26).string(message.className);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CSVCMsgClassInfo_classT {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCSVCMsgClassInfo_classT();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.classId = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.className = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CSVCMsgClassInfo_classT {
    return {
      classId: isSet(object.classId) ? globalThis.Number(object.classId) : 0,
      className: isSet(object.className) ? globalThis.String(object.className) : "",
    };
  },

  toJSON(message: CSVCMsgClassInfo_classT): unknown {
    const obj: any = {};
    if (message.classId !== undefined && message.classId !== 0) {
      obj.classId = Math.round(message.classId);
    }
    if (message.className !== undefined && message.className !== "") {
      obj.className = message.className;
    }
    return obj;
  },

  create(base?: DeepPartial<CSVCMsgClassInfo_classT>): CSVCMsgClassInfo_classT {
    return CSVCMsgClassInfo_classT.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CSVCMsgClassInfo_classT>): CSVCMsgClassInfo_classT {
    const message = createBaseCSVCMsgClassInfo_classT();
    message.classId = object.classId ?? 0;
    message.className = object.className ?? "";
    return message;
  },
};

function createBaseCSVCMsgSetPause(): CSVCMsgSetPause {
  return { paused: false };
}

export const CSVCMsgSetPause = {
  encode(message: CSVCMsgSetPause, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.paused !== undefined && message.paused !== false) {
      writer.uint32(8).bool(message.paused);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CSVCMsgSetPause {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCSVCMsgSetPause();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.paused = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CSVCMsgSetPause {
    return { paused: isSet(object.paused) ? globalThis.Boolean(object.paused) : false };
  },

  toJSON(message: CSVCMsgSetPause): unknown {
    const obj: any = {};
    if (message.paused !== undefined && message.paused !== false) {
      obj.paused = message.paused;
    }
    return obj;
  },

  create(base?: DeepPartial<CSVCMsgSetPause>): CSVCMsgSetPause {
    return CSVCMsgSetPause.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CSVCMsgSetPause>): CSVCMsgSetPause {
    const message = createBaseCSVCMsgSetPause();
    message.paused = object.paused ?? false;
    return message;
  },
};

function createBaseCSVCMsgVoiceInit(): CSVCMsgVoiceInit {
  return { quality: 0, codec: "", version: 0 };
}

export const CSVCMsgVoiceInit = {
  encode(message: CSVCMsgVoiceInit, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.quality !== undefined && message.quality !== 0) {
      writer.uint32(8).int32(message.quality);
    }
    if (message.codec !== undefined && message.codec !== "") {
      writer.uint32(18).string(message.codec);
    }
    if (message.version !== undefined && message.version !== 0) {
      writer.uint32(24).int32(message.version);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CSVCMsgVoiceInit {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCSVCMsgVoiceInit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.quality = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.codec = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.version = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CSVCMsgVoiceInit {
    return {
      quality: isSet(object.quality) ? globalThis.Number(object.quality) : 0,
      codec: isSet(object.codec) ? globalThis.String(object.codec) : "",
      version: isSet(object.version) ? globalThis.Number(object.version) : 0,
    };
  },

  toJSON(message: CSVCMsgVoiceInit): unknown {
    const obj: any = {};
    if (message.quality !== undefined && message.quality !== 0) {
      obj.quality = Math.round(message.quality);
    }
    if (message.codec !== undefined && message.codec !== "") {
      obj.codec = message.codec;
    }
    if (message.version !== undefined && message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    return obj;
  },

  create(base?: DeepPartial<CSVCMsgVoiceInit>): CSVCMsgVoiceInit {
    return CSVCMsgVoiceInit.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CSVCMsgVoiceInit>): CSVCMsgVoiceInit {
    const message = createBaseCSVCMsgVoiceInit();
    message.quality = object.quality ?? 0;
    message.codec = object.codec ?? "";
    message.version = object.version ?? 0;
    return message;
  },
};

function createBaseCSVCMsgPrint(): CSVCMsgPrint {
  return { text: "" };
}

export const CSVCMsgPrint = {
  encode(message: CSVCMsgPrint, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.text !== undefined && message.text !== "") {
      writer.uint32(10).string(message.text);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CSVCMsgPrint {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCSVCMsgPrint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.text = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CSVCMsgPrint {
    return { text: isSet(object.text) ? globalThis.String(object.text) : "" };
  },

  toJSON(message: CSVCMsgPrint): unknown {
    const obj: any = {};
    if (message.text !== undefined && message.text !== "") {
      obj.text = message.text;
    }
    return obj;
  },

  create(base?: DeepPartial<CSVCMsgPrint>): CSVCMsgPrint {
    return CSVCMsgPrint.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CSVCMsgPrint>): CSVCMsgPrint {
    const message = createBaseCSVCMsgPrint();
    message.text = object.text ?? "";
    return message;
  },
};

function createBaseCSVCMsgSounds(): CSVCMsgSounds {
  return { reliableSound: false, sounds: [] };
}

export const CSVCMsgSounds = {
  encode(message: CSVCMsgSounds, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.reliableSound !== undefined && message.reliableSound !== false) {
      writer.uint32(8).bool(message.reliableSound);
    }
    for (const v of message.sounds) {
      CSVCMsgSounds_sounddataT.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CSVCMsgSounds {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCSVCMsgSounds();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.reliableSound = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.sounds.push(CSVCMsgSounds_sounddataT.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CSVCMsgSounds {
    return {
      reliableSound: isSet(object.reliableSound) ? globalThis.Boolean(object.reliableSound) : false,
      sounds: globalThis.Array.isArray(object?.sounds)
        ? object.sounds.map((e: any) => CSVCMsgSounds_sounddataT.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CSVCMsgSounds): unknown {
    const obj: any = {};
    if (message.reliableSound !== undefined && message.reliableSound !== false) {
      obj.reliableSound = message.reliableSound;
    }
    if (message.sounds?.length) {
      obj.sounds = message.sounds.map((e) => CSVCMsgSounds_sounddataT.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CSVCMsgSounds>): CSVCMsgSounds {
    return CSVCMsgSounds.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CSVCMsgSounds>): CSVCMsgSounds {
    const message = createBaseCSVCMsgSounds();
    message.reliableSound = object.reliableSound ?? false;
    message.sounds = object.sounds?.map((e) => CSVCMsgSounds_sounddataT.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCSVCMsgSounds_sounddataT(): CSVCMsgSounds_sounddataT {
  return {
    originX: 0,
    originY: 0,
    originZ: 0,
    volume: 0,
    delayValue: 0,
    sequenceNumber: 0,
    entityIndex: -1,
    channel: 0,
    pitch: 0,
    flags: 0,
    soundNum: 0,
    soundNumHandle: 0,
    speakerEntity: 0,
    randomSeed: 0,
    soundLevel: 0,
    isSentence: false,
    isAmbient: false,
    guid: 0,
    soundResourceId: "0",
  };
}

export const CSVCMsgSounds_sounddataT = {
  encode(message: CSVCMsgSounds_sounddataT, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.originX !== undefined && message.originX !== 0) {
      writer.uint32(8).sint32(message.originX);
    }
    if (message.originY !== undefined && message.originY !== 0) {
      writer.uint32(16).sint32(message.originY);
    }
    if (message.originZ !== undefined && message.originZ !== 0) {
      writer.uint32(24).sint32(message.originZ);
    }
    if (message.volume !== undefined && message.volume !== 0) {
      writer.uint32(32).uint32(message.volume);
    }
    if (message.delayValue !== undefined && message.delayValue !== 0) {
      writer.uint32(45).float(message.delayValue);
    }
    if (message.sequenceNumber !== undefined && message.sequenceNumber !== 0) {
      writer.uint32(48).int32(message.sequenceNumber);
    }
    if (message.entityIndex !== undefined && message.entityIndex !== -1) {
      writer.uint32(56).int32(message.entityIndex);
    }
    if (message.channel !== undefined && message.channel !== 0) {
      writer.uint32(64).int32(message.channel);
    }
    if (message.pitch !== undefined && message.pitch !== 0) {
      writer.uint32(72).int32(message.pitch);
    }
    if (message.flags !== undefined && message.flags !== 0) {
      writer.uint32(80).int32(message.flags);
    }
    if (message.soundNum !== undefined && message.soundNum !== 0) {
      writer.uint32(88).uint32(message.soundNum);
    }
    if (message.soundNumHandle !== undefined && message.soundNumHandle !== 0) {
      writer.uint32(101).fixed32(message.soundNumHandle);
    }
    if (message.speakerEntity !== undefined && message.speakerEntity !== 0) {
      writer.uint32(104).int32(message.speakerEntity);
    }
    if (message.randomSeed !== undefined && message.randomSeed !== 0) {
      writer.uint32(112).int32(message.randomSeed);
    }
    if (message.soundLevel !== undefined && message.soundLevel !== 0) {
      writer.uint32(120).int32(message.soundLevel);
    }
    if (message.isSentence !== undefined && message.isSentence !== false) {
      writer.uint32(128).bool(message.isSentence);
    }
    if (message.isAmbient !== undefined && message.isAmbient !== false) {
      writer.uint32(136).bool(message.isAmbient);
    }
    if (message.guid !== undefined && message.guid !== 0) {
      writer.uint32(144).uint32(message.guid);
    }
    if (message.soundResourceId !== undefined && message.soundResourceId !== "0") {
      writer.uint32(153).fixed64(message.soundResourceId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CSVCMsgSounds_sounddataT {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCSVCMsgSounds_sounddataT();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.originX = reader.sint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.originY = reader.sint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.originZ = reader.sint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.volume = reader.uint32();
          continue;
        case 5:
          if (tag !== 45) {
            break;
          }

          message.delayValue = reader.float();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.sequenceNumber = reader.int32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.entityIndex = reader.int32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.channel = reader.int32();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.pitch = reader.int32();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.flags = reader.int32();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.soundNum = reader.uint32();
          continue;
        case 12:
          if (tag !== 101) {
            break;
          }

          message.soundNumHandle = reader.fixed32();
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.speakerEntity = reader.int32();
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.randomSeed = reader.int32();
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.soundLevel = reader.int32();
          continue;
        case 16:
          if (tag !== 128) {
            break;
          }

          message.isSentence = reader.bool();
          continue;
        case 17:
          if (tag !== 136) {
            break;
          }

          message.isAmbient = reader.bool();
          continue;
        case 18:
          if (tag !== 144) {
            break;
          }

          message.guid = reader.uint32();
          continue;
        case 19:
          if (tag !== 153) {
            break;
          }

          message.soundResourceId = longToString(reader.fixed64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CSVCMsgSounds_sounddataT {
    return {
      originX: isSet(object.originX) ? globalThis.Number(object.originX) : 0,
      originY: isSet(object.originY) ? globalThis.Number(object.originY) : 0,
      originZ: isSet(object.originZ) ? globalThis.Number(object.originZ) : 0,
      volume: isSet(object.volume) ? globalThis.Number(object.volume) : 0,
      delayValue: isSet(object.delayValue) ? globalThis.Number(object.delayValue) : 0,
      sequenceNumber: isSet(object.sequenceNumber) ? globalThis.Number(object.sequenceNumber) : 0,
      entityIndex: isSet(object.entityIndex) ? globalThis.Number(object.entityIndex) : -1,
      channel: isSet(object.channel) ? globalThis.Number(object.channel) : 0,
      pitch: isSet(object.pitch) ? globalThis.Number(object.pitch) : 0,
      flags: isSet(object.flags) ? globalThis.Number(object.flags) : 0,
      soundNum: isSet(object.soundNum) ? globalThis.Number(object.soundNum) : 0,
      soundNumHandle: isSet(object.soundNumHandle) ? globalThis.Number(object.soundNumHandle) : 0,
      speakerEntity: isSet(object.speakerEntity) ? globalThis.Number(object.speakerEntity) : 0,
      randomSeed: isSet(object.randomSeed) ? globalThis.Number(object.randomSeed) : 0,
      soundLevel: isSet(object.soundLevel) ? globalThis.Number(object.soundLevel) : 0,
      isSentence: isSet(object.isSentence) ? globalThis.Boolean(object.isSentence) : false,
      isAmbient: isSet(object.isAmbient) ? globalThis.Boolean(object.isAmbient) : false,
      guid: isSet(object.guid) ? globalThis.Number(object.guid) : 0,
      soundResourceId: isSet(object.soundResourceId) ? globalThis.String(object.soundResourceId) : "0",
    };
  },

  toJSON(message: CSVCMsgSounds_sounddataT): unknown {
    const obj: any = {};
    if (message.originX !== undefined && message.originX !== 0) {
      obj.originX = Math.round(message.originX);
    }
    if (message.originY !== undefined && message.originY !== 0) {
      obj.originY = Math.round(message.originY);
    }
    if (message.originZ !== undefined && message.originZ !== 0) {
      obj.originZ = Math.round(message.originZ);
    }
    if (message.volume !== undefined && message.volume !== 0) {
      obj.volume = Math.round(message.volume);
    }
    if (message.delayValue !== undefined && message.delayValue !== 0) {
      obj.delayValue = message.delayValue;
    }
    if (message.sequenceNumber !== undefined && message.sequenceNumber !== 0) {
      obj.sequenceNumber = Math.round(message.sequenceNumber);
    }
    if (message.entityIndex !== undefined && message.entityIndex !== -1) {
      obj.entityIndex = Math.round(message.entityIndex);
    }
    if (message.channel !== undefined && message.channel !== 0) {
      obj.channel = Math.round(message.channel);
    }
    if (message.pitch !== undefined && message.pitch !== 0) {
      obj.pitch = Math.round(message.pitch);
    }
    if (message.flags !== undefined && message.flags !== 0) {
      obj.flags = Math.round(message.flags);
    }
    if (message.soundNum !== undefined && message.soundNum !== 0) {
      obj.soundNum = Math.round(message.soundNum);
    }
    if (message.soundNumHandle !== undefined && message.soundNumHandle !== 0) {
      obj.soundNumHandle = Math.round(message.soundNumHandle);
    }
    if (message.speakerEntity !== undefined && message.speakerEntity !== 0) {
      obj.speakerEntity = Math.round(message.speakerEntity);
    }
    if (message.randomSeed !== undefined && message.randomSeed !== 0) {
      obj.randomSeed = Math.round(message.randomSeed);
    }
    if (message.soundLevel !== undefined && message.soundLevel !== 0) {
      obj.soundLevel = Math.round(message.soundLevel);
    }
    if (message.isSentence !== undefined && message.isSentence !== false) {
      obj.isSentence = message.isSentence;
    }
    if (message.isAmbient !== undefined && message.isAmbient !== false) {
      obj.isAmbient = message.isAmbient;
    }
    if (message.guid !== undefined && message.guid !== 0) {
      obj.guid = Math.round(message.guid);
    }
    if (message.soundResourceId !== undefined && message.soundResourceId !== "0") {
      obj.soundResourceId = message.soundResourceId;
    }
    return obj;
  },

  create(base?: DeepPartial<CSVCMsgSounds_sounddataT>): CSVCMsgSounds_sounddataT {
    return CSVCMsgSounds_sounddataT.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CSVCMsgSounds_sounddataT>): CSVCMsgSounds_sounddataT {
    const message = createBaseCSVCMsgSounds_sounddataT();
    message.originX = object.originX ?? 0;
    message.originY = object.originY ?? 0;
    message.originZ = object.originZ ?? 0;
    message.volume = object.volume ?? 0;
    message.delayValue = object.delayValue ?? 0;
    message.sequenceNumber = object.sequenceNumber ?? 0;
    message.entityIndex = object.entityIndex ?? -1;
    message.channel = object.channel ?? 0;
    message.pitch = object.pitch ?? 0;
    message.flags = object.flags ?? 0;
    message.soundNum = object.soundNum ?? 0;
    message.soundNumHandle = object.soundNumHandle ?? 0;
    message.speakerEntity = object.speakerEntity ?? 0;
    message.randomSeed = object.randomSeed ?? 0;
    message.soundLevel = object.soundLevel ?? 0;
    message.isSentence = object.isSentence ?? false;
    message.isAmbient = object.isAmbient ?? false;
    message.guid = object.guid ?? 0;
    message.soundResourceId = object.soundResourceId ?? "0";
    return message;
  },
};

function createBaseCSVCMsgPrefetch(): CSVCMsgPrefetch {
  return { soundIndex: 0, resourceType: 0 };
}

export const CSVCMsgPrefetch = {
  encode(message: CSVCMsgPrefetch, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.soundIndex !== undefined && message.soundIndex !== 0) {
      writer.uint32(8).int32(message.soundIndex);
    }
    if (message.resourceType !== undefined && message.resourceType !== 0) {
      writer.uint32(16).int32(message.resourceType);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CSVCMsgPrefetch {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCSVCMsgPrefetch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.soundIndex = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.resourceType = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CSVCMsgPrefetch {
    return {
      soundIndex: isSet(object.soundIndex) ? globalThis.Number(object.soundIndex) : 0,
      resourceType: isSet(object.resourceType) ? prefetchTypeFromJSON(object.resourceType) : 0,
    };
  },

  toJSON(message: CSVCMsgPrefetch): unknown {
    const obj: any = {};
    if (message.soundIndex !== undefined && message.soundIndex !== 0) {
      obj.soundIndex = Math.round(message.soundIndex);
    }
    if (message.resourceType !== undefined && message.resourceType !== 0) {
      obj.resourceType = prefetchTypeToJSON(message.resourceType);
    }
    return obj;
  },

  create(base?: DeepPartial<CSVCMsgPrefetch>): CSVCMsgPrefetch {
    return CSVCMsgPrefetch.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CSVCMsgPrefetch>): CSVCMsgPrefetch {
    const message = createBaseCSVCMsgPrefetch();
    message.soundIndex = object.soundIndex ?? 0;
    message.resourceType = object.resourceType ?? 0;
    return message;
  },
};

function createBaseCSVCMsgSetView(): CSVCMsgSetView {
  return { entityIndex: -1, slot: -1 };
}

export const CSVCMsgSetView = {
  encode(message: CSVCMsgSetView, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.entityIndex !== undefined && message.entityIndex !== -1) {
      writer.uint32(8).int32(message.entityIndex);
    }
    if (message.slot !== undefined && message.slot !== -1) {
      writer.uint32(16).int32(message.slot);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CSVCMsgSetView {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCSVCMsgSetView();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.entityIndex = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.slot = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CSVCMsgSetView {
    return {
      entityIndex: isSet(object.entityIndex) ? globalThis.Number(object.entityIndex) : -1,
      slot: isSet(object.slot) ? globalThis.Number(object.slot) : -1,
    };
  },

  toJSON(message: CSVCMsgSetView): unknown {
    const obj: any = {};
    if (message.entityIndex !== undefined && message.entityIndex !== -1) {
      obj.entityIndex = Math.round(message.entityIndex);
    }
    if (message.slot !== undefined && message.slot !== -1) {
      obj.slot = Math.round(message.slot);
    }
    return obj;
  },

  create(base?: DeepPartial<CSVCMsgSetView>): CSVCMsgSetView {
    return CSVCMsgSetView.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CSVCMsgSetView>): CSVCMsgSetView {
    const message = createBaseCSVCMsgSetView();
    message.entityIndex = object.entityIndex ?? -1;
    message.slot = object.slot ?? -1;
    return message;
  },
};

function createBaseCSVCMsgFixAngle(): CSVCMsgFixAngle {
  return { relative: false, angle: undefined };
}

export const CSVCMsgFixAngle = {
  encode(message: CSVCMsgFixAngle, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.relative !== undefined && message.relative !== false) {
      writer.uint32(8).bool(message.relative);
    }
    if (message.angle !== undefined) {
      CMsgQAngle.encode(message.angle, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CSVCMsgFixAngle {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCSVCMsgFixAngle();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.relative = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.angle = CMsgQAngle.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CSVCMsgFixAngle {
    return {
      relative: isSet(object.relative) ? globalThis.Boolean(object.relative) : false,
      angle: isSet(object.angle) ? CMsgQAngle.fromJSON(object.angle) : undefined,
    };
  },

  toJSON(message: CSVCMsgFixAngle): unknown {
    const obj: any = {};
    if (message.relative !== undefined && message.relative !== false) {
      obj.relative = message.relative;
    }
    if (message.angle !== undefined) {
      obj.angle = CMsgQAngle.toJSON(message.angle);
    }
    return obj;
  },

  create(base?: DeepPartial<CSVCMsgFixAngle>): CSVCMsgFixAngle {
    return CSVCMsgFixAngle.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CSVCMsgFixAngle>): CSVCMsgFixAngle {
    const message = createBaseCSVCMsgFixAngle();
    message.relative = object.relative ?? false;
    message.angle = (object.angle !== undefined && object.angle !== null)
      ? CMsgQAngle.fromPartial(object.angle)
      : undefined;
    return message;
  },
};

function createBaseCSVCMsgCrosshairAngle(): CSVCMsgCrosshairAngle {
  return { angle: undefined };
}

export const CSVCMsgCrosshairAngle = {
  encode(message: CSVCMsgCrosshairAngle, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.angle !== undefined) {
      CMsgQAngle.encode(message.angle, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CSVCMsgCrosshairAngle {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCSVCMsgCrosshairAngle();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.angle = CMsgQAngle.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CSVCMsgCrosshairAngle {
    return { angle: isSet(object.angle) ? CMsgQAngle.fromJSON(object.angle) : undefined };
  },

  toJSON(message: CSVCMsgCrosshairAngle): unknown {
    const obj: any = {};
    if (message.angle !== undefined) {
      obj.angle = CMsgQAngle.toJSON(message.angle);
    }
    return obj;
  },

  create(base?: DeepPartial<CSVCMsgCrosshairAngle>): CSVCMsgCrosshairAngle {
    return CSVCMsgCrosshairAngle.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CSVCMsgCrosshairAngle>): CSVCMsgCrosshairAngle {
    const message = createBaseCSVCMsgCrosshairAngle();
    message.angle = (object.angle !== undefined && object.angle !== null)
      ? CMsgQAngle.fromPartial(object.angle)
      : undefined;
    return message;
  },
};

function createBaseCSVCMsgBSPDecal(): CSVCMsgBSPDecal {
  return { pos: undefined, decalTextureIndex: 0, entityIndex: -1, modelIndex: 0, lowPriority: false };
}

export const CSVCMsgBSPDecal = {
  encode(message: CSVCMsgBSPDecal, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.pos !== undefined) {
      CMsgVector.encode(message.pos, writer.uint32(10).fork()).ldelim();
    }
    if (message.decalTextureIndex !== undefined && message.decalTextureIndex !== 0) {
      writer.uint32(16).int32(message.decalTextureIndex);
    }
    if (message.entityIndex !== undefined && message.entityIndex !== -1) {
      writer.uint32(24).int32(message.entityIndex);
    }
    if (message.modelIndex !== undefined && message.modelIndex !== 0) {
      writer.uint32(32).int32(message.modelIndex);
    }
    if (message.lowPriority !== undefined && message.lowPriority !== false) {
      writer.uint32(40).bool(message.lowPriority);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CSVCMsgBSPDecal {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCSVCMsgBSPDecal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.pos = CMsgVector.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.decalTextureIndex = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.entityIndex = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.modelIndex = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.lowPriority = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CSVCMsgBSPDecal {
    return {
      pos: isSet(object.pos) ? CMsgVector.fromJSON(object.pos) : undefined,
      decalTextureIndex: isSet(object.decalTextureIndex) ? globalThis.Number(object.decalTextureIndex) : 0,
      entityIndex: isSet(object.entityIndex) ? globalThis.Number(object.entityIndex) : -1,
      modelIndex: isSet(object.modelIndex) ? globalThis.Number(object.modelIndex) : 0,
      lowPriority: isSet(object.lowPriority) ? globalThis.Boolean(object.lowPriority) : false,
    };
  },

  toJSON(message: CSVCMsgBSPDecal): unknown {
    const obj: any = {};
    if (message.pos !== undefined) {
      obj.pos = CMsgVector.toJSON(message.pos);
    }
    if (message.decalTextureIndex !== undefined && message.decalTextureIndex !== 0) {
      obj.decalTextureIndex = Math.round(message.decalTextureIndex);
    }
    if (message.entityIndex !== undefined && message.entityIndex !== -1) {
      obj.entityIndex = Math.round(message.entityIndex);
    }
    if (message.modelIndex !== undefined && message.modelIndex !== 0) {
      obj.modelIndex = Math.round(message.modelIndex);
    }
    if (message.lowPriority !== undefined && message.lowPriority !== false) {
      obj.lowPriority = message.lowPriority;
    }
    return obj;
  },

  create(base?: DeepPartial<CSVCMsgBSPDecal>): CSVCMsgBSPDecal {
    return CSVCMsgBSPDecal.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CSVCMsgBSPDecal>): CSVCMsgBSPDecal {
    const message = createBaseCSVCMsgBSPDecal();
    message.pos = (object.pos !== undefined && object.pos !== null) ? CMsgVector.fromPartial(object.pos) : undefined;
    message.decalTextureIndex = object.decalTextureIndex ?? 0;
    message.entityIndex = object.entityIndex ?? -1;
    message.modelIndex = object.modelIndex ?? 0;
    message.lowPriority = object.lowPriority ?? false;
    return message;
  },
};

function createBaseCSVCMsgSplitScreen(): CSVCMsgSplitScreen {
  return { type: 0, slot: 0, playerIndex: -1 };
}

export const CSVCMsgSplitScreen = {
  encode(message: CSVCMsgSplitScreen, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.type !== undefined && message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.slot !== undefined && message.slot !== 0) {
      writer.uint32(16).int32(message.slot);
    }
    if (message.playerIndex !== undefined && message.playerIndex !== -1) {
      writer.uint32(24).int32(message.playerIndex);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CSVCMsgSplitScreen {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCSVCMsgSplitScreen();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.slot = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.playerIndex = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CSVCMsgSplitScreen {
    return {
      type: isSet(object.type) ? eSplitScreenMessageTypeFromJSON(object.type) : 0,
      slot: isSet(object.slot) ? globalThis.Number(object.slot) : 0,
      playerIndex: isSet(object.playerIndex) ? globalThis.Number(object.playerIndex) : -1,
    };
  },

  toJSON(message: CSVCMsgSplitScreen): unknown {
    const obj: any = {};
    if (message.type !== undefined && message.type !== 0) {
      obj.type = eSplitScreenMessageTypeToJSON(message.type);
    }
    if (message.slot !== undefined && message.slot !== 0) {
      obj.slot = Math.round(message.slot);
    }
    if (message.playerIndex !== undefined && message.playerIndex !== -1) {
      obj.playerIndex = Math.round(message.playerIndex);
    }
    return obj;
  },

  create(base?: DeepPartial<CSVCMsgSplitScreen>): CSVCMsgSplitScreen {
    return CSVCMsgSplitScreen.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CSVCMsgSplitScreen>): CSVCMsgSplitScreen {
    const message = createBaseCSVCMsgSplitScreen();
    message.type = object.type ?? 0;
    message.slot = object.slot ?? 0;
    message.playerIndex = object.playerIndex ?? -1;
    return message;
  },
};

function createBaseCSVCMsgGetCvarValue(): CSVCMsgGetCvarValue {
  return { cookie: 0, cvarName: "" };
}

export const CSVCMsgGetCvarValue = {
  encode(message: CSVCMsgGetCvarValue, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.cookie !== undefined && message.cookie !== 0) {
      writer.uint32(8).int32(message.cookie);
    }
    if (message.cvarName !== undefined && message.cvarName !== "") {
      writer.uint32(18).string(message.cvarName);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CSVCMsgGetCvarValue {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCSVCMsgGetCvarValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.cookie = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.cvarName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CSVCMsgGetCvarValue {
    return {
      cookie: isSet(object.cookie) ? globalThis.Number(object.cookie) : 0,
      cvarName: isSet(object.cvarName) ? globalThis.String(object.cvarName) : "",
    };
  },

  toJSON(message: CSVCMsgGetCvarValue): unknown {
    const obj: any = {};
    if (message.cookie !== undefined && message.cookie !== 0) {
      obj.cookie = Math.round(message.cookie);
    }
    if (message.cvarName !== undefined && message.cvarName !== "") {
      obj.cvarName = message.cvarName;
    }
    return obj;
  },

  create(base?: DeepPartial<CSVCMsgGetCvarValue>): CSVCMsgGetCvarValue {
    return CSVCMsgGetCvarValue.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CSVCMsgGetCvarValue>): CSVCMsgGetCvarValue {
    const message = createBaseCSVCMsgGetCvarValue();
    message.cookie = object.cookie ?? 0;
    message.cvarName = object.cvarName ?? "";
    return message;
  },
};

function createBaseCSVCMsgMenu(): CSVCMsgMenu {
  return { dialogType: 0, menuKeyValues: Buffer.alloc(0) };
}

export const CSVCMsgMenu = {
  encode(message: CSVCMsgMenu, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.dialogType !== undefined && message.dialogType !== 0) {
      writer.uint32(8).int32(message.dialogType);
    }
    if (message.menuKeyValues !== undefined && message.menuKeyValues.length !== 0) {
      writer.uint32(18).bytes(message.menuKeyValues);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CSVCMsgMenu {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCSVCMsgMenu();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.dialogType = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.menuKeyValues = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CSVCMsgMenu {
    return {
      dialogType: isSet(object.dialogType) ? globalThis.Number(object.dialogType) : 0,
      menuKeyValues: isSet(object.menuKeyValues) ? Buffer.from(bytesFromBase64(object.menuKeyValues)) : Buffer.alloc(0),
    };
  },

  toJSON(message: CSVCMsgMenu): unknown {
    const obj: any = {};
    if (message.dialogType !== undefined && message.dialogType !== 0) {
      obj.dialogType = Math.round(message.dialogType);
    }
    if (message.menuKeyValues !== undefined && message.menuKeyValues.length !== 0) {
      obj.menuKeyValues = base64FromBytes(message.menuKeyValues);
    }
    return obj;
  },

  create(base?: DeepPartial<CSVCMsgMenu>): CSVCMsgMenu {
    return CSVCMsgMenu.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CSVCMsgMenu>): CSVCMsgMenu {
    const message = createBaseCSVCMsgMenu();
    message.dialogType = object.dialogType ?? 0;
    message.menuKeyValues = object.menuKeyValues ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseCSVCMsgUserMessage(): CSVCMsgUserMessage {
  return { msgType: 0, msgData: Buffer.alloc(0), passthrough: 0 };
}

export const CSVCMsgUserMessage = {
  encode(message: CSVCMsgUserMessage, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.msgType !== undefined && message.msgType !== 0) {
      writer.uint32(8).int32(message.msgType);
    }
    if (message.msgData !== undefined && message.msgData.length !== 0) {
      writer.uint32(18).bytes(message.msgData);
    }
    if (message.passthrough !== undefined && message.passthrough !== 0) {
      writer.uint32(24).int32(message.passthrough);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CSVCMsgUserMessage {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCSVCMsgUserMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.msgType = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.msgData = reader.bytes() as Buffer;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.passthrough = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CSVCMsgUserMessage {
    return {
      msgType: isSet(object.msgType) ? globalThis.Number(object.msgType) : 0,
      msgData: isSet(object.msgData) ? Buffer.from(bytesFromBase64(object.msgData)) : Buffer.alloc(0),
      passthrough: isSet(object.passthrough) ? globalThis.Number(object.passthrough) : 0,
    };
  },

  toJSON(message: CSVCMsgUserMessage): unknown {
    const obj: any = {};
    if (message.msgType !== undefined && message.msgType !== 0) {
      obj.msgType = Math.round(message.msgType);
    }
    if (message.msgData !== undefined && message.msgData.length !== 0) {
      obj.msgData = base64FromBytes(message.msgData);
    }
    if (message.passthrough !== undefined && message.passthrough !== 0) {
      obj.passthrough = Math.round(message.passthrough);
    }
    return obj;
  },

  create(base?: DeepPartial<CSVCMsgUserMessage>): CSVCMsgUserMessage {
    return CSVCMsgUserMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CSVCMsgUserMessage>): CSVCMsgUserMessage {
    const message = createBaseCSVCMsgUserMessage();
    message.msgType = object.msgType ?? 0;
    message.msgData = object.msgData ?? Buffer.alloc(0);
    message.passthrough = object.passthrough ?? 0;
    return message;
  },
};

function createBaseCSVCMsgSendTable(): CSVCMsgSendTable {
  return { isEnd: false, netTableName: "", needsDecoder: false, props: [] };
}

export const CSVCMsgSendTable = {
  encode(message: CSVCMsgSendTable, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.isEnd !== undefined && message.isEnd !== false) {
      writer.uint32(8).bool(message.isEnd);
    }
    if (message.netTableName !== undefined && message.netTableName !== "") {
      writer.uint32(18).string(message.netTableName);
    }
    if (message.needsDecoder !== undefined && message.needsDecoder !== false) {
      writer.uint32(24).bool(message.needsDecoder);
    }
    for (const v of message.props) {
      CSVCMsgSendTable_sendpropT.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CSVCMsgSendTable {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCSVCMsgSendTable();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.isEnd = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.netTableName = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.needsDecoder = reader.bool();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.props.push(CSVCMsgSendTable_sendpropT.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CSVCMsgSendTable {
    return {
      isEnd: isSet(object.isEnd) ? globalThis.Boolean(object.isEnd) : false,
      netTableName: isSet(object.netTableName) ? globalThis.String(object.netTableName) : "",
      needsDecoder: isSet(object.needsDecoder) ? globalThis.Boolean(object.needsDecoder) : false,
      props: globalThis.Array.isArray(object?.props)
        ? object.props.map((e: any) => CSVCMsgSendTable_sendpropT.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CSVCMsgSendTable): unknown {
    const obj: any = {};
    if (message.isEnd !== undefined && message.isEnd !== false) {
      obj.isEnd = message.isEnd;
    }
    if (message.netTableName !== undefined && message.netTableName !== "") {
      obj.netTableName = message.netTableName;
    }
    if (message.needsDecoder !== undefined && message.needsDecoder !== false) {
      obj.needsDecoder = message.needsDecoder;
    }
    if (message.props?.length) {
      obj.props = message.props.map((e) => CSVCMsgSendTable_sendpropT.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CSVCMsgSendTable>): CSVCMsgSendTable {
    return CSVCMsgSendTable.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CSVCMsgSendTable>): CSVCMsgSendTable {
    const message = createBaseCSVCMsgSendTable();
    message.isEnd = object.isEnd ?? false;
    message.netTableName = object.netTableName ?? "";
    message.needsDecoder = object.needsDecoder ?? false;
    message.props = object.props?.map((e) => CSVCMsgSendTable_sendpropT.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCSVCMsgSendTable_sendpropT(): CSVCMsgSendTable_sendpropT {
  return {
    type: 0,
    varName: "",
    flags: 0,
    priority: 0,
    dtName: "",
    numElements: 0,
    lowValue: 0,
    highValue: 0,
    numBits: 0,
  };
}

export const CSVCMsgSendTable_sendpropT = {
  encode(message: CSVCMsgSendTable_sendpropT, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.type !== undefined && message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.varName !== undefined && message.varName !== "") {
      writer.uint32(18).string(message.varName);
    }
    if (message.flags !== undefined && message.flags !== 0) {
      writer.uint32(24).int32(message.flags);
    }
    if (message.priority !== undefined && message.priority !== 0) {
      writer.uint32(32).int32(message.priority);
    }
    if (message.dtName !== undefined && message.dtName !== "") {
      writer.uint32(42).string(message.dtName);
    }
    if (message.numElements !== undefined && message.numElements !== 0) {
      writer.uint32(48).int32(message.numElements);
    }
    if (message.lowValue !== undefined && message.lowValue !== 0) {
      writer.uint32(61).float(message.lowValue);
    }
    if (message.highValue !== undefined && message.highValue !== 0) {
      writer.uint32(69).float(message.highValue);
    }
    if (message.numBits !== undefined && message.numBits !== 0) {
      writer.uint32(72).int32(message.numBits);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CSVCMsgSendTable_sendpropT {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCSVCMsgSendTable_sendpropT();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.varName = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.flags = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.priority = reader.int32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.dtName = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.numElements = reader.int32();
          continue;
        case 7:
          if (tag !== 61) {
            break;
          }

          message.lowValue = reader.float();
          continue;
        case 8:
          if (tag !== 69) {
            break;
          }

          message.highValue = reader.float();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.numBits = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CSVCMsgSendTable_sendpropT {
    return {
      type: isSet(object.type) ? globalThis.Number(object.type) : 0,
      varName: isSet(object.varName) ? globalThis.String(object.varName) : "",
      flags: isSet(object.flags) ? globalThis.Number(object.flags) : 0,
      priority: isSet(object.priority) ? globalThis.Number(object.priority) : 0,
      dtName: isSet(object.dtName) ? globalThis.String(object.dtName) : "",
      numElements: isSet(object.numElements) ? globalThis.Number(object.numElements) : 0,
      lowValue: isSet(object.lowValue) ? globalThis.Number(object.lowValue) : 0,
      highValue: isSet(object.highValue) ? globalThis.Number(object.highValue) : 0,
      numBits: isSet(object.numBits) ? globalThis.Number(object.numBits) : 0,
    };
  },

  toJSON(message: CSVCMsgSendTable_sendpropT): unknown {
    const obj: any = {};
    if (message.type !== undefined && message.type !== 0) {
      obj.type = Math.round(message.type);
    }
    if (message.varName !== undefined && message.varName !== "") {
      obj.varName = message.varName;
    }
    if (message.flags !== undefined && message.flags !== 0) {
      obj.flags = Math.round(message.flags);
    }
    if (message.priority !== undefined && message.priority !== 0) {
      obj.priority = Math.round(message.priority);
    }
    if (message.dtName !== undefined && message.dtName !== "") {
      obj.dtName = message.dtName;
    }
    if (message.numElements !== undefined && message.numElements !== 0) {
      obj.numElements = Math.round(message.numElements);
    }
    if (message.lowValue !== undefined && message.lowValue !== 0) {
      obj.lowValue = message.lowValue;
    }
    if (message.highValue !== undefined && message.highValue !== 0) {
      obj.highValue = message.highValue;
    }
    if (message.numBits !== undefined && message.numBits !== 0) {
      obj.numBits = Math.round(message.numBits);
    }
    return obj;
  },

  create(base?: DeepPartial<CSVCMsgSendTable_sendpropT>): CSVCMsgSendTable_sendpropT {
    return CSVCMsgSendTable_sendpropT.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CSVCMsgSendTable_sendpropT>): CSVCMsgSendTable_sendpropT {
    const message = createBaseCSVCMsgSendTable_sendpropT();
    message.type = object.type ?? 0;
    message.varName = object.varName ?? "";
    message.flags = object.flags ?? 0;
    message.priority = object.priority ?? 0;
    message.dtName = object.dtName ?? "";
    message.numElements = object.numElements ?? 0;
    message.lowValue = object.lowValue ?? 0;
    message.highValue = object.highValue ?? 0;
    message.numBits = object.numBits ?? 0;
    return message;
  },
};

function createBaseCSVCMsgGameEventList(): CSVCMsgGameEventList {
  return { descriptors: [] };
}

export const CSVCMsgGameEventList = {
  encode(message: CSVCMsgGameEventList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.descriptors) {
      CSVCMsgGameEventList_descriptorT.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CSVCMsgGameEventList {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCSVCMsgGameEventList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.descriptors.push(CSVCMsgGameEventList_descriptorT.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CSVCMsgGameEventList {
    return {
      descriptors: globalThis.Array.isArray(object?.descriptors)
        ? object.descriptors.map((e: any) => CSVCMsgGameEventList_descriptorT.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CSVCMsgGameEventList): unknown {
    const obj: any = {};
    if (message.descriptors?.length) {
      obj.descriptors = message.descriptors.map((e) => CSVCMsgGameEventList_descriptorT.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CSVCMsgGameEventList>): CSVCMsgGameEventList {
    return CSVCMsgGameEventList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CSVCMsgGameEventList>): CSVCMsgGameEventList {
    const message = createBaseCSVCMsgGameEventList();
    message.descriptors = object.descriptors?.map((e) => CSVCMsgGameEventList_descriptorT.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCSVCMsgGameEventList_keyT(): CSVCMsgGameEventList_keyT {
  return { type: 0, name: "" };
}

export const CSVCMsgGameEventList_keyT = {
  encode(message: CSVCMsgGameEventList_keyT, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.type !== undefined && message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CSVCMsgGameEventList_keyT {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCSVCMsgGameEventList_keyT();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CSVCMsgGameEventList_keyT {
    return {
      type: isSet(object.type) ? globalThis.Number(object.type) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: CSVCMsgGameEventList_keyT): unknown {
    const obj: any = {};
    if (message.type !== undefined && message.type !== 0) {
      obj.type = Math.round(message.type);
    }
    if (message.name !== undefined && message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<CSVCMsgGameEventList_keyT>): CSVCMsgGameEventList_keyT {
    return CSVCMsgGameEventList_keyT.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CSVCMsgGameEventList_keyT>): CSVCMsgGameEventList_keyT {
    const message = createBaseCSVCMsgGameEventList_keyT();
    message.type = object.type ?? 0;
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseCSVCMsgGameEventList_descriptorT(): CSVCMsgGameEventList_descriptorT {
  return { eventid: 0, name: "", keys: [] };
}

export const CSVCMsgGameEventList_descriptorT = {
  encode(message: CSVCMsgGameEventList_descriptorT, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.eventid !== undefined && message.eventid !== 0) {
      writer.uint32(8).int32(message.eventid);
    }
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    for (const v of message.keys) {
      CSVCMsgGameEventList_keyT.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CSVCMsgGameEventList_descriptorT {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCSVCMsgGameEventList_descriptorT();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.eventid = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.keys.push(CSVCMsgGameEventList_keyT.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CSVCMsgGameEventList_descriptorT {
    return {
      eventid: isSet(object.eventid) ? globalThis.Number(object.eventid) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      keys: globalThis.Array.isArray(object?.keys)
        ? object.keys.map((e: any) => CSVCMsgGameEventList_keyT.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CSVCMsgGameEventList_descriptorT): unknown {
    const obj: any = {};
    if (message.eventid !== undefined && message.eventid !== 0) {
      obj.eventid = Math.round(message.eventid);
    }
    if (message.name !== undefined && message.name !== "") {
      obj.name = message.name;
    }
    if (message.keys?.length) {
      obj.keys = message.keys.map((e) => CSVCMsgGameEventList_keyT.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CSVCMsgGameEventList_descriptorT>): CSVCMsgGameEventList_descriptorT {
    return CSVCMsgGameEventList_descriptorT.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CSVCMsgGameEventList_descriptorT>): CSVCMsgGameEventList_descriptorT {
    const message = createBaseCSVCMsgGameEventList_descriptorT();
    message.eventid = object.eventid ?? 0;
    message.name = object.name ?? "";
    message.keys = object.keys?.map((e) => CSVCMsgGameEventList_keyT.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCSVCMsgPacketEntities(): CSVCMsgPacketEntities {
  return {
    maxEntries: 0,
    updatedEntries: 0,
    legacyIsDelta: false,
    updateBaseline: false,
    baseline: 0,
    deltaFrom: 0,
    entityData: Buffer.alloc(0),
    pendingFullFrame: false,
    activeSpawngroupHandle: 0,
    maxSpawngroupCreationsequence: 0,
    lastCmdNumberExecuted: 0,
    lastCmdNumberRecvDelta: 0,
    serverTick: 0,
    serializedEntities: Buffer.alloc(0),
    alternateBaselines: [],
    hasPvsVisBitsDeprecated: 0,
    cmdRecvStatus: [],
    nonTransmittedEntities: undefined,
    cqStarvedCommandTicks: 0,
    cqDiscardedCommandTicks: 0,
    devPadding: Buffer.alloc(0),
  };
}

export const CSVCMsgPacketEntities = {
  encode(message: CSVCMsgPacketEntities, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.maxEntries !== undefined && message.maxEntries !== 0) {
      writer.uint32(8).int32(message.maxEntries);
    }
    if (message.updatedEntries !== undefined && message.updatedEntries !== 0) {
      writer.uint32(16).int32(message.updatedEntries);
    }
    if (message.legacyIsDelta !== undefined && message.legacyIsDelta !== false) {
      writer.uint32(24).bool(message.legacyIsDelta);
    }
    if (message.updateBaseline !== undefined && message.updateBaseline !== false) {
      writer.uint32(32).bool(message.updateBaseline);
    }
    if (message.baseline !== undefined && message.baseline !== 0) {
      writer.uint32(40).int32(message.baseline);
    }
    if (message.deltaFrom !== undefined && message.deltaFrom !== 0) {
      writer.uint32(48).int32(message.deltaFrom);
    }
    if (message.entityData !== undefined && message.entityData.length !== 0) {
      writer.uint32(58).bytes(message.entityData);
    }
    if (message.pendingFullFrame !== undefined && message.pendingFullFrame !== false) {
      writer.uint32(64).bool(message.pendingFullFrame);
    }
    if (message.activeSpawngroupHandle !== undefined && message.activeSpawngroupHandle !== 0) {
      writer.uint32(72).uint32(message.activeSpawngroupHandle);
    }
    if (message.maxSpawngroupCreationsequence !== undefined && message.maxSpawngroupCreationsequence !== 0) {
      writer.uint32(80).uint32(message.maxSpawngroupCreationsequence);
    }
    if (message.lastCmdNumberExecuted !== undefined && message.lastCmdNumberExecuted !== 0) {
      writer.uint32(88).uint32(message.lastCmdNumberExecuted);
    }
    if (message.lastCmdNumberRecvDelta !== undefined && message.lastCmdNumberRecvDelta !== 0) {
      writer.uint32(136).sint32(message.lastCmdNumberRecvDelta);
    }
    if (message.serverTick !== undefined && message.serverTick !== 0) {
      writer.uint32(96).uint32(message.serverTick);
    }
    if (message.serializedEntities !== undefined && message.serializedEntities.length !== 0) {
      writer.uint32(106).bytes(message.serializedEntities);
    }
    for (const v of message.alternateBaselines) {
      CSVCMsgPacketEntities_alternateBaselineT.encode(v!, writer.uint32(122).fork()).ldelim();
    }
    if (message.hasPvsVisBitsDeprecated !== undefined && message.hasPvsVisBitsDeprecated !== 0) {
      writer.uint32(128).uint32(message.hasPvsVisBitsDeprecated);
    }
    writer.uint32(178).fork();
    for (const v of message.cmdRecvStatus) {
      writer.sint32(v);
    }
    writer.ldelim();
    if (message.nonTransmittedEntities !== undefined) {
      CSVCMsgPacketEntities_nonTransmittedEntitiesT.encode(message.nonTransmittedEntities, writer.uint32(154).fork())
        .ldelim();
    }
    if (message.cqStarvedCommandTicks !== undefined && message.cqStarvedCommandTicks !== 0) {
      writer.uint32(160).uint32(message.cqStarvedCommandTicks);
    }
    if (message.cqDiscardedCommandTicks !== undefined && message.cqDiscardedCommandTicks !== 0) {
      writer.uint32(168).uint32(message.cqDiscardedCommandTicks);
    }
    if (message.devPadding !== undefined && message.devPadding.length !== 0) {
      writer.uint32(7994).bytes(message.devPadding);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CSVCMsgPacketEntities {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCSVCMsgPacketEntities();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.maxEntries = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.updatedEntries = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.legacyIsDelta = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.updateBaseline = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.baseline = reader.int32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.deltaFrom = reader.int32();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.entityData = reader.bytes() as Buffer;
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.pendingFullFrame = reader.bool();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.activeSpawngroupHandle = reader.uint32();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.maxSpawngroupCreationsequence = reader.uint32();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.lastCmdNumberExecuted = reader.uint32();
          continue;
        case 17:
          if (tag !== 136) {
            break;
          }

          message.lastCmdNumberRecvDelta = reader.sint32();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.serverTick = reader.uint32();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.serializedEntities = reader.bytes() as Buffer;
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.alternateBaselines.push(CSVCMsgPacketEntities_alternateBaselineT.decode(reader, reader.uint32()));
          continue;
        case 16:
          if (tag !== 128) {
            break;
          }

          message.hasPvsVisBitsDeprecated = reader.uint32();
          continue;
        case 22:
          if (tag === 176) {
            message.cmdRecvStatus.push(reader.sint32());

            continue;
          }

          if (tag === 178) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.cmdRecvStatus.push(reader.sint32());
            }

            continue;
          }

          break;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.nonTransmittedEntities = CSVCMsgPacketEntities_nonTransmittedEntitiesT.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 20:
          if (tag !== 160) {
            break;
          }

          message.cqStarvedCommandTicks = reader.uint32();
          continue;
        case 21:
          if (tag !== 168) {
            break;
          }

          message.cqDiscardedCommandTicks = reader.uint32();
          continue;
        case 999:
          if (tag !== 7994) {
            break;
          }

          message.devPadding = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CSVCMsgPacketEntities {
    return {
      maxEntries: isSet(object.maxEntries) ? globalThis.Number(object.maxEntries) : 0,
      updatedEntries: isSet(object.updatedEntries) ? globalThis.Number(object.updatedEntries) : 0,
      legacyIsDelta: isSet(object.legacyIsDelta) ? globalThis.Boolean(object.legacyIsDelta) : false,
      updateBaseline: isSet(object.updateBaseline) ? globalThis.Boolean(object.updateBaseline) : false,
      baseline: isSet(object.baseline) ? globalThis.Number(object.baseline) : 0,
      deltaFrom: isSet(object.deltaFrom) ? globalThis.Number(object.deltaFrom) : 0,
      entityData: isSet(object.entityData) ? Buffer.from(bytesFromBase64(object.entityData)) : Buffer.alloc(0),
      pendingFullFrame: isSet(object.pendingFullFrame) ? globalThis.Boolean(object.pendingFullFrame) : false,
      activeSpawngroupHandle: isSet(object.activeSpawngroupHandle)
        ? globalThis.Number(object.activeSpawngroupHandle)
        : 0,
      maxSpawngroupCreationsequence: isSet(object.maxSpawngroupCreationsequence)
        ? globalThis.Number(object.maxSpawngroupCreationsequence)
        : 0,
      lastCmdNumberExecuted: isSet(object.lastCmdNumberExecuted) ? globalThis.Number(object.lastCmdNumberExecuted) : 0,
      lastCmdNumberRecvDelta: isSet(object.lastCmdNumberRecvDelta)
        ? globalThis.Number(object.lastCmdNumberRecvDelta)
        : 0,
      serverTick: isSet(object.serverTick) ? globalThis.Number(object.serverTick) : 0,
      serializedEntities: isSet(object.serializedEntities)
        ? Buffer.from(bytesFromBase64(object.serializedEntities))
        : Buffer.alloc(0),
      alternateBaselines: globalThis.Array.isArray(object?.alternateBaselines)
        ? object.alternateBaselines.map((e: any) => CSVCMsgPacketEntities_alternateBaselineT.fromJSON(e))
        : [],
      hasPvsVisBitsDeprecated: isSet(object.hasPvsVisBitsDeprecated)
        ? globalThis.Number(object.hasPvsVisBitsDeprecated)
        : 0,
      cmdRecvStatus: globalThis.Array.isArray(object?.cmdRecvStatus)
        ? object.cmdRecvStatus.map((e: any) => globalThis.Number(e))
        : [],
      nonTransmittedEntities: isSet(object.nonTransmittedEntities)
        ? CSVCMsgPacketEntities_nonTransmittedEntitiesT.fromJSON(object.nonTransmittedEntities)
        : undefined,
      cqStarvedCommandTicks: isSet(object.cqStarvedCommandTicks) ? globalThis.Number(object.cqStarvedCommandTicks) : 0,
      cqDiscardedCommandTicks: isSet(object.cqDiscardedCommandTicks)
        ? globalThis.Number(object.cqDiscardedCommandTicks)
        : 0,
      devPadding: isSet(object.devPadding) ? Buffer.from(bytesFromBase64(object.devPadding)) : Buffer.alloc(0),
    };
  },

  toJSON(message: CSVCMsgPacketEntities): unknown {
    const obj: any = {};
    if (message.maxEntries !== undefined && message.maxEntries !== 0) {
      obj.maxEntries = Math.round(message.maxEntries);
    }
    if (message.updatedEntries !== undefined && message.updatedEntries !== 0) {
      obj.updatedEntries = Math.round(message.updatedEntries);
    }
    if (message.legacyIsDelta !== undefined && message.legacyIsDelta !== false) {
      obj.legacyIsDelta = message.legacyIsDelta;
    }
    if (message.updateBaseline !== undefined && message.updateBaseline !== false) {
      obj.updateBaseline = message.updateBaseline;
    }
    if (message.baseline !== undefined && message.baseline !== 0) {
      obj.baseline = Math.round(message.baseline);
    }
    if (message.deltaFrom !== undefined && message.deltaFrom !== 0) {
      obj.deltaFrom = Math.round(message.deltaFrom);
    }
    if (message.entityData !== undefined && message.entityData.length !== 0) {
      obj.entityData = base64FromBytes(message.entityData);
    }
    if (message.pendingFullFrame !== undefined && message.pendingFullFrame !== false) {
      obj.pendingFullFrame = message.pendingFullFrame;
    }
    if (message.activeSpawngroupHandle !== undefined && message.activeSpawngroupHandle !== 0) {
      obj.activeSpawngroupHandle = Math.round(message.activeSpawngroupHandle);
    }
    if (message.maxSpawngroupCreationsequence !== undefined && message.maxSpawngroupCreationsequence !== 0) {
      obj.maxSpawngroupCreationsequence = Math.round(message.maxSpawngroupCreationsequence);
    }
    if (message.lastCmdNumberExecuted !== undefined && message.lastCmdNumberExecuted !== 0) {
      obj.lastCmdNumberExecuted = Math.round(message.lastCmdNumberExecuted);
    }
    if (message.lastCmdNumberRecvDelta !== undefined && message.lastCmdNumberRecvDelta !== 0) {
      obj.lastCmdNumberRecvDelta = Math.round(message.lastCmdNumberRecvDelta);
    }
    if (message.serverTick !== undefined && message.serverTick !== 0) {
      obj.serverTick = Math.round(message.serverTick);
    }
    if (message.serializedEntities !== undefined && message.serializedEntities.length !== 0) {
      obj.serializedEntities = base64FromBytes(message.serializedEntities);
    }
    if (message.alternateBaselines?.length) {
      obj.alternateBaselines = message.alternateBaselines.map((e) =>
        CSVCMsgPacketEntities_alternateBaselineT.toJSON(e)
      );
    }
    if (message.hasPvsVisBitsDeprecated !== undefined && message.hasPvsVisBitsDeprecated !== 0) {
      obj.hasPvsVisBitsDeprecated = Math.round(message.hasPvsVisBitsDeprecated);
    }
    if (message.cmdRecvStatus?.length) {
      obj.cmdRecvStatus = message.cmdRecvStatus.map((e) => Math.round(e));
    }
    if (message.nonTransmittedEntities !== undefined) {
      obj.nonTransmittedEntities = CSVCMsgPacketEntities_nonTransmittedEntitiesT.toJSON(message.nonTransmittedEntities);
    }
    if (message.cqStarvedCommandTicks !== undefined && message.cqStarvedCommandTicks !== 0) {
      obj.cqStarvedCommandTicks = Math.round(message.cqStarvedCommandTicks);
    }
    if (message.cqDiscardedCommandTicks !== undefined && message.cqDiscardedCommandTicks !== 0) {
      obj.cqDiscardedCommandTicks = Math.round(message.cqDiscardedCommandTicks);
    }
    if (message.devPadding !== undefined && message.devPadding.length !== 0) {
      obj.devPadding = base64FromBytes(message.devPadding);
    }
    return obj;
  },

  create(base?: DeepPartial<CSVCMsgPacketEntities>): CSVCMsgPacketEntities {
    return CSVCMsgPacketEntities.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CSVCMsgPacketEntities>): CSVCMsgPacketEntities {
    const message = createBaseCSVCMsgPacketEntities();
    message.maxEntries = object.maxEntries ?? 0;
    message.updatedEntries = object.updatedEntries ?? 0;
    message.legacyIsDelta = object.legacyIsDelta ?? false;
    message.updateBaseline = object.updateBaseline ?? false;
    message.baseline = object.baseline ?? 0;
    message.deltaFrom = object.deltaFrom ?? 0;
    message.entityData = object.entityData ?? Buffer.alloc(0);
    message.pendingFullFrame = object.pendingFullFrame ?? false;
    message.activeSpawngroupHandle = object.activeSpawngroupHandle ?? 0;
    message.maxSpawngroupCreationsequence = object.maxSpawngroupCreationsequence ?? 0;
    message.lastCmdNumberExecuted = object.lastCmdNumberExecuted ?? 0;
    message.lastCmdNumberRecvDelta = object.lastCmdNumberRecvDelta ?? 0;
    message.serverTick = object.serverTick ?? 0;
    message.serializedEntities = object.serializedEntities ?? Buffer.alloc(0);
    message.alternateBaselines =
      object.alternateBaselines?.map((e) => CSVCMsgPacketEntities_alternateBaselineT.fromPartial(e)) || [];
    message.hasPvsVisBitsDeprecated = object.hasPvsVisBitsDeprecated ?? 0;
    message.cmdRecvStatus = object.cmdRecvStatus?.map((e) => e) || [];
    message.nonTransmittedEntities =
      (object.nonTransmittedEntities !== undefined && object.nonTransmittedEntities !== null)
        ? CSVCMsgPacketEntities_nonTransmittedEntitiesT.fromPartial(object.nonTransmittedEntities)
        : undefined;
    message.cqStarvedCommandTicks = object.cqStarvedCommandTicks ?? 0;
    message.cqDiscardedCommandTicks = object.cqDiscardedCommandTicks ?? 0;
    message.devPadding = object.devPadding ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseCSVCMsgPacketEntities_alternateBaselineT(): CSVCMsgPacketEntities_alternateBaselineT {
  return { entityIndex: 0, baselineIndex: 0 };
}

export const CSVCMsgPacketEntities_alternateBaselineT = {
  encode(message: CSVCMsgPacketEntities_alternateBaselineT, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.entityIndex !== undefined && message.entityIndex !== 0) {
      writer.uint32(8).int32(message.entityIndex);
    }
    if (message.baselineIndex !== undefined && message.baselineIndex !== 0) {
      writer.uint32(16).int32(message.baselineIndex);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CSVCMsgPacketEntities_alternateBaselineT {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCSVCMsgPacketEntities_alternateBaselineT();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.entityIndex = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.baselineIndex = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CSVCMsgPacketEntities_alternateBaselineT {
    return {
      entityIndex: isSet(object.entityIndex) ? globalThis.Number(object.entityIndex) : 0,
      baselineIndex: isSet(object.baselineIndex) ? globalThis.Number(object.baselineIndex) : 0,
    };
  },

  toJSON(message: CSVCMsgPacketEntities_alternateBaselineT): unknown {
    const obj: any = {};
    if (message.entityIndex !== undefined && message.entityIndex !== 0) {
      obj.entityIndex = Math.round(message.entityIndex);
    }
    if (message.baselineIndex !== undefined && message.baselineIndex !== 0) {
      obj.baselineIndex = Math.round(message.baselineIndex);
    }
    return obj;
  },

  create(base?: DeepPartial<CSVCMsgPacketEntities_alternateBaselineT>): CSVCMsgPacketEntities_alternateBaselineT {
    return CSVCMsgPacketEntities_alternateBaselineT.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CSVCMsgPacketEntities_alternateBaselineT>): CSVCMsgPacketEntities_alternateBaselineT {
    const message = createBaseCSVCMsgPacketEntities_alternateBaselineT();
    message.entityIndex = object.entityIndex ?? 0;
    message.baselineIndex = object.baselineIndex ?? 0;
    return message;
  },
};

function createBaseCSVCMsgPacketEntities_nonTransmittedEntitiesT(): CSVCMsgPacketEntities_nonTransmittedEntitiesT {
  return { headerCount: 0, data: Buffer.alloc(0) };
}

export const CSVCMsgPacketEntities_nonTransmittedEntitiesT = {
  encode(message: CSVCMsgPacketEntities_nonTransmittedEntitiesT, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.headerCount !== undefined && message.headerCount !== 0) {
      writer.uint32(8).int32(message.headerCount);
    }
    if (message.data !== undefined && message.data.length !== 0) {
      writer.uint32(18).bytes(message.data);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CSVCMsgPacketEntities_nonTransmittedEntitiesT {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCSVCMsgPacketEntities_nonTransmittedEntitiesT();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.headerCount = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.data = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CSVCMsgPacketEntities_nonTransmittedEntitiesT {
    return {
      headerCount: isSet(object.headerCount) ? globalThis.Number(object.headerCount) : 0,
      data: isSet(object.data) ? Buffer.from(bytesFromBase64(object.data)) : Buffer.alloc(0),
    };
  },

  toJSON(message: CSVCMsgPacketEntities_nonTransmittedEntitiesT): unknown {
    const obj: any = {};
    if (message.headerCount !== undefined && message.headerCount !== 0) {
      obj.headerCount = Math.round(message.headerCount);
    }
    if (message.data !== undefined && message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    return obj;
  },

  create(
    base?: DeepPartial<CSVCMsgPacketEntities_nonTransmittedEntitiesT>,
  ): CSVCMsgPacketEntities_nonTransmittedEntitiesT {
    return CSVCMsgPacketEntities_nonTransmittedEntitiesT.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CSVCMsgPacketEntities_nonTransmittedEntitiesT>,
  ): CSVCMsgPacketEntities_nonTransmittedEntitiesT {
    const message = createBaseCSVCMsgPacketEntities_nonTransmittedEntitiesT();
    message.headerCount = object.headerCount ?? 0;
    message.data = object.data ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseCSVCMsgTempEntities(): CSVCMsgTempEntities {
  return { reliable: false, numEntries: 0, entityData: Buffer.alloc(0) };
}

export const CSVCMsgTempEntities = {
  encode(message: CSVCMsgTempEntities, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.reliable !== undefined && message.reliable !== false) {
      writer.uint32(8).bool(message.reliable);
    }
    if (message.numEntries !== undefined && message.numEntries !== 0) {
      writer.uint32(16).int32(message.numEntries);
    }
    if (message.entityData !== undefined && message.entityData.length !== 0) {
      writer.uint32(26).bytes(message.entityData);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CSVCMsgTempEntities {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCSVCMsgTempEntities();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.reliable = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.numEntries = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.entityData = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CSVCMsgTempEntities {
    return {
      reliable: isSet(object.reliable) ? globalThis.Boolean(object.reliable) : false,
      numEntries: isSet(object.numEntries) ? globalThis.Number(object.numEntries) : 0,
      entityData: isSet(object.entityData) ? Buffer.from(bytesFromBase64(object.entityData)) : Buffer.alloc(0),
    };
  },

  toJSON(message: CSVCMsgTempEntities): unknown {
    const obj: any = {};
    if (message.reliable !== undefined && message.reliable !== false) {
      obj.reliable = message.reliable;
    }
    if (message.numEntries !== undefined && message.numEntries !== 0) {
      obj.numEntries = Math.round(message.numEntries);
    }
    if (message.entityData !== undefined && message.entityData.length !== 0) {
      obj.entityData = base64FromBytes(message.entityData);
    }
    return obj;
  },

  create(base?: DeepPartial<CSVCMsgTempEntities>): CSVCMsgTempEntities {
    return CSVCMsgTempEntities.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CSVCMsgTempEntities>): CSVCMsgTempEntities {
    const message = createBaseCSVCMsgTempEntities();
    message.reliable = object.reliable ?? false;
    message.numEntries = object.numEntries ?? 0;
    message.entityData = object.entityData ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseCSVCMsgCreateStringTable(): CSVCMsgCreateStringTable {
  return {
    name: "",
    numEntries: 0,
    userDataFixedSize: false,
    userDataSize: 0,
    userDataSizeBits: 0,
    flags: 0,
    stringData: Buffer.alloc(0),
    uncompressedSize: 0,
    dataCompressed: false,
    usingVarintBitcounts: false,
  };
}

export const CSVCMsgCreateStringTable = {
  encode(message: CSVCMsgCreateStringTable, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.numEntries !== undefined && message.numEntries !== 0) {
      writer.uint32(16).int32(message.numEntries);
    }
    if (message.userDataFixedSize !== undefined && message.userDataFixedSize !== false) {
      writer.uint32(24).bool(message.userDataFixedSize);
    }
    if (message.userDataSize !== undefined && message.userDataSize !== 0) {
      writer.uint32(32).int32(message.userDataSize);
    }
    if (message.userDataSizeBits !== undefined && message.userDataSizeBits !== 0) {
      writer.uint32(40).int32(message.userDataSizeBits);
    }
    if (message.flags !== undefined && message.flags !== 0) {
      writer.uint32(48).int32(message.flags);
    }
    if (message.stringData !== undefined && message.stringData.length !== 0) {
      writer.uint32(58).bytes(message.stringData);
    }
    if (message.uncompressedSize !== undefined && message.uncompressedSize !== 0) {
      writer.uint32(64).int32(message.uncompressedSize);
    }
    if (message.dataCompressed !== undefined && message.dataCompressed !== false) {
      writer.uint32(72).bool(message.dataCompressed);
    }
    if (message.usingVarintBitcounts !== undefined && message.usingVarintBitcounts !== false) {
      writer.uint32(80).bool(message.usingVarintBitcounts);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CSVCMsgCreateStringTable {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCSVCMsgCreateStringTable();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.numEntries = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.userDataFixedSize = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.userDataSize = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.userDataSizeBits = reader.int32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.flags = reader.int32();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.stringData = reader.bytes() as Buffer;
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.uncompressedSize = reader.int32();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.dataCompressed = reader.bool();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.usingVarintBitcounts = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CSVCMsgCreateStringTable {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      numEntries: isSet(object.numEntries) ? globalThis.Number(object.numEntries) : 0,
      userDataFixedSize: isSet(object.userDataFixedSize) ? globalThis.Boolean(object.userDataFixedSize) : false,
      userDataSize: isSet(object.userDataSize) ? globalThis.Number(object.userDataSize) : 0,
      userDataSizeBits: isSet(object.userDataSizeBits) ? globalThis.Number(object.userDataSizeBits) : 0,
      flags: isSet(object.flags) ? globalThis.Number(object.flags) : 0,
      stringData: isSet(object.stringData) ? Buffer.from(bytesFromBase64(object.stringData)) : Buffer.alloc(0),
      uncompressedSize: isSet(object.uncompressedSize) ? globalThis.Number(object.uncompressedSize) : 0,
      dataCompressed: isSet(object.dataCompressed) ? globalThis.Boolean(object.dataCompressed) : false,
      usingVarintBitcounts: isSet(object.usingVarintBitcounts)
        ? globalThis.Boolean(object.usingVarintBitcounts)
        : false,
    };
  },

  toJSON(message: CSVCMsgCreateStringTable): unknown {
    const obj: any = {};
    if (message.name !== undefined && message.name !== "") {
      obj.name = message.name;
    }
    if (message.numEntries !== undefined && message.numEntries !== 0) {
      obj.numEntries = Math.round(message.numEntries);
    }
    if (message.userDataFixedSize !== undefined && message.userDataFixedSize !== false) {
      obj.userDataFixedSize = message.userDataFixedSize;
    }
    if (message.userDataSize !== undefined && message.userDataSize !== 0) {
      obj.userDataSize = Math.round(message.userDataSize);
    }
    if (message.userDataSizeBits !== undefined && message.userDataSizeBits !== 0) {
      obj.userDataSizeBits = Math.round(message.userDataSizeBits);
    }
    if (message.flags !== undefined && message.flags !== 0) {
      obj.flags = Math.round(message.flags);
    }
    if (message.stringData !== undefined && message.stringData.length !== 0) {
      obj.stringData = base64FromBytes(message.stringData);
    }
    if (message.uncompressedSize !== undefined && message.uncompressedSize !== 0) {
      obj.uncompressedSize = Math.round(message.uncompressedSize);
    }
    if (message.dataCompressed !== undefined && message.dataCompressed !== false) {
      obj.dataCompressed = message.dataCompressed;
    }
    if (message.usingVarintBitcounts !== undefined && message.usingVarintBitcounts !== false) {
      obj.usingVarintBitcounts = message.usingVarintBitcounts;
    }
    return obj;
  },

  create(base?: DeepPartial<CSVCMsgCreateStringTable>): CSVCMsgCreateStringTable {
    return CSVCMsgCreateStringTable.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CSVCMsgCreateStringTable>): CSVCMsgCreateStringTable {
    const message = createBaseCSVCMsgCreateStringTable();
    message.name = object.name ?? "";
    message.numEntries = object.numEntries ?? 0;
    message.userDataFixedSize = object.userDataFixedSize ?? false;
    message.userDataSize = object.userDataSize ?? 0;
    message.userDataSizeBits = object.userDataSizeBits ?? 0;
    message.flags = object.flags ?? 0;
    message.stringData = object.stringData ?? Buffer.alloc(0);
    message.uncompressedSize = object.uncompressedSize ?? 0;
    message.dataCompressed = object.dataCompressed ?? false;
    message.usingVarintBitcounts = object.usingVarintBitcounts ?? false;
    return message;
  },
};

function createBaseCSVCMsgUpdateStringTable(): CSVCMsgUpdateStringTable {
  return { tableId: 0, numChangedEntries: 0, stringData: Buffer.alloc(0) };
}

export const CSVCMsgUpdateStringTable = {
  encode(message: CSVCMsgUpdateStringTable, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.tableId !== undefined && message.tableId !== 0) {
      writer.uint32(8).int32(message.tableId);
    }
    if (message.numChangedEntries !== undefined && message.numChangedEntries !== 0) {
      writer.uint32(16).int32(message.numChangedEntries);
    }
    if (message.stringData !== undefined && message.stringData.length !== 0) {
      writer.uint32(26).bytes(message.stringData);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CSVCMsgUpdateStringTable {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCSVCMsgUpdateStringTable();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.tableId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.numChangedEntries = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.stringData = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CSVCMsgUpdateStringTable {
    return {
      tableId: isSet(object.tableId) ? globalThis.Number(object.tableId) : 0,
      numChangedEntries: isSet(object.numChangedEntries) ? globalThis.Number(object.numChangedEntries) : 0,
      stringData: isSet(object.stringData) ? Buffer.from(bytesFromBase64(object.stringData)) : Buffer.alloc(0),
    };
  },

  toJSON(message: CSVCMsgUpdateStringTable): unknown {
    const obj: any = {};
    if (message.tableId !== undefined && message.tableId !== 0) {
      obj.tableId = Math.round(message.tableId);
    }
    if (message.numChangedEntries !== undefined && message.numChangedEntries !== 0) {
      obj.numChangedEntries = Math.round(message.numChangedEntries);
    }
    if (message.stringData !== undefined && message.stringData.length !== 0) {
      obj.stringData = base64FromBytes(message.stringData);
    }
    return obj;
  },

  create(base?: DeepPartial<CSVCMsgUpdateStringTable>): CSVCMsgUpdateStringTable {
    return CSVCMsgUpdateStringTable.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CSVCMsgUpdateStringTable>): CSVCMsgUpdateStringTable {
    const message = createBaseCSVCMsgUpdateStringTable();
    message.tableId = object.tableId ?? 0;
    message.numChangedEntries = object.numChangedEntries ?? 0;
    message.stringData = object.stringData ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseCSVCMsgVoiceData(): CSVCMsgVoiceData {
  return { audio: undefined, client: -1, proximity: false, xuid: "0", audibleMask: 0, tick: 0, passthrough: 0 };
}

export const CSVCMsgVoiceData = {
  encode(message: CSVCMsgVoiceData, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.audio !== undefined) {
      CMsgVoiceAudio.encode(message.audio, writer.uint32(10).fork()).ldelim();
    }
    if (message.client !== undefined && message.client !== -1) {
      writer.uint32(16).int32(message.client);
    }
    if (message.proximity !== undefined && message.proximity !== false) {
      writer.uint32(24).bool(message.proximity);
    }
    if (message.xuid !== undefined && message.xuid !== "0") {
      writer.uint32(33).fixed64(message.xuid);
    }
    if (message.audibleMask !== undefined && message.audibleMask !== 0) {
      writer.uint32(40).int32(message.audibleMask);
    }
    if (message.tick !== undefined && message.tick !== 0) {
      writer.uint32(48).uint32(message.tick);
    }
    if (message.passthrough !== undefined && message.passthrough !== 0) {
      writer.uint32(56).int32(message.passthrough);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CSVCMsgVoiceData {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCSVCMsgVoiceData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.audio = CMsgVoiceAudio.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.client = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.proximity = reader.bool();
          continue;
        case 4:
          if (tag !== 33) {
            break;
          }

          message.xuid = longToString(reader.fixed64() as Long);
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.audibleMask = reader.int32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.tick = reader.uint32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.passthrough = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CSVCMsgVoiceData {
    return {
      audio: isSet(object.audio) ? CMsgVoiceAudio.fromJSON(object.audio) : undefined,
      client: isSet(object.client) ? globalThis.Number(object.client) : -1,
      proximity: isSet(object.proximity) ? globalThis.Boolean(object.proximity) : false,
      xuid: isSet(object.xuid) ? globalThis.String(object.xuid) : "0",
      audibleMask: isSet(object.audibleMask) ? globalThis.Number(object.audibleMask) : 0,
      tick: isSet(object.tick) ? globalThis.Number(object.tick) : 0,
      passthrough: isSet(object.passthrough) ? globalThis.Number(object.passthrough) : 0,
    };
  },

  toJSON(message: CSVCMsgVoiceData): unknown {
    const obj: any = {};
    if (message.audio !== undefined) {
      obj.audio = CMsgVoiceAudio.toJSON(message.audio);
    }
    if (message.client !== undefined && message.client !== -1) {
      obj.client = Math.round(message.client);
    }
    if (message.proximity !== undefined && message.proximity !== false) {
      obj.proximity = message.proximity;
    }
    if (message.xuid !== undefined && message.xuid !== "0") {
      obj.xuid = message.xuid;
    }
    if (message.audibleMask !== undefined && message.audibleMask !== 0) {
      obj.audibleMask = Math.round(message.audibleMask);
    }
    if (message.tick !== undefined && message.tick !== 0) {
      obj.tick = Math.round(message.tick);
    }
    if (message.passthrough !== undefined && message.passthrough !== 0) {
      obj.passthrough = Math.round(message.passthrough);
    }
    return obj;
  },

  create(base?: DeepPartial<CSVCMsgVoiceData>): CSVCMsgVoiceData {
    return CSVCMsgVoiceData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CSVCMsgVoiceData>): CSVCMsgVoiceData {
    const message = createBaseCSVCMsgVoiceData();
    message.audio = (object.audio !== undefined && object.audio !== null)
      ? CMsgVoiceAudio.fromPartial(object.audio)
      : undefined;
    message.client = object.client ?? -1;
    message.proximity = object.proximity ?? false;
    message.xuid = object.xuid ?? "0";
    message.audibleMask = object.audibleMask ?? 0;
    message.tick = object.tick ?? 0;
    message.passthrough = object.passthrough ?? 0;
    return message;
  },
};

function createBaseCSVCMsgPacketReliable(): CSVCMsgPacketReliable {
  return { tick: 0, messagessize: 0, state: false };
}

export const CSVCMsgPacketReliable = {
  encode(message: CSVCMsgPacketReliable, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.tick !== undefined && message.tick !== 0) {
      writer.uint32(8).int32(message.tick);
    }
    if (message.messagessize !== undefined && message.messagessize !== 0) {
      writer.uint32(16).int32(message.messagessize);
    }
    if (message.state !== undefined && message.state !== false) {
      writer.uint32(24).bool(message.state);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CSVCMsgPacketReliable {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCSVCMsgPacketReliable();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.tick = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.messagessize = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.state = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CSVCMsgPacketReliable {
    return {
      tick: isSet(object.tick) ? globalThis.Number(object.tick) : 0,
      messagessize: isSet(object.messagessize) ? globalThis.Number(object.messagessize) : 0,
      state: isSet(object.state) ? globalThis.Boolean(object.state) : false,
    };
  },

  toJSON(message: CSVCMsgPacketReliable): unknown {
    const obj: any = {};
    if (message.tick !== undefined && message.tick !== 0) {
      obj.tick = Math.round(message.tick);
    }
    if (message.messagessize !== undefined && message.messagessize !== 0) {
      obj.messagessize = Math.round(message.messagessize);
    }
    if (message.state !== undefined && message.state !== false) {
      obj.state = message.state;
    }
    return obj;
  },

  create(base?: DeepPartial<CSVCMsgPacketReliable>): CSVCMsgPacketReliable {
    return CSVCMsgPacketReliable.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CSVCMsgPacketReliable>): CSVCMsgPacketReliable {
    const message = createBaseCSVCMsgPacketReliable();
    message.tick = object.tick ?? 0;
    message.messagessize = object.messagessize ?? 0;
    message.state = object.state ?? false;
    return message;
  },
};

function createBaseCSVCMsgFullFrameSplit(): CSVCMsgFullFrameSplit {
  return { tick: 0, section: 0, total: 0, data: Buffer.alloc(0) };
}

export const CSVCMsgFullFrameSplit = {
  encode(message: CSVCMsgFullFrameSplit, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.tick !== undefined && message.tick !== 0) {
      writer.uint32(8).int32(message.tick);
    }
    if (message.section !== undefined && message.section !== 0) {
      writer.uint32(16).int32(message.section);
    }
    if (message.total !== undefined && message.total !== 0) {
      writer.uint32(24).int32(message.total);
    }
    if (message.data !== undefined && message.data.length !== 0) {
      writer.uint32(34).bytes(message.data);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CSVCMsgFullFrameSplit {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCSVCMsgFullFrameSplit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.tick = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.section = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.total = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.data = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CSVCMsgFullFrameSplit {
    return {
      tick: isSet(object.tick) ? globalThis.Number(object.tick) : 0,
      section: isSet(object.section) ? globalThis.Number(object.section) : 0,
      total: isSet(object.total) ? globalThis.Number(object.total) : 0,
      data: isSet(object.data) ? Buffer.from(bytesFromBase64(object.data)) : Buffer.alloc(0),
    };
  },

  toJSON(message: CSVCMsgFullFrameSplit): unknown {
    const obj: any = {};
    if (message.tick !== undefined && message.tick !== 0) {
      obj.tick = Math.round(message.tick);
    }
    if (message.section !== undefined && message.section !== 0) {
      obj.section = Math.round(message.section);
    }
    if (message.total !== undefined && message.total !== 0) {
      obj.total = Math.round(message.total);
    }
    if (message.data !== undefined && message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    return obj;
  },

  create(base?: DeepPartial<CSVCMsgFullFrameSplit>): CSVCMsgFullFrameSplit {
    return CSVCMsgFullFrameSplit.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CSVCMsgFullFrameSplit>): CSVCMsgFullFrameSplit {
    const message = createBaseCSVCMsgFullFrameSplit();
    message.tick = object.tick ?? 0;
    message.section = object.section ?? 0;
    message.total = object.total ?? 0;
    message.data = object.data ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseCSVCMsgHLTVStatus(): CSVCMsgHLTVStatus {
  return { master: "", clients: 0, slots: 0, proxies: 0 };
}

export const CSVCMsgHLTVStatus = {
  encode(message: CSVCMsgHLTVStatus, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.master !== undefined && message.master !== "") {
      writer.uint32(10).string(message.master);
    }
    if (message.clients !== undefined && message.clients !== 0) {
      writer.uint32(16).int32(message.clients);
    }
    if (message.slots !== undefined && message.slots !== 0) {
      writer.uint32(24).int32(message.slots);
    }
    if (message.proxies !== undefined && message.proxies !== 0) {
      writer.uint32(32).int32(message.proxies);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CSVCMsgHLTVStatus {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCSVCMsgHLTVStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.master = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.clients = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.slots = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.proxies = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CSVCMsgHLTVStatus {
    return {
      master: isSet(object.master) ? globalThis.String(object.master) : "",
      clients: isSet(object.clients) ? globalThis.Number(object.clients) : 0,
      slots: isSet(object.slots) ? globalThis.Number(object.slots) : 0,
      proxies: isSet(object.proxies) ? globalThis.Number(object.proxies) : 0,
    };
  },

  toJSON(message: CSVCMsgHLTVStatus): unknown {
    const obj: any = {};
    if (message.master !== undefined && message.master !== "") {
      obj.master = message.master;
    }
    if (message.clients !== undefined && message.clients !== 0) {
      obj.clients = Math.round(message.clients);
    }
    if (message.slots !== undefined && message.slots !== 0) {
      obj.slots = Math.round(message.slots);
    }
    if (message.proxies !== undefined && message.proxies !== 0) {
      obj.proxies = Math.round(message.proxies);
    }
    return obj;
  },

  create(base?: DeepPartial<CSVCMsgHLTVStatus>): CSVCMsgHLTVStatus {
    return CSVCMsgHLTVStatus.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CSVCMsgHLTVStatus>): CSVCMsgHLTVStatus {
    const message = createBaseCSVCMsgHLTVStatus();
    message.master = object.master ?? "";
    message.clients = object.clients ?? 0;
    message.slots = object.slots ?? 0;
    message.proxies = object.proxies ?? 0;
    return message;
  },
};

function createBaseCSVCMsgServerSteamID(): CSVCMsgServerSteamID {
  return { steamId: "0" };
}

export const CSVCMsgServerSteamID = {
  encode(message: CSVCMsgServerSteamID, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.steamId !== undefined && message.steamId !== "0") {
      writer.uint32(8).uint64(message.steamId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CSVCMsgServerSteamID {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCSVCMsgServerSteamID();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.steamId = longToString(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CSVCMsgServerSteamID {
    return { steamId: isSet(object.steamId) ? globalThis.String(object.steamId) : "0" };
  },

  toJSON(message: CSVCMsgServerSteamID): unknown {
    const obj: any = {};
    if (message.steamId !== undefined && message.steamId !== "0") {
      obj.steamId = message.steamId;
    }
    return obj;
  },

  create(base?: DeepPartial<CSVCMsgServerSteamID>): CSVCMsgServerSteamID {
    return CSVCMsgServerSteamID.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CSVCMsgServerSteamID>): CSVCMsgServerSteamID {
    const message = createBaseCSVCMsgServerSteamID();
    message.steamId = object.steamId ?? "0";
    return message;
  },
};

function createBaseCSVCMsgCmdKeyValues(): CSVCMsgCmdKeyValues {
  return { data: Buffer.alloc(0) };
}

export const CSVCMsgCmdKeyValues = {
  encode(message: CSVCMsgCmdKeyValues, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.data !== undefined && message.data.length !== 0) {
      writer.uint32(10).bytes(message.data);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CSVCMsgCmdKeyValues {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCSVCMsgCmdKeyValues();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.data = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CSVCMsgCmdKeyValues {
    return { data: isSet(object.data) ? Buffer.from(bytesFromBase64(object.data)) : Buffer.alloc(0) };
  },

  toJSON(message: CSVCMsgCmdKeyValues): unknown {
    const obj: any = {};
    if (message.data !== undefined && message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    return obj;
  },

  create(base?: DeepPartial<CSVCMsgCmdKeyValues>): CSVCMsgCmdKeyValues {
    return CSVCMsgCmdKeyValues.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CSVCMsgCmdKeyValues>): CSVCMsgCmdKeyValues {
    const message = createBaseCSVCMsgCmdKeyValues();
    message.data = object.data ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseCSVCMsgRconServerDetails(): CSVCMsgRconServerDetails {
  return { token: Buffer.alloc(0), details: "" };
}

export const CSVCMsgRconServerDetails = {
  encode(message: CSVCMsgRconServerDetails, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.token !== undefined && message.token.length !== 0) {
      writer.uint32(10).bytes(message.token);
    }
    if (message.details !== undefined && message.details !== "") {
      writer.uint32(18).string(message.details);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CSVCMsgRconServerDetails {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCSVCMsgRconServerDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.token = reader.bytes() as Buffer;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.details = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CSVCMsgRconServerDetails {
    return {
      token: isSet(object.token) ? Buffer.from(bytesFromBase64(object.token)) : Buffer.alloc(0),
      details: isSet(object.details) ? globalThis.String(object.details) : "",
    };
  },

  toJSON(message: CSVCMsgRconServerDetails): unknown {
    const obj: any = {};
    if (message.token !== undefined && message.token.length !== 0) {
      obj.token = base64FromBytes(message.token);
    }
    if (message.details !== undefined && message.details !== "") {
      obj.details = message.details;
    }
    return obj;
  },

  create(base?: DeepPartial<CSVCMsgRconServerDetails>): CSVCMsgRconServerDetails {
    return CSVCMsgRconServerDetails.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CSVCMsgRconServerDetails>): CSVCMsgRconServerDetails {
    const message = createBaseCSVCMsgRconServerDetails();
    message.token = object.token ?? Buffer.alloc(0);
    message.details = object.details ?? "";
    return message;
  },
};

function createBaseCMsgIPCAddress(): CMsgIPCAddress {
  return { computerGuid: "0", processId: 0 };
}

export const CMsgIPCAddress = {
  encode(message: CMsgIPCAddress, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.computerGuid !== undefined && message.computerGuid !== "0") {
      writer.uint32(9).fixed64(message.computerGuid);
    }
    if (message.processId !== undefined && message.processId !== 0) {
      writer.uint32(16).uint32(message.processId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgIPCAddress {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgIPCAddress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.computerGuid = longToString(reader.fixed64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.processId = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgIPCAddress {
    return {
      computerGuid: isSet(object.computerGuid) ? globalThis.String(object.computerGuid) : "0",
      processId: isSet(object.processId) ? globalThis.Number(object.processId) : 0,
    };
  },

  toJSON(message: CMsgIPCAddress): unknown {
    const obj: any = {};
    if (message.computerGuid !== undefined && message.computerGuid !== "0") {
      obj.computerGuid = message.computerGuid;
    }
    if (message.processId !== undefined && message.processId !== 0) {
      obj.processId = Math.round(message.processId);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgIPCAddress>): CMsgIPCAddress {
    return CMsgIPCAddress.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgIPCAddress>): CMsgIPCAddress {
    const message = createBaseCMsgIPCAddress();
    message.computerGuid = object.computerGuid ?? "0";
    message.processId = object.processId ?? 0;
    return message;
  },
};

function createBaseCMsgServerPeer(): CMsgServerPeer {
  return {
    playerSlot: -1,
    steamid: "0",
    ipc: undefined,
    theyHearYou: false,
    youHearThem: false,
    isListenserverHost: false,
  };
}

export const CMsgServerPeer = {
  encode(message: CMsgServerPeer, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.playerSlot !== undefined && message.playerSlot !== -1) {
      writer.uint32(8).int32(message.playerSlot);
    }
    if (message.steamid !== undefined && message.steamid !== "0") {
      writer.uint32(17).fixed64(message.steamid);
    }
    if (message.ipc !== undefined) {
      CMsgIPCAddress.encode(message.ipc, writer.uint32(26).fork()).ldelim();
    }
    if (message.theyHearYou !== undefined && message.theyHearYou !== false) {
      writer.uint32(32).bool(message.theyHearYou);
    }
    if (message.youHearThem !== undefined && message.youHearThem !== false) {
      writer.uint32(40).bool(message.youHearThem);
    }
    if (message.isListenserverHost !== undefined && message.isListenserverHost !== false) {
      writer.uint32(48).bool(message.isListenserverHost);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgServerPeer {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgServerPeer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.playerSlot = reader.int32();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.steamid = longToString(reader.fixed64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.ipc = CMsgIPCAddress.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.theyHearYou = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.youHearThem = reader.bool();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.isListenserverHost = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgServerPeer {
    return {
      playerSlot: isSet(object.playerSlot) ? globalThis.Number(object.playerSlot) : -1,
      steamid: isSet(object.steamid) ? globalThis.String(object.steamid) : "0",
      ipc: isSet(object.ipc) ? CMsgIPCAddress.fromJSON(object.ipc) : undefined,
      theyHearYou: isSet(object.theyHearYou) ? globalThis.Boolean(object.theyHearYou) : false,
      youHearThem: isSet(object.youHearThem) ? globalThis.Boolean(object.youHearThem) : false,
      isListenserverHost: isSet(object.isListenserverHost) ? globalThis.Boolean(object.isListenserverHost) : false,
    };
  },

  toJSON(message: CMsgServerPeer): unknown {
    const obj: any = {};
    if (message.playerSlot !== undefined && message.playerSlot !== -1) {
      obj.playerSlot = Math.round(message.playerSlot);
    }
    if (message.steamid !== undefined && message.steamid !== "0") {
      obj.steamid = message.steamid;
    }
    if (message.ipc !== undefined) {
      obj.ipc = CMsgIPCAddress.toJSON(message.ipc);
    }
    if (message.theyHearYou !== undefined && message.theyHearYou !== false) {
      obj.theyHearYou = message.theyHearYou;
    }
    if (message.youHearThem !== undefined && message.youHearThem !== false) {
      obj.youHearThem = message.youHearThem;
    }
    if (message.isListenserverHost !== undefined && message.isListenserverHost !== false) {
      obj.isListenserverHost = message.isListenserverHost;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgServerPeer>): CMsgServerPeer {
    return CMsgServerPeer.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgServerPeer>): CMsgServerPeer {
    const message = createBaseCMsgServerPeer();
    message.playerSlot = object.playerSlot ?? -1;
    message.steamid = object.steamid ?? "0";
    message.ipc = (object.ipc !== undefined && object.ipc !== null)
      ? CMsgIPCAddress.fromPartial(object.ipc)
      : undefined;
    message.theyHearYou = object.theyHearYou ?? false;
    message.youHearThem = object.youHearThem ?? false;
    message.isListenserverHost = object.isListenserverHost ?? false;
    return message;
  },
};

function createBaseCSVCMsgPeerList(): CSVCMsgPeerList {
  return { peer: [] };
}

export const CSVCMsgPeerList = {
  encode(message: CSVCMsgPeerList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.peer) {
      CMsgServerPeer.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CSVCMsgPeerList {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCSVCMsgPeerList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.peer.push(CMsgServerPeer.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CSVCMsgPeerList {
    return {
      peer: globalThis.Array.isArray(object?.peer) ? object.peer.map((e: any) => CMsgServerPeer.fromJSON(e)) : [],
    };
  },

  toJSON(message: CSVCMsgPeerList): unknown {
    const obj: any = {};
    if (message.peer?.length) {
      obj.peer = message.peer.map((e) => CMsgServerPeer.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CSVCMsgPeerList>): CSVCMsgPeerList {
    return CSVCMsgPeerList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CSVCMsgPeerList>): CSVCMsgPeerList {
    const message = createBaseCSVCMsgPeerList();
    message.peer = object.peer?.map((e) => CMsgServerPeer.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCSVCMsgClearAllStringTables(): CSVCMsgClearAllStringTables {
  return { mapname: "", createTablesSkipped: false };
}

export const CSVCMsgClearAllStringTables = {
  encode(message: CSVCMsgClearAllStringTables, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.mapname !== undefined && message.mapname !== "") {
      writer.uint32(10).string(message.mapname);
    }
    if (message.createTablesSkipped !== undefined && message.createTablesSkipped !== false) {
      writer.uint32(24).bool(message.createTablesSkipped);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CSVCMsgClearAllStringTables {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCSVCMsgClearAllStringTables();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.mapname = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.createTablesSkipped = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CSVCMsgClearAllStringTables {
    return {
      mapname: isSet(object.mapname) ? globalThis.String(object.mapname) : "",
      createTablesSkipped: isSet(object.createTablesSkipped) ? globalThis.Boolean(object.createTablesSkipped) : false,
    };
  },

  toJSON(message: CSVCMsgClearAllStringTables): unknown {
    const obj: any = {};
    if (message.mapname !== undefined && message.mapname !== "") {
      obj.mapname = message.mapname;
    }
    if (message.createTablesSkipped !== undefined && message.createTablesSkipped !== false) {
      obj.createTablesSkipped = message.createTablesSkipped;
    }
    return obj;
  },

  create(base?: DeepPartial<CSVCMsgClearAllStringTables>): CSVCMsgClearAllStringTables {
    return CSVCMsgClearAllStringTables.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CSVCMsgClearAllStringTables>): CSVCMsgClearAllStringTables {
    const message = createBaseCSVCMsgClearAllStringTables();
    message.mapname = object.mapname ?? "";
    message.createTablesSkipped = object.createTablesSkipped ?? false;
    return message;
  },
};

function createBaseProtoFlattenedSerializerFieldT(): ProtoFlattenedSerializerFieldT {
  return {
    varTypeSym: 0,
    varNameSym: 0,
    bitCount: 0,
    lowValue: 0,
    highValue: 0,
    encodeFlags: 0,
    fieldSerializerNameSym: 0,
    fieldSerializerVersion: 0,
    sendNodeSym: 0,
    varEncoderSym: 0,
    polymorphicTypes: [],
    varSerializerSym: 0,
  };
}

export const ProtoFlattenedSerializerFieldT = {
  encode(message: ProtoFlattenedSerializerFieldT, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.varTypeSym !== undefined && message.varTypeSym !== 0) {
      writer.uint32(8).int32(message.varTypeSym);
    }
    if (message.varNameSym !== undefined && message.varNameSym !== 0) {
      writer.uint32(16).int32(message.varNameSym);
    }
    if (message.bitCount !== undefined && message.bitCount !== 0) {
      writer.uint32(24).int32(message.bitCount);
    }
    if (message.lowValue !== undefined && message.lowValue !== 0) {
      writer.uint32(37).float(message.lowValue);
    }
    if (message.highValue !== undefined && message.highValue !== 0) {
      writer.uint32(45).float(message.highValue);
    }
    if (message.encodeFlags !== undefined && message.encodeFlags !== 0) {
      writer.uint32(48).int32(message.encodeFlags);
    }
    if (message.fieldSerializerNameSym !== undefined && message.fieldSerializerNameSym !== 0) {
      writer.uint32(56).int32(message.fieldSerializerNameSym);
    }
    if (message.fieldSerializerVersion !== undefined && message.fieldSerializerVersion !== 0) {
      writer.uint32(64).int32(message.fieldSerializerVersion);
    }
    if (message.sendNodeSym !== undefined && message.sendNodeSym !== 0) {
      writer.uint32(72).int32(message.sendNodeSym);
    }
    if (message.varEncoderSym !== undefined && message.varEncoderSym !== 0) {
      writer.uint32(80).int32(message.varEncoderSym);
    }
    for (const v of message.polymorphicTypes) {
      ProtoFlattenedSerializerFieldT_polymorphicFieldT.encode(v!, writer.uint32(90).fork()).ldelim();
    }
    if (message.varSerializerSym !== undefined && message.varSerializerSym !== 0) {
      writer.uint32(96).int32(message.varSerializerSym);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ProtoFlattenedSerializerFieldT {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProtoFlattenedSerializerFieldT();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.varTypeSym = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.varNameSym = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.bitCount = reader.int32();
          continue;
        case 4:
          if (tag !== 37) {
            break;
          }

          message.lowValue = reader.float();
          continue;
        case 5:
          if (tag !== 45) {
            break;
          }

          message.highValue = reader.float();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.encodeFlags = reader.int32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.fieldSerializerNameSym = reader.int32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.fieldSerializerVersion = reader.int32();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.sendNodeSym = reader.int32();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.varEncoderSym = reader.int32();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.polymorphicTypes.push(
            ProtoFlattenedSerializerFieldT_polymorphicFieldT.decode(reader, reader.uint32()),
          );
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.varSerializerSym = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProtoFlattenedSerializerFieldT {
    return {
      varTypeSym: isSet(object.varTypeSym) ? globalThis.Number(object.varTypeSym) : 0,
      varNameSym: isSet(object.varNameSym) ? globalThis.Number(object.varNameSym) : 0,
      bitCount: isSet(object.bitCount) ? globalThis.Number(object.bitCount) : 0,
      lowValue: isSet(object.lowValue) ? globalThis.Number(object.lowValue) : 0,
      highValue: isSet(object.highValue) ? globalThis.Number(object.highValue) : 0,
      encodeFlags: isSet(object.encodeFlags) ? globalThis.Number(object.encodeFlags) : 0,
      fieldSerializerNameSym: isSet(object.fieldSerializerNameSym)
        ? globalThis.Number(object.fieldSerializerNameSym)
        : 0,
      fieldSerializerVersion: isSet(object.fieldSerializerVersion)
        ? globalThis.Number(object.fieldSerializerVersion)
        : 0,
      sendNodeSym: isSet(object.sendNodeSym) ? globalThis.Number(object.sendNodeSym) : 0,
      varEncoderSym: isSet(object.varEncoderSym) ? globalThis.Number(object.varEncoderSym) : 0,
      polymorphicTypes: globalThis.Array.isArray(object?.polymorphicTypes)
        ? object.polymorphicTypes.map((e: any) => ProtoFlattenedSerializerFieldT_polymorphicFieldT.fromJSON(e))
        : [],
      varSerializerSym: isSet(object.varSerializerSym) ? globalThis.Number(object.varSerializerSym) : 0,
    };
  },

  toJSON(message: ProtoFlattenedSerializerFieldT): unknown {
    const obj: any = {};
    if (message.varTypeSym !== undefined && message.varTypeSym !== 0) {
      obj.varTypeSym = Math.round(message.varTypeSym);
    }
    if (message.varNameSym !== undefined && message.varNameSym !== 0) {
      obj.varNameSym = Math.round(message.varNameSym);
    }
    if (message.bitCount !== undefined && message.bitCount !== 0) {
      obj.bitCount = Math.round(message.bitCount);
    }
    if (message.lowValue !== undefined && message.lowValue !== 0) {
      obj.lowValue = message.lowValue;
    }
    if (message.highValue !== undefined && message.highValue !== 0) {
      obj.highValue = message.highValue;
    }
    if (message.encodeFlags !== undefined && message.encodeFlags !== 0) {
      obj.encodeFlags = Math.round(message.encodeFlags);
    }
    if (message.fieldSerializerNameSym !== undefined && message.fieldSerializerNameSym !== 0) {
      obj.fieldSerializerNameSym = Math.round(message.fieldSerializerNameSym);
    }
    if (message.fieldSerializerVersion !== undefined && message.fieldSerializerVersion !== 0) {
      obj.fieldSerializerVersion = Math.round(message.fieldSerializerVersion);
    }
    if (message.sendNodeSym !== undefined && message.sendNodeSym !== 0) {
      obj.sendNodeSym = Math.round(message.sendNodeSym);
    }
    if (message.varEncoderSym !== undefined && message.varEncoderSym !== 0) {
      obj.varEncoderSym = Math.round(message.varEncoderSym);
    }
    if (message.polymorphicTypes?.length) {
      obj.polymorphicTypes = message.polymorphicTypes.map((e) =>
        ProtoFlattenedSerializerFieldT_polymorphicFieldT.toJSON(e)
      );
    }
    if (message.varSerializerSym !== undefined && message.varSerializerSym !== 0) {
      obj.varSerializerSym = Math.round(message.varSerializerSym);
    }
    return obj;
  },

  create(base?: DeepPartial<ProtoFlattenedSerializerFieldT>): ProtoFlattenedSerializerFieldT {
    return ProtoFlattenedSerializerFieldT.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProtoFlattenedSerializerFieldT>): ProtoFlattenedSerializerFieldT {
    const message = createBaseProtoFlattenedSerializerFieldT();
    message.varTypeSym = object.varTypeSym ?? 0;
    message.varNameSym = object.varNameSym ?? 0;
    message.bitCount = object.bitCount ?? 0;
    message.lowValue = object.lowValue ?? 0;
    message.highValue = object.highValue ?? 0;
    message.encodeFlags = object.encodeFlags ?? 0;
    message.fieldSerializerNameSym = object.fieldSerializerNameSym ?? 0;
    message.fieldSerializerVersion = object.fieldSerializerVersion ?? 0;
    message.sendNodeSym = object.sendNodeSym ?? 0;
    message.varEncoderSym = object.varEncoderSym ?? 0;
    message.polymorphicTypes =
      object.polymorphicTypes?.map((e) => ProtoFlattenedSerializerFieldT_polymorphicFieldT.fromPartial(e)) || [];
    message.varSerializerSym = object.varSerializerSym ?? 0;
    return message;
  },
};

function createBaseProtoFlattenedSerializerFieldT_polymorphicFieldT(): ProtoFlattenedSerializerFieldT_polymorphicFieldT {
  return { polymorphicFieldSerializerNameSym: 0, polymorphicFieldSerializerVersion: 0 };
}

export const ProtoFlattenedSerializerFieldT_polymorphicFieldT = {
  encode(
    message: ProtoFlattenedSerializerFieldT_polymorphicFieldT,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.polymorphicFieldSerializerNameSym !== undefined && message.polymorphicFieldSerializerNameSym !== 0) {
      writer.uint32(8).int32(message.polymorphicFieldSerializerNameSym);
    }
    if (message.polymorphicFieldSerializerVersion !== undefined && message.polymorphicFieldSerializerVersion !== 0) {
      writer.uint32(16).int32(message.polymorphicFieldSerializerVersion);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ProtoFlattenedSerializerFieldT_polymorphicFieldT {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProtoFlattenedSerializerFieldT_polymorphicFieldT();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.polymorphicFieldSerializerNameSym = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.polymorphicFieldSerializerVersion = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProtoFlattenedSerializerFieldT_polymorphicFieldT {
    return {
      polymorphicFieldSerializerNameSym: isSet(object.polymorphicFieldSerializerNameSym)
        ? globalThis.Number(object.polymorphicFieldSerializerNameSym)
        : 0,
      polymorphicFieldSerializerVersion: isSet(object.polymorphicFieldSerializerVersion)
        ? globalThis.Number(object.polymorphicFieldSerializerVersion)
        : 0,
    };
  },

  toJSON(message: ProtoFlattenedSerializerFieldT_polymorphicFieldT): unknown {
    const obj: any = {};
    if (message.polymorphicFieldSerializerNameSym !== undefined && message.polymorphicFieldSerializerNameSym !== 0) {
      obj.polymorphicFieldSerializerNameSym = Math.round(message.polymorphicFieldSerializerNameSym);
    }
    if (message.polymorphicFieldSerializerVersion !== undefined && message.polymorphicFieldSerializerVersion !== 0) {
      obj.polymorphicFieldSerializerVersion = Math.round(message.polymorphicFieldSerializerVersion);
    }
    return obj;
  },

  create(
    base?: DeepPartial<ProtoFlattenedSerializerFieldT_polymorphicFieldT>,
  ): ProtoFlattenedSerializerFieldT_polymorphicFieldT {
    return ProtoFlattenedSerializerFieldT_polymorphicFieldT.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<ProtoFlattenedSerializerFieldT_polymorphicFieldT>,
  ): ProtoFlattenedSerializerFieldT_polymorphicFieldT {
    const message = createBaseProtoFlattenedSerializerFieldT_polymorphicFieldT();
    message.polymorphicFieldSerializerNameSym = object.polymorphicFieldSerializerNameSym ?? 0;
    message.polymorphicFieldSerializerVersion = object.polymorphicFieldSerializerVersion ?? 0;
    return message;
  },
};

function createBaseProtoFlattenedSerializerT(): ProtoFlattenedSerializerT {
  return { serializerNameSym: 0, serializerVersion: 0, fieldsIndex: [] };
}

export const ProtoFlattenedSerializerT = {
  encode(message: ProtoFlattenedSerializerT, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.serializerNameSym !== undefined && message.serializerNameSym !== 0) {
      writer.uint32(8).int32(message.serializerNameSym);
    }
    if (message.serializerVersion !== undefined && message.serializerVersion !== 0) {
      writer.uint32(16).int32(message.serializerVersion);
    }
    writer.uint32(26).fork();
    for (const v of message.fieldsIndex) {
      writer.int32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ProtoFlattenedSerializerT {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProtoFlattenedSerializerT();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.serializerNameSym = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.serializerVersion = reader.int32();
          continue;
        case 3:
          if (tag === 24) {
            message.fieldsIndex.push(reader.int32());

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.fieldsIndex.push(reader.int32());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProtoFlattenedSerializerT {
    return {
      serializerNameSym: isSet(object.serializerNameSym) ? globalThis.Number(object.serializerNameSym) : 0,
      serializerVersion: isSet(object.serializerVersion) ? globalThis.Number(object.serializerVersion) : 0,
      fieldsIndex: globalThis.Array.isArray(object?.fieldsIndex)
        ? object.fieldsIndex.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: ProtoFlattenedSerializerT): unknown {
    const obj: any = {};
    if (message.serializerNameSym !== undefined && message.serializerNameSym !== 0) {
      obj.serializerNameSym = Math.round(message.serializerNameSym);
    }
    if (message.serializerVersion !== undefined && message.serializerVersion !== 0) {
      obj.serializerVersion = Math.round(message.serializerVersion);
    }
    if (message.fieldsIndex?.length) {
      obj.fieldsIndex = message.fieldsIndex.map((e) => Math.round(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ProtoFlattenedSerializerT>): ProtoFlattenedSerializerT {
    return ProtoFlattenedSerializerT.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProtoFlattenedSerializerT>): ProtoFlattenedSerializerT {
    const message = createBaseProtoFlattenedSerializerT();
    message.serializerNameSym = object.serializerNameSym ?? 0;
    message.serializerVersion = object.serializerVersion ?? 0;
    message.fieldsIndex = object.fieldsIndex?.map((e) => e) || [];
    return message;
  },
};

function createBaseCSVCMsgFlattenedSerializer(): CSVCMsgFlattenedSerializer {
  return { serializers: [], symbols: [], fields: [] };
}

export const CSVCMsgFlattenedSerializer = {
  encode(message: CSVCMsgFlattenedSerializer, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.serializers) {
      ProtoFlattenedSerializerT.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.symbols) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.fields) {
      ProtoFlattenedSerializerFieldT.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CSVCMsgFlattenedSerializer {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCSVCMsgFlattenedSerializer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.serializers.push(ProtoFlattenedSerializerT.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.symbols.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.fields.push(ProtoFlattenedSerializerFieldT.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CSVCMsgFlattenedSerializer {
    return {
      serializers: globalThis.Array.isArray(object?.serializers)
        ? object.serializers.map((e: any) => ProtoFlattenedSerializerT.fromJSON(e))
        : [],
      symbols: globalThis.Array.isArray(object?.symbols) ? object.symbols.map((e: any) => globalThis.String(e)) : [],
      fields: globalThis.Array.isArray(object?.fields)
        ? object.fields.map((e: any) => ProtoFlattenedSerializerFieldT.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CSVCMsgFlattenedSerializer): unknown {
    const obj: any = {};
    if (message.serializers?.length) {
      obj.serializers = message.serializers.map((e) => ProtoFlattenedSerializerT.toJSON(e));
    }
    if (message.symbols?.length) {
      obj.symbols = message.symbols;
    }
    if (message.fields?.length) {
      obj.fields = message.fields.map((e) => ProtoFlattenedSerializerFieldT.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CSVCMsgFlattenedSerializer>): CSVCMsgFlattenedSerializer {
    return CSVCMsgFlattenedSerializer.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CSVCMsgFlattenedSerializer>): CSVCMsgFlattenedSerializer {
    const message = createBaseCSVCMsgFlattenedSerializer();
    message.serializers = object.serializers?.map((e) => ProtoFlattenedSerializerT.fromPartial(e)) || [];
    message.symbols = object.symbols?.map((e) => e) || [];
    message.fields = object.fields?.map((e) => ProtoFlattenedSerializerFieldT.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCSVCMsgStopSound(): CSVCMsgStopSound {
  return { guid: 0 };
}

export const CSVCMsgStopSound = {
  encode(message: CSVCMsgStopSound, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.guid !== undefined && message.guid !== 0) {
      writer.uint32(13).fixed32(message.guid);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CSVCMsgStopSound {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCSVCMsgStopSound();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.guid = reader.fixed32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CSVCMsgStopSound {
    return { guid: isSet(object.guid) ? globalThis.Number(object.guid) : 0 };
  },

  toJSON(message: CSVCMsgStopSound): unknown {
    const obj: any = {};
    if (message.guid !== undefined && message.guid !== 0) {
      obj.guid = Math.round(message.guid);
    }
    return obj;
  },

  create(base?: DeepPartial<CSVCMsgStopSound>): CSVCMsgStopSound {
    return CSVCMsgStopSound.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CSVCMsgStopSound>): CSVCMsgStopSound {
    const message = createBaseCSVCMsgStopSound();
    message.guid = object.guid ?? 0;
    return message;
  },
};

function createBaseCBidirMsgRebroadcastGameEvent(): CBidirMsgRebroadcastGameEvent {
  return { posttoserver: false, buftype: 0, clientbitcount: 0, receivingclients: "0" };
}

export const CBidirMsgRebroadcastGameEvent = {
  encode(message: CBidirMsgRebroadcastGameEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.posttoserver !== undefined && message.posttoserver !== false) {
      writer.uint32(8).bool(message.posttoserver);
    }
    if (message.buftype !== undefined && message.buftype !== 0) {
      writer.uint32(16).int32(message.buftype);
    }
    if (message.clientbitcount !== undefined && message.clientbitcount !== 0) {
      writer.uint32(24).uint32(message.clientbitcount);
    }
    if (message.receivingclients !== undefined && message.receivingclients !== "0") {
      writer.uint32(32).uint64(message.receivingclients);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CBidirMsgRebroadcastGameEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCBidirMsgRebroadcastGameEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.posttoserver = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.buftype = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.clientbitcount = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.receivingclients = longToString(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CBidirMsgRebroadcastGameEvent {
    return {
      posttoserver: isSet(object.posttoserver) ? globalThis.Boolean(object.posttoserver) : false,
      buftype: isSet(object.buftype) ? globalThis.Number(object.buftype) : 0,
      clientbitcount: isSet(object.clientbitcount) ? globalThis.Number(object.clientbitcount) : 0,
      receivingclients: isSet(object.receivingclients) ? globalThis.String(object.receivingclients) : "0",
    };
  },

  toJSON(message: CBidirMsgRebroadcastGameEvent): unknown {
    const obj: any = {};
    if (message.posttoserver !== undefined && message.posttoserver !== false) {
      obj.posttoserver = message.posttoserver;
    }
    if (message.buftype !== undefined && message.buftype !== 0) {
      obj.buftype = Math.round(message.buftype);
    }
    if (message.clientbitcount !== undefined && message.clientbitcount !== 0) {
      obj.clientbitcount = Math.round(message.clientbitcount);
    }
    if (message.receivingclients !== undefined && message.receivingclients !== "0") {
      obj.receivingclients = message.receivingclients;
    }
    return obj;
  },

  create(base?: DeepPartial<CBidirMsgRebroadcastGameEvent>): CBidirMsgRebroadcastGameEvent {
    return CBidirMsgRebroadcastGameEvent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CBidirMsgRebroadcastGameEvent>): CBidirMsgRebroadcastGameEvent {
    const message = createBaseCBidirMsgRebroadcastGameEvent();
    message.posttoserver = object.posttoserver ?? false;
    message.buftype = object.buftype ?? 0;
    message.clientbitcount = object.clientbitcount ?? 0;
    message.receivingclients = object.receivingclients ?? "0";
    return message;
  },
};

function createBaseCBidirMsgRebroadcastSource(): CBidirMsgRebroadcastSource {
  return { eventsource: 0 };
}

export const CBidirMsgRebroadcastSource = {
  encode(message: CBidirMsgRebroadcastSource, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.eventsource !== undefined && message.eventsource !== 0) {
      writer.uint32(8).int32(message.eventsource);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CBidirMsgRebroadcastSource {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCBidirMsgRebroadcastSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.eventsource = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CBidirMsgRebroadcastSource {
    return { eventsource: isSet(object.eventsource) ? globalThis.Number(object.eventsource) : 0 };
  },

  toJSON(message: CBidirMsgRebroadcastSource): unknown {
    const obj: any = {};
    if (message.eventsource !== undefined && message.eventsource !== 0) {
      obj.eventsource = Math.round(message.eventsource);
    }
    return obj;
  },

  create(base?: DeepPartial<CBidirMsgRebroadcastSource>): CBidirMsgRebroadcastSource {
    return CBidirMsgRebroadcastSource.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CBidirMsgRebroadcastSource>): CBidirMsgRebroadcastSource {
    const message = createBaseCBidirMsgRebroadcastSource();
    message.eventsource = object.eventsource ?? 0;
    return message;
  },
};

function createBaseCBidirMsgPredictionEvent(): CBidirMsgPredictionEvent {
  return { eventId: 0, eventData: Buffer.alloc(0), syncType: 0, syncValUint32: 0 };
}

export const CBidirMsgPredictionEvent = {
  encode(message: CBidirMsgPredictionEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.eventId !== 0) {
      writer.uint32(8).uint32(message.eventId);
    }
    if (message.eventData.length !== 0) {
      writer.uint32(18).bytes(message.eventData);
    }
    if (message.syncType !== undefined && message.syncType !== 0) {
      writer.uint32(24).uint32(message.syncType);
    }
    if (message.syncValUint32 !== undefined && message.syncValUint32 !== 0) {
      writer.uint32(32).uint32(message.syncValUint32);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CBidirMsgPredictionEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCBidirMsgPredictionEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.eventId = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.eventData = reader.bytes() as Buffer;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.syncType = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.syncValUint32 = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CBidirMsgPredictionEvent {
    return {
      eventId: isSet(object.eventId) ? globalThis.Number(object.eventId) : 0,
      eventData: isSet(object.eventData) ? Buffer.from(bytesFromBase64(object.eventData)) : Buffer.alloc(0),
      syncType: isSet(object.syncType) ? globalThis.Number(object.syncType) : 0,
      syncValUint32: isSet(object.syncValUint32) ? globalThis.Number(object.syncValUint32) : 0,
    };
  },

  toJSON(message: CBidirMsgPredictionEvent): unknown {
    const obj: any = {};
    if (message.eventId !== 0) {
      obj.eventId = Math.round(message.eventId);
    }
    if (message.eventData.length !== 0) {
      obj.eventData = base64FromBytes(message.eventData);
    }
    if (message.syncType !== undefined && message.syncType !== 0) {
      obj.syncType = Math.round(message.syncType);
    }
    if (message.syncValUint32 !== undefined && message.syncValUint32 !== 0) {
      obj.syncValUint32 = Math.round(message.syncValUint32);
    }
    return obj;
  },

  create(base?: DeepPartial<CBidirMsgPredictionEvent>): CBidirMsgPredictionEvent {
    return CBidirMsgPredictionEvent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CBidirMsgPredictionEvent>): CBidirMsgPredictionEvent {
    const message = createBaseCBidirMsgPredictionEvent();
    message.eventId = object.eventId ?? 0;
    message.eventData = object.eventData ?? Buffer.alloc(0);
    message.syncType = object.syncType ?? 0;
    message.syncValUint32 = object.syncValUint32 ?? 0;
    return message;
  },
};

function createBaseCMsgServerNetworkStats(): CMsgServerNetworkStats {
  return {
    dedicated: false,
    cpuUsage: 0,
    memoryUsedMb: 0,
    memoryFreeMb: 0,
    uptime: 0,
    spawnCount: 0,
    numClients: 0,
    numBots: 0,
    numSpectators: 0,
    numTvRelays: 0,
    fps: 0,
    ports: [],
    avgPingMs: 0,
    avgEngineLatencyOut: 0,
    avgPacketsOut: 0,
    avgPacketsIn: 0,
    avgLossOut: 0,
    avgLossIn: 0,
    avgDataOut: 0,
    avgDataIn: 0,
    totalDataIn: "0",
    totalPacketsIn: "0",
    totalDataOut: "0",
    totalPacketsOut: "0",
    players: [],
  };
}

export const CMsgServerNetworkStats = {
  encode(message: CMsgServerNetworkStats, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.dedicated !== undefined && message.dedicated !== false) {
      writer.uint32(8).bool(message.dedicated);
    }
    if (message.cpuUsage !== undefined && message.cpuUsage !== 0) {
      writer.uint32(16).int32(message.cpuUsage);
    }
    if (message.memoryUsedMb !== undefined && message.memoryUsedMb !== 0) {
      writer.uint32(24).int32(message.memoryUsedMb);
    }
    if (message.memoryFreeMb !== undefined && message.memoryFreeMb !== 0) {
      writer.uint32(32).int32(message.memoryFreeMb);
    }
    if (message.uptime !== undefined && message.uptime !== 0) {
      writer.uint32(40).int32(message.uptime);
    }
    if (message.spawnCount !== undefined && message.spawnCount !== 0) {
      writer.uint32(48).int32(message.spawnCount);
    }
    if (message.numClients !== undefined && message.numClients !== 0) {
      writer.uint32(64).int32(message.numClients);
    }
    if (message.numBots !== undefined && message.numBots !== 0) {
      writer.uint32(72).int32(message.numBots);
    }
    if (message.numSpectators !== undefined && message.numSpectators !== 0) {
      writer.uint32(80).int32(message.numSpectators);
    }
    if (message.numTvRelays !== undefined && message.numTvRelays !== 0) {
      writer.uint32(88).int32(message.numTvRelays);
    }
    if (message.fps !== undefined && message.fps !== 0) {
      writer.uint32(101).float(message.fps);
    }
    for (const v of message.ports) {
      CMsgServerNetworkStats_Port.encode(v!, writer.uint32(138).fork()).ldelim();
    }
    if (message.avgPingMs !== undefined && message.avgPingMs !== 0) {
      writer.uint32(149).float(message.avgPingMs);
    }
    if (message.avgEngineLatencyOut !== undefined && message.avgEngineLatencyOut !== 0) {
      writer.uint32(157).float(message.avgEngineLatencyOut);
    }
    if (message.avgPacketsOut !== undefined && message.avgPacketsOut !== 0) {
      writer.uint32(165).float(message.avgPacketsOut);
    }
    if (message.avgPacketsIn !== undefined && message.avgPacketsIn !== 0) {
      writer.uint32(173).float(message.avgPacketsIn);
    }
    if (message.avgLossOut !== undefined && message.avgLossOut !== 0) {
      writer.uint32(181).float(message.avgLossOut);
    }
    if (message.avgLossIn !== undefined && message.avgLossIn !== 0) {
      writer.uint32(189).float(message.avgLossIn);
    }
    if (message.avgDataOut !== undefined && message.avgDataOut !== 0) {
      writer.uint32(197).float(message.avgDataOut);
    }
    if (message.avgDataIn !== undefined && message.avgDataIn !== 0) {
      writer.uint32(205).float(message.avgDataIn);
    }
    if (message.totalDataIn !== undefined && message.totalDataIn !== "0") {
      writer.uint32(208).uint64(message.totalDataIn);
    }
    if (message.totalPacketsIn !== undefined && message.totalPacketsIn !== "0") {
      writer.uint32(216).uint64(message.totalPacketsIn);
    }
    if (message.totalDataOut !== undefined && message.totalDataOut !== "0") {
      writer.uint32(224).uint64(message.totalDataOut);
    }
    if (message.totalPacketsOut !== undefined && message.totalPacketsOut !== "0") {
      writer.uint32(232).uint64(message.totalPacketsOut);
    }
    for (const v of message.players) {
      CMsgServerNetworkStats_Player.encode(v!, writer.uint32(242).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgServerNetworkStats {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgServerNetworkStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.dedicated = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.cpuUsage = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.memoryUsedMb = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.memoryFreeMb = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.uptime = reader.int32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.spawnCount = reader.int32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.numClients = reader.int32();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.numBots = reader.int32();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.numSpectators = reader.int32();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.numTvRelays = reader.int32();
          continue;
        case 12:
          if (tag !== 101) {
            break;
          }

          message.fps = reader.float();
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.ports.push(CMsgServerNetworkStats_Port.decode(reader, reader.uint32()));
          continue;
        case 18:
          if (tag !== 149) {
            break;
          }

          message.avgPingMs = reader.float();
          continue;
        case 19:
          if (tag !== 157) {
            break;
          }

          message.avgEngineLatencyOut = reader.float();
          continue;
        case 20:
          if (tag !== 165) {
            break;
          }

          message.avgPacketsOut = reader.float();
          continue;
        case 21:
          if (tag !== 173) {
            break;
          }

          message.avgPacketsIn = reader.float();
          continue;
        case 22:
          if (tag !== 181) {
            break;
          }

          message.avgLossOut = reader.float();
          continue;
        case 23:
          if (tag !== 189) {
            break;
          }

          message.avgLossIn = reader.float();
          continue;
        case 24:
          if (tag !== 197) {
            break;
          }

          message.avgDataOut = reader.float();
          continue;
        case 25:
          if (tag !== 205) {
            break;
          }

          message.avgDataIn = reader.float();
          continue;
        case 26:
          if (tag !== 208) {
            break;
          }

          message.totalDataIn = longToString(reader.uint64() as Long);
          continue;
        case 27:
          if (tag !== 216) {
            break;
          }

          message.totalPacketsIn = longToString(reader.uint64() as Long);
          continue;
        case 28:
          if (tag !== 224) {
            break;
          }

          message.totalDataOut = longToString(reader.uint64() as Long);
          continue;
        case 29:
          if (tag !== 232) {
            break;
          }

          message.totalPacketsOut = longToString(reader.uint64() as Long);
          continue;
        case 30:
          if (tag !== 242) {
            break;
          }

          message.players.push(CMsgServerNetworkStats_Player.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgServerNetworkStats {
    return {
      dedicated: isSet(object.dedicated) ? globalThis.Boolean(object.dedicated) : false,
      cpuUsage: isSet(object.cpuUsage) ? globalThis.Number(object.cpuUsage) : 0,
      memoryUsedMb: isSet(object.memoryUsedMb) ? globalThis.Number(object.memoryUsedMb) : 0,
      memoryFreeMb: isSet(object.memoryFreeMb) ? globalThis.Number(object.memoryFreeMb) : 0,
      uptime: isSet(object.uptime) ? globalThis.Number(object.uptime) : 0,
      spawnCount: isSet(object.spawnCount) ? globalThis.Number(object.spawnCount) : 0,
      numClients: isSet(object.numClients) ? globalThis.Number(object.numClients) : 0,
      numBots: isSet(object.numBots) ? globalThis.Number(object.numBots) : 0,
      numSpectators: isSet(object.numSpectators) ? globalThis.Number(object.numSpectators) : 0,
      numTvRelays: isSet(object.numTvRelays) ? globalThis.Number(object.numTvRelays) : 0,
      fps: isSet(object.fps) ? globalThis.Number(object.fps) : 0,
      ports: globalThis.Array.isArray(object?.ports)
        ? object.ports.map((e: any) => CMsgServerNetworkStats_Port.fromJSON(e))
        : [],
      avgPingMs: isSet(object.avgPingMs) ? globalThis.Number(object.avgPingMs) : 0,
      avgEngineLatencyOut: isSet(object.avgEngineLatencyOut) ? globalThis.Number(object.avgEngineLatencyOut) : 0,
      avgPacketsOut: isSet(object.avgPacketsOut) ? globalThis.Number(object.avgPacketsOut) : 0,
      avgPacketsIn: isSet(object.avgPacketsIn) ? globalThis.Number(object.avgPacketsIn) : 0,
      avgLossOut: isSet(object.avgLossOut) ? globalThis.Number(object.avgLossOut) : 0,
      avgLossIn: isSet(object.avgLossIn) ? globalThis.Number(object.avgLossIn) : 0,
      avgDataOut: isSet(object.avgDataOut) ? globalThis.Number(object.avgDataOut) : 0,
      avgDataIn: isSet(object.avgDataIn) ? globalThis.Number(object.avgDataIn) : 0,
      totalDataIn: isSet(object.totalDataIn) ? globalThis.String(object.totalDataIn) : "0",
      totalPacketsIn: isSet(object.totalPacketsIn) ? globalThis.String(object.totalPacketsIn) : "0",
      totalDataOut: isSet(object.totalDataOut) ? globalThis.String(object.totalDataOut) : "0",
      totalPacketsOut: isSet(object.totalPacketsOut) ? globalThis.String(object.totalPacketsOut) : "0",
      players: globalThis.Array.isArray(object?.players)
        ? object.players.map((e: any) => CMsgServerNetworkStats_Player.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgServerNetworkStats): unknown {
    const obj: any = {};
    if (message.dedicated !== undefined && message.dedicated !== false) {
      obj.dedicated = message.dedicated;
    }
    if (message.cpuUsage !== undefined && message.cpuUsage !== 0) {
      obj.cpuUsage = Math.round(message.cpuUsage);
    }
    if (message.memoryUsedMb !== undefined && message.memoryUsedMb !== 0) {
      obj.memoryUsedMb = Math.round(message.memoryUsedMb);
    }
    if (message.memoryFreeMb !== undefined && message.memoryFreeMb !== 0) {
      obj.memoryFreeMb = Math.round(message.memoryFreeMb);
    }
    if (message.uptime !== undefined && message.uptime !== 0) {
      obj.uptime = Math.round(message.uptime);
    }
    if (message.spawnCount !== undefined && message.spawnCount !== 0) {
      obj.spawnCount = Math.round(message.spawnCount);
    }
    if (message.numClients !== undefined && message.numClients !== 0) {
      obj.numClients = Math.round(message.numClients);
    }
    if (message.numBots !== undefined && message.numBots !== 0) {
      obj.numBots = Math.round(message.numBots);
    }
    if (message.numSpectators !== undefined && message.numSpectators !== 0) {
      obj.numSpectators = Math.round(message.numSpectators);
    }
    if (message.numTvRelays !== undefined && message.numTvRelays !== 0) {
      obj.numTvRelays = Math.round(message.numTvRelays);
    }
    if (message.fps !== undefined && message.fps !== 0) {
      obj.fps = message.fps;
    }
    if (message.ports?.length) {
      obj.ports = message.ports.map((e) => CMsgServerNetworkStats_Port.toJSON(e));
    }
    if (message.avgPingMs !== undefined && message.avgPingMs !== 0) {
      obj.avgPingMs = message.avgPingMs;
    }
    if (message.avgEngineLatencyOut !== undefined && message.avgEngineLatencyOut !== 0) {
      obj.avgEngineLatencyOut = message.avgEngineLatencyOut;
    }
    if (message.avgPacketsOut !== undefined && message.avgPacketsOut !== 0) {
      obj.avgPacketsOut = message.avgPacketsOut;
    }
    if (message.avgPacketsIn !== undefined && message.avgPacketsIn !== 0) {
      obj.avgPacketsIn = message.avgPacketsIn;
    }
    if (message.avgLossOut !== undefined && message.avgLossOut !== 0) {
      obj.avgLossOut = message.avgLossOut;
    }
    if (message.avgLossIn !== undefined && message.avgLossIn !== 0) {
      obj.avgLossIn = message.avgLossIn;
    }
    if (message.avgDataOut !== undefined && message.avgDataOut !== 0) {
      obj.avgDataOut = message.avgDataOut;
    }
    if (message.avgDataIn !== undefined && message.avgDataIn !== 0) {
      obj.avgDataIn = message.avgDataIn;
    }
    if (message.totalDataIn !== undefined && message.totalDataIn !== "0") {
      obj.totalDataIn = message.totalDataIn;
    }
    if (message.totalPacketsIn !== undefined && message.totalPacketsIn !== "0") {
      obj.totalPacketsIn = message.totalPacketsIn;
    }
    if (message.totalDataOut !== undefined && message.totalDataOut !== "0") {
      obj.totalDataOut = message.totalDataOut;
    }
    if (message.totalPacketsOut !== undefined && message.totalPacketsOut !== "0") {
      obj.totalPacketsOut = message.totalPacketsOut;
    }
    if (message.players?.length) {
      obj.players = message.players.map((e) => CMsgServerNetworkStats_Player.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgServerNetworkStats>): CMsgServerNetworkStats {
    return CMsgServerNetworkStats.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgServerNetworkStats>): CMsgServerNetworkStats {
    const message = createBaseCMsgServerNetworkStats();
    message.dedicated = object.dedicated ?? false;
    message.cpuUsage = object.cpuUsage ?? 0;
    message.memoryUsedMb = object.memoryUsedMb ?? 0;
    message.memoryFreeMb = object.memoryFreeMb ?? 0;
    message.uptime = object.uptime ?? 0;
    message.spawnCount = object.spawnCount ?? 0;
    message.numClients = object.numClients ?? 0;
    message.numBots = object.numBots ?? 0;
    message.numSpectators = object.numSpectators ?? 0;
    message.numTvRelays = object.numTvRelays ?? 0;
    message.fps = object.fps ?? 0;
    message.ports = object.ports?.map((e) => CMsgServerNetworkStats_Port.fromPartial(e)) || [];
    message.avgPingMs = object.avgPingMs ?? 0;
    message.avgEngineLatencyOut = object.avgEngineLatencyOut ?? 0;
    message.avgPacketsOut = object.avgPacketsOut ?? 0;
    message.avgPacketsIn = object.avgPacketsIn ?? 0;
    message.avgLossOut = object.avgLossOut ?? 0;
    message.avgLossIn = object.avgLossIn ?? 0;
    message.avgDataOut = object.avgDataOut ?? 0;
    message.avgDataIn = object.avgDataIn ?? 0;
    message.totalDataIn = object.totalDataIn ?? "0";
    message.totalPacketsIn = object.totalPacketsIn ?? "0";
    message.totalDataOut = object.totalDataOut ?? "0";
    message.totalPacketsOut = object.totalPacketsOut ?? "0";
    message.players = object.players?.map((e) => CMsgServerNetworkStats_Player.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgServerNetworkStats_Port(): CMsgServerNetworkStats_Port {
  return { port: 0, name: "" };
}

export const CMsgServerNetworkStats_Port = {
  encode(message: CMsgServerNetworkStats_Port, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.port !== undefined && message.port !== 0) {
      writer.uint32(8).int32(message.port);
    }
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgServerNetworkStats_Port {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgServerNetworkStats_Port();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.port = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgServerNetworkStats_Port {
    return {
      port: isSet(object.port) ? globalThis.Number(object.port) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: CMsgServerNetworkStats_Port): unknown {
    const obj: any = {};
    if (message.port !== undefined && message.port !== 0) {
      obj.port = Math.round(message.port);
    }
    if (message.name !== undefined && message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgServerNetworkStats_Port>): CMsgServerNetworkStats_Port {
    return CMsgServerNetworkStats_Port.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgServerNetworkStats_Port>): CMsgServerNetworkStats_Port {
    const message = createBaseCMsgServerNetworkStats_Port();
    message.port = object.port ?? 0;
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseCMsgServerNetworkStats_Player(): CMsgServerNetworkStats_Player {
  return {
    steamid: "0",
    remoteAddr: "",
    pingAvgMs: 0,
    packetLossPct: 0,
    isBot: false,
    lossIn: 0,
    lossOut: 0,
    engineLatencyMs: 0,
  };
}

export const CMsgServerNetworkStats_Player = {
  encode(message: CMsgServerNetworkStats_Player, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.steamid !== undefined && message.steamid !== "0") {
      writer.uint32(8).uint64(message.steamid);
    }
    if (message.remoteAddr !== undefined && message.remoteAddr !== "") {
      writer.uint32(18).string(message.remoteAddr);
    }
    if (message.pingAvgMs !== undefined && message.pingAvgMs !== 0) {
      writer.uint32(32).int32(message.pingAvgMs);
    }
    if (message.packetLossPct !== undefined && message.packetLossPct !== 0) {
      writer.uint32(45).float(message.packetLossPct);
    }
    if (message.isBot !== undefined && message.isBot !== false) {
      writer.uint32(48).bool(message.isBot);
    }
    if (message.lossIn !== undefined && message.lossIn !== 0) {
      writer.uint32(61).float(message.lossIn);
    }
    if (message.lossOut !== undefined && message.lossOut !== 0) {
      writer.uint32(69).float(message.lossOut);
    }
    if (message.engineLatencyMs !== undefined && message.engineLatencyMs !== 0) {
      writer.uint32(72).int32(message.engineLatencyMs);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgServerNetworkStats_Player {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgServerNetworkStats_Player();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.steamid = longToString(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.remoteAddr = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.pingAvgMs = reader.int32();
          continue;
        case 5:
          if (tag !== 45) {
            break;
          }

          message.packetLossPct = reader.float();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.isBot = reader.bool();
          continue;
        case 7:
          if (tag !== 61) {
            break;
          }

          message.lossIn = reader.float();
          continue;
        case 8:
          if (tag !== 69) {
            break;
          }

          message.lossOut = reader.float();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.engineLatencyMs = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgServerNetworkStats_Player {
    return {
      steamid: isSet(object.steamid) ? globalThis.String(object.steamid) : "0",
      remoteAddr: isSet(object.remoteAddr) ? globalThis.String(object.remoteAddr) : "",
      pingAvgMs: isSet(object.pingAvgMs) ? globalThis.Number(object.pingAvgMs) : 0,
      packetLossPct: isSet(object.packetLossPct) ? globalThis.Number(object.packetLossPct) : 0,
      isBot: isSet(object.isBot) ? globalThis.Boolean(object.isBot) : false,
      lossIn: isSet(object.lossIn) ? globalThis.Number(object.lossIn) : 0,
      lossOut: isSet(object.lossOut) ? globalThis.Number(object.lossOut) : 0,
      engineLatencyMs: isSet(object.engineLatencyMs) ? globalThis.Number(object.engineLatencyMs) : 0,
    };
  },

  toJSON(message: CMsgServerNetworkStats_Player): unknown {
    const obj: any = {};
    if (message.steamid !== undefined && message.steamid !== "0") {
      obj.steamid = message.steamid;
    }
    if (message.remoteAddr !== undefined && message.remoteAddr !== "") {
      obj.remoteAddr = message.remoteAddr;
    }
    if (message.pingAvgMs !== undefined && message.pingAvgMs !== 0) {
      obj.pingAvgMs = Math.round(message.pingAvgMs);
    }
    if (message.packetLossPct !== undefined && message.packetLossPct !== 0) {
      obj.packetLossPct = message.packetLossPct;
    }
    if (message.isBot !== undefined && message.isBot !== false) {
      obj.isBot = message.isBot;
    }
    if (message.lossIn !== undefined && message.lossIn !== 0) {
      obj.lossIn = message.lossIn;
    }
    if (message.lossOut !== undefined && message.lossOut !== 0) {
      obj.lossOut = message.lossOut;
    }
    if (message.engineLatencyMs !== undefined && message.engineLatencyMs !== 0) {
      obj.engineLatencyMs = Math.round(message.engineLatencyMs);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgServerNetworkStats_Player>): CMsgServerNetworkStats_Player {
    return CMsgServerNetworkStats_Player.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgServerNetworkStats_Player>): CMsgServerNetworkStats_Player {
    const message = createBaseCMsgServerNetworkStats_Player();
    message.steamid = object.steamid ?? "0";
    message.remoteAddr = object.remoteAddr ?? "";
    message.pingAvgMs = object.pingAvgMs ?? 0;
    message.packetLossPct = object.packetLossPct ?? 0;
    message.isBot = object.isBot ?? false;
    message.lossIn = object.lossIn ?? 0;
    message.lossOut = object.lossOut ?? 0;
    message.engineLatencyMs = object.engineLatencyMs ?? 0;
    return message;
  },
};

function createBaseCSVCMsgHltvReplay(): CSVCMsgHltvReplay {
  return {
    delay: 0,
    primaryTarget: -1,
    replayStopAt: 0,
    replayStartAt: 0,
    replaySlowdownBegin: 0,
    replaySlowdownEnd: 0,
    replaySlowdownRate: 0,
    reason: 0,
  };
}

export const CSVCMsgHltvReplay = {
  encode(message: CSVCMsgHltvReplay, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.delay !== undefined && message.delay !== 0) {
      writer.uint32(8).int32(message.delay);
    }
    if (message.primaryTarget !== undefined && message.primaryTarget !== -1) {
      writer.uint32(16).int32(message.primaryTarget);
    }
    if (message.replayStopAt !== undefined && message.replayStopAt !== 0) {
      writer.uint32(24).int32(message.replayStopAt);
    }
    if (message.replayStartAt !== undefined && message.replayStartAt !== 0) {
      writer.uint32(32).int32(message.replayStartAt);
    }
    if (message.replaySlowdownBegin !== undefined && message.replaySlowdownBegin !== 0) {
      writer.uint32(40).int32(message.replaySlowdownBegin);
    }
    if (message.replaySlowdownEnd !== undefined && message.replaySlowdownEnd !== 0) {
      writer.uint32(48).int32(message.replaySlowdownEnd);
    }
    if (message.replaySlowdownRate !== undefined && message.replaySlowdownRate !== 0) {
      writer.uint32(61).float(message.replaySlowdownRate);
    }
    if (message.reason !== undefined && message.reason !== 0) {
      writer.uint32(64).int32(message.reason);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CSVCMsgHltvReplay {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCSVCMsgHltvReplay();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.delay = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.primaryTarget = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.replayStopAt = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.replayStartAt = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.replaySlowdownBegin = reader.int32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.replaySlowdownEnd = reader.int32();
          continue;
        case 7:
          if (tag !== 61) {
            break;
          }

          message.replaySlowdownRate = reader.float();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.reason = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CSVCMsgHltvReplay {
    return {
      delay: isSet(object.delay) ? globalThis.Number(object.delay) : 0,
      primaryTarget: isSet(object.primaryTarget) ? globalThis.Number(object.primaryTarget) : -1,
      replayStopAt: isSet(object.replayStopAt) ? globalThis.Number(object.replayStopAt) : 0,
      replayStartAt: isSet(object.replayStartAt) ? globalThis.Number(object.replayStartAt) : 0,
      replaySlowdownBegin: isSet(object.replaySlowdownBegin) ? globalThis.Number(object.replaySlowdownBegin) : 0,
      replaySlowdownEnd: isSet(object.replaySlowdownEnd) ? globalThis.Number(object.replaySlowdownEnd) : 0,
      replaySlowdownRate: isSet(object.replaySlowdownRate) ? globalThis.Number(object.replaySlowdownRate) : 0,
      reason: isSet(object.reason) ? globalThis.Number(object.reason) : 0,
    };
  },

  toJSON(message: CSVCMsgHltvReplay): unknown {
    const obj: any = {};
    if (message.delay !== undefined && message.delay !== 0) {
      obj.delay = Math.round(message.delay);
    }
    if (message.primaryTarget !== undefined && message.primaryTarget !== -1) {
      obj.primaryTarget = Math.round(message.primaryTarget);
    }
    if (message.replayStopAt !== undefined && message.replayStopAt !== 0) {
      obj.replayStopAt = Math.round(message.replayStopAt);
    }
    if (message.replayStartAt !== undefined && message.replayStartAt !== 0) {
      obj.replayStartAt = Math.round(message.replayStartAt);
    }
    if (message.replaySlowdownBegin !== undefined && message.replaySlowdownBegin !== 0) {
      obj.replaySlowdownBegin = Math.round(message.replaySlowdownBegin);
    }
    if (message.replaySlowdownEnd !== undefined && message.replaySlowdownEnd !== 0) {
      obj.replaySlowdownEnd = Math.round(message.replaySlowdownEnd);
    }
    if (message.replaySlowdownRate !== undefined && message.replaySlowdownRate !== 0) {
      obj.replaySlowdownRate = message.replaySlowdownRate;
    }
    if (message.reason !== undefined && message.reason !== 0) {
      obj.reason = Math.round(message.reason);
    }
    return obj;
  },

  create(base?: DeepPartial<CSVCMsgHltvReplay>): CSVCMsgHltvReplay {
    return CSVCMsgHltvReplay.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CSVCMsgHltvReplay>): CSVCMsgHltvReplay {
    const message = createBaseCSVCMsgHltvReplay();
    message.delay = object.delay ?? 0;
    message.primaryTarget = object.primaryTarget ?? -1;
    message.replayStopAt = object.replayStopAt ?? 0;
    message.replayStartAt = object.replayStartAt ?? 0;
    message.replaySlowdownBegin = object.replaySlowdownBegin ?? 0;
    message.replaySlowdownEnd = object.replaySlowdownEnd ?? 0;
    message.replaySlowdownRate = object.replaySlowdownRate ?? 0;
    message.reason = object.reason ?? 0;
    return message;
  },
};

function createBaseCCLCMsgHltvReplay(): CCLCMsgHltvReplay {
  return { request: 0, slowdownLength: 0, slowdownRate: 0, primaryTarget: -1, eventTime: 0 };
}

export const CCLCMsgHltvReplay = {
  encode(message: CCLCMsgHltvReplay, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.request !== undefined && message.request !== 0) {
      writer.uint32(8).int32(message.request);
    }
    if (message.slowdownLength !== undefined && message.slowdownLength !== 0) {
      writer.uint32(21).float(message.slowdownLength);
    }
    if (message.slowdownRate !== undefined && message.slowdownRate !== 0) {
      writer.uint32(29).float(message.slowdownRate);
    }
    if (message.primaryTarget !== undefined && message.primaryTarget !== -1) {
      writer.uint32(32).int32(message.primaryTarget);
    }
    if (message.eventTime !== undefined && message.eventTime !== 0) {
      writer.uint32(45).float(message.eventTime);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CCLCMsgHltvReplay {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCCLCMsgHltvReplay();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.request = reader.int32();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.slowdownLength = reader.float();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.slowdownRate = reader.float();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.primaryTarget = reader.int32();
          continue;
        case 5:
          if (tag !== 45) {
            break;
          }

          message.eventTime = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CCLCMsgHltvReplay {
    return {
      request: isSet(object.request) ? globalThis.Number(object.request) : 0,
      slowdownLength: isSet(object.slowdownLength) ? globalThis.Number(object.slowdownLength) : 0,
      slowdownRate: isSet(object.slowdownRate) ? globalThis.Number(object.slowdownRate) : 0,
      primaryTarget: isSet(object.primaryTarget) ? globalThis.Number(object.primaryTarget) : -1,
      eventTime: isSet(object.eventTime) ? globalThis.Number(object.eventTime) : 0,
    };
  },

  toJSON(message: CCLCMsgHltvReplay): unknown {
    const obj: any = {};
    if (message.request !== undefined && message.request !== 0) {
      obj.request = Math.round(message.request);
    }
    if (message.slowdownLength !== undefined && message.slowdownLength !== 0) {
      obj.slowdownLength = message.slowdownLength;
    }
    if (message.slowdownRate !== undefined && message.slowdownRate !== 0) {
      obj.slowdownRate = message.slowdownRate;
    }
    if (message.primaryTarget !== undefined && message.primaryTarget !== -1) {
      obj.primaryTarget = Math.round(message.primaryTarget);
    }
    if (message.eventTime !== undefined && message.eventTime !== 0) {
      obj.eventTime = message.eventTime;
    }
    return obj;
  },

  create(base?: DeepPartial<CCLCMsgHltvReplay>): CCLCMsgHltvReplay {
    return CCLCMsgHltvReplay.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CCLCMsgHltvReplay>): CCLCMsgHltvReplay {
    const message = createBaseCCLCMsgHltvReplay();
    message.request = object.request ?? 0;
    message.slowdownLength = object.slowdownLength ?? 0;
    message.slowdownRate = object.slowdownRate ?? 0;
    message.primaryTarget = object.primaryTarget ?? -1;
    message.eventTime = object.eventTime ?? 0;
    return message;
  },
};

function createBaseCSVCMsgBroadcastCommand(): CSVCMsgBroadcastCommand {
  return { cmd: "" };
}

export const CSVCMsgBroadcastCommand = {
  encode(message: CSVCMsgBroadcastCommand, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.cmd !== undefined && message.cmd !== "") {
      writer.uint32(10).string(message.cmd);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CSVCMsgBroadcastCommand {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCSVCMsgBroadcastCommand();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.cmd = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CSVCMsgBroadcastCommand {
    return { cmd: isSet(object.cmd) ? globalThis.String(object.cmd) : "" };
  },

  toJSON(message: CSVCMsgBroadcastCommand): unknown {
    const obj: any = {};
    if (message.cmd !== undefined && message.cmd !== "") {
      obj.cmd = message.cmd;
    }
    return obj;
  },

  create(base?: DeepPartial<CSVCMsgBroadcastCommand>): CSVCMsgBroadcastCommand {
    return CSVCMsgBroadcastCommand.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CSVCMsgBroadcastCommand>): CSVCMsgBroadcastCommand {
    const message = createBaseCSVCMsgBroadcastCommand();
    message.cmd = object.cmd ?? "";
    return message;
  },
};

function createBaseCCLCMsgHltvFixupOperatorTick(): CCLCMsgHltvFixupOperatorTick {
  return {
    tick: 0,
    propsData: Buffer.alloc(0),
    origin: undefined,
    eyeAngles: undefined,
    observerMode: 0,
    cameramanScoreboard: false,
    observerTarget: 0,
    viewOffset: undefined,
  };
}

export const CCLCMsgHltvFixupOperatorTick = {
  encode(message: CCLCMsgHltvFixupOperatorTick, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.tick !== undefined && message.tick !== 0) {
      writer.uint32(8).int32(message.tick);
    }
    if (message.propsData !== undefined && message.propsData.length !== 0) {
      writer.uint32(18).bytes(message.propsData);
    }
    if (message.origin !== undefined) {
      CMsgVector.encode(message.origin, writer.uint32(26).fork()).ldelim();
    }
    if (message.eyeAngles !== undefined) {
      CMsgQAngle.encode(message.eyeAngles, writer.uint32(34).fork()).ldelim();
    }
    if (message.observerMode !== undefined && message.observerMode !== 0) {
      writer.uint32(40).int32(message.observerMode);
    }
    if (message.cameramanScoreboard !== undefined && message.cameramanScoreboard !== false) {
      writer.uint32(48).bool(message.cameramanScoreboard);
    }
    if (message.observerTarget !== undefined && message.observerTarget !== 0) {
      writer.uint32(56).int32(message.observerTarget);
    }
    if (message.viewOffset !== undefined) {
      CMsgVector.encode(message.viewOffset, writer.uint32(66).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CCLCMsgHltvFixupOperatorTick {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCCLCMsgHltvFixupOperatorTick();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.tick = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.propsData = reader.bytes() as Buffer;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.origin = CMsgVector.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.eyeAngles = CMsgQAngle.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.observerMode = reader.int32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.cameramanScoreboard = reader.bool();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.observerTarget = reader.int32();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.viewOffset = CMsgVector.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CCLCMsgHltvFixupOperatorTick {
    return {
      tick: isSet(object.tick) ? globalThis.Number(object.tick) : 0,
      propsData: isSet(object.propsData) ? Buffer.from(bytesFromBase64(object.propsData)) : Buffer.alloc(0),
      origin: isSet(object.origin) ? CMsgVector.fromJSON(object.origin) : undefined,
      eyeAngles: isSet(object.eyeAngles) ? CMsgQAngle.fromJSON(object.eyeAngles) : undefined,
      observerMode: isSet(object.observerMode) ? globalThis.Number(object.observerMode) : 0,
      cameramanScoreboard: isSet(object.cameramanScoreboard) ? globalThis.Boolean(object.cameramanScoreboard) : false,
      observerTarget: isSet(object.observerTarget) ? globalThis.Number(object.observerTarget) : 0,
      viewOffset: isSet(object.viewOffset) ? CMsgVector.fromJSON(object.viewOffset) : undefined,
    };
  },

  toJSON(message: CCLCMsgHltvFixupOperatorTick): unknown {
    const obj: any = {};
    if (message.tick !== undefined && message.tick !== 0) {
      obj.tick = Math.round(message.tick);
    }
    if (message.propsData !== undefined && message.propsData.length !== 0) {
      obj.propsData = base64FromBytes(message.propsData);
    }
    if (message.origin !== undefined) {
      obj.origin = CMsgVector.toJSON(message.origin);
    }
    if (message.eyeAngles !== undefined) {
      obj.eyeAngles = CMsgQAngle.toJSON(message.eyeAngles);
    }
    if (message.observerMode !== undefined && message.observerMode !== 0) {
      obj.observerMode = Math.round(message.observerMode);
    }
    if (message.cameramanScoreboard !== undefined && message.cameramanScoreboard !== false) {
      obj.cameramanScoreboard = message.cameramanScoreboard;
    }
    if (message.observerTarget !== undefined && message.observerTarget !== 0) {
      obj.observerTarget = Math.round(message.observerTarget);
    }
    if (message.viewOffset !== undefined) {
      obj.viewOffset = CMsgVector.toJSON(message.viewOffset);
    }
    return obj;
  },

  create(base?: DeepPartial<CCLCMsgHltvFixupOperatorTick>): CCLCMsgHltvFixupOperatorTick {
    return CCLCMsgHltvFixupOperatorTick.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CCLCMsgHltvFixupOperatorTick>): CCLCMsgHltvFixupOperatorTick {
    const message = createBaseCCLCMsgHltvFixupOperatorTick();
    message.tick = object.tick ?? 0;
    message.propsData = object.propsData ?? Buffer.alloc(0);
    message.origin = (object.origin !== undefined && object.origin !== null)
      ? CMsgVector.fromPartial(object.origin)
      : undefined;
    message.eyeAngles = (object.eyeAngles !== undefined && object.eyeAngles !== null)
      ? CMsgQAngle.fromPartial(object.eyeAngles)
      : undefined;
    message.observerMode = object.observerMode ?? 0;
    message.cameramanScoreboard = object.cameramanScoreboard ?? false;
    message.observerTarget = object.observerTarget ?? 0;
    message.viewOffset = (object.viewOffset !== undefined && object.viewOffset !== null)
      ? CMsgVector.fromPartial(object.viewOffset)
      : undefined;
    return message;
  },
};

function createBaseCSVCMsgHltvFixupOperatorStatus(): CSVCMsgHltvFixupOperatorStatus {
  return { mode: 0, overrideOperatorName: "" };
}

export const CSVCMsgHltvFixupOperatorStatus = {
  encode(message: CSVCMsgHltvFixupOperatorStatus, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.mode !== undefined && message.mode !== 0) {
      writer.uint32(8).uint32(message.mode);
    }
    if (message.overrideOperatorName !== undefined && message.overrideOperatorName !== "") {
      writer.uint32(18).string(message.overrideOperatorName);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CSVCMsgHltvFixupOperatorStatus {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCSVCMsgHltvFixupOperatorStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.mode = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.overrideOperatorName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CSVCMsgHltvFixupOperatorStatus {
    return {
      mode: isSet(object.mode) ? globalThis.Number(object.mode) : 0,
      overrideOperatorName: isSet(object.overrideOperatorName) ? globalThis.String(object.overrideOperatorName) : "",
    };
  },

  toJSON(message: CSVCMsgHltvFixupOperatorStatus): unknown {
    const obj: any = {};
    if (message.mode !== undefined && message.mode !== 0) {
      obj.mode = Math.round(message.mode);
    }
    if (message.overrideOperatorName !== undefined && message.overrideOperatorName !== "") {
      obj.overrideOperatorName = message.overrideOperatorName;
    }
    return obj;
  },

  create(base?: DeepPartial<CSVCMsgHltvFixupOperatorStatus>): CSVCMsgHltvFixupOperatorStatus {
    return CSVCMsgHltvFixupOperatorStatus.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CSVCMsgHltvFixupOperatorStatus>): CSVCMsgHltvFixupOperatorStatus {
    const message = createBaseCSVCMsgHltvFixupOperatorStatus();
    message.mode = object.mode ?? 0;
    message.overrideOperatorName = object.overrideOperatorName ?? "";
    return message;
  },
};

function createBaseCMsgServerUserCmd(): CMsgServerUserCmd {
  return { data: Buffer.alloc(0), cmdNumber: 0, playerSlot: -1, serverTickExecuted: 0, clientTick: 0 };
}

export const CMsgServerUserCmd = {
  encode(message: CMsgServerUserCmd, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.data !== undefined && message.data.length !== 0) {
      writer.uint32(10).bytes(message.data);
    }
    if (message.cmdNumber !== undefined && message.cmdNumber !== 0) {
      writer.uint32(16).int32(message.cmdNumber);
    }
    if (message.playerSlot !== undefined && message.playerSlot !== -1) {
      writer.uint32(24).int32(message.playerSlot);
    }
    if (message.serverTickExecuted !== undefined && message.serverTickExecuted !== 0) {
      writer.uint32(32).int32(message.serverTickExecuted);
    }
    if (message.clientTick !== undefined && message.clientTick !== 0) {
      writer.uint32(40).int32(message.clientTick);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgServerUserCmd {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgServerUserCmd();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.data = reader.bytes() as Buffer;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.cmdNumber = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.playerSlot = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.serverTickExecuted = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.clientTick = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgServerUserCmd {
    return {
      data: isSet(object.data) ? Buffer.from(bytesFromBase64(object.data)) : Buffer.alloc(0),
      cmdNumber: isSet(object.cmdNumber) ? globalThis.Number(object.cmdNumber) : 0,
      playerSlot: isSet(object.playerSlot) ? globalThis.Number(object.playerSlot) : -1,
      serverTickExecuted: isSet(object.serverTickExecuted) ? globalThis.Number(object.serverTickExecuted) : 0,
      clientTick: isSet(object.clientTick) ? globalThis.Number(object.clientTick) : 0,
    };
  },

  toJSON(message: CMsgServerUserCmd): unknown {
    const obj: any = {};
    if (message.data !== undefined && message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    if (message.cmdNumber !== undefined && message.cmdNumber !== 0) {
      obj.cmdNumber = Math.round(message.cmdNumber);
    }
    if (message.playerSlot !== undefined && message.playerSlot !== -1) {
      obj.playerSlot = Math.round(message.playerSlot);
    }
    if (message.serverTickExecuted !== undefined && message.serverTickExecuted !== 0) {
      obj.serverTickExecuted = Math.round(message.serverTickExecuted);
    }
    if (message.clientTick !== undefined && message.clientTick !== 0) {
      obj.clientTick = Math.round(message.clientTick);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgServerUserCmd>): CMsgServerUserCmd {
    return CMsgServerUserCmd.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgServerUserCmd>): CMsgServerUserCmd {
    const message = createBaseCMsgServerUserCmd();
    message.data = object.data ?? Buffer.alloc(0);
    message.cmdNumber = object.cmdNumber ?? 0;
    message.playerSlot = object.playerSlot ?? -1;
    message.serverTickExecuted = object.serverTickExecuted ?? 0;
    message.clientTick = object.clientTick ?? 0;
    return message;
  },
};

function createBaseCSVCMsgUserCommands(): CSVCMsgUserCommands {
  return { commands: [] };
}

export const CSVCMsgUserCommands = {
  encode(message: CSVCMsgUserCommands, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.commands) {
      CMsgServerUserCmd.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CSVCMsgUserCommands {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCSVCMsgUserCommands();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.commands.push(CMsgServerUserCmd.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CSVCMsgUserCommands {
    return {
      commands: globalThis.Array.isArray(object?.commands)
        ? object.commands.map((e: any) => CMsgServerUserCmd.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CSVCMsgUserCommands): unknown {
    const obj: any = {};
    if (message.commands?.length) {
      obj.commands = message.commands.map((e) => CMsgServerUserCmd.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CSVCMsgUserCommands>): CSVCMsgUserCommands {
    return CSVCMsgUserCommands.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CSVCMsgUserCommands>): CSVCMsgUserCommands {
    const message = createBaseCSVCMsgUserCommands();
    message.commands = object.commands?.map((e) => CMsgServerUserCmd.fromPartial(e)) || [];
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function longToString(long: Long) {
  return long.toString();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

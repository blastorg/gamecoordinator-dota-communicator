// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.176.1
//   protoc               v5.26.1
// source: te.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";
import { CMsgQAngle, CMsgVector } from "./networkbasetypes";

export enum ETEProtobufIds {
  TE_EffectDispatchId = 400,
  TE_ArmorRicochetId = 401,
  TE_BeamEntPointId = 402,
  TE_BeamEntsId = 403,
  TE_BeamPointsId = 404,
  TE_BeamRingId = 405,
  TE_BSPDecalId = 407,
  TE_BubblesId = 408,
  TE_BubbleTrailId = 409,
  TE_DecalId = 410,
  TE_WorldDecalId = 411,
  TE_EnergySplashId = 412,
  TE_FizzId = 413,
  TE_ShatterSurfaceId = 414,
  TE_GlowSpriteId = 415,
  TE_ImpactId = 416,
  TE_MuzzleFlashId = 417,
  TE_BloodStreamId = 418,
  TE_ExplosionId = 419,
  TE_DustId = 420,
  TE_LargeFunnelId = 421,
  TE_SparksId = 422,
  TE_PhysicsPropId = 423,
  TE_PlayerDecalId = 424,
  TE_ProjectedDecalId = 425,
  TE_SmokeId = 426,
}

export function eTEProtobufIdsFromJSON(object: any): ETEProtobufIds {
  switch (object) {
    case 400:
    case "TE_EffectDispatchId":
      return ETEProtobufIds.TE_EffectDispatchId;
    case 401:
    case "TE_ArmorRicochetId":
      return ETEProtobufIds.TE_ArmorRicochetId;
    case 402:
    case "TE_BeamEntPointId":
      return ETEProtobufIds.TE_BeamEntPointId;
    case 403:
    case "TE_BeamEntsId":
      return ETEProtobufIds.TE_BeamEntsId;
    case 404:
    case "TE_BeamPointsId":
      return ETEProtobufIds.TE_BeamPointsId;
    case 405:
    case "TE_BeamRingId":
      return ETEProtobufIds.TE_BeamRingId;
    case 407:
    case "TE_BSPDecalId":
      return ETEProtobufIds.TE_BSPDecalId;
    case 408:
    case "TE_BubblesId":
      return ETEProtobufIds.TE_BubblesId;
    case 409:
    case "TE_BubbleTrailId":
      return ETEProtobufIds.TE_BubbleTrailId;
    case 410:
    case "TE_DecalId":
      return ETEProtobufIds.TE_DecalId;
    case 411:
    case "TE_WorldDecalId":
      return ETEProtobufIds.TE_WorldDecalId;
    case 412:
    case "TE_EnergySplashId":
      return ETEProtobufIds.TE_EnergySplashId;
    case 413:
    case "TE_FizzId":
      return ETEProtobufIds.TE_FizzId;
    case 414:
    case "TE_ShatterSurfaceId":
      return ETEProtobufIds.TE_ShatterSurfaceId;
    case 415:
    case "TE_GlowSpriteId":
      return ETEProtobufIds.TE_GlowSpriteId;
    case 416:
    case "TE_ImpactId":
      return ETEProtobufIds.TE_ImpactId;
    case 417:
    case "TE_MuzzleFlashId":
      return ETEProtobufIds.TE_MuzzleFlashId;
    case 418:
    case "TE_BloodStreamId":
      return ETEProtobufIds.TE_BloodStreamId;
    case 419:
    case "TE_ExplosionId":
      return ETEProtobufIds.TE_ExplosionId;
    case 420:
    case "TE_DustId":
      return ETEProtobufIds.TE_DustId;
    case 421:
    case "TE_LargeFunnelId":
      return ETEProtobufIds.TE_LargeFunnelId;
    case 422:
    case "TE_SparksId":
      return ETEProtobufIds.TE_SparksId;
    case 423:
    case "TE_PhysicsPropId":
      return ETEProtobufIds.TE_PhysicsPropId;
    case 424:
    case "TE_PlayerDecalId":
      return ETEProtobufIds.TE_PlayerDecalId;
    case 425:
    case "TE_ProjectedDecalId":
      return ETEProtobufIds.TE_ProjectedDecalId;
    case 426:
    case "TE_SmokeId":
      return ETEProtobufIds.TE_SmokeId;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ETEProtobufIds");
  }
}

export function eTEProtobufIdsToJSON(object: ETEProtobufIds): string {
  switch (object) {
    case ETEProtobufIds.TE_EffectDispatchId:
      return "TE_EffectDispatchId";
    case ETEProtobufIds.TE_ArmorRicochetId:
      return "TE_ArmorRicochetId";
    case ETEProtobufIds.TE_BeamEntPointId:
      return "TE_BeamEntPointId";
    case ETEProtobufIds.TE_BeamEntsId:
      return "TE_BeamEntsId";
    case ETEProtobufIds.TE_BeamPointsId:
      return "TE_BeamPointsId";
    case ETEProtobufIds.TE_BeamRingId:
      return "TE_BeamRingId";
    case ETEProtobufIds.TE_BSPDecalId:
      return "TE_BSPDecalId";
    case ETEProtobufIds.TE_BubblesId:
      return "TE_BubblesId";
    case ETEProtobufIds.TE_BubbleTrailId:
      return "TE_BubbleTrailId";
    case ETEProtobufIds.TE_DecalId:
      return "TE_DecalId";
    case ETEProtobufIds.TE_WorldDecalId:
      return "TE_WorldDecalId";
    case ETEProtobufIds.TE_EnergySplashId:
      return "TE_EnergySplashId";
    case ETEProtobufIds.TE_FizzId:
      return "TE_FizzId";
    case ETEProtobufIds.TE_ShatterSurfaceId:
      return "TE_ShatterSurfaceId";
    case ETEProtobufIds.TE_GlowSpriteId:
      return "TE_GlowSpriteId";
    case ETEProtobufIds.TE_ImpactId:
      return "TE_ImpactId";
    case ETEProtobufIds.TE_MuzzleFlashId:
      return "TE_MuzzleFlashId";
    case ETEProtobufIds.TE_BloodStreamId:
      return "TE_BloodStreamId";
    case ETEProtobufIds.TE_ExplosionId:
      return "TE_ExplosionId";
    case ETEProtobufIds.TE_DustId:
      return "TE_DustId";
    case ETEProtobufIds.TE_LargeFunnelId:
      return "TE_LargeFunnelId";
    case ETEProtobufIds.TE_SparksId:
      return "TE_SparksId";
    case ETEProtobufIds.TE_PhysicsPropId:
      return "TE_PhysicsPropId";
    case ETEProtobufIds.TE_PlayerDecalId:
      return "TE_PlayerDecalId";
    case ETEProtobufIds.TE_ProjectedDecalId:
      return "TE_ProjectedDecalId";
    case ETEProtobufIds.TE_SmokeId:
      return "TE_SmokeId";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ETEProtobufIds");
  }
}

export interface CMsgTEArmorRicochet {
  pos?: CMsgVector | undefined;
  dir?: CMsgVector | undefined;
}

export interface CMsgTEBaseBeam {
  modelindex?: string | undefined;
  haloindex?: string | undefined;
  startframe?: number | undefined;
  framerate?: number | undefined;
  life?: number | undefined;
  width?: number | undefined;
  endwidth?: number | undefined;
  fadelength?: number | undefined;
  amplitude?: number | undefined;
  color?: number | undefined;
  speed?: number | undefined;
  flags?: number | undefined;
}

export interface CMsgTEBeamEntPoint {
  base?: CMsgTEBaseBeam | undefined;
  startentity?: number | undefined;
  endentity?: number | undefined;
  start?: CMsgVector | undefined;
  end?: CMsgVector | undefined;
}

export interface CMsgTEBeamEnts {
  base?: CMsgTEBaseBeam | undefined;
  startentity?: number | undefined;
  endentity?: number | undefined;
}

export interface CMsgTEBeamPoints {
  base?: CMsgTEBaseBeam | undefined;
  start?: CMsgVector | undefined;
  end?: CMsgVector | undefined;
}

export interface CMsgTEBeamRing {
  base?: CMsgTEBaseBeam | undefined;
  startentity?: number | undefined;
  endentity?: number | undefined;
}

export interface CMsgTEBSPDecal {
  origin?: CMsgVector | undefined;
  normal?: CMsgVector | undefined;
  saxis?: CMsgVector | undefined;
  entity?: number | undefined;
  index?: number | undefined;
}

export interface CMsgTEBubbles {
  mins?: CMsgVector | undefined;
  maxs?: CMsgVector | undefined;
  height?: number | undefined;
  count?: number | undefined;
  speed?: number | undefined;
}

export interface CMsgTEBubbleTrail {
  mins?: CMsgVector | undefined;
  maxs?: CMsgVector | undefined;
  waterz?: number | undefined;
  count?: number | undefined;
  speed?: number | undefined;
}

export interface CMsgTEDecal {
  origin?: CMsgVector | undefined;
  start?: CMsgVector | undefined;
  entity?: number | undefined;
  hitbox?: number | undefined;
  index?: number | undefined;
}

export interface CMsgEffectData {
  origin?: CMsgVector | undefined;
  start?: CMsgVector | undefined;
  normal?: CMsgVector | undefined;
  angles?: CMsgQAngle | undefined;
  entity?: number | undefined;
  otherentity?: number | undefined;
  scale?: number | undefined;
  magnitude?: number | undefined;
  radius?: number | undefined;
  surfaceprop?: number | undefined;
  effectindex?: string | undefined;
  damagetype?: number | undefined;
  material?: number | undefined;
  hitbox?: number | undefined;
  color?: number | undefined;
  flags?: number | undefined;
  attachmentindex?: number | undefined;
  effectname?: number | undefined;
  attachmentname?: number | undefined;
}

export interface CMsgTEEffectDispatch {
  effectdata?: CMsgEffectData | undefined;
}

export interface CMsgTEEnergySplash {
  pos?: CMsgVector | undefined;
  dir?: CMsgVector | undefined;
  explosive?: boolean | undefined;
}

export interface CMsgTEFizz {
  entity?: number | undefined;
  density?: number | undefined;
  current?: number | undefined;
}

export interface CMsgTEShatterSurface {
  origin?: CMsgVector | undefined;
  angles?: CMsgQAngle | undefined;
  force?: CMsgVector | undefined;
  forcepos?: CMsgVector | undefined;
  width?: number | undefined;
  height?: number | undefined;
  shardsize?: number | undefined;
  surfacetype?: number | undefined;
  frontcolor?: number | undefined;
  backcolor?: number | undefined;
}

export interface CMsgTEGlowSprite {
  origin?: CMsgVector | undefined;
  scale?: number | undefined;
  life?: number | undefined;
  brightness?: number | undefined;
}

export interface CMsgTEImpact {
  origin?: CMsgVector | undefined;
  normal?: CMsgVector | undefined;
  type?: number | undefined;
}

export interface CMsgTEMuzzleFlash {
  origin?: CMsgVector | undefined;
  angles?: CMsgQAngle | undefined;
  scale?: number | undefined;
  type?: number | undefined;
}

export interface CMsgTEBloodStream {
  origin?: CMsgVector | undefined;
  direction?: CMsgVector | undefined;
  color?: number | undefined;
  amount?: number | undefined;
}

export interface CMsgTEExplosion {
  origin?: CMsgVector | undefined;
  framerate?: number | undefined;
  flags?: number | undefined;
  normal?: CMsgVector | undefined;
  materialtype?: number | undefined;
  radius?: number | undefined;
  magnitude?: number | undefined;
  scale?: number | undefined;
  affectRagdolls?: boolean | undefined;
  effectName?: string | undefined;
  explosionType?: number | undefined;
}

export interface CMsgTEDust {
  origin?: CMsgVector | undefined;
  size?: number | undefined;
  speed?: number | undefined;
  direction?: CMsgVector | undefined;
}

export interface CMsgTELargeFunnel {
  origin?: CMsgVector | undefined;
  reversed?: number | undefined;
}

export interface CMsgTESparks {
  origin?: CMsgVector | undefined;
  magnitude?: number | undefined;
  length?: number | undefined;
  direction?: CMsgVector | undefined;
}

export interface CMsgTEPhysicsProp {
  origin?: CMsgVector | undefined;
  velocity?: CMsgVector | undefined;
  angles?: CMsgQAngle | undefined;
  skin?: number | undefined;
  flags?: number | undefined;
  effects?: number | undefined;
  color?: number | undefined;
  modelindex?: string | undefined;
  unusedBreakmodelsnottomake?: number | undefined;
  scale?: number | undefined;
  dmgpos?: CMsgVector | undefined;
  dmgdir?: CMsgVector | undefined;
  dmgtype?: number | undefined;
}

export interface CMsgTEPlayerDecal {
  origin?: CMsgVector | undefined;
  player?: number | undefined;
  entity?: number | undefined;
}

export interface CMsgTEProjectedDecal {
  origin?: CMsgVector | undefined;
  angles?: CMsgQAngle | undefined;
  index?: number | undefined;
  distance?: number | undefined;
}

export interface CMsgTESmoke {
  origin?: CMsgVector | undefined;
  scale?: number | undefined;
}

export interface CMsgTEWorldDecal {
  origin?: CMsgVector | undefined;
  normal?: CMsgVector | undefined;
  index?: number | undefined;
}

function createBaseCMsgTEArmorRicochet(): CMsgTEArmorRicochet {
  return { pos: undefined, dir: undefined };
}

export const CMsgTEArmorRicochet = {
  encode(message: CMsgTEArmorRicochet, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.pos !== undefined) {
      CMsgVector.encode(message.pos, writer.uint32(10).fork()).ldelim();
    }
    if (message.dir !== undefined) {
      CMsgVector.encode(message.dir, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgTEArmorRicochet {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgTEArmorRicochet();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.pos = CMsgVector.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.dir = CMsgVector.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgTEArmorRicochet {
    return {
      pos: isSet(object.pos) ? CMsgVector.fromJSON(object.pos) : undefined,
      dir: isSet(object.dir) ? CMsgVector.fromJSON(object.dir) : undefined,
    };
  },

  toJSON(message: CMsgTEArmorRicochet): unknown {
    const obj: any = {};
    if (message.pos !== undefined) {
      obj.pos = CMsgVector.toJSON(message.pos);
    }
    if (message.dir !== undefined) {
      obj.dir = CMsgVector.toJSON(message.dir);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgTEArmorRicochet>): CMsgTEArmorRicochet {
    return CMsgTEArmorRicochet.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgTEArmorRicochet>): CMsgTEArmorRicochet {
    const message = createBaseCMsgTEArmorRicochet();
    message.pos = object.pos !== undefined && object.pos !== null ? CMsgVector.fromPartial(object.pos) : undefined;
    message.dir = object.dir !== undefined && object.dir !== null ? CMsgVector.fromPartial(object.dir) : undefined;
    return message;
  },
};

function createBaseCMsgTEBaseBeam(): CMsgTEBaseBeam {
  return {
    modelindex: "0",
    haloindex: "0",
    startframe: 0,
    framerate: 0,
    life: 0,
    width: 0,
    endwidth: 0,
    fadelength: 0,
    amplitude: 0,
    color: 0,
    speed: 0,
    flags: 0,
  };
}

export const CMsgTEBaseBeam = {
  encode(message: CMsgTEBaseBeam, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.modelindex !== undefined && message.modelindex !== "0") {
      writer.uint32(9).fixed64(message.modelindex);
    }
    if (message.haloindex !== undefined && message.haloindex !== "0") {
      writer.uint32(17).fixed64(message.haloindex);
    }
    if (message.startframe !== undefined && message.startframe !== 0) {
      writer.uint32(24).uint32(message.startframe);
    }
    if (message.framerate !== undefined && message.framerate !== 0) {
      writer.uint32(32).uint32(message.framerate);
    }
    if (message.life !== undefined && message.life !== 0) {
      writer.uint32(45).float(message.life);
    }
    if (message.width !== undefined && message.width !== 0) {
      writer.uint32(53).float(message.width);
    }
    if (message.endwidth !== undefined && message.endwidth !== 0) {
      writer.uint32(61).float(message.endwidth);
    }
    if (message.fadelength !== undefined && message.fadelength !== 0) {
      writer.uint32(64).uint32(message.fadelength);
    }
    if (message.amplitude !== undefined && message.amplitude !== 0) {
      writer.uint32(77).float(message.amplitude);
    }
    if (message.color !== undefined && message.color !== 0) {
      writer.uint32(85).fixed32(message.color);
    }
    if (message.speed !== undefined && message.speed !== 0) {
      writer.uint32(88).uint32(message.speed);
    }
    if (message.flags !== undefined && message.flags !== 0) {
      writer.uint32(96).uint32(message.flags);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgTEBaseBeam {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgTEBaseBeam();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.modelindex = longToString(reader.fixed64() as Long);
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.haloindex = longToString(reader.fixed64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.startframe = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.framerate = reader.uint32();
          continue;
        case 5:
          if (tag !== 45) {
            break;
          }

          message.life = reader.float();
          continue;
        case 6:
          if (tag !== 53) {
            break;
          }

          message.width = reader.float();
          continue;
        case 7:
          if (tag !== 61) {
            break;
          }

          message.endwidth = reader.float();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.fadelength = reader.uint32();
          continue;
        case 9:
          if (tag !== 77) {
            break;
          }

          message.amplitude = reader.float();
          continue;
        case 10:
          if (tag !== 85) {
            break;
          }

          message.color = reader.fixed32();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.speed = reader.uint32();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.flags = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgTEBaseBeam {
    return {
      modelindex: isSet(object.modelindex) ? globalThis.String(object.modelindex) : "0",
      haloindex: isSet(object.haloindex) ? globalThis.String(object.haloindex) : "0",
      startframe: isSet(object.startframe) ? globalThis.Number(object.startframe) : 0,
      framerate: isSet(object.framerate) ? globalThis.Number(object.framerate) : 0,
      life: isSet(object.life) ? globalThis.Number(object.life) : 0,
      width: isSet(object.width) ? globalThis.Number(object.width) : 0,
      endwidth: isSet(object.endwidth) ? globalThis.Number(object.endwidth) : 0,
      fadelength: isSet(object.fadelength) ? globalThis.Number(object.fadelength) : 0,
      amplitude: isSet(object.amplitude) ? globalThis.Number(object.amplitude) : 0,
      color: isSet(object.color) ? globalThis.Number(object.color) : 0,
      speed: isSet(object.speed) ? globalThis.Number(object.speed) : 0,
      flags: isSet(object.flags) ? globalThis.Number(object.flags) : 0,
    };
  },

  toJSON(message: CMsgTEBaseBeam): unknown {
    const obj: any = {};
    if (message.modelindex !== undefined && message.modelindex !== "0") {
      obj.modelindex = message.modelindex;
    }
    if (message.haloindex !== undefined && message.haloindex !== "0") {
      obj.haloindex = message.haloindex;
    }
    if (message.startframe !== undefined && message.startframe !== 0) {
      obj.startframe = Math.round(message.startframe);
    }
    if (message.framerate !== undefined && message.framerate !== 0) {
      obj.framerate = Math.round(message.framerate);
    }
    if (message.life !== undefined && message.life !== 0) {
      obj.life = message.life;
    }
    if (message.width !== undefined && message.width !== 0) {
      obj.width = message.width;
    }
    if (message.endwidth !== undefined && message.endwidth !== 0) {
      obj.endwidth = message.endwidth;
    }
    if (message.fadelength !== undefined && message.fadelength !== 0) {
      obj.fadelength = Math.round(message.fadelength);
    }
    if (message.amplitude !== undefined && message.amplitude !== 0) {
      obj.amplitude = message.amplitude;
    }
    if (message.color !== undefined && message.color !== 0) {
      obj.color = Math.round(message.color);
    }
    if (message.speed !== undefined && message.speed !== 0) {
      obj.speed = Math.round(message.speed);
    }
    if (message.flags !== undefined && message.flags !== 0) {
      obj.flags = Math.round(message.flags);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgTEBaseBeam>): CMsgTEBaseBeam {
    return CMsgTEBaseBeam.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgTEBaseBeam>): CMsgTEBaseBeam {
    const message = createBaseCMsgTEBaseBeam();
    message.modelindex = object.modelindex ?? "0";
    message.haloindex = object.haloindex ?? "0";
    message.startframe = object.startframe ?? 0;
    message.framerate = object.framerate ?? 0;
    message.life = object.life ?? 0;
    message.width = object.width ?? 0;
    message.endwidth = object.endwidth ?? 0;
    message.fadelength = object.fadelength ?? 0;
    message.amplitude = object.amplitude ?? 0;
    message.color = object.color ?? 0;
    message.speed = object.speed ?? 0;
    message.flags = object.flags ?? 0;
    return message;
  },
};

function createBaseCMsgTEBeamEntPoint(): CMsgTEBeamEntPoint {
  return { base: undefined, startentity: 0, endentity: 0, start: undefined, end: undefined };
}

export const CMsgTEBeamEntPoint = {
  encode(message: CMsgTEBeamEntPoint, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.base !== undefined) {
      CMsgTEBaseBeam.encode(message.base, writer.uint32(10).fork()).ldelim();
    }
    if (message.startentity !== undefined && message.startentity !== 0) {
      writer.uint32(16).uint32(message.startentity);
    }
    if (message.endentity !== undefined && message.endentity !== 0) {
      writer.uint32(24).uint32(message.endentity);
    }
    if (message.start !== undefined) {
      CMsgVector.encode(message.start, writer.uint32(34).fork()).ldelim();
    }
    if (message.end !== undefined) {
      CMsgVector.encode(message.end, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgTEBeamEntPoint {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgTEBeamEntPoint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.base = CMsgTEBaseBeam.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.startentity = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.endentity = reader.uint32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.start = CMsgVector.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.end = CMsgVector.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgTEBeamEntPoint {
    return {
      base: isSet(object.base) ? CMsgTEBaseBeam.fromJSON(object.base) : undefined,
      startentity: isSet(object.startentity) ? globalThis.Number(object.startentity) : 0,
      endentity: isSet(object.endentity) ? globalThis.Number(object.endentity) : 0,
      start: isSet(object.start) ? CMsgVector.fromJSON(object.start) : undefined,
      end: isSet(object.end) ? CMsgVector.fromJSON(object.end) : undefined,
    };
  },

  toJSON(message: CMsgTEBeamEntPoint): unknown {
    const obj: any = {};
    if (message.base !== undefined) {
      obj.base = CMsgTEBaseBeam.toJSON(message.base);
    }
    if (message.startentity !== undefined && message.startentity !== 0) {
      obj.startentity = Math.round(message.startentity);
    }
    if (message.endentity !== undefined && message.endentity !== 0) {
      obj.endentity = Math.round(message.endentity);
    }
    if (message.start !== undefined) {
      obj.start = CMsgVector.toJSON(message.start);
    }
    if (message.end !== undefined) {
      obj.end = CMsgVector.toJSON(message.end);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgTEBeamEntPoint>): CMsgTEBeamEntPoint {
    return CMsgTEBeamEntPoint.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgTEBeamEntPoint>): CMsgTEBeamEntPoint {
    const message = createBaseCMsgTEBeamEntPoint();
    message.base =
      object.base !== undefined && object.base !== null ? CMsgTEBaseBeam.fromPartial(object.base) : undefined;
    message.startentity = object.startentity ?? 0;
    message.endentity = object.endentity ?? 0;
    message.start =
      object.start !== undefined && object.start !== null ? CMsgVector.fromPartial(object.start) : undefined;
    message.end = object.end !== undefined && object.end !== null ? CMsgVector.fromPartial(object.end) : undefined;
    return message;
  },
};

function createBaseCMsgTEBeamEnts(): CMsgTEBeamEnts {
  return { base: undefined, startentity: 0, endentity: 0 };
}

export const CMsgTEBeamEnts = {
  encode(message: CMsgTEBeamEnts, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.base !== undefined) {
      CMsgTEBaseBeam.encode(message.base, writer.uint32(10).fork()).ldelim();
    }
    if (message.startentity !== undefined && message.startentity !== 0) {
      writer.uint32(16).uint32(message.startentity);
    }
    if (message.endentity !== undefined && message.endentity !== 0) {
      writer.uint32(24).uint32(message.endentity);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgTEBeamEnts {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgTEBeamEnts();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.base = CMsgTEBaseBeam.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.startentity = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.endentity = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgTEBeamEnts {
    return {
      base: isSet(object.base) ? CMsgTEBaseBeam.fromJSON(object.base) : undefined,
      startentity: isSet(object.startentity) ? globalThis.Number(object.startentity) : 0,
      endentity: isSet(object.endentity) ? globalThis.Number(object.endentity) : 0,
    };
  },

  toJSON(message: CMsgTEBeamEnts): unknown {
    const obj: any = {};
    if (message.base !== undefined) {
      obj.base = CMsgTEBaseBeam.toJSON(message.base);
    }
    if (message.startentity !== undefined && message.startentity !== 0) {
      obj.startentity = Math.round(message.startentity);
    }
    if (message.endentity !== undefined && message.endentity !== 0) {
      obj.endentity = Math.round(message.endentity);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgTEBeamEnts>): CMsgTEBeamEnts {
    return CMsgTEBeamEnts.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgTEBeamEnts>): CMsgTEBeamEnts {
    const message = createBaseCMsgTEBeamEnts();
    message.base =
      object.base !== undefined && object.base !== null ? CMsgTEBaseBeam.fromPartial(object.base) : undefined;
    message.startentity = object.startentity ?? 0;
    message.endentity = object.endentity ?? 0;
    return message;
  },
};

function createBaseCMsgTEBeamPoints(): CMsgTEBeamPoints {
  return { base: undefined, start: undefined, end: undefined };
}

export const CMsgTEBeamPoints = {
  encode(message: CMsgTEBeamPoints, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.base !== undefined) {
      CMsgTEBaseBeam.encode(message.base, writer.uint32(10).fork()).ldelim();
    }
    if (message.start !== undefined) {
      CMsgVector.encode(message.start, writer.uint32(18).fork()).ldelim();
    }
    if (message.end !== undefined) {
      CMsgVector.encode(message.end, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgTEBeamPoints {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgTEBeamPoints();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.base = CMsgTEBaseBeam.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.start = CMsgVector.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.end = CMsgVector.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgTEBeamPoints {
    return {
      base: isSet(object.base) ? CMsgTEBaseBeam.fromJSON(object.base) : undefined,
      start: isSet(object.start) ? CMsgVector.fromJSON(object.start) : undefined,
      end: isSet(object.end) ? CMsgVector.fromJSON(object.end) : undefined,
    };
  },

  toJSON(message: CMsgTEBeamPoints): unknown {
    const obj: any = {};
    if (message.base !== undefined) {
      obj.base = CMsgTEBaseBeam.toJSON(message.base);
    }
    if (message.start !== undefined) {
      obj.start = CMsgVector.toJSON(message.start);
    }
    if (message.end !== undefined) {
      obj.end = CMsgVector.toJSON(message.end);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgTEBeamPoints>): CMsgTEBeamPoints {
    return CMsgTEBeamPoints.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgTEBeamPoints>): CMsgTEBeamPoints {
    const message = createBaseCMsgTEBeamPoints();
    message.base =
      object.base !== undefined && object.base !== null ? CMsgTEBaseBeam.fromPartial(object.base) : undefined;
    message.start =
      object.start !== undefined && object.start !== null ? CMsgVector.fromPartial(object.start) : undefined;
    message.end = object.end !== undefined && object.end !== null ? CMsgVector.fromPartial(object.end) : undefined;
    return message;
  },
};

function createBaseCMsgTEBeamRing(): CMsgTEBeamRing {
  return { base: undefined, startentity: 0, endentity: 0 };
}

export const CMsgTEBeamRing = {
  encode(message: CMsgTEBeamRing, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.base !== undefined) {
      CMsgTEBaseBeam.encode(message.base, writer.uint32(10).fork()).ldelim();
    }
    if (message.startentity !== undefined && message.startentity !== 0) {
      writer.uint32(16).uint32(message.startentity);
    }
    if (message.endentity !== undefined && message.endentity !== 0) {
      writer.uint32(24).uint32(message.endentity);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgTEBeamRing {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgTEBeamRing();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.base = CMsgTEBaseBeam.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.startentity = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.endentity = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgTEBeamRing {
    return {
      base: isSet(object.base) ? CMsgTEBaseBeam.fromJSON(object.base) : undefined,
      startentity: isSet(object.startentity) ? globalThis.Number(object.startentity) : 0,
      endentity: isSet(object.endentity) ? globalThis.Number(object.endentity) : 0,
    };
  },

  toJSON(message: CMsgTEBeamRing): unknown {
    const obj: any = {};
    if (message.base !== undefined) {
      obj.base = CMsgTEBaseBeam.toJSON(message.base);
    }
    if (message.startentity !== undefined && message.startentity !== 0) {
      obj.startentity = Math.round(message.startentity);
    }
    if (message.endentity !== undefined && message.endentity !== 0) {
      obj.endentity = Math.round(message.endentity);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgTEBeamRing>): CMsgTEBeamRing {
    return CMsgTEBeamRing.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgTEBeamRing>): CMsgTEBeamRing {
    const message = createBaseCMsgTEBeamRing();
    message.base =
      object.base !== undefined && object.base !== null ? CMsgTEBaseBeam.fromPartial(object.base) : undefined;
    message.startentity = object.startentity ?? 0;
    message.endentity = object.endentity ?? 0;
    return message;
  },
};

function createBaseCMsgTEBSPDecal(): CMsgTEBSPDecal {
  return { origin: undefined, normal: undefined, saxis: undefined, entity: -1, index: 0 };
}

export const CMsgTEBSPDecal = {
  encode(message: CMsgTEBSPDecal, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.origin !== undefined) {
      CMsgVector.encode(message.origin, writer.uint32(10).fork()).ldelim();
    }
    if (message.normal !== undefined) {
      CMsgVector.encode(message.normal, writer.uint32(18).fork()).ldelim();
    }
    if (message.saxis !== undefined) {
      CMsgVector.encode(message.saxis, writer.uint32(26).fork()).ldelim();
    }
    if (message.entity !== undefined && message.entity !== -1) {
      writer.uint32(32).int32(message.entity);
    }
    if (message.index !== undefined && message.index !== 0) {
      writer.uint32(40).uint32(message.index);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgTEBSPDecal {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgTEBSPDecal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.origin = CMsgVector.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.normal = CMsgVector.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.saxis = CMsgVector.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.entity = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.index = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgTEBSPDecal {
    return {
      origin: isSet(object.origin) ? CMsgVector.fromJSON(object.origin) : undefined,
      normal: isSet(object.normal) ? CMsgVector.fromJSON(object.normal) : undefined,
      saxis: isSet(object.saxis) ? CMsgVector.fromJSON(object.saxis) : undefined,
      entity: isSet(object.entity) ? globalThis.Number(object.entity) : -1,
      index: isSet(object.index) ? globalThis.Number(object.index) : 0,
    };
  },

  toJSON(message: CMsgTEBSPDecal): unknown {
    const obj: any = {};
    if (message.origin !== undefined) {
      obj.origin = CMsgVector.toJSON(message.origin);
    }
    if (message.normal !== undefined) {
      obj.normal = CMsgVector.toJSON(message.normal);
    }
    if (message.saxis !== undefined) {
      obj.saxis = CMsgVector.toJSON(message.saxis);
    }
    if (message.entity !== undefined && message.entity !== -1) {
      obj.entity = Math.round(message.entity);
    }
    if (message.index !== undefined && message.index !== 0) {
      obj.index = Math.round(message.index);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgTEBSPDecal>): CMsgTEBSPDecal {
    return CMsgTEBSPDecal.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgTEBSPDecal>): CMsgTEBSPDecal {
    const message = createBaseCMsgTEBSPDecal();
    message.origin =
      object.origin !== undefined && object.origin !== null ? CMsgVector.fromPartial(object.origin) : undefined;
    message.normal =
      object.normal !== undefined && object.normal !== null ? CMsgVector.fromPartial(object.normal) : undefined;
    message.saxis =
      object.saxis !== undefined && object.saxis !== null ? CMsgVector.fromPartial(object.saxis) : undefined;
    message.entity = object.entity ?? -1;
    message.index = object.index ?? 0;
    return message;
  },
};

function createBaseCMsgTEBubbles(): CMsgTEBubbles {
  return { mins: undefined, maxs: undefined, height: 0, count: 0, speed: 0 };
}

export const CMsgTEBubbles = {
  encode(message: CMsgTEBubbles, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.mins !== undefined) {
      CMsgVector.encode(message.mins, writer.uint32(10).fork()).ldelim();
    }
    if (message.maxs !== undefined) {
      CMsgVector.encode(message.maxs, writer.uint32(18).fork()).ldelim();
    }
    if (message.height !== undefined && message.height !== 0) {
      writer.uint32(29).float(message.height);
    }
    if (message.count !== undefined && message.count !== 0) {
      writer.uint32(32).uint32(message.count);
    }
    if (message.speed !== undefined && message.speed !== 0) {
      writer.uint32(45).float(message.speed);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgTEBubbles {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgTEBubbles();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.mins = CMsgVector.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.maxs = CMsgVector.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.height = reader.float();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.count = reader.uint32();
          continue;
        case 5:
          if (tag !== 45) {
            break;
          }

          message.speed = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgTEBubbles {
    return {
      mins: isSet(object.mins) ? CMsgVector.fromJSON(object.mins) : undefined,
      maxs: isSet(object.maxs) ? CMsgVector.fromJSON(object.maxs) : undefined,
      height: isSet(object.height) ? globalThis.Number(object.height) : 0,
      count: isSet(object.count) ? globalThis.Number(object.count) : 0,
      speed: isSet(object.speed) ? globalThis.Number(object.speed) : 0,
    };
  },

  toJSON(message: CMsgTEBubbles): unknown {
    const obj: any = {};
    if (message.mins !== undefined) {
      obj.mins = CMsgVector.toJSON(message.mins);
    }
    if (message.maxs !== undefined) {
      obj.maxs = CMsgVector.toJSON(message.maxs);
    }
    if (message.height !== undefined && message.height !== 0) {
      obj.height = message.height;
    }
    if (message.count !== undefined && message.count !== 0) {
      obj.count = Math.round(message.count);
    }
    if (message.speed !== undefined && message.speed !== 0) {
      obj.speed = message.speed;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgTEBubbles>): CMsgTEBubbles {
    return CMsgTEBubbles.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgTEBubbles>): CMsgTEBubbles {
    const message = createBaseCMsgTEBubbles();
    message.mins = object.mins !== undefined && object.mins !== null ? CMsgVector.fromPartial(object.mins) : undefined;
    message.maxs = object.maxs !== undefined && object.maxs !== null ? CMsgVector.fromPartial(object.maxs) : undefined;
    message.height = object.height ?? 0;
    message.count = object.count ?? 0;
    message.speed = object.speed ?? 0;
    return message;
  },
};

function createBaseCMsgTEBubbleTrail(): CMsgTEBubbleTrail {
  return { mins: undefined, maxs: undefined, waterz: 0, count: 0, speed: 0 };
}

export const CMsgTEBubbleTrail = {
  encode(message: CMsgTEBubbleTrail, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.mins !== undefined) {
      CMsgVector.encode(message.mins, writer.uint32(10).fork()).ldelim();
    }
    if (message.maxs !== undefined) {
      CMsgVector.encode(message.maxs, writer.uint32(18).fork()).ldelim();
    }
    if (message.waterz !== undefined && message.waterz !== 0) {
      writer.uint32(29).float(message.waterz);
    }
    if (message.count !== undefined && message.count !== 0) {
      writer.uint32(32).uint32(message.count);
    }
    if (message.speed !== undefined && message.speed !== 0) {
      writer.uint32(45).float(message.speed);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgTEBubbleTrail {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgTEBubbleTrail();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.mins = CMsgVector.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.maxs = CMsgVector.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.waterz = reader.float();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.count = reader.uint32();
          continue;
        case 5:
          if (tag !== 45) {
            break;
          }

          message.speed = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgTEBubbleTrail {
    return {
      mins: isSet(object.mins) ? CMsgVector.fromJSON(object.mins) : undefined,
      maxs: isSet(object.maxs) ? CMsgVector.fromJSON(object.maxs) : undefined,
      waterz: isSet(object.waterz) ? globalThis.Number(object.waterz) : 0,
      count: isSet(object.count) ? globalThis.Number(object.count) : 0,
      speed: isSet(object.speed) ? globalThis.Number(object.speed) : 0,
    };
  },

  toJSON(message: CMsgTEBubbleTrail): unknown {
    const obj: any = {};
    if (message.mins !== undefined) {
      obj.mins = CMsgVector.toJSON(message.mins);
    }
    if (message.maxs !== undefined) {
      obj.maxs = CMsgVector.toJSON(message.maxs);
    }
    if (message.waterz !== undefined && message.waterz !== 0) {
      obj.waterz = message.waterz;
    }
    if (message.count !== undefined && message.count !== 0) {
      obj.count = Math.round(message.count);
    }
    if (message.speed !== undefined && message.speed !== 0) {
      obj.speed = message.speed;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgTEBubbleTrail>): CMsgTEBubbleTrail {
    return CMsgTEBubbleTrail.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgTEBubbleTrail>): CMsgTEBubbleTrail {
    const message = createBaseCMsgTEBubbleTrail();
    message.mins = object.mins !== undefined && object.mins !== null ? CMsgVector.fromPartial(object.mins) : undefined;
    message.maxs = object.maxs !== undefined && object.maxs !== null ? CMsgVector.fromPartial(object.maxs) : undefined;
    message.waterz = object.waterz ?? 0;
    message.count = object.count ?? 0;
    message.speed = object.speed ?? 0;
    return message;
  },
};

function createBaseCMsgTEDecal(): CMsgTEDecal {
  return { origin: undefined, start: undefined, entity: -1, hitbox: 0, index: 0 };
}

export const CMsgTEDecal = {
  encode(message: CMsgTEDecal, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.origin !== undefined) {
      CMsgVector.encode(message.origin, writer.uint32(10).fork()).ldelim();
    }
    if (message.start !== undefined) {
      CMsgVector.encode(message.start, writer.uint32(18).fork()).ldelim();
    }
    if (message.entity !== undefined && message.entity !== -1) {
      writer.uint32(24).int32(message.entity);
    }
    if (message.hitbox !== undefined && message.hitbox !== 0) {
      writer.uint32(32).uint32(message.hitbox);
    }
    if (message.index !== undefined && message.index !== 0) {
      writer.uint32(40).uint32(message.index);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgTEDecal {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgTEDecal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.origin = CMsgVector.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.start = CMsgVector.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.entity = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.hitbox = reader.uint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.index = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgTEDecal {
    return {
      origin: isSet(object.origin) ? CMsgVector.fromJSON(object.origin) : undefined,
      start: isSet(object.start) ? CMsgVector.fromJSON(object.start) : undefined,
      entity: isSet(object.entity) ? globalThis.Number(object.entity) : -1,
      hitbox: isSet(object.hitbox) ? globalThis.Number(object.hitbox) : 0,
      index: isSet(object.index) ? globalThis.Number(object.index) : 0,
    };
  },

  toJSON(message: CMsgTEDecal): unknown {
    const obj: any = {};
    if (message.origin !== undefined) {
      obj.origin = CMsgVector.toJSON(message.origin);
    }
    if (message.start !== undefined) {
      obj.start = CMsgVector.toJSON(message.start);
    }
    if (message.entity !== undefined && message.entity !== -1) {
      obj.entity = Math.round(message.entity);
    }
    if (message.hitbox !== undefined && message.hitbox !== 0) {
      obj.hitbox = Math.round(message.hitbox);
    }
    if (message.index !== undefined && message.index !== 0) {
      obj.index = Math.round(message.index);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgTEDecal>): CMsgTEDecal {
    return CMsgTEDecal.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgTEDecal>): CMsgTEDecal {
    const message = createBaseCMsgTEDecal();
    message.origin =
      object.origin !== undefined && object.origin !== null ? CMsgVector.fromPartial(object.origin) : undefined;
    message.start =
      object.start !== undefined && object.start !== null ? CMsgVector.fromPartial(object.start) : undefined;
    message.entity = object.entity ?? -1;
    message.hitbox = object.hitbox ?? 0;
    message.index = object.index ?? 0;
    return message;
  },
};

function createBaseCMsgEffectData(): CMsgEffectData {
  return {
    origin: undefined,
    start: undefined,
    normal: undefined,
    angles: undefined,
    entity: 16777215,
    otherentity: 16777215,
    scale: 0,
    magnitude: 0,
    radius: 0,
    surfaceprop: 0,
    effectindex: "0",
    damagetype: 0,
    material: 0,
    hitbox: 0,
    color: 0,
    flags: 0,
    attachmentindex: 0,
    effectname: 0,
    attachmentname: 0,
  };
}

export const CMsgEffectData = {
  encode(message: CMsgEffectData, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.origin !== undefined) {
      CMsgVector.encode(message.origin, writer.uint32(10).fork()).ldelim();
    }
    if (message.start !== undefined) {
      CMsgVector.encode(message.start, writer.uint32(18).fork()).ldelim();
    }
    if (message.normal !== undefined) {
      CMsgVector.encode(message.normal, writer.uint32(26).fork()).ldelim();
    }
    if (message.angles !== undefined) {
      CMsgQAngle.encode(message.angles, writer.uint32(34).fork()).ldelim();
    }
    if (message.entity !== undefined && message.entity !== 16777215) {
      writer.uint32(45).fixed32(message.entity);
    }
    if (message.otherentity !== undefined && message.otherentity !== 16777215) {
      writer.uint32(53).fixed32(message.otherentity);
    }
    if (message.scale !== undefined && message.scale !== 0) {
      writer.uint32(61).float(message.scale);
    }
    if (message.magnitude !== undefined && message.magnitude !== 0) {
      writer.uint32(69).float(message.magnitude);
    }
    if (message.radius !== undefined && message.radius !== 0) {
      writer.uint32(77).float(message.radius);
    }
    if (message.surfaceprop !== undefined && message.surfaceprop !== 0) {
      writer.uint32(85).fixed32(message.surfaceprop);
    }
    if (message.effectindex !== undefined && message.effectindex !== "0") {
      writer.uint32(89).fixed64(message.effectindex);
    }
    if (message.damagetype !== undefined && message.damagetype !== 0) {
      writer.uint32(96).uint32(message.damagetype);
    }
    if (message.material !== undefined && message.material !== 0) {
      writer.uint32(104).uint32(message.material);
    }
    if (message.hitbox !== undefined && message.hitbox !== 0) {
      writer.uint32(112).uint32(message.hitbox);
    }
    if (message.color !== undefined && message.color !== 0) {
      writer.uint32(120).uint32(message.color);
    }
    if (message.flags !== undefined && message.flags !== 0) {
      writer.uint32(128).uint32(message.flags);
    }
    if (message.attachmentindex !== undefined && message.attachmentindex !== 0) {
      writer.uint32(136).int32(message.attachmentindex);
    }
    if (message.effectname !== undefined && message.effectname !== 0) {
      writer.uint32(144).uint32(message.effectname);
    }
    if (message.attachmentname !== undefined && message.attachmentname !== 0) {
      writer.uint32(152).uint32(message.attachmentname);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgEffectData {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgEffectData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.origin = CMsgVector.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.start = CMsgVector.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.normal = CMsgVector.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.angles = CMsgQAngle.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 45) {
            break;
          }

          message.entity = reader.fixed32();
          continue;
        case 6:
          if (tag !== 53) {
            break;
          }

          message.otherentity = reader.fixed32();
          continue;
        case 7:
          if (tag !== 61) {
            break;
          }

          message.scale = reader.float();
          continue;
        case 8:
          if (tag !== 69) {
            break;
          }

          message.magnitude = reader.float();
          continue;
        case 9:
          if (tag !== 77) {
            break;
          }

          message.radius = reader.float();
          continue;
        case 10:
          if (tag !== 85) {
            break;
          }

          message.surfaceprop = reader.fixed32();
          continue;
        case 11:
          if (tag !== 89) {
            break;
          }

          message.effectindex = longToString(reader.fixed64() as Long);
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.damagetype = reader.uint32();
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.material = reader.uint32();
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.hitbox = reader.uint32();
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.color = reader.uint32();
          continue;
        case 16:
          if (tag !== 128) {
            break;
          }

          message.flags = reader.uint32();
          continue;
        case 17:
          if (tag !== 136) {
            break;
          }

          message.attachmentindex = reader.int32();
          continue;
        case 18:
          if (tag !== 144) {
            break;
          }

          message.effectname = reader.uint32();
          continue;
        case 19:
          if (tag !== 152) {
            break;
          }

          message.attachmentname = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgEffectData {
    return {
      origin: isSet(object.origin) ? CMsgVector.fromJSON(object.origin) : undefined,
      start: isSet(object.start) ? CMsgVector.fromJSON(object.start) : undefined,
      normal: isSet(object.normal) ? CMsgVector.fromJSON(object.normal) : undefined,
      angles: isSet(object.angles) ? CMsgQAngle.fromJSON(object.angles) : undefined,
      entity: isSet(object.entity) ? globalThis.Number(object.entity) : 16777215,
      otherentity: isSet(object.otherentity) ? globalThis.Number(object.otherentity) : 16777215,
      scale: isSet(object.scale) ? globalThis.Number(object.scale) : 0,
      magnitude: isSet(object.magnitude) ? globalThis.Number(object.magnitude) : 0,
      radius: isSet(object.radius) ? globalThis.Number(object.radius) : 0,
      surfaceprop: isSet(object.surfaceprop) ? globalThis.Number(object.surfaceprop) : 0,
      effectindex: isSet(object.effectindex) ? globalThis.String(object.effectindex) : "0",
      damagetype: isSet(object.damagetype) ? globalThis.Number(object.damagetype) : 0,
      material: isSet(object.material) ? globalThis.Number(object.material) : 0,
      hitbox: isSet(object.hitbox) ? globalThis.Number(object.hitbox) : 0,
      color: isSet(object.color) ? globalThis.Number(object.color) : 0,
      flags: isSet(object.flags) ? globalThis.Number(object.flags) : 0,
      attachmentindex: isSet(object.attachmentindex) ? globalThis.Number(object.attachmentindex) : 0,
      effectname: isSet(object.effectname) ? globalThis.Number(object.effectname) : 0,
      attachmentname: isSet(object.attachmentname) ? globalThis.Number(object.attachmentname) : 0,
    };
  },

  toJSON(message: CMsgEffectData): unknown {
    const obj: any = {};
    if (message.origin !== undefined) {
      obj.origin = CMsgVector.toJSON(message.origin);
    }
    if (message.start !== undefined) {
      obj.start = CMsgVector.toJSON(message.start);
    }
    if (message.normal !== undefined) {
      obj.normal = CMsgVector.toJSON(message.normal);
    }
    if (message.angles !== undefined) {
      obj.angles = CMsgQAngle.toJSON(message.angles);
    }
    if (message.entity !== undefined && message.entity !== 16777215) {
      obj.entity = Math.round(message.entity);
    }
    if (message.otherentity !== undefined && message.otherentity !== 16777215) {
      obj.otherentity = Math.round(message.otherentity);
    }
    if (message.scale !== undefined && message.scale !== 0) {
      obj.scale = message.scale;
    }
    if (message.magnitude !== undefined && message.magnitude !== 0) {
      obj.magnitude = message.magnitude;
    }
    if (message.radius !== undefined && message.radius !== 0) {
      obj.radius = message.radius;
    }
    if (message.surfaceprop !== undefined && message.surfaceprop !== 0) {
      obj.surfaceprop = Math.round(message.surfaceprop);
    }
    if (message.effectindex !== undefined && message.effectindex !== "0") {
      obj.effectindex = message.effectindex;
    }
    if (message.damagetype !== undefined && message.damagetype !== 0) {
      obj.damagetype = Math.round(message.damagetype);
    }
    if (message.material !== undefined && message.material !== 0) {
      obj.material = Math.round(message.material);
    }
    if (message.hitbox !== undefined && message.hitbox !== 0) {
      obj.hitbox = Math.round(message.hitbox);
    }
    if (message.color !== undefined && message.color !== 0) {
      obj.color = Math.round(message.color);
    }
    if (message.flags !== undefined && message.flags !== 0) {
      obj.flags = Math.round(message.flags);
    }
    if (message.attachmentindex !== undefined && message.attachmentindex !== 0) {
      obj.attachmentindex = Math.round(message.attachmentindex);
    }
    if (message.effectname !== undefined && message.effectname !== 0) {
      obj.effectname = Math.round(message.effectname);
    }
    if (message.attachmentname !== undefined && message.attachmentname !== 0) {
      obj.attachmentname = Math.round(message.attachmentname);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgEffectData>): CMsgEffectData {
    return CMsgEffectData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgEffectData>): CMsgEffectData {
    const message = createBaseCMsgEffectData();
    message.origin =
      object.origin !== undefined && object.origin !== null ? CMsgVector.fromPartial(object.origin) : undefined;
    message.start =
      object.start !== undefined && object.start !== null ? CMsgVector.fromPartial(object.start) : undefined;
    message.normal =
      object.normal !== undefined && object.normal !== null ? CMsgVector.fromPartial(object.normal) : undefined;
    message.angles =
      object.angles !== undefined && object.angles !== null ? CMsgQAngle.fromPartial(object.angles) : undefined;
    message.entity = object.entity ?? 16777215;
    message.otherentity = object.otherentity ?? 16777215;
    message.scale = object.scale ?? 0;
    message.magnitude = object.magnitude ?? 0;
    message.radius = object.radius ?? 0;
    message.surfaceprop = object.surfaceprop ?? 0;
    message.effectindex = object.effectindex ?? "0";
    message.damagetype = object.damagetype ?? 0;
    message.material = object.material ?? 0;
    message.hitbox = object.hitbox ?? 0;
    message.color = object.color ?? 0;
    message.flags = object.flags ?? 0;
    message.attachmentindex = object.attachmentindex ?? 0;
    message.effectname = object.effectname ?? 0;
    message.attachmentname = object.attachmentname ?? 0;
    return message;
  },
};

function createBaseCMsgTEEffectDispatch(): CMsgTEEffectDispatch {
  return { effectdata: undefined };
}

export const CMsgTEEffectDispatch = {
  encode(message: CMsgTEEffectDispatch, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.effectdata !== undefined) {
      CMsgEffectData.encode(message.effectdata, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgTEEffectDispatch {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgTEEffectDispatch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.effectdata = CMsgEffectData.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgTEEffectDispatch {
    return { effectdata: isSet(object.effectdata) ? CMsgEffectData.fromJSON(object.effectdata) : undefined };
  },

  toJSON(message: CMsgTEEffectDispatch): unknown {
    const obj: any = {};
    if (message.effectdata !== undefined) {
      obj.effectdata = CMsgEffectData.toJSON(message.effectdata);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgTEEffectDispatch>): CMsgTEEffectDispatch {
    return CMsgTEEffectDispatch.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgTEEffectDispatch>): CMsgTEEffectDispatch {
    const message = createBaseCMsgTEEffectDispatch();
    message.effectdata =
      object.effectdata !== undefined && object.effectdata !== null
        ? CMsgEffectData.fromPartial(object.effectdata)
        : undefined;
    return message;
  },
};

function createBaseCMsgTEEnergySplash(): CMsgTEEnergySplash {
  return { pos: undefined, dir: undefined, explosive: false };
}

export const CMsgTEEnergySplash = {
  encode(message: CMsgTEEnergySplash, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.pos !== undefined) {
      CMsgVector.encode(message.pos, writer.uint32(10).fork()).ldelim();
    }
    if (message.dir !== undefined) {
      CMsgVector.encode(message.dir, writer.uint32(18).fork()).ldelim();
    }
    if (message.explosive !== undefined && message.explosive !== false) {
      writer.uint32(24).bool(message.explosive);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgTEEnergySplash {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgTEEnergySplash();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.pos = CMsgVector.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.dir = CMsgVector.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.explosive = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgTEEnergySplash {
    return {
      pos: isSet(object.pos) ? CMsgVector.fromJSON(object.pos) : undefined,
      dir: isSet(object.dir) ? CMsgVector.fromJSON(object.dir) : undefined,
      explosive: isSet(object.explosive) ? globalThis.Boolean(object.explosive) : false,
    };
  },

  toJSON(message: CMsgTEEnergySplash): unknown {
    const obj: any = {};
    if (message.pos !== undefined) {
      obj.pos = CMsgVector.toJSON(message.pos);
    }
    if (message.dir !== undefined) {
      obj.dir = CMsgVector.toJSON(message.dir);
    }
    if (message.explosive !== undefined && message.explosive !== false) {
      obj.explosive = message.explosive;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgTEEnergySplash>): CMsgTEEnergySplash {
    return CMsgTEEnergySplash.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgTEEnergySplash>): CMsgTEEnergySplash {
    const message = createBaseCMsgTEEnergySplash();
    message.pos = object.pos !== undefined && object.pos !== null ? CMsgVector.fromPartial(object.pos) : undefined;
    message.dir = object.dir !== undefined && object.dir !== null ? CMsgVector.fromPartial(object.dir) : undefined;
    message.explosive = object.explosive ?? false;
    return message;
  },
};

function createBaseCMsgTEFizz(): CMsgTEFizz {
  return { entity: -1, density: 0, current: 0 };
}

export const CMsgTEFizz = {
  encode(message: CMsgTEFizz, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.entity !== undefined && message.entity !== -1) {
      writer.uint32(8).int32(message.entity);
    }
    if (message.density !== undefined && message.density !== 0) {
      writer.uint32(16).uint32(message.density);
    }
    if (message.current !== undefined && message.current !== 0) {
      writer.uint32(24).int32(message.current);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgTEFizz {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgTEFizz();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.entity = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.density = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.current = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgTEFizz {
    return {
      entity: isSet(object.entity) ? globalThis.Number(object.entity) : -1,
      density: isSet(object.density) ? globalThis.Number(object.density) : 0,
      current: isSet(object.current) ? globalThis.Number(object.current) : 0,
    };
  },

  toJSON(message: CMsgTEFizz): unknown {
    const obj: any = {};
    if (message.entity !== undefined && message.entity !== -1) {
      obj.entity = Math.round(message.entity);
    }
    if (message.density !== undefined && message.density !== 0) {
      obj.density = Math.round(message.density);
    }
    if (message.current !== undefined && message.current !== 0) {
      obj.current = Math.round(message.current);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgTEFizz>): CMsgTEFizz {
    return CMsgTEFizz.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgTEFizz>): CMsgTEFizz {
    const message = createBaseCMsgTEFizz();
    message.entity = object.entity ?? -1;
    message.density = object.density ?? 0;
    message.current = object.current ?? 0;
    return message;
  },
};

function createBaseCMsgTEShatterSurface(): CMsgTEShatterSurface {
  return {
    origin: undefined,
    angles: undefined,
    force: undefined,
    forcepos: undefined,
    width: 0,
    height: 0,
    shardsize: 0,
    surfacetype: 0,
    frontcolor: 0,
    backcolor: 0,
  };
}

export const CMsgTEShatterSurface = {
  encode(message: CMsgTEShatterSurface, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.origin !== undefined) {
      CMsgVector.encode(message.origin, writer.uint32(10).fork()).ldelim();
    }
    if (message.angles !== undefined) {
      CMsgQAngle.encode(message.angles, writer.uint32(18).fork()).ldelim();
    }
    if (message.force !== undefined) {
      CMsgVector.encode(message.force, writer.uint32(26).fork()).ldelim();
    }
    if (message.forcepos !== undefined) {
      CMsgVector.encode(message.forcepos, writer.uint32(34).fork()).ldelim();
    }
    if (message.width !== undefined && message.width !== 0) {
      writer.uint32(45).float(message.width);
    }
    if (message.height !== undefined && message.height !== 0) {
      writer.uint32(53).float(message.height);
    }
    if (message.shardsize !== undefined && message.shardsize !== 0) {
      writer.uint32(61).float(message.shardsize);
    }
    if (message.surfacetype !== undefined && message.surfacetype !== 0) {
      writer.uint32(64).uint32(message.surfacetype);
    }
    if (message.frontcolor !== undefined && message.frontcolor !== 0) {
      writer.uint32(77).fixed32(message.frontcolor);
    }
    if (message.backcolor !== undefined && message.backcolor !== 0) {
      writer.uint32(85).fixed32(message.backcolor);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgTEShatterSurface {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgTEShatterSurface();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.origin = CMsgVector.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.angles = CMsgQAngle.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.force = CMsgVector.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.forcepos = CMsgVector.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 45) {
            break;
          }

          message.width = reader.float();
          continue;
        case 6:
          if (tag !== 53) {
            break;
          }

          message.height = reader.float();
          continue;
        case 7:
          if (tag !== 61) {
            break;
          }

          message.shardsize = reader.float();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.surfacetype = reader.uint32();
          continue;
        case 9:
          if (tag !== 77) {
            break;
          }

          message.frontcolor = reader.fixed32();
          continue;
        case 10:
          if (tag !== 85) {
            break;
          }

          message.backcolor = reader.fixed32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgTEShatterSurface {
    return {
      origin: isSet(object.origin) ? CMsgVector.fromJSON(object.origin) : undefined,
      angles: isSet(object.angles) ? CMsgQAngle.fromJSON(object.angles) : undefined,
      force: isSet(object.force) ? CMsgVector.fromJSON(object.force) : undefined,
      forcepos: isSet(object.forcepos) ? CMsgVector.fromJSON(object.forcepos) : undefined,
      width: isSet(object.width) ? globalThis.Number(object.width) : 0,
      height: isSet(object.height) ? globalThis.Number(object.height) : 0,
      shardsize: isSet(object.shardsize) ? globalThis.Number(object.shardsize) : 0,
      surfacetype: isSet(object.surfacetype) ? globalThis.Number(object.surfacetype) : 0,
      frontcolor: isSet(object.frontcolor) ? globalThis.Number(object.frontcolor) : 0,
      backcolor: isSet(object.backcolor) ? globalThis.Number(object.backcolor) : 0,
    };
  },

  toJSON(message: CMsgTEShatterSurface): unknown {
    const obj: any = {};
    if (message.origin !== undefined) {
      obj.origin = CMsgVector.toJSON(message.origin);
    }
    if (message.angles !== undefined) {
      obj.angles = CMsgQAngle.toJSON(message.angles);
    }
    if (message.force !== undefined) {
      obj.force = CMsgVector.toJSON(message.force);
    }
    if (message.forcepos !== undefined) {
      obj.forcepos = CMsgVector.toJSON(message.forcepos);
    }
    if (message.width !== undefined && message.width !== 0) {
      obj.width = message.width;
    }
    if (message.height !== undefined && message.height !== 0) {
      obj.height = message.height;
    }
    if (message.shardsize !== undefined && message.shardsize !== 0) {
      obj.shardsize = message.shardsize;
    }
    if (message.surfacetype !== undefined && message.surfacetype !== 0) {
      obj.surfacetype = Math.round(message.surfacetype);
    }
    if (message.frontcolor !== undefined && message.frontcolor !== 0) {
      obj.frontcolor = Math.round(message.frontcolor);
    }
    if (message.backcolor !== undefined && message.backcolor !== 0) {
      obj.backcolor = Math.round(message.backcolor);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgTEShatterSurface>): CMsgTEShatterSurface {
    return CMsgTEShatterSurface.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgTEShatterSurface>): CMsgTEShatterSurface {
    const message = createBaseCMsgTEShatterSurface();
    message.origin =
      object.origin !== undefined && object.origin !== null ? CMsgVector.fromPartial(object.origin) : undefined;
    message.angles =
      object.angles !== undefined && object.angles !== null ? CMsgQAngle.fromPartial(object.angles) : undefined;
    message.force =
      object.force !== undefined && object.force !== null ? CMsgVector.fromPartial(object.force) : undefined;
    message.forcepos =
      object.forcepos !== undefined && object.forcepos !== null ? CMsgVector.fromPartial(object.forcepos) : undefined;
    message.width = object.width ?? 0;
    message.height = object.height ?? 0;
    message.shardsize = object.shardsize ?? 0;
    message.surfacetype = object.surfacetype ?? 0;
    message.frontcolor = object.frontcolor ?? 0;
    message.backcolor = object.backcolor ?? 0;
    return message;
  },
};

function createBaseCMsgTEGlowSprite(): CMsgTEGlowSprite {
  return { origin: undefined, scale: 0, life: 0, brightness: 0 };
}

export const CMsgTEGlowSprite = {
  encode(message: CMsgTEGlowSprite, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.origin !== undefined) {
      CMsgVector.encode(message.origin, writer.uint32(10).fork()).ldelim();
    }
    if (message.scale !== undefined && message.scale !== 0) {
      writer.uint32(21).float(message.scale);
    }
    if (message.life !== undefined && message.life !== 0) {
      writer.uint32(29).float(message.life);
    }
    if (message.brightness !== undefined && message.brightness !== 0) {
      writer.uint32(32).uint32(message.brightness);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgTEGlowSprite {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgTEGlowSprite();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.origin = CMsgVector.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.scale = reader.float();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.life = reader.float();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.brightness = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgTEGlowSprite {
    return {
      origin: isSet(object.origin) ? CMsgVector.fromJSON(object.origin) : undefined,
      scale: isSet(object.scale) ? globalThis.Number(object.scale) : 0,
      life: isSet(object.life) ? globalThis.Number(object.life) : 0,
      brightness: isSet(object.brightness) ? globalThis.Number(object.brightness) : 0,
    };
  },

  toJSON(message: CMsgTEGlowSprite): unknown {
    const obj: any = {};
    if (message.origin !== undefined) {
      obj.origin = CMsgVector.toJSON(message.origin);
    }
    if (message.scale !== undefined && message.scale !== 0) {
      obj.scale = message.scale;
    }
    if (message.life !== undefined && message.life !== 0) {
      obj.life = message.life;
    }
    if (message.brightness !== undefined && message.brightness !== 0) {
      obj.brightness = Math.round(message.brightness);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgTEGlowSprite>): CMsgTEGlowSprite {
    return CMsgTEGlowSprite.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgTEGlowSprite>): CMsgTEGlowSprite {
    const message = createBaseCMsgTEGlowSprite();
    message.origin =
      object.origin !== undefined && object.origin !== null ? CMsgVector.fromPartial(object.origin) : undefined;
    message.scale = object.scale ?? 0;
    message.life = object.life ?? 0;
    message.brightness = object.brightness ?? 0;
    return message;
  },
};

function createBaseCMsgTEImpact(): CMsgTEImpact {
  return { origin: undefined, normal: undefined, type: 0 };
}

export const CMsgTEImpact = {
  encode(message: CMsgTEImpact, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.origin !== undefined) {
      CMsgVector.encode(message.origin, writer.uint32(10).fork()).ldelim();
    }
    if (message.normal !== undefined) {
      CMsgVector.encode(message.normal, writer.uint32(18).fork()).ldelim();
    }
    if (message.type !== undefined && message.type !== 0) {
      writer.uint32(24).uint32(message.type);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgTEImpact {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgTEImpact();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.origin = CMsgVector.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.normal = CMsgVector.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.type = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgTEImpact {
    return {
      origin: isSet(object.origin) ? CMsgVector.fromJSON(object.origin) : undefined,
      normal: isSet(object.normal) ? CMsgVector.fromJSON(object.normal) : undefined,
      type: isSet(object.type) ? globalThis.Number(object.type) : 0,
    };
  },

  toJSON(message: CMsgTEImpact): unknown {
    const obj: any = {};
    if (message.origin !== undefined) {
      obj.origin = CMsgVector.toJSON(message.origin);
    }
    if (message.normal !== undefined) {
      obj.normal = CMsgVector.toJSON(message.normal);
    }
    if (message.type !== undefined && message.type !== 0) {
      obj.type = Math.round(message.type);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgTEImpact>): CMsgTEImpact {
    return CMsgTEImpact.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgTEImpact>): CMsgTEImpact {
    const message = createBaseCMsgTEImpact();
    message.origin =
      object.origin !== undefined && object.origin !== null ? CMsgVector.fromPartial(object.origin) : undefined;
    message.normal =
      object.normal !== undefined && object.normal !== null ? CMsgVector.fromPartial(object.normal) : undefined;
    message.type = object.type ?? 0;
    return message;
  },
};

function createBaseCMsgTEMuzzleFlash(): CMsgTEMuzzleFlash {
  return { origin: undefined, angles: undefined, scale: 0, type: 0 };
}

export const CMsgTEMuzzleFlash = {
  encode(message: CMsgTEMuzzleFlash, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.origin !== undefined) {
      CMsgVector.encode(message.origin, writer.uint32(10).fork()).ldelim();
    }
    if (message.angles !== undefined) {
      CMsgQAngle.encode(message.angles, writer.uint32(18).fork()).ldelim();
    }
    if (message.scale !== undefined && message.scale !== 0) {
      writer.uint32(29).float(message.scale);
    }
    if (message.type !== undefined && message.type !== 0) {
      writer.uint32(32).uint32(message.type);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgTEMuzzleFlash {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgTEMuzzleFlash();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.origin = CMsgVector.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.angles = CMsgQAngle.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.scale = reader.float();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.type = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgTEMuzzleFlash {
    return {
      origin: isSet(object.origin) ? CMsgVector.fromJSON(object.origin) : undefined,
      angles: isSet(object.angles) ? CMsgQAngle.fromJSON(object.angles) : undefined,
      scale: isSet(object.scale) ? globalThis.Number(object.scale) : 0,
      type: isSet(object.type) ? globalThis.Number(object.type) : 0,
    };
  },

  toJSON(message: CMsgTEMuzzleFlash): unknown {
    const obj: any = {};
    if (message.origin !== undefined) {
      obj.origin = CMsgVector.toJSON(message.origin);
    }
    if (message.angles !== undefined) {
      obj.angles = CMsgQAngle.toJSON(message.angles);
    }
    if (message.scale !== undefined && message.scale !== 0) {
      obj.scale = message.scale;
    }
    if (message.type !== undefined && message.type !== 0) {
      obj.type = Math.round(message.type);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgTEMuzzleFlash>): CMsgTEMuzzleFlash {
    return CMsgTEMuzzleFlash.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgTEMuzzleFlash>): CMsgTEMuzzleFlash {
    const message = createBaseCMsgTEMuzzleFlash();
    message.origin =
      object.origin !== undefined && object.origin !== null ? CMsgVector.fromPartial(object.origin) : undefined;
    message.angles =
      object.angles !== undefined && object.angles !== null ? CMsgQAngle.fromPartial(object.angles) : undefined;
    message.scale = object.scale ?? 0;
    message.type = object.type ?? 0;
    return message;
  },
};

function createBaseCMsgTEBloodStream(): CMsgTEBloodStream {
  return { origin: undefined, direction: undefined, color: 0, amount: 0 };
}

export const CMsgTEBloodStream = {
  encode(message: CMsgTEBloodStream, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.origin !== undefined) {
      CMsgVector.encode(message.origin, writer.uint32(10).fork()).ldelim();
    }
    if (message.direction !== undefined) {
      CMsgVector.encode(message.direction, writer.uint32(18).fork()).ldelim();
    }
    if (message.color !== undefined && message.color !== 0) {
      writer.uint32(29).fixed32(message.color);
    }
    if (message.amount !== undefined && message.amount !== 0) {
      writer.uint32(32).uint32(message.amount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgTEBloodStream {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgTEBloodStream();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.origin = CMsgVector.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.direction = CMsgVector.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.color = reader.fixed32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.amount = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgTEBloodStream {
    return {
      origin: isSet(object.origin) ? CMsgVector.fromJSON(object.origin) : undefined,
      direction: isSet(object.direction) ? CMsgVector.fromJSON(object.direction) : undefined,
      color: isSet(object.color) ? globalThis.Number(object.color) : 0,
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
    };
  },

  toJSON(message: CMsgTEBloodStream): unknown {
    const obj: any = {};
    if (message.origin !== undefined) {
      obj.origin = CMsgVector.toJSON(message.origin);
    }
    if (message.direction !== undefined) {
      obj.direction = CMsgVector.toJSON(message.direction);
    }
    if (message.color !== undefined && message.color !== 0) {
      obj.color = Math.round(message.color);
    }
    if (message.amount !== undefined && message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgTEBloodStream>): CMsgTEBloodStream {
    return CMsgTEBloodStream.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgTEBloodStream>): CMsgTEBloodStream {
    const message = createBaseCMsgTEBloodStream();
    message.origin =
      object.origin !== undefined && object.origin !== null ? CMsgVector.fromPartial(object.origin) : undefined;
    message.direction =
      object.direction !== undefined && object.direction !== null
        ? CMsgVector.fromPartial(object.direction)
        : undefined;
    message.color = object.color ?? 0;
    message.amount = object.amount ?? 0;
    return message;
  },
};

function createBaseCMsgTEExplosion(): CMsgTEExplosion {
  return {
    origin: undefined,
    framerate: 0,
    flags: 0,
    normal: undefined,
    materialtype: 0,
    radius: 0,
    magnitude: 0,
    scale: 0,
    affectRagdolls: false,
    effectName: "",
    explosionType: 0,
  };
}

export const CMsgTEExplosion = {
  encode(message: CMsgTEExplosion, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.origin !== undefined) {
      CMsgVector.encode(message.origin, writer.uint32(10).fork()).ldelim();
    }
    if (message.framerate !== undefined && message.framerate !== 0) {
      writer.uint32(16).uint32(message.framerate);
    }
    if (message.flags !== undefined && message.flags !== 0) {
      writer.uint32(24).uint32(message.flags);
    }
    if (message.normal !== undefined) {
      CMsgVector.encode(message.normal, writer.uint32(34).fork()).ldelim();
    }
    if (message.materialtype !== undefined && message.materialtype !== 0) {
      writer.uint32(40).uint32(message.materialtype);
    }
    if (message.radius !== undefined && message.radius !== 0) {
      writer.uint32(48).uint32(message.radius);
    }
    if (message.magnitude !== undefined && message.magnitude !== 0) {
      writer.uint32(56).uint32(message.magnitude);
    }
    if (message.scale !== undefined && message.scale !== 0) {
      writer.uint32(69).float(message.scale);
    }
    if (message.affectRagdolls !== undefined && message.affectRagdolls !== false) {
      writer.uint32(72).bool(message.affectRagdolls);
    }
    if (message.effectName !== undefined && message.effectName !== "") {
      writer.uint32(82).string(message.effectName);
    }
    if (message.explosionType !== undefined && message.explosionType !== 0) {
      writer.uint32(88).uint32(message.explosionType);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgTEExplosion {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgTEExplosion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.origin = CMsgVector.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.framerate = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.flags = reader.uint32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.normal = CMsgVector.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.materialtype = reader.uint32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.radius = reader.uint32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.magnitude = reader.uint32();
          continue;
        case 8:
          if (tag !== 69) {
            break;
          }

          message.scale = reader.float();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.affectRagdolls = reader.bool();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.effectName = reader.string();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.explosionType = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgTEExplosion {
    return {
      origin: isSet(object.origin) ? CMsgVector.fromJSON(object.origin) : undefined,
      framerate: isSet(object.framerate) ? globalThis.Number(object.framerate) : 0,
      flags: isSet(object.flags) ? globalThis.Number(object.flags) : 0,
      normal: isSet(object.normal) ? CMsgVector.fromJSON(object.normal) : undefined,
      materialtype: isSet(object.materialtype) ? globalThis.Number(object.materialtype) : 0,
      radius: isSet(object.radius) ? globalThis.Number(object.radius) : 0,
      magnitude: isSet(object.magnitude) ? globalThis.Number(object.magnitude) : 0,
      scale: isSet(object.scale) ? globalThis.Number(object.scale) : 0,
      affectRagdolls: isSet(object.affectRagdolls) ? globalThis.Boolean(object.affectRagdolls) : false,
      effectName: isSet(object.effectName) ? globalThis.String(object.effectName) : "",
      explosionType: isSet(object.explosionType) ? globalThis.Number(object.explosionType) : 0,
    };
  },

  toJSON(message: CMsgTEExplosion): unknown {
    const obj: any = {};
    if (message.origin !== undefined) {
      obj.origin = CMsgVector.toJSON(message.origin);
    }
    if (message.framerate !== undefined && message.framerate !== 0) {
      obj.framerate = Math.round(message.framerate);
    }
    if (message.flags !== undefined && message.flags !== 0) {
      obj.flags = Math.round(message.flags);
    }
    if (message.normal !== undefined) {
      obj.normal = CMsgVector.toJSON(message.normal);
    }
    if (message.materialtype !== undefined && message.materialtype !== 0) {
      obj.materialtype = Math.round(message.materialtype);
    }
    if (message.radius !== undefined && message.radius !== 0) {
      obj.radius = Math.round(message.radius);
    }
    if (message.magnitude !== undefined && message.magnitude !== 0) {
      obj.magnitude = Math.round(message.magnitude);
    }
    if (message.scale !== undefined && message.scale !== 0) {
      obj.scale = message.scale;
    }
    if (message.affectRagdolls !== undefined && message.affectRagdolls !== false) {
      obj.affectRagdolls = message.affectRagdolls;
    }
    if (message.effectName !== undefined && message.effectName !== "") {
      obj.effectName = message.effectName;
    }
    if (message.explosionType !== undefined && message.explosionType !== 0) {
      obj.explosionType = Math.round(message.explosionType);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgTEExplosion>): CMsgTEExplosion {
    return CMsgTEExplosion.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgTEExplosion>): CMsgTEExplosion {
    const message = createBaseCMsgTEExplosion();
    message.origin =
      object.origin !== undefined && object.origin !== null ? CMsgVector.fromPartial(object.origin) : undefined;
    message.framerate = object.framerate ?? 0;
    message.flags = object.flags ?? 0;
    message.normal =
      object.normal !== undefined && object.normal !== null ? CMsgVector.fromPartial(object.normal) : undefined;
    message.materialtype = object.materialtype ?? 0;
    message.radius = object.radius ?? 0;
    message.magnitude = object.magnitude ?? 0;
    message.scale = object.scale ?? 0;
    message.affectRagdolls = object.affectRagdolls ?? false;
    message.effectName = object.effectName ?? "";
    message.explosionType = object.explosionType ?? 0;
    return message;
  },
};

function createBaseCMsgTEDust(): CMsgTEDust {
  return { origin: undefined, size: 0, speed: 0, direction: undefined };
}

export const CMsgTEDust = {
  encode(message: CMsgTEDust, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.origin !== undefined) {
      CMsgVector.encode(message.origin, writer.uint32(10).fork()).ldelim();
    }
    if (message.size !== undefined && message.size !== 0) {
      writer.uint32(21).float(message.size);
    }
    if (message.speed !== undefined && message.speed !== 0) {
      writer.uint32(29).float(message.speed);
    }
    if (message.direction !== undefined) {
      CMsgVector.encode(message.direction, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgTEDust {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgTEDust();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.origin = CMsgVector.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.size = reader.float();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.speed = reader.float();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.direction = CMsgVector.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgTEDust {
    return {
      origin: isSet(object.origin) ? CMsgVector.fromJSON(object.origin) : undefined,
      size: isSet(object.size) ? globalThis.Number(object.size) : 0,
      speed: isSet(object.speed) ? globalThis.Number(object.speed) : 0,
      direction: isSet(object.direction) ? CMsgVector.fromJSON(object.direction) : undefined,
    };
  },

  toJSON(message: CMsgTEDust): unknown {
    const obj: any = {};
    if (message.origin !== undefined) {
      obj.origin = CMsgVector.toJSON(message.origin);
    }
    if (message.size !== undefined && message.size !== 0) {
      obj.size = message.size;
    }
    if (message.speed !== undefined && message.speed !== 0) {
      obj.speed = message.speed;
    }
    if (message.direction !== undefined) {
      obj.direction = CMsgVector.toJSON(message.direction);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgTEDust>): CMsgTEDust {
    return CMsgTEDust.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgTEDust>): CMsgTEDust {
    const message = createBaseCMsgTEDust();
    message.origin =
      object.origin !== undefined && object.origin !== null ? CMsgVector.fromPartial(object.origin) : undefined;
    message.size = object.size ?? 0;
    message.speed = object.speed ?? 0;
    message.direction =
      object.direction !== undefined && object.direction !== null
        ? CMsgVector.fromPartial(object.direction)
        : undefined;
    return message;
  },
};

function createBaseCMsgTELargeFunnel(): CMsgTELargeFunnel {
  return { origin: undefined, reversed: 0 };
}

export const CMsgTELargeFunnel = {
  encode(message: CMsgTELargeFunnel, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.origin !== undefined) {
      CMsgVector.encode(message.origin, writer.uint32(10).fork()).ldelim();
    }
    if (message.reversed !== undefined && message.reversed !== 0) {
      writer.uint32(16).uint32(message.reversed);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgTELargeFunnel {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgTELargeFunnel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.origin = CMsgVector.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.reversed = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgTELargeFunnel {
    return {
      origin: isSet(object.origin) ? CMsgVector.fromJSON(object.origin) : undefined,
      reversed: isSet(object.reversed) ? globalThis.Number(object.reversed) : 0,
    };
  },

  toJSON(message: CMsgTELargeFunnel): unknown {
    const obj: any = {};
    if (message.origin !== undefined) {
      obj.origin = CMsgVector.toJSON(message.origin);
    }
    if (message.reversed !== undefined && message.reversed !== 0) {
      obj.reversed = Math.round(message.reversed);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgTELargeFunnel>): CMsgTELargeFunnel {
    return CMsgTELargeFunnel.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgTELargeFunnel>): CMsgTELargeFunnel {
    const message = createBaseCMsgTELargeFunnel();
    message.origin =
      object.origin !== undefined && object.origin !== null ? CMsgVector.fromPartial(object.origin) : undefined;
    message.reversed = object.reversed ?? 0;
    return message;
  },
};

function createBaseCMsgTESparks(): CMsgTESparks {
  return { origin: undefined, magnitude: 0, length: 0, direction: undefined };
}

export const CMsgTESparks = {
  encode(message: CMsgTESparks, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.origin !== undefined) {
      CMsgVector.encode(message.origin, writer.uint32(10).fork()).ldelim();
    }
    if (message.magnitude !== undefined && message.magnitude !== 0) {
      writer.uint32(16).uint32(message.magnitude);
    }
    if (message.length !== undefined && message.length !== 0) {
      writer.uint32(24).uint32(message.length);
    }
    if (message.direction !== undefined) {
      CMsgVector.encode(message.direction, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgTESparks {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgTESparks();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.origin = CMsgVector.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.magnitude = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.length = reader.uint32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.direction = CMsgVector.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgTESparks {
    return {
      origin: isSet(object.origin) ? CMsgVector.fromJSON(object.origin) : undefined,
      magnitude: isSet(object.magnitude) ? globalThis.Number(object.magnitude) : 0,
      length: isSet(object.length) ? globalThis.Number(object.length) : 0,
      direction: isSet(object.direction) ? CMsgVector.fromJSON(object.direction) : undefined,
    };
  },

  toJSON(message: CMsgTESparks): unknown {
    const obj: any = {};
    if (message.origin !== undefined) {
      obj.origin = CMsgVector.toJSON(message.origin);
    }
    if (message.magnitude !== undefined && message.magnitude !== 0) {
      obj.magnitude = Math.round(message.magnitude);
    }
    if (message.length !== undefined && message.length !== 0) {
      obj.length = Math.round(message.length);
    }
    if (message.direction !== undefined) {
      obj.direction = CMsgVector.toJSON(message.direction);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgTESparks>): CMsgTESparks {
    return CMsgTESparks.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgTESparks>): CMsgTESparks {
    const message = createBaseCMsgTESparks();
    message.origin =
      object.origin !== undefined && object.origin !== null ? CMsgVector.fromPartial(object.origin) : undefined;
    message.magnitude = object.magnitude ?? 0;
    message.length = object.length ?? 0;
    message.direction =
      object.direction !== undefined && object.direction !== null
        ? CMsgVector.fromPartial(object.direction)
        : undefined;
    return message;
  },
};

function createBaseCMsgTEPhysicsProp(): CMsgTEPhysicsProp {
  return {
    origin: undefined,
    velocity: undefined,
    angles: undefined,
    skin: 0,
    flags: 0,
    effects: 0,
    color: 0,
    modelindex: "0",
    unusedBreakmodelsnottomake: 0,
    scale: 0,
    dmgpos: undefined,
    dmgdir: undefined,
    dmgtype: 0,
  };
}

export const CMsgTEPhysicsProp = {
  encode(message: CMsgTEPhysicsProp, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.origin !== undefined) {
      CMsgVector.encode(message.origin, writer.uint32(10).fork()).ldelim();
    }
    if (message.velocity !== undefined) {
      CMsgVector.encode(message.velocity, writer.uint32(18).fork()).ldelim();
    }
    if (message.angles !== undefined) {
      CMsgQAngle.encode(message.angles, writer.uint32(26).fork()).ldelim();
    }
    if (message.skin !== undefined && message.skin !== 0) {
      writer.uint32(37).fixed32(message.skin);
    }
    if (message.flags !== undefined && message.flags !== 0) {
      writer.uint32(40).uint32(message.flags);
    }
    if (message.effects !== undefined && message.effects !== 0) {
      writer.uint32(48).uint32(message.effects);
    }
    if (message.color !== undefined && message.color !== 0) {
      writer.uint32(61).fixed32(message.color);
    }
    if (message.modelindex !== undefined && message.modelindex !== "0") {
      writer.uint32(65).fixed64(message.modelindex);
    }
    if (message.unusedBreakmodelsnottomake !== undefined && message.unusedBreakmodelsnottomake !== 0) {
      writer.uint32(72).uint32(message.unusedBreakmodelsnottomake);
    }
    if (message.scale !== undefined && message.scale !== 0) {
      writer.uint32(85).float(message.scale);
    }
    if (message.dmgpos !== undefined) {
      CMsgVector.encode(message.dmgpos, writer.uint32(90).fork()).ldelim();
    }
    if (message.dmgdir !== undefined) {
      CMsgVector.encode(message.dmgdir, writer.uint32(98).fork()).ldelim();
    }
    if (message.dmgtype !== undefined && message.dmgtype !== 0) {
      writer.uint32(104).int32(message.dmgtype);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgTEPhysicsProp {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgTEPhysicsProp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.origin = CMsgVector.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.velocity = CMsgVector.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.angles = CMsgQAngle.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 37) {
            break;
          }

          message.skin = reader.fixed32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.flags = reader.uint32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.effects = reader.uint32();
          continue;
        case 7:
          if (tag !== 61) {
            break;
          }

          message.color = reader.fixed32();
          continue;
        case 8:
          if (tag !== 65) {
            break;
          }

          message.modelindex = longToString(reader.fixed64() as Long);
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.unusedBreakmodelsnottomake = reader.uint32();
          continue;
        case 10:
          if (tag !== 85) {
            break;
          }

          message.scale = reader.float();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.dmgpos = CMsgVector.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.dmgdir = CMsgVector.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.dmgtype = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgTEPhysicsProp {
    return {
      origin: isSet(object.origin) ? CMsgVector.fromJSON(object.origin) : undefined,
      velocity: isSet(object.velocity) ? CMsgVector.fromJSON(object.velocity) : undefined,
      angles: isSet(object.angles) ? CMsgQAngle.fromJSON(object.angles) : undefined,
      skin: isSet(object.skin) ? globalThis.Number(object.skin) : 0,
      flags: isSet(object.flags) ? globalThis.Number(object.flags) : 0,
      effects: isSet(object.effects) ? globalThis.Number(object.effects) : 0,
      color: isSet(object.color) ? globalThis.Number(object.color) : 0,
      modelindex: isSet(object.modelindex) ? globalThis.String(object.modelindex) : "0",
      unusedBreakmodelsnottomake: isSet(object.unusedBreakmodelsnottomake)
        ? globalThis.Number(object.unusedBreakmodelsnottomake)
        : 0,
      scale: isSet(object.scale) ? globalThis.Number(object.scale) : 0,
      dmgpos: isSet(object.dmgpos) ? CMsgVector.fromJSON(object.dmgpos) : undefined,
      dmgdir: isSet(object.dmgdir) ? CMsgVector.fromJSON(object.dmgdir) : undefined,
      dmgtype: isSet(object.dmgtype) ? globalThis.Number(object.dmgtype) : 0,
    };
  },

  toJSON(message: CMsgTEPhysicsProp): unknown {
    const obj: any = {};
    if (message.origin !== undefined) {
      obj.origin = CMsgVector.toJSON(message.origin);
    }
    if (message.velocity !== undefined) {
      obj.velocity = CMsgVector.toJSON(message.velocity);
    }
    if (message.angles !== undefined) {
      obj.angles = CMsgQAngle.toJSON(message.angles);
    }
    if (message.skin !== undefined && message.skin !== 0) {
      obj.skin = Math.round(message.skin);
    }
    if (message.flags !== undefined && message.flags !== 0) {
      obj.flags = Math.round(message.flags);
    }
    if (message.effects !== undefined && message.effects !== 0) {
      obj.effects = Math.round(message.effects);
    }
    if (message.color !== undefined && message.color !== 0) {
      obj.color = Math.round(message.color);
    }
    if (message.modelindex !== undefined && message.modelindex !== "0") {
      obj.modelindex = message.modelindex;
    }
    if (message.unusedBreakmodelsnottomake !== undefined && message.unusedBreakmodelsnottomake !== 0) {
      obj.unusedBreakmodelsnottomake = Math.round(message.unusedBreakmodelsnottomake);
    }
    if (message.scale !== undefined && message.scale !== 0) {
      obj.scale = message.scale;
    }
    if (message.dmgpos !== undefined) {
      obj.dmgpos = CMsgVector.toJSON(message.dmgpos);
    }
    if (message.dmgdir !== undefined) {
      obj.dmgdir = CMsgVector.toJSON(message.dmgdir);
    }
    if (message.dmgtype !== undefined && message.dmgtype !== 0) {
      obj.dmgtype = Math.round(message.dmgtype);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgTEPhysicsProp>): CMsgTEPhysicsProp {
    return CMsgTEPhysicsProp.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgTEPhysicsProp>): CMsgTEPhysicsProp {
    const message = createBaseCMsgTEPhysicsProp();
    message.origin =
      object.origin !== undefined && object.origin !== null ? CMsgVector.fromPartial(object.origin) : undefined;
    message.velocity =
      object.velocity !== undefined && object.velocity !== null ? CMsgVector.fromPartial(object.velocity) : undefined;
    message.angles =
      object.angles !== undefined && object.angles !== null ? CMsgQAngle.fromPartial(object.angles) : undefined;
    message.skin = object.skin ?? 0;
    message.flags = object.flags ?? 0;
    message.effects = object.effects ?? 0;
    message.color = object.color ?? 0;
    message.modelindex = object.modelindex ?? "0";
    message.unusedBreakmodelsnottomake = object.unusedBreakmodelsnottomake ?? 0;
    message.scale = object.scale ?? 0;
    message.dmgpos =
      object.dmgpos !== undefined && object.dmgpos !== null ? CMsgVector.fromPartial(object.dmgpos) : undefined;
    message.dmgdir =
      object.dmgdir !== undefined && object.dmgdir !== null ? CMsgVector.fromPartial(object.dmgdir) : undefined;
    message.dmgtype = object.dmgtype ?? 0;
    return message;
  },
};

function createBaseCMsgTEPlayerDecal(): CMsgTEPlayerDecal {
  return { origin: undefined, player: -1, entity: -1 };
}

export const CMsgTEPlayerDecal = {
  encode(message: CMsgTEPlayerDecal, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.origin !== undefined) {
      CMsgVector.encode(message.origin, writer.uint32(10).fork()).ldelim();
    }
    if (message.player !== undefined && message.player !== -1) {
      writer.uint32(16).int32(message.player);
    }
    if (message.entity !== undefined && message.entity !== -1) {
      writer.uint32(24).int32(message.entity);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgTEPlayerDecal {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgTEPlayerDecal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.origin = CMsgVector.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.player = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.entity = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgTEPlayerDecal {
    return {
      origin: isSet(object.origin) ? CMsgVector.fromJSON(object.origin) : undefined,
      player: isSet(object.player) ? globalThis.Number(object.player) : -1,
      entity: isSet(object.entity) ? globalThis.Number(object.entity) : -1,
    };
  },

  toJSON(message: CMsgTEPlayerDecal): unknown {
    const obj: any = {};
    if (message.origin !== undefined) {
      obj.origin = CMsgVector.toJSON(message.origin);
    }
    if (message.player !== undefined && message.player !== -1) {
      obj.player = Math.round(message.player);
    }
    if (message.entity !== undefined && message.entity !== -1) {
      obj.entity = Math.round(message.entity);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgTEPlayerDecal>): CMsgTEPlayerDecal {
    return CMsgTEPlayerDecal.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgTEPlayerDecal>): CMsgTEPlayerDecal {
    const message = createBaseCMsgTEPlayerDecal();
    message.origin =
      object.origin !== undefined && object.origin !== null ? CMsgVector.fromPartial(object.origin) : undefined;
    message.player = object.player ?? -1;
    message.entity = object.entity ?? -1;
    return message;
  },
};

function createBaseCMsgTEProjectedDecal(): CMsgTEProjectedDecal {
  return { origin: undefined, angles: undefined, index: 0, distance: 0 };
}

export const CMsgTEProjectedDecal = {
  encode(message: CMsgTEProjectedDecal, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.origin !== undefined) {
      CMsgVector.encode(message.origin, writer.uint32(10).fork()).ldelim();
    }
    if (message.angles !== undefined) {
      CMsgQAngle.encode(message.angles, writer.uint32(18).fork()).ldelim();
    }
    if (message.index !== undefined && message.index !== 0) {
      writer.uint32(24).uint32(message.index);
    }
    if (message.distance !== undefined && message.distance !== 0) {
      writer.uint32(37).float(message.distance);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgTEProjectedDecal {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgTEProjectedDecal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.origin = CMsgVector.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.angles = CMsgQAngle.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.index = reader.uint32();
          continue;
        case 4:
          if (tag !== 37) {
            break;
          }

          message.distance = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgTEProjectedDecal {
    return {
      origin: isSet(object.origin) ? CMsgVector.fromJSON(object.origin) : undefined,
      angles: isSet(object.angles) ? CMsgQAngle.fromJSON(object.angles) : undefined,
      index: isSet(object.index) ? globalThis.Number(object.index) : 0,
      distance: isSet(object.distance) ? globalThis.Number(object.distance) : 0,
    };
  },

  toJSON(message: CMsgTEProjectedDecal): unknown {
    const obj: any = {};
    if (message.origin !== undefined) {
      obj.origin = CMsgVector.toJSON(message.origin);
    }
    if (message.angles !== undefined) {
      obj.angles = CMsgQAngle.toJSON(message.angles);
    }
    if (message.index !== undefined && message.index !== 0) {
      obj.index = Math.round(message.index);
    }
    if (message.distance !== undefined && message.distance !== 0) {
      obj.distance = message.distance;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgTEProjectedDecal>): CMsgTEProjectedDecal {
    return CMsgTEProjectedDecal.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgTEProjectedDecal>): CMsgTEProjectedDecal {
    const message = createBaseCMsgTEProjectedDecal();
    message.origin =
      object.origin !== undefined && object.origin !== null ? CMsgVector.fromPartial(object.origin) : undefined;
    message.angles =
      object.angles !== undefined && object.angles !== null ? CMsgQAngle.fromPartial(object.angles) : undefined;
    message.index = object.index ?? 0;
    message.distance = object.distance ?? 0;
    return message;
  },
};

function createBaseCMsgTESmoke(): CMsgTESmoke {
  return { origin: undefined, scale: 0 };
}

export const CMsgTESmoke = {
  encode(message: CMsgTESmoke, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.origin !== undefined) {
      CMsgVector.encode(message.origin, writer.uint32(10).fork()).ldelim();
    }
    if (message.scale !== undefined && message.scale !== 0) {
      writer.uint32(21).float(message.scale);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgTESmoke {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgTESmoke();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.origin = CMsgVector.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.scale = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgTESmoke {
    return {
      origin: isSet(object.origin) ? CMsgVector.fromJSON(object.origin) : undefined,
      scale: isSet(object.scale) ? globalThis.Number(object.scale) : 0,
    };
  },

  toJSON(message: CMsgTESmoke): unknown {
    const obj: any = {};
    if (message.origin !== undefined) {
      obj.origin = CMsgVector.toJSON(message.origin);
    }
    if (message.scale !== undefined && message.scale !== 0) {
      obj.scale = message.scale;
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgTESmoke>): CMsgTESmoke {
    return CMsgTESmoke.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgTESmoke>): CMsgTESmoke {
    const message = createBaseCMsgTESmoke();
    message.origin =
      object.origin !== undefined && object.origin !== null ? CMsgVector.fromPartial(object.origin) : undefined;
    message.scale = object.scale ?? 0;
    return message;
  },
};

function createBaseCMsgTEWorldDecal(): CMsgTEWorldDecal {
  return { origin: undefined, normal: undefined, index: 0 };
}

export const CMsgTEWorldDecal = {
  encode(message: CMsgTEWorldDecal, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.origin !== undefined) {
      CMsgVector.encode(message.origin, writer.uint32(10).fork()).ldelim();
    }
    if (message.normal !== undefined) {
      CMsgVector.encode(message.normal, writer.uint32(18).fork()).ldelim();
    }
    if (message.index !== undefined && message.index !== 0) {
      writer.uint32(24).uint32(message.index);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgTEWorldDecal {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgTEWorldDecal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.origin = CMsgVector.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.normal = CMsgVector.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.index = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CMsgTEWorldDecal {
    return {
      origin: isSet(object.origin) ? CMsgVector.fromJSON(object.origin) : undefined,
      normal: isSet(object.normal) ? CMsgVector.fromJSON(object.normal) : undefined,
      index: isSet(object.index) ? globalThis.Number(object.index) : 0,
    };
  },

  toJSON(message: CMsgTEWorldDecal): unknown {
    const obj: any = {};
    if (message.origin !== undefined) {
      obj.origin = CMsgVector.toJSON(message.origin);
    }
    if (message.normal !== undefined) {
      obj.normal = CMsgVector.toJSON(message.normal);
    }
    if (message.index !== undefined && message.index !== 0) {
      obj.index = Math.round(message.index);
    }
    return obj;
  },

  create(base?: DeepPartial<CMsgTEWorldDecal>): CMsgTEWorldDecal {
    return CMsgTEWorldDecal.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CMsgTEWorldDecal>): CMsgTEWorldDecal {
    const message = createBaseCMsgTEWorldDecal();
    message.origin =
      object.origin !== undefined && object.origin !== null ? CMsgVector.fromPartial(object.origin) : undefined;
    message.normal =
      object.normal !== undefined && object.normal !== null ? CMsgVector.fromPartial(object.normal) : undefined;
    message.index = object.index ?? 0;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin
  ? T
  : T extends globalThis.Array<infer U>
    ? globalThis.Array<DeepPartial<U>>
    : T extends ReadonlyArray<infer U>
      ? ReadonlyArray<DeepPartial<U>>
      : T extends {}
        ? { [K in keyof T]?: DeepPartial<T[K]> }
        : Partial<T>;

function longToString(long: Long) {
  return long.toString();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
